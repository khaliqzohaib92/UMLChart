/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/acorn/dist/acorn.mjs":
/*!*******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.mjs ***!
  \*******************************************/
/*! exports provided: Node, Parser, Position, SourceLocation, TokContext, Token, TokenType, defaultOptions, getLineInfo, isIdentifierChar, isIdentifierStart, isNewLine, keywordTypes, lineBreak, lineBreakG, nonASCIIwhitespace, parse, parseExpressionAt, tokContexts, tokTypes, tokenizer, version */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SourceLocation", function() { return SourceLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokContext", function() { return TokContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOptions", function() { return defaultOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineInfo", function() { return getLineInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierChar", function() { return isIdentifierChar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierStart", function() { return isIdentifierStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNewLine", function() { return isNewLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keywordTypes", function() { return keywords$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreak", function() { return lineBreak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreakG", function() { return lineBreakG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonASCIIwhitespace", function() { return nonASCIIwhitespace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseExpressionAt", function() { return parseExpressionAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokContexts", function() { return types$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokTypes", function() { return types; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenizer", function() { return tokenizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 9.
  ecmaVersion: 9,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
pp.strictDirective = function(start) {
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") { return true }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // '['
  if (context) { return false }

  if (nextCh === 123) { return true } // '{'
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (this.options.ecmaVersion > 10 && starttype === types._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40) // '('
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope, node) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (!this.eat(types.braceR)) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  } else if (init.type === "AssignmentPattern") {
    this.raise(init.start, "Invalid left-hand side in for-loop");
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      }
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  this.strict = oldStrict;
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassElement = function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
      key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    method.kind = "constructor";
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, "getter should have no params"); }
  if (method.kind === "set" && method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && method.value.params[0].type === "RestElement")
    { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, "MethodDefinition")
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
    this.expectContextual("from");
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseIdent(true);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    this.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types.comma); }
    if (allowEmpty && this.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (bindingType === BIND_LEXICAL && expr.name === "let")
      { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, "Argument name clash"); }
      checkClashes[expr.name] = true;
    }
    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    break

  case "MemberExpression":
    if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1)
      {
    var prop = list[i];

    this.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(noIn) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldShorthandAssign = refDestructuringErrors.shorthandAssign;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
    if (element === base || element.type === "ArrowFunctionExpression") { return element }
    base = element;
  }
};

pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
  if (computed || this.eat(types.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
    node.computed = !!computed;
    if (computed) { this.expect(types.bracketR); }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== "Import", false, refDestructuringErrors);
    if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (node$1.callee.type === "Import") {
      if (node$1.arguments.length !== 1) {
        this.raise(node$1.start, "import() requires exactly one argument");
      }

      var importArg = node$1.arguments[0];
      if (importArg && importArg.type === "SpreadElement") {
        this.raise(importArg.start, "... is not allowed in import()");
      }
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  case types._import:
    if (this.options.ecmaVersion > 10) {
      return this.parseDynamicImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
};

pp$3.parseDynamicImport = function() {
  var node = this.startNode();
  this.next();
  if (this.type !== types.parenL) {
    this.unexpected();
  }
  return this.finishNode(node, "Import")
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types.parenR) {
      first ? first = false : this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target" || containsEsc)
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
    if (!this.inNonArrowFunction())
      { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.options.ecmaVersion > 10 && node.callee.type === "Import") {
    this.raise(node.callee.start, "Cannot use new with import(...)");
  }
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== "Import", false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types.comma && this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();

  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types.comma)
      { elt = null; }
    else if (this.type === types.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$5.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$5.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$5.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$5.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$5.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$5.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$5.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues
};

var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
buildUnicodeData(9);
buildUnicodeData(10);
buildUnicodeData(11);

var pp$8 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i), next;
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current () {
  return this.at(this.pos)
};

RegExpValidationState.prototype.lookahead = function lookahead () {
  return this.at(this.nextIndex(this.pos))
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.current() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString(ch) {
  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$8.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$8.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$8.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$8.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$8.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$8.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$8.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$8.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
pp$8.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>
pp$8.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$8.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$8.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$8.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$8.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$8.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &&
      this.regexp_eatUnicodePropertyValueExpression(state) &&
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise("Invalid property value"); }
};
pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
    { state.raise("Invalid property name"); }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$8.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw "unterminated regular expression" error before.
    state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$8.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$8.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$8.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$8.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$8.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$8.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$9 = Parser.prototype;

// Move to the next token

pp$9.next = function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$9.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$9[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$9.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$9.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$9.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$9.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$9.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // '/'
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // '*'
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$9.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$9.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$9.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$9.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$9.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$9.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$9.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$9.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
};

pp$9.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$9.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$9.readInt = function(radix, len) {
  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);
    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

pp$9.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$9.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var str$1 = this.input.slice(start, this.pos);
    var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val$1)
  }
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$9.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString$1(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$9.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$9.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$9.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types.template, out)
    }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$9.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case "\\":
      ++this.pos;
      break

    case "$":
      if (this.input[this.pos + 1] !== "{") {
        break
      }
    // falls through

    case "`":
      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$9.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString$1(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$9.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$9.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString$1(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$9.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.

var version = "6.4.0";

Parser.acorn = {
  Parser: Parser,
  version: version,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types,
  keywordTypes: keywords$1,
  TokContext: TokContext,
  tokContexts: types$1,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  Token: Token,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
};

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return Parser.parse(input, options)
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}




/***/ }),

/***/ "./node_modules/paper/dist/paper-full.js":
/*!***********************************************!*\
  !*** ./node_modules/paper/dist/paper-full.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Paper.js v0.12.11 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jürg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Fri Jun 19 19:14:33 2020 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jürg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */
var paper = function (self, undefined) {
  self = self || __webpack_require__(/*! ./node/self.js */ 0);
  var window = self.window,
      document = self.document;
  var Base = new function () {
    var hidden = /^(statics|enumerable|beans|preserve)$/,
        array = [],
        slice = array.slice,
        create = Object.create,
        describe = Object.getOwnPropertyDescriptor,
        define = Object.defineProperty,
        forEach = array.forEach || function (iter, bind) {
      for (var i = 0, l = this.length; i < l; i++) {
        iter.call(bind, this[i], i, this);
      }
    },
        forIn = function (iter, bind) {
      for (var i in this) {
        if (this.hasOwnProperty(i)) iter.call(bind, this[i], i, this);
      }
    },
        set = Object.assign || function (dst) {
      for (var i = 1, l = arguments.length; i < l; i++) {
        var src = arguments[i];

        for (var key in src) {
          if (src.hasOwnProperty(key)) dst[key] = src[key];
        }
      }

      return dst;
    },
        each = function (obj, iter, bind) {
      if (obj) {
        var desc = describe(obj, 'length');
        (desc && typeof desc.value === 'number' ? forEach : forIn).call(obj, iter, bind = bind || obj);
      }

      return bind;
    };

    function inject(dest, src, enumerable, beans, preserve) {
      var beansNames = {};

      function field(name, val) {
        val = val || (val = describe(src, name)) && (val.get ? val : val.value);
        if (typeof val === 'string' && val[0] === '#') val = dest[val.substring(1)] || val;
        var isFunc = typeof val === 'function',
            res = val,
            prev = preserve || isFunc && !val.base ? val && val.get ? name in dest : dest[name] : null,
            bean;

        if (!preserve || !prev) {
          if (isFunc && prev) val.base = prev;
          if (isFunc && beans !== false && (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/))) beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];

          if (!res || isFunc || !res.get || typeof res.get !== 'function' || !Base.isPlainObject(res)) {
            res = {
              value: res,
              writable: true
            };
          }

          if ((describe(dest, name) || {
            configurable: true
          }).configurable) {
            res.configurable = true;
            res.enumerable = enumerable != null ? enumerable : !bean;
          }

          define(dest, name, res);
        }
      }

      if (src) {
        for (var name in src) {
          if (src.hasOwnProperty(name) && !hidden.test(name)) field(name);
        }

        for (var name in beansNames) {
          var part = beansNames[name],
              set = dest['set' + part],
              get = dest['get' + part] || set && dest['is' + part];
          if (get && (beans === true || get.length === 0)) field(name, {
            get: get,
            set: set
          });
        }
      }

      return dest;
    }

    function Base() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        var src = arguments[i];
        if (src) set(this, src);
      }

      return this;
    }

    return inject(Base, {
      inject: function (src) {
        if (src) {
          var statics = src.statics === true ? src : src.statics,
              beans = src.beans,
              preserve = src.preserve;
          if (statics !== src) inject(this.prototype, src, src.enumerable, beans, preserve);
          inject(this, statics, null, beans, preserve);
        }

        for (var i = 1, l = arguments.length; i < l; i++) this.inject(arguments[i]);

        return this;
      },
      extend: function () {
        var base = this,
            ctor,
            proto;

        for (var i = 0, obj, l = arguments.length; i < l && !(ctor && proto); i++) {
          obj = arguments[i];
          ctor = ctor || obj.initialize;
          proto = proto || obj.prototype;
        }

        ctor = ctor || function () {
          base.apply(this, arguments);
        };

        proto = ctor.prototype = proto || create(this.prototype);
        define(proto, 'constructor', {
          value: ctor,
          writable: true,
          configurable: true
        });
        inject(ctor, this);
        if (arguments.length) this.inject.apply(ctor, arguments);
        ctor.base = base;
        return ctor;
      }
    }).inject({
      enumerable: false,
      initialize: Base,
      set: Base,
      inject: function () {
        for (var i = 0, l = arguments.length; i < l; i++) {
          var src = arguments[i];

          if (src) {
            inject(this, src, src.enumerable, src.beans, src.preserve);
          }
        }

        return this;
      },
      extend: function () {
        var res = create(this);
        return res.inject.apply(res, arguments);
      },
      each: function (iter, bind) {
        return each(this, iter, bind);
      },
      clone: function () {
        return new this.constructor(this);
      },
      statics: {
        set: set,
        each: each,
        create: create,
        define: define,
        describe: describe,
        clone: function (obj) {
          return set(new obj.constructor(), obj);
        },
        isPlainObject: function (obj) {
          var ctor = obj != null && obj.constructor;
          return ctor && (ctor === Object || ctor === Base || ctor.name === 'Object');
        },
        pick: function (a, b) {
          return a !== undefined ? a : b;
        },
        slice: function (list, begin, end) {
          return slice.call(list, begin, end);
        }
      }
    });
  }();
  if (true) module.exports = Base;
  Base.inject({
    enumerable: false,
    toString: function () {
      return this._id != null ? (this._class || 'Object') + (this._name ? " '" + this._name + "'" : ' @' + this._id) : '{ ' + Base.each(this, function (value, key) {
        if (!/^_/.test(key)) {
          var type = typeof value;
          this.push(key + ': ' + (type === 'number' ? Formatter.instance.number(value) : type === 'string' ? "'" + value + "'" : value));
        }
      }, []).join(', ') + ' }';
    },
    getClassName: function () {
      return this._class || '';
    },
    importJSON: function (json) {
      return Base.importJSON(json, this);
    },
    exportJSON: function (options) {
      return Base.exportJSON(this, options);
    },
    toJSON: function () {
      return Base.serialize(this);
    },
    set: function (props, exclude) {
      if (props) Base.filter(this, props, exclude, this._prioritize);
      return this;
    }
  }, {
    beans: false,
    statics: {
      exports: {},
      extend: function extend() {
        var res = extend.base.apply(this, arguments),
            name = res.prototype._class;
        if (name && !Base.exports[name]) Base.exports[name] = res;
        return res;
      },
      equals: function (obj1, obj2) {
        if (obj1 === obj2) return true;
        if (obj1 && obj1.equals) return obj1.equals(obj2);
        if (obj2 && obj2.equals) return obj2.equals(obj1);

        if (obj1 && obj2 && typeof obj1 === 'object' && typeof obj2 === 'object') {
          if (Array.isArray(obj1) && Array.isArray(obj2)) {
            var length = obj1.length;
            if (length !== obj2.length) return false;

            while (length--) {
              if (!Base.equals(obj1[length], obj2[length])) return false;
            }
          } else {
            var keys = Object.keys(obj1),
                length = keys.length;
            if (length !== Object.keys(obj2).length) return false;

            while (length--) {
              var key = keys[length];
              if (!(obj2.hasOwnProperty(key) && Base.equals(obj1[key], obj2[key]))) return false;
            }
          }

          return true;
        }

        return false;
      },
      read: function (list, start, options, amount) {
        if (this === Base) {
          var value = this.peek(list, start);
          list.__index++;
          return value;
        }

        var proto = this.prototype,
            readIndex = proto._readIndex,
            begin = start || readIndex && list.__index || 0,
            length = list.length,
            obj = list[begin];
        amount = amount || length - begin;

        if (obj instanceof this || options && options.readNull && obj == null && amount <= 1) {
          if (readIndex) list.__index = begin + 1;
          return obj && options && options.clone ? obj.clone() : obj;
        }

        obj = Base.create(proto);
        if (readIndex) obj.__read = true;
        obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length ? Base.slice(list, begin, begin + amount) : list) || obj;

        if (readIndex) {
          list.__index = begin + obj.__read;
          var filtered = obj.__filtered;

          if (filtered) {
            list.__filtered = filtered;
            obj.__filtered = undefined;
          }

          obj.__read = undefined;
        }

        return obj;
      },
      peek: function (list, start) {
        return list[list.__index = start || list.__index || 0];
      },
      remain: function (list) {
        return list.length - (list.__index || 0);
      },
      readList: function (list, start, options, amount) {
        var res = [],
            entry,
            begin = start || 0,
            end = amount ? begin + amount : list.length;

        for (var i = begin; i < end; i++) {
          res.push(Array.isArray(entry = list[i]) ? this.read(entry, 0, options) : this.read(list, i, options, 1));
        }

        return res;
      },
      readNamed: function (list, name, start, options, amount) {
        var value = this.getNamed(list, name),
            hasValue = value !== undefined;

        if (hasValue) {
          var filtered = list.__filtered;

          if (!filtered) {
            var source = this.getSource(list);
            filtered = list.__filtered = Base.create(source);
            filtered.__unfiltered = source;
          }

          filtered[name] = undefined;
        }

        return this.read(hasValue ? [value] : list, start, options, amount);
      },
      readSupported: function (list, dest) {
        var source = this.getSource(list),
            that = this,
            read = false;

        if (source) {
          Object.keys(source).forEach(function (key) {
            if (key in dest) {
              var value = that.readNamed(list, key);

              if (value !== undefined) {
                dest[key] = value;
              }

              read = true;
            }
          });
        }

        return read;
      },
      getSource: function (list) {
        var source = list.__source;

        if (source === undefined) {
          var arg = list.length === 1 && list[0];
          source = list.__source = arg && Base.isPlainObject(arg) ? arg : null;
        }

        return source;
      },
      getNamed: function (list, name) {
        var source = this.getSource(list);

        if (source) {
          return name ? source[name] : list.__filtered || source;
        }
      },
      hasNamed: function (list, name) {
        return !!this.getNamed(list, name);
      },
      filter: function (dest, source, exclude, prioritize) {
        var processed;

        function handleKey(key) {
          if (!(exclude && key in exclude) && !(processed && key in processed)) {
            var value = source[key];
            if (value !== undefined) dest[key] = value;
          }
        }

        if (prioritize) {
          var keys = {};

          for (var i = 0, key, l = prioritize.length; i < l; i++) {
            if ((key = prioritize[i]) in source) {
              handleKey(key);
              keys[key] = true;
            }
          }

          processed = keys;
        }

        Object.keys(source.__unfiltered || source).forEach(handleKey);
        return dest;
      },
      isPlainValue: function (obj, asString) {
        return Base.isPlainObject(obj) || Array.isArray(obj) || asString && typeof obj === 'string';
      },
      serialize: function (obj, options, compact, dictionary) {
        options = options || {};
        var isRoot = !dictionary,
            res;

        if (isRoot) {
          options.formatter = new Formatter(options.precision);
          dictionary = {
            length: 0,
            definitions: {},
            references: {},
            add: function (item, create) {
              var id = '#' + item._id,
                  ref = this.references[id];

              if (!ref) {
                this.length++;
                var res = create.call(item),
                    name = item._class;
                if (name && res[0] !== name) res.unshift(name);
                this.definitions[id] = res;
                ref = this.references[id] = [id];
              }

              return ref;
            }
          };
        }

        if (obj && obj._serialize) {
          res = obj._serialize(options, dictionary);
          var name = obj._class;

          if (name && !obj._compactSerialize && (isRoot || !compact) && res[0] !== name) {
            res.unshift(name);
          }
        } else if (Array.isArray(obj)) {
          res = [];

          for (var i = 0, l = obj.length; i < l; i++) res[i] = Base.serialize(obj[i], options, compact, dictionary);
        } else if (Base.isPlainObject(obj)) {
          res = {};
          var keys = Object.keys(obj);

          for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            res[key] = Base.serialize(obj[key], options, compact, dictionary);
          }
        } else if (typeof obj === 'number') {
          res = options.formatter.number(obj, options.precision);
        } else {
          res = obj;
        }

        return isRoot && dictionary.length > 0 ? [['dictionary', dictionary.definitions], res] : res;
      },
      deserialize: function (json, create, _data, _setDictionary, _isRoot) {
        var res = json,
            isFirst = !_data,
            hasDictionary = isFirst && json && json.length && json[0][0] === 'dictionary';
        _data = _data || {};

        if (Array.isArray(json)) {
          var type = json[0],
              isDictionary = type === 'dictionary';

          if (json.length == 1 && /^#/.test(type)) {
            return _data.dictionary[type];
          }

          type = Base.exports[type];
          res = [];

          for (var i = type ? 1 : 0, l = json.length; i < l; i++) {
            res.push(Base.deserialize(json[i], create, _data, isDictionary, hasDictionary));
          }

          if (type) {
            var args = res;

            if (create) {
              res = create(type, args, isFirst || _isRoot);
            } else {
              res = new type(args);
            }
          }
        } else if (Base.isPlainObject(json)) {
          res = {};
          if (_setDictionary) _data.dictionary = res;

          for (var key in json) res[key] = Base.deserialize(json[key], create, _data);
        }

        return hasDictionary ? res[1] : res;
      },
      exportJSON: function (obj, options) {
        var json = Base.serialize(obj, options);
        return options && options.asString == false ? json : JSON.stringify(json);
      },
      importJSON: function (json, target) {
        return Base.deserialize(typeof json === 'string' ? JSON.parse(json) : json, function (ctor, args, isRoot) {
          var useTarget = isRoot && target && target.constructor === ctor,
              obj = useTarget ? target : Base.create(ctor.prototype);

          if (args.length === 1 && obj instanceof Item && (useTarget || !(obj instanceof Layer))) {
            var arg = args[0];

            if (Base.isPlainObject(arg)) {
              arg.insert = false;

              if (useTarget) {
                args = args.concat([{
                  insert: true
                }]);
              }
            }
          }

          (useTarget ? obj.set : ctor).apply(obj, args);
          if (useTarget) target = null;
          return obj;
        });
      },
      push: function (list, items) {
        var itemsLength = items.length;

        if (itemsLength < 4096) {
          list.push.apply(list, items);
        } else {
          var startLength = list.length;
          list.length += itemsLength;

          for (var i = 0; i < itemsLength; i++) {
            list[startLength + i] = items[i];
          }
        }

        return list;
      },
      splice: function (list, items, index, remove) {
        var amount = items && items.length,
            append = index === undefined;
        index = append ? list.length : index;
        if (index > list.length) index = list.length;

        for (var i = 0; i < amount; i++) items[i]._index = index + i;

        if (append) {
          Base.push(list, items);
          return [];
        } else {
          var args = [index, remove];
          if (items) Base.push(args, items);
          var removed = list.splice.apply(list, args);

          for (var i = 0, l = removed.length; i < l; i++) removed[i]._index = undefined;

          for (var i = index + amount, l = list.length; i < l; i++) list[i]._index = i;

          return removed;
        }
      },
      capitalize: function (str) {
        return str.replace(/\b[a-z]/g, function (match) {
          return match.toUpperCase();
        });
      },
      camelize: function (str) {
        return str.replace(/-(.)/g, function (match, chr) {
          return chr.toUpperCase();
        });
      },
      hyphenate: function (str) {
        return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
      }
    }
  });
  var Emitter = {
    on: function (type, func) {
      if (typeof type !== 'string') {
        Base.each(type, function (value, key) {
          this.on(key, value);
        }, this);
      } else {
        var types = this._eventTypes,
            entry = types && types[type],
            handlers = this._callbacks = this._callbacks || {};
        handlers = handlers[type] = handlers[type] || [];

        if (handlers.indexOf(func) === -1) {
          handlers.push(func);
          if (entry && entry.install && handlers.length === 1) entry.install.call(this, type);
        }
      }

      return this;
    },
    off: function (type, func) {
      if (typeof type !== 'string') {
        Base.each(type, function (value, key) {
          this.off(key, value);
        }, this);
        return;
      }

      var types = this._eventTypes,
          entry = types && types[type],
          handlers = this._callbacks && this._callbacks[type],
          index;

      if (handlers) {
        if (!func || (index = handlers.indexOf(func)) !== -1 && handlers.length === 1) {
          if (entry && entry.uninstall) entry.uninstall.call(this, type);
          delete this._callbacks[type];
        } else if (index !== -1) {
          handlers.splice(index, 1);
        }
      }

      return this;
    },
    once: function (type, func) {
      return this.on(type, function handler() {
        func.apply(this, arguments);
        this.off(type, handler);
      });
    },
    emit: function (type, event) {
      var handlers = this._callbacks && this._callbacks[type];
      if (!handlers) return false;
      var args = Base.slice(arguments, 1),
          setTarget = event && event.target && !event.currentTarget;
      handlers = handlers.slice();
      if (setTarget) event.currentTarget = this;

      for (var i = 0, l = handlers.length; i < l; i++) {
        if (handlers[i].apply(this, args) == false) {
          if (event && event.stop) event.stop();
          break;
        }
      }

      if (setTarget) delete event.currentTarget;
      return true;
    },
    responds: function (type) {
      return !!(this._callbacks && this._callbacks[type]);
    },
    attach: '#on',
    detach: '#off',
    fire: '#emit',
    _installEvents: function (install) {
      var types = this._eventTypes,
          handlers = this._callbacks,
          key = install ? 'install' : 'uninstall';

      if (types) {
        for (var type in handlers) {
          if (handlers[type].length > 0) {
            var entry = types[type],
                func = entry && entry[key];
            if (func) func.call(this, type);
          }
        }
      }
    },
    statics: {
      inject: function inject(src) {
        var events = src._events;

        if (events) {
          var types = {};
          Base.each(events, function (entry, key) {
            var isString = typeof entry === 'string',
                name = isString ? entry : key,
                part = Base.capitalize(name),
                type = name.substring(2).toLowerCase();
            types[type] = isString ? {} : entry;
            name = '_' + name;

            src['get' + part] = function () {
              return this[name];
            };

            src['set' + part] = function (func) {
              var prev = this[name];
              if (prev) this.off(type, prev);
              if (func) this.on(type, func);
              this[name] = func;
            };
          });
          src._eventTypes = types;
        }

        return inject.base.apply(this, arguments);
      }
    }
  };
  var PaperScope = Base.extend({
    _class: 'PaperScope',
    initialize: function PaperScope() {
      paper = this;
      this.settings = new Base({
        applyMatrix: true,
        insertItems: true,
        handleSize: 4,
        hitTolerance: 0
      });
      this.project = null;
      this.projects = [];
      this.tools = [];
      this._id = PaperScope._id++;
      PaperScope._scopes[this._id] = this;
      var proto = PaperScope.prototype;

      if (!this.support) {
        var ctx = CanvasProvider.getContext(1, 1) || {};
        proto.support = {
          nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
          nativeBlendModes: BlendMode.nativeModes
        };
        CanvasProvider.release(ctx);
      }

      if (!this.agent) {
        var user = self.navigator.userAgent.toLowerCase(),
            os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user) || [])[0],
            platform = os === 'darwin' ? 'mac' : os,
            agent = proto.agent = proto.browser = {
          platform: platform
        };
        if (platform) agent[platform] = true;
        user.replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g, function (match, n, v1, v2, rv) {
          if (!agent.chrome) {
            var v = n === 'opera' ? v2 : /^(node|trident)$/.test(n) ? rv : v1;
            agent.version = v;
            agent.versionNumber = parseFloat(v);
            n = {
              trident: 'msie',
              jsdom: 'node'
            }[n] || n;
            agent.name = n;
            agent[n] = true;
          }
        });
        if (agent.chrome) delete agent.webkit;
        if (agent.atom) delete agent.chrome;
      }
    },
    version: "0.12.11",
    getView: function () {
      var project = this.project;
      return project && project._view;
    },
    getPaper: function () {
      return this;
    },
    execute: function (code, options) {
      var exports = paper.PaperScript.execute(code, this, options);
      View.updateFocus();
      return exports;
    },
    install: function (scope) {
      var that = this;
      Base.each(['project', 'view', 'tool'], function (key) {
        Base.define(scope, key, {
          configurable: true,
          get: function () {
            return that[key];
          }
        });
      });

      for (var key in this) if (!/^_/.test(key) && this[key]) scope[key] = this[key];
    },
    setup: function (element) {
      paper = this;
      this.project = new Project(element);
      return this;
    },
    createCanvas: function (width, height) {
      return CanvasProvider.getCanvas(width, height);
    },
    activate: function () {
      paper = this;
    },
    clear: function () {
      var projects = this.projects,
          tools = this.tools;

      for (var i = projects.length - 1; i >= 0; i--) projects[i].remove();

      for (var i = tools.length - 1; i >= 0; i--) tools[i].remove();
    },
    remove: function () {
      this.clear();
      delete PaperScope._scopes[this._id];
    },
    statics: new function () {
      function handleAttribute(name) {
        name += 'Attribute';
        return function (el, attr) {
          return el[name](attr) || el[name]('data-paper-' + attr);
        };
      }

      return {
        _scopes: {},
        _id: 0,
        get: function (id) {
          return this._scopes[id] || null;
        },
        getAttribute: handleAttribute('get'),
        hasAttribute: handleAttribute('has')
      };
    }()
  });
  var PaperScopeItem = Base.extend(Emitter, {
    initialize: function (activate) {
      this._scope = paper;
      this._index = this._scope[this._list].push(this) - 1;
      if (activate || !this._scope[this._reference]) this.activate();
    },
    activate: function () {
      if (!this._scope) return false;
      var prev = this._scope[this._reference];
      if (prev && prev !== this) prev.emit('deactivate');
      this._scope[this._reference] = this;
      this.emit('activate', prev);
      return true;
    },
    isActive: function () {
      return this._scope[this._reference] === this;
    },
    remove: function () {
      if (this._index == null) return false;
      Base.splice(this._scope[this._list], null, this._index, 1);
      if (this._scope[this._reference] == this) this._scope[this._reference] = null;
      this._scope = null;
      return true;
    },
    getView: function () {
      return this._scope.getView();
    }
  });
  var CollisionDetection = {
    findItemBoundsCollisions: function (items1, items2, tolerance) {
      function getBounds(items) {
        var bounds = new Array(items.length);

        for (var i = 0; i < items.length; i++) {
          var rect = items[i].getBounds();
          bounds[i] = [rect.left, rect.top, rect.right, rect.bottom];
        }

        return bounds;
      }

      var bounds1 = getBounds(items1),
          bounds2 = !items2 || items2 === items1 ? bounds1 : getBounds(items2);
      return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
    },
    findCurveBoundsCollisions: function (curves1, curves2, tolerance, bothAxis) {
      function getBounds(curves) {
        var min = Math.min,
            max = Math.max,
            bounds = new Array(curves.length);

        for (var i = 0; i < curves.length; i++) {
          var v = curves[i];
          bounds[i] = [min(v[0], v[2], v[4], v[6]), min(v[1], v[3], v[5], v[7]), max(v[0], v[2], v[4], v[6]), max(v[1], v[3], v[5], v[7])];
        }

        return bounds;
      }

      var bounds1 = getBounds(curves1),
          bounds2 = !curves2 || curves2 === curves1 ? bounds1 : getBounds(curves2);

      if (bothAxis) {
        var hor = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, false, true),
            ver = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, true, true),
            list = [];

        for (var i = 0, l = hor.length; i < l; i++) {
          list[i] = {
            hor: hor[i],
            ver: ver[i]
          };
        }

        return list;
      }

      return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
    },
    findBoundsCollisions: function (boundsA, boundsB, tolerance, sweepVertical, onlySweepAxisCollisions) {
      var self = !boundsB || boundsA === boundsB,
          allBounds = self ? boundsA : boundsA.concat(boundsB),
          lengthA = boundsA.length,
          lengthAll = allBounds.length;

      function binarySearch(indices, coord, value) {
        var lo = 0,
            hi = indices.length;

        while (lo < hi) {
          var mid = hi + lo >>> 1;

          if (allBounds[indices[mid]][coord] < value) {
            lo = mid + 1;
          } else {
            hi = mid;
          }
        }

        return lo - 1;
      }

      var pri0 = sweepVertical ? 1 : 0,
          pri1 = pri0 + 2,
          sec0 = sweepVertical ? 0 : 1,
          sec1 = sec0 + 2;
      var allIndicesByPri0 = new Array(lengthAll);

      for (var i = 0; i < lengthAll; i++) {
        allIndicesByPri0[i] = i;
      }

      allIndicesByPri0.sort(function (i1, i2) {
        return allBounds[i1][pri0] - allBounds[i2][pri0];
      });
      var activeIndicesByPri1 = [],
          allCollisions = new Array(lengthA);

      for (var i = 0; i < lengthAll; i++) {
        var curIndex = allIndicesByPri0[i],
            curBounds = allBounds[curIndex],
            origIndex = self ? curIndex : curIndex - lengthA,
            isCurrentA = curIndex < lengthA,
            isCurrentB = self || !isCurrentA,
            curCollisions = isCurrentA ? [] : null;

        if (activeIndicesByPri1.length) {
          var pruneCount = binarySearch(activeIndicesByPri1, pri1, curBounds[pri0] - tolerance) + 1;
          activeIndicesByPri1.splice(0, pruneCount);

          if (self && onlySweepAxisCollisions) {
            curCollisions = curCollisions.concat(activeIndicesByPri1);

            for (var j = 0; j < activeIndicesByPri1.length; j++) {
              var activeIndex = activeIndicesByPri1[j];
              allCollisions[activeIndex].push(origIndex);
            }
          } else {
            var curSec1 = curBounds[sec1],
                curSec0 = curBounds[sec0];

            for (var j = 0; j < activeIndicesByPri1.length; j++) {
              var activeIndex = activeIndicesByPri1[j],
                  activeBounds = allBounds[activeIndex],
                  isActiveA = activeIndex < lengthA,
                  isActiveB = self || activeIndex >= lengthA;

              if (onlySweepAxisCollisions || (isCurrentA && isActiveB || isCurrentB && isActiveA) && curSec1 >= activeBounds[sec0] - tolerance && curSec0 <= activeBounds[sec1] + tolerance) {
                if (isCurrentA && isActiveB) {
                  curCollisions.push(self ? activeIndex : activeIndex - lengthA);
                }

                if (isCurrentB && isActiveA) {
                  allCollisions[activeIndex].push(origIndex);
                }
              }
            }
          }
        }

        if (isCurrentA) {
          if (boundsA === boundsB) {
            curCollisions.push(curIndex);
          }

          allCollisions[curIndex] = curCollisions;
        }

        if (activeIndicesByPri1.length) {
          var curPri1 = curBounds[pri1],
              index = binarySearch(activeIndicesByPri1, pri1, curPri1);
          activeIndicesByPri1.splice(index + 1, 0, curIndex);
        } else {
          activeIndicesByPri1.push(curIndex);
        }
      }

      for (var i = 0; i < allCollisions.length; i++) {
        var collisions = allCollisions[i];

        if (collisions) {
          collisions.sort(function (i1, i2) {
            return i1 - i2;
          });
        }
      }

      return allCollisions;
    }
  };
  var Formatter = Base.extend({
    initialize: function (precision) {
      this.precision = Base.pick(precision, 5);
      this.multiplier = Math.pow(10, this.precision);
    },
    number: function (val) {
      return this.precision < 16 ? Math.round(val * this.multiplier) / this.multiplier : val;
    },
    pair: function (val1, val2, separator) {
      return this.number(val1) + (separator || ',') + this.number(val2);
    },
    point: function (val, separator) {
      return this.number(val.x) + (separator || ',') + this.number(val.y);
    },
    size: function (val, separator) {
      return this.number(val.width) + (separator || ',') + this.number(val.height);
    },
    rectangle: function (val, separator) {
      return this.point(val, separator) + (separator || ',') + this.size(val, separator);
    }
  });
  Formatter.instance = new Formatter();
  var Numerical = new function () {
    var abscissas = [[0.5773502691896257645091488], [0, 0.7745966692414833770358531], [0.3399810435848562648026658, 0.8611363115940525752239465], [0, 0.5384693101056830910363144, 0.9061798459386639927976269], [0.2386191860831969086305017, 0.6612093864662645136613996, 0.9324695142031520278123016], [0, 0.4058451513773971669066064, 0.7415311855993944398638648, 0.9491079123427585245261897], [0.1834346424956498049394761, 0.5255324099163289858177390, 0.7966664774136267395915539, 0.9602898564975362316835609], [0, 0.3242534234038089290385380, 0.6133714327005903973087020, 0.8360311073266357942994298, 0.9681602395076260898355762], [0.1488743389816312108848260, 0.4333953941292471907992659, 0.6794095682990244062343274, 0.8650633666889845107320967, 0.9739065285171717200779640], [0, 0.2695431559523449723315320, 0.5190961292068118159257257, 0.7301520055740493240934163, 0.8870625997680952990751578, 0.9782286581460569928039380], [0.1252334085114689154724414, 0.3678314989981801937526915, 0.5873179542866174472967024, 0.7699026741943046870368938, 0.9041172563704748566784659, 0.9815606342467192506905491], [0, 0.2304583159551347940655281, 0.4484927510364468528779129, 0.6423493394403402206439846, 0.8015780907333099127942065, 0.9175983992229779652065478, 0.9841830547185881494728294], [0.1080549487073436620662447, 0.3191123689278897604356718, 0.5152486363581540919652907, 0.6872929048116854701480198, 0.8272013150697649931897947, 0.9284348836635735173363911, 0.9862838086968123388415973], [0, 0.2011940939974345223006283, 0.3941513470775633698972074, 0.5709721726085388475372267, 0.7244177313601700474161861, 0.8482065834104272162006483, 0.9372733924007059043077589, 0.9879925180204854284895657], [0.0950125098376374401853193, 0.2816035507792589132304605, 0.4580167776572273863424194, 0.6178762444026437484466718, 0.7554044083550030338951012, 0.8656312023878317438804679, 0.9445750230732325760779884, 0.9894009349916499325961542]];
    var weights = [[1], [0.8888888888888888888888889, 0.5555555555555555555555556], [0.6521451548625461426269361, 0.3478548451374538573730639], [0.5688888888888888888888889, 0.4786286704993664680412915, 0.2369268850561890875142640], [0.4679139345726910473898703, 0.3607615730481386075698335, 0.1713244923791703450402961], [0.4179591836734693877551020, 0.3818300505051189449503698, 0.2797053914892766679014678, 0.1294849661688696932706114], [0.3626837833783619829651504, 0.3137066458778872873379622, 0.2223810344533744705443560, 0.1012285362903762591525314], [0.3302393550012597631645251, 0.3123470770400028400686304, 0.2606106964029354623187429, 0.1806481606948574040584720, 0.0812743883615744119718922], [0.2955242247147528701738930, 0.2692667193099963550912269, 0.2190863625159820439955349, 0.1494513491505805931457763, 0.0666713443086881375935688], [0.2729250867779006307144835, 0.2628045445102466621806889, 0.2331937645919904799185237, 0.1862902109277342514260976, 0.1255803694649046246346943, 0.0556685671161736664827537], [0.2491470458134027850005624, 0.2334925365383548087608499, 0.2031674267230659217490645, 0.1600783285433462263346525, 0.1069393259953184309602547, 0.0471753363865118271946160], [0.2325515532308739101945895, 0.2262831802628972384120902, 0.2078160475368885023125232, 0.1781459807619457382800467, 0.1388735102197872384636018, 0.0921214998377284479144218, 0.0404840047653158795200216], [0.2152638534631577901958764, 0.2051984637212956039659241, 0.1855383974779378137417166, 0.1572031671581935345696019, 0.1215185706879031846894148, 0.0801580871597602098056333, 0.0351194603317518630318329], [0.2025782419255612728806202, 0.1984314853271115764561183, 0.1861610000155622110268006, 0.1662692058169939335532009, 0.1395706779261543144478048, 0.1071592204671719350118695, 0.0703660474881081247092674, 0.0307532419961172683546284], [0.1894506104550684962853967, 0.1826034150449235888667637, 0.1691565193950025381893121, 0.1495959888165767320815017, 0.1246289712555338720524763, 0.0951585116824927848099251, 0.0622535239386478928628438, 0.0271524594117540948517806]];

    var abs = Math.abs,
        sqrt = Math.sqrt,
        pow = Math.pow,
        log2 = Math.log2 || function (x) {
      return Math.log(x) * Math.LOG2E;
    },
        EPSILON = 1e-12,
        MACHINE_EPSILON = 1.12e-16;

    function clamp(value, min, max) {
      return value < min ? min : value > max ? max : value;
    }

    function getDiscriminant(a, b, c) {
      function split(v) {
        var x = v * 134217729,
            y = v - x,
            hi = y + x,
            lo = v - hi;
        return [hi, lo];
      }

      var D = b * b - a * c,
          E = b * b + a * c;

      if (abs(D) * 3 < E) {
        var ad = split(a),
            bd = split(b),
            cd = split(c),
            p = b * b,
            dp = bd[0] * bd[0] - p + 2 * bd[0] * bd[1] + bd[1] * bd[1],
            q = a * c,
            dq = ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0] + ad[1] * cd[1];
        D = p - q + (dp - dq);
      }

      return D;
    }

    function getNormalizationFactor() {
      var norm = Math.max.apply(Math, arguments);
      return norm && (norm < 1e-8 || norm > 1e8) ? pow(2, -Math.round(log2(norm))) : 0;
    }

    return {
      EPSILON: EPSILON,
      MACHINE_EPSILON: MACHINE_EPSILON,
      CURVETIME_EPSILON: 1e-8,
      GEOMETRIC_EPSILON: 1e-7,
      TRIGONOMETRIC_EPSILON: 1e-8,
      KAPPA: 4 * (sqrt(2) - 1) / 3,
      isZero: function (val) {
        return val >= -EPSILON && val <= EPSILON;
      },
      isMachineZero: function (val) {
        return val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;
      },
      clamp: clamp,
      integrate: function (f, a, b, n) {
        var x = abscissas[n - 2],
            w = weights[n - 2],
            A = (b - a) * 0.5,
            B = A + a,
            i = 0,
            m = n + 1 >> 1,
            sum = n & 1 ? w[i++] * f(B) : 0;

        while (i < m) {
          var Ax = A * x[i];
          sum += w[i++] * (f(B + Ax) + f(B - Ax));
        }

        return A * sum;
      },
      findRoot: function (f, df, x, a, b, n, tolerance) {
        for (var i = 0; i < n; i++) {
          var fx = f(x),
              dx = fx / df(x),
              nx = x - dx;

          if (abs(dx) < tolerance) {
            x = nx;
            break;
          }

          if (fx > 0) {
            b = x;
            x = nx <= a ? (a + b) * 0.5 : nx;
          } else {
            a = x;
            x = nx >= b ? (a + b) * 0.5 : nx;
          }
        }

        return clamp(x, a, b);
      },
      solveQuadratic: function (a, b, c, roots, min, max) {
        var x1,
            x2 = Infinity;

        if (abs(a) < EPSILON) {
          if (abs(b) < EPSILON) return abs(c) < EPSILON ? -1 : 0;
          x1 = -c / b;
        } else {
          b *= -0.5;
          var D = getDiscriminant(a, b, c);

          if (D && abs(D) < MACHINE_EPSILON) {
            var f = getNormalizationFactor(abs(a), abs(b), abs(c));

            if (f) {
              a *= f;
              b *= f;
              c *= f;
              D = getDiscriminant(a, b, c);
            }
          }

          if (D >= -MACHINE_EPSILON) {
            var Q = D < 0 ? 0 : sqrt(D),
                R = b + (b < 0 ? -Q : Q);

            if (R === 0) {
              x1 = c / a;
              x2 = -x1;
            } else {
              x1 = R / a;
              x2 = c / R;
            }
          }
        }

        var count = 0,
            boundless = min == null,
            minB = min - EPSILON,
            maxB = max + EPSILON;
        if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB)) roots[count++] = boundless ? x1 : clamp(x1, min, max);
        if (x2 !== x1 && isFinite(x2) && (boundless || x2 > minB && x2 < maxB)) roots[count++] = boundless ? x2 : clamp(x2, min, max);
        return count;
      },
      solveCubic: function (a, b, c, d, roots, min, max) {
        var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),
            x,
            b1,
            c2,
            qd,
            q;

        if (f) {
          a *= f;
          b *= f;
          c *= f;
          d *= f;
        }

        function evaluate(x0) {
          x = x0;
          var tmp = a * x;
          b1 = tmp + b;
          c2 = b1 * x + c;
          qd = (tmp + b1) * x + c2;
          q = c2 * x + d;
        }

        if (abs(a) < EPSILON) {
          a = b;
          b1 = c;
          c2 = d;
          x = Infinity;
        } else if (abs(d) < EPSILON) {
          b1 = b;
          c2 = c;
          x = 0;
        } else {
          evaluate(-(b / a) / 3);
          var t = q / a,
              r = pow(abs(t), 1 / 3),
              s = t < 0 ? -1 : 1,
              td = -qd / a,
              rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,
              x0 = x - s * rd;

          if (x0 !== x) {
            do {
              evaluate(x0);
              x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);
            } while (s * x0 > s * x);

            if (abs(a) * x * x > abs(d / x)) {
              c2 = -d / x;
              b1 = (c2 - c) / x;
            }
          }
        }

        var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),
            boundless = min == null;
        if (isFinite(x) && (count === 0 || count > 0 && x !== roots[0] && x !== roots[1]) && (boundless || x > min - EPSILON && x < max + EPSILON)) roots[count++] = boundless ? x : clamp(x, min, max);
        return count;
      }
    };
  }();
  var UID = {
    _id: 1,
    _pools: {},
    get: function (name) {
      if (name) {
        var pool = this._pools[name];
        if (!pool) pool = this._pools[name] = {
          _id: 1
        };
        return pool._id++;
      } else {
        return this._id++;
      }
    }
  };
  var Point = Base.extend({
    _class: 'Point',
    _readIndex: true,
    initialize: function Point(arg0, arg1) {
      var type = typeof arg0,
          reading = this.__read,
          read = 0;

      if (type === 'number') {
        var hasY = typeof arg1 === 'number';

        this._set(arg0, hasY ? arg1 : arg0);

        if (reading) read = hasY ? 2 : 1;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0);

        if (reading) read = arg0 === null ? 1 : 0;
      } else {
        var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
        read = 1;

        if (Array.isArray(obj)) {
          this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
        } else if ('x' in obj) {
          this._set(obj.x || 0, obj.y || 0);
        } else if ('width' in obj) {
          this._set(obj.width || 0, obj.height || 0);
        } else if ('angle' in obj) {
          this._set(obj.length || 0, 0);

          this.setAngle(obj.angle || 0);
        } else {
          this._set(0, 0);

          read = 0;
        }
      }

      if (reading) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function (x, y) {
      this.x = x;
      this.y = y;
      return this;
    },
    equals: function (point) {
      return this === point || point && (this.x === point.x && this.y === point.y || Array.isArray(point) && this.x === point[0] && this.y === point[1]) || false;
    },
    clone: function () {
      return new Point(this.x, this.y);
    },
    toString: function () {
      var f = Formatter.instance;
      return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
    },
    _serialize: function (options) {
      var f = options.formatter;
      return [f.number(this.x), f.number(this.y)];
    },
    getLength: function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    setLength: function (length) {
      if (this.isZero()) {
        var angle = this._angle || 0;

        this._set(Math.cos(angle) * length, Math.sin(angle) * length);
      } else {
        var scale = length / this.getLength();
        if (Numerical.isZero(scale)) this.getAngle();

        this._set(this.x * scale, this.y * scale);
      }
    },
    getAngle: function () {
      return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
    },
    setAngle: function (angle) {
      this.setAngleInRadians.call(this, angle * Math.PI / 180);
    },
    getAngleInDegrees: '#getAngle',
    setAngleInDegrees: '#setAngle',
    getAngleInRadians: function () {
      if (!arguments.length) {
        return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
      } else {
        var point = Point.read(arguments),
            div = this.getLength() * point.getLength();

        if (Numerical.isZero(div)) {
          return NaN;
        } else {
          var a = this.dot(point) / div;
          return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
        }
      }
    },
    setAngleInRadians: function (angle) {
      this._angle = angle;

      if (!this.isZero()) {
        var length = this.getLength();

        this._set(Math.cos(angle) * length, Math.sin(angle) * length);
      }
    },
    getQuadrant: function () {
      return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
    }
  }, {
    beans: false,
    getDirectedAngle: function () {
      var point = Point.read(arguments);
      return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
    },
    getDistance: function () {
      var args = arguments,
          point = Point.read(args),
          x = point.x - this.x,
          y = point.y - this.y,
          d = x * x + y * y,
          squared = Base.read(args);
      return squared ? d : Math.sqrt(d);
    },
    normalize: function (length) {
      if (length === undefined) length = 1;
      var current = this.getLength(),
          scale = current !== 0 ? length / current : 0,
          point = new Point(this.x * scale, this.y * scale);
      if (scale >= 0) point._angle = this._angle;
      return point;
    },
    rotate: function (angle, center) {
      if (angle === 0) return this.clone();
      angle = angle * Math.PI / 180;
      var point = center ? this.subtract(center) : this,
          sin = Math.sin(angle),
          cos = Math.cos(angle);
      point = new Point(point.x * cos - point.y * sin, point.x * sin + point.y * cos);
      return center ? point.add(center) : point;
    },
    transform: function (matrix) {
      return matrix ? matrix._transformPoint(this) : this;
    },
    add: function () {
      var point = Point.read(arguments);
      return new Point(this.x + point.x, this.y + point.y);
    },
    subtract: function () {
      var point = Point.read(arguments);
      return new Point(this.x - point.x, this.y - point.y);
    },
    multiply: function () {
      var point = Point.read(arguments);
      return new Point(this.x * point.x, this.y * point.y);
    },
    divide: function () {
      var point = Point.read(arguments);
      return new Point(this.x / point.x, this.y / point.y);
    },
    modulo: function () {
      var point = Point.read(arguments);
      return new Point(this.x % point.x, this.y % point.y);
    },
    negate: function () {
      return new Point(-this.x, -this.y);
    },
    isInside: function () {
      return Rectangle.read(arguments).contains(this);
    },
    isClose: function () {
      var args = arguments,
          point = Point.read(args),
          tolerance = Base.read(args);
      return this.getDistance(point) <= tolerance;
    },
    isCollinear: function () {
      var point = Point.read(arguments);
      return Point.isCollinear(this.x, this.y, point.x, point.y);
    },
    isColinear: '#isCollinear',
    isOrthogonal: function () {
      var point = Point.read(arguments);
      return Point.isOrthogonal(this.x, this.y, point.x, point.y);
    },
    isZero: function () {
      var isZero = Numerical.isZero;
      return isZero(this.x) && isZero(this.y);
    },
    isNaN: function () {
      return isNaN(this.x) || isNaN(this.y);
    },
    isInQuadrant: function (q) {
      return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0 && this.y * (q > 2 ? -1 : 1) >= 0;
    },
    dot: function () {
      var point = Point.read(arguments);
      return this.x * point.x + this.y * point.y;
    },
    cross: function () {
      var point = Point.read(arguments);
      return this.x * point.y - this.y * point.x;
    },
    project: function () {
      var point = Point.read(arguments),
          scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
      return new Point(point.x * scale, point.y * scale);
    },
    statics: {
      min: function () {
        var args = arguments,
            point1 = Point.read(args),
            point2 = Point.read(args);
        return new Point(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y));
      },
      max: function () {
        var args = arguments,
            point1 = Point.read(args),
            point2 = Point.read(args);
        return new Point(Math.max(point1.x, point2.x), Math.max(point1.y, point2.y));
      },
      random: function () {
        return new Point(Math.random(), Math.random());
      },
      isCollinear: function (x1, y1, x2, y2) {
        return Math.abs(x1 * y2 - y1 * x2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;
      },
      isOrthogonal: function (x1, y1, x2, y2) {
        return Math.abs(x1 * x2 + y1 * y2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;
      }
    }
  }, Base.each(['round', 'ceil', 'floor', 'abs'], function (key) {
    var op = Math[key];

    this[key] = function () {
      return new Point(op(this.x), op(this.y));
    };
  }, {}));
  var LinkedPoint = Point.extend({
    initialize: function Point(x, y, owner, setter) {
      this._x = x;
      this._y = y;
      this._owner = owner;
      this._setter = setter;
    },
    _set: function (x, y, _dontNotify) {
      this._x = x;
      this._y = y;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    },
    getX: function () {
      return this._x;
    },
    setX: function (x) {
      this._x = x;

      this._owner[this._setter](this);
    },
    getY: function () {
      return this._y;
    },
    setY: function (y) {
      this._y = y;

      this._owner[this._setter](this);
    },
    isSelected: function () {
      return !!(this._owner._selection & this._getSelection());
    },
    setSelected: function (selected) {
      this._owner._changeSelection(this._getSelection(), selected);
    },
    _getSelection: function () {
      return this._setter === 'setPosition' ? 4 : 0;
    }
  });
  var Size = Base.extend({
    _class: 'Size',
    _readIndex: true,
    initialize: function Size(arg0, arg1) {
      var type = typeof arg0,
          reading = this.__read,
          read = 0;

      if (type === 'number') {
        var hasHeight = typeof arg1 === 'number';

        this._set(arg0, hasHeight ? arg1 : arg0);

        if (reading) read = hasHeight ? 2 : 1;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0);

        if (reading) read = arg0 === null ? 1 : 0;
      } else {
        var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
        read = 1;

        if (Array.isArray(obj)) {
          this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
        } else if ('width' in obj) {
          this._set(obj.width || 0, obj.height || 0);
        } else if ('x' in obj) {
          this._set(obj.x || 0, obj.y || 0);
        } else {
          this._set(0, 0);

          read = 0;
        }
      }

      if (reading) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function (width, height) {
      this.width = width;
      this.height = height;
      return this;
    },
    equals: function (size) {
      return size === this || size && (this.width === size.width && this.height === size.height || Array.isArray(size) && this.width === size[0] && this.height === size[1]) || false;
    },
    clone: function () {
      return new Size(this.width, this.height);
    },
    toString: function () {
      var f = Formatter.instance;
      return '{ width: ' + f.number(this.width) + ', height: ' + f.number(this.height) + ' }';
    },
    _serialize: function (options) {
      var f = options.formatter;
      return [f.number(this.width), f.number(this.height)];
    },
    add: function () {
      var size = Size.read(arguments);
      return new Size(this.width + size.width, this.height + size.height);
    },
    subtract: function () {
      var size = Size.read(arguments);
      return new Size(this.width - size.width, this.height - size.height);
    },
    multiply: function () {
      var size = Size.read(arguments);
      return new Size(this.width * size.width, this.height * size.height);
    },
    divide: function () {
      var size = Size.read(arguments);
      return new Size(this.width / size.width, this.height / size.height);
    },
    modulo: function () {
      var size = Size.read(arguments);
      return new Size(this.width % size.width, this.height % size.height);
    },
    negate: function () {
      return new Size(-this.width, -this.height);
    },
    isZero: function () {
      var isZero = Numerical.isZero;
      return isZero(this.width) && isZero(this.height);
    },
    isNaN: function () {
      return isNaN(this.width) || isNaN(this.height);
    },
    statics: {
      min: function (size1, size2) {
        return new Size(Math.min(size1.width, size2.width), Math.min(size1.height, size2.height));
      },
      max: function (size1, size2) {
        return new Size(Math.max(size1.width, size2.width), Math.max(size1.height, size2.height));
      },
      random: function () {
        return new Size(Math.random(), Math.random());
      }
    }
  }, Base.each(['round', 'ceil', 'floor', 'abs'], function (key) {
    var op = Math[key];

    this[key] = function () {
      return new Size(op(this.width), op(this.height));
    };
  }, {}));
  var LinkedSize = Size.extend({
    initialize: function Size(width, height, owner, setter) {
      this._width = width;
      this._height = height;
      this._owner = owner;
      this._setter = setter;
    },
    _set: function (width, height, _dontNotify) {
      this._width = width;
      this._height = height;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    },
    getWidth: function () {
      return this._width;
    },
    setWidth: function (width) {
      this._width = width;

      this._owner[this._setter](this);
    },
    getHeight: function () {
      return this._height;
    },
    setHeight: function (height) {
      this._height = height;

      this._owner[this._setter](this);
    }
  });
  var Rectangle = Base.extend({
    _class: 'Rectangle',
    _readIndex: true,
    beans: true,
    initialize: function Rectangle(arg0, arg1, arg2, arg3) {
      var args = arguments,
          type = typeof arg0,
          read;

      if (type === 'number') {
        this._set(arg0, arg1, arg2, arg3);

        read = 4;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0, 0, 0);

        read = arg0 === null ? 1 : 0;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          this._set.apply(this, arg0);

          read = 1;
        } else if (arg0.x !== undefined || arg0.width !== undefined) {
          this._set(arg0.x || 0, arg0.y || 0, arg0.width || 0, arg0.height || 0);

          read = 1;
        } else if (arg0.from === undefined && arg0.to === undefined) {
          this._set(0, 0, 0, 0);

          if (Base.readSupported(args, this)) {
            read = 1;
          }
        }
      }

      if (read === undefined) {
        var frm = Point.readNamed(args, 'from'),
            next = Base.peek(args),
            x = frm.x,
            y = frm.y,
            width,
            height;

        if (next && next.x !== undefined || Base.hasNamed(args, 'to')) {
          var to = Point.readNamed(args, 'to');
          width = to.x - x;
          height = to.y - y;

          if (width < 0) {
            x = to.x;
            width = -width;
          }

          if (height < 0) {
            y = to.y;
            height = -height;
          }
        } else {
          var size = Size.read(args);
          width = size.width;
          height = size.height;
        }

        this._set(x, y, width, height);

        read = args.__index;
      }

      var filtered = args.__filtered;
      if (filtered) this.__filtered = filtered;
      if (this.__read) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function (x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      return this;
    },
    clone: function () {
      return new Rectangle(this.x, this.y, this.width, this.height);
    },
    equals: function (rect) {
      var rt = Base.isPlainValue(rect) ? Rectangle.read(arguments) : rect;
      return rt === this || rt && this.x === rt.x && this.y === rt.y && this.width === rt.width && this.height === rt.height || false;
    },
    toString: function () {
      var f = Formatter.instance;
      return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ', width: ' + f.number(this.width) + ', height: ' + f.number(this.height) + ' }';
    },
    _serialize: function (options) {
      var f = options.formatter;
      return [f.number(this.x), f.number(this.y), f.number(this.width), f.number(this.height)];
    },
    getPoint: function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this.x, this.y, this, 'setPoint');
    },
    setPoint: function () {
      var point = Point.read(arguments);
      this.x = point.x;
      this.y = point.y;
    },
    getSize: function (_dontLink) {
      var ctor = _dontLink ? Size : LinkedSize;
      return new ctor(this.width, this.height, this, 'setSize');
    },
    _fw: 1,
    _fh: 1,
    setSize: function () {
      var size = Size.read(arguments),
          sx = this._sx,
          sy = this._sy,
          w = size.width,
          h = size.height;

      if (sx) {
        this.x += (this.width - w) * sx;
      }

      if (sy) {
        this.y += (this.height - h) * sy;
      }

      this.width = w;
      this.height = h;
      this._fw = this._fh = 1;
    },
    getLeft: function () {
      return this.x;
    },
    setLeft: function (left) {
      if (!this._fw) {
        var amount = left - this.x;
        this.width -= this._sx === 0.5 ? amount * 2 : amount;
      }

      this.x = left;
      this._sx = this._fw = 0;
    },
    getTop: function () {
      return this.y;
    },
    setTop: function (top) {
      if (!this._fh) {
        var amount = top - this.y;
        this.height -= this._sy === 0.5 ? amount * 2 : amount;
      }

      this.y = top;
      this._sy = this._fh = 0;
    },
    getRight: function () {
      return this.x + this.width;
    },
    setRight: function (right) {
      if (!this._fw) {
        var amount = right - this.x;
        this.width = this._sx === 0.5 ? amount * 2 : amount;
      }

      this.x = right - this.width;
      this._sx = 1;
      this._fw = 0;
    },
    getBottom: function () {
      return this.y + this.height;
    },
    setBottom: function (bottom) {
      if (!this._fh) {
        var amount = bottom - this.y;
        this.height = this._sy === 0.5 ? amount * 2 : amount;
      }

      this.y = bottom - this.height;
      this._sy = 1;
      this._fh = 0;
    },
    getCenterX: function () {
      return this.x + this.width / 2;
    },
    setCenterX: function (x) {
      if (this._fw || this._sx === 0.5) {
        this.x = x - this.width / 2;
      } else {
        if (this._sx) {
          this.x += (x - this.x) * 2 * this._sx;
        }

        this.width = (x - this.x) * 2;
      }

      this._sx = 0.5;
      this._fw = 0;
    },
    getCenterY: function () {
      return this.y + this.height / 2;
    },
    setCenterY: function (y) {
      if (this._fh || this._sy === 0.5) {
        this.y = y - this.height / 2;
      } else {
        if (this._sy) {
          this.y += (y - this.y) * 2 * this._sy;
        }

        this.height = (y - this.y) * 2;
      }

      this._sy = 0.5;
      this._fh = 0;
    },
    getCenter: function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
    },
    setCenter: function () {
      var point = Point.read(arguments);
      this.setCenterX(point.x);
      this.setCenterY(point.y);
      return this;
    },
    getArea: function () {
      return this.width * this.height;
    },
    isEmpty: function () {
      return this.width === 0 || this.height === 0;
    },
    contains: function (arg) {
      return arg && arg.width !== undefined || (Array.isArray(arg) ? arg : arguments).length === 4 ? this._containsRectangle(Rectangle.read(arguments)) : this._containsPoint(Point.read(arguments));
    },
    _containsPoint: function (point) {
      var x = point.x,
          y = point.y;
      return x >= this.x && y >= this.y && x <= this.x + this.width && y <= this.y + this.height;
    },
    _containsRectangle: function (rect) {
      var x = rect.x,
          y = rect.y;
      return x >= this.x && y >= this.y && x + rect.width <= this.x + this.width && y + rect.height <= this.y + this.height;
    },
    intersects: function () {
      var rect = Rectangle.read(arguments),
          epsilon = Base.read(arguments) || 0;
      return rect.x + rect.width > this.x - epsilon && rect.y + rect.height > this.y - epsilon && rect.x < this.x + this.width + epsilon && rect.y < this.y + this.height + epsilon;
    },
    intersect: function () {
      var rect = Rectangle.read(arguments),
          x1 = Math.max(this.x, rect.x),
          y1 = Math.max(this.y, rect.y),
          x2 = Math.min(this.x + this.width, rect.x + rect.width),
          y2 = Math.min(this.y + this.height, rect.y + rect.height);
      return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    unite: function () {
      var rect = Rectangle.read(arguments),
          x1 = Math.min(this.x, rect.x),
          y1 = Math.min(this.y, rect.y),
          x2 = Math.max(this.x + this.width, rect.x + rect.width),
          y2 = Math.max(this.y + this.height, rect.y + rect.height);
      return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    include: function () {
      var point = Point.read(arguments);
      var x1 = Math.min(this.x, point.x),
          y1 = Math.min(this.y, point.y),
          x2 = Math.max(this.x + this.width, point.x),
          y2 = Math.max(this.y + this.height, point.y);
      return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    expand: function () {
      var amount = Size.read(arguments),
          hor = amount.width,
          ver = amount.height;
      return new Rectangle(this.x - hor / 2, this.y - ver / 2, this.width + hor, this.height + ver);
    },
    scale: function (hor, ver) {
      return this.expand(this.width * hor - this.width, this.height * (ver === undefined ? hor : ver) - this.height);
    }
  }, Base.each([['Top', 'Left'], ['Top', 'Right'], ['Bottom', 'Left'], ['Bottom', 'Right'], ['Left', 'Center'], ['Top', 'Center'], ['Right', 'Center'], ['Bottom', 'Center']], function (parts, index) {
    var part = parts.join(''),
        xFirst = /^[RL]/.test(part);
    if (index >= 4) parts[1] += xFirst ? 'Y' : 'X';
    var x = parts[xFirst ? 0 : 1],
        y = parts[xFirst ? 1 : 0],
        getX = 'get' + x,
        getY = 'get' + y,
        setX = 'set' + x,
        setY = 'set' + y,
        get = 'get' + part,
        set = 'set' + part;

    this[get] = function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this[getX](), this[getY](), this, set);
    };

    this[set] = function () {
      var point = Point.read(arguments);
      this[setX](point.x);
      this[setY](point.y);
    };
  }, {
    beans: true
  }));
  var LinkedRectangle = Rectangle.extend({
    initialize: function Rectangle(x, y, width, height, owner, setter) {
      this._set(x, y, width, height, true);

      this._owner = owner;
      this._setter = setter;
    },
    _set: function (x, y, width, height, _dontNotify) {
      this._x = x;
      this._y = y;
      this._width = width;
      this._height = height;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    }
  }, new function () {
    var proto = Rectangle.prototype;
    return Base.each(['x', 'y', 'width', 'height'], function (key) {
      var part = Base.capitalize(key),
          internal = '_' + key;

      this['get' + part] = function () {
        return this[internal];
      };

      this['set' + part] = function (value) {
        this[internal] = value;
        if (!this._dontNotify) this._owner[this._setter](this);
      };
    }, Base.each(['Point', 'Size', 'Center', 'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY', 'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'], function (key) {
      var name = 'set' + key;

      this[name] = function () {
        this._dontNotify = true;
        proto[name].apply(this, arguments);
        this._dontNotify = false;

        this._owner[this._setter](this);
      };
    }, {
      isSelected: function () {
        return !!(this._owner._selection & 2);
      },
      setSelected: function (selected) {
        var owner = this._owner;

        if (owner._changeSelection) {
          owner._changeSelection(2, selected);
        }
      }
    }));
  }());
  var Matrix = Base.extend({
    _class: 'Matrix',
    initialize: function Matrix(arg, _dontNotify) {
      var args = arguments,
          count = args.length,
          ok = true;

      if (count >= 6) {
        this._set.apply(this, args);
      } else if (count === 1 || count === 2) {
        if (arg instanceof Matrix) {
          this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty, _dontNotify);
        } else if (Array.isArray(arg)) {
          this._set.apply(this, _dontNotify ? arg.concat([_dontNotify]) : arg);
        } else {
          ok = false;
        }
      } else if (!count) {
        this.reset();
      } else {
        ok = false;
      }

      if (!ok) {
        throw new Error('Unsupported matrix parameters');
      }

      return this;
    },
    set: '#initialize',
    _set: function (a, b, c, d, tx, ty, _dontNotify) {
      this._a = a;
      this._b = b;
      this._c = c;
      this._d = d;
      this._tx = tx;
      this._ty = ty;
      if (!_dontNotify) this._changed();
      return this;
    },
    _serialize: function (options, dictionary) {
      return Base.serialize(this.getValues(), options, true, dictionary);
    },
    _changed: function () {
      var owner = this._owner;

      if (owner) {
        if (owner._applyMatrix) {
          owner.transform(null, true);
        } else {
          owner._changed(25);
        }
      }
    },
    clone: function () {
      return new Matrix(this._a, this._b, this._c, this._d, this._tx, this._ty);
    },
    equals: function (mx) {
      return mx === this || mx && this._a === mx._a && this._b === mx._b && this._c === mx._c && this._d === mx._d && this._tx === mx._tx && this._ty === mx._ty;
    },
    toString: function () {
      var f = Formatter.instance;
      return '[[' + [f.number(this._a), f.number(this._c), f.number(this._tx)].join(', ') + '], [' + [f.number(this._b), f.number(this._d), f.number(this._ty)].join(', ') + ']]';
    },
    reset: function (_dontNotify) {
      this._a = this._d = 1;
      this._b = this._c = this._tx = this._ty = 0;
      if (!_dontNotify) this._changed();
      return this;
    },
    apply: function (recursively, _setApplyMatrix) {
      var owner = this._owner;

      if (owner) {
        owner.transform(null, Base.pick(recursively, true), _setApplyMatrix);
        return this.isIdentity();
      }

      return false;
    },
    translate: function () {
      var point = Point.read(arguments),
          x = point.x,
          y = point.y;
      this._tx += x * this._a + y * this._c;
      this._ty += x * this._b + y * this._d;

      this._changed();

      return this;
    },
    scale: function () {
      var args = arguments,
          scale = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      if (center) this.translate(center);
      this._a *= scale.x;
      this._b *= scale.x;
      this._c *= scale.y;
      this._d *= scale.y;
      if (center) this.translate(center.negate());

      this._changed();

      return this;
    },
    rotate: function (angle) {
      angle *= Math.PI / 180;
      var center = Point.read(arguments, 1),
          x = center.x,
          y = center.y,
          cos = Math.cos(angle),
          sin = Math.sin(angle),
          tx = x - x * cos + y * sin,
          ty = y - x * sin - y * cos,
          a = this._a,
          b = this._b,
          c = this._c,
          d = this._d;
      this._a = cos * a + sin * c;
      this._b = cos * b + sin * d;
      this._c = -sin * a + cos * c;
      this._d = -sin * b + cos * d;
      this._tx += tx * a + ty * c;
      this._ty += tx * b + ty * d;

      this._changed();

      return this;
    },
    shear: function () {
      var args = arguments,
          shear = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      if (center) this.translate(center);
      var a = this._a,
          b = this._b;
      this._a += shear.y * this._c;
      this._b += shear.y * this._d;
      this._c += shear.x * a;
      this._d += shear.x * b;
      if (center) this.translate(center.negate());

      this._changed();

      return this;
    },
    skew: function () {
      var args = arguments,
          skew = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      }),
          toRadians = Math.PI / 180,
          shear = new Point(Math.tan(skew.x * toRadians), Math.tan(skew.y * toRadians));
      return this.shear(shear, center);
    },
    append: function (mx, _dontNotify) {
      if (mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            a2 = mx._a,
            b2 = mx._c,
            c2 = mx._b,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        this._a = a2 * a1 + c2 * c1;
        this._c = b2 * a1 + d2 * c1;
        this._b = a2 * b1 + c2 * d1;
        this._d = b2 * b1 + d2 * d1;
        this._tx += tx2 * a1 + ty2 * c1;
        this._ty += tx2 * b1 + ty2 * d1;
        if (!_dontNotify) this._changed();
      }

      return this;
    },
    prepend: function (mx, _dontNotify) {
      if (mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            tx1 = this._tx,
            ty1 = this._ty,
            a2 = mx._a,
            b2 = mx._c,
            c2 = mx._b,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        this._a = a2 * a1 + b2 * b1;
        this._c = a2 * c1 + b2 * d1;
        this._b = c2 * a1 + d2 * b1;
        this._d = c2 * c1 + d2 * d1;
        this._tx = a2 * tx1 + b2 * ty1 + tx2;
        this._ty = c2 * tx1 + d2 * ty1 + ty2;
        if (!_dontNotify) this._changed();
      }

      return this;
    },
    appended: function (mx) {
      return this.clone().append(mx);
    },
    prepended: function (mx) {
      return this.clone().prepend(mx);
    },
    invert: function () {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          tx = this._tx,
          ty = this._ty,
          det = a * d - b * c,
          res = null;

      if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
        this._a = d / det;
        this._b = -b / det;
        this._c = -c / det;
        this._d = a / det;
        this._tx = (c * ty - d * tx) / det;
        this._ty = (b * tx - a * ty) / det;
        res = this;
      }

      return res;
    },
    inverted: function () {
      return this.clone().invert();
    },
    concatenate: '#append',
    preConcatenate: '#prepend',
    chain: '#appended',
    _shiftless: function () {
      return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
    },
    _orNullIfIdentity: function () {
      return this.isIdentity() ? null : this;
    },
    isIdentity: function () {
      return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1 && this._tx === 0 && this._ty === 0;
    },
    isInvertible: function () {
      var det = this._a * this._d - this._c * this._b;
      return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
    },
    isSingular: function () {
      return !this.isInvertible();
    },
    transform: function (src, dst, count) {
      return arguments.length < 3 ? this._transformPoint(Point.read(arguments)) : this._transformCoordinates(src, dst, count);
    },
    _transformPoint: function (point, dest, _dontNotify) {
      var x = point.x,
          y = point.y;
      if (!dest) dest = new Point();
      return dest._set(x * this._a + y * this._c + this._tx, x * this._b + y * this._d + this._ty, _dontNotify);
    },
    _transformCoordinates: function (src, dst, count) {
      for (var i = 0, max = 2 * count; i < max; i += 2) {
        var x = src[i],
            y = src[i + 1];
        dst[i] = x * this._a + y * this._c + this._tx;
        dst[i + 1] = x * this._b + y * this._d + this._ty;
      }

      return dst;
    },
    _transformCorners: function (rect) {
      var x1 = rect.x,
          y1 = rect.y,
          x2 = x1 + rect.width,
          y2 = y1 + rect.height,
          coords = [x1, y1, x2, y1, x2, y2, x1, y2];
      return this._transformCoordinates(coords, coords, 4);
    },
    _transformBounds: function (bounds, dest, _dontNotify) {
      var coords = this._transformCorners(bounds),
          min = coords.slice(0, 2),
          max = min.slice();

      for (var i = 2; i < 8; i++) {
        var val = coords[i],
            j = i & 1;

        if (val < min[j]) {
          min[j] = val;
        } else if (val > max[j]) {
          max[j] = val;
        }
      }

      if (!dest) dest = new Rectangle();
      return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1], _dontNotify);
    },
    inverseTransform: function () {
      return this._inverseTransform(Point.read(arguments));
    },
    _inverseTransform: function (point, dest, _dontNotify) {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          tx = this._tx,
          ty = this._ty,
          det = a * d - b * c,
          res = null;

      if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
        var x = point.x - this._tx,
            y = point.y - this._ty;
        if (!dest) dest = new Point();
        res = dest._set((x * d - y * c) / det, (y * a - x * b) / det, _dontNotify);
      }

      return res;
    },
    decompose: function () {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          det = a * d - b * c,
          sqrt = Math.sqrt,
          atan2 = Math.atan2,
          degrees = 180 / Math.PI,
          rotate,
          scale,
          skew;

      if (a !== 0 || b !== 0) {
        var r = sqrt(a * a + b * b);
        rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);
        scale = [r, det / r];
        skew = [atan2(a * c + b * d, r * r), 0];
      } else if (c !== 0 || d !== 0) {
        var s = sqrt(c * c + d * d);
        rotate = Math.asin(c / s) * (d > 0 ? 1 : -1);
        scale = [det / s, s];
        skew = [0, atan2(a * c + b * d, s * s)];
      } else {
        rotate = 0;
        skew = scale = [0, 0];
      }

      return {
        translation: this.getTranslation(),
        rotation: rotate * degrees,
        scaling: new Point(scale),
        skewing: new Point(skew[0] * degrees, skew[1] * degrees)
      };
    },
    getValues: function () {
      return [this._a, this._b, this._c, this._d, this._tx, this._ty];
    },
    getTranslation: function () {
      return new Point(this._tx, this._ty);
    },
    getScaling: function () {
      return this.decompose().scaling;
    },
    getRotation: function () {
      return this.decompose().rotation;
    },
    applyToContext: function (ctx) {
      if (!this.isIdentity()) {
        ctx.transform(this._a, this._b, this._c, this._d, this._tx, this._ty);
      }
    }
  }, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function (key) {
    var part = Base.capitalize(key),
        prop = '_' + key;

    this['get' + part] = function () {
      return this[prop];
    };

    this['set' + part] = function (value) {
      this[prop] = value;

      this._changed();
    };
  }, {}));
  var Line = Base.extend({
    _class: 'Line',
    initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
      var asVector = false;

      if (arguments.length >= 4) {
        this._px = arg0;
        this._py = arg1;
        this._vx = arg2;
        this._vy = arg3;
        asVector = arg4;
      } else {
        this._px = arg0.x;
        this._py = arg0.y;
        this._vx = arg1.x;
        this._vy = arg1.y;
        asVector = arg2;
      }

      if (!asVector) {
        this._vx -= this._px;
        this._vy -= this._py;
      }
    },
    getPoint: function () {
      return new Point(this._px, this._py);
    },
    getVector: function () {
      return new Point(this._vx, this._vy);
    },
    getLength: function () {
      return this.getVector().getLength();
    },
    intersect: function (line, isInfinite) {
      return Line.intersect(this._px, this._py, this._vx, this._vy, line._px, line._py, line._vx, line._vy, true, isInfinite);
    },
    getSide: function (point, isInfinite) {
      return Line.getSide(this._px, this._py, this._vx, this._vy, point.x, point.y, true, isInfinite);
    },
    getDistance: function (point) {
      return Math.abs(this.getSignedDistance(point));
    },
    getSignedDistance: function (point) {
      return Line.getSignedDistance(this._px, this._py, this._vx, this._vy, point.x, point.y, true);
    },
    isCollinear: function (line) {
      return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
    },
    isOrthogonal: function (line) {
      return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
    },
    statics: {
      intersect: function (p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector, isInfinite) {
        if (!asVector) {
          v1x -= p1x;
          v1y -= p1y;
          v2x -= p2x;
          v2y -= p2y;
        }

        var cross = v1x * v2y - v1y * v2x;

        if (!Numerical.isMachineZero(cross)) {
          var dx = p1x - p2x,
              dy = p1y - p2y,
              u1 = (v2x * dy - v2y * dx) / cross,
              u2 = (v1x * dy - v1y * dx) / cross,
              epsilon = 1e-12,
              uMin = -epsilon,
              uMax = 1 + epsilon;

          if (isInfinite || uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
            if (!isInfinite) {
              u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
            }

            return new Point(p1x + u1 * v1x, p1y + u1 * v1y);
          }
        }
      },
      getSide: function (px, py, vx, vy, x, y, asVector, isInfinite) {
        if (!asVector) {
          vx -= px;
          vy -= py;
        }

        var v2x = x - px,
            v2y = y - py,
            ccw = v2x * vy - v2y * vx;

        if (!isInfinite && Numerical.isMachineZero(ccw)) {
          ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
          if (ccw >= 0 && ccw <= 1) ccw = 0;
        }

        return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
      },
      getSignedDistance: function (px, py, vx, vy, x, y, asVector) {
        if (!asVector) {
          vx -= px;
          vy -= py;
        }

        return vx === 0 ? vy > 0 ? x - px : px - x : vy === 0 ? vx < 0 ? y - py : py - y : ((x - px) * vy - (y - py) * vx) / (vy > vx ? vy * Math.sqrt(1 + vx * vx / (vy * vy)) : vx * Math.sqrt(1 + vy * vy / (vx * vx)));
      },
      getDistance: function (px, py, vx, vy, x, y, asVector) {
        return Math.abs(Line.getSignedDistance(px, py, vx, vy, x, y, asVector));
      }
    }
  });
  var Project = PaperScopeItem.extend({
    _class: 'Project',
    _list: 'projects',
    _reference: 'project',
    _compactSerialize: true,
    initialize: function Project(element) {
      PaperScopeItem.call(this, true);
      this._children = [];
      this._namedChildren = {};
      this._activeLayer = null;
      this._currentStyle = new Style(null, null, this);
      this._view = View.create(this, element || CanvasProvider.getCanvas(1, 1));
      this._selectionItems = {};
      this._selectionCount = 0;
      this._updateVersion = 0;
    },
    _serialize: function (options, dictionary) {
      return Base.serialize(this._children, options, true, dictionary);
    },
    _changed: function (flags, item) {
      if (flags & 1) {
        var view = this._view;

        if (view) {
          view._needsUpdate = true;
          if (!view._requested && view._autoUpdate) view.requestUpdate();
        }
      }

      var changes = this._changes;

      if (changes && item) {
        var changesById = this._changesById,
            id = item._id,
            entry = changesById[id];

        if (entry) {
          entry.flags |= flags;
        } else {
          changes.push(changesById[id] = {
            item: item,
            flags: flags
          });
        }
      }
    },
    clear: function () {
      var children = this._children;

      for (var i = children.length - 1; i >= 0; i--) children[i].remove();
    },
    isEmpty: function () {
      return !this._children.length;
    },
    remove: function remove() {
      if (!remove.base.call(this)) return false;
      if (this._view) this._view.remove();
      return true;
    },
    getView: function () {
      return this._view;
    },
    getCurrentStyle: function () {
      return this._currentStyle;
    },
    setCurrentStyle: function (style) {
      this._currentStyle.set(style);
    },
    getIndex: function () {
      return this._index;
    },
    getOptions: function () {
      return this._scope.settings;
    },
    getLayers: function () {
      return this._children;
    },
    getActiveLayer: function () {
      return this._activeLayer || new Layer({
        project: this,
        insert: true
      });
    },
    getSymbolDefinitions: function () {
      var definitions = [],
          ids = {};
      this.getItems({
        class: SymbolItem,
        match: function (item) {
          var definition = item._definition,
              id = definition._id;

          if (!ids[id]) {
            ids[id] = true;
            definitions.push(definition);
          }

          return false;
        }
      });
      return definitions;
    },
    getSymbols: 'getSymbolDefinitions',
    getSelectedItems: function () {
      var selectionItems = this._selectionItems,
          items = [];

      for (var id in selectionItems) {
        var item = selectionItems[id],
            selection = item._selection;

        if (selection & 1 && item.isInserted()) {
          items.push(item);
        } else if (!selection) {
          this._updateSelection(item);
        }
      }

      return items;
    },
    _updateSelection: function (item) {
      var id = item._id,
          selectionItems = this._selectionItems;

      if (item._selection) {
        if (selectionItems[id] !== item) {
          this._selectionCount++;
          selectionItems[id] = item;
        }
      } else if (selectionItems[id] === item) {
        this._selectionCount--;
        delete selectionItems[id];
      }
    },
    selectAll: function () {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) children[i].setFullySelected(true);
    },
    deselectAll: function () {
      var selectionItems = this._selectionItems;

      for (var i in selectionItems) selectionItems[i].setFullySelected(false);
    },
    addLayer: function (layer) {
      return this.insertLayer(undefined, layer);
    },
    insertLayer: function (index, layer) {
      if (layer instanceof Layer) {
        layer._remove(false, true);

        Base.splice(this._children, [layer], index, 0);

        layer._setProject(this, true);

        var name = layer._name;
        if (name) layer.setName(name);
        if (this._changes) layer._changed(5);
        if (!this._activeLayer) this._activeLayer = layer;
      } else {
        layer = null;
      }

      return layer;
    },
    _insertItem: function (index, item, _created) {
      item = this.insertLayer(index, item) || (this._activeLayer || this._insertItem(undefined, new Layer(Item.NO_INSERT), true)).insertChild(index, item);
      if (_created && item.activate) item.activate();
      return item;
    },
    getItems: function (options) {
      return Item._getItems(this, options);
    },
    getItem: function (options) {
      return Item._getItems(this, options, null, null, true)[0] || null;
    },
    importJSON: function (json) {
      this.activate();
      var layer = this._activeLayer;
      return Base.importJSON(json, layer && layer.isEmpty() && layer);
    },
    removeOn: function (type) {
      var sets = this._removeSets;

      if (sets) {
        if (type === 'mouseup') sets.mousedrag = null;
        var set = sets[type];

        if (set) {
          for (var id in set) {
            var item = set[id];

            for (var key in sets) {
              var other = sets[key];
              if (other && other != set) delete other[item._id];
            }

            item.remove();
          }

          sets[type] = null;
        }
      }
    },
    draw: function (ctx, matrix, pixelRatio) {
      this._updateVersion++;
      ctx.save();
      matrix.applyToContext(ctx);
      var children = this._children,
          param = new Base({
        offset: new Point(0, 0),
        pixelRatio: pixelRatio,
        viewMatrix: matrix.isIdentity() ? null : matrix,
        matrices: [new Matrix()],
        updateMatrix: true
      });

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].draw(ctx, param);
      }

      ctx.restore();

      if (this._selectionCount > 0) {
        ctx.save();
        ctx.strokeWidth = 1;
        var items = this._selectionItems,
            size = this._scope.settings.handleSize,
            version = this._updateVersion;

        for (var id in items) {
          items[id]._drawSelection(ctx, matrix, size, items, version);
        }

        ctx.restore();
      }
    }
  });
  var Item = Base.extend(Emitter, {
    statics: {
      extend: function extend(src) {
        if (src._serializeFields) src._serializeFields = Base.set({}, this.prototype._serializeFields, src._serializeFields);
        return extend.base.apply(this, arguments);
      },
      NO_INSERT: {
        insert: false
      }
    },
    _class: 'Item',
    _name: null,
    _applyMatrix: true,
    _canApplyMatrix: true,
    _canScaleStroke: false,
    _pivot: null,
    _visible: true,
    _blendMode: 'normal',
    _opacity: 1,
    _locked: false,
    _guide: false,
    _clipMask: false,
    _selection: 0,
    _selectBounds: true,
    _selectChildren: false,
    _serializeFields: {
      name: null,
      applyMatrix: null,
      matrix: new Matrix(),
      pivot: null,
      visible: true,
      blendMode: 'normal',
      opacity: 1,
      locked: false,
      guide: false,
      clipMask: false,
      selected: false,
      data: {}
    },
    _prioritize: ['applyMatrix']
  }, new function () {
    var handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick', 'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];
    return Base.each(handlers, function (name) {
      this._events[name] = {
        install: function (type) {
          this.getView()._countItemEvent(type, 1);
        },
        uninstall: function (type) {
          this.getView()._countItemEvent(type, -1);
        }
      };
    }, {
      _events: {
        onFrame: {
          install: function () {
            this.getView()._animateItem(this, true);
          },
          uninstall: function () {
            this.getView()._animateItem(this, false);
          }
        },
        onLoad: {},
        onError: {}
      },
      statics: {
        _itemHandlers: handlers
      }
    });
  }(), {
    initialize: function Item() {},
    _initialize: function (props, point) {
      var hasProps = props && Base.isPlainObject(props),
          internal = hasProps && props.internal === true,
          matrix = this._matrix = new Matrix(),
          project = hasProps && props.project || paper.project,
          settings = paper.settings;
      this._id = internal ? null : UID.get();
      this._parent = this._index = null;
      this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
      if (point) matrix.translate(point);
      matrix._owner = this;
      this._style = new Style(project._currentStyle, this, project);

      if (internal || hasProps && props.insert == false || !settings.insertItems && !(hasProps && props.insert === true)) {
        this._setProject(project);
      } else {
        (hasProps && props.parent || project)._insertItem(undefined, this, true);
      }

      if (hasProps && props !== Item.NO_INSERT) {
        this.set(props, {
          internal: true,
          insert: true,
          project: true,
          parent: true
        });
      }

      return hasProps;
    },
    _serialize: function (options, dictionary) {
      var props = {},
          that = this;

      function serialize(fields) {
        for (var key in fields) {
          var value = that[key];

          if (!Base.equals(value, key === 'leading' ? fields.fontSize * 1.2 : fields[key])) {
            props[key] = Base.serialize(value, options, key !== 'data', dictionary);
          }
        }
      }

      serialize(this._serializeFields);
      if (!(this instanceof Group)) serialize(this._style._defaults);
      return [this._class, props];
    },
    _changed: function (flags) {
      var symbol = this._symbol,
          cacheParent = this._parent || symbol,
          project = this._project;

      if (flags & 8) {
        this._bounds = this._position = this._decomposed = undefined;
      }

      if (flags & 16) {
        this._globalMatrix = undefined;
      }

      if (cacheParent && flags & 72) {
        Item._clearBoundsCache(cacheParent);
      }

      if (flags & 2) {
        Item._clearBoundsCache(this);
      }

      if (project) project._changed(flags, this);
      if (symbol) symbol._changed(flags);
    },
    getId: function () {
      return this._id;
    },
    getName: function () {
      return this._name;
    },
    setName: function (name) {
      if (this._name) this._removeNamed();
      if (name === +name + '') throw new Error('Names consisting only of numbers are not supported.');

      var owner = this._getOwner();

      if (name && owner) {
        var children = owner._children,
            namedChildren = owner._namedChildren;
        (namedChildren[name] = namedChildren[name] || []).push(this);
        if (!(name in children)) children[name] = this;
      }

      this._name = name || undefined;

      this._changed(256);
    },
    getStyle: function () {
      return this._style;
    },
    setStyle: function (style) {
      this.getStyle().set(style);
    }
  }, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'], function (name) {
    var part = Base.capitalize(name),
        key = '_' + name,
        flags = {
      locked: 256,
      visible: 265
    };

    this['get' + part] = function () {
      return this[key];
    };

    this['set' + part] = function (value) {
      if (value != this[key]) {
        this[key] = value;

        this._changed(flags[name] || 257);
      }
    };
  }, {}), {
    beans: true,
    getSelection: function () {
      return this._selection;
    },
    setSelection: function (selection) {
      if (selection !== this._selection) {
        this._selection = selection;
        var project = this._project;

        if (project) {
          project._updateSelection(this);

          this._changed(257);
        }
      }
    },
    _changeSelection: function (flag, selected) {
      var selection = this._selection;
      this.setSelection(selected ? selection | flag : selection & ~flag);
    },
    isSelected: function () {
      if (this._selectChildren) {
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) if (children[i].isSelected()) return true;
      }

      return !!(this._selection & 1);
    },
    setSelected: function (selected) {
      if (this._selectChildren) {
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) children[i].setSelected(selected);
      }

      this._changeSelection(1, selected);
    },
    isFullySelected: function () {
      var children = this._children,
          selected = !!(this._selection & 1);

      if (children && selected) {
        for (var i = 0, l = children.length; i < l; i++) if (!children[i].isFullySelected()) return false;

        return true;
      }

      return selected;
    },
    setFullySelected: function (selected) {
      var children = this._children;

      if (children) {
        for (var i = 0, l = children.length; i < l; i++) children[i].setFullySelected(selected);
      }

      this._changeSelection(1, selected);
    },
    isClipMask: function () {
      return this._clipMask;
    },
    setClipMask: function (clipMask) {
      if (this._clipMask != (clipMask = !!clipMask)) {
        this._clipMask = clipMask;

        if (clipMask) {
          this.setFillColor(null);
          this.setStrokeColor(null);
        }

        this._changed(257);

        if (this._parent) this._parent._changed(2048);
      }
    },
    getData: function () {
      if (!this._data) this._data = {};
      return this._data;
    },
    setData: function (data) {
      this._data = data;
    },
    getPosition: function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;

      var position = this._position || (this._position = this._getPositionFromBounds());

      return new ctor(position.x, position.y, this, 'setPosition');
    },
    setPosition: function () {
      this.translate(Point.read(arguments).subtract(this.getPosition(true)));
    },
    _getPositionFromBounds: function (bounds) {
      return this._pivot ? this._matrix._transformPoint(this._pivot) : (bounds || this.getBounds()).getCenter(true);
    },
    getPivot: function () {
      var pivot = this._pivot;
      return pivot ? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot') : null;
    },
    setPivot: function () {
      this._pivot = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });
      this._position = undefined;
    }
  }, Base.each({
    getStrokeBounds: {
      stroke: true
    },
    getHandleBounds: {
      handle: true
    },
    getInternalBounds: {
      internal: true
    }
  }, function (options, key) {
    this[key] = function (matrix) {
      return this.getBounds(matrix, options);
    };
  }, {
    beans: true,
    getBounds: function (matrix, options) {
      var hasMatrix = options || matrix instanceof Matrix,
          opts = Base.set({}, hasMatrix ? options : matrix, this._boundsOptions);
      if (!opts.stroke || this.getStrokeScaling()) opts.cacheItem = this;

      var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;

      return !arguments.length ? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height, this, 'setBounds') : rect;
    },
    setBounds: function () {
      var rect = Rectangle.read(arguments),
          bounds = this.getBounds(),
          _matrix = this._matrix,
          matrix = new Matrix(),
          center = rect.getCenter();
      matrix.translate(center);

      if (rect.width != bounds.width || rect.height != bounds.height) {
        if (!_matrix.isInvertible()) {
          _matrix.set(_matrix._backup || new Matrix().translate(_matrix.getTranslation()));

          bounds = this.getBounds();
        }

        matrix.scale(bounds.width !== 0 ? rect.width / bounds.width : 0, bounds.height !== 0 ? rect.height / bounds.height : 0);
      }

      center = bounds.getCenter();
      matrix.translate(-center.x, -center.y);
      this.transform(matrix);
    },
    _getBounds: function (matrix, options) {
      var children = this._children;
      if (!children || !children.length) return new Rectangle();

      Item._updateBoundsCache(this, options.cacheItem);

      return Item._getBounds(children, matrix, options);
    },
    _getBoundsCacheKey: function (options, internal) {
      return [options.stroke ? 1 : 0, options.handle ? 1 : 0, internal ? 1 : 0].join('');
    },
    _getCachedBounds: function (matrix, options, noInternal) {
      matrix = matrix && matrix._orNullIfIdentity();

      var internal = options.internal && !noInternal,
          cacheItem = options.cacheItem,
          _matrix = internal ? null : this._matrix._orNullIfIdentity(),
          cacheKey = cacheItem && (!matrix || matrix.equals(_matrix)) && this._getBoundsCacheKey(options, internal),
          bounds = this._bounds;

      Item._updateBoundsCache(this._parent || this._symbol, cacheItem);

      if (cacheKey && bounds && cacheKey in bounds) {
        var cached = bounds[cacheKey];
        return {
          rect: cached.rect.clone(),
          nonscaling: cached.nonscaling
        };
      }

      var res = this._getBounds(matrix || _matrix, options),
          rect = res.rect || res,
          style = this._style,
          nonscaling = res.nonscaling || style.hasStroke() && !style.getStrokeScaling();

      if (cacheKey) {
        if (!bounds) {
          this._bounds = bounds = {};
        }

        var cached = bounds[cacheKey] = {
          rect: rect.clone(),
          nonscaling: nonscaling,
          internal: internal
        };
      }

      return {
        rect: rect,
        nonscaling: nonscaling
      };
    },
    _getStrokeMatrix: function (matrix, options) {
      var parent = this.getStrokeScaling() ? null : options && options.internal ? this : this._parent || this._symbol && this._symbol._item,
          mx = parent ? parent.getViewMatrix().invert() : matrix;
      return mx && mx._shiftless();
    },
    statics: {
      _updateBoundsCache: function (parent, item) {
        if (parent && item) {
          var id = item._id,
              ref = parent._boundsCache = parent._boundsCache || {
            ids: {},
            list: []
          };

          if (!ref.ids[id]) {
            ref.list.push(item);
            ref.ids[id] = item;
          }
        }
      },
      _clearBoundsCache: function (item) {
        var cache = item._boundsCache;

        if (cache) {
          item._bounds = item._position = item._boundsCache = undefined;

          for (var i = 0, list = cache.list, l = list.length; i < l; i++) {
            var other = list[i];

            if (other !== item) {
              other._bounds = other._position = undefined;
              if (other._boundsCache) Item._clearBoundsCache(other);
            }
          }
        }
      },
      _getBounds: function (items, matrix, options) {
        var x1 = Infinity,
            x2 = -x1,
            y1 = x1,
            y2 = x2,
            nonscaling = false;
        options = options || {};

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i];

          if (item._visible && !item.isEmpty(true)) {
            var bounds = item._getCachedBounds(matrix && matrix.appended(item._matrix), options, true),
                rect = bounds.rect;

            x1 = Math.min(rect.x, x1);
            y1 = Math.min(rect.y, y1);
            x2 = Math.max(rect.x + rect.width, x2);
            y2 = Math.max(rect.y + rect.height, y2);
            if (bounds.nonscaling) nonscaling = true;
          }
        }

        return {
          rect: isFinite(x1) ? new Rectangle(x1, y1, x2 - x1, y2 - y1) : new Rectangle(),
          nonscaling: nonscaling
        };
      }
    }
  }), {
    beans: true,
    _decompose: function () {
      return this._applyMatrix ? null : this._decomposed || (this._decomposed = this._matrix.decompose());
    },
    getRotation: function () {
      var decomposed = this._decompose();

      return decomposed ? decomposed.rotation : 0;
    },
    setRotation: function (rotation) {
      var current = this.getRotation();

      if (current != null && rotation != null) {
        var decomposed = this._decomposed;
        this.rotate(rotation - current);

        if (decomposed) {
          decomposed.rotation = rotation;
          this._decomposed = decomposed;
        }
      }
    },
    getScaling: function () {
      var decomposed = this._decompose(),
          s = decomposed && decomposed.scaling;

      return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');
    },
    setScaling: function () {
      var current = this.getScaling(),
          scaling = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });

      if (current && scaling && !current.equals(scaling)) {
        var rotation = this.getRotation(),
            decomposed = this._decomposed,
            matrix = new Matrix(),
            isZero = Numerical.isZero;

        if (isZero(current.x) || isZero(current.y)) {
          matrix.translate(decomposed.translation);

          if (rotation) {
            matrix.rotate(rotation);
          }

          matrix.scale(scaling.x, scaling.y);

          this._matrix.set(matrix);
        } else {
          var center = this.getPosition(true);
          matrix.translate(center);
          if (rotation) matrix.rotate(rotation);
          matrix.scale(scaling.x / current.x, scaling.y / current.y);
          if (rotation) matrix.rotate(-rotation);
          matrix.translate(center.negate());
          this.transform(matrix);
        }

        if (decomposed) {
          decomposed.scaling = scaling;
          this._decomposed = decomposed;
        }
      }
    },
    getMatrix: function () {
      return this._matrix;
    },
    setMatrix: function () {
      var matrix = this._matrix;
      matrix.set.apply(matrix, arguments);
    },
    getGlobalMatrix: function (_dontClone) {
      var matrix = this._globalMatrix;

      if (matrix) {
        var parent = this._parent;
        var parents = [];

        while (parent) {
          if (!parent._globalMatrix) {
            matrix = null;

            for (var i = 0, l = parents.length; i < l; i++) {
              parents[i]._globalMatrix = null;
            }

            break;
          }

          parents.push(parent);
          parent = parent._parent;
        }
      }

      if (!matrix) {
        matrix = this._globalMatrix = this._matrix.clone();
        var parent = this._parent;
        if (parent) matrix.prepend(parent.getGlobalMatrix(true));
      }

      return _dontClone ? matrix : matrix.clone();
    },
    getViewMatrix: function () {
      return this.getGlobalMatrix().prepend(this.getView()._matrix);
    },
    getApplyMatrix: function () {
      return this._applyMatrix;
    },
    setApplyMatrix: function (apply) {
      if (this._applyMatrix = this._canApplyMatrix && !!apply) this.transform(null, true);
    },
    getTransformContent: '#getApplyMatrix',
    setTransformContent: '#setApplyMatrix'
  }, {
    getProject: function () {
      return this._project;
    },
    _setProject: function (project, installEvents) {
      if (this._project !== project) {
        if (this._project) this._installEvents(false);
        this._project = project;
        var children = this._children;

        for (var i = 0, l = children && children.length; i < l; i++) children[i]._setProject(project);

        installEvents = true;
      }

      if (installEvents) this._installEvents(true);
    },
    getView: function () {
      return this._project._view;
    },
    _installEvents: function _installEvents(install) {
      _installEvents.base.call(this, install);

      var children = this._children;

      for (var i = 0, l = children && children.length; i < l; i++) children[i]._installEvents(install);
    },
    getLayer: function () {
      var parent = this;

      while (parent = parent._parent) {
        if (parent instanceof Layer) return parent;
      }

      return null;
    },
    getParent: function () {
      return this._parent;
    },
    setParent: function (item) {
      return item.addChild(this);
    },
    _getOwner: '#getParent',
    getChildren: function () {
      return this._children;
    },
    setChildren: function (items) {
      this.removeChildren();
      this.addChildren(items);
    },
    getFirstChild: function () {
      return this._children && this._children[0] || null;
    },
    getLastChild: function () {
      return this._children && this._children[this._children.length - 1] || null;
    },
    getNextSibling: function () {
      var owner = this._getOwner();

      return owner && owner._children[this._index + 1] || null;
    },
    getPreviousSibling: function () {
      var owner = this._getOwner();

      return owner && owner._children[this._index - 1] || null;
    },
    getIndex: function () {
      return this._index;
    },
    equals: function (item) {
      return item === this || item && this._class === item._class && this._style.equals(item._style) && this._matrix.equals(item._matrix) && this._locked === item._locked && this._visible === item._visible && this._blendMode === item._blendMode && this._opacity === item._opacity && this._clipMask === item._clipMask && this._guide === item._guide && this._equals(item) || false;
    },
    _equals: function (item) {
      return Base.equals(this._children, item._children);
    },
    clone: function (options) {
      var copy = new this.constructor(Item.NO_INSERT),
          children = this._children,
          insert = Base.pick(options ? options.insert : undefined, options === undefined || options === true),
          deep = Base.pick(options ? options.deep : undefined, true);
      if (children) copy.copyAttributes(this);
      if (!children || deep) copy.copyContent(this);
      if (!children) copy.copyAttributes(this);
      if (insert) copy.insertAbove(this);
      var name = this._name,
          parent = this._parent;

      if (name && parent) {
        var children = parent._children,
            orig = name,
            i = 1;

        while (children[name]) name = orig + ' ' + i++;

        if (name !== orig) copy.setName(name);
      }

      return copy;
    },
    copyContent: function (source) {
      var children = source._children;

      for (var i = 0, l = children && children.length; i < l; i++) {
        this.addChild(children[i].clone(false), true);
      }
    },
    copyAttributes: function (source, excludeMatrix) {
      this.setStyle(source._style);
      var keys = ['_locked', '_visible', '_blendMode', '_opacity', '_clipMask', '_guide'];

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        if (source.hasOwnProperty(key)) this[key] = source[key];
      }

      if (!excludeMatrix) this._matrix.set(source._matrix, true);
      this.setApplyMatrix(source._applyMatrix);
      this.setPivot(source._pivot);
      this.setSelection(source._selection);
      var data = source._data,
          name = source._name;
      this._data = data ? Base.clone(data) : null;
      if (name) this.setName(name);
    },
    rasterize: function (resolution, insert) {
      var bounds = this.getStrokeBounds(),
          scale = (resolution || this.getView().getResolution()) / 72,
          topLeft = bounds.getTopLeft().floor(),
          bottomRight = bounds.getBottomRight().ceil(),
          size = new Size(bottomRight.subtract(topLeft)),
          raster = new Raster(Item.NO_INSERT);

      if (!size.isZero()) {
        var canvas = CanvasProvider.getCanvas(size.multiply(scale)),
            ctx = canvas.getContext('2d'),
            matrix = new Matrix().scale(scale).translate(topLeft.negate());
        ctx.save();
        matrix.applyToContext(ctx);
        this.draw(ctx, new Base({
          matrices: [matrix]
        }));
        ctx.restore();
        raster.setCanvas(canvas);
      }

      raster.transform(new Matrix().translate(topLeft.add(size.divide(2))).scale(1 / scale));
      if (insert === undefined || insert) raster.insertAbove(this);
      return raster;
    },
    contains: function () {
      var matrix = this._matrix;
      return matrix.isInvertible() && !!this._contains(matrix._inverseTransform(Point.read(arguments)));
    },
    _contains: function (point) {
      var children = this._children;

      if (children) {
        for (var i = children.length - 1; i >= 0; i--) {
          if (children[i].contains(point)) return true;
        }

        return false;
      }

      return point.isInside(this.getInternalBounds());
    },
    isInside: function () {
      return Rectangle.read(arguments).contains(this.getBounds());
    },
    _asPathItem: function () {
      return new Path.Rectangle({
        rectangle: this.getInternalBounds(),
        matrix: this._matrix,
        insert: false
      });
    },
    intersects: function (item, _matrix) {
      if (!(item instanceof Item)) return false;
      return this._asPathItem().getIntersections(item._asPathItem(), null, _matrix, true).length > 0;
    }
  }, new function () {
    function hitTest() {
      var args = arguments;
      return this._hitTest(Point.read(args), HitResult.getOptions(args));
    }

    function hitTestAll() {
      var args = arguments,
          point = Point.read(args),
          options = HitResult.getOptions(args),
          all = [];

      this._hitTest(point, new Base({
        all: all
      }, options));

      return all;
    }

    function hitTestChildren(point, options, viewMatrix, _exclude) {
      var children = this._children;

      if (children) {
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];

          var res = child !== _exclude && child._hitTest(point, options, viewMatrix);

          if (res && !options.all) return res;
        }
      }

      return null;
    }

    Project.inject({
      hitTest: hitTest,
      hitTestAll: hitTestAll,
      _hitTest: hitTestChildren
    });
    return {
      hitTest: hitTest,
      hitTestAll: hitTestAll,
      _hitTestChildren: hitTestChildren
    };
  }(), {
    _hitTest: function (point, options, parentViewMatrix) {
      if (this._locked || !this._visible || this._guide && !options.guides || this.isEmpty()) {
        return null;
      }

      var matrix = this._matrix,
          viewMatrix = parentViewMatrix ? parentViewMatrix.appended(matrix) : this.getGlobalMatrix().prepend(this.getView()._matrix),
          tolerance = Math.max(options.tolerance, 1e-12),
          tolerancePadding = options._tolerancePadding = new Size(Path._getStrokePadding(tolerance, matrix._shiftless().invert()));
      point = matrix._inverseTransform(point);

      if (!point || !this._children && !this.getBounds({
        internal: true,
        stroke: true,
        handle: true
      }).expand(tolerancePadding.multiply(2))._containsPoint(point)) {
        return null;
      }

      var checkSelf = !(options.guides && !this._guide || options.selected && !this.isSelected() || options.type && options.type !== Base.hyphenate(this._class) || options.class && !(this instanceof options.class)),
          match = options.match,
          that = this,
          bounds,
          res;

      function filter(hit) {
        if (hit && match && !match(hit)) hit = null;
        if (hit && options.all) options.all.push(hit);
        return hit;
      }

      function checkPoint(type, part) {
        var pt = part ? bounds['get' + part]() : that.getPosition();

        if (point.subtract(pt).divide(tolerancePadding).length <= 1) {
          return new HitResult(type, that, {
            name: part ? Base.hyphenate(part) : type,
            point: pt
          });
        }
      }

      var checkPosition = options.position,
          checkCenter = options.center,
          checkBounds = options.bounds;

      if (checkSelf && this._parent && (checkPosition || checkCenter || checkBounds)) {
        if (checkCenter || checkBounds) {
          bounds = this.getInternalBounds();
        }

        res = checkPosition && checkPoint('position') || checkCenter && checkPoint('center', 'Center');

        if (!res && checkBounds) {
          var points = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'];

          for (var i = 0; i < 8 && !res; i++) {
            res = checkPoint('bounds', points[i]);
          }
        }

        res = filter(res);
      }

      if (!res) {
        res = this._hitTestChildren(point, options, viewMatrix) || checkSelf && filter(this._hitTestSelf(point, options, viewMatrix, this.getStrokeScaling() ? null : viewMatrix._shiftless().invert())) || null;
      }

      if (res && res.point) {
        res.point = matrix.transform(res.point);
      }

      return res;
    },
    _hitTestSelf: function (point, options) {
      if (options.fill && this.hasFill() && this._contains(point)) return new HitResult('fill', this);
    },
    matches: function (name, compare) {
      function matchObject(obj1, obj2) {
        for (var i in obj1) {
          if (obj1.hasOwnProperty(i)) {
            var val1 = obj1[i],
                val2 = obj2[i];

            if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
              if (!matchObject(val1, val2)) return false;
            } else if (!Base.equals(val1, val2)) {
              return false;
            }
          }
        }

        return true;
      }

      var type = typeof name;

      if (type === 'object') {
        for (var key in name) {
          if (name.hasOwnProperty(key) && !this.matches(key, name[key])) return false;
        }

        return true;
      } else if (type === 'function') {
        return name(this);
      } else if (name === 'match') {
        return compare(this);
      } else {
        var value = /^(empty|editable)$/.test(name) ? this['is' + Base.capitalize(name)]() : name === 'type' ? Base.hyphenate(this._class) : this[name];

        if (name === 'class') {
          if (typeof compare === 'function') return this instanceof compare;
          value = this._class;
        }

        if (typeof compare === 'function') {
          return !!compare(value);
        } else if (compare) {
          if (compare.test) {
            return compare.test(value);
          } else if (Base.isPlainObject(compare)) {
            return matchObject(compare, value);
          }
        }

        return Base.equals(value, compare);
      }
    },
    getItems: function (options) {
      return Item._getItems(this, options, this._matrix);
    },
    getItem: function (options) {
      return Item._getItems(this, options, this._matrix, null, true)[0] || null;
    },
    statics: {
      _getItems: function _getItems(item, options, matrix, param, firstOnly) {
        if (!param) {
          var obj = typeof options === 'object' && options,
              overlapping = obj && obj.overlapping,
              inside = obj && obj.inside,
              bounds = overlapping || inside,
              rect = bounds && Rectangle.read([bounds]);
          param = {
            items: [],
            recursive: obj && obj.recursive !== false,
            inside: !!inside,
            overlapping: !!overlapping,
            rect: rect,
            path: overlapping && new Path.Rectangle({
              rectangle: rect,
              insert: false
            })
          };

          if (obj) {
            options = Base.filter({}, options, {
              recursive: true,
              inside: true,
              overlapping: true
            });
          }
        }

        var children = item._children,
            items = param.items,
            rect = param.rect;
        matrix = rect && (matrix || new Matrix());

        for (var i = 0, l = children && children.length; i < l; i++) {
          var child = children[i],
              childMatrix = matrix && matrix.appended(child._matrix),
              add = true;

          if (rect) {
            var bounds = child.getBounds(childMatrix);
            if (!rect.intersects(bounds)) continue;
            if (!(rect.contains(bounds) || param.overlapping && (bounds.contains(rect) || param.path.intersects(child, childMatrix)))) add = false;
          }

          if (add && child.matches(options)) {
            items.push(child);
            if (firstOnly) break;
          }

          if (param.recursive !== false) {
            _getItems(child, options, childMatrix, param, firstOnly);
          }

          if (firstOnly && items.length > 0) break;
        }

        return items;
      }
    }
  }, {
    importJSON: function (json) {
      var res = Base.importJSON(json, this);
      return res !== this ? this.addChild(res) : res;
    },
    addChild: function (item) {
      return this.insertChild(undefined, item);
    },
    insertChild: function (index, item) {
      var res = item ? this.insertChildren(index, [item]) : null;
      return res && res[0];
    },
    addChildren: function (items) {
      return this.insertChildren(this._children.length, items);
    },
    insertChildren: function (index, items) {
      var children = this._children;

      if (children && items && items.length > 0) {
        items = Base.slice(items);
        var inserted = {};

        for (var i = items.length - 1; i >= 0; i--) {
          var item = items[i],
              id = item && item._id;

          if (!item || inserted[id]) {
            items.splice(i, 1);
          } else {
            item._remove(false, true);

            inserted[id] = true;
          }
        }

        Base.splice(children, items, index, 0);
        var project = this._project,
            notifySelf = project._changes;

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i],
              name = item._name;
          item._parent = this;

          item._setProject(project, true);

          if (name) item.setName(name);
          if (notifySelf) item._changed(5);
        }

        this._changed(11);
      } else {
        items = null;
      }

      return items;
    },
    _insertItem: '#insertChild',
    _insertAt: function (item, offset) {
      var owner = item && item._getOwner(),
          res = item !== this && owner ? this : null;

      if (res) {
        res._remove(false, true);

        owner._insertItem(item._index + offset, res);
      }

      return res;
    },
    insertAbove: function (item) {
      return this._insertAt(item, 1);
    },
    insertBelow: function (item) {
      return this._insertAt(item, 0);
    },
    sendToBack: function () {
      var owner = this._getOwner();

      return owner ? owner._insertItem(0, this) : null;
    },
    bringToFront: function () {
      var owner = this._getOwner();

      return owner ? owner._insertItem(undefined, this) : null;
    },
    appendTop: '#addChild',
    appendBottom: function (item) {
      return this.insertChild(0, item);
    },
    moveAbove: '#insertAbove',
    moveBelow: '#insertBelow',
    addTo: function (owner) {
      return owner._insertItem(undefined, this);
    },
    copyTo: function (owner) {
      return this.clone(false).addTo(owner);
    },
    reduce: function (options) {
      var children = this._children;

      if (children && children.length === 1) {
        var child = children[0].reduce(options);

        if (this._parent) {
          child.insertAbove(this);
          this.remove();
        } else {
          child.remove();
        }

        return child;
      }

      return this;
    },
    _removeNamed: function () {
      var owner = this._getOwner();

      if (owner) {
        var children = owner._children,
            namedChildren = owner._namedChildren,
            name = this._name,
            namedArray = namedChildren[name],
            index = namedArray ? namedArray.indexOf(this) : -1;

        if (index !== -1) {
          if (children[name] == this) delete children[name];
          namedArray.splice(index, 1);

          if (namedArray.length) {
            children[name] = namedArray[0];
          } else {
            delete namedChildren[name];
          }
        }
      }
    },
    _remove: function (notifySelf, notifyParent) {
      var owner = this._getOwner(),
          project = this._project,
          index = this._index;

      if (this._style) this._style._dispose();

      if (owner) {
        if (this._name) this._removeNamed();

        if (index != null) {
          if (project._activeLayer === this) project._activeLayer = this.getNextSibling() || this.getPreviousSibling();
          Base.splice(owner._children, null, index, 1);
        }

        this._installEvents(false);

        if (notifySelf && project._changes) this._changed(5);
        if (notifyParent) owner._changed(11, this);
        this._parent = null;
        return true;
      }

      return false;
    },
    remove: function () {
      return this._remove(true, true);
    },
    replaceWith: function (item) {
      var ok = item && item.insertBelow(this);
      if (ok) this.remove();
      return ok;
    },
    removeChildren: function (start, end) {
      if (!this._children) return null;
      start = start || 0;
      end = Base.pick(end, this._children.length);
      var removed = Base.splice(this._children, null, start, end - start);

      for (var i = removed.length - 1; i >= 0; i--) {
        removed[i]._remove(true, false);
      }

      if (removed.length > 0) this._changed(11);
      return removed;
    },
    clear: '#removeChildren',
    reverseChildren: function () {
      if (this._children) {
        this._children.reverse();

        for (var i = 0, l = this._children.length; i < l; i++) this._children[i]._index = i;

        this._changed(11);
      }
    },
    isEmpty: function (recursively) {
      var children = this._children;
      var numChildren = children ? children.length : 0;

      if (recursively) {
        for (var i = 0; i < numChildren; i++) {
          if (!children[i].isEmpty(recursively)) {
            return false;
          }
        }

        return true;
      }

      return !numChildren;
    },
    isEditable: function () {
      var item = this;

      while (item) {
        if (!item._visible || item._locked) return false;
        item = item._parent;
      }

      return true;
    },
    hasFill: function () {
      return this.getStyle().hasFill();
    },
    hasStroke: function () {
      return this.getStyle().hasStroke();
    },
    hasShadow: function () {
      return this.getStyle().hasShadow();
    },
    _getOrder: function (item) {
      function getList(item) {
        var list = [];

        do {
          list.unshift(item);
        } while (item = item._parent);

        return list;
      }

      var list1 = getList(this),
          list2 = getList(item);

      for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
        if (list1[i] != list2[i]) {
          return list1[i]._index < list2[i]._index ? 1 : -1;
        }
      }

      return 0;
    },
    hasChildren: function () {
      return this._children && this._children.length > 0;
    },
    isInserted: function () {
      return this._parent ? this._parent.isInserted() : false;
    },
    isAbove: function (item) {
      return this._getOrder(item) === -1;
    },
    isBelow: function (item) {
      return this._getOrder(item) === 1;
    },
    isParent: function (item) {
      return this._parent === item;
    },
    isChild: function (item) {
      return item && item._parent === this;
    },
    isDescendant: function (item) {
      var parent = this;

      while (parent = parent._parent) {
        if (parent === item) return true;
      }

      return false;
    },
    isAncestor: function (item) {
      return item ? item.isDescendant(this) : false;
    },
    isSibling: function (item) {
      return this._parent === item._parent;
    },
    isGroupedWith: function (item) {
      var parent = this._parent;

      while (parent) {
        if (parent._parent && /^(Group|Layer|CompoundPath)$/.test(parent._class) && item.isDescendant(parent)) return true;
        parent = parent._parent;
      }

      return false;
    }
  }, Base.each(['rotate', 'scale', 'shear', 'skew'], function (key) {
    var rotate = key === 'rotate';

    this[key] = function () {
      var args = arguments,
          value = (rotate ? Base : Point).read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      return this.transform(new Matrix()[key](value, center || this.getPosition(true)));
    };
  }, {
    translate: function () {
      var mx = new Matrix();
      return this.transform(mx.translate.apply(mx, arguments));
    },
    transform: function (matrix, _applyRecursively, _setApplyMatrix) {
      var _matrix = this._matrix,
          transformMatrix = matrix && !matrix.isIdentity(),
          applyMatrix = _setApplyMatrix && this._canApplyMatrix || this._applyMatrix && (transformMatrix || !_matrix.isIdentity() || _applyRecursively && this._children);
      if (!transformMatrix && !applyMatrix) return this;

      if (transformMatrix) {
        if (!matrix.isInvertible() && _matrix.isInvertible()) _matrix._backup = _matrix.getValues();

        _matrix.prepend(matrix, true);

        var style = this._style,
            fillColor = style.getFillColor(true),
            strokeColor = style.getStrokeColor(true);
        if (fillColor) fillColor.transform(matrix);
        if (strokeColor) strokeColor.transform(matrix);
      }

      if (applyMatrix && (applyMatrix = this._transformContent(_matrix, _applyRecursively, _setApplyMatrix))) {
        var pivot = this._pivot;
        if (pivot) _matrix._transformPoint(pivot, pivot, true);

        _matrix.reset(true);

        if (_setApplyMatrix && this._canApplyMatrix) this._applyMatrix = true;
      }

      var bounds = this._bounds,
          position = this._position;

      if (transformMatrix || applyMatrix) {
        this._changed(25);
      }

      var decomp = transformMatrix && bounds && matrix.decompose();

      if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
        for (var key in bounds) {
          var cache = bounds[key];

          if (cache.nonscaling) {
            delete bounds[key];
          } else if (applyMatrix || !cache.internal) {
            var rect = cache.rect;

            matrix._transformBounds(rect, rect);
          }
        }

        this._bounds = bounds;

        var cached = bounds[this._getBoundsCacheKey(this._boundsOptions || {})];

        if (cached) {
          this._position = this._getPositionFromBounds(cached.rect);
        }
      } else if (transformMatrix && position && this._pivot) {
        this._position = matrix._transformPoint(position, position);
      }

      return this;
    },
    _transformContent: function (matrix, applyRecursively, setApplyMatrix) {
      var children = this._children;

      if (children) {
        for (var i = 0, l = children.length; i < l; i++) {
          children[i].transform(matrix, applyRecursively, setApplyMatrix);
        }

        return true;
      }
    },
    globalToLocal: function () {
      return this.getGlobalMatrix(true)._inverseTransform(Point.read(arguments));
    },
    localToGlobal: function () {
      return this.getGlobalMatrix(true)._transformPoint(Point.read(arguments));
    },
    parentToLocal: function () {
      return this._matrix._inverseTransform(Point.read(arguments));
    },
    localToParent: function () {
      return this._matrix._transformPoint(Point.read(arguments));
    },
    fitBounds: function (rectangle, fill) {
      rectangle = Rectangle.read(arguments);
      var bounds = this.getBounds(),
          itemRatio = bounds.height / bounds.width,
          rectRatio = rectangle.height / rectangle.width,
          scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio) ? rectangle.width / bounds.width : rectangle.height / bounds.height,
          newBounds = new Rectangle(new Point(), new Size(bounds.width * scale, bounds.height * scale));
      newBounds.setCenter(rectangle.getCenter());
      this.setBounds(newBounds);
    }
  }), {
    _setStyles: function (ctx, param, viewMatrix) {
      var style = this._style,
          matrix = this._matrix;

      if (style.hasFill()) {
        ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);
      }

      if (style.hasStroke()) {
        ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);
        ctx.lineWidth = style.getStrokeWidth();
        var strokeJoin = style.getStrokeJoin(),
            strokeCap = style.getStrokeCap(),
            miterLimit = style.getMiterLimit();
        if (strokeJoin) ctx.lineJoin = strokeJoin;
        if (strokeCap) ctx.lineCap = strokeCap;
        if (miterLimit) ctx.miterLimit = miterLimit;

        if (paper.support.nativeDash) {
          var dashArray = style.getDashArray(),
              dashOffset = style.getDashOffset();

          if (dashArray && dashArray.length) {
            if ('setLineDash' in ctx) {
              ctx.setLineDash(dashArray);
              ctx.lineDashOffset = dashOffset;
            } else {
              ctx.mozDash = dashArray;
              ctx.mozDashOffset = dashOffset;
            }
          }
        }
      }

      if (style.hasShadow()) {
        var pixelRatio = param.pixelRatio || 1,
            mx = viewMatrix._shiftless().prepend(new Matrix().scale(pixelRatio, pixelRatio)),
            blur = mx.transform(new Point(style.getShadowBlur(), 0)),
            offset = mx.transform(this.getShadowOffset());

        ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
        ctx.shadowBlur = blur.getLength();
        ctx.shadowOffsetX = offset.x;
        ctx.shadowOffsetY = offset.y;
      }
    },
    draw: function (ctx, param, parentStrokeMatrix) {
      var updateVersion = this._updateVersion = this._project._updateVersion;
      if (!this._visible || this._opacity === 0) return;
      var matrices = param.matrices,
          viewMatrix = param.viewMatrix,
          matrix = this._matrix,
          globalMatrix = matrices[matrices.length - 1].appended(matrix);
      if (!globalMatrix.isInvertible()) return;
      viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix) : globalMatrix;
      matrices.push(globalMatrix);

      if (param.updateMatrix) {
        this._globalMatrix = globalMatrix;
      }

      var blendMode = this._blendMode,
          opacity = Numerical.clamp(this._opacity, 0, 1),
          normalBlend = blendMode === 'normal',
          nativeBlend = BlendMode.nativeModes[blendMode],
          direct = normalBlend && opacity === 1 || param.dontStart || param.clip || (nativeBlend || normalBlend && opacity < 1) && this._canComposite(),
          pixelRatio = param.pixelRatio || 1,
          mainCtx,
          itemOffset,
          prevOffset;

      if (!direct) {
        var bounds = this.getStrokeBounds(viewMatrix);

        if (!bounds.width || !bounds.height) {
          matrices.pop();
          return;
        }

        prevOffset = param.offset;
        itemOffset = param.offset = bounds.getTopLeft().floor();
        mainCtx = ctx;
        ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1).multiply(pixelRatio));
        if (pixelRatio !== 1) ctx.scale(pixelRatio, pixelRatio);
      }

      ctx.save();
      var strokeMatrix = parentStrokeMatrix ? parentStrokeMatrix.appended(matrix) : this._canScaleStroke && !this.getStrokeScaling(true) && viewMatrix,
          clip = !direct && param.clipItem,
          transform = !strokeMatrix || clip;

      if (direct) {
        ctx.globalAlpha = opacity;
        if (nativeBlend) ctx.globalCompositeOperation = blendMode;
      } else if (transform) {
        ctx.translate(-itemOffset.x, -itemOffset.y);
      }

      if (transform) {
        (direct ? matrix : viewMatrix).applyToContext(ctx);
      }

      if (clip) {
        param.clipItem.draw(ctx, param.extend({
          clip: true
        }));
      }

      if (strokeMatrix) {
        ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        var offset = param.offset;
        if (offset) ctx.translate(-offset.x, -offset.y);
      }

      this._draw(ctx, param, viewMatrix, strokeMatrix);

      ctx.restore();
      matrices.pop();

      if (param.clip && !param.dontFinish) {
        ctx.clip(this.getFillRule());
      }

      if (!direct) {
        BlendMode.process(blendMode, ctx, mainCtx, opacity, itemOffset.subtract(prevOffset).multiply(pixelRatio));
        CanvasProvider.release(ctx);
        param.offset = prevOffset;
      }
    },
    _isUpdated: function (updateVersion) {
      var parent = this._parent;
      if (parent instanceof CompoundPath) return parent._isUpdated(updateVersion);
      var updated = this._updateVersion === updateVersion;

      if (!updated && parent && parent._visible && parent._isUpdated(updateVersion)) {
        this._updateVersion = updateVersion;
        updated = true;
      }

      return updated;
    },
    _drawSelection: function (ctx, matrix, size, selectionItems, updateVersion) {
      var selection = this._selection,
          itemSelected = selection & 1,
          boundsSelected = selection & 2 || itemSelected && this._selectBounds,
          positionSelected = selection & 4;
      if (!this._drawSelected) itemSelected = false;

      if ((itemSelected || boundsSelected || positionSelected) && this._isUpdated(updateVersion)) {
        var layer,
            color = this.getSelectedColor(true) || (layer = this.getLayer()) && layer.getSelectedColor(true),
            mx = matrix.appended(this.getGlobalMatrix(true)),
            half = size / 2;
        ctx.strokeStyle = ctx.fillStyle = color ? color.toCanvasStyle(ctx) : '#009dec';
        if (itemSelected) this._drawSelected(ctx, mx, selectionItems);

        if (positionSelected) {
          var pos = this.getPosition(true),
              parent = this._parent,
              point = parent ? parent.localToGlobal(pos) : pos,
              x = point.x,
              y = point.y;
          ctx.beginPath();
          ctx.arc(x, y, half, 0, Math.PI * 2, true);
          ctx.stroke();
          var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],
              start = half,
              end = size + 1;

          for (var i = 0; i < 4; i++) {
            var delta = deltas[i],
                dx = delta[0],
                dy = delta[1];
            ctx.moveTo(x + dx * start, y + dy * start);
            ctx.lineTo(x + dx * end, y + dy * end);
            ctx.stroke();
          }
        }

        if (boundsSelected) {
          var coords = mx._transformCorners(this.getInternalBounds());

          ctx.beginPath();

          for (var i = 0; i < 8; i++) {
            ctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
          }

          ctx.closePath();
          ctx.stroke();

          for (var i = 0; i < 8; i++) {
            ctx.fillRect(coords[i] - half, coords[++i] - half, size, size);
          }
        }
      }
    },
    _canComposite: function () {
      return false;
    }
  }, Base.each(['down', 'drag', 'up', 'move'], function (key) {
    this['removeOn' + Base.capitalize(key)] = function () {
      var hash = {};
      hash[key] = true;
      return this.removeOn(hash);
    };
  }, {
    removeOn: function (obj) {
      for (var name in obj) {
        if (obj[name]) {
          var key = 'mouse' + name,
              project = this._project,
              sets = project._removeSets = project._removeSets || {};
          sets[key] = sets[key] || {};
          sets[key][this._id] = this;
        }
      }

      return this;
    }
  }), {
    tween: function (from, to, options) {
      if (!options) {
        options = to;
        to = from;
        from = null;

        if (!options) {
          options = to;
          to = null;
        }
      }

      var easing = options && options.easing,
          start = options && options.start,
          duration = options != null && (typeof options === 'number' ? options : options.duration),
          tween = new Tween(this, from, to, duration, easing, start);

      function onFrame(event) {
        tween._handleFrame(event.time * 1000);

        if (!tween.running) {
          this.off('frame', onFrame);
        }
      }

      if (duration) {
        this.on('frame', onFrame);
      }

      return tween;
    },
    tweenTo: function (to, options) {
      return this.tween(null, to, options);
    },
    tweenFrom: function (from, options) {
      return this.tween(from, null, options);
    }
  });
  var Group = Item.extend({
    _class: 'Group',
    _selectBounds: false,
    _selectChildren: true,
    _serializeFields: {
      children: []
    },
    initialize: function Group(arg) {
      this._children = [];
      this._namedChildren = {};
      if (!this._initialize(arg)) this.addChildren(Array.isArray(arg) ? arg : arguments);
    },
    _changed: function _changed(flags) {
      _changed.base.call(this, flags);

      if (flags & 2050) {
        this._clipItem = undefined;
      }
    },
    _getClipItem: function () {
      var clipItem = this._clipItem;

      if (clipItem === undefined) {
        clipItem = null;
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) {
          if (children[i]._clipMask) {
            clipItem = children[i];
            break;
          }
        }

        this._clipItem = clipItem;
      }

      return clipItem;
    },
    isClipped: function () {
      return !!this._getClipItem();
    },
    setClipped: function (clipped) {
      var child = this.getFirstChild();
      if (child) child.setClipMask(clipped);
    },
    _getBounds: function _getBounds(matrix, options) {
      var clipItem = this._getClipItem();

      return clipItem ? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix), Base.set({}, options, {
        stroke: false
      })) : _getBounds.base.call(this, matrix, options);
    },
    _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
      var clipItem = this._getClipItem();

      return (!clipItem || clipItem.contains(point)) && _hitTestChildren.base.call(this, point, options, viewMatrix, clipItem);
    },
    _draw: function (ctx, param) {
      var clip = param.clip,
          clipItem = !clip && this._getClipItem();

      param = param.extend({
        clipItem: clipItem,
        clip: false
      });

      if (clip) {
        ctx.beginPath();
        param.dontStart = param.dontFinish = true;
      } else if (clipItem) {
        clipItem.draw(ctx, param.extend({
          clip: true
        }));
      }

      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        var item = children[i];
        if (item !== clipItem) item.draw(ctx, param);
      }
    }
  });
  var Layer = Group.extend({
    _class: 'Layer',
    initialize: function Layer() {
      Group.apply(this, arguments);
    },
    _getOwner: function () {
      return this._parent || this._index != null && this._project;
    },
    isInserted: function isInserted() {
      return this._parent ? isInserted.base.call(this) : this._index != null;
    },
    activate: function () {
      this._project._activeLayer = this;
    },
    _hitTestSelf: function () {}
  });
  var Shape = Item.extend({
    _class: 'Shape',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _canScaleStroke: true,
    _serializeFields: {
      type: null,
      size: null,
      radius: null
    },
    initialize: function Shape(props, point) {
      this._initialize(props, point);
    },
    _equals: function (item) {
      return this._type === item._type && this._size.equals(item._size) && Base.equals(this._radius, item._radius);
    },
    copyContent: function (source) {
      this.setType(source._type);
      this.setSize(source._size);
      this.setRadius(source._radius);
    },
    getType: function () {
      return this._type;
    },
    setType: function (type) {
      this._type = type;
    },
    getShape: '#getType',
    setShape: '#setType',
    getSize: function () {
      var size = this._size;
      return new LinkedSize(size.width, size.height, this, 'setSize');
    },
    setSize: function () {
      var size = Size.read(arguments);

      if (!this._size) {
        this._size = size.clone();
      } else if (!this._size.equals(size)) {
        var type = this._type,
            width = size.width,
            height = size.height;

        if (type === 'rectangle') {
          this._radius.set(Size.min(this._radius, size.divide(2).abs()));
        } else if (type === 'circle') {
          width = height = (width + height) / 2;
          this._radius = width / 2;
        } else if (type === 'ellipse') {
          this._radius._set(width / 2, height / 2);
        }

        this._size._set(width, height);

        this._changed(9);
      }
    },
    getRadius: function () {
      var rad = this._radius;
      return this._type === 'circle' ? rad : new LinkedSize(rad.width, rad.height, this, 'setRadius');
    },
    setRadius: function (radius) {
      var type = this._type;

      if (type === 'circle') {
        if (radius === this._radius) return;
        var size = radius * 2;
        this._radius = radius;

        this._size._set(size, size);
      } else {
        radius = Size.read(arguments);

        if (!this._radius) {
          this._radius = radius.clone();
        } else {
          if (this._radius.equals(radius)) return;

          this._radius.set(radius);

          if (type === 'rectangle') {
            var size = Size.max(this._size, radius.multiply(2));

            this._size.set(size);
          } else if (type === 'ellipse') {
            this._size._set(radius.width * 2, radius.height * 2);
          }
        }
      }

      this._changed(9);
    },
    isEmpty: function () {
      return false;
    },
    toPath: function (insert) {
      var path = new Path[Base.capitalize(this._type)]({
        center: new Point(),
        size: this._size,
        radius: this._radius,
        insert: false
      });
      path.copyAttributes(this);
      if (paper.settings.applyMatrix) path.setApplyMatrix(true);
      if (insert === undefined || insert) path.insertAbove(this);
      return path;
    },
    toShape: '#clone',
    _asPathItem: function () {
      return this.toPath(false);
    },
    _draw: function (ctx, param, viewMatrix, strokeMatrix) {
      var style = this._style,
          hasFill = style.hasFill(),
          hasStroke = style.hasStroke(),
          dontPaint = param.dontFinish || param.clip,
          untransformed = !strokeMatrix;

      if (hasFill || hasStroke || dontPaint) {
        var type = this._type,
            radius = this._radius,
            isCircle = type === 'circle';
        if (!param.dontStart) ctx.beginPath();

        if (untransformed && isCircle) {
          ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
        } else {
          var rx = isCircle ? radius : radius.width,
              ry = isCircle ? radius : radius.height,
              size = this._size,
              width = size.width,
              height = size.height;

          if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
            ctx.rect(-width / 2, -height / 2, width, height);
          } else {
            var x = width / 2,
                y = height / 2,
                kappa = 1 - 0.5522847498307936,
                cx = rx * kappa,
                cy = ry * kappa,
                c = [-x, -y + ry, -x, -y + cy, -x + cx, -y, -x + rx, -y, x - rx, -y, x - cx, -y, x, -y + cy, x, -y + ry, x, y - ry, x, y - cy, x - cx, y, x - rx, y, -x + rx, y, -x + cx, y, -x, y - cy, -x, y - ry];
            if (strokeMatrix) strokeMatrix.transform(c, c, 32);
            ctx.moveTo(c[0], c[1]);
            ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
            if (x !== rx) ctx.lineTo(c[8], c[9]);
            ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
            if (y !== ry) ctx.lineTo(c[16], c[17]);
            ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
            if (x !== rx) ctx.lineTo(c[24], c[25]);
            ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
          }
        }

        ctx.closePath();
      }

      if (!dontPaint && (hasFill || hasStroke)) {
        this._setStyles(ctx, param, viewMatrix);

        if (hasFill) {
          ctx.fill(style.getFillRule());
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (hasStroke) ctx.stroke();
      }
    },
    _canComposite: function () {
      return !(this.hasFill() && this.hasStroke());
    },
    _getBounds: function (matrix, options) {
      var rect = new Rectangle(this._size).setCenter(0, 0),
          style = this._style,
          strokeWidth = options.stroke && style.hasStroke() && style.getStrokeWidth();
      if (matrix) rect = matrix._transformBounds(rect);
      return strokeWidth ? rect.expand(Path._getStrokePadding(strokeWidth, this._getStrokeMatrix(matrix, options))) : rect;
    }
  }, new function () {
    function getCornerCenter(that, point, expand) {
      var radius = that._radius;

      if (!radius.isZero()) {
        var halfSize = that._size.divide(2);

        for (var q = 1; q <= 4; q++) {
          var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),
              corner = dir.multiply(halfSize),
              center = corner.subtract(dir.multiply(radius)),
              rect = new Rectangle(expand ? corner.add(dir.multiply(expand)) : corner, center);
          if (rect.contains(point)) return {
            point: center,
            quadrant: q
          };
        }
      }
    }

    function isOnEllipseStroke(point, radius, padding, quadrant) {
      var vector = point.divide(radius);
      return (!quadrant || vector.isInQuadrant(quadrant)) && vector.subtract(vector.normalize()).multiply(radius).divide(padding).length <= 1;
    }

    return {
      _contains: function _contains(point) {
        if (this._type === 'rectangle') {
          var center = getCornerCenter(this, point);
          return center ? point.subtract(center.point).divide(this._radius).getLength() <= 1 : _contains.base.call(this, point);
        } else {
          return point.divide(this.size).getLength() <= 0.5;
        }
      },
      _hitTestSelf: function _hitTestSelf(point, options, viewMatrix, strokeMatrix) {
        var hit = false,
            style = this._style,
            hitStroke = options.stroke && style.hasStroke(),
            hitFill = options.fill && style.hasFill();

        if (hitStroke || hitFill) {
          var type = this._type,
              radius = this._radius,
              strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,
              strokePadding = options._tolerancePadding.add(Path._getStrokePadding(strokeRadius, !style.getStrokeScaling() && strokeMatrix));

          if (type === 'rectangle') {
            var padding = strokePadding.multiply(2),
                center = getCornerCenter(this, point, padding);

            if (center) {
              hit = isOnEllipseStroke(point.subtract(center.point), radius, strokePadding, center.quadrant);
            } else {
              var rect = new Rectangle(this._size).setCenter(0, 0),
                  outer = rect.expand(padding),
                  inner = rect.expand(padding.negate());
              hit = outer._containsPoint(point) && !inner._containsPoint(point);
            }
          } else {
            hit = isOnEllipseStroke(point, radius, strokePadding);
          }
        }

        return hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this) : _hitTestSelf.base.apply(this, arguments);
      }
    };
  }(), {
    statics: new function () {
      function createShape(type, point, size, radius, args) {
        var item = Base.create(Shape.prototype);
        item._type = type;
        item._size = size;
        item._radius = radius;

        item._initialize(Base.getNamed(args), point);

        return item;
      }

      return {
        Circle: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              radius = Base.readNamed(args, 'radius');
          return createShape('circle', center, new Size(radius * 2), radius, args);
        },
        Rectangle: function () {
          var args = arguments,
              rect = Rectangle.readNamed(args, 'rectangle'),
              radius = Size.min(Size.readNamed(args, 'radius'), rect.getSize(true).divide(2));
          return createShape('rectangle', rect.getCenter(true), rect.getSize(true), radius, args);
        },
        Ellipse: function () {
          var args = arguments,
              ellipse = Shape._readEllipse(args),
              radius = ellipse.radius;

          return createShape('ellipse', ellipse.center, radius.multiply(2), radius, args);
        },
        _readEllipse: function (args) {
          var center, radius;

          if (Base.hasNamed(args, 'radius')) {
            center = Point.readNamed(args, 'center');
            radius = Size.readNamed(args, 'radius');
          } else {
            var rect = Rectangle.readNamed(args, 'rectangle');
            center = rect.getCenter(true);
            radius = rect.getSize(true).divide(2);
          }

          return {
            center: center,
            radius: radius
          };
        }
      };
    }()
  });
  var Raster = Item.extend({
    _class: 'Raster',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsOptions: {
      stroke: false,
      handle: false
    },
    _serializeFields: {
      crossOrigin: null,
      source: null
    },
    _prioritize: ['crossOrigin'],
    _smoothing: true,
    beans: true,
    initialize: function Raster(source, position) {
      if (!this._initialize(source, position !== undefined && Point.read(arguments))) {
        var image,
            type = typeof source,
            object = type === 'string' ? document.getElementById(source) : type === 'object' ? source : null;

        if (object && object !== Item.NO_INSERT) {
          if (object.getContext || object.naturalHeight != null) {
            image = object;
          } else if (object) {
            var size = Size.read(arguments);

            if (!size.isZero()) {
              image = CanvasProvider.getCanvas(size);
            }
          }
        }

        if (image) {
          this.setImage(image);
        } else {
          this.setSource(source);
        }
      }

      if (!this._size) {
        this._size = new Size();
        this._loaded = false;
      }
    },
    _equals: function (item) {
      return this.getSource() === item.getSource();
    },
    copyContent: function (source) {
      var image = source._image,
          canvas = source._canvas;

      if (image) {
        this._setImage(image);
      } else if (canvas) {
        var copyCanvas = CanvasProvider.getCanvas(source._size);
        copyCanvas.getContext('2d').drawImage(canvas, 0, 0);

        this._setImage(copyCanvas);
      }

      this._crossOrigin = source._crossOrigin;
    },
    getSize: function () {
      var size = this._size;
      return new LinkedSize(size ? size.width : 0, size ? size.height : 0, this, 'setSize');
    },
    setSize: function () {
      var size = Size.read(arguments);

      if (!size.equals(this._size)) {
        if (size.width > 0 && size.height > 0) {
          var element = this.getElement();

          this._setImage(CanvasProvider.getCanvas(size));

          if (element) this.getContext(true).drawImage(element, 0, 0, size.width, size.height);
        } else {
          if (this._canvas) CanvasProvider.release(this._canvas);
          this._size = size.clone();
        }
      }
    },
    getWidth: function () {
      return this._size ? this._size.width : 0;
    },
    setWidth: function (width) {
      this.setSize(width, this.getHeight());
    },
    getHeight: function () {
      return this._size ? this._size.height : 0;
    },
    setHeight: function (height) {
      this.setSize(this.getWidth(), height);
    },
    getLoaded: function () {
      return this._loaded;
    },
    isEmpty: function () {
      var size = this._size;
      return !size || size.width === 0 && size.height === 0;
    },
    getResolution: function () {
      var matrix = this._matrix,
          orig = new Point(0, 0).transform(matrix),
          u = new Point(1, 0).transform(matrix).subtract(orig),
          v = new Point(0, 1).transform(matrix).subtract(orig);
      return new Size(72 / u.getLength(), 72 / v.getLength());
    },
    getPpi: '#getResolution',
    getImage: function () {
      return this._image;
    },
    setImage: function (image) {
      var that = this;

      function emit(event) {
        var view = that.getView(),
            type = event && event.type || 'load';

        if (view && that.responds(type)) {
          paper = view._scope;
          that.emit(type, new Event(event));
        }
      }

      this._setImage(image);

      if (this._loaded) {
        setTimeout(emit, 0);
      } else if (image) {
        DomEvent.add(image, {
          load: function (event) {
            that._setImage(image);

            emit(event);
          },
          error: emit
        });
      }
    },
    _setImage: function (image) {
      if (this._canvas) CanvasProvider.release(this._canvas);

      if (image && image.getContext) {
        this._image = null;
        this._canvas = image;
        this._loaded = true;
      } else {
        this._image = image;
        this._canvas = null;
        this._loaded = !!(image && image.src && image.complete);
      }

      this._size = new Size(image ? image.naturalWidth || image.width : 0, image ? image.naturalHeight || image.height : 0);
      this._context = null;

      this._changed(1033);
    },
    getCanvas: function () {
      if (!this._canvas) {
        var ctx = CanvasProvider.getContext(this._size);

        try {
          if (this._image) ctx.drawImage(this._image, 0, 0);
          this._canvas = ctx.canvas;
        } catch (e) {
          CanvasProvider.release(ctx);
        }
      }

      return this._canvas;
    },
    setCanvas: '#setImage',
    getContext: function (_change) {
      if (!this._context) this._context = this.getCanvas().getContext('2d');

      if (_change) {
        this._image = null;

        this._changed(1025);
      }

      return this._context;
    },
    setContext: function (context) {
      this._context = context;
    },
    getSource: function () {
      var image = this._image;
      return image && image.src || this.toDataURL();
    },
    setSource: function (src) {
      var image = new self.Image(),
          crossOrigin = this._crossOrigin;
      if (crossOrigin) image.crossOrigin = crossOrigin;
      if (src) image.src = src;
      this.setImage(image);
    },
    getCrossOrigin: function () {
      var image = this._image;
      return image && image.crossOrigin || this._crossOrigin || '';
    },
    setCrossOrigin: function (crossOrigin) {
      this._crossOrigin = crossOrigin;
      var image = this._image;
      if (image) image.crossOrigin = crossOrigin;
    },
    getSmoothing: function () {
      return this._smoothing;
    },
    setSmoothing: function (smoothing) {
      this._smoothing = smoothing;

      this._changed(257);
    },
    getElement: function () {
      return this._canvas || this._loaded && this._image;
    }
  }, {
    beans: false,
    getSubCanvas: function () {
      var rect = Rectangle.read(arguments),
          ctx = CanvasProvider.getContext(rect.getSize());
      ctx.drawImage(this.getCanvas(), rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
      return ctx.canvas;
    },
    getSubRaster: function () {
      var rect = Rectangle.read(arguments),
          raster = new Raster(Item.NO_INSERT);

      raster._setImage(this.getSubCanvas(rect));

      raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));

      raster._matrix.prepend(this._matrix);

      raster.insertAbove(this);
      return raster;
    },
    toDataURL: function () {
      var image = this._image,
          src = image && image.src;
      if (/^data:/.test(src)) return src;
      var canvas = this.getCanvas();
      return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
    },
    drawImage: function (image) {
      var point = Point.read(arguments, 1);
      this.getContext(true).drawImage(image, point.x, point.y);
    },
    getAverageColor: function (object) {
      var bounds, path;

      if (!object) {
        bounds = this.getBounds();
      } else if (object instanceof PathItem) {
        path = object;
        bounds = object.getBounds();
      } else if (typeof object === 'object') {
        if ('width' in object) {
          bounds = new Rectangle(object);
        } else if ('x' in object) {
          bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
        }
      }

      if (!bounds) return null;
      var sampleSize = 32,
          width = Math.min(bounds.width, sampleSize),
          height = Math.min(bounds.height, sampleSize);
      var ctx = Raster._sampleContext;

      if (!ctx) {
        ctx = Raster._sampleContext = CanvasProvider.getContext(new Size(sampleSize));
      } else {
        ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
      }

      ctx.save();
      var matrix = new Matrix().scale(width / bounds.width, height / bounds.height).translate(-bounds.x, -bounds.y);
      matrix.applyToContext(ctx);
      if (path) path.draw(ctx, new Base({
        clip: true,
        matrices: [matrix]
      }));

      this._matrix.applyToContext(ctx);

      var element = this.getElement(),
          size = this._size;
      if (element) ctx.drawImage(element, -size.width / 2, -size.height / 2);
      ctx.restore();
      var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width), Math.ceil(height)).data,
          channels = [0, 0, 0],
          total = 0;

      for (var i = 0, l = pixels.length; i < l; i += 4) {
        var alpha = pixels[i + 3];
        total += alpha;
        alpha /= 255;
        channels[0] += pixels[i] * alpha;
        channels[1] += pixels[i + 1] * alpha;
        channels[2] += pixels[i + 2] * alpha;
      }

      for (var i = 0; i < 3; i++) channels[i] /= total;

      return total ? Color.read(channels) : null;
    },
    getPixel: function () {
      var point = Point.read(arguments);
      var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
      return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255], data[3] / 255);
    },
    setPixel: function () {
      var args = arguments,
          point = Point.read(args),
          color = Color.read(args),
          components = color._convert('rgb'),
          alpha = color._alpha,
          ctx = this.getContext(true),
          imageData = ctx.createImageData(1, 1),
          data = imageData.data;

      data[0] = components[0] * 255;
      data[1] = components[1] * 255;
      data[2] = components[2] * 255;
      data[3] = alpha != null ? alpha * 255 : 255;
      ctx.putImageData(imageData, point.x, point.y);
    },
    clear: function () {
      var size = this._size;
      this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);
    },
    createImageData: function () {
      var size = Size.read(arguments);
      return this.getContext().createImageData(size.width, size.height);
    },
    getImageData: function () {
      var rect = Rectangle.read(arguments);
      if (rect.isEmpty()) rect = new Rectangle(this._size);
      return this.getContext().getImageData(rect.x, rect.y, rect.width, rect.height);
    },
    setImageData: function (data) {
      var point = Point.read(arguments, 1);
      this.getContext(true).putImageData(data, point.x, point.y);
    },
    _getBounds: function (matrix, options) {
      var rect = new Rectangle(this._size).setCenter(0, 0);
      return matrix ? matrix._transformBounds(rect) : rect;
    },
    _hitTestSelf: function (point) {
      if (this._contains(point)) {
        var that = this;
        return new HitResult('pixel', that, {
          offset: point.add(that._size.divide(2)).round(),
          color: {
            get: function () {
              return that.getPixel(this.offset);
            }
          }
        });
      }
    },
    _draw: function (ctx, param, viewMatrix) {
      var element = this.getElement();

      if (element && element.width > 0 && element.height > 0) {
        ctx.globalAlpha = Numerical.clamp(this._opacity, 0, 1);

        this._setStyles(ctx, param, viewMatrix);

        DomElement.setPrefixed(ctx, 'imageSmoothingEnabled', this._smoothing);
        ctx.drawImage(element, -this._size.width / 2, -this._size.height / 2);
      }
    },
    _canComposite: function () {
      return true;
    }
  });
  var SymbolItem = Item.extend({
    _class: 'SymbolItem',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsOptions: {
      stroke: true
    },
    _serializeFields: {
      symbol: null
    },
    initialize: function SymbolItem(arg0, arg1) {
      if (!this._initialize(arg0, arg1 !== undefined && Point.read(arguments, 1))) this.setDefinition(arg0 instanceof SymbolDefinition ? arg0 : new SymbolDefinition(arg0));
    },
    _equals: function (item) {
      return this._definition === item._definition;
    },
    copyContent: function (source) {
      this.setDefinition(source._definition);
    },
    getDefinition: function () {
      return this._definition;
    },
    setDefinition: function (definition) {
      this._definition = definition;

      this._changed(9);
    },
    getSymbol: '#getDefinition',
    setSymbol: '#setDefinition',
    isEmpty: function () {
      return this._definition._item.isEmpty();
    },
    _getBounds: function (matrix, options) {
      var item = this._definition._item;
      return item._getCachedBounds(item._matrix.prepended(matrix), options);
    },
    _hitTestSelf: function (point, options, viewMatrix) {
      var opts = options.extend({
        all: false
      });

      var res = this._definition._item._hitTest(point, opts, viewMatrix);

      if (res) res.item = this;
      return res;
    },
    _draw: function (ctx, param) {
      this._definition._item.draw(ctx, param);
    }
  });
  var SymbolDefinition = Base.extend({
    _class: 'SymbolDefinition',
    initialize: function SymbolDefinition(item, dontCenter) {
      this._id = UID.get();
      this.project = paper.project;
      if (item) this.setItem(item, dontCenter);
    },
    _serialize: function (options, dictionary) {
      return dictionary.add(this, function () {
        return Base.serialize([this._class, this._item], options, false, dictionary);
      });
    },
    _changed: function (flags) {
      if (flags & 8) Item._clearBoundsCache(this);
      if (flags & 1) this.project._changed(flags);
    },
    getItem: function () {
      return this._item;
    },
    setItem: function (item, _dontCenter) {
      if (item._symbol) item = item.clone();
      if (this._item) this._item._symbol = null;
      this._item = item;
      item.remove();
      item.setSelected(false);
      if (!_dontCenter) item.setPosition(new Point());
      item._symbol = this;

      this._changed(9);
    },
    getDefinition: '#getItem',
    setDefinition: '#setItem',
    place: function (position) {
      return new SymbolItem(this, position);
    },
    clone: function () {
      return new SymbolDefinition(this._item.clone(false));
    },
    equals: function (symbol) {
      return symbol === this || symbol && this._item.equals(symbol._item) || false;
    }
  });
  var HitResult = Base.extend({
    _class: 'HitResult',
    initialize: function HitResult(type, item, values) {
      this.type = type;
      this.item = item;
      if (values) this.inject(values);
    },
    statics: {
      getOptions: function (args) {
        var options = args && Base.read(args);
        return new Base({
          type: null,
          tolerance: paper.settings.hitTolerance,
          fill: !options,
          stroke: !options,
          segments: !options,
          handles: false,
          ends: false,
          position: false,
          center: false,
          bounds: false,
          guides: false,
          selected: false
        }, options);
      }
    }
  });
  var Segment = Base.extend({
    _class: 'Segment',
    beans: true,
    _selection: 0,
    initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
      var count = arguments.length,
          point,
          handleIn,
          handleOut,
          selection;

      if (count > 0) {
        if (arg0 == null || typeof arg0 === 'object') {
          if (count === 1 && arg0 && 'point' in arg0) {
            point = arg0.point;
            handleIn = arg0.handleIn;
            handleOut = arg0.handleOut;
            selection = arg0.selection;
          } else {
            point = arg0;
            handleIn = arg1;
            handleOut = arg2;
            selection = arg3;
          }
        } else {
          point = [arg0, arg1];
          handleIn = arg2 !== undefined ? [arg2, arg3] : null;
          handleOut = arg4 !== undefined ? [arg4, arg5] : null;
        }
      }

      new SegmentPoint(point, this, '_point');
      new SegmentPoint(handleIn, this, '_handleIn');
      new SegmentPoint(handleOut, this, '_handleOut');
      if (selection) this.setSelection(selection);
    },
    _serialize: function (options, dictionary) {
      var point = this._point,
          selection = this._selection,
          obj = selection || this.hasHandles() ? [point, this._handleIn, this._handleOut] : point;
      if (selection) obj.push(selection);
      return Base.serialize(obj, options, true, dictionary);
    },
    _changed: function (point) {
      var path = this._path;
      if (!path) return;
      var curves = path._curves,
          index = this._index,
          curve;

      if (curves) {
        if ((!point || point === this._point || point === this._handleIn) && (curve = index > 0 ? curves[index - 1] : path._closed ? curves[curves.length - 1] : null)) curve._changed();
        if ((!point || point === this._point || point === this._handleOut) && (curve = curves[index])) curve._changed();
      }

      path._changed(41);
    },
    getPoint: function () {
      return this._point;
    },
    setPoint: function () {
      this._point.set(Point.read(arguments));
    },
    getHandleIn: function () {
      return this._handleIn;
    },
    setHandleIn: function () {
      this._handleIn.set(Point.read(arguments));
    },
    getHandleOut: function () {
      return this._handleOut;
    },
    setHandleOut: function () {
      this._handleOut.set(Point.read(arguments));
    },
    hasHandles: function () {
      return !this._handleIn.isZero() || !this._handleOut.isZero();
    },
    isSmooth: function () {
      var handleIn = this._handleIn,
          handleOut = this._handleOut;
      return !handleIn.isZero() && !handleOut.isZero() && handleIn.isCollinear(handleOut);
    },
    clearHandles: function () {
      this._handleIn._set(0, 0);

      this._handleOut._set(0, 0);
    },
    getSelection: function () {
      return this._selection;
    },
    setSelection: function (selection) {
      var oldSelection = this._selection,
          path = this._path;
      this._selection = selection = selection || 0;

      if (path && selection !== oldSelection) {
        path._updateSelection(this, oldSelection, selection);

        path._changed(257);
      }
    },
    _changeSelection: function (flag, selected) {
      var selection = this._selection;
      this.setSelection(selected ? selection | flag : selection & ~flag);
    },
    isSelected: function () {
      return !!(this._selection & 7);
    },
    setSelected: function (selected) {
      this._changeSelection(7, selected);
    },
    getIndex: function () {
      return this._index !== undefined ? this._index : null;
    },
    getPath: function () {
      return this._path || null;
    },
    getCurve: function () {
      var path = this._path,
          index = this._index;

      if (path) {
        if (index > 0 && !path._closed && index === path._segments.length - 1) index--;
        return path.getCurves()[index] || null;
      }

      return null;
    },
    getLocation: function () {
      var curve = this.getCurve();
      return curve ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1) : null;
    },
    getNext: function () {
      var segments = this._path && this._path._segments;
      return segments && (segments[this._index + 1] || this._path._closed && segments[0]) || null;
    },
    smooth: function (options, _first, _last) {
      var opts = options || {},
          type = opts.type,
          factor = opts.factor,
          prev = this.getPrevious(),
          next = this.getNext(),
          p0 = (prev || this)._point,
          p1 = this._point,
          p2 = (next || this)._point,
          d1 = p0.getDistance(p1),
          d2 = p1.getDistance(p2);

      if (!type || type === 'catmull-rom') {
        var a = factor === undefined ? 0.5 : factor,
            d1_a = Math.pow(d1, a),
            d1_2a = d1_a * d1_a,
            d2_a = Math.pow(d2, a),
            d2_2a = d2_a * d2_a;

        if (!_first && prev) {
          var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,
              N = 3 * d2_a * (d2_a + d1_a);
          this.setHandleIn(N !== 0 ? new Point((d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x, (d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y) : new Point());
        }

        if (!_last && next) {
          var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,
              N = 3 * d1_a * (d1_a + d2_a);
          this.setHandleOut(N !== 0 ? new Point((d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x, (d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y) : new Point());
        }
      } else if (type === 'geometric') {
        if (prev && next) {
          var vector = p0.subtract(p2),
              t = factor === undefined ? 0.4 : factor,
              k = t * d1 / (d1 + d2);
          if (!_first) this.setHandleIn(vector.multiply(k));
          if (!_last) this.setHandleOut(vector.multiply(k - t));
        }
      } else {
        throw new Error('Smoothing method \'' + type + '\' not supported.');
      }
    },
    getPrevious: function () {
      var segments = this._path && this._path._segments;
      return segments && (segments[this._index - 1] || this._path._closed && segments[segments.length - 1]) || null;
    },
    isFirst: function () {
      return !this._index;
    },
    isLast: function () {
      var path = this._path;
      return path && this._index === path._segments.length - 1 || false;
    },
    reverse: function () {
      var handleIn = this._handleIn,
          handleOut = this._handleOut,
          tmp = handleIn.clone();
      handleIn.set(handleOut);
      handleOut.set(tmp);
    },
    reversed: function () {
      return new Segment(this._point, this._handleOut, this._handleIn);
    },
    remove: function () {
      return this._path ? !!this._path.removeSegment(this._index) : false;
    },
    clone: function () {
      return new Segment(this._point, this._handleIn, this._handleOut);
    },
    equals: function (segment) {
      return segment === this || segment && this._class === segment._class && this._point.equals(segment._point) && this._handleIn.equals(segment._handleIn) && this._handleOut.equals(segment._handleOut) || false;
    },
    toString: function () {
      var parts = ['point: ' + this._point];
      if (!this._handleIn.isZero()) parts.push('handleIn: ' + this._handleIn);
      if (!this._handleOut.isZero()) parts.push('handleOut: ' + this._handleOut);
      return '{ ' + parts.join(', ') + ' }';
    },
    transform: function (matrix) {
      this._transformCoordinates(matrix, new Array(6), true);

      this._changed();
    },
    interpolate: function (from, to, factor) {
      var u = 1 - factor,
          v = factor,
          point1 = from._point,
          point2 = to._point,
          handleIn1 = from._handleIn,
          handleIn2 = to._handleIn,
          handleOut2 = to._handleOut,
          handleOut1 = from._handleOut;

      this._point._set(u * point1._x + v * point2._x, u * point1._y + v * point2._y, true);

      this._handleIn._set(u * handleIn1._x + v * handleIn2._x, u * handleIn1._y + v * handleIn2._y, true);

      this._handleOut._set(u * handleOut1._x + v * handleOut2._x, u * handleOut1._y + v * handleOut2._y, true);

      this._changed();
    },
    _transformCoordinates: function (matrix, coords, change) {
      var point = this._point,
          handleIn = !change || !this._handleIn.isZero() ? this._handleIn : null,
          handleOut = !change || !this._handleOut.isZero() ? this._handleOut : null,
          x = point._x,
          y = point._y,
          i = 2;
      coords[0] = x;
      coords[1] = y;

      if (handleIn) {
        coords[i++] = handleIn._x + x;
        coords[i++] = handleIn._y + y;
      }

      if (handleOut) {
        coords[i++] = handleOut._x + x;
        coords[i++] = handleOut._y + y;
      }

      if (matrix) {
        matrix._transformCoordinates(coords, coords, i / 2);

        x = coords[0];
        y = coords[1];

        if (change) {
          point._x = x;
          point._y = y;
          i = 2;

          if (handleIn) {
            handleIn._x = coords[i++] - x;
            handleIn._y = coords[i++] - y;
          }

          if (handleOut) {
            handleOut._x = coords[i++] - x;
            handleOut._y = coords[i++] - y;
          }
        } else {
          if (!handleIn) {
            coords[i++] = x;
            coords[i++] = y;
          }

          if (!handleOut) {
            coords[i++] = x;
            coords[i++] = y;
          }
        }
      }

      return coords;
    }
  });
  var SegmentPoint = Point.extend({
    initialize: function SegmentPoint(point, owner, key) {
      var x, y, selected;

      if (!point) {
        x = y = 0;
      } else if ((x = point[0]) !== undefined) {
        y = point[1];
      } else {
        var pt = point;

        if ((x = pt.x) === undefined) {
          pt = Point.read(arguments);
          x = pt.x;
        }

        y = pt.y;
        selected = pt.selected;
      }

      this._x = x;
      this._y = y;
      this._owner = owner;
      owner[key] = this;
      if (selected) this.setSelected(true);
    },
    _set: function (x, y) {
      this._x = x;
      this._y = y;

      this._owner._changed(this);

      return this;
    },
    getX: function () {
      return this._x;
    },
    setX: function (x) {
      this._x = x;

      this._owner._changed(this);
    },
    getY: function () {
      return this._y;
    },
    setY: function (y) {
      this._y = y;

      this._owner._changed(this);
    },
    isZero: function () {
      var isZero = Numerical.isZero;
      return isZero(this._x) && isZero(this._y);
    },
    isSelected: function () {
      return !!(this._owner._selection & this._getSelection());
    },
    setSelected: function (selected) {
      this._owner._changeSelection(this._getSelection(), selected);
    },
    _getSelection: function () {
      var owner = this._owner;
      return this === owner._point ? 1 : this === owner._handleIn ? 2 : this === owner._handleOut ? 4 : 0;
    }
  });
  var Curve = Base.extend({
    _class: 'Curve',
    beans: true,
    initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      var count = arguments.length,
          seg1,
          seg2,
          point1,
          point2,
          handle1,
          handle2;

      if (count === 3) {
        this._path = arg0;
        seg1 = arg1;
        seg2 = arg2;
      } else if (!count) {
        seg1 = new Segment();
        seg2 = new Segment();
      } else if (count === 1) {
        if ('segment1' in arg0) {
          seg1 = new Segment(arg0.segment1);
          seg2 = new Segment(arg0.segment2);
        } else if ('point1' in arg0) {
          point1 = arg0.point1;
          handle1 = arg0.handle1;
          handle2 = arg0.handle2;
          point2 = arg0.point2;
        } else if (Array.isArray(arg0)) {
          point1 = [arg0[0], arg0[1]];
          point2 = [arg0[6], arg0[7]];
          handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
          handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
        }
      } else if (count === 2) {
        seg1 = new Segment(arg0);
        seg2 = new Segment(arg1);
      } else if (count === 4) {
        point1 = arg0;
        handle1 = arg1;
        handle2 = arg2;
        point2 = arg3;
      } else if (count === 8) {
        point1 = [arg0, arg1];
        point2 = [arg6, arg7];
        handle1 = [arg2 - arg0, arg3 - arg1];
        handle2 = [arg4 - arg6, arg5 - arg7];
      }

      this._segment1 = seg1 || new Segment(point1, null, handle1);
      this._segment2 = seg2 || new Segment(point2, handle2, null);
    },
    _serialize: function (options, dictionary) {
      return Base.serialize(this.hasHandles() ? [this.getPoint1(), this.getHandle1(), this.getHandle2(), this.getPoint2()] : [this.getPoint1(), this.getPoint2()], options, true, dictionary);
    },
    _changed: function () {
      this._length = this._bounds = undefined;
    },
    clone: function () {
      return new Curve(this._segment1, this._segment2);
    },
    toString: function () {
      var parts = ['point1: ' + this._segment1._point];
      if (!this._segment1._handleOut.isZero()) parts.push('handle1: ' + this._segment1._handleOut);
      if (!this._segment2._handleIn.isZero()) parts.push('handle2: ' + this._segment2._handleIn);
      parts.push('point2: ' + this._segment2._point);
      return '{ ' + parts.join(', ') + ' }';
    },
    classify: function () {
      return Curve.classify(this.getValues());
    },
    remove: function () {
      var removed = false;

      if (this._path) {
        var segment2 = this._segment2,
            handleOut = segment2._handleOut;
        removed = segment2.remove();
        if (removed) this._segment1._handleOut.set(handleOut);
      }

      return removed;
    },
    getPoint1: function () {
      return this._segment1._point;
    },
    setPoint1: function () {
      this._segment1._point.set(Point.read(arguments));
    },
    getPoint2: function () {
      return this._segment2._point;
    },
    setPoint2: function () {
      this._segment2._point.set(Point.read(arguments));
    },
    getHandle1: function () {
      return this._segment1._handleOut;
    },
    setHandle1: function () {
      this._segment1._handleOut.set(Point.read(arguments));
    },
    getHandle2: function () {
      return this._segment2._handleIn;
    },
    setHandle2: function () {
      this._segment2._handleIn.set(Point.read(arguments));
    },
    getSegment1: function () {
      return this._segment1;
    },
    getSegment2: function () {
      return this._segment2;
    },
    getPath: function () {
      return this._path;
    },
    getIndex: function () {
      return this._segment1._index;
    },
    getNext: function () {
      var curves = this._path && this._path._curves;
      return curves && (curves[this._segment1._index + 1] || this._path._closed && curves[0]) || null;
    },
    getPrevious: function () {
      var curves = this._path && this._path._curves;
      return curves && (curves[this._segment1._index - 1] || this._path._closed && curves[curves.length - 1]) || null;
    },
    isFirst: function () {
      return !this._segment1._index;
    },
    isLast: function () {
      var path = this._path;
      return path && this._segment1._index === path._curves.length - 1 || false;
    },
    isSelected: function () {
      return this.getPoint1().isSelected() && this.getHandle1().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
    },
    setSelected: function (selected) {
      this.getPoint1().setSelected(selected);
      this.getHandle1().setSelected(selected);
      this.getHandle2().setSelected(selected);
      this.getPoint2().setSelected(selected);
    },
    getValues: function (matrix) {
      return Curve.getValues(this._segment1, this._segment2, matrix);
    },
    getPoints: function () {
      var coords = this.getValues(),
          points = [];

      for (var i = 0; i < 8; i += 2) points.push(new Point(coords[i], coords[i + 1]));

      return points;
    }
  }, {
    getLength: function () {
      if (this._length == null) this._length = Curve.getLength(this.getValues(), 0, 1);
      return this._length;
    },
    getArea: function () {
      return Curve.getArea(this.getValues());
    },
    getLine: function () {
      return new Line(this._segment1._point, this._segment2._point);
    },
    getPart: function (from, to) {
      return new Curve(Curve.getPart(this.getValues(), from, to));
    },
    getPartLength: function (from, to) {
      return Curve.getLength(this.getValues(), from, to);
    },
    divideAt: function (location) {
      return this.divideAtTime(location && location.curve === this ? location.time : this.getTimeAt(location));
    },
    divideAtTime: function (time, _setHandles) {
      var tMin = 1e-8,
          tMax = 1 - tMin,
          res = null;

      if (time >= tMin && time <= tMax) {
        var parts = Curve.subdivide(this.getValues(), time),
            left = parts[0],
            right = parts[1],
            setHandles = _setHandles || this.hasHandles(),
            seg1 = this._segment1,
            seg2 = this._segment2,
            path = this._path;

        if (setHandles) {
          seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);

          seg2._handleIn._set(right[4] - right[6], right[5] - right[7]);
        }

        var x = left[6],
            y = left[7],
            segment = new Segment(new Point(x, y), setHandles && new Point(left[4] - x, left[5] - y), setHandles && new Point(right[2] - x, right[3] - y));

        if (path) {
          path.insert(seg1._index + 1, segment);
          res = this.getNext();
        } else {
          this._segment2 = segment;

          this._changed();

          res = new Curve(segment, seg2);
        }
      }

      return res;
    },
    splitAt: function (location) {
      var path = this._path;
      return path ? path.splitAt(location) : null;
    },
    splitAtTime: function (time) {
      return this.splitAt(this.getLocationAtTime(time));
    },
    divide: function (offset, isTime) {
      return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset : this.getTimeAt(offset));
    },
    split: function (offset, isTime) {
      return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset : this.getTimeAt(offset));
    },
    reversed: function () {
      return new Curve(this._segment2.reversed(), this._segment1.reversed());
    },
    clearHandles: function () {
      this._segment1._handleOut._set(0, 0);

      this._segment2._handleIn._set(0, 0);
    },
    statics: {
      getValues: function (segment1, segment2, matrix, straight) {
        var p1 = segment1._point,
            h1 = segment1._handleOut,
            h2 = segment2._handleIn,
            p2 = segment2._point,
            x1 = p1.x,
            y1 = p1.y,
            x2 = p2.x,
            y2 = p2.y,
            values = straight ? [x1, y1, x1, y1, x2, y2, x2, y2] : [x1, y1, x1 + h1._x, y1 + h1._y, x2 + h2._x, y2 + h2._y, x2, y2];
        if (matrix) matrix._transformCoordinates(values, values, 4);
        return values;
      },
      subdivide: function (v, t) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7];
        if (t === undefined) t = 0.5;
        var u = 1 - t,
            x4 = u * x0 + t * x1,
            y4 = u * y0 + t * y1,
            x5 = u * x1 + t * x2,
            y5 = u * y1 + t * y2,
            x6 = u * x2 + t * x3,
            y6 = u * y2 + t * y3,
            x7 = u * x4 + t * x5,
            y7 = u * y4 + t * y5,
            x8 = u * x5 + t * x6,
            y8 = u * y5 + t * y6,
            x9 = u * x7 + t * x8,
            y9 = u * y7 + t * y8;
        return [[x0, y0, x4, y4, x7, y7, x9, y9], [x9, y9, x8, y8, x6, y6, x3, y3]];
      },
      getMonoCurves: function (v, dir) {
        var curves = [],
            io = dir ? 0 : 1,
            o0 = v[io + 0],
            o1 = v[io + 2],
            o2 = v[io + 4],
            o3 = v[io + 6];

        if (o0 >= o1 === o1 >= o2 && o1 >= o2 === o2 >= o3 || Curve.isStraight(v)) {
          curves.push(v);
        } else {
          var a = 3 * (o1 - o2) - o0 + o3,
              b = 2 * (o0 + o2) - 4 * o1,
              c = o1 - o0,
              tMin = 1e-8,
              tMax = 1 - tMin,
              roots = [],
              n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);

          if (!n) {
            curves.push(v);
          } else {
            roots.sort();
            var t = roots[0],
                parts = Curve.subdivide(v, t);
            curves.push(parts[0]);

            if (n > 1) {
              t = (roots[1] - t) / (1 - t);
              parts = Curve.subdivide(parts[1], t);
              curves.push(parts[0]);
            }

            curves.push(parts[1]);
          }
        }

        return curves;
      },
      solveCubic: function (v, coord, val, roots, min, max) {
        var v0 = v[coord],
            v1 = v[coord + 2],
            v2 = v[coord + 4],
            v3 = v[coord + 6],
            res = 0;

        if (!(v0 < val && v3 < val && v1 < val && v2 < val || v0 > val && v3 > val && v1 > val && v2 > val)) {
          var c = 3 * (v1 - v0),
              b = 3 * (v2 - v1) - c,
              a = v3 - v0 - c - b;
          res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);
        }

        return res;
      },
      getTimeOf: function (v, point) {
        var p0 = new Point(v[0], v[1]),
            p3 = new Point(v[6], v[7]),
            epsilon = 1e-12,
            geomEpsilon = 1e-7,
            t = point.isClose(p0, epsilon) ? 0 : point.isClose(p3, epsilon) ? 1 : null;

        if (t === null) {
          var coords = [point.x, point.y],
              roots = [];

          for (var c = 0; c < 2; c++) {
            var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);

            for (var i = 0; i < count; i++) {
              var u = roots[i];
              if (point.isClose(Curve.getPoint(v, u), geomEpsilon)) return u;
            }
          }
        }

        return point.isClose(p0, geomEpsilon) ? 0 : point.isClose(p3, geomEpsilon) ? 1 : null;
      },
      getNearestTime: function (v, point) {
        if (Curve.isStraight(v)) {
          var x0 = v[0],
              y0 = v[1],
              x3 = v[6],
              y3 = v[7],
              vx = x3 - x0,
              vy = y3 - y0,
              det = vx * vx + vy * vy;
          if (det === 0) return 0;
          var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
          return u < 1e-12 ? 0 : u > 0.999999999999 ? 1 : Curve.getTimeOf(v, new Point(x0 + u * vx, y0 + u * vy));
        }

        var count = 100,
            minDist = Infinity,
            minT = 0;

        function refine(t) {
          if (t >= 0 && t <= 1) {
            var dist = point.getDistance(Curve.getPoint(v, t), true);

            if (dist < minDist) {
              minDist = dist;
              minT = t;
              return true;
            }
          }
        }

        for (var i = 0; i <= count; i++) refine(i / count);

        var step = 1 / (count * 2);

        while (step > 1e-8) {
          if (!refine(minT - step) && !refine(minT + step)) step /= 2;
        }

        return minT;
      },
      getPart: function (v, from, to) {
        var flip = from > to;

        if (flip) {
          var tmp = from;
          from = to;
          to = tmp;
        }

        if (from > 0) v = Curve.subdivide(v, from)[1];
        if (to < 1) v = Curve.subdivide(v, (to - from) / (1 - from))[0];
        return flip ? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]] : v;
      },
      isFlatEnough: function (v, flatness) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7],
            ux = 3 * x1 - 2 * x0 - x3,
            uy = 3 * y1 - 2 * y0 - y3,
            vx = 3 * x2 - 2 * x3 - x0,
            vy = 3 * y2 - 2 * y3 - y0;
        return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy) <= 16 * flatness * flatness;
      },
      getArea: function (v) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7];
        return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2) + y1 * (x0 - x2) - x1 * (y0 - y2) + y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
      },
      getBounds: function (v) {
        var min = v.slice(0, 2),
            max = min.slice(),
            roots = [0, 0];

        for (var i = 0; i < 2; i++) Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6], i, 0, min, max, roots);

        return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      _addBounds: function (v0, v1, v2, v3, coord, padding, min, max, roots) {
        function add(value, padding) {
          var left = value - padding,
              right = value + padding;
          if (left < min[coord]) min[coord] = left;
          if (right > max[coord]) max[coord] = right;
        }

        padding /= 2;
        var minPad = min[coord] + padding,
            maxPad = max[coord] - padding;

        if (v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad || v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
          if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
            add(v0, 0);
            add(v3, 0);
          } else {
            var a = 3 * (v1 - v2) - v0 + v3,
                b = 2 * (v0 + v2) - 4 * v1,
                c = v1 - v0,
                count = Numerical.solveQuadratic(a, b, c, roots),
                tMin = 1e-8,
                tMax = 1 - tMin;
            add(v3, 0);

            for (var i = 0; i < count; i++) {
              var t = roots[i],
                  u = 1 - t;
              if (tMin <= t && t <= tMax) add(u * u * u * v0 + 3 * u * u * t * v1 + 3 * u * t * t * v2 + t * t * t * v3, padding);
            }
          }
        }
      }
    }
  }, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds'], function (name) {
    this[name] = function () {
      if (!this._bounds) this._bounds = {};
      var bounds = this._bounds[name];

      if (!bounds) {
        bounds = this._bounds[name] = Path[name]([this._segment1, this._segment2], false, this._path);
      }

      return bounds.clone();
    };
  }, {}), Base.each({
    isStraight: function (p1, h1, h2, p2) {
      if (h1.isZero() && h2.isZero()) {
        return true;
      } else {
        var v = p2.subtract(p1);

        if (v.isZero()) {
          return false;
        } else if (v.isCollinear(h1) && v.isCollinear(h2)) {
          var l = new Line(p1, p2),
              epsilon = 1e-7;

          if (l.getDistance(p1.add(h1)) < epsilon && l.getDistance(p2.add(h2)) < epsilon) {
            var div = v.dot(v),
                s1 = v.dot(h1) / div,
                s2 = v.dot(h2) / div;
            return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
          }
        }
      }

      return false;
    },
    isLinear: function (p1, h1, h2, p2) {
      var third = p2.subtract(p1).divide(3);
      return h1.equals(third) && h2.negate().equals(third);
    }
  }, function (test, name) {
    this[name] = function (epsilon) {
      var seg1 = this._segment1,
          seg2 = this._segment2;
      return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point, epsilon);
    };

    this.statics[name] = function (v, epsilon) {
      var x0 = v[0],
          y0 = v[1],
          x3 = v[6],
          y3 = v[7];
      return test(new Point(x0, y0), new Point(v[2] - x0, v[3] - y0), new Point(v[4] - x3, v[5] - y3), new Point(x3, y3), epsilon);
    };
  }, {
    statics: {},
    hasHandles: function () {
      return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero();
    },
    hasLength: function (epsilon) {
      return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (epsilon || 0);
    },
    isCollinear: function (curve) {
      return curve && this.isStraight() && curve.isStraight() && this.getLine().isCollinear(curve.getLine());
    },
    isHorizontal: function () {
      return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y) < 1e-8;
    },
    isVertical: function () {
      return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x) < 1e-8;
    }
  }), {
    beans: false,
    getLocationAt: function (offset, _isTime) {
      return this.getLocationAtTime(_isTime ? offset : this.getTimeAt(offset));
    },
    getLocationAtTime: function (t) {
      return t != null && t >= 0 && t <= 1 ? new CurveLocation(this, t) : null;
    },
    getTimeAt: function (offset, start) {
      return Curve.getTimeAt(this.getValues(), offset, start);
    },
    getParameterAt: '#getTimeAt',
    getTimesWithTangent: function () {
      var tangent = Point.read(arguments);
      return tangent.isZero() ? [] : Curve.getTimesWithTangent(this.getValues(), tangent);
    },
    getOffsetAtTime: function (t) {
      return this.getPartLength(0, t);
    },
    getLocationOf: function () {
      return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
    },
    getOffsetOf: function () {
      var loc = this.getLocationOf.apply(this, arguments);
      return loc ? loc.getOffset() : null;
    },
    getTimeOf: function () {
      return Curve.getTimeOf(this.getValues(), Point.read(arguments));
    },
    getParameterOf: '#getTimeOf',
    getNearestLocation: function () {
      var point = Point.read(arguments),
          values = this.getValues(),
          t = Curve.getNearestTime(values, point),
          pt = Curve.getPoint(values, t);
      return new CurveLocation(this, t, pt, null, point.getDistance(pt));
    },
    getNearestPoint: function () {
      var loc = this.getNearestLocation.apply(this, arguments);
      return loc ? loc.getPoint() : loc;
    }
  }, new function () {
    var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent', 'getWeightedNormal', 'getCurvature'];
    return Base.each(methods, function (name) {
      this[name + 'At'] = function (location, _isTime) {
        var values = this.getValues();
        return Curve[name](values, _isTime ? location : Curve.getTimeAt(values, location));
      };

      this[name + 'AtTime'] = function (time) {
        return Curve[name](this.getValues(), time);
      };
    }, {
      statics: {
        _evaluateMethods: methods
      }
    });
  }(), new function () {
    function getLengthIntegrand(v) {
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          ax = 9 * (x1 - x2) + 3 * (x3 - x0),
          bx = 6 * (x0 + x2) - 12 * x1,
          cx = 3 * (x1 - x0),
          ay = 9 * (y1 - y2) + 3 * (y3 - y0),
          by = 6 * (y0 + y2) - 12 * y1,
          cy = 3 * (y1 - y0);
      return function (t) {
        var dx = (ax * t + bx) * t + cx,
            dy = (ay * t + by) * t + cy;
        return Math.sqrt(dx * dx + dy * dy);
      };
    }

    function getIterations(a, b) {
      return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
    }

    function evaluate(v, t, type, normalized) {
      if (t == null || t < 0 || t > 1) return null;
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          isZero = Numerical.isZero;

      if (isZero(x1 - x0) && isZero(y1 - y0)) {
        x1 = x0;
        y1 = y0;
      }

      if (isZero(x2 - x3) && isZero(y2 - y3)) {
        x2 = x3;
        y2 = y3;
      }

      var cx = 3 * (x1 - x0),
          bx = 3 * (x2 - x1) - cx,
          ax = x3 - x0 - cx - bx,
          cy = 3 * (y1 - y0),
          by = 3 * (y2 - y1) - cy,
          ay = y3 - y0 - cy - by,
          x,
          y;

      if (type === 0) {
        x = t === 0 ? x0 : t === 1 ? x3 : ((ax * t + bx) * t + cx) * t + x0;
        y = t === 0 ? y0 : t === 1 ? y3 : ((ay * t + by) * t + cy) * t + y0;
      } else {
        var tMin = 1e-8,
            tMax = 1 - tMin;

        if (t < tMin) {
          x = cx;
          y = cy;
        } else if (t > tMax) {
          x = 3 * (x3 - x2);
          y = 3 * (y3 - y2);
        } else {
          x = (3 * ax * t + 2 * bx) * t + cx;
          y = (3 * ay * t + 2 * by) * t + cy;
        }

        if (normalized) {
          if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
            x = x2 - x1;
            y = y2 - y1;
          }

          var len = Math.sqrt(x * x + y * y);

          if (len) {
            x /= len;
            y /= len;
          }
        }

        if (type === 3) {
          var x2 = 6 * ax * t + 2 * bx,
              y2 = 6 * ay * t + 2 * by,
              d = Math.pow(x * x + y * y, 3 / 2);
          x = d !== 0 ? (x * y2 - y * x2) / d : 0;
          y = 0;
        }
      }

      return type === 2 ? new Point(y, -x) : new Point(x, y);
    }

    return {
      statics: {
        classify: function (v) {
          var x0 = v[0],
              y0 = v[1],
              x1 = v[2],
              y1 = v[3],
              x2 = v[4],
              y2 = v[5],
              x3 = v[6],
              y3 = v[7],
              a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,
              a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,
              a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,
              d3 = 3 * a3,
              d2 = d3 - a2,
              d1 = d2 - a2 + a1,
              l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),
              s = l !== 0 ? 1 / l : 0,
              isZero = Numerical.isZero,
              serpentine = 'serpentine';
          d1 *= s;
          d2 *= s;
          d3 *= s;

          function type(type, t1, t2) {
            var hasRoots = t1 !== undefined,
                t1Ok = hasRoots && t1 > 0 && t1 < 1,
                t2Ok = hasRoots && t2 > 0 && t2 < 1;

            if (hasRoots && (!(t1Ok || t2Ok) || type === 'loop' && !(t1Ok && t2Ok))) {
              type = 'arch';
              t1Ok = t2Ok = false;
            }

            return {
              type: type,
              roots: t1Ok || t2Ok ? t1Ok && t2Ok ? t1 < t2 ? [t1, t2] : [t2, t1] : [t1Ok ? t1 : t2] : null
            };
          }

          if (isZero(d1)) {
            return isZero(d2) ? type(isZero(d3) ? 'line' : 'quadratic') : type(serpentine, d3 / (3 * d2));
          }

          var d = 3 * d2 * d2 - 4 * d1 * d3;

          if (isZero(d)) {
            return type('cusp', d2 / (2 * d1));
          }

          var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),
              f2 = 2 * d1;
          return type(d > 0 ? serpentine : 'loop', (d2 + f1) / f2, (d2 - f1) / f2);
        },
        getLength: function (v, a, b, ds) {
          if (a === undefined) a = 0;
          if (b === undefined) b = 1;

          if (Curve.isStraight(v)) {
            var c = v;

            if (b < 1) {
              c = Curve.subdivide(c, b)[0];
              a /= b;
            }

            if (a > 0) {
              c = Curve.subdivide(c, a)[1];
            }

            var dx = c[6] - c[0],
                dy = c[7] - c[1];
            return Math.sqrt(dx * dx + dy * dy);
          }

          return Numerical.integrate(ds || getLengthIntegrand(v), a, b, getIterations(a, b));
        },
        getTimeAt: function (v, offset, start) {
          if (start === undefined) start = offset < 0 ? 1 : 0;
          if (offset === 0) return start;
          var abs = Math.abs,
              epsilon = 1e-12,
              forward = offset > 0,
              a = forward ? start : 0,
              b = forward ? 1 : start,
              ds = getLengthIntegrand(v),
              rangeLength = Curve.getLength(v, a, b, ds),
              diff = abs(offset) - rangeLength;

          if (abs(diff) < epsilon) {
            return forward ? b : a;
          } else if (diff > epsilon) {
            return null;
          }

          var guess = offset / rangeLength,
              length = 0;

          function f(t) {
            length += Numerical.integrate(ds, start, t, getIterations(start, t));
            start = t;
            return length - offset;
          }

          return Numerical.findRoot(f, ds, start + guess, a, b, 32, 1e-12);
        },
        getPoint: function (v, t) {
          return evaluate(v, t, 0, false);
        },
        getTangent: function (v, t) {
          return evaluate(v, t, 1, true);
        },
        getWeightedTangent: function (v, t) {
          return evaluate(v, t, 1, false);
        },
        getNormal: function (v, t) {
          return evaluate(v, t, 2, true);
        },
        getWeightedNormal: function (v, t) {
          return evaluate(v, t, 2, false);
        },
        getCurvature: function (v, t) {
          return evaluate(v, t, 3, false).x;
        },
        getPeaks: function (v) {
          var x0 = v[0],
              y0 = v[1],
              x1 = v[2],
              y1 = v[3],
              x2 = v[4],
              y2 = v[5],
              x3 = v[6],
              y3 = v[7],
              ax = -x0 + 3 * x1 - 3 * x2 + x3,
              bx = 3 * x0 - 6 * x1 + 3 * x2,
              cx = -3 * x0 + 3 * x1,
              ay = -y0 + 3 * y1 - 3 * y2 + y3,
              by = 3 * y0 - 6 * y1 + 3 * y2,
              cy = -3 * y0 + 3 * y1,
              tMin = 1e-8,
              tMax = 1 - tMin,
              roots = [];
          Numerical.solveCubic(9 * (ax * ax + ay * ay), 9 * (ax * bx + by * ay), 2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay), cx * bx + by * cy, roots, tMin, tMax);
          return roots.sort();
        }
      }
    };
  }(), new function () {
    function addLocation(locations, include, c1, t1, c2, t2, overlap) {
      var excludeStart = !overlap && c1.getPrevious() === c2,
          excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,
          tMin = 1e-8,
          tMax = 1 - tMin;

      if (t1 !== null && t1 >= (excludeStart ? tMin : 0) && t1 <= (excludeEnd ? tMax : 1)) {
        if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) && t2 <= (excludeStart ? tMax : 1)) {
          var loc1 = new CurveLocation(c1, t1, null, overlap),
              loc2 = new CurveLocation(c2, t2, null, overlap);
          loc1._intersection = loc2;
          loc2._intersection = loc1;

          if (!include || include(loc1)) {
            CurveLocation.insert(locations, loc1, true);
          }
        }
      }
    }

    function addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMin, tMax, uMin, uMax) {
      if (++calls >= 4096 || ++recursion >= 40) return calls;
      var fatLineEpsilon = 1e-9,
          q0x = v2[0],
          q0y = v2[1],
          q3x = v2[6],
          q3y = v2[7],
          getSignedDistance = Line.getSignedDistance,
          d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
          d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
          factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
          dMin = factor * Math.min(0, d1, d2),
          dMax = factor * Math.max(0, d1, d2),
          dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
          dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
          dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
          dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
          hull = getConvexHull(dp0, dp1, dp2, dp3),
          top = hull[0],
          bottom = hull[1],
          tMinClip,
          tMaxClip;
      if (d1 === 0 && d2 === 0 && dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0 || (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null || (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(), dMin, dMax)) == null) return calls;
      var tMinNew = tMin + (tMax - tMin) * tMinClip,
          tMaxNew = tMin + (tMax - tMin) * tMaxClip;

      if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
        var t = (tMinNew + tMaxNew) / 2,
            u = (uMin + uMax) / 2;
        addLocation(locations, include, flip ? c2 : c1, flip ? u : t, flip ? c1 : c2, flip ? t : u);
      } else {
        v1 = Curve.getPart(v1, tMinClip, tMaxClip);
        var uDiff = uMax - uMin;

        if (tMaxClip - tMinClip > 0.8) {
          if (tMaxNew - tMinNew > uDiff) {
            var parts = Curve.subdivide(v1, 0.5),
                t = (tMinNew + tMaxNew) / 2;
            calls = addCurveIntersections(v2, parts[0], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, t);
            calls = addCurveIntersections(v2, parts[1], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, t, tMaxNew);
          } else {
            var parts = Curve.subdivide(v2, 0.5),
                u = (uMin + uMax) / 2;
            calls = addCurveIntersections(parts[0], v1, c2, c1, locations, include, !flip, recursion, calls, uMin, u, tMinNew, tMaxNew);
            calls = addCurveIntersections(parts[1], v1, c2, c1, locations, include, !flip, recursion, calls, u, uMax, tMinNew, tMaxNew);
          }
        } else {
          if (uDiff === 0 || uDiff >= fatLineEpsilon) {
            calls = addCurveIntersections(v2, v1, c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, tMaxNew);
          } else {
            calls = addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMinNew, tMaxNew, uMin, uMax);
          }
        }
      }

      return calls;
    }

    function getConvexHull(dq0, dq1, dq2, dq3) {
      var p0 = [0, dq0],
          p1 = [1 / 3, dq1],
          p2 = [2 / 3, dq2],
          p3 = [1, dq3],
          dist1 = dq1 - (2 * dq0 + dq3) / 3,
          dist2 = dq2 - (dq0 + 2 * dq3) / 3,
          hull;

      if (dist1 * dist2 < 0) {
        hull = [[p0, p1, p3], [p0, p2, p3]];
      } else {
        var distRatio = dist1 / dist2;
        hull = [distRatio >= 2 ? [p0, p1, p3] : distRatio <= 0.5 ? [p0, p2, p3] : [p0, p1, p2, p3], [p0, p3]];
      }

      return (dist1 || dist2) < 0 ? hull.reverse() : hull;
    }

    function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
      if (hullTop[0][1] < dMin) {
        return clipConvexHullPart(hullTop, true, dMin);
      } else if (hullBottom[0][1] > dMax) {
        return clipConvexHullPart(hullBottom, false, dMax);
      } else {
        return hullTop[0][0];
      }
    }

    function clipConvexHullPart(part, top, threshold) {
      var px = part[0][0],
          py = part[0][1];

      for (var i = 1, l = part.length; i < l; i++) {
        var qx = part[i][0],
            qy = part[i][1];

        if (top ? qy >= threshold : qy <= threshold) {
          return qy === threshold ? qx : px + (threshold - py) * (qx - px) / (qy - py);
        }

        px = qx;
        py = qy;
      }

      return null;
    }

    function getCurveLineIntersections(v, px, py, vx, vy) {
      var isZero = Numerical.isZero;

      if (isZero(vx) && isZero(vy)) {
        var t = Curve.getTimeOf(v, new Point(px, py));
        return t === null ? [] : [t];
      }

      var angle = Math.atan2(-vy, vx),
          sin = Math.sin(angle),
          cos = Math.cos(angle),
          rv = [],
          roots = [];

      for (var i = 0; i < 8; i += 2) {
        var x = v[i] - px,
            y = v[i + 1] - py;
        rv.push(x * cos - y * sin, x * sin + y * cos);
      }

      Curve.solveCubic(rv, 1, 0, roots, 0, 1);
      return roots;
    }

    function addCurveLineIntersections(v1, v2, c1, c2, locations, include, flip) {
      var x1 = v2[0],
          y1 = v2[1],
          x2 = v2[6],
          y2 = v2[7],
          roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);

      for (var i = 0, l = roots.length; i < l; i++) {
        var t1 = roots[i],
            p1 = Curve.getPoint(v1, t1),
            t2 = Curve.getTimeOf(v2, p1);

        if (t2 !== null) {
          addLocation(locations, include, flip ? c2 : c1, flip ? t2 : t1, flip ? c1 : c2, flip ? t1 : t2);
        }
      }
    }

    function addLineIntersection(v1, v2, c1, c2, locations, include) {
      var pt = Line.intersect(v1[0], v1[1], v1[6], v1[7], v2[0], v2[1], v2[6], v2[7]);

      if (pt) {
        addLocation(locations, include, c1, Curve.getTimeOf(v1, pt), c2, Curve.getTimeOf(v2, pt));
      }
    }

    function getCurveIntersections(v1, v2, c1, c2, locations, include) {
      var epsilon = 1e-12,
          min = Math.min,
          max = Math.max;

      if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon > min(v2[0], v2[2], v2[4], v2[6]) && min(v1[0], v1[2], v1[4], v1[6]) - epsilon < max(v2[0], v2[2], v2[4], v2[6]) && max(v1[1], v1[3], v1[5], v1[7]) + epsilon > min(v2[1], v2[3], v2[5], v2[7]) && min(v1[1], v1[3], v1[5], v1[7]) - epsilon < max(v2[1], v2[3], v2[5], v2[7])) {
        var overlaps = getOverlaps(v1, v2);

        if (overlaps) {
          for (var i = 0; i < 2; i++) {
            var overlap = overlaps[i];
            addLocation(locations, include, c1, overlap[0], c2, overlap[1], true);
          }
        } else {
          var straight1 = Curve.isStraight(v1),
              straight2 = Curve.isStraight(v2),
              straight = straight1 && straight2,
              flip = straight1 && !straight2,
              before = locations.length;
          (straight ? addLineIntersection : straight1 || straight2 ? addCurveLineIntersections : addCurveIntersections)(flip ? v2 : v1, flip ? v1 : v2, flip ? c2 : c1, flip ? c1 : c2, locations, include, flip, 0, 0, 0, 1, 0, 1);

          if (!straight || locations.length === before) {
            for (var i = 0; i < 4; i++) {
              var t1 = i >> 1,
                  t2 = i & 1,
                  i1 = t1 * 6,
                  i2 = t2 * 6,
                  p1 = new Point(v1[i1], v1[i1 + 1]),
                  p2 = new Point(v2[i2], v2[i2 + 1]);

              if (p1.isClose(p2, epsilon)) {
                addLocation(locations, include, c1, t1, c2, t2);
              }
            }
          }
        }
      }

      return locations;
    }

    function getSelfIntersection(v1, c1, locations, include) {
      var info = Curve.classify(v1);

      if (info.type === 'loop') {
        var roots = info.roots;
        addLocation(locations, include, c1, roots[0], c1, roots[1]);
      }

      return locations;
    }

    function getIntersections(curves1, curves2, include, matrix1, matrix2, _returnFirst) {
      var epsilon = 1e-7,
          self = !curves2;
      if (self) curves2 = curves1;
      var length1 = curves1.length,
          length2 = curves2.length,
          values1 = new Array(length1),
          values2 = self ? values1 : new Array(length2),
          locations = [];

      for (var i = 0; i < length1; i++) {
        values1[i] = curves1[i].getValues(matrix1);
      }

      if (!self) {
        for (var i = 0; i < length2; i++) {
          values2[i] = curves2[i].getValues(matrix2);
        }
      }

      var boundsCollisions = CollisionDetection.findCurveBoundsCollisions(values1, values2, epsilon);

      for (var index1 = 0; index1 < length1; index1++) {
        var curve1 = curves1[index1],
            v1 = values1[index1];

        if (self) {
          getSelfIntersection(v1, curve1, locations, include);
        }

        var collisions1 = boundsCollisions[index1];

        if (collisions1) {
          for (var j = 0; j < collisions1.length; j++) {
            if (_returnFirst && locations.length) return locations;
            var index2 = collisions1[j];

            if (!self || index2 > index1) {
              var curve2 = curves2[index2],
                  v2 = values2[index2];
              getCurveIntersections(v1, v2, curve1, curve2, locations, include);
            }
          }
        }
      }

      return locations;
    }

    function getOverlaps(v1, v2) {
      function getSquaredLineLength(v) {
        var x = v[6] - v[0],
            y = v[7] - v[1];
        return x * x + y * y;
      }

      var abs = Math.abs,
          getDistance = Line.getDistance,
          timeEpsilon = 1e-8,
          geomEpsilon = 1e-7,
          straight1 = Curve.isStraight(v1),
          straight2 = Curve.isStraight(v2),
          straightBoth = straight1 && straight2,
          flip = getSquaredLineLength(v1) < getSquaredLineLength(v2),
          l1 = flip ? v2 : v1,
          l2 = flip ? v1 : v2,
          px = l1[0],
          py = l1[1],
          vx = l1[6] - px,
          vy = l1[7] - py;

      if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
        if (!straightBoth && getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
          straight1 = straight2 = straightBoth = true;
        }
      } else if (straightBoth) {
        return null;
      }

      if (straight1 ^ straight2) {
        return null;
      }

      var v = [v1, v2],
          pairs = [];

      for (var i = 0; i < 4 && pairs.length < 2; i++) {
        var i1 = i & 1,
            i2 = i1 ^ 1,
            t1 = i >> 1,
            t2 = Curve.getTimeOf(v[i1], new Point(v[i2][t1 ? 6 : 0], v[i2][t1 ? 7 : 1]));

        if (t2 != null) {
          var pair = i1 ? [t1, t2] : [t2, t1];

          if (!pairs.length || abs(pair[0] - pairs[0][0]) > timeEpsilon && abs(pair[1] - pairs[0][1]) > timeEpsilon) {
            pairs.push(pair);
          }
        }

        if (i > 2 && !pairs.length) break;
      }

      if (pairs.length !== 2) {
        pairs = null;
      } else if (!straightBoth) {
        var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
            o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
        if (abs(o2[2] - o1[2]) > geomEpsilon || abs(o2[3] - o1[3]) > geomEpsilon || abs(o2[4] - o1[4]) > geomEpsilon || abs(o2[5] - o1[5]) > geomEpsilon) pairs = null;
      }

      return pairs;
    }

    function getTimesWithTangent(v, tangent) {
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          normalized = tangent.normalize(),
          tx = normalized.x,
          ty = normalized.y,
          ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,
          ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,
          bx = 6 * x2 - 12 * x1 + 6 * x0,
          by = 6 * y2 - 12 * y1 + 6 * y0,
          cx = 3 * x1 - 3 * x0,
          cy = 3 * y1 - 3 * y0,
          den = 2 * ax * ty - 2 * ay * tx,
          times = [];

      if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {
        var num = ax * cy - ay * cx,
            den = ax * by - ay * bx;

        if (den != 0) {
          var t = -num / den;
          if (t >= 0 && t <= 1) times.push(t);
        }
      } else {
        var delta = (bx * bx - 4 * ax * cx) * ty * ty + (-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty + (by * by - 4 * ay * cy) * tx * tx,
            k = bx * ty - by * tx;

        if (delta >= 0 && den != 0) {
          var d = Math.sqrt(delta),
              t0 = -(k + d) / den,
              t1 = (-k + d) / den;
          if (t0 >= 0 && t0 <= 1) times.push(t0);
          if (t1 >= 0 && t1 <= 1) times.push(t1);
        }
      }

      return times;
    }

    return {
      getIntersections: function (curve) {
        var v1 = this.getValues(),
            v2 = curve && curve !== this && curve.getValues();
        return v2 ? getCurveIntersections(v1, v2, this, curve, []) : getSelfIntersection(v1, this, []);
      },
      statics: {
        getOverlaps: getOverlaps,
        getIntersections: getIntersections,
        getCurveLineIntersections: getCurveLineIntersections,
        getTimesWithTangent: getTimesWithTangent
      }
    };
  }());
  var CurveLocation = Base.extend({
    _class: 'CurveLocation',
    initialize: function CurveLocation(curve, time, point, _overlap, _distance) {
      if (time >= 0.99999999) {
        var next = curve.getNext();

        if (next) {
          time = 0;
          curve = next;
        }
      }

      this._setCurve(curve);

      this._time = time;
      this._point = point || curve.getPointAtTime(time);
      this._overlap = _overlap;
      this._distance = _distance;
      this._intersection = this._next = this._previous = null;
    },
    _setPath: function (path) {
      this._path = path;
      this._version = path ? path._version : 0;
    },
    _setCurve: function (curve) {
      this._setPath(curve._path);

      this._curve = curve;
      this._segment = null;
      this._segment1 = curve._segment1;
      this._segment2 = curve._segment2;
    },
    _setSegment: function (segment) {
      var curve = segment.getCurve();

      if (curve) {
        this._setCurve(curve);
      } else {
        this._setPath(segment._path);

        this._segment1 = segment;
        this._segment2 = null;
      }

      this._segment = segment;
      this._time = segment === this._segment1 ? 0 : 1;
      this._point = segment._point.clone();
    },
    getSegment: function () {
      var segment = this._segment;

      if (!segment) {
        var curve = this.getCurve(),
            time = this.getTime();

        if (time === 0) {
          segment = curve._segment1;
        } else if (time === 1) {
          segment = curve._segment2;
        } else if (time != null) {
          segment = curve.getPartLength(0, time) < curve.getPartLength(time, 1) ? curve._segment1 : curve._segment2;
        }

        this._segment = segment;
      }

      return segment;
    },
    getCurve: function () {
      var path = this._path,
          that = this;

      if (path && path._version !== this._version) {
        this._time = this._offset = this._curveOffset = this._curve = null;
      }

      function trySegment(segment) {
        var curve = segment && segment.getCurve();

        if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
          that._setCurve(curve);

          return curve;
        }
      }

      return this._curve || trySegment(this._segment) || trySegment(this._segment1) || trySegment(this._segment2.getPrevious());
    },
    getPath: function () {
      var curve = this.getCurve();
      return curve && curve._path;
    },
    getIndex: function () {
      var curve = this.getCurve();
      return curve && curve.getIndex();
    },
    getTime: function () {
      var curve = this.getCurve(),
          time = this._time;
      return curve && time == null ? this._time = curve.getTimeOf(this._point) : time;
    },
    getParameter: '#getTime',
    getPoint: function () {
      return this._point;
    },
    getOffset: function () {
      var offset = this._offset;

      if (offset == null) {
        offset = 0;
        var path = this.getPath(),
            index = this.getIndex();

        if (path && index != null) {
          var curves = path.getCurves();

          for (var i = 0; i < index; i++) offset += curves[i].getLength();
        }

        this._offset = offset += this.getCurveOffset();
      }

      return offset;
    },
    getCurveOffset: function () {
      var offset = this._curveOffset;

      if (offset == null) {
        var curve = this.getCurve(),
            time = this.getTime();
        this._curveOffset = offset = time != null && curve && curve.getPartLength(0, time);
      }

      return offset;
    },
    getIntersection: function () {
      return this._intersection;
    },
    getDistance: function () {
      return this._distance;
    },
    divide: function () {
      var curve = this.getCurve(),
          res = curve && curve.divideAtTime(this.getTime());

      if (res) {
        this._setSegment(res._segment1);
      }

      return res;
    },
    split: function () {
      var curve = this.getCurve(),
          path = curve._path,
          res = curve && curve.splitAtTime(this.getTime());

      if (res) {
        this._setSegment(path.getLastSegment());
      }

      return res;
    },
    equals: function (loc, _ignoreOther) {
      var res = this === loc;

      if (!res && loc instanceof CurveLocation) {
        var c1 = this.getCurve(),
            c2 = loc.getCurve(),
            p1 = c1._path,
            p2 = c2._path;

        if (p1 === p2) {
          var abs = Math.abs,
              epsilon = 1e-7,
              diff = abs(this.getOffset() - loc.getOffset()),
              i1 = !_ignoreOther && this._intersection,
              i2 = !_ignoreOther && loc._intersection;
          res = (diff < epsilon || p1 && abs(p1.getLength() - diff) < epsilon) && (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
        }
      }

      return res;
    },
    toString: function () {
      var parts = [],
          point = this.getPoint(),
          f = Formatter.instance;
      if (point) parts.push('point: ' + point);
      var index = this.getIndex();
      if (index != null) parts.push('index: ' + index);
      var time = this.getTime();
      if (time != null) parts.push('time: ' + f.number(time));
      if (this._distance != null) parts.push('distance: ' + f.number(this._distance));
      return '{ ' + parts.join(', ') + ' }';
    },
    isTouching: function () {
      var inter = this._intersection;

      if (inter && this.getTangent().isCollinear(inter.getTangent())) {
        var curve1 = this.getCurve(),
            curve2 = inter.getCurve();
        return !(curve1.isStraight() && curve2.isStraight() && curve1.getLine().intersect(curve2.getLine()));
      }

      return false;
    },
    isCrossing: function () {
      var inter = this._intersection;
      if (!inter) return false;
      var t1 = this.getTime(),
          t2 = inter.getTime(),
          tMin = 1e-8,
          tMax = 1 - tMin,
          t1Inside = t1 >= tMin && t1 <= tMax,
          t2Inside = t2 >= tMin && t2 <= tMax;
      if (t1Inside && t2Inside) return !this.isTouching();
      var c2 = this.getCurve(),
          c1 = c2 && t1 < tMin ? c2.getPrevious() : c2,
          c4 = inter.getCurve(),
          c3 = c4 && t2 < tMin ? c4.getPrevious() : c4;
      if (t1 > tMax) c2 = c2.getNext();
      if (t2 > tMax) c4 = c4.getNext();
      if (!c1 || !c2 || !c3 || !c4) return false;
      var offsets = [];

      function addOffsets(curve, end) {
        var v = curve.getValues(),
            roots = Curve.classify(v).roots || Curve.getPeaks(v),
            count = roots.length,
            offset = Curve.getLength(v, end && count ? roots[count - 1] : 0, !end && count ? roots[0] : 1);
        offsets.push(count ? offset : offset / 32);
      }

      function isInRange(angle, min, max) {
        return min < max ? angle > min && angle < max : angle > min || angle < max;
      }

      if (!t1Inside) {
        addOffsets(c1, true);
        addOffsets(c2, false);
      }

      if (!t2Inside) {
        addOffsets(c3, true);
        addOffsets(c4, false);
      }

      var pt = this.getPoint(),
          offset = Math.min.apply(Math, offsets),
          v2 = t1Inside ? c2.getTangentAtTime(t1) : c2.getPointAt(offset).subtract(pt),
          v1 = t1Inside ? v2.negate() : c1.getPointAt(-offset).subtract(pt),
          v4 = t2Inside ? c4.getTangentAtTime(t2) : c4.getPointAt(offset).subtract(pt),
          v3 = t2Inside ? v4.negate() : c3.getPointAt(-offset).subtract(pt),
          a1 = v1.getAngle(),
          a2 = v2.getAngle(),
          a3 = v3.getAngle(),
          a4 = v4.getAngle();
      return !!(t1Inside ? isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4) && isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3) : isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2) && isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));
    },
    hasOverlap: function () {
      return !!this._overlap;
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    var get = name + 'At';

    this[name] = function () {
      var curve = this.getCurve(),
          time = this.getTime();
      return time != null && curve && curve[get](time, true);
    };
  }, {
    preserve: true
  }), new function () {
    function insert(locations, loc, merge) {
      var length = locations.length,
          l = 0,
          r = length - 1;

      function search(index, dir) {
        for (var i = index + dir; i >= -1 && i <= length; i += dir) {
          var loc2 = locations[(i % length + length) % length];
          if (!loc.getPoint().isClose(loc2.getPoint(), 1e-7)) break;
          if (loc.equals(loc2)) return loc2;
        }

        return null;
      }

      while (l <= r) {
        var m = l + r >>> 1,
            loc2 = locations[m],
            found;

        if (merge && (found = loc.equals(loc2) ? loc2 : search(m, -1) || search(m, 1))) {
          if (loc._overlap) {
            found._overlap = found._intersection._overlap = true;
          }

          return found;
        }

        var path1 = loc.getPath(),
            path2 = loc2.getPath(),
            diff = path1 !== path2 ? path1._id - path2._id : loc.getIndex() + loc.getTime() - (loc2.getIndex() + loc2.getTime());

        if (diff < 0) {
          r = m - 1;
        } else {
          l = m + 1;
        }
      }

      locations.splice(l, 0, loc);
      return loc;
    }

    return {
      statics: {
        insert: insert,
        expand: function (locations) {
          var expanded = locations.slice();

          for (var i = locations.length - 1; i >= 0; i--) {
            insert(expanded, locations[i]._intersection, false);
          }

          return expanded;
        }
      }
    };
  }());
  var PathItem = Item.extend({
    _class: 'PathItem',
    _selectBounds: false,
    _canScaleStroke: true,
    beans: true,
    initialize: function PathItem() {},
    statics: {
      create: function (arg) {
        var data, segments, compound;

        if (Base.isPlainObject(arg)) {
          segments = arg.segments;
          data = arg.pathData;
        } else if (Array.isArray(arg)) {
          segments = arg;
        } else if (typeof arg === 'string') {
          data = arg;
        }

        if (segments) {
          var first = segments[0];
          compound = first && Array.isArray(first[0]);
        } else if (data) {
          compound = (data.match(/m/gi) || []).length > 1 || /z\s*\S+/i.test(data);
        }

        var ctor = compound ? CompoundPath : Path;
        return new ctor(arg);
      }
    },
    _asPathItem: function () {
      return this;
    },
    isClockwise: function () {
      return this.getArea() >= 0;
    },
    setClockwise: function (clockwise) {
      if (this.isClockwise() != (clockwise = !!clockwise)) this.reverse();
    },
    setPathData: function (data) {
      var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
          coords,
          relative = false,
          previous,
          control,
          current = new Point(),
          start = new Point();

      function getCoord(index, coord) {
        var val = +coords[index];
        if (relative) val += current[coord];
        return val;
      }

      function getPoint(index) {
        return new Point(getCoord(index, 'x'), getCoord(index + 1, 'y'));
      }

      this.clear();

      for (var i = 0, l = parts && parts.length; i < l; i++) {
        var part = parts[i],
            command = part[0],
            lower = command.toLowerCase();
        coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
        var length = coords && coords.length;
        relative = command === lower;
        if (previous === 'z' && !/[mz]/.test(lower)) this.moveTo(current);

        switch (lower) {
          case 'm':
          case 'l':
            var move = lower === 'm';

            for (var j = 0; j < length; j += 2) {
              this[move ? 'moveTo' : 'lineTo'](current = getPoint(j));

              if (move) {
                start = current;
                move = false;
              }
            }

            control = current;
            break;

          case 'h':
          case 'v':
            var coord = lower === 'h' ? 'x' : 'y';
            current = current.clone();

            for (var j = 0; j < length; j++) {
              current[coord] = getCoord(j, coord);
              this.lineTo(current);
            }

            control = current;
            break;

          case 'c':
            for (var j = 0; j < length; j += 6) {
              this.cubicCurveTo(getPoint(j), control = getPoint(j + 2), current = getPoint(j + 4));
            }

            break;

          case 's':
            for (var j = 0; j < length; j += 4) {
              this.cubicCurveTo(/[cs]/.test(previous) ? current.multiply(2).subtract(control) : current, control = getPoint(j), current = getPoint(j + 2));
              previous = lower;
            }

            break;

          case 'q':
            for (var j = 0; j < length; j += 4) {
              this.quadraticCurveTo(control = getPoint(j), current = getPoint(j + 2));
            }

            break;

          case 't':
            for (var j = 0; j < length; j += 2) {
              this.quadraticCurveTo(control = /[qt]/.test(previous) ? current.multiply(2).subtract(control) : current, current = getPoint(j));
              previous = lower;
            }

            break;

          case 'a':
            for (var j = 0; j < length; j += 7) {
              this.arcTo(current = getPoint(j + 5), new Size(+coords[j], +coords[j + 1]), +coords[j + 2], +coords[j + 4], +coords[j + 3]);
            }

            break;

          case 'z':
            this.closePath(1e-12);
            current = start;
            break;
        }

        previous = lower;
      }
    },
    _canComposite: function () {
      return !(this.hasFill() && this.hasStroke());
    },
    _contains: function (point) {
      var winding = point.isInside(this.getBounds({
        internal: true,
        handle: true
      })) ? this._getWinding(point) : {};
      return winding.onPath || !!(this.getFillRule() === 'evenodd' ? winding.windingL & 1 || winding.windingR & 1 : winding.winding);
    },
    getIntersections: function (path, include, _matrix, _returnFirst) {
      var self = this === path || !path,
          matrix1 = this._matrix._orNullIfIdentity(),
          matrix2 = self ? matrix1 : (_matrix || path._matrix)._orNullIfIdentity();

      return self || this.getBounds(matrix1).intersects(path.getBounds(matrix2), 1e-12) ? Curve.getIntersections(this.getCurves(), !self && path.getCurves(), include, matrix1, matrix2, _returnFirst) : [];
    },
    getCrossings: function (path) {
      return this.getIntersections(path, function (inter) {
        return inter.isCrossing();
      });
    },
    getNearestLocation: function () {
      var point = Point.read(arguments),
          curves = this.getCurves(),
          minDist = Infinity,
          minLoc = null;

      for (var i = 0, l = curves.length; i < l; i++) {
        var loc = curves[i].getNearestLocation(point);

        if (loc._distance < minDist) {
          minDist = loc._distance;
          minLoc = loc;
        }
      }

      return minLoc;
    },
    getNearestPoint: function () {
      var loc = this.getNearestLocation.apply(this, arguments);
      return loc ? loc.getPoint() : loc;
    },
    interpolate: function (from, to, factor) {
      var isPath = !this._children,
          name = isPath ? '_segments' : '_children',
          itemsFrom = from[name],
          itemsTo = to[name],
          items = this[name];

      if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
        throw new Error('Invalid operands in interpolate() call: ' + from + ', ' + to);
      }

      var current = items.length,
          length = itemsTo.length;

      if (current < length) {
        var ctor = isPath ? Segment : Path;

        for (var i = current; i < length; i++) {
          this.add(new ctor());
        }
      } else if (current > length) {
        this[isPath ? 'removeSegments' : 'removeChildren'](length, current);
      }

      for (var i = 0; i < length; i++) {
        items[i].interpolate(itemsFrom[i], itemsTo[i], factor);
      }

      if (isPath) {
        this.setClosed(from._closed);

        this._changed(9);
      }
    },
    compare: function (path) {
      var ok = false;

      if (path) {
        var paths1 = this._children || [this],
            paths2 = path._children ? path._children.slice() : [path],
            length1 = paths1.length,
            length2 = paths2.length,
            matched = [],
            count = 0;
        ok = true;
        var boundsOverlaps = CollisionDetection.findItemBoundsCollisions(paths1, paths2, Numerical.GEOMETRIC_EPSILON);

        for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
          var path1 = paths1[i1];
          ok = false;
          var pathBoundsOverlaps = boundsOverlaps[i1];

          if (pathBoundsOverlaps) {
            for (var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--) {
              if (path1.compare(paths2[pathBoundsOverlaps[i2]])) {
                if (!matched[pathBoundsOverlaps[i2]]) {
                  matched[pathBoundsOverlaps[i2]] = true;
                  count++;
                }

                ok = true;
              }
            }
          }
        }

        ok = ok && count === length2;
      }

      return ok;
    }
  });
  var Path = PathItem.extend({
    _class: 'Path',
    _serializeFields: {
      segments: [],
      closed: false
    },
    initialize: function Path(arg) {
      this._closed = false;
      this._segments = [];
      this._version = 0;
      var args = arguments,
          segments = Array.isArray(arg) ? typeof arg[0] === 'object' ? arg : args : arg && arg.size === undefined && (arg.x !== undefined || arg.point !== undefined) ? args : null;

      if (segments && segments.length > 0) {
        this.setSegments(segments);
      } else {
        this._curves = undefined;
        this._segmentSelection = 0;

        if (!segments && typeof arg === 'string') {
          this.setPathData(arg);
          arg = null;
        }
      }

      this._initialize(!segments && arg);
    },
    _equals: function (item) {
      return this._closed === item._closed && Base.equals(this._segments, item._segments);
    },
    copyContent: function (source) {
      this.setSegments(source._segments);
      this._closed = source._closed;
    },
    _changed: function _changed(flags) {
      _changed.base.call(this, flags);

      if (flags & 8) {
        this._length = this._area = undefined;

        if (flags & 32) {
          this._version++;
        } else if (this._curves) {
          for (var i = 0, l = this._curves.length; i < l; i++) this._curves[i]._changed();
        }
      } else if (flags & 64) {
        this._bounds = undefined;
      }
    },
    getStyle: function () {
      var parent = this._parent;
      return (parent instanceof CompoundPath ? parent : this)._style;
    },
    getSegments: function () {
      return this._segments;
    },
    setSegments: function (segments) {
      var fullySelected = this.isFullySelected(),
          length = segments && segments.length;
      this._segments.length = 0;
      this._segmentSelection = 0;
      this._curves = undefined;

      if (length) {
        var last = segments[length - 1];

        if (typeof last === 'boolean') {
          this.setClosed(last);
          length--;
        }

        this._add(Segment.readList(segments, 0, {}, length));
      }

      if (fullySelected) this.setFullySelected(true);
    },
    getFirstSegment: function () {
      return this._segments[0];
    },
    getLastSegment: function () {
      return this._segments[this._segments.length - 1];
    },
    getCurves: function () {
      var curves = this._curves,
          segments = this._segments;

      if (!curves) {
        var length = this._countCurves();

        curves = this._curves = new Array(length);

        for (var i = 0; i < length; i++) curves[i] = new Curve(this, segments[i], segments[i + 1] || segments[0]);
      }

      return curves;
    },
    getFirstCurve: function () {
      return this.getCurves()[0];
    },
    getLastCurve: function () {
      var curves = this.getCurves();
      return curves[curves.length - 1];
    },
    isClosed: function () {
      return this._closed;
    },
    setClosed: function (closed) {
      if (this._closed != (closed = !!closed)) {
        this._closed = closed;

        if (this._curves) {
          var length = this._curves.length = this._countCurves();

          if (closed) this._curves[length - 1] = new Curve(this, this._segments[length - 1], this._segments[0]);
        }

        this._changed(41);
      }
    }
  }, {
    beans: true,
    getPathData: function (_matrix, _precision) {
      var segments = this._segments,
          length = segments.length,
          f = new Formatter(_precision),
          coords = new Array(6),
          first = true,
          curX,
          curY,
          prevX,
          prevY,
          inX,
          inY,
          outX,
          outY,
          parts = [];

      function addSegment(segment, skipLine) {
        segment._transformCoordinates(_matrix, coords);

        curX = coords[0];
        curY = coords[1];

        if (first) {
          parts.push('M' + f.pair(curX, curY));
          first = false;
        } else {
          inX = coords[2];
          inY = coords[3];

          if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
            if (!skipLine) {
              var dx = curX - prevX,
                  dy = curY - prevY;
              parts.push(dx === 0 ? 'v' + f.number(dy) : dy === 0 ? 'h' + f.number(dx) : 'l' + f.pair(dx, dy));
            }
          } else {
            parts.push('c' + f.pair(outX - prevX, outY - prevY) + ' ' + f.pair(inX - prevX, inY - prevY) + ' ' + f.pair(curX - prevX, curY - prevY));
          }
        }

        prevX = curX;
        prevY = curY;
        outX = coords[4];
        outY = coords[5];
      }

      if (!length) return '';

      for (var i = 0; i < length; i++) addSegment(segments[i]);

      if (this._closed && length > 0) {
        addSegment(segments[0], true);
        parts.push('z');
      }

      return parts.join('');
    },
    isEmpty: function () {
      return !this._segments.length;
    },
    _transformContent: function (matrix) {
      var segments = this._segments,
          coords = new Array(6);

      for (var i = 0, l = segments.length; i < l; i++) segments[i]._transformCoordinates(matrix, coords, true);

      return true;
    },
    _add: function (segs, index) {
      var segments = this._segments,
          curves = this._curves,
          amount = segs.length,
          append = index == null,
          index = append ? segments.length : index;

      for (var i = 0; i < amount; i++) {
        var segment = segs[i];
        if (segment._path) segment = segs[i] = segment.clone();
        segment._path = this;
        segment._index = index + i;
        if (segment._selection) this._updateSelection(segment, 0, segment._selection);
      }

      if (append) {
        Base.push(segments, segs);
      } else {
        segments.splice.apply(segments, [index, 0].concat(segs));

        for (var i = index + amount, l = segments.length; i < l; i++) segments[i]._index = i;
      }

      if (curves) {
        var total = this._countCurves(),
            start = index > 0 && index + amount - 1 === total ? index - 1 : index,
            insert = start,
            end = Math.min(start + amount, total);

        if (segs._curves) {
          curves.splice.apply(curves, [start, 0].concat(segs._curves));
          insert += segs._curves.length;
        }

        for (var i = insert; i < end; i++) curves.splice(i, 0, new Curve(this, null, null));

        this._adjustCurves(start, end);
      }

      this._changed(41);

      return segs;
    },
    _adjustCurves: function (start, end) {
      var segments = this._segments,
          curves = this._curves,
          curve;

      for (var i = start; i < end; i++) {
        curve = curves[i];
        curve._path = this;
        curve._segment1 = segments[i];
        curve._segment2 = segments[i + 1] || segments[0];

        curve._changed();
      }

      if (curve = curves[this._closed && !start ? segments.length - 1 : start - 1]) {
        curve._segment2 = segments[start] || segments[0];

        curve._changed();
      }

      if (curve = curves[end]) {
        curve._segment1 = segments[end];

        curve._changed();
      }
    },
    _countCurves: function () {
      var length = this._segments.length;
      return !this._closed && length > 0 ? length - 1 : length;
    },
    add: function (segment1) {
      var args = arguments;
      return args.length > 1 && typeof segment1 !== 'number' ? this._add(Segment.readList(args)) : this._add([Segment.read(args)])[0];
    },
    insert: function (index, segment1) {
      var args = arguments;
      return args.length > 2 && typeof segment1 !== 'number' ? this._add(Segment.readList(args, 1), index) : this._add([Segment.read(args, 1)], index)[0];
    },
    addSegment: function () {
      return this._add([Segment.read(arguments)])[0];
    },
    insertSegment: function (index) {
      return this._add([Segment.read(arguments, 1)], index)[0];
    },
    addSegments: function (segments) {
      return this._add(Segment.readList(segments));
    },
    insertSegments: function (index, segments) {
      return this._add(Segment.readList(segments), index);
    },
    removeSegment: function (index) {
      return this.removeSegments(index, index + 1)[0] || null;
    },
    removeSegments: function (start, end, _includeCurves) {
      start = start || 0;
      end = Base.pick(end, this._segments.length);
      var segments = this._segments,
          curves = this._curves,
          count = segments.length,
          removed = segments.splice(start, end - start),
          amount = removed.length;
      if (!amount) return removed;

      for (var i = 0; i < amount; i++) {
        var segment = removed[i];
        if (segment._selection) this._updateSelection(segment, segment._selection, 0);
        segment._index = segment._path = null;
      }

      for (var i = start, l = segments.length; i < l; i++) segments[i]._index = i;

      if (curves) {
        var index = start > 0 && end === count + (this._closed ? 1 : 0) ? start - 1 : start,
            curves = curves.splice(index, amount);

        for (var i = curves.length - 1; i >= 0; i--) curves[i]._path = null;

        if (_includeCurves) removed._curves = curves.slice(1);

        this._adjustCurves(index, index);
      }

      this._changed(41);

      return removed;
    },
    clear: '#removeSegments',
    hasHandles: function () {
      var segments = this._segments;

      for (var i = 0, l = segments.length; i < l; i++) {
        if (segments[i].hasHandles()) return true;
      }

      return false;
    },
    clearHandles: function () {
      var segments = this._segments;

      for (var i = 0, l = segments.length; i < l; i++) segments[i].clearHandles();
    },
    getLength: function () {
      if (this._length == null) {
        var curves = this.getCurves(),
            length = 0;

        for (var i = 0, l = curves.length; i < l; i++) length += curves[i].getLength();

        this._length = length;
      }

      return this._length;
    },
    getArea: function () {
      var area = this._area;

      if (area == null) {
        var segments = this._segments,
            closed = this._closed;
        area = 0;

        for (var i = 0, l = segments.length; i < l; i++) {
          var last = i + 1 === l;
          area += Curve.getArea(Curve.getValues(segments[i], segments[last ? 0 : i + 1], null, last && !closed));
        }

        this._area = area;
      }

      return area;
    },
    isFullySelected: function () {
      var length = this._segments.length;
      return this.isSelected() && length > 0 && this._segmentSelection === length * 7;
    },
    setFullySelected: function (selected) {
      if (selected) this._selectSegments(true);
      this.setSelected(selected);
    },
    setSelection: function setSelection(selection) {
      if (!(selection & 1)) this._selectSegments(false);
      setSelection.base.call(this, selection);
    },
    _selectSegments: function (selected) {
      var segments = this._segments,
          length = segments.length,
          selection = selected ? 7 : 0;
      this._segmentSelection = selection * length;

      for (var i = 0; i < length; i++) segments[i]._selection = selection;
    },
    _updateSelection: function (segment, oldSelection, newSelection) {
      segment._selection = newSelection;
      var selection = this._segmentSelection += newSelection - oldSelection;
      if (selection > 0) this.setSelected(true);
    },
    divideAt: function (location) {
      var loc = this.getLocationAt(location),
          curve;
      return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset())) ? curve._segment1 : null;
    },
    splitAt: function (location) {
      var loc = this.getLocationAt(location),
          index = loc && loc.index,
          time = loc && loc.time,
          tMin = 1e-8,
          tMax = 1 - tMin;

      if (time > tMax) {
        index++;
        time = 0;
      }

      var curves = this.getCurves();

      if (index >= 0 && index < curves.length) {
        if (time >= tMin) {
          curves[index++].divideAtTime(time);
        }

        var segs = this.removeSegments(index, this._segments.length, true),
            path;

        if (this._closed) {
          this.setClosed(false);
          path = this;
        } else {
          path = new Path(Item.NO_INSERT);
          path.insertAbove(this);
          path.copyAttributes(this);
        }

        path._add(segs, 0);

        this.addSegment(segs[0]);
        return path;
      }

      return null;
    },
    split: function (index, time) {
      var curve,
          location = time === undefined ? index : (curve = this.getCurves()[index]) && curve.getLocationAtTime(time);
      return location != null ? this.splitAt(location) : null;
    },
    join: function (path, tolerance) {
      var epsilon = tolerance || 0;

      if (path && path !== this) {
        var segments = path._segments,
            last1 = this.getLastSegment(),
            last2 = path.getLastSegment();
        if (!last2) return this;
        if (last1 && last1._point.isClose(last2._point, epsilon)) path.reverse();
        var first2 = path.getFirstSegment();

        if (last1 && last1._point.isClose(first2._point, epsilon)) {
          last1.setHandleOut(first2._handleOut);

          this._add(segments.slice(1));
        } else {
          var first1 = this.getFirstSegment();
          if (first1 && first1._point.isClose(first2._point, epsilon)) path.reverse();
          last2 = path.getLastSegment();

          if (first1 && first1._point.isClose(last2._point, epsilon)) {
            first1.setHandleIn(last2._handleIn);

            this._add(segments.slice(0, segments.length - 1), 0);
          } else {
            this._add(segments.slice());
          }
        }

        if (path._closed) this._add([segments[0]]);
        path.remove();
      }

      var first = this.getFirstSegment(),
          last = this.getLastSegment();

      if (first !== last && first._point.isClose(last._point, epsilon)) {
        first.setHandleIn(last._handleIn);
        last.remove();
        this.setClosed(true);
      }

      return this;
    },
    reduce: function (options) {
      var curves = this.getCurves(),
          simplify = options && options.simplify,
          tolerance = simplify ? 1e-7 : 0;

      for (var i = curves.length - 1; i >= 0; i--) {
        var curve = curves[i];
        if (!curve.hasHandles() && (!curve.hasLength(tolerance) || simplify && curve.isCollinear(curve.getNext()))) curve.remove();
      }

      return this;
    },
    reverse: function () {
      this._segments.reverse();

      for (var i = 0, l = this._segments.length; i < l; i++) {
        var segment = this._segments[i];
        var handleIn = segment._handleIn;
        segment._handleIn = segment._handleOut;
        segment._handleOut = handleIn;
        segment._index = i;
      }

      this._curves = null;

      this._changed(9);
    },
    flatten: function (flatness) {
      var flattener = new PathFlattener(this, flatness || 0.25, 256, true),
          parts = flattener.parts,
          length = parts.length,
          segments = [];

      for (var i = 0; i < length; i++) {
        segments.push(new Segment(parts[i].curve.slice(0, 2)));
      }

      if (!this._closed && length > 0) {
        segments.push(new Segment(parts[length - 1].curve.slice(6)));
      }

      this.setSegments(segments);
    },
    simplify: function (tolerance) {
      var segments = new PathFitter(this).fit(tolerance || 2.5);
      if (segments) this.setSegments(segments);
      return !!segments;
    },
    smooth: function (options) {
      var that = this,
          opts = options || {},
          type = opts.type || 'asymmetric',
          segments = this._segments,
          length = segments.length,
          closed = this._closed;

      function getIndex(value, _default) {
        var index = value && value.index;

        if (index != null) {
          var path = value.path;
          if (path && path !== that) throw new Error(value._class + ' ' + index + ' of ' + path + ' is not part of ' + that);
          if (_default && value instanceof Curve) index++;
        } else {
          index = typeof value === 'number' ? value : _default;
        }

        return Math.min(index < 0 && closed ? index % length : index < 0 ? index + length : index, length - 1);
      }

      var loop = closed && opts.from === undefined && opts.to === undefined,
          from = getIndex(opts.from, 0),
          to = getIndex(opts.to, length - 1);

      if (from > to) {
        if (closed) {
          from -= length;
        } else {
          var tmp = from;
          from = to;
          to = tmp;
        }
      }

      if (/^(?:asymmetric|continuous)$/.test(type)) {
        var asymmetric = type === 'asymmetric',
            min = Math.min,
            amount = to - from + 1,
            n = amount - 1,
            padding = loop ? min(amount, 4) : 1,
            paddingLeft = padding,
            paddingRight = padding,
            knots = [];

        if (!closed) {
          paddingLeft = min(1, from);
          paddingRight = min(1, length - to - 1);
        }

        n += paddingLeft + paddingRight;
        if (n <= 1) return;

        for (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {
          knots[i] = segments[(j < 0 ? j + length : j) % length]._point;
        }

        var x = knots[0]._x + 2 * knots[1]._x,
            y = knots[0]._y + 2 * knots[1]._y,
            f = 2,
            n_1 = n - 1,
            rx = [x],
            ry = [y],
            rf = [f],
            px = [],
            py = [];

        for (var i = 1; i < n; i++) {
          var internal = i < n_1,
              a = internal ? 1 : asymmetric ? 1 : 2,
              b = internal ? 4 : asymmetric ? 2 : 7,
              u = internal ? 4 : asymmetric ? 3 : 8,
              v = internal ? 2 : asymmetric ? 0 : 1,
              m = a / f;
          f = rf[i] = b - m;
          x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;
          y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;
        }

        px[n_1] = rx[n_1] / rf[n_1];
        py[n_1] = ry[n_1] / rf[n_1];

        for (var i = n - 2; i >= 0; i--) {
          px[i] = (rx[i] - px[i + 1]) / rf[i];
          py[i] = (ry[i] - py[i + 1]) / rf[i];
        }

        px[n] = (3 * knots[n]._x - px[n_1]) / 2;
        py[n] = (3 * knots[n]._y - py[n_1]) / 2;

        for (var i = paddingLeft, max = n - paddingRight, j = from; i <= max; i++, j++) {
          var segment = segments[j < 0 ? j + length : j],
              pt = segment._point,
              hx = px[i] - pt._x,
              hy = py[i] - pt._y;
          if (loop || i < max) segment.setHandleOut(hx, hy);
          if (loop || i > paddingLeft) segment.setHandleIn(-hx, -hy);
        }
      } else {
        for (var i = from; i <= to; i++) {
          segments[i < 0 ? i + length : i].smooth(opts, !loop && i === from, !loop && i === to);
        }
      }
    },
    toShape: function (insert) {
      if (!this._closed) return null;
      var segments = this._segments,
          type,
          size,
          radius,
          topCenter;

      function isCollinear(i, j) {
        var seg1 = segments[i],
            seg2 = seg1.getNext(),
            seg3 = segments[j],
            seg4 = seg3.getNext();
        return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg3._handleOut.isZero() && seg4._handleIn.isZero() && seg2._point.subtract(seg1._point).isCollinear(seg4._point.subtract(seg3._point));
      }

      function isOrthogonal(i) {
        var seg2 = segments[i],
            seg1 = seg2.getPrevious(),
            seg3 = seg2.getNext();
        return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg2._handleOut.isZero() && seg3._handleIn.isZero() && seg2._point.subtract(seg1._point).isOrthogonal(seg3._point.subtract(seg2._point));
      }

      function isArc(i) {
        var seg1 = segments[i],
            seg2 = seg1.getNext(),
            handle1 = seg1._handleOut,
            handle2 = seg2._handleIn,
            kappa = 0.5522847498307936;

        if (handle1.isOrthogonal(handle2)) {
          var pt1 = seg1._point,
              pt2 = seg2._point,
              corner = new Line(pt1, handle1, true).intersect(new Line(pt2, handle2, true), true);
          return corner && Numerical.isZero(handle1.getLength() / corner.subtract(pt1).getLength() - kappa) && Numerical.isZero(handle2.getLength() / corner.subtract(pt2).getLength() - kappa);
        }

        return false;
      }

      function getDistance(i, j) {
        return segments[i]._point.getDistance(segments[j]._point);
      }

      if (!this.hasHandles() && segments.length === 4 && isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
        type = Shape.Rectangle;
        size = new Size(getDistance(0, 3), getDistance(0, 1));
        topCenter = segments[1]._point.add(segments[2]._point).divide(2);
      } else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4) && isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
        type = Shape.Rectangle;
        size = new Size(getDistance(1, 6), getDistance(0, 3));
        radius = size.subtract(new Size(getDistance(0, 7), getDistance(1, 2))).divide(2);
        topCenter = segments[3]._point.add(segments[4]._point).divide(2);
      } else if (segments.length === 4 && isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
        if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
          type = Shape.Circle;
          radius = getDistance(0, 2) / 2;
        } else {
          type = Shape.Ellipse;
          radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
        }

        topCenter = segments[1]._point;
      }

      if (type) {
        var center = this.getPosition(true),
            shape = new type({
          center: center,
          size: size,
          radius: radius,
          insert: false
        });
        shape.copyAttributes(this, true);

        shape._matrix.prepend(this._matrix);

        shape.rotate(topCenter.subtract(center).getAngle() + 90);
        if (insert === undefined || insert) shape.insertAbove(this);
        return shape;
      }

      return null;
    },
    toPath: '#clone',
    compare: function compare(path) {
      if (!path || path instanceof CompoundPath) return compare.base.call(this, path);
      var curves1 = this.getCurves(),
          curves2 = path.getCurves(),
          length1 = curves1.length,
          length2 = curves2.length;

      if (!length1 || !length2) {
        return length1 == length2;
      }

      var v1 = curves1[0].getValues(),
          values2 = [],
          pos1 = 0,
          pos2,
          end1 = 0,
          end2;

      for (var i = 0; i < length2; i++) {
        var v2 = curves2[i].getValues();
        values2.push(v2);
        var overlaps = Curve.getOverlaps(v1, v2);

        if (overlaps) {
          pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;
          end2 = overlaps[0][1];
          break;
        }
      }

      var abs = Math.abs,
          epsilon = 1e-8,
          v2 = values2[pos2],
          start2;

      while (v1 && v2) {
        var overlaps = Curve.getOverlaps(v1, v2);

        if (overlaps) {
          var t1 = overlaps[0][0];

          if (abs(t1 - end1) < epsilon) {
            end1 = overlaps[1][0];

            if (end1 === 1) {
              v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
              end1 = 0;
            }

            var t2 = overlaps[0][1];

            if (abs(t2 - end2) < epsilon) {
              if (!start2) start2 = [pos2, t2];
              end2 = overlaps[1][1];

              if (end2 === 1) {
                if (++pos2 >= length2) pos2 = 0;
                v2 = values2[pos2] || curves2[pos2].getValues();
                end2 = 0;
              }

              if (!v1) {
                return start2[0] === pos2 && start2[1] === end2;
              }

              continue;
            }
          }
        }

        break;
      }

      return false;
    },
    _hitTestSelf: function (point, options, viewMatrix, strokeMatrix) {
      var that = this,
          style = this.getStyle(),
          segments = this._segments,
          numSegments = segments.length,
          closed = this._closed,
          tolerancePadding = options._tolerancePadding,
          strokePadding = tolerancePadding,
          join,
          cap,
          miterLimit,
          area,
          loc,
          res,
          hitStroke = options.stroke && style.hasStroke(),
          hitFill = options.fill && style.hasFill(),
          hitCurves = options.curves,
          strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : hitFill && options.tolerance > 0 || hitCurves ? 0 : null;

      if (strokeRadius !== null) {
        if (strokeRadius > 0) {
          join = style.getStrokeJoin();
          cap = style.getStrokeCap();
          miterLimit = style.getMiterLimit();
          strokePadding = strokePadding.add(Path._getStrokePadding(strokeRadius, strokeMatrix));
        } else {
          join = cap = 'round';
        }
      }

      function isCloseEnough(pt, padding) {
        return point.subtract(pt).divide(padding).length <= 1;
      }

      function checkSegmentPoint(seg, pt, name) {
        if (!options.selected || pt.isSelected()) {
          var anchor = seg._point;
          if (pt !== anchor) pt = pt.add(anchor);

          if (isCloseEnough(pt, strokePadding)) {
            return new HitResult(name, that, {
              segment: seg,
              point: pt
            });
          }
        }
      }

      function checkSegmentPoints(seg, ends) {
        return (ends || options.segments) && checkSegmentPoint(seg, seg._point, 'segment') || !ends && options.handles && (checkSegmentPoint(seg, seg._handleIn, 'handle-in') || checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
      }

      function addToArea(point) {
        area.add(point);
      }

      function checkSegmentStroke(segment) {
        var isJoin = closed || segment._index > 0 && segment._index < numSegments - 1;

        if ((isJoin ? join : cap) === 'round') {
          return isCloseEnough(segment._point, strokePadding);
        } else {
          area = new Path({
            internal: true,
            closed: true
          });

          if (isJoin) {
            if (!segment.isSmooth()) {
              Path._addBevelJoin(segment, join, strokeRadius, miterLimit, null, strokeMatrix, addToArea, true);
            }
          } else if (cap === 'square') {
            Path._addSquareCap(segment, cap, strokeRadius, null, strokeMatrix, addToArea, true);
          }

          if (!area.isEmpty()) {
            var loc;
            return area.contains(point) || (loc = area.getNearestLocation(point)) && isCloseEnough(loc.getPoint(), tolerancePadding);
          }
        }
      }

      if (options.ends && !options.segments && !closed) {
        if (res = checkSegmentPoints(segments[0], true) || checkSegmentPoints(segments[numSegments - 1], true)) return res;
      } else if (options.segments || options.handles) {
        for (var i = 0; i < numSegments; i++) if (res = checkSegmentPoints(segments[i])) return res;
      }

      if (strokeRadius !== null) {
        loc = this.getNearestLocation(point);

        if (loc) {
          var time = loc.getTime();

          if (time === 0 || time === 1 && numSegments > 1) {
            if (!checkSegmentStroke(loc.getSegment())) loc = null;
          } else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
            loc = null;
          }
        }

        if (!loc && join === 'miter' && numSegments > 1) {
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];

            if (point.getDistance(segment._point) <= miterLimit * strokeRadius && checkSegmentStroke(segment)) {
              loc = segment.getLocation();
              break;
            }
          }
        }
      }

      return !loc && hitFill && this._contains(point) || loc && !hitStroke && !hitCurves ? new HitResult('fill', this) : loc ? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
        location: loc,
        point: loc.getPoint()
      }) : null;
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    this[name + 'At'] = function (offset) {
      var loc = this.getLocationAt(offset);
      return loc && loc[name]();
    };
  }, {
    beans: false,
    getLocationOf: function () {
      var point = Point.read(arguments),
          curves = this.getCurves();

      for (var i = 0, l = curves.length; i < l; i++) {
        var loc = curves[i].getLocationOf(point);
        if (loc) return loc;
      }

      return null;
    },
    getOffsetOf: function () {
      var loc = this.getLocationOf.apply(this, arguments);
      return loc ? loc.getOffset() : null;
    },
    getLocationAt: function (offset) {
      if (typeof offset === 'number') {
        var curves = this.getCurves(),
            length = 0;

        for (var i = 0, l = curves.length; i < l; i++) {
          var start = length,
              curve = curves[i];
          length += curve.getLength();

          if (length > offset) {
            return curve.getLocationAt(offset - start);
          }
        }

        if (curves.length > 0 && offset <= this.getLength()) {
          return new CurveLocation(curves[curves.length - 1], 1);
        }
      } else if (offset && offset.getPath && offset.getPath() === this) {
        return offset;
      }

      return null;
    },
    getOffsetsWithTangent: function () {
      var tangent = Point.read(arguments);

      if (tangent.isZero()) {
        return [];
      }

      var offsets = [];
      var curveStart = 0;
      var curves = this.getCurves();

      for (var i = 0, l = curves.length; i < l; i++) {
        var curve = curves[i];
        var curveTimes = curve.getTimesWithTangent(tangent);

        for (var j = 0, m = curveTimes.length; j < m; j++) {
          var offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);

          if (offsets.indexOf(offset) < 0) {
            offsets.push(offset);
          }
        }

        curveStart += curve.length;
      }

      return offsets;
    }
  }), new function () {
    function drawHandles(ctx, segments, matrix, size) {
      if (size <= 0) return;
      var half = size / 2,
          miniSize = size - 2,
          miniHalf = half - 1,
          coords = new Array(6),
          pX,
          pY;

      function drawHandle(index) {
        var hX = coords[index],
            hY = coords[index + 1];

        if (pX != hX || pY != hY) {
          ctx.beginPath();
          ctx.moveTo(pX, pY);
          ctx.lineTo(hX, hY);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
          ctx.fill();
        }
      }

      for (var i = 0, l = segments.length; i < l; i++) {
        var segment = segments[i],
            selection = segment._selection;

        segment._transformCoordinates(matrix, coords);

        pX = coords[0];
        pY = coords[1];
        if (selection & 2) drawHandle(2);
        if (selection & 4) drawHandle(4);
        ctx.fillRect(pX - half, pY - half, size, size);

        if (miniSize > 0 && !(selection & 1)) {
          var fillStyle = ctx.fillStyle;
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);
          ctx.fillStyle = fillStyle;
        }
      }
    }

    function drawSegments(ctx, path, matrix) {
      var segments = path._segments,
          length = segments.length,
          coords = new Array(6),
          first = true,
          curX,
          curY,
          prevX,
          prevY,
          inX,
          inY,
          outX,
          outY;

      function drawSegment(segment) {
        if (matrix) {
          segment._transformCoordinates(matrix, coords);

          curX = coords[0];
          curY = coords[1];
        } else {
          var point = segment._point;
          curX = point._x;
          curY = point._y;
        }

        if (first) {
          ctx.moveTo(curX, curY);
          first = false;
        } else {
          if (matrix) {
            inX = coords[2];
            inY = coords[3];
          } else {
            var handle = segment._handleIn;
            inX = curX + handle._x;
            inY = curY + handle._y;
          }

          if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
            ctx.lineTo(curX, curY);
          } else {
            ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
          }
        }

        prevX = curX;
        prevY = curY;

        if (matrix) {
          outX = coords[4];
          outY = coords[5];
        } else {
          var handle = segment._handleOut;
          outX = prevX + handle._x;
          outY = prevY + handle._y;
        }
      }

      for (var i = 0; i < length; i++) drawSegment(segments[i]);

      if (path._closed && length > 0) drawSegment(segments[0]);
    }

    return {
      _draw: function (ctx, param, viewMatrix, strokeMatrix) {
        var dontStart = param.dontStart,
            dontPaint = param.dontFinish || param.clip,
            style = this.getStyle(),
            hasFill = style.hasFill(),
            hasStroke = style.hasStroke(),
            dashArray = style.getDashArray(),
            dashLength = !paper.support.nativeDash && hasStroke && dashArray && dashArray.length;
        if (!dontStart) ctx.beginPath();

        if (hasFill || hasStroke && !dashLength || dontPaint) {
          drawSegments(ctx, this, strokeMatrix);
          if (this._closed) ctx.closePath();
        }

        function getOffset(i) {
          return dashArray[(i % dashLength + dashLength) % dashLength];
        }

        if (!dontPaint && (hasFill || hasStroke)) {
          this._setStyles(ctx, param, viewMatrix);

          if (hasFill) {
            ctx.fill(style.getFillRule());
            ctx.shadowColor = 'rgba(0,0,0,0)';
          }

          if (hasStroke) {
            if (dashLength) {
              if (!dontStart) ctx.beginPath();
              var flattener = new PathFlattener(this, 0.25, 32, false, strokeMatrix),
                  length = flattener.length,
                  from = -style.getDashOffset(),
                  to,
                  i = 0;

              while (from > 0) {
                from -= getOffset(i--) + getOffset(i--);
              }

              while (from < length) {
                to = from + getOffset(i++);
                if (from > 0 || to > 0) flattener.drawPart(ctx, Math.max(from, 0), Math.max(to, 0));
                from = to + getOffset(i++);
              }
            }

            ctx.stroke();
          }
        }
      },
      _drawSelected: function (ctx, matrix) {
        ctx.beginPath();
        drawSegments(ctx, this, matrix);
        ctx.stroke();
        drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
      }
    };
  }(), new function () {
    function getCurrentSegment(that) {
      var segments = that._segments;
      if (!segments.length) throw new Error('Use a moveTo() command first');
      return segments[segments.length - 1];
    }

    return {
      moveTo: function () {
        var segments = this._segments;
        if (segments.length === 1) this.removeSegment(0);
        if (!segments.length) this._add([new Segment(Point.read(arguments))]);
      },
      moveBy: function () {
        throw new Error('moveBy() is unsupported on Path items.');
      },
      lineTo: function () {
        this._add([new Segment(Point.read(arguments))]);
      },
      cubicCurveTo: function () {
        var args = arguments,
            handle1 = Point.read(args),
            handle2 = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this);
        current.setHandleOut(handle1.subtract(current._point));

        this._add([new Segment(to, handle2.subtract(to))]);
      },
      quadraticCurveTo: function () {
        var args = arguments,
            handle = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.cubicCurveTo(handle.add(current.subtract(handle).multiply(1 / 3)), handle.add(to.subtract(handle).multiply(1 / 3)), to);
      },
      curveTo: function () {
        var args = arguments,
            through = Point.read(args),
            to = Point.read(args),
            t = Base.pick(Base.read(args), 0.5),
            t1 = 1 - t,
            current = getCurrentSegment(this)._point,
            handle = through.subtract(current.multiply(t1 * t1)).subtract(to.multiply(t * t)).divide(2 * t * t1);

        if (handle.isNaN()) throw new Error('Cannot put a curve through points with parameter = ' + t);
        this.quadraticCurveTo(handle, to);
      },
      arcTo: function () {
        var args = arguments,
            abs = Math.abs,
            sqrt = Math.sqrt,
            current = getCurrentSegment(this),
            from = current._point,
            to = Point.read(args),
            through,
            peek = Base.peek(args),
            clockwise = Base.pick(peek, true),
            center,
            extent,
            vector,
            matrix;

        if (typeof clockwise === 'boolean') {
          var middle = from.add(to).divide(2),
              through = middle.add(middle.subtract(from).rotate(clockwise ? -90 : 90));
        } else if (Base.remain(args) <= 2) {
          through = to;
          to = Point.read(args);
        } else if (!from.equals(to)) {
          var radius = Size.read(args),
              isZero = Numerical.isZero;
          if (isZero(radius.width) || isZero(radius.height)) return this.lineTo(to);
          var rotation = Base.read(args),
              clockwise = !!Base.read(args),
              large = !!Base.read(args),
              middle = from.add(to).divide(2),
              pt = from.subtract(middle).rotate(-rotation),
              x = pt.x,
              y = pt.y,
              rx = abs(radius.width),
              ry = abs(radius.height),
              rxSq = rx * rx,
              rySq = ry * ry,
              xSq = x * x,
              ySq = y * y;
          var factor = sqrt(xSq / rxSq + ySq / rySq);

          if (factor > 1) {
            rx *= factor;
            ry *= factor;
            rxSq = rx * rx;
            rySq = ry * ry;
          }

          factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) / (rxSq * ySq + rySq * xSq);
          if (abs(factor) < 1e-12) factor = 0;
          if (factor < 0) throw new Error('Cannot create an arc with the given arguments');
          center = new Point(rx * y / ry, -ry * x / rx).multiply((large === clockwise ? -1 : 1) * sqrt(factor)).rotate(rotation).add(middle);
          matrix = new Matrix().translate(center).rotate(rotation).scale(rx, ry);
          vector = matrix._inverseTransform(from);
          extent = vector.getDirectedAngle(matrix._inverseTransform(to));
          if (!clockwise && extent > 0) extent -= 360;else if (clockwise && extent < 0) extent += 360;
        }

        if (through) {
          var l1 = new Line(from.add(through).divide(2), through.subtract(from).rotate(90), true),
              l2 = new Line(through.add(to).divide(2), to.subtract(through).rotate(90), true),
              line = new Line(from, to),
              throughSide = line.getSide(through);
          center = l1.intersect(l2, true);

          if (!center) {
            if (!throughSide) return this.lineTo(to);
            throw new Error('Cannot create an arc with the given arguments');
          }

          vector = from.subtract(center);
          extent = vector.getDirectedAngle(to.subtract(center));
          var centerSide = line.getSide(center, true);

          if (centerSide === 0) {
            extent = throughSide * abs(extent);
          } else if (throughSide === centerSide) {
            extent += extent < 0 ? 360 : -360;
          }
        }

        if (extent) {
          var epsilon = 1e-7,
              ext = abs(extent),
              count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),
              inc = extent / count,
              half = inc * Math.PI / 360,
              z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
              segments = [];

          for (var i = 0; i <= count; i++) {
            var pt = to,
                out = null;

            if (i < count) {
              out = vector.rotate(90).multiply(z);

              if (matrix) {
                pt = matrix._transformPoint(vector);
                out = matrix._transformPoint(vector.add(out)).subtract(pt);
              } else {
                pt = center.add(vector);
              }
            }

            if (!i) {
              current.setHandleOut(out);
            } else {
              var _in = vector.rotate(-90).multiply(z);

              if (matrix) {
                _in = matrix._transformPoint(vector.add(_in)).subtract(pt);
              }

              segments.push(new Segment(pt, _in, out));
            }

            vector = vector.rotate(inc);
          }

          this._add(segments);
        }
      },
      lineBy: function () {
        var to = Point.read(arguments),
            current = getCurrentSegment(this)._point;

        this.lineTo(current.add(to));
      },
      curveBy: function () {
        var args = arguments,
            through = Point.read(args),
            to = Point.read(args),
            parameter = Base.read(args),
            current = getCurrentSegment(this)._point;

        this.curveTo(current.add(through), current.add(to), parameter);
      },
      cubicCurveBy: function () {
        var args = arguments,
            handle1 = Point.read(args),
            handle2 = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.cubicCurveTo(current.add(handle1), current.add(handle2), current.add(to));
      },
      quadraticCurveBy: function () {
        var args = arguments,
            handle = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.quadraticCurveTo(current.add(handle), current.add(to));
      },
      arcBy: function () {
        var args = arguments,
            current = getCurrentSegment(this)._point,
            point = current.add(Point.read(args)),
            clockwise = Base.pick(Base.peek(args), true);

        if (typeof clockwise === 'boolean') {
          this.arcTo(point, clockwise);
        } else {
          this.arcTo(point, current.add(Point.read(args)));
        }
      },
      closePath: function (tolerance) {
        this.setClosed(true);
        this.join(this, tolerance);
      }
    };
  }(), {
    _getBounds: function (matrix, options) {
      var method = options.handle ? 'getHandleBounds' : options.stroke ? 'getStrokeBounds' : 'getBounds';
      return Path[method](this._segments, this._closed, this, matrix, options);
    },
    statics: {
      getBounds: function (segments, closed, path, matrix, options, strokePadding) {
        var first = segments[0];
        if (!first) return new Rectangle();

        var coords = new Array(6),
            prevCoords = first._transformCoordinates(matrix, new Array(6)),
            min = prevCoords.slice(0, 2),
            max = min.slice(),
            roots = new Array(2);

        function processSegment(segment) {
          segment._transformCoordinates(matrix, coords);

          for (var i = 0; i < 2; i++) {
            Curve._addBounds(prevCoords[i], prevCoords[i + 4], coords[i + 2], coords[i], i, strokePadding ? strokePadding[i] : 0, min, max, roots);
          }

          var tmp = prevCoords;
          prevCoords = coords;
          coords = tmp;
        }

        for (var i = 1, l = segments.length; i < l; i++) processSegment(segments[i]);

        if (closed) processSegment(first);
        return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      getStrokeBounds: function (segments, closed, path, matrix, options) {
        var style = path.getStyle(),
            stroke = style.hasStroke(),
            strokeWidth = style.getStrokeWidth(),
            strokeMatrix = stroke && path._getStrokeMatrix(matrix, options),
            strokePadding = stroke && Path._getStrokePadding(strokeWidth, strokeMatrix),
            bounds = Path.getBounds(segments, closed, path, matrix, options, strokePadding);

        if (!stroke) return bounds;
        var strokeRadius = strokeWidth / 2,
            join = style.getStrokeJoin(),
            cap = style.getStrokeCap(),
            miterLimit = style.getMiterLimit(),
            joinBounds = new Rectangle(new Size(strokePadding));

        function addPoint(point) {
          bounds = bounds.include(point);
        }

        function addRound(segment) {
          bounds = bounds.unite(joinBounds.setCenter(segment._point.transform(matrix)));
        }

        function addJoin(segment, join) {
          if (join === 'round' || segment.isSmooth()) {
            addRound(segment);
          } else {
            Path._addBevelJoin(segment, join, strokeRadius, miterLimit, matrix, strokeMatrix, addPoint);
          }
        }

        function addCap(segment, cap) {
          if (cap === 'round') {
            addRound(segment);
          } else {
            Path._addSquareCap(segment, cap, strokeRadius, matrix, strokeMatrix, addPoint);
          }
        }

        var length = segments.length - (closed ? 0 : 1);

        if (length > 0) {
          for (var i = 1; i < length; i++) {
            addJoin(segments[i], join);
          }

          if (closed) {
            addJoin(segments[0], join);
          } else {
            addCap(segments[0], cap);
            addCap(segments[segments.length - 1], cap);
          }
        }

        return bounds;
      },
      _getStrokePadding: function (radius, matrix) {
        if (!matrix) return [radius, radius];
        var hor = new Point(radius, 0).transform(matrix),
            ver = new Point(0, radius).transform(matrix),
            phi = hor.getAngleInRadians(),
            a = hor.getLength(),
            b = ver.getLength();
        var sin = Math.sin(phi),
            cos = Math.cos(phi),
            tan = Math.tan(phi),
            tx = Math.atan2(b * tan, a),
            ty = Math.atan2(b, tan * a);
        return [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin), Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
      },
      _addBevelJoin: function (segment, join, radius, miterLimit, matrix, strokeMatrix, addPoint, isArea) {
        var curve2 = segment.getCurve(),
            curve1 = curve2.getPrevious(),
            point = curve2.getPoint1().transform(matrix),
            normal1 = curve1.getNormalAtTime(1).multiply(radius).transform(strokeMatrix),
            normal2 = curve2.getNormalAtTime(0).multiply(radius).transform(strokeMatrix),
            angle = normal1.getDirectedAngle(normal2);

        if (angle < 0 || angle >= 180) {
          normal1 = normal1.negate();
          normal2 = normal2.negate();
        }

        if (isArea) addPoint(point);
        addPoint(point.add(normal1));

        if (join === 'miter') {
          var corner = new Line(point.add(normal1), new Point(-normal1.y, normal1.x), true).intersect(new Line(point.add(normal2), new Point(-normal2.y, normal2.x), true), true);

          if (corner && point.getDistance(corner) <= miterLimit * radius) {
            addPoint(corner);
          }
        }

        addPoint(point.add(normal2));
      },
      _addSquareCap: function (segment, cap, radius, matrix, strokeMatrix, addPoint, isArea) {
        var point = segment._point.transform(matrix),
            loc = segment.getLocation(),
            normal = loc.getNormal().multiply(loc.getTime() === 0 ? radius : -radius).transform(strokeMatrix);

        if (cap === 'square') {
          if (isArea) {
            addPoint(point.subtract(normal));
            addPoint(point.add(normal));
          }

          point = point.add(normal.rotate(-90));
        }

        addPoint(point.add(normal));
        addPoint(point.subtract(normal));
      },
      getHandleBounds: function (segments, closed, path, matrix, options) {
        var style = path.getStyle(),
            stroke = options.stroke && style.hasStroke(),
            strokePadding,
            joinPadding;

        if (stroke) {
          var strokeMatrix = path._getStrokeMatrix(matrix, options),
              strokeRadius = style.getStrokeWidth() / 2,
              joinRadius = strokeRadius;

          if (style.getStrokeJoin() === 'miter') joinRadius = strokeRadius * style.getMiterLimit();
          if (style.getStrokeCap() === 'square') joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
          strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
          joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
        }

        var coords = new Array(6),
            x1 = Infinity,
            x2 = -x1,
            y1 = x1,
            y2 = x2;

        for (var i = 0, l = segments.length; i < l; i++) {
          var segment = segments[i];

          segment._transformCoordinates(matrix, coords);

          for (var j = 0; j < 6; j += 2) {
            var padding = !j ? joinPadding : strokePadding,
                paddingX = padding ? padding[0] : 0,
                paddingY = padding ? padding[1] : 0,
                x = coords[j],
                y = coords[j + 1],
                xn = x - paddingX,
                xx = x + paddingX,
                yn = y - paddingY,
                yx = y + paddingY;
            if (xn < x1) x1 = xn;
            if (xx > x2) x2 = xx;
            if (yn < y1) y1 = yn;
            if (yx > y2) y2 = yx;
          }
        }

        return new Rectangle(x1, y1, x2 - x1, y2 - y1);
      }
    }
  });
  Path.inject({
    statics: new function () {
      var kappa = 0.5522847498307936,
          ellipseSegments = [new Segment([-1, 0], [0, kappa], [0, -kappa]), new Segment([0, -1], [-kappa, 0], [kappa, 0]), new Segment([1, 0], [0, -kappa], [0, kappa]), new Segment([0, 1], [kappa, 0], [-kappa, 0])];

      function createPath(segments, closed, args) {
        var props = Base.getNamed(args),
            path = new Path(props && props.insert == false && Item.NO_INSERT);

        path._add(segments);

        path._closed = closed;
        return path.set(props, {
          insert: true
        });
      }

      function createEllipse(center, radius, args) {
        var segments = new Array(4);

        for (var i = 0; i < 4; i++) {
          var segment = ellipseSegments[i];
          segments[i] = new Segment(segment._point.multiply(radius).add(center), segment._handleIn.multiply(radius), segment._handleOut.multiply(radius));
        }

        return createPath(segments, true, args);
      }

      return {
        Line: function () {
          var args = arguments;
          return createPath([new Segment(Point.readNamed(args, 'from')), new Segment(Point.readNamed(args, 'to'))], false, args);
        },
        Circle: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              radius = Base.readNamed(args, 'radius');
          return createEllipse(center, new Size(radius), args);
        },
        Rectangle: function () {
          var args = arguments,
              rect = Rectangle.readNamed(args, 'rectangle'),
              radius = Size.readNamed(args, 'radius', 0, {
            readNull: true
          }),
              bl = rect.getBottomLeft(true),
              tl = rect.getTopLeft(true),
              tr = rect.getTopRight(true),
              br = rect.getBottomRight(true),
              segments;

          if (!radius || radius.isZero()) {
            segments = [new Segment(bl), new Segment(tl), new Segment(tr), new Segment(br)];
          } else {
            radius = Size.min(radius, rect.getSize(true).divide(2));
            var rx = radius.width,
                ry = radius.height,
                hx = rx * kappa,
                hy = ry * kappa;
            segments = [new Segment(bl.add(rx, 0), null, [-hx, 0]), new Segment(bl.subtract(0, ry), [0, hy]), new Segment(tl.add(0, ry), null, [0, -hy]), new Segment(tl.add(rx, 0), [-hx, 0], null), new Segment(tr.subtract(rx, 0), null, [hx, 0]), new Segment(tr.add(0, ry), [0, -hy], null), new Segment(br.subtract(0, ry), null, [0, hy]), new Segment(br.subtract(rx, 0), [hx, 0])];
          }

          return createPath(segments, true, args);
        },
        RoundRectangle: '#Rectangle',
        Ellipse: function () {
          var args = arguments,
              ellipse = Shape._readEllipse(args);

          return createEllipse(ellipse.center, ellipse.radius, args);
        },
        Oval: '#Ellipse',
        Arc: function () {
          var args = arguments,
              from = Point.readNamed(args, 'from'),
              through = Point.readNamed(args, 'through'),
              to = Point.readNamed(args, 'to'),
              props = Base.getNamed(args),
              path = new Path(props && props.insert == false && Item.NO_INSERT);
          path.moveTo(from);
          path.arcTo(through, to);
          return path.set(props);
        },
        RegularPolygon: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              sides = Base.readNamed(args, 'sides'),
              radius = Base.readNamed(args, 'radius'),
              step = 360 / sides,
              three = sides % 3 === 0,
              vector = new Point(0, three ? -radius : radius),
              offset = three ? -1 : 0.5,
              segments = new Array(sides);

          for (var i = 0; i < sides; i++) segments[i] = new Segment(center.add(vector.rotate((i + offset) * step)));

          return createPath(segments, true, args);
        },
        Star: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              points = Base.readNamed(args, 'points') * 2,
              radius1 = Base.readNamed(args, 'radius1'),
              radius2 = Base.readNamed(args, 'radius2'),
              step = 360 / points,
              vector = new Point(0, -1),
              segments = new Array(points);

          for (var i = 0; i < points; i++) segments[i] = new Segment(center.add(vector.rotate(step * i).multiply(i % 2 ? radius2 : radius1)));

          return createPath(segments, true, args);
        }
      };
    }()
  });
  var CompoundPath = PathItem.extend({
    _class: 'CompoundPath',
    _serializeFields: {
      children: []
    },
    beans: true,
    initialize: function CompoundPath(arg) {
      this._children = [];
      this._namedChildren = {};

      if (!this._initialize(arg)) {
        if (typeof arg === 'string') {
          this.setPathData(arg);
        } else {
          this.addChildren(Array.isArray(arg) ? arg : arguments);
        }
      }
    },
    insertChildren: function insertChildren(index, items) {
      var list = items,
          first = list[0];
      if (first && typeof first[0] === 'number') list = [list];

      for (var i = items.length - 1; i >= 0; i--) {
        var item = list[i];
        if (list === items && !(item instanceof Path)) list = Base.slice(list);

        if (Array.isArray(item)) {
          list[i] = new Path({
            segments: item,
            insert: false
          });
        } else if (item instanceof CompoundPath) {
          list.splice.apply(list, [i, 1].concat(item.removeChildren()));
          item.remove();
        }
      }

      return insertChildren.base.call(this, index, list);
    },
    reduce: function reduce(options) {
      var children = this._children;

      for (var i = children.length - 1; i >= 0; i--) {
        var path = children[i].reduce(options);
        if (path.isEmpty()) path.remove();
      }

      if (!children.length) {
        var path = new Path(Item.NO_INSERT);
        path.copyAttributes(this);
        path.insertAbove(this);
        this.remove();
        return path;
      }

      return reduce.base.call(this);
    },
    isClosed: function () {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        if (!children[i]._closed) return false;
      }

      return true;
    },
    setClosed: function (closed) {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].setClosed(closed);
      }
    },
    getFirstSegment: function () {
      var first = this.getFirstChild();
      return first && first.getFirstSegment();
    },
    getLastSegment: function () {
      var last = this.getLastChild();
      return last && last.getLastSegment();
    },
    getCurves: function () {
      var children = this._children,
          curves = [];

      for (var i = 0, l = children.length; i < l; i++) {
        Base.push(curves, children[i].getCurves());
      }

      return curves;
    },
    getFirstCurve: function () {
      var first = this.getFirstChild();
      return first && first.getFirstCurve();
    },
    getLastCurve: function () {
      var last = this.getLastChild();
      return last && last.getLastCurve();
    },
    getArea: function () {
      var children = this._children,
          area = 0;

      for (var i = 0, l = children.length; i < l; i++) area += children[i].getArea();

      return area;
    },
    getLength: function () {
      var children = this._children,
          length = 0;

      for (var i = 0, l = children.length; i < l; i++) length += children[i].getLength();

      return length;
    },
    getPathData: function (_matrix, _precision) {
      var children = this._children,
          paths = [];

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i],
            mx = child._matrix;
        paths.push(child.getPathData(_matrix && !mx.isIdentity() ? _matrix.appended(mx) : _matrix, _precision));
      }

      return paths.join('');
    },
    _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
      return _hitTestChildren.base.call(this, point, options.class === Path || options.type === 'path' ? options : Base.set({}, options, {
        fill: false
      }), viewMatrix);
    },
    _draw: function (ctx, param, viewMatrix, strokeMatrix) {
      var children = this._children;
      if (!children.length) return;
      param = param.extend({
        dontStart: true,
        dontFinish: true
      });
      ctx.beginPath();

      for (var i = 0, l = children.length; i < l; i++) children[i].draw(ctx, param, strokeMatrix);

      if (!param.clip) {
        this._setStyles(ctx, param, viewMatrix);

        var style = this._style;

        if (style.hasFill()) {
          ctx.fill(style.getFillRule());
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (style.hasStroke()) ctx.stroke();
      }
    },
    _drawSelected: function (ctx, matrix, selectionItems) {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i],
            mx = child._matrix;

        if (!selectionItems[child._id]) {
          child._drawSelected(ctx, mx.isIdentity() ? matrix : matrix.appended(mx));
        }
      }
    }
  }, new function () {
    function getCurrentPath(that, check) {
      var children = that._children;
      if (check && !children.length) throw new Error('Use a moveTo() command first');
      return children[children.length - 1];
    }

    return Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'], function (key) {
      this[key] = function () {
        var path = getCurrentPath(this, true);
        path[key].apply(path, arguments);
      };
    }, {
      moveTo: function () {
        var current = getCurrentPath(this),
            path = current && current.isEmpty() ? current : new Path(Item.NO_INSERT);
        if (path !== current) this.addChild(path);
        path.moveTo.apply(path, arguments);
      },
      moveBy: function () {
        var current = getCurrentPath(this, true),
            last = current && current.getLastSegment(),
            point = Point.read(arguments);
        this.moveTo(last ? point.add(last._point) : point);
      },
      closePath: function (tolerance) {
        getCurrentPath(this, true).closePath(tolerance);
      }
    });
  }(), Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function (key) {
    this[key] = function (param) {
      var children = this._children,
          res;

      for (var i = 0, l = children.length; i < l; i++) {
        res = children[i][key](param) || res;
      }

      return res;
    };
  }, {}));
  PathItem.inject(new function () {
    var min = Math.min,
        max = Math.max,
        abs = Math.abs,
        operators = {
      unite: {
        '1': true,
        '2': true
      },
      intersect: {
        '2': true
      },
      subtract: {
        '1': true
      },
      exclude: {
        '1': true,
        '-1': true
      }
    };

    function getPaths(path) {
      return path._children || [path];
    }

    function preparePath(path, resolve) {
      var res = path.clone(false).reduce({
        simplify: true
      }).transform(null, true, true);

      if (resolve) {
        var paths = getPaths(res);

        for (var i = 0, l = paths.length; i < l; i++) {
          var path = paths[i];

          if (!path._closed && !path.isEmpty()) {
            path.closePath(1e-12);
            path.getFirstSegment().setHandleIn(0, 0);
            path.getLastSegment().setHandleOut(0, 0);
          }
        }

        res = res.resolveCrossings().reorient(res.getFillRule() === 'nonzero', true);
      }

      return res;
    }

    function createResult(paths, simplify, path1, path2, options) {
      var result = new CompoundPath(Item.NO_INSERT);
      result.addChildren(paths, true);
      result = result.reduce({
        simplify: simplify
      });

      if (!(options && options.insert == false)) {
        result.insertAbove(path2 && path1.isSibling(path2) && path1.getIndex() < path2.getIndex() ? path2 : path1);
      }

      result.copyAttributes(path1, true);
      return result;
    }

    function filterIntersection(inter) {
      return inter.hasOverlap() || inter.isCrossing();
    }

    function traceBoolean(path1, path2, operation, options) {
      if (options && (options.trace == false || options.stroke) && /^(subtract|intersect)$/.test(operation)) return splitBoolean(path1, path2, operation);

      var _path1 = preparePath(path1, true),
          _path2 = path2 && path1 !== path2 && preparePath(path2, true),
          operator = operators[operation];

      operator[operation] = true;
      if (_path2 && (operator.subtract || operator.exclude) ^ (_path2.isClockwise() ^ _path1.isClockwise())) _path2.reverse();

      var crossings = divideLocations(CurveLocation.expand(_path1.getIntersections(_path2, filterIntersection))),
          paths1 = getPaths(_path1),
          paths2 = _path2 && getPaths(_path2),
          segments = [],
          curves = [],
          paths;

      function collectPaths(paths) {
        for (var i = 0, l = paths.length; i < l; i++) {
          var path = paths[i];
          Base.push(segments, path._segments);
          Base.push(curves, path.getCurves());
          path._overlapsOnly = true;
        }
      }

      function getCurves(indices) {
        var list = [];

        for (var i = 0, l = indices && indices.length; i < l; i++) {
          list.push(curves[indices[i]]);
        }

        return list;
      }

      if (crossings.length) {
        collectPaths(paths1);
        if (paths2) collectPaths(paths2);
        var curvesValues = new Array(curves.length);

        for (var i = 0, l = curves.length; i < l; i++) {
          curvesValues[i] = curves[i].getValues();
        }

        var curveCollisions = CollisionDetection.findCurveBoundsCollisions(curvesValues, curvesValues, 0, true);
        var curveCollisionsMap = {};

        for (var i = 0; i < curves.length; i++) {
          var curve = curves[i],
              id = curve._path._id,
              map = curveCollisionsMap[id] = curveCollisionsMap[id] || {};
          map[curve.getIndex()] = {
            hor: getCurves(curveCollisions[i].hor),
            ver: getCurves(curveCollisions[i].ver)
          };
        }

        for (var i = 0, l = crossings.length; i < l; i++) {
          propagateWinding(crossings[i]._segment, _path1, _path2, curveCollisionsMap, operator);
        }

        for (var i = 0, l = segments.length; i < l; i++) {
          var segment = segments[i],
              inter = segment._intersection;

          if (!segment._winding) {
            propagateWinding(segment, _path1, _path2, curveCollisionsMap, operator);
          }

          if (!(inter && inter._overlap)) segment._path._overlapsOnly = false;
        }

        paths = tracePaths(segments, operator);
      } else {
        paths = reorientPaths(paths2 ? paths1.concat(paths2) : paths1.slice(), function (w) {
          return !!operator[w];
        });
      }

      return createResult(paths, true, path1, path2, options);
    }

    function splitBoolean(path1, path2, operation) {
      var _path1 = preparePath(path1),
          _path2 = preparePath(path2),
          crossings = _path1.getIntersections(_path2, filterIntersection),
          subtract = operation === 'subtract',
          divide = operation === 'divide',
          added = {},
          paths = [];

      function addPath(path) {
        if (!added[path._id] && (divide || _path2.contains(path.getPointAt(path.getLength() / 2)) ^ subtract)) {
          paths.unshift(path);
          return added[path._id] = true;
        }
      }

      for (var i = crossings.length - 1; i >= 0; i--) {
        var path = crossings[i].split();

        if (path) {
          if (addPath(path)) path.getFirstSegment().setHandleIn(0, 0);

          _path1.getLastSegment().setHandleOut(0, 0);
        }
      }

      addPath(_path1);
      return createResult(paths, false, path1, path2);
    }

    function linkIntersections(from, to) {
      var prev = from;

      while (prev) {
        if (prev === to) return;
        prev = prev._previous;
      }

      while (from._next && from._next !== to) from = from._next;

      if (!from._next) {
        while (to._previous) to = to._previous;

        from._next = to;
        to._previous = from;
      }
    }

    function clearCurveHandles(curves) {
      for (var i = curves.length - 1; i >= 0; i--) curves[i].clearHandles();
    }

    function reorientPaths(paths, isInside, clockwise) {
      var length = paths && paths.length;

      if (length) {
        var lookup = Base.each(paths, function (path, i) {
          this[path._id] = {
            container: null,
            winding: path.isClockwise() ? 1 : -1,
            index: i
          };
        }, {}),
            sorted = paths.slice().sort(function (a, b) {
          return abs(b.getArea()) - abs(a.getArea());
        }),
            first = sorted[0];
        var collisions = CollisionDetection.findItemBoundsCollisions(sorted, null, Numerical.GEOMETRIC_EPSILON);
        if (clockwise == null) clockwise = first.isClockwise();

        for (var i = 0; i < length; i++) {
          var path1 = sorted[i],
              entry1 = lookup[path1._id],
              containerWinding = 0,
              indices = collisions[i];

          if (indices) {
            var point = null;

            for (var j = indices.length - 1; j >= 0; j--) {
              if (indices[j] < i) {
                point = point || path1.getInteriorPoint();
                var path2 = sorted[indices[j]];

                if (path2.contains(point)) {
                  var entry2 = lookup[path2._id];
                  containerWinding = entry2.winding;
                  entry1.winding += containerWinding;
                  entry1.container = entry2.exclude ? entry2.container : path2;
                  break;
                }
              }
            }
          }

          if (isInside(entry1.winding) === isInside(containerWinding)) {
            entry1.exclude = true;
            paths[entry1.index] = null;
          } else {
            var container = entry1.container;
            path1.setClockwise(container ? !container.isClockwise() : clockwise);
          }
        }
      }

      return paths;
    }

    function divideLocations(locations, include, clearLater) {
      var results = include && [],
          tMin = 1e-8,
          tMax = 1 - tMin,
          clearHandles = false,
          clearCurves = clearLater || [],
          clearLookup = clearLater && {},
          renormalizeLocs,
          prevCurve,
          prevTime;

      function getId(curve) {
        return curve._path._id + '.' + curve._segment1._index;
      }

      for (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {
        var curve = clearLater[i];
        if (curve._path) clearLookup[getId(curve)] = true;
      }

      for (var i = locations.length - 1; i >= 0; i--) {
        var loc = locations[i],
            time = loc._time,
            origTime = time,
            exclude = include && !include(loc),
            curve = loc._curve,
            segment;

        if (curve) {
          if (curve !== prevCurve) {
            clearHandles = !curve.hasHandles() || clearLookup && clearLookup[getId(curve)];
            renormalizeLocs = [];
            prevTime = null;
            prevCurve = curve;
          } else if (prevTime >= tMin) {
            time /= prevTime;
          }
        }

        if (exclude) {
          if (renormalizeLocs) renormalizeLocs.push(loc);
          continue;
        } else if (include) {
          results.unshift(loc);
        }

        prevTime = origTime;

        if (time < tMin) {
          segment = curve._segment1;
        } else if (time > tMax) {
          segment = curve._segment2;
        } else {
          var newCurve = curve.divideAtTime(time, true);
          if (clearHandles) clearCurves.push(curve, newCurve);
          segment = newCurve._segment1;

          for (var j = renormalizeLocs.length - 1; j >= 0; j--) {
            var l = renormalizeLocs[j];
            l._time = (l._time - time) / (1 - time);
          }
        }

        loc._setSegment(segment);

        var inter = segment._intersection,
            dest = loc._intersection;

        if (inter) {
          linkIntersections(inter, dest);
          var other = inter;

          while (other) {
            linkIntersections(other._intersection, inter);
            other = other._next;
          }
        } else {
          segment._intersection = dest;
        }
      }

      if (!clearLater) clearCurveHandles(clearCurves);
      return results || locations;
    }

    function getWinding(point, curves, dir, closed, dontFlip) {
      var curvesList = Array.isArray(curves) ? curves : curves[dir ? 'hor' : 'ver'];
      var ia = dir ? 1 : 0,
          io = ia ^ 1,
          pv = [point.x, point.y],
          pa = pv[ia],
          po = pv[io],
          windingEpsilon = 1e-9,
          qualityEpsilon = 1e-6,
          paL = pa - windingEpsilon,
          paR = pa + windingEpsilon,
          windingL = 0,
          windingR = 0,
          pathWindingL = 0,
          pathWindingR = 0,
          onPath = false,
          onAnyPath = false,
          quality = 1,
          roots = [],
          vPrev,
          vClose;

      function addWinding(v) {
        var o0 = v[io + 0],
            o3 = v[io + 6];

        if (po < min(o0, o3) || po > max(o0, o3)) {
          return;
        }

        var a0 = v[ia + 0],
            a1 = v[ia + 2],
            a2 = v[ia + 4],
            a3 = v[ia + 6];

        if (o0 === o3) {
          if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
            onPath = true;
          }

          return;
        }

        var t = po === o0 ? 0 : po === o3 ? 1 : paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? 1 : Curve.solveCubic(v, io, po, roots, 0, 1) > 0 ? roots[0] : 1,
            a = t === 0 ? a0 : t === 1 ? a3 : Curve.getPoint(v, t)[dir ? 'y' : 'x'],
            winding = o0 > o3 ? 1 : -1,
            windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,
            a3Prev = vPrev[ia + 6];

        if (po !== o0) {
          if (a < paL) {
            pathWindingL += winding;
          } else if (a > paR) {
            pathWindingR += winding;
          } else {
            onPath = true;
          }

          if (a > pa - qualityEpsilon && a < pa + qualityEpsilon) quality /= 2;
        } else {
          if (winding !== windingPrev) {
            if (a0 < paL) {
              pathWindingL += winding;
            } else if (a0 > paR) {
              pathWindingR += winding;
            }
          } else if (a0 != a3Prev) {
            if (a3Prev < paR && a > paR) {
              pathWindingR += winding;
              onPath = true;
            } else if (a3Prev > paL && a < paL) {
              pathWindingL += winding;
              onPath = true;
            }
          }

          quality /= 4;
        }

        vPrev = v;
        return !dontFlip && a > paL && a < paR && Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0 && getWinding(point, curves, !dir, closed, true);
      }

      function handleCurve(v) {
        var o0 = v[io + 0],
            o1 = v[io + 2],
            o2 = v[io + 4],
            o3 = v[io + 6];

        if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {
          var a0 = v[ia + 0],
              a1 = v[ia + 2],
              a2 = v[ia + 4],
              a3 = v[ia + 6],
              monoCurves = paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? [v] : Curve.getMonoCurves(v, dir),
              res;

          for (var i = 0, l = monoCurves.length; i < l; i++) {
            if (res = addWinding(monoCurves[i])) return res;
          }
        }
      }

      for (var i = 0, l = curvesList.length; i < l; i++) {
        var curve = curvesList[i],
            path = curve._path,
            v = curve.getValues(),
            res;

        if (!i || curvesList[i - 1]._path !== path) {
          vPrev = null;

          if (!path._closed) {
            vClose = Curve.getValues(path.getLastCurve().getSegment2(), curve.getSegment1(), null, !closed);

            if (vClose[io] !== vClose[io + 6]) {
              vPrev = vClose;
            }
          }

          if (!vPrev) {
            vPrev = v;
            var prev = path.getLastCurve();

            while (prev && prev !== curve) {
              var v2 = prev.getValues();

              if (v2[io] !== v2[io + 6]) {
                vPrev = v2;
                break;
              }

              prev = prev.getPrevious();
            }
          }
        }

        if (res = handleCurve(v)) return res;

        if (i + 1 === l || curvesList[i + 1]._path !== path) {
          if (vClose && (res = handleCurve(vClose))) return res;

          if (onPath && !pathWindingL && !pathWindingR) {
            pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir ? 1 : -1;
          }

          windingL += pathWindingL;
          windingR += pathWindingR;
          pathWindingL = pathWindingR = 0;

          if (onPath) {
            onAnyPath = true;
            onPath = false;
          }

          vClose = null;
        }
      }

      windingL = abs(windingL);
      windingR = abs(windingR);
      return {
        winding: max(windingL, windingR),
        windingL: windingL,
        windingR: windingR,
        quality: quality,
        onPath: onAnyPath
      };
    }

    function propagateWinding(segment, path1, path2, curveCollisionsMap, operator) {
      var chain = [],
          start = segment,
          totalLength = 0,
          winding;

      do {
        var curve = segment.getCurve();

        if (curve) {
          var length = curve.getLength();
          chain.push({
            segment: segment,
            curve: curve,
            length: length
          });
          totalLength += length;
        }

        segment = segment.getNext();
      } while (segment && !segment._intersection && segment !== start);

      var offsets = [0.5, 0.25, 0.75],
          winding = {
        winding: 0,
        quality: -1
      },
          tMin = 1e-3,
          tMax = 1 - tMin;

      for (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {
        var length = totalLength * offsets[i];

        for (var j = 0, l = chain.length; j < l; j++) {
          var entry = chain[j],
              curveLength = entry.length;

          if (length <= curveLength) {
            var curve = entry.curve,
                path = curve._path,
                parent = path._parent,
                operand = parent instanceof CompoundPath ? parent : path,
                t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),
                pt = curve.getPointAtTime(t),
                dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;
            var wind = null;

            if (operator.subtract && path2) {
              var otherPath = operand === path1 ? path2 : path1,
                  pathWinding = otherPath._getWinding(pt, dir, true);

              if (operand === path1 && pathWinding.winding || operand === path2 && !pathWinding.winding) {
                if (pathWinding.quality < 1) {
                  continue;
                } else {
                  wind = {
                    winding: 0,
                    quality: 1
                  };
                }
              }
            }

            wind = wind || getWinding(pt, curveCollisionsMap[path._id][curve.getIndex()], dir, true);
            if (wind.quality > winding.quality) winding = wind;
            break;
          }

          length -= curveLength;
        }
      }

      for (var j = chain.length - 1; j >= 0; j--) {
        chain[j].segment._winding = winding;
      }
    }

    function tracePaths(segments, operator) {
      var paths = [],
          starts;

      function isValid(seg) {
        var winding;
        return !!(seg && !seg._visited && (!operator || operator[(winding = seg._winding || {}).winding] && !(operator.unite && winding.winding === 2 && winding.windingL && winding.windingR)));
      }

      function isStart(seg) {
        if (seg) {
          for (var i = 0, l = starts.length; i < l; i++) {
            if (seg === starts[i]) return true;
          }
        }

        return false;
      }

      function visitPath(path) {
        var segments = path._segments;

        for (var i = 0, l = segments.length; i < l; i++) {
          segments[i]._visited = true;
        }
      }

      function getCrossingSegments(segment, collectStarts) {
        var inter = segment._intersection,
            start = inter,
            crossings = [];
        if (collectStarts) starts = [segment];

        function collect(inter, end) {
          while (inter && inter !== end) {
            var other = inter._segment,
                path = other && other._path;

            if (path) {
              var next = other.getNext() || path.getFirstSegment(),
                  nextInter = next._intersection;

              if (other !== segment && (isStart(other) || isStart(next) || next && isValid(other) && (isValid(next) || nextInter && isValid(nextInter._segment)))) {
                crossings.push(other);
              }

              if (collectStarts) starts.push(other);
            }

            inter = inter._next;
          }
        }

        if (inter) {
          collect(inter);

          while (inter && inter._previous) inter = inter._previous;

          collect(inter, start);
        }

        return crossings;
      }

      segments.sort(function (seg1, seg2) {
        var inter1 = seg1._intersection,
            inter2 = seg2._intersection,
            over1 = !!(inter1 && inter1._overlap),
            over2 = !!(inter2 && inter2._overlap),
            path1 = seg1._path,
            path2 = seg2._path;
        return over1 ^ over2 ? over1 ? 1 : -1 : !inter1 ^ !inter2 ? inter1 ? 1 : -1 : path1 !== path2 ? path1._id - path2._id : seg1._index - seg2._index;
      });

      for (var i = 0, l = segments.length; i < l; i++) {
        var seg = segments[i],
            valid = isValid(seg),
            path = null,
            finished = false,
            closed = true,
            branches = [],
            branch,
            visited,
            handleIn;

        if (valid && seg._path._overlapsOnly) {
          var path1 = seg._path,
              path2 = seg._intersection._segment._path;

          if (path1.compare(path2)) {
            if (path1.getArea()) paths.push(path1.clone(false));
            visitPath(path1);
            visitPath(path2);
            valid = false;
          }
        }

        while (valid) {
          var first = !path,
              crossings = getCrossingSegments(seg, first),
              other = crossings.shift(),
              finished = !first && (isStart(seg) || isStart(other)),
              cross = !finished && other;

          if (first) {
            path = new Path(Item.NO_INSERT);
            branch = null;
          }

          if (finished) {
            if (seg.isFirst() || seg.isLast()) closed = seg._path._closed;
            seg._visited = true;
            break;
          }

          if (cross && branch) {
            branches.push(branch);
            branch = null;
          }

          if (!branch) {
            if (cross) crossings.push(seg);
            branch = {
              start: path._segments.length,
              crossings: crossings,
              visited: visited = [],
              handleIn: handleIn
            };
          }

          if (cross) seg = other;

          if (!isValid(seg)) {
            path.removeSegments(branch.start);

            for (var j = 0, k = visited.length; j < k; j++) {
              visited[j]._visited = false;
            }

            visited.length = 0;

            do {
              seg = branch && branch.crossings.shift();

              if (!seg || !seg._path) {
                seg = null;
                branch = branches.pop();

                if (branch) {
                  visited = branch.visited;
                  handleIn = branch.handleIn;
                }
              }
            } while (branch && !isValid(seg));

            if (!seg) break;
          }

          var next = seg.getNext();
          path.add(new Segment(seg._point, handleIn, next && seg._handleOut));
          seg._visited = true;
          visited.push(seg);
          seg = next || seg._path.getFirstSegment();
          handleIn = next && next._handleIn;
        }

        if (finished) {
          if (closed) {
            path.getFirstSegment().setHandleIn(handleIn);
            path.setClosed(closed);
          }

          if (path.getArea() !== 0) {
            paths.push(path);
          }
        }
      }

      return paths;
    }

    return {
      _getWinding: function (point, dir, closed) {
        return getWinding(point, this.getCurves(), dir, closed);
      },
      unite: function (path, options) {
        return traceBoolean(this, path, 'unite', options);
      },
      intersect: function (path, options) {
        return traceBoolean(this, path, 'intersect', options);
      },
      subtract: function (path, options) {
        return traceBoolean(this, path, 'subtract', options);
      },
      exclude: function (path, options) {
        return traceBoolean(this, path, 'exclude', options);
      },
      divide: function (path, options) {
        return options && (options.trace == false || options.stroke) ? splitBoolean(this, path, 'divide') : createResult([this.subtract(path, options), this.intersect(path, options)], true, this, path, options);
      },
      resolveCrossings: function () {
        var children = this._children,
            paths = children || [this];

        function hasOverlap(seg, path) {
          var inter = seg && seg._intersection;
          return inter && inter._overlap && inter._path === path;
        }

        var hasOverlaps = false,
            hasCrossings = false,
            intersections = this.getIntersections(null, function (inter) {
          return inter.hasOverlap() && (hasOverlaps = true) || inter.isCrossing() && (hasCrossings = true);
        }),
            clearCurves = hasOverlaps && hasCrossings && [];
        intersections = CurveLocation.expand(intersections);

        if (hasOverlaps) {
          var overlaps = divideLocations(intersections, function (inter) {
            return inter.hasOverlap();
          }, clearCurves);

          for (var i = overlaps.length - 1; i >= 0; i--) {
            var overlap = overlaps[i],
                path = overlap._path,
                seg = overlap._segment,
                prev = seg.getPrevious(),
                next = seg.getNext();

            if (hasOverlap(prev, path) && hasOverlap(next, path)) {
              seg.remove();

              prev._handleOut._set(0, 0);

              next._handleIn._set(0, 0);

              if (prev !== seg && !prev.getCurve().hasLength()) {
                next._handleIn.set(prev._handleIn);

                prev.remove();
              }
            }
          }
        }

        if (hasCrossings) {
          divideLocations(intersections, hasOverlaps && function (inter) {
            var curve1 = inter.getCurve(),
                seg1 = inter.getSegment(),
                other = inter._intersection,
                curve2 = other._curve,
                seg2 = other._segment;
            if (curve1 && curve2 && curve1._path && curve2._path) return true;
            if (seg1) seg1._intersection = null;
            if (seg2) seg2._intersection = null;
          }, clearCurves);
          if (clearCurves) clearCurveHandles(clearCurves);
          paths = tracePaths(Base.each(paths, function (path) {
            Base.push(this, path._segments);
          }, []));
        }

        var length = paths.length,
            item;

        if (length > 1 && children) {
          if (paths !== children) this.setChildren(paths);
          item = this;
        } else if (length === 1 && !children) {
          if (paths[0] !== this) this.setSegments(paths[0].removeSegments());
          item = this;
        }

        if (!item) {
          item = new CompoundPath(Item.NO_INSERT);
          item.addChildren(paths);
          item = item.reduce();
          item.copyAttributes(this);
          this.replaceWith(item);
        }

        return item;
      },
      reorient: function (nonZero, clockwise) {
        var children = this._children;

        if (children && children.length) {
          this.setChildren(reorientPaths(this.removeChildren(), function (w) {
            return !!(nonZero ? w : w & 1);
          }, clockwise));
        } else if (clockwise !== undefined) {
          this.setClockwise(clockwise);
        }

        return this;
      },
      getInteriorPoint: function () {
        var bounds = this.getBounds(),
            point = bounds.getCenter(true);

        if (!this.contains(point)) {
          var curves = this.getCurves(),
              y = point.y,
              intercepts = [],
              roots = [];

          for (var i = 0, l = curves.length; i < l; i++) {
            var v = curves[i].getValues(),
                o0 = v[1],
                o1 = v[3],
                o2 = v[5],
                o3 = v[7];

            if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {
              var monoCurves = Curve.getMonoCurves(v);

              for (var j = 0, m = monoCurves.length; j < m; j++) {
                var mv = monoCurves[j],
                    mo0 = mv[1],
                    mo3 = mv[7];

                if (mo0 !== mo3 && (y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)) {
                  var x = y === mo0 ? mv[0] : y === mo3 ? mv[6] : Curve.solveCubic(mv, 1, y, roots, 0, 1) === 1 ? Curve.getPoint(mv, roots[0]).x : (mv[0] + mv[6]) / 2;
                  intercepts.push(x);
                }
              }
            }
          }

          if (intercepts.length > 1) {
            intercepts.sort(function (a, b) {
              return a - b;
            });
            point.x = (intercepts[0] + intercepts[1]) / 2;
          }
        }

        return point;
      }
    };
  }());
  var PathFlattener = Base.extend({
    _class: 'PathFlattener',
    initialize: function (path, flatness, maxRecursion, ignoreStraight, matrix) {
      var curves = [],
          parts = [],
          length = 0,
          minSpan = 1 / (maxRecursion || 32),
          segments = path._segments,
          segment1 = segments[0],
          segment2;

      function addCurve(segment1, segment2) {
        var curve = Curve.getValues(segment1, segment2, matrix);
        curves.push(curve);
        computeParts(curve, segment1._index, 0, 1);
      }

      function computeParts(curve, index, t1, t2) {
        if (t2 - t1 > minSpan && !(ignoreStraight && Curve.isStraight(curve)) && !Curve.isFlatEnough(curve, flatness || 0.25)) {
          var halves = Curve.subdivide(curve, 0.5),
              tMid = (t1 + t2) / 2;
          computeParts(halves[0], index, t1, tMid);
          computeParts(halves[1], index, tMid, t2);
        } else {
          var dx = curve[6] - curve[0],
              dy = curve[7] - curve[1],
              dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            length += dist;
            parts.push({
              offset: length,
              curve: curve,
              index: index,
              time: t2
            });
          }
        }
      }

      for (var i = 1, l = segments.length; i < l; i++) {
        segment2 = segments[i];
        addCurve(segment1, segment2);
        segment1 = segment2;
      }

      if (path._closed) addCurve(segment2 || segment1, segments[0]);
      this.curves = curves;
      this.parts = parts;
      this.length = length;
      this.index = 0;
    },
    _get: function (offset) {
      var parts = this.parts,
          length = parts.length,
          start,
          i,
          j = this.index;

      for (;;) {
        i = j;
        if (!j || parts[--j].offset < offset) break;
      }

      for (; i < length; i++) {
        var part = parts[i];

        if (part.offset >= offset) {
          this.index = i;
          var prev = parts[i - 1],
              prevTime = prev && prev.index === part.index ? prev.time : 0,
              prevOffset = prev ? prev.offset : 0;
          return {
            index: part.index,
            time: prevTime + (part.time - prevTime) * (offset - prevOffset) / (part.offset - prevOffset)
          };
        }
      }

      return {
        index: parts[length - 1].index,
        time: 1
      };
    },
    drawPart: function (ctx, from, to) {
      var start = this._get(from),
          end = this._get(to);

      for (var i = start.index, l = end.index; i <= l; i++) {
        var curve = Curve.getPart(this.curves[i], i === start.index ? start.time : 0, i === end.index ? end.time : 1);
        if (i === start.index) ctx.moveTo(curve[0], curve[1]);
        ctx.bezierCurveTo.apply(ctx, curve.slice(2));
      }
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    this[name + 'At'] = function (offset) {
      var param = this._get(offset);

      return Curve[name](this.curves[param.index], param.time);
    };
  }, {}));
  var PathFitter = Base.extend({
    initialize: function (path) {
      var points = this.points = [],
          segments = path._segments,
          closed = path._closed;

      for (var i = 0, prev, l = segments.length; i < l; i++) {
        var point = segments[i].point;

        if (!prev || !prev.equals(point)) {
          points.push(prev = point.clone());
        }
      }

      if (closed) {
        points.unshift(points[points.length - 1]);
        points.push(points[1]);
      }

      this.closed = closed;
    },
    fit: function (error) {
      var points = this.points,
          length = points.length,
          segments = null;

      if (length > 0) {
        segments = [new Segment(points[0])];

        if (length > 1) {
          this.fitCubic(segments, error, 0, length - 1, points[1].subtract(points[0]), points[length - 2].subtract(points[length - 1]));

          if (this.closed) {
            segments.shift();
            segments.pop();
          }
        }
      }

      return segments;
    },
    fitCubic: function (segments, error, first, last, tan1, tan2) {
      var points = this.points;

      if (last - first === 1) {
        var pt1 = points[first],
            pt2 = points[last],
            dist = pt1.getDistance(pt2) / 3;
        this.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)), pt2.add(tan2.normalize(dist)), pt2]);
        return;
      }

      var uPrime = this.chordLengthParameterize(first, last),
          maxError = Math.max(error, error * error),
          split,
          parametersInOrder = true;

      for (var i = 0; i <= 4; i++) {
        var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
        var max = this.findMaxError(first, last, curve, uPrime);

        if (max.error < error && parametersInOrder) {
          this.addCurve(segments, curve);
          return;
        }

        split = max.index;
        if (max.error >= maxError) break;
        parametersInOrder = this.reparameterize(first, last, uPrime, curve);
        maxError = max.error;
      }

      var tanCenter = points[split - 1].subtract(points[split + 1]);
      this.fitCubic(segments, error, first, split, tan1, tanCenter);
      this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
    },
    addCurve: function (segments, curve) {
      var prev = segments[segments.length - 1];
      prev.setHandleOut(curve[1].subtract(curve[0]));
      segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
    },
    generateBezier: function (first, last, uPrime, tan1, tan2) {
      var epsilon = 1e-12,
          abs = Math.abs,
          points = this.points,
          pt1 = points[first],
          pt2 = points[last],
          C = [[0, 0], [0, 0]],
          X = [0, 0];

      for (var i = 0, l = last - first + 1; i < l; i++) {
        var u = uPrime[i],
            t = 1 - u,
            b = 3 * u * t,
            b0 = t * t * t,
            b1 = b * t,
            b2 = b * u,
            b3 = u * u * u,
            a1 = tan1.normalize(b1),
            a2 = tan2.normalize(b2),
            tmp = points[first + i].subtract(pt1.multiply(b0 + b1)).subtract(pt2.multiply(b2 + b3));
        C[0][0] += a1.dot(a1);
        C[0][1] += a1.dot(a2);
        C[1][0] = C[0][1];
        C[1][1] += a2.dot(a2);
        X[0] += a1.dot(tmp);
        X[1] += a2.dot(tmp);
      }

      var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
          alpha1,
          alpha2;

      if (abs(detC0C1) > epsilon) {
        var detC0X = C[0][0] * X[1] - C[1][0] * X[0],
            detXC1 = X[0] * C[1][1] - X[1] * C[0][1];
        alpha1 = detXC1 / detC0C1;
        alpha2 = detC0X / detC0C1;
      } else {
        var c0 = C[0][0] + C[0][1],
            c1 = C[1][0] + C[1][1];
        alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0 : abs(c1) > epsilon ? X[1] / c1 : 0;
      }

      var segLength = pt2.getDistance(pt1),
          eps = epsilon * segLength,
          handle1,
          handle2;

      if (alpha1 < eps || alpha2 < eps) {
        alpha1 = alpha2 = segLength / 3;
      } else {
        var line = pt2.subtract(pt1);
        handle1 = tan1.normalize(alpha1);
        handle2 = tan2.normalize(alpha2);

        if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
          alpha1 = alpha2 = segLength / 3;
          handle1 = handle2 = null;
        }
      }

      return [pt1, pt1.add(handle1 || tan1.normalize(alpha1)), pt2.add(handle2 || tan2.normalize(alpha2)), pt2];
    },
    reparameterize: function (first, last, u, curve) {
      for (var i = first; i <= last; i++) {
        u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
      }

      for (var i = 1, l = u.length; i < l; i++) {
        if (u[i] <= u[i - 1]) return false;
      }

      return true;
    },
    findRoot: function (curve, point, u) {
      var curve1 = [],
          curve2 = [];

      for (var i = 0; i <= 2; i++) {
        curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
      }

      for (var i = 0; i <= 1; i++) {
        curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
      }

      var pt = this.evaluate(3, curve, u),
          pt1 = this.evaluate(2, curve1, u),
          pt2 = this.evaluate(1, curve2, u),
          diff = pt.subtract(point),
          df = pt1.dot(pt1) + diff.dot(pt2);
      return Numerical.isMachineZero(df) ? u : u - diff.dot(pt1) / df;
    },
    evaluate: function (degree, curve, t) {
      var tmp = curve.slice();

      for (var i = 1; i <= degree; i++) {
        for (var j = 0; j <= degree - i; j++) {
          tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
        }
      }

      return tmp[0];
    },
    chordLengthParameterize: function (first, last) {
      var u = [0];

      for (var i = first + 1; i <= last; i++) {
        u[i - first] = u[i - first - 1] + this.points[i].getDistance(this.points[i - 1]);
      }

      for (var i = 1, m = last - first; i <= m; i++) {
        u[i] /= u[m];
      }

      return u;
    },
    findMaxError: function (first, last, curve, u) {
      var index = Math.floor((last - first + 1) / 2),
          maxDist = 0;

      for (var i = first + 1; i < last; i++) {
        var P = this.evaluate(3, curve, u[i - first]);
        var v = P.subtract(this.points[i]);
        var dist = v.x * v.x + v.y * v.y;

        if (dist >= maxDist) {
          maxDist = dist;
          index = i;
        }
      }

      return {
        error: maxDist,
        index: index
      };
    }
  });
  var TextItem = Item.extend({
    _class: 'TextItem',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _serializeFields: {
      content: null
    },
    _boundsOptions: {
      stroke: false,
      handle: false
    },
    initialize: function TextItem(arg) {
      this._content = '';
      this._lines = [];
      var hasProps = arg && Base.isPlainObject(arg) && arg.x === undefined && arg.y === undefined;

      this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
    },
    _equals: function (item) {
      return this._content === item._content;
    },
    copyContent: function (source) {
      this.setContent(source._content);
    },
    getContent: function () {
      return this._content;
    },
    setContent: function (content) {
      this._content = '' + content;
      this._lines = this._content.split(/\r\n|\n|\r/mg);

      this._changed(521);
    },
    isEmpty: function () {
      return !this._content;
    },
    getCharacterStyle: '#getStyle',
    setCharacterStyle: '#setStyle',
    getParagraphStyle: '#getStyle',
    setParagraphStyle: '#setStyle'
  });
  var PointText = TextItem.extend({
    _class: 'PointText',
    initialize: function PointText() {
      TextItem.apply(this, arguments);
    },
    getPoint: function () {
      var point = this._matrix.getTranslation();

      return new LinkedPoint(point.x, point.y, this, 'setPoint');
    },
    setPoint: function () {
      var point = Point.read(arguments);
      this.translate(point.subtract(this._matrix.getTranslation()));
    },
    _draw: function (ctx, param, viewMatrix) {
      if (!this._content) return;

      this._setStyles(ctx, param, viewMatrix);

      var lines = this._lines,
          style = this._style,
          hasFill = style.hasFill(),
          hasStroke = style.hasStroke(),
          leading = style.getLeading(),
          shadowColor = ctx.shadowColor;
      ctx.font = style.getFontStyle();
      ctx.textAlign = style.getJustification();

      for (var i = 0, l = lines.length; i < l; i++) {
        ctx.shadowColor = shadowColor;
        var line = lines[i];

        if (hasFill) {
          ctx.fillText(line, 0, 0);
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (hasStroke) ctx.strokeText(line, 0, 0);
        ctx.translate(0, leading);
      }
    },
    _getBounds: function (matrix, options) {
      var style = this._style,
          lines = this._lines,
          numLines = lines.length,
          justification = style.getJustification(),
          leading = style.getLeading(),
          width = this.getView().getTextWidth(style.getFontStyle(), lines),
          x = 0;
      if (justification !== 'left') x -= width / (justification === 'center' ? 2 : 1);
      var rect = new Rectangle(x, numLines ? -0.75 * leading : 0, width, numLines * leading);
      return matrix ? matrix._transformBounds(rect, rect) : rect;
    }
  });
  var Color = Base.extend(new function () {
    var types = {
      gray: ['gray'],
      rgb: ['red', 'green', 'blue'],
      hsb: ['hue', 'saturation', 'brightness'],
      hsl: ['hue', 'saturation', 'lightness'],
      gradient: ['gradient', 'origin', 'destination', 'highlight']
    };
    var componentParsers = {},
        namedColors = {
      transparent: [0, 0, 0, 0]
    },
        colorCtx;

    function fromCSS(string) {
      var match = string.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i) || string.match(/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i),
          type = 'rgb',
          components;

      if (match) {
        var amount = match[4] ? 4 : 3;
        components = new Array(amount);

        for (var i = 0; i < amount; i++) {
          var value = match[i + 1];
          components[i] = parseInt(value.length == 1 ? value + value : value, 16) / 255;
        }
      } else if (match = string.match(/^(rgb|hsl)a?\((.*)\)$/)) {
        type = match[1];
        components = match[2].trim().split(/[,\s]+/g);
        var isHSL = type === 'hsl';

        for (var i = 0, l = Math.min(components.length, 4); i < l; i++) {
          var component = components[i];
          var value = parseFloat(component);

          if (isHSL) {
            if (i === 0) {
              var unit = component.match(/([a-z]*)$/)[1];
              value *= {
                turn: 360,
                rad: 180 / Math.PI,
                grad: 0.9
              }[unit] || 1;
            } else if (i < 3) {
              value /= 100;
            }
          } else if (i < 3) {
            value /= /%$/.test(component) ? 100 : 255;
          }

          components[i] = value;
        }
      } else {
        var color = namedColors[string];

        if (!color) {
          if (window) {
            if (!colorCtx) {
              colorCtx = CanvasProvider.getContext(1, 1);
              colorCtx.globalCompositeOperation = 'copy';
            }

            colorCtx.fillStyle = 'rgba(0,0,0,0)';
            colorCtx.fillStyle = string;
            colorCtx.fillRect(0, 0, 1, 1);
            var data = colorCtx.getImageData(0, 0, 1, 1).data;
            color = namedColors[string] = [data[0] / 255, data[1] / 255, data[2] / 255];
          } else {
            color = [0, 0, 0];
          }
        }

        components = color.slice();
      }

      return [type, components];
    }

    var hsbIndices = [[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]];
    var converters = {
      'rgb-hsb': function (r, g, b) {
        var max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            delta = max - min,
            h = delta === 0 ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60;
        return [h, max === 0 ? 0 : delta / max, max];
      },
      'hsb-rgb': function (h, s, b) {
        h = (h / 60 % 6 + 6) % 6;
        var i = Math.floor(h),
            f = h - i,
            i = hsbIndices[i],
            v = [b, b * (1 - s), b * (1 - s * f), b * (1 - s * (1 - f))];
        return [v[i[0]], v[i[1]], v[i[2]]];
      },
      'rgb-hsl': function (r, g, b) {
        var max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            delta = max - min,
            achromatic = delta === 0,
            h = achromatic ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60,
            l = (max + min) / 2,
            s = achromatic ? 0 : l < 0.5 ? delta / (max + min) : delta / (2 - max - min);
        return [h, s, l];
      },
      'hsl-rgb': function (h, s, l) {
        h = (h / 360 % 1 + 1) % 1;
        if (s === 0) return [l, l, l];
        var t3s = [h + 1 / 3, h, h - 1 / 3],
            t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
            t1 = 2 * l - t2,
            c = [];

        for (var i = 0; i < 3; i++) {
          var t3 = t3s[i];
          if (t3 < 0) t3 += 1;
          if (t3 > 1) t3 -= 1;
          c[i] = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
        }

        return c;
      },
      'rgb-gray': function (r, g, b) {
        return [r * 0.2989 + g * 0.587 + b * 0.114];
      },
      'gray-rgb': function (g) {
        return [g, g, g];
      },
      'gray-hsb': function (g) {
        return [0, 0, g];
      },
      'gray-hsl': function (g) {
        return [0, 0, g];
      },
      'gradient-rgb': function () {
        return [];
      },
      'rgb-gradient': function () {
        return [];
      }
    };
    return Base.each(types, function (properties, type) {
      componentParsers[type] = [];
      Base.each(properties, function (name, index) {
        var part = Base.capitalize(name),
            hasOverlap = /^(hue|saturation)$/.test(name),
            parser = componentParsers[type][index] = type === 'gradient' ? name === 'gradient' ? function (value) {
          var current = this._components[0];
          value = Gradient.read(Array.isArray(value) ? value : arguments, 0, {
            readNull: true
          });

          if (current !== value) {
            if (current) current._removeOwner(this);
            if (value) value._addOwner(this);
          }

          return value;
        } : function () {
          return Point.read(arguments, 0, {
            readNull: name === 'highlight',
            clone: true
          });
        } : function (value) {
          return value == null || isNaN(value) ? 0 : +value;
        };

        this['get' + part] = function () {
          return this._type === type || hasOverlap && /^hs[bl]$/.test(this._type) ? this._components[index] : this._convert(type)[index];
        };

        this['set' + part] = function (value) {
          if (this._type !== type && !(hasOverlap && /^hs[bl]$/.test(this._type))) {
            this._components = this._convert(type);
            this._properties = types[type];
            this._type = type;
          }

          this._components[index] = parser.call(this, value);

          this._changed();
        };
      }, this);
    }, {
      _class: 'Color',
      _readIndex: true,
      initialize: function Color(arg) {
        var args = arguments,
            reading = this.__read,
            read = 0,
            type,
            components,
            alpha,
            values;

        if (Array.isArray(arg)) {
          args = arg;
          arg = args[0];
        }

        var argType = arg != null && typeof arg;

        if (argType === 'string' && arg in types) {
          type = arg;
          arg = args[1];

          if (Array.isArray(arg)) {
            components = arg;
            alpha = args[2];
          } else {
            if (reading) read = 1;
            args = Base.slice(args, 1);
            argType = typeof arg;
          }
        }

        if (!components) {
          values = argType === 'number' ? args : argType === 'object' && arg.length != null ? arg : null;

          if (values) {
            if (!type) type = values.length >= 3 ? 'rgb' : 'gray';
            var length = types[type].length;
            alpha = values[length];

            if (reading) {
              read += values === arguments ? length + (alpha != null ? 1 : 0) : 1;
            }

            if (values.length > length) values = Base.slice(values, 0, length);
          } else if (argType === 'string') {
            var converted = fromCSS(arg);
            type = converted[0];
            components = converted[1];

            if (components.length === 4) {
              alpha = components[3];
              components.length--;
            }
          } else if (argType === 'object') {
            if (arg.constructor === Color) {
              type = arg._type;
              components = arg._components.slice();
              alpha = arg._alpha;

              if (type === 'gradient') {
                for (var i = 1, l = components.length; i < l; i++) {
                  var point = components[i];
                  if (point) components[i] = point.clone();
                }
              }
            } else if (arg.constructor === Gradient) {
              type = 'gradient';
              values = args;
            } else {
              type = 'hue' in arg ? 'lightness' in arg ? 'hsl' : 'hsb' : 'gradient' in arg || 'stops' in arg || 'radial' in arg ? 'gradient' : 'gray' in arg ? 'gray' : 'rgb';
              var properties = types[type],
                  parsers = componentParsers[type];
              this._components = components = [];

              for (var i = 0, l = properties.length; i < l; i++) {
                var value = arg[properties[i]];

                if (value == null && !i && type === 'gradient' && 'stops' in arg) {
                  value = {
                    stops: arg.stops,
                    radial: arg.radial
                  };
                }

                value = parsers[i].call(this, value);
                if (value != null) components[i] = value;
              }

              alpha = arg.alpha;
            }
          }

          if (reading && type) read = 1;
        }

        this._type = type || 'rgb';

        if (!components) {
          this._components = components = [];
          var parsers = componentParsers[this._type];

          for (var i = 0, l = parsers.length; i < l; i++) {
            var value = parsers[i].call(this, values && values[i]);
            if (value != null) components[i] = value;
          }
        }

        this._components = components;
        this._properties = types[this._type];
        this._alpha = alpha;
        if (reading) this.__read = read;
        return this;
      },
      set: '#initialize',
      _serialize: function (options, dictionary) {
        var components = this.getComponents();
        return Base.serialize(/^(gray|rgb)$/.test(this._type) ? components : [this._type].concat(components), options, true, dictionary);
      },
      _changed: function () {
        this._canvasStyle = null;

        if (this._owner) {
          if (this._setter) {
            this._owner[this._setter](this);
          } else {
            this._owner._changed(129);
          }
        }
      },
      _convert: function (type) {
        var converter;
        return this._type === type ? this._components.slice() : (converter = converters[this._type + '-' + type]) ? converter.apply(this, this._components) : converters['rgb-' + type].apply(this, converters[this._type + '-rgb'].apply(this, this._components));
      },
      convert: function (type) {
        return new Color(type, this._convert(type), this._alpha);
      },
      getType: function () {
        return this._type;
      },
      setType: function (type) {
        this._components = this._convert(type);
        this._properties = types[type];
        this._type = type;
      },
      getComponents: function () {
        var components = this._components.slice();

        if (this._alpha != null) components.push(this._alpha);
        return components;
      },
      getAlpha: function () {
        return this._alpha != null ? this._alpha : 1;
      },
      setAlpha: function (alpha) {
        this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);

        this._changed();
      },
      hasAlpha: function () {
        return this._alpha != null;
      },
      equals: function (color) {
        var col = Base.isPlainValue(color, true) ? Color.read(arguments) : color;
        return col === this || col && this._class === col._class && this._type === col._type && this.getAlpha() === col.getAlpha() && Base.equals(this._components, col._components) || false;
      },
      toString: function () {
        var properties = this._properties,
            parts = [],
            isGradient = this._type === 'gradient',
            f = Formatter.instance;

        for (var i = 0, l = properties.length; i < l; i++) {
          var value = this._components[i];
          if (value != null) parts.push(properties[i] + ': ' + (isGradient ? value : f.number(value)));
        }

        if (this._alpha != null) parts.push('alpha: ' + f.number(this._alpha));
        return '{ ' + parts.join(', ') + ' }';
      },
      toCSS: function (hex) {
        var components = this._convert('rgb'),
            alpha = hex || this._alpha == null ? 1 : this._alpha;

        function convert(val) {
          return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
        }

        components = [convert(components[0]), convert(components[1]), convert(components[2])];
        if (alpha < 1) components.push(alpha < 0 ? 0 : alpha);
        return hex ? '#' + ((1 << 24) + (components[0] << 16) + (components[1] << 8) + components[2]).toString(16).slice(1) : (components.length == 4 ? 'rgba(' : 'rgb(') + components.join(',') + ')';
      },
      toCanvasStyle: function (ctx, matrix) {
        if (this._canvasStyle) return this._canvasStyle;
        if (this._type !== 'gradient') return this._canvasStyle = this.toCSS();
        var components = this._components,
            gradient = components[0],
            stops = gradient._stops,
            origin = components[1],
            destination = components[2],
            highlight = components[3],
            inverse = matrix && matrix.inverted(),
            canvasGradient;

        if (inverse) {
          origin = inverse._transformPoint(origin);
          destination = inverse._transformPoint(destination);
          if (highlight) highlight = inverse._transformPoint(highlight);
        }

        if (gradient._radial) {
          var radius = destination.getDistance(origin);

          if (highlight) {
            var vector = highlight.subtract(origin);
            if (vector.getLength() > radius) highlight = origin.add(vector.normalize(radius - 0.1));
          }

          var start = highlight || origin;
          canvasGradient = ctx.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius);
        } else {
          canvasGradient = ctx.createLinearGradient(origin.x, origin.y, destination.x, destination.y);
        }

        for (var i = 0, l = stops.length; i < l; i++) {
          var stop = stops[i],
              offset = stop._offset;
          canvasGradient.addColorStop(offset == null ? i / (l - 1) : offset, stop._color.toCanvasStyle());
        }

        return this._canvasStyle = canvasGradient;
      },
      transform: function (matrix) {
        if (this._type === 'gradient') {
          var components = this._components;

          for (var i = 1, l = components.length; i < l; i++) {
            var point = components[i];

            matrix._transformPoint(point, point, true);
          }

          this._changed();
        }
      },
      statics: {
        _types: types,
        random: function () {
          var random = Math.random;
          return new Color(random(), random(), random());
        },
        _setOwner: function (color, owner, setter) {
          if (color) {
            if (color._owner && owner && color._owner !== owner) {
              color = color.clone();
            }

            if (!color._owner ^ !owner) {
              color._owner = owner || null;
              color._setter = setter || null;
            }
          }

          return color;
        }
      }
    });
  }(), new function () {
    var operators = {
      add: function (a, b) {
        return a + b;
      },
      subtract: function (a, b) {
        return a - b;
      },
      multiply: function (a, b) {
        return a * b;
      },
      divide: function (a, b) {
        return a / b;
      }
    };
    return Base.each(operators, function (operator, name) {
      this[name] = function (color) {
        color = Color.read(arguments);

        var type = this._type,
            components1 = this._components,
            components2 = color._convert(type);

        for (var i = 0, l = components1.length; i < l; i++) components2[i] = operator(components1[i], components2[i]);

        return new Color(type, components2, this._alpha != null ? operator(this._alpha, color.getAlpha()) : null);
      };
    }, {});
  }());
  var Gradient = Base.extend({
    _class: 'Gradient',
    initialize: function Gradient(stops, radial) {
      this._id = UID.get();

      if (stops && Base.isPlainObject(stops)) {
        this.set(stops);
        stops = radial = null;
      }

      if (this._stops == null) {
        this.setStops(stops || ['white', 'black']);
      }

      if (this._radial == null) {
        this.setRadial(typeof radial === 'string' && radial === 'radial' || radial || false);
      }
    },
    _serialize: function (options, dictionary) {
      return dictionary.add(this, function () {
        return Base.serialize([this._stops, this._radial], options, true, dictionary);
      });
    },
    _changed: function () {
      for (var i = 0, l = this._owners && this._owners.length; i < l; i++) {
        this._owners[i]._changed();
      }
    },
    _addOwner: function (color) {
      if (!this._owners) this._owners = [];

      this._owners.push(color);
    },
    _removeOwner: function (color) {
      var index = this._owners ? this._owners.indexOf(color) : -1;

      if (index != -1) {
        this._owners.splice(index, 1);

        if (!this._owners.length) this._owners = undefined;
      }
    },
    clone: function () {
      var stops = [];

      for (var i = 0, l = this._stops.length; i < l; i++) {
        stops[i] = this._stops[i].clone();
      }

      return new Gradient(stops, this._radial);
    },
    getStops: function () {
      return this._stops;
    },
    setStops: function (stops) {
      if (stops.length < 2) {
        throw new Error('Gradient stop list needs to contain at least two stops.');
      }

      var _stops = this._stops;

      if (_stops) {
        for (var i = 0, l = _stops.length; i < l; i++) _stops[i]._owner = undefined;
      }

      _stops = this._stops = GradientStop.readList(stops, 0, {
        clone: true
      });

      for (var i = 0, l = _stops.length; i < l; i++) _stops[i]._owner = this;

      this._changed();
    },
    getRadial: function () {
      return this._radial;
    },
    setRadial: function (radial) {
      this._radial = radial;

      this._changed();
    },
    equals: function (gradient) {
      if (gradient === this) return true;

      if (gradient && this._class === gradient._class) {
        var stops1 = this._stops,
            stops2 = gradient._stops,
            length = stops1.length;

        if (length === stops2.length) {
          for (var i = 0; i < length; i++) {
            if (!stops1[i].equals(stops2[i])) return false;
          }

          return true;
        }
      }

      return false;
    }
  });
  var GradientStop = Base.extend({
    _class: 'GradientStop',
    initialize: function GradientStop(arg0, arg1) {
      var color = arg0,
          offset = arg1;

      if (typeof arg0 === 'object' && arg1 === undefined) {
        if (Array.isArray(arg0) && typeof arg0[0] !== 'number') {
          color = arg0[0];
          offset = arg0[1];
        } else if ('color' in arg0 || 'offset' in arg0 || 'rampPoint' in arg0) {
          color = arg0.color;
          offset = arg0.offset || arg0.rampPoint || 0;
        }
      }

      this.setColor(color);
      this.setOffset(offset);
    },
    clone: function () {
      return new GradientStop(this._color.clone(), this._offset);
    },
    _serialize: function (options, dictionary) {
      var color = this._color,
          offset = this._offset;
      return Base.serialize(offset == null ? [color] : [color, offset], options, true, dictionary);
    },
    _changed: function () {
      if (this._owner) this._owner._changed(129);
    },
    getOffset: function () {
      return this._offset;
    },
    setOffset: function (offset) {
      this._offset = offset;

      this._changed();
    },
    getRampPoint: '#getOffset',
    setRampPoint: '#setOffset',
    getColor: function () {
      return this._color;
    },
    setColor: function () {
      Color._setOwner(this._color, null);

      this._color = Color._setOwner(Color.read(arguments, 0), this, 'setColor');

      this._changed();
    },
    equals: function (stop) {
      return stop === this || stop && this._class === stop._class && this._color.equals(stop._color) && this._offset == stop._offset || false;
    }
  });
  var Style = Base.extend(new function () {
    var itemDefaults = {
      fillColor: null,
      fillRule: 'nonzero',
      strokeColor: null,
      strokeWidth: 1,
      strokeCap: 'butt',
      strokeJoin: 'miter',
      strokeScaling: true,
      miterLimit: 10,
      dashOffset: 0,
      dashArray: [],
      shadowColor: null,
      shadowBlur: 0,
      shadowOffset: new Point(),
      selectedColor: null
    },
        groupDefaults = Base.set({}, itemDefaults, {
      fontFamily: 'sans-serif',
      fontWeight: 'normal',
      fontSize: 12,
      leading: null,
      justification: 'left'
    }),
        textDefaults = Base.set({}, groupDefaults, {
      fillColor: new Color()
    }),
        flags = {
      strokeWidth: 193,
      strokeCap: 193,
      strokeJoin: 193,
      strokeScaling: 201,
      miterLimit: 193,
      fontFamily: 9,
      fontWeight: 9,
      fontSize: 9,
      font: 9,
      leading: 9,
      justification: 9
    },
        item = {
      beans: true
    },
        fields = {
      _class: 'Style',
      beans: true,
      initialize: function Style(style, _owner, _project) {
        this._values = {};
        this._owner = _owner;
        this._project = _owner && _owner._project || _project || paper.project;
        this._defaults = !_owner || _owner instanceof Group ? groupDefaults : _owner instanceof TextItem ? textDefaults : itemDefaults;
        if (style) this.set(style);
      }
    };
    Base.each(groupDefaults, function (value, key) {
      var isColor = /Color$/.test(key),
          isPoint = key === 'shadowOffset',
          part = Base.capitalize(key),
          flag = flags[key],
          set = 'set' + part,
          get = 'get' + part;

      fields[set] = function (value) {
        var owner = this._owner,
            children = owner && owner._children,
            applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath);

        if (applyToChildren) {
          for (var i = 0, l = children.length; i < l; i++) children[i]._style[set](value);
        }

        if ((key === 'selectedColor' || !applyToChildren) && key in this._defaults) {
          var old = this._values[key];

          if (old !== value) {
            if (isColor) {
              if (old) {
                Color._setOwner(old, null);

                old._canvasStyle = null;
              }

              if (value && value.constructor === Color) {
                value = Color._setOwner(value, owner, applyToChildren && set);
              }
            }

            this._values[key] = value;
            if (owner) owner._changed(flag || 129);
          }
        }
      };

      fields[get] = function (_dontMerge) {
        var owner = this._owner,
            children = owner && owner._children,
            applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath),
            value;

        if (applyToChildren && !_dontMerge) {
          for (var i = 0, l = children.length; i < l; i++) {
            var childValue = children[i]._style[get]();

            if (!i) {
              value = childValue;
            } else if (!Base.equals(value, childValue)) {
              return undefined;
            }
          }
        } else if (key in this._defaults) {
          var value = this._values[key];

          if (value === undefined) {
            value = this._defaults[key];

            if (value && value.clone) {
              value = value.clone();
            }
          } else {
            var ctor = isColor ? Color : isPoint ? Point : null;

            if (ctor && !(value && value.constructor === ctor)) {
              this._values[key] = value = ctor.read([value], 0, {
                readNull: true,
                clone: true
              });
            }
          }
        }

        if (value && isColor) {
          value = Color._setOwner(value, owner, applyToChildren && set);
        }

        return value;
      };

      item[get] = function (_dontMerge) {
        return this._style[get](_dontMerge);
      };

      item[set] = function (value) {
        this._style[set](value);
      };
    });
    Base.each({
      Font: 'FontFamily',
      WindingRule: 'FillRule'
    }, function (value, key) {
      var get = 'get' + key,
          set = 'set' + key;
      fields[get] = item[get] = '#get' + value;
      fields[set] = item[set] = '#set' + value;
    });
    Item.inject(item);
    return fields;
  }(), {
    set: function (style) {
      var isStyle = style instanceof Style,
          values = isStyle ? style._values : style;

      if (values) {
        for (var key in values) {
          if (key in this._defaults) {
            var value = values[key];
            this[key] = value && isStyle && value.clone ? value.clone() : value;
          }
        }
      }
    },
    equals: function (style) {
      function compare(style1, style2, secondary) {
        var values1 = style1._values,
            values2 = style2._values,
            defaults2 = style2._defaults;

        for (var key in values1) {
          var value1 = values1[key],
              value2 = values2[key];
          if (!(secondary && key in values2) && !Base.equals(value1, value2 === undefined ? defaults2[key] : value2)) return false;
        }

        return true;
      }

      return style === this || style && this._class === style._class && compare(this, style) && compare(style, this, true) || false;
    },
    _dispose: function () {
      var color;
      color = this.getFillColor();
      if (color) color._canvasStyle = null;
      color = this.getStrokeColor();
      if (color) color._canvasStyle = null;
      color = this.getShadowColor();
      if (color) color._canvasStyle = null;
    },
    hasFill: function () {
      var color = this.getFillColor();
      return !!color && color.alpha > 0;
    },
    hasStroke: function () {
      var color = this.getStrokeColor();
      return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
    },
    hasShadow: function () {
      var color = this.getShadowColor();
      return !!color && color.alpha > 0 && (this.getShadowBlur() > 0 || !this.getShadowOffset().isZero());
    },
    getView: function () {
      return this._project._view;
    },
    getFontStyle: function () {
      var fontSize = this.getFontSize();
      return this.getFontWeight() + ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ') + this.getFontFamily();
    },
    getFont: '#getFontFamily',
    setFont: '#setFontFamily',
    getLeading: function getLeading() {
      var leading = getLeading.base.call(this),
          fontSize = this.getFontSize();
      if (/pt|em|%|px/.test(fontSize)) fontSize = this.getView().getPixelSize(fontSize);
      return leading != null ? leading : fontSize * 1.2;
    }
  });
  var DomElement = new function () {
    function handlePrefix(el, name, set, value) {
      var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
          suffix = name[0].toUpperCase() + name.substring(1);

      for (var i = 0; i < 6; i++) {
        var prefix = prefixes[i],
            key = prefix ? prefix + suffix : name;

        if (key in el) {
          if (set) {
            el[key] = value;
          } else {
            return el[key];
          }

          break;
        }
      }
    }

    return {
      getStyles: function (el) {
        var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
            view = doc && doc.defaultView;
        return view && view.getComputedStyle(el, '');
      },
      getBounds: function (el, viewport) {
        var doc = el.ownerDocument,
            body = doc.body,
            html = doc.documentElement,
            rect;

        try {
          rect = el.getBoundingClientRect();
        } catch (e) {
          rect = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
          };
        }

        var x = rect.left - (html.clientLeft || body.clientLeft || 0),
            y = rect.top - (html.clientTop || body.clientTop || 0);

        if (!viewport) {
          var view = doc.defaultView;
          x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
          y += view.pageYOffset || html.scrollTop || body.scrollTop;
        }

        return new Rectangle(x, y, rect.width, rect.height);
      },
      getViewportBounds: function (el) {
        var doc = el.ownerDocument,
            view = doc.defaultView,
            html = doc.documentElement;
        return new Rectangle(0, 0, view.innerWidth || html.clientWidth, view.innerHeight || html.clientHeight);
      },
      getOffset: function (el, viewport) {
        return DomElement.getBounds(el, viewport).getPoint();
      },
      getSize: function (el) {
        return DomElement.getBounds(el, true).getSize();
      },
      isInvisible: function (el) {
        return DomElement.getSize(el).equals(new Size(0, 0));
      },
      isInView: function (el) {
        return !DomElement.isInvisible(el) && DomElement.getViewportBounds(el).intersects(DomElement.getBounds(el, true));
      },
      isInserted: function (el) {
        return document.body.contains(el);
      },
      getPrefixed: function (el, name) {
        return el && handlePrefix(el, name);
      },
      setPrefixed: function (el, name, value) {
        if (typeof name === 'object') {
          for (var key in name) handlePrefix(el, key, true, name[key]);
        } else {
          handlePrefix(el, name, true, value);
        }
      }
    };
  }();
  var DomEvent = {
    add: function (el, events) {
      if (el) {
        for (var type in events) {
          var func = events[type],
              parts = type.split(/[\s,]+/g);

          for (var i = 0, l = parts.length; i < l; i++) {
            var name = parts[i];
            var options = el === document && (name === 'touchstart' || name === 'touchmove') ? {
              passive: false
            } : false;
            el.addEventListener(name, func, options);
          }
        }
      }
    },
    remove: function (el, events) {
      if (el) {
        for (var type in events) {
          var func = events[type],
              parts = type.split(/[\s,]+/g);

          for (var i = 0, l = parts.length; i < l; i++) el.removeEventListener(parts[i], func, false);
        }
      }
    },
    getPoint: function (event) {
      var pos = event.targetTouches ? event.targetTouches.length ? event.targetTouches[0] : event.changedTouches[0] : event;
      return new Point(pos.pageX || pos.clientX + document.documentElement.scrollLeft, pos.pageY || pos.clientY + document.documentElement.scrollTop);
    },
    getTarget: function (event) {
      return event.target || event.srcElement;
    },
    getRelatedTarget: function (event) {
      return event.relatedTarget || event.toElement;
    },
    getOffset: function (event, target) {
      return DomEvent.getPoint(event).subtract(DomElement.getOffset(target || DomEvent.getTarget(event)));
    }
  };
  DomEvent.requestAnimationFrame = new function () {
    var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
        requested = false,
        callbacks = [],
        timer;

    function handleCallbacks() {
      var functions = callbacks;
      callbacks = [];

      for (var i = 0, l = functions.length; i < l; i++) functions[i]();

      requested = nativeRequest && callbacks.length;
      if (requested) nativeRequest(handleCallbacks);
    }

    return function (callback) {
      callbacks.push(callback);

      if (nativeRequest) {
        if (!requested) {
          nativeRequest(handleCallbacks);
          requested = true;
        }
      } else if (!timer) {
        timer = setInterval(handleCallbacks, 1000 / 60);
      }
    };
  }();
  var View = Base.extend(Emitter, {
    _class: 'View',
    initialize: function View(project, element) {
      function getSize(name) {
        return element[name] || parseInt(element.getAttribute(name), 10);
      }

      function getCanvasSize() {
        var size = DomElement.getSize(element);
        return size.isNaN() || size.isZero() ? new Size(getSize('width'), getSize('height')) : size;
      }

      var size;

      if (window && element) {
        this._id = element.getAttribute('id');
        if (this._id == null) element.setAttribute('id', this._id = 'paper-view-' + View._id++);
        DomEvent.add(element, this._viewEvents);
        var none = 'none';
        DomElement.setPrefixed(element.style, {
          userDrag: none,
          userSelect: none,
          touchCallout: none,
          contentZooming: none,
          tapHighlightColor: 'rgba(0,0,0,0)'
        });

        if (PaperScope.hasAttribute(element, 'resize')) {
          var that = this;
          DomEvent.add(window, this._windowEvents = {
            resize: function () {
              that.setViewSize(getCanvasSize());
            }
          });
        }

        size = getCanvasSize();

        if (PaperScope.hasAttribute(element, 'stats') && typeof Stats !== 'undefined') {
          this._stats = new Stats();
          var stats = this._stats.domElement,
              style = stats.style,
              offset = DomElement.getOffset(element);
          style.position = 'absolute';
          style.left = offset.x + 'px';
          style.top = offset.y + 'px';
          document.body.appendChild(stats);
        }
      } else {
        size = new Size(element);
        element = null;
      }

      this._project = project;
      this._scope = project._scope;
      this._element = element;
      if (!this._pixelRatio) this._pixelRatio = window && window.devicePixelRatio || 1;

      this._setElementSize(size.width, size.height);

      this._viewSize = size;

      View._views.push(this);

      View._viewsById[this._id] = this;
      (this._matrix = new Matrix())._owner = this;
      if (!View._focused) View._focused = this;
      this._frameItems = {};
      this._frameItemCount = 0;
      this._itemEvents = {
        native: {},
        virtual: {}
      };
      this._autoUpdate = !paper.agent.node;
      this._needsUpdate = false;
    },
    remove: function () {
      if (!this._project) return false;
      if (View._focused === this) View._focused = null;

      View._views.splice(View._views.indexOf(this), 1);

      delete View._viewsById[this._id];
      var project = this._project;
      if (project._view === this) project._view = null;
      DomEvent.remove(this._element, this._viewEvents);
      DomEvent.remove(window, this._windowEvents);
      this._element = this._project = null;
      this.off('frame');
      this._animate = false;
      this._frameItems = {};
      return true;
    },
    _events: Base.each(Item._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']), function (name) {
      this[name] = {};
    }, {
      onFrame: {
        install: function () {
          this.play();
        },
        uninstall: function () {
          this.pause();
        }
      }
    }),
    _animate: false,
    _time: 0,
    _count: 0,
    getAutoUpdate: function () {
      return this._autoUpdate;
    },
    setAutoUpdate: function (autoUpdate) {
      this._autoUpdate = autoUpdate;
      if (autoUpdate) this.requestUpdate();
    },
    update: function () {},
    draw: function () {
      this.update();
    },
    requestUpdate: function () {
      if (!this._requested) {
        var that = this;
        DomEvent.requestAnimationFrame(function () {
          that._requested = false;

          if (that._animate) {
            that.requestUpdate();
            var element = that._element;

            if ((!DomElement.getPrefixed(document, 'hidden') || PaperScope.getAttribute(element, 'keepalive') === 'true') && DomElement.isInView(element)) {
              that._handleFrame();
            }
          }

          if (that._autoUpdate) that.update();
        });
        this._requested = true;
      }
    },
    play: function () {
      this._animate = true;
      this.requestUpdate();
    },
    pause: function () {
      this._animate = false;
    },
    _handleFrame: function () {
      paper = this._scope;
      var now = Date.now() / 1000,
          delta = this._last ? now - this._last : 0;
      this._last = now;
      this.emit('frame', new Base({
        delta: delta,
        time: this._time += delta,
        count: this._count++
      }));
      if (this._stats) this._stats.update();
    },
    _animateItem: function (item, animate) {
      var items = this._frameItems;

      if (animate) {
        items[item._id] = {
          item: item,
          time: 0,
          count: 0
        };
        if (++this._frameItemCount === 1) this.on('frame', this._handleFrameItems);
      } else {
        delete items[item._id];

        if (--this._frameItemCount === 0) {
          this.off('frame', this._handleFrameItems);
        }
      }
    },
    _handleFrameItems: function (event) {
      for (var i in this._frameItems) {
        var entry = this._frameItems[i];
        entry.item.emit('frame', new Base(event, {
          time: entry.time += event.delta,
          count: entry.count++
        }));
      }
    },
    _changed: function () {
      this._project._changed(4097);

      this._bounds = this._decomposed = undefined;
    },
    getElement: function () {
      return this._element;
    },
    getPixelRatio: function () {
      return this._pixelRatio;
    },
    getResolution: function () {
      return this._pixelRatio * 72;
    },
    getViewSize: function () {
      var size = this._viewSize;
      return new LinkedSize(size.width, size.height, this, 'setViewSize');
    },
    setViewSize: function () {
      var size = Size.read(arguments),
          delta = size.subtract(this._viewSize);
      if (delta.isZero()) return;

      this._setElementSize(size.width, size.height);

      this._viewSize.set(size);

      this._changed();

      this.emit('resize', {
        size: size,
        delta: delta
      });

      if (this._autoUpdate) {
        this.update();
      }
    },
    _setElementSize: function (width, height) {
      var element = this._element;

      if (element) {
        if (element.width !== width) element.width = width;
        if (element.height !== height) element.height = height;
      }
    },
    getBounds: function () {
      if (!this._bounds) this._bounds = this._matrix.inverted()._transformBounds(new Rectangle(new Point(), this._viewSize));
      return this._bounds;
    },
    getSize: function () {
      return this.getBounds().getSize();
    },
    isVisible: function () {
      return DomElement.isInView(this._element);
    },
    isInserted: function () {
      return DomElement.isInserted(this._element);
    },
    getPixelSize: function (size) {
      var element = this._element,
          pixels;

      if (element) {
        var parent = element.parentNode,
            temp = document.createElement('div');
        temp.style.fontSize = size;
        parent.appendChild(temp);
        pixels = parseFloat(DomElement.getStyles(temp).fontSize);
        parent.removeChild(temp);
      } else {
        pixels = parseFloat(pixels);
      }

      return pixels;
    },
    getTextWidth: function (font, lines) {
      return 0;
    }
  }, Base.each(['rotate', 'scale', 'shear', 'skew'], function (key) {
    var rotate = key === 'rotate';

    this[key] = function () {
      var args = arguments,
          value = (rotate ? Base : Point).read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      return this.transform(new Matrix()[key](value, center || this.getCenter(true)));
    };
  }, {
    _decompose: function () {
      return this._decomposed || (this._decomposed = this._matrix.decompose());
    },
    translate: function () {
      var mx = new Matrix();
      return this.transform(mx.translate.apply(mx, arguments));
    },
    getCenter: function () {
      return this.getBounds().getCenter();
    },
    setCenter: function () {
      var center = Point.read(arguments);
      this.translate(this.getCenter().subtract(center));
    },
    getZoom: function () {
      var scaling = this._decompose().scaling;

      return (scaling.x + scaling.y) / 2;
    },
    setZoom: function (zoom) {
      this.transform(new Matrix().scale(zoom / this.getZoom(), this.getCenter()));
    },
    getRotation: function () {
      return this._decompose().rotation;
    },
    setRotation: function (rotation) {
      var current = this.getRotation();

      if (current != null && rotation != null) {
        this.rotate(rotation - current);
      }
    },
    getScaling: function () {
      var scaling = this._decompose().scaling;

      return new LinkedPoint(scaling.x, scaling.y, this, 'setScaling');
    },
    setScaling: function () {
      var current = this.getScaling(),
          scaling = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });

      if (current && scaling) {
        this.scale(scaling.x / current.x, scaling.y / current.y);
      }
    },
    getMatrix: function () {
      return this._matrix;
    },
    setMatrix: function () {
      var matrix = this._matrix;
      matrix.set.apply(matrix, arguments);
    },
    transform: function (matrix) {
      this._matrix.append(matrix);
    },
    scrollBy: function () {
      this.translate(Point.read(arguments).negate());
    }
  }), {
    projectToView: function () {
      return this._matrix._transformPoint(Point.read(arguments));
    },
    viewToProject: function () {
      return this._matrix._inverseTransform(Point.read(arguments));
    },
    getEventPoint: function (event) {
      return this.viewToProject(DomEvent.getOffset(event, this._element));
    }
  }, {
    statics: {
      _views: [],
      _viewsById: {},
      _id: 0,
      create: function (project, element) {
        if (document && typeof element === 'string') element = document.getElementById(element);
        var ctor = window ? CanvasView : View;
        return new ctor(project, element);
      }
    }
  }, new function () {
    if (!window) return;
    var prevFocus,
        tempFocus,
        dragging = false,
        mouseDown = false;

    function getView(event) {
      var target = DomEvent.getTarget(event);
      return target.getAttribute && View._viewsById[target.getAttribute('id')];
    }

    function updateFocus() {
      var view = View._focused;

      if (!view || !view.isVisible()) {
        for (var i = 0, l = View._views.length; i < l; i++) {
          if ((view = View._views[i]).isVisible()) {
            View._focused = tempFocus = view;
            break;
          }
        }
      }
    }

    function handleMouseMove(view, event, point) {
      view._handleMouseEvent('mousemove', event, point);
    }

    var navigator = window.navigator,
        mousedown,
        mousemove,
        mouseup;

    if (navigator.pointerEnabled || navigator.msPointerEnabled) {
      mousedown = 'pointerdown MSPointerDown';
      mousemove = 'pointermove MSPointerMove';
      mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
    } else {
      mousedown = 'touchstart';
      mousemove = 'touchmove';
      mouseup = 'touchend touchcancel';

      if (!('ontouchstart' in window && navigator.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
        mousedown += ' mousedown';
        mousemove += ' mousemove';
        mouseup += ' mouseup';
      }
    }

    var viewEvents = {},
        docEvents = {
      mouseout: function (event) {
        var view = View._focused,
            target = DomEvent.getRelatedTarget(event);

        if (view && (!target || target.nodeName === 'HTML')) {
          var offset = DomEvent.getOffset(event, view._element),
              x = offset.x,
              abs = Math.abs,
              ax = abs(x),
              max = 1 << 25,
              diff = ax - max;
          offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;
          handleMouseMove(view, event, view.viewToProject(offset));
        }
      },
      scroll: updateFocus
    };

    viewEvents[mousedown] = function (event) {
      var view = View._focused = getView(event);

      if (!dragging) {
        dragging = true;

        view._handleMouseEvent('mousedown', event);
      }
    };

    docEvents[mousemove] = function (event) {
      var view = View._focused;

      if (!mouseDown) {
        var target = getView(event);

        if (target) {
          if (view !== target) {
            if (view) handleMouseMove(view, event);
            if (!prevFocus) prevFocus = view;
            view = View._focused = tempFocus = target;
          }
        } else if (tempFocus && tempFocus === view) {
          if (prevFocus && !prevFocus.isInserted()) prevFocus = null;
          view = View._focused = prevFocus;
          prevFocus = null;
          updateFocus();
        }
      }

      if (view) handleMouseMove(view, event);
    };

    docEvents[mousedown] = function () {
      mouseDown = true;
    };

    docEvents[mouseup] = function (event) {
      var view = View._focused;
      if (view && dragging) view._handleMouseEvent('mouseup', event);
      mouseDown = dragging = false;
    };

    DomEvent.add(document, docEvents);
    DomEvent.add(window, {
      load: updateFocus
    });
    var called = false,
        prevented = false,
        fallbacks = {
      doubleclick: 'click',
      mousedrag: 'mousemove'
    },
        wasInView = false,
        overView,
        downPoint,
        lastPoint,
        downItem,
        overItem,
        dragItem,
        clickItem,
        clickTime,
        dblClick;

    function emitMouseEvent(obj, target, type, event, point, prevPoint, stopItem) {
      var stopped = false,
          mouseEvent;

      function emit(obj, type) {
        if (obj.responds(type)) {
          if (!mouseEvent) {
            mouseEvent = new MouseEvent(type, event, point, target || obj, prevPoint ? point.subtract(prevPoint) : null);
          }

          if (obj.emit(type, mouseEvent)) {
            called = true;
            if (mouseEvent.prevented) prevented = true;
            if (mouseEvent.stopped) return stopped = true;
          }
        } else {
          var fallback = fallbacks[type];
          if (fallback) return emit(obj, fallback);
        }
      }

      while (obj && obj !== stopItem) {
        if (emit(obj, type)) break;
        obj = obj._parent;
      }

      return stopped;
    }

    function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
      view._project.removeOn(type);

      prevented = called = false;
      return dragItem && emitMouseEvent(dragItem, null, type, event, point, prevPoint) || hitItem && hitItem !== dragItem && !hitItem.isDescendant(dragItem) && emitMouseEvent(hitItem, null, type === 'mousedrag' ? 'mousemove' : type, event, point, prevPoint, dragItem) || emitMouseEvent(view, dragItem || hitItem || view, type, event, point, prevPoint);
    }

    var itemEventsMap = {
      mousedown: {
        mousedown: 1,
        mousedrag: 1,
        click: 1,
        doubleclick: 1
      },
      mouseup: {
        mouseup: 1,
        mousedrag: 1,
        click: 1,
        doubleclick: 1
      },
      mousemove: {
        mousedrag: 1,
        mousemove: 1,
        mouseenter: 1,
        mouseleave: 1
      }
    };
    return {
      _viewEvents: viewEvents,
      _handleMouseEvent: function (type, event, point) {
        var itemEvents = this._itemEvents,
            hitItems = itemEvents.native[type],
            nativeMove = type === 'mousemove',
            tool = this._scope.tool,
            view = this;

        function responds(type) {
          return itemEvents.virtual[type] || view.responds(type) || tool && tool.responds(type);
        }

        if (nativeMove && dragging && responds('mousedrag')) type = 'mousedrag';
        if (!point) point = this.getEventPoint(event);

        var inView = this.getBounds().contains(point),
            hit = hitItems && inView && view._project.hitTest(point, {
          tolerance: 0,
          fill: true,
          stroke: true
        }),
            hitItem = hit && hit.item || null,
            handle = false,
            mouse = {};

        mouse[type.substr(5)] = true;

        if (hitItems && hitItem !== overItem) {
          if (overItem) {
            emitMouseEvent(overItem, null, 'mouseleave', event, point);
          }

          if (hitItem) {
            emitMouseEvent(hitItem, null, 'mouseenter', event, point);
          }

          overItem = hitItem;
        }

        if (wasInView ^ inView) {
          emitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave', event, point);
          overView = inView ? this : null;
          handle = true;
        }

        if ((inView || mouse.drag) && !point.equals(lastPoint)) {
          emitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove', event, point, lastPoint);
          handle = true;
        }

        wasInView = inView;

        if (mouse.down && inView || mouse.up && downPoint) {
          emitMouseEvents(this, hitItem, type, event, point, downPoint);

          if (mouse.down) {
            dblClick = hitItem === clickItem && Date.now() - clickTime < 300;
            downItem = clickItem = hitItem;

            if (!prevented && hitItem) {
              var item = hitItem;

              while (item && !item.responds('mousedrag')) item = item._parent;

              if (item) dragItem = hitItem;
            }

            downPoint = point;
          } else if (mouse.up) {
            if (!prevented && hitItem === downItem) {
              clickTime = Date.now();
              emitMouseEvents(this, hitItem, dblClick ? 'doubleclick' : 'click', event, point, downPoint);
              dblClick = false;
            }

            downItem = dragItem = null;
          }

          wasInView = false;
          handle = true;
        }

        lastPoint = point;

        if (handle && tool) {
          called = tool._handleMouseEvent(type, event, point, mouse) || called;
        }

        if (event.cancelable !== false && (called && !mouse.move || mouse.down && responds('mouseup'))) {
          event.preventDefault();
        }
      },
      _handleKeyEvent: function (type, event, key, character) {
        var scope = this._scope,
            tool = scope.tool,
            keyEvent;

        function emit(obj) {
          if (obj.responds(type)) {
            paper = scope;
            obj.emit(type, keyEvent = keyEvent || new KeyEvent(type, event, key, character));
          }
        }

        if (this.isVisible()) {
          emit(this);
          if (tool && tool.responds(type)) emit(tool);
        }
      },
      _countItemEvent: function (type, sign) {
        var itemEvents = this._itemEvents,
            native = itemEvents.native,
            virtual = itemEvents.virtual;

        for (var key in itemEventsMap) {
          native[key] = (native[key] || 0) + (itemEventsMap[key][type] || 0) * sign;
        }

        virtual[type] = (virtual[type] || 0) + sign;
      },
      statics: {
        updateFocus: updateFocus,
        _resetState: function () {
          dragging = mouseDown = called = wasInView = false;
          prevFocus = tempFocus = overView = downPoint = lastPoint = downItem = overItem = dragItem = clickItem = clickTime = dblClick = null;
        }
      }
    };
  }());
  var CanvasView = View.extend({
    _class: 'CanvasView',
    initialize: function CanvasView(project, canvas) {
      if (!(canvas instanceof window.HTMLCanvasElement)) {
        var size = Size.read(arguments, 1);
        if (size.isZero()) throw new Error('Cannot create CanvasView with the provided argument: ' + Base.slice(arguments, 1));
        canvas = CanvasProvider.getCanvas(size);
      }

      var ctx = this._context = canvas.getContext('2d');
      ctx.save();
      this._pixelRatio = 1;

      if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
        var deviceRatio = window.devicePixelRatio || 1,
            backingStoreRatio = DomElement.getPrefixed(ctx, 'backingStorePixelRatio') || 1;
        this._pixelRatio = deviceRatio / backingStoreRatio;
      }

      View.call(this, project, canvas);
      this._needsUpdate = true;
    },
    remove: function remove() {
      this._context.restore();

      return remove.base.call(this);
    },
    _setElementSize: function _setElementSize(width, height) {
      var pixelRatio = this._pixelRatio;

      _setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);

      if (pixelRatio !== 1) {
        var element = this._element,
            ctx = this._context;

        if (!PaperScope.hasAttribute(element, 'resize')) {
          var style = element.style;
          style.width = width + 'px';
          style.height = height + 'px';
        }

        ctx.restore();
        ctx.save();
        ctx.scale(pixelRatio, pixelRatio);
      }
    },
    getContext: function () {
      return this._context;
    },
    getPixelSize: function getPixelSize(size) {
      var agent = paper.agent,
          pixels;

      if (agent && agent.firefox) {
        pixels = getPixelSize.base.call(this, size);
      } else {
        var ctx = this._context,
            prevFont = ctx.font;
        ctx.font = size + ' serif';
        pixels = parseFloat(ctx.font);
        ctx.font = prevFont;
      }

      return pixels;
    },
    getTextWidth: function (font, lines) {
      var ctx = this._context,
          prevFont = ctx.font,
          width = 0;
      ctx.font = font;

      for (var i = 0, l = lines.length; i < l; i++) width = Math.max(width, ctx.measureText(lines[i]).width);

      ctx.font = prevFont;
      return width;
    },
    update: function () {
      if (!this._needsUpdate) return false;
      var project = this._project,
          ctx = this._context,
          size = this._viewSize;
      ctx.clearRect(0, 0, size.width + 1, size.height + 1);
      if (project) project.draw(ctx, this._matrix, this._pixelRatio);
      this._needsUpdate = false;
      return true;
    }
  });
  var Event = Base.extend({
    _class: 'Event',
    initialize: function Event(event) {
      this.event = event;
      this.type = event && event.type;
    },
    prevented: false,
    stopped: false,
    preventDefault: function () {
      this.prevented = true;
      this.event.preventDefault();
    },
    stopPropagation: function () {
      this.stopped = true;
      this.event.stopPropagation();
    },
    stop: function () {
      this.stopPropagation();
      this.preventDefault();
    },
    getTimeStamp: function () {
      return this.event.timeStamp;
    },
    getModifiers: function () {
      return Key.modifiers;
    }
  });
  var KeyEvent = Event.extend({
    _class: 'KeyEvent',
    initialize: function KeyEvent(type, event, key, character) {
      this.type = type;
      this.event = event;
      this.key = key;
      this.character = character;
    },
    toString: function () {
      return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
    }
  });
  var Key = new function () {
    var keyLookup = {
      '\t': 'tab',
      ' ': 'space',
      '\b': 'backspace',
      '\x7f': 'delete',
      'Spacebar': 'space',
      'Del': 'delete',
      'Win': 'meta',
      'Esc': 'escape'
    },
        charLookup = {
      'tab': '\t',
      'space': ' ',
      'enter': '\r'
    },
        keyMap = {},
        charMap = {},
        metaFixMap,
        downKey,
        modifiers = new Base({
      shift: false,
      control: false,
      alt: false,
      meta: false,
      capsLock: false,
      space: false
    }).inject({
      option: {
        get: function () {
          return this.alt;
        }
      },
      command: {
        get: function () {
          var agent = paper && paper.agent;
          return agent && agent.mac ? this.meta : this.control;
        }
      }
    });

    function getKey(event) {
      var key = event.key || event.keyIdentifier;
      key = /^U\+/.test(key) ? String.fromCharCode(parseInt(key.substr(2), 16)) : /^Arrow[A-Z]/.test(key) ? key.substr(5) : key === 'Unidentified' || key === undefined ? String.fromCharCode(event.keyCode) : key;
      return keyLookup[key] || (key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
    }

    function handleKey(down, key, character, event) {
      var type = down ? 'keydown' : 'keyup',
          view = View._focused,
          name;
      keyMap[key] = down;

      if (down) {
        charMap[key] = character;
      } else {
        delete charMap[key];
      }

      if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
        modifiers[name] = down;
        var agent = paper && paper.agent;

        if (name === 'meta' && agent && agent.mac) {
          if (down) {
            metaFixMap = {};
          } else {
            for (var k in metaFixMap) {
              if (k in charMap) handleKey(false, k, metaFixMap[k], event);
            }

            metaFixMap = null;
          }
        }
      } else if (down && metaFixMap) {
        metaFixMap[key] = character;
      }

      if (view) {
        view._handleKeyEvent(down ? 'keydown' : 'keyup', event, key, character);
      }
    }

    DomEvent.add(document, {
      keydown: function (event) {
        var key = getKey(event),
            agent = paper && paper.agent;

        if (key.length > 1 || agent && agent.chrome && (event.altKey || agent.mac && event.metaKey || !agent.mac && event.ctrlKey)) {
          handleKey(true, key, charLookup[key] || (key.length > 1 ? '' : key), event);
        } else {
          downKey = key;
        }
      },
      keypress: function (event) {
        if (downKey) {
          var key = getKey(event),
              code = event.charCode,
              character = code >= 32 ? String.fromCharCode(code) : key.length > 1 ? '' : key;

          if (key !== downKey) {
            key = character.toLowerCase();
          }

          handleKey(true, key, character, event);
          downKey = null;
        }
      },
      keyup: function (event) {
        var key = getKey(event);
        if (key in charMap) handleKey(false, key, charMap[key], event);
      }
    });
    DomEvent.add(window, {
      blur: function (event) {
        for (var key in charMap) handleKey(false, key, charMap[key], event);
      }
    });
    return {
      modifiers: modifiers,
      isDown: function (key) {
        return !!keyMap[key];
      }
    };
  }();
  var MouseEvent = Event.extend({
    _class: 'MouseEvent',
    initialize: function MouseEvent(type, event, point, target, delta) {
      this.type = type;
      this.event = event;
      this.point = point;
      this.target = target;
      this.delta = delta;
    },
    toString: function () {
      return "{ type: '" + this.type + "', point: " + this.point + ', target: ' + this.target + (this.delta ? ', delta: ' + this.delta : '') + ', modifiers: ' + this.getModifiers() + ' }';
    }
  });
  var ToolEvent = Event.extend({
    _class: 'ToolEvent',
    _item: null,
    initialize: function ToolEvent(tool, type, event) {
      this.tool = tool;
      this.type = type;
      this.event = event;
    },
    _choosePoint: function (point, toolPoint) {
      return point ? point : toolPoint ? toolPoint.clone() : null;
    },
    getPoint: function () {
      return this._choosePoint(this._point, this.tool._point);
    },
    setPoint: function (point) {
      this._point = point;
    },
    getLastPoint: function () {
      return this._choosePoint(this._lastPoint, this.tool._lastPoint);
    },
    setLastPoint: function (lastPoint) {
      this._lastPoint = lastPoint;
    },
    getDownPoint: function () {
      return this._choosePoint(this._downPoint, this.tool._downPoint);
    },
    setDownPoint: function (downPoint) {
      this._downPoint = downPoint;
    },
    getMiddlePoint: function () {
      if (!this._middlePoint && this.tool._lastPoint) {
        return this.tool._point.add(this.tool._lastPoint).divide(2);
      }

      return this._middlePoint;
    },
    setMiddlePoint: function (middlePoint) {
      this._middlePoint = middlePoint;
    },
    getDelta: function () {
      return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
    },
    setDelta: function (delta) {
      this._delta = delta;
    },
    getCount: function () {
      return this.tool[/^mouse(down|up)$/.test(this.type) ? '_downCount' : '_moveCount'];
    },
    setCount: function (count) {
      this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count'] = count;
    },
    getItem: function () {
      if (!this._item) {
        var result = this.tool._scope.project.hitTest(this.getPoint());

        if (result) {
          var item = result.item,
              parent = item._parent;

          while (/^(Group|CompoundPath)$/.test(parent._class)) {
            item = parent;
            parent = parent._parent;
          }

          this._item = item;
        }
      }

      return this._item;
    },
    setItem: function (item) {
      this._item = item;
    },
    toString: function () {
      return '{ type: ' + this.type + ', point: ' + this.getPoint() + ', count: ' + this.getCount() + ', modifiers: ' + this.getModifiers() + ' }';
    }
  });
  var Tool = PaperScopeItem.extend({
    _class: 'Tool',
    _list: 'tools',
    _reference: 'tool',
    _events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove', 'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown', 'onKeyUp'],
    initialize: function Tool(props) {
      PaperScopeItem.call(this);
      this._moveCount = -1;
      this._downCount = -1;
      this.set(props);
    },
    getMinDistance: function () {
      return this._minDistance;
    },
    setMinDistance: function (minDistance) {
      this._minDistance = minDistance;

      if (minDistance != null && this._maxDistance != null && minDistance > this._maxDistance) {
        this._maxDistance = minDistance;
      }
    },
    getMaxDistance: function () {
      return this._maxDistance;
    },
    setMaxDistance: function (maxDistance) {
      this._maxDistance = maxDistance;

      if (this._minDistance != null && maxDistance != null && maxDistance < this._minDistance) {
        this._minDistance = maxDistance;
      }
    },
    getFixedDistance: function () {
      return this._minDistance == this._maxDistance ? this._minDistance : null;
    },
    setFixedDistance: function (distance) {
      this._minDistance = this._maxDistance = distance;
    },
    _handleMouseEvent: function (type, event, point, mouse) {
      paper = this._scope;
      if (mouse.drag && !this.responds(type)) type = 'mousemove';
      var move = mouse.move || mouse.drag,
          responds = this.responds(type),
          minDistance = this.minDistance,
          maxDistance = this.maxDistance,
          called = false,
          tool = this;

      function update(minDistance, maxDistance) {
        var pt = point,
            toolPoint = move ? tool._point : tool._downPoint || pt;

        if (move) {
          if (tool._moveCount >= 0 && pt.equals(toolPoint)) {
            return false;
          }

          if (toolPoint && (minDistance != null || maxDistance != null)) {
            var vector = pt.subtract(toolPoint),
                distance = vector.getLength();
            if (distance < (minDistance || 0)) return false;

            if (maxDistance) {
              pt = toolPoint.add(vector.normalize(Math.min(distance, maxDistance)));
            }
          }

          tool._moveCount++;
        }

        tool._point = pt;
        tool._lastPoint = toolPoint || pt;

        if (mouse.down) {
          tool._moveCount = -1;
          tool._downPoint = pt;
          tool._downCount++;
        }

        return true;
      }

      function emit() {
        if (responds) {
          called = tool.emit(type, new ToolEvent(tool, type, event)) || called;
        }
      }

      if (mouse.down) {
        update();
        emit();
      } else if (mouse.up) {
        update(null, maxDistance);
        emit();
      } else if (responds) {
        while (update(minDistance, maxDistance)) emit();
      }

      return called;
    }
  });
  var Tween = Base.extend(Emitter, {
    _class: 'Tween',
    statics: {
      easings: {
        linear: function (t) {
          return t;
        },
        easeInQuad: function (t) {
          return t * t;
        },
        easeOutQuad: function (t) {
          return t * (2 - t);
        },
        easeInOutQuad: function (t) {
          return t < 0.5 ? 2 * t * t : -1 + 2 * (2 - t) * t;
        },
        easeInCubic: function (t) {
          return t * t * t;
        },
        easeOutCubic: function (t) {
          return --t * t * t + 1;
        },
        easeInOutCubic: function (t) {
          return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        },
        easeInQuart: function (t) {
          return t * t * t * t;
        },
        easeOutQuart: function (t) {
          return 1 - --t * t * t * t;
        },
        easeInOutQuart: function (t) {
          return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
        },
        easeInQuint: function (t) {
          return t * t * t * t * t;
        },
        easeOutQuint: function (t) {
          return 1 + --t * t * t * t * t;
        },
        easeInOutQuint: function (t) {
          return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
        }
      }
    },
    initialize: function Tween(object, from, to, duration, easing, start) {
      this.object = object;
      var type = typeof easing;
      var isFunction = type === 'function';
      this.type = isFunction ? type : type === 'string' ? easing : 'linear';
      this.easing = isFunction ? easing : Tween.easings[this.type];
      this.duration = duration;
      this.running = false;
      this._then = null;
      this._startTime = null;
      var state = from || to;
      this._keys = state ? Object.keys(state) : [];
      this._parsedKeys = this._parseKeys(this._keys);
      this._from = state && this._getState(from);
      this._to = state && this._getState(to);

      if (start !== false) {
        this.start();
      }
    },
    then: function (then) {
      this._then = then;
      return this;
    },
    start: function () {
      this._startTime = null;
      this.running = true;
      return this;
    },
    stop: function () {
      this.running = false;
      return this;
    },
    update: function (progress) {
      if (this.running) {
        if (progress >= 1) {
          progress = 1;
          this.running = false;
        }

        var factor = this.easing(progress),
            keys = this._keys,
            getValue = function (value) {
          return typeof value === 'function' ? value(factor, progress) : value;
        };

        for (var i = 0, l = keys && keys.length; i < l; i++) {
          var key = keys[i],
              from = getValue(this._from[key]),
              to = getValue(this._to[key]),
              value = from && to && from.__add && to.__add ? to.__subtract(from).__multiply(factor).__add(from) : (to - from) * factor + from;

          this._setProperty(this._parsedKeys[key], value);
        }

        if (this.responds('update')) {
          this.emit('update', new Base({
            progress: progress,
            factor: factor
          }));
        }

        if (!this.running && this._then) {
          this._then(this.object);
        }
      }

      return this;
    },
    _events: {
      onUpdate: {}
    },
    _handleFrame: function (time) {
      var startTime = this._startTime,
          progress = startTime ? (time - startTime) / this.duration : 0;

      if (!startTime) {
        this._startTime = time;
      }

      this.update(progress);
    },
    _getState: function (state) {
      var keys = this._keys,
          result = {};

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i],
            path = this._parsedKeys[key],
            current = this._getProperty(path),
            value;

        if (state) {
          var resolved = this._resolveValue(current, state[key]);

          this._setProperty(path, resolved);

          value = this._getProperty(path);
          value = value && value.clone ? value.clone() : value;

          this._setProperty(path, current);
        } else {
          value = current && current.clone ? current.clone() : current;
        }

        result[key] = value;
      }

      return result;
    },
    _resolveValue: function (current, value) {
      if (value) {
        if (Array.isArray(value) && value.length === 2) {
          var operator = value[0];
          return operator && operator.match && operator.match(/^[+\-\*\/]=/) ? this._calculate(current, operator[0], value[1]) : value;
        } else if (typeof value === 'string') {
          var match = value.match(/^[+\-*/]=(.*)/);

          if (match) {
            var parsed = JSON.parse(match[1].replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": '));
            return this._calculate(current, value[0], parsed);
          }
        }
      }

      return value;
    },
    _calculate: function (left, operator, right) {
      return paper.PaperScript.calculateBinary(left, operator, right);
    },
    _parseKeys: function (keys) {
      var parsed = {};

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i],
            path = key.replace(/\.([^.]*)/g, '/$1').replace(/\[['"]?([^'"\]]*)['"]?\]/g, '/$1');
        parsed[key] = path.split('/');
      }

      return parsed;
    },
    _getProperty: function (path, offset) {
      var obj = this.object;

      for (var i = 0, l = path.length - (offset || 0); i < l && obj; i++) {
        obj = obj[path[i]];
      }

      return obj;
    },
    _setProperty: function (path, value) {
      var dest = this._getProperty(path, 1);

      if (dest) {
        dest[path[path.length - 1]] = value;
      }
    }
  });
  var Http = {
    request: function (options) {
      var xhr = new self.XMLHttpRequest();
      xhr.open((options.method || 'get').toUpperCase(), options.url, Base.pick(options.async, true));
      if (options.mimeType) xhr.overrideMimeType(options.mimeType);

      xhr.onload = function () {
        var status = xhr.status;

        if (status === 0 || status === 200) {
          if (options.onLoad) {
            options.onLoad.call(xhr, xhr.responseText);
          }
        } else {
          xhr.onerror();
        }
      };

      xhr.onerror = function () {
        var status = xhr.status,
            message = 'Could not load "' + options.url + '" (Status: ' + status + ')';

        if (options.onError) {
          options.onError(message, status);
        } else {
          throw new Error(message);
        }
      };

      return xhr.send(null);
    }
  };
  var CanvasProvider = Base.exports.CanvasProvider = {
    canvases: [],
    getCanvas: function (width, height) {
      if (!window) return null;
      var canvas,
          clear = true;

      if (typeof width === 'object') {
        height = width.height;
        width = width.width;
      }

      if (this.canvases.length) {
        canvas = this.canvases.pop();
      } else {
        canvas = document.createElement('canvas');
        clear = false;
      }

      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Canvas ' + canvas + ' is unable to provide a 2D context.');
      }

      if (canvas.width === width && canvas.height === height) {
        if (clear) ctx.clearRect(0, 0, width + 1, height + 1);
      } else {
        canvas.width = width;
        canvas.height = height;
      }

      ctx.save();
      return canvas;
    },
    getContext: function (width, height) {
      var canvas = this.getCanvas(width, height);
      return canvas ? canvas.getContext('2d') : null;
    },
    release: function (obj) {
      var canvas = obj && obj.canvas ? obj.canvas : obj;

      if (canvas && canvas.getContext) {
        canvas.getContext('2d').restore();
        this.canvases.push(canvas);
      }
    }
  };
  var BlendMode = new function () {
    var min = Math.min,
        max = Math.max,
        abs = Math.abs,
        sr,
        sg,
        sb,
        sa,
        br,
        bg,
        bb,
        ba,
        dr,
        dg,
        db;

    function getLum(r, g, b) {
      return 0.2989 * r + 0.587 * g + 0.114 * b;
    }

    function setLum(r, g, b, l) {
      var d = l - getLum(r, g, b);
      dr = r + d;
      dg = g + d;
      db = b + d;
      var l = getLum(dr, dg, db),
          mn = min(dr, dg, db),
          mx = max(dr, dg, db);

      if (mn < 0) {
        var lmn = l - mn;
        dr = l + (dr - l) * l / lmn;
        dg = l + (dg - l) * l / lmn;
        db = l + (db - l) * l / lmn;
      }

      if (mx > 255) {
        var ln = 255 - l,
            mxl = mx - l;
        dr = l + (dr - l) * ln / mxl;
        dg = l + (dg - l) * ln / mxl;
        db = l + (db - l) * ln / mxl;
      }
    }

    function getSat(r, g, b) {
      return max(r, g, b) - min(r, g, b);
    }

    function setSat(r, g, b, s) {
      var col = [r, g, b],
          mx = max(r, g, b),
          mn = min(r, g, b),
          md;
      mn = mn === r ? 0 : mn === g ? 1 : 2;
      mx = mx === r ? 0 : mx === g ? 1 : 2;
      md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;

      if (col[mx] > col[mn]) {
        col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
        col[mx] = s;
      } else {
        col[md] = col[mx] = 0;
      }

      col[mn] = 0;
      dr = col[0];
      dg = col[1];
      db = col[2];
    }

    var modes = {
      multiply: function () {
        dr = br * sr / 255;
        dg = bg * sg / 255;
        db = bb * sb / 255;
      },
      screen: function () {
        dr = br + sr - br * sr / 255;
        dg = bg + sg - bg * sg / 255;
        db = bb + sb - bb * sb / 255;
      },
      overlay: function () {
        dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
        dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
        db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
      },
      'soft-light': function () {
        var t = sr * br / 255;
        dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
        t = sg * bg / 255;
        dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
        t = sb * bb / 255;
        db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
      },
      'hard-light': function () {
        dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
        dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
        db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
      },
      'color-dodge': function () {
        dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
        dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
        db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
      },
      'color-burn': function () {
        dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
        dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
        db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
      },
      darken: function () {
        dr = br < sr ? br : sr;
        dg = bg < sg ? bg : sg;
        db = bb < sb ? bb : sb;
      },
      lighten: function () {
        dr = br > sr ? br : sr;
        dg = bg > sg ? bg : sg;
        db = bb > sb ? bb : sb;
      },
      difference: function () {
        dr = br - sr;
        if (dr < 0) dr = -dr;
        dg = bg - sg;
        if (dg < 0) dg = -dg;
        db = bb - sb;
        if (db < 0) db = -db;
      },
      exclusion: function () {
        dr = br + sr * (255 - br - br) / 255;
        dg = bg + sg * (255 - bg - bg) / 255;
        db = bb + sb * (255 - bb - bb) / 255;
      },
      hue: function () {
        setSat(sr, sg, sb, getSat(br, bg, bb));
        setLum(dr, dg, db, getLum(br, bg, bb));
      },
      saturation: function () {
        setSat(br, bg, bb, getSat(sr, sg, sb));
        setLum(dr, dg, db, getLum(br, bg, bb));
      },
      luminosity: function () {
        setLum(br, bg, bb, getLum(sr, sg, sb));
      },
      color: function () {
        setLum(sr, sg, sb, getLum(br, bg, bb));
      },
      add: function () {
        dr = min(br + sr, 255);
        dg = min(bg + sg, 255);
        db = min(bb + sb, 255);
      },
      subtract: function () {
        dr = max(br - sr, 0);
        dg = max(bg - sg, 0);
        db = max(bb - sb, 0);
      },
      average: function () {
        dr = (br + sr) / 2;
        dg = (bg + sg) / 2;
        db = (bb + sb) / 2;
      },
      negation: function () {
        dr = 255 - abs(255 - sr - br);
        dg = 255 - abs(255 - sg - bg);
        db = 255 - abs(255 - sb - bb);
      }
    };
    var nativeModes = this.nativeModes = Base.each(['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'darker', 'copy', 'xor'], function (mode) {
      this[mode] = true;
    }, {});
    var ctx = CanvasProvider.getContext(1, 1);

    if (ctx) {
      Base.each(modes, function (func, mode) {
        var darken = mode === 'darken',
            ok = false;
        ctx.save();

        try {
          ctx.fillStyle = darken ? '#300' : '#a00';
          ctx.fillRect(0, 0, 1, 1);
          ctx.globalCompositeOperation = mode;

          if (ctx.globalCompositeOperation === mode) {
            ctx.fillStyle = darken ? '#a00' : '#300';
            ctx.fillRect(0, 0, 1, 1);
            ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
          }
        } catch (e) {}

        ctx.restore();
        nativeModes[mode] = ok;
      });
      CanvasProvider.release(ctx);
    }

    this.process = function (mode, srcContext, dstContext, alpha, offset) {
      var srcCanvas = srcContext.canvas,
          normal = mode === 'normal';

      if (normal || nativeModes[mode]) {
        dstContext.save();
        dstContext.setTransform(1, 0, 0, 1, 0, 0);
        dstContext.globalAlpha = alpha;
        if (!normal) dstContext.globalCompositeOperation = mode;
        dstContext.drawImage(srcCanvas, offset.x, offset.y);
        dstContext.restore();
      } else {
        var process = modes[mode];
        if (!process) return;
        var dstData = dstContext.getImageData(offset.x, offset.y, srcCanvas.width, srcCanvas.height),
            dst = dstData.data,
            src = srcContext.getImageData(0, 0, srcCanvas.width, srcCanvas.height).data;

        for (var i = 0, l = dst.length; i < l; i += 4) {
          sr = src[i];
          br = dst[i];
          sg = src[i + 1];
          bg = dst[i + 1];
          sb = src[i + 2];
          bb = dst[i + 2];
          sa = src[i + 3];
          ba = dst[i + 3];
          process();
          var a1 = sa * alpha / 255,
              a2 = 1 - a1;
          dst[i] = a1 * dr + a2 * br;
          dst[i + 1] = a1 * dg + a2 * bg;
          dst[i + 2] = a1 * db + a2 * bb;
          dst[i + 3] = sa * alpha + a2 * ba;
        }

        dstContext.putImageData(dstData, offset.x, offset.y);
      }
    };
  }();
  var SvgElement = new function () {
    var svg = 'http://www.w3.org/2000/svg',
        xmlns = 'http://www.w3.org/2000/xmlns',
        xlink = 'http://www.w3.org/1999/xlink',
        attributeNamespace = {
      href: xlink,
      xlink: xmlns,
      xmlns: xmlns + '/',
      'xmlns:xlink': xmlns + '/'
    };

    function create(tag, attributes, formatter) {
      return set(document.createElementNS(svg, tag), attributes, formatter);
    }

    function get(node, name) {
      var namespace = attributeNamespace[name],
          value = namespace ? node.getAttributeNS(namespace, name) : node.getAttribute(name);
      return value === 'null' ? null : value;
    }

    function set(node, attributes, formatter) {
      for (var name in attributes) {
        var value = attributes[name],
            namespace = attributeNamespace[name];
        if (typeof value === 'number' && formatter) value = formatter.number(value);

        if (namespace) {
          node.setAttributeNS(namespace, name, value);
        } else {
          node.setAttribute(name, value);
        }
      }

      return node;
    }

    return {
      svg: svg,
      xmlns: xmlns,
      xlink: xlink,
      create: create,
      get: get,
      set: set
    };
  }();
  var SvgStyles = Base.each({
    fillColor: ['fill', 'color'],
    fillRule: ['fill-rule', 'string'],
    strokeColor: ['stroke', 'color'],
    strokeWidth: ['stroke-width', 'number'],
    strokeCap: ['stroke-linecap', 'string'],
    strokeJoin: ['stroke-linejoin', 'string'],
    strokeScaling: ['vector-effect', 'lookup', {
      true: 'none',
      false: 'non-scaling-stroke'
    }, function (item, value) {
      return !value && (item instanceof PathItem || item instanceof Shape || item instanceof TextItem);
    }],
    miterLimit: ['stroke-miterlimit', 'number'],
    dashArray: ['stroke-dasharray', 'array'],
    dashOffset: ['stroke-dashoffset', 'number'],
    fontFamily: ['font-family', 'string'],
    fontWeight: ['font-weight', 'string'],
    fontSize: ['font-size', 'number'],
    justification: ['text-anchor', 'lookup', {
      left: 'start',
      center: 'middle',
      right: 'end'
    }],
    opacity: ['opacity', 'number'],
    blendMode: ['mix-blend-mode', 'style']
  }, function (entry, key) {
    var part = Base.capitalize(key),
        lookup = entry[2];
    this[key] = {
      type: entry[1],
      property: key,
      attribute: entry[0],
      toSVG: lookup,
      fromSVG: lookup && Base.each(lookup, function (value, name) {
        this[value] = name;
      }, {}),
      exportFilter: entry[3],
      get: 'get' + part,
      set: 'set' + part
    };
  }, {});
  new function () {
    var formatter;

    function getTransform(matrix, coordinates, center) {
      var attrs = new Base(),
          trans = matrix.getTranslation();

      if (coordinates) {
        var point;

        if (matrix.isInvertible()) {
          matrix = matrix._shiftless();
          point = matrix._inverseTransform(trans);
          trans = null;
        } else {
          point = new Point();
        }

        attrs[center ? 'cx' : 'x'] = point.x;
        attrs[center ? 'cy' : 'y'] = point.y;
      }

      if (!matrix.isIdentity()) {
        var decomposed = matrix.decompose();

        if (decomposed) {
          var parts = [],
              angle = decomposed.rotation,
              scale = decomposed.scaling,
              skew = decomposed.skewing;
          if (trans && !trans.isZero()) parts.push('translate(' + formatter.point(trans) + ')');
          if (angle) parts.push('rotate(' + formatter.number(angle) + ')');
          if (!Numerical.isZero(scale.x - 1) || !Numerical.isZero(scale.y - 1)) parts.push('scale(' + formatter.point(scale) + ')');
          if (skew.x) parts.push('skewX(' + formatter.number(skew.x) + ')');
          if (skew.y) parts.push('skewY(' + formatter.number(skew.y) + ')');
          attrs.transform = parts.join(' ');
        } else {
          attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
        }
      }

      return attrs;
    }

    function exportGroup(item, options) {
      var attrs = getTransform(item._matrix),
          children = item._children;
      var node = SvgElement.create('g', attrs, formatter);

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        var childNode = exportSVG(child, options);

        if (childNode) {
          if (child.isClipMask()) {
            var clip = SvgElement.create('clipPath');
            clip.appendChild(childNode);
            setDefinition(child, clip, 'clip');
            SvgElement.set(node, {
              'clip-path': 'url(#' + clip.id + ')'
            });
          } else {
            node.appendChild(childNode);
          }
        }
      }

      return node;
    }

    function exportRaster(item, options) {
      var attrs = getTransform(item._matrix, true),
          size = item.getSize(),
          image = item.getImage();
      attrs.x -= size.width / 2;
      attrs.y -= size.height / 2;
      attrs.width = size.width;
      attrs.height = size.height;
      attrs.href = options.embedImages == false && image && image.src || item.toDataURL();
      return SvgElement.create('image', attrs, formatter);
    }

    function exportPath(item, options) {
      var matchShapes = options.matchShapes;

      if (matchShapes) {
        var shape = item.toShape(false);
        if (shape) return exportShape(shape, options);
      }

      var segments = item._segments,
          length = segments.length,
          type,
          attrs = getTransform(item._matrix);

      if (matchShapes && length >= 2 && !item.hasHandles()) {
        if (length > 2) {
          type = item._closed ? 'polygon' : 'polyline';
          var parts = [];

          for (var i = 0; i < length; i++) {
            parts.push(formatter.point(segments[i]._point));
          }

          attrs.points = parts.join(' ');
        } else {
          type = 'line';
          var start = segments[0]._point,
              end = segments[1]._point;
          attrs.set({
            x1: start.x,
            y1: start.y,
            x2: end.x,
            y2: end.y
          });
        }
      } else {
        type = 'path';
        attrs.d = item.getPathData(null, options.precision);
      }

      return SvgElement.create(type, attrs, formatter);
    }

    function exportShape(item) {
      var type = item._type,
          radius = item._radius,
          attrs = getTransform(item._matrix, true, type !== 'rectangle');

      if (type === 'rectangle') {
        type = 'rect';
        var size = item._size,
            width = size.width,
            height = size.height;
        attrs.x -= width / 2;
        attrs.y -= height / 2;
        attrs.width = width;
        attrs.height = height;
        if (radius.isZero()) radius = null;
      }

      if (radius) {
        if (type === 'circle') {
          attrs.r = radius;
        } else {
          attrs.rx = radius.width;
          attrs.ry = radius.height;
        }
      }

      return SvgElement.create(type, attrs, formatter);
    }

    function exportCompoundPath(item, options) {
      var attrs = getTransform(item._matrix);
      var data = item.getPathData(null, options.precision);
      if (data) attrs.d = data;
      return SvgElement.create('path', attrs, formatter);
    }

    function exportSymbolItem(item, options) {
      var attrs = getTransform(item._matrix, true),
          definition = item._definition,
          node = getDefinition(definition, 'symbol'),
          definitionItem = definition._item,
          bounds = definitionItem.getStrokeBounds();

      if (!node) {
        node = SvgElement.create('symbol', {
          viewBox: formatter.rectangle(bounds)
        });
        node.appendChild(exportSVG(definitionItem, options));
        setDefinition(definition, node, 'symbol');
      }

      attrs.href = '#' + node.id;
      attrs.x += bounds.x;
      attrs.y += bounds.y;
      attrs.width = bounds.width;
      attrs.height = bounds.height;
      attrs.overflow = 'visible';
      return SvgElement.create('use', attrs, formatter);
    }

    function exportGradient(color) {
      var gradientNode = getDefinition(color, 'color');

      if (!gradientNode) {
        var gradient = color.getGradient(),
            radial = gradient._radial,
            origin = color.getOrigin(),
            destination = color.getDestination(),
            attrs;

        if (radial) {
          attrs = {
            cx: origin.x,
            cy: origin.y,
            r: origin.getDistance(destination)
          };
          var highlight = color.getHighlight();

          if (highlight) {
            attrs.fx = highlight.x;
            attrs.fy = highlight.y;
          }
        } else {
          attrs = {
            x1: origin.x,
            y1: origin.y,
            x2: destination.x,
            y2: destination.y
          };
        }

        attrs.gradientUnits = 'userSpaceOnUse';
        gradientNode = SvgElement.create((radial ? 'radial' : 'linear') + 'Gradient', attrs, formatter);
        var stops = gradient._stops;

        for (var i = 0, l = stops.length; i < l; i++) {
          var stop = stops[i],
              stopColor = stop._color,
              alpha = stopColor.getAlpha(),
              offset = stop._offset;
          attrs = {
            offset: offset == null ? i / (l - 1) : offset
          };
          if (stopColor) attrs['stop-color'] = stopColor.toCSS(true);
          if (alpha < 1) attrs['stop-opacity'] = alpha;
          gradientNode.appendChild(SvgElement.create('stop', attrs, formatter));
        }

        setDefinition(color, gradientNode, 'color');
      }

      return 'url(#' + gradientNode.id + ')';
    }

    function exportText(item) {
      var node = SvgElement.create('text', getTransform(item._matrix, true), formatter);
      node.textContent = item._content;
      return node;
    }

    var exporters = {
      Group: exportGroup,
      Layer: exportGroup,
      Raster: exportRaster,
      Path: exportPath,
      Shape: exportShape,
      CompoundPath: exportCompoundPath,
      SymbolItem: exportSymbolItem,
      PointText: exportText
    };

    function applyStyle(item, node, isRoot) {
      var attrs = {},
          parent = !isRoot && item.getParent(),
          style = [];
      if (item._name != null) attrs.id = item._name;
      Base.each(SvgStyles, function (entry) {
        var get = entry.get,
            type = entry.type,
            value = item[get]();

        if (entry.exportFilter ? entry.exportFilter(item, value) : !parent || !Base.equals(parent[get](), value)) {
          if (type === 'color' && value != null) {
            var alpha = value.getAlpha();
            if (alpha < 1) attrs[entry.attribute + '-opacity'] = alpha;
          }

          if (type === 'style') {
            style.push(entry.attribute + ': ' + value);
          } else {
            attrs[entry.attribute] = value == null ? 'none' : type === 'color' ? value.gradient ? exportGradient(value, item) : value.toCSS(true) : type === 'array' ? value.join(',') : type === 'lookup' ? entry.toSVG[value] : value;
          }
        }
      });
      if (style.length) attrs.style = style.join(';');
      if (attrs.opacity === 1) delete attrs.opacity;
      if (!item._visible) attrs.visibility = 'hidden';
      return SvgElement.set(node, attrs, formatter);
    }

    var definitions;

    function getDefinition(item, type) {
      if (!definitions) definitions = {
        ids: {},
        svgs: {}
      };
      return item && definitions.svgs[type + '-' + (item._id || item.__id || (item.__id = UID.get('svg')))];
    }

    function setDefinition(item, node, type) {
      if (!definitions) getDefinition();
      var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
      node.id = type + '-' + typeId;
      definitions.svgs[type + '-' + (item._id || item.__id)] = node;
    }

    function exportDefinitions(node, options) {
      var svg = node,
          defs = null;

      if (definitions) {
        svg = node.nodeName.toLowerCase() === 'svg' && node;

        for (var i in definitions.svgs) {
          if (!defs) {
            if (!svg) {
              svg = SvgElement.create('svg');
              svg.appendChild(node);
            }

            defs = svg.insertBefore(SvgElement.create('defs'), svg.firstChild);
          }

          defs.appendChild(definitions.svgs[i]);
        }

        definitions = null;
      }

      return options.asString ? new self.XMLSerializer().serializeToString(svg) : svg;
    }

    function exportSVG(item, options, isRoot) {
      var exporter = exporters[item._class],
          node = exporter && exporter(item, options);

      if (node) {
        var onExport = options.onExport;
        if (onExport) node = onExport(item, node, options) || node;
        var data = JSON.stringify(item._data);
        if (data && data !== '{}' && data !== 'null') node.setAttribute('data-paper-data', data);
      }

      return node && applyStyle(item, node, isRoot);
    }

    function setOptions(options) {
      if (!options) options = {};
      formatter = new Formatter(options.precision);
      return options;
    }

    Item.inject({
      exportSVG: function (options) {
        options = setOptions(options);
        return exportDefinitions(exportSVG(this, options, true), options);
      }
    });
    Project.inject({
      exportSVG: function (options) {
        options = setOptions(options);
        var children = this._children,
            view = this.getView(),
            bounds = Base.pick(options.bounds, 'view'),
            mx = options.matrix || bounds === 'view' && view._matrix,
            matrix = mx && Matrix.read([mx]),
            rect = bounds === 'view' ? new Rectangle([0, 0], view.getViewSize()) : bounds === 'content' ? Item._getBounds(children, matrix, {
          stroke: true
        }).rect : Rectangle.read([bounds], 0, {
          readNull: true
        }),
            attrs = {
          version: '1.1',
          xmlns: SvgElement.svg,
          'xmlns:xlink': SvgElement.xlink
        };

        if (rect) {
          attrs.width = rect.width;
          attrs.height = rect.height;
          if (rect.x || rect.x === 0 || rect.y || rect.y === 0) attrs.viewBox = formatter.rectangle(rect);
        }

        var node = SvgElement.create('svg', attrs, formatter),
            parent = node;

        if (matrix && !matrix.isIdentity()) {
          parent = node.appendChild(SvgElement.create('g', getTransform(matrix), formatter));
        }

        for (var i = 0, l = children.length; i < l; i++) {
          parent.appendChild(exportSVG(children[i], options, true));
        }

        return exportDefinitions(node, options);
      }
    });
  }();
  new function () {
    var definitions = {},
        rootSize;

    function getValue(node, name, isString, allowNull, allowPercent, defaultValue) {
      var value = SvgElement.get(node, name) || defaultValue,
          res = value == null ? allowNull ? null : isString ? '' : 0 : isString ? value : parseFloat(value);
      return /%\s*$/.test(value) ? res / 100 * (allowPercent ? 1 : rootSize[/x|^width/.test(name) ? 'width' : 'height']) : res;
    }

    function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {
      x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);
      y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);
      return allowNull && (x == null || y == null) ? null : new Point(x, y);
    }

    function getSize(node, w, h, allowNull, allowPercent) {
      w = getValue(node, w || 'width', false, allowNull, allowPercent);
      h = getValue(node, h || 'height', false, allowNull, allowPercent);
      return allowNull && (w == null || h == null) ? null : new Size(w, h);
    }

    function convertValue(value, type, lookup) {
      return value === 'none' ? null : type === 'number' ? parseFloat(value) : type === 'array' ? value ? value.split(/[\s,]+/g).map(parseFloat) : [] : type === 'color' ? getDefinition(value) || value : type === 'lookup' ? lookup[value] : value;
    }

    function importGroup(node, type, options, isRoot) {
      var nodes = node.childNodes,
          isClip = type === 'clippath',
          isDefs = type === 'defs',
          item = new Group(),
          project = item._project,
          currentStyle = project._currentStyle,
          children = [];

      if (!isClip && !isDefs) {
        item = applyAttributes(item, node, isRoot);
        project._currentStyle = item._style.clone();
      }

      if (isRoot) {
        var defs = node.querySelectorAll('defs');

        for (var i = 0, l = defs.length; i < l; i++) {
          importNode(defs[i], options, false);
        }
      }

      for (var i = 0, l = nodes.length; i < l; i++) {
        var childNode = nodes[i],
            child;
        if (childNode.nodeType === 1 && !/^defs$/i.test(childNode.nodeName) && (child = importNode(childNode, options, false)) && !(child instanceof SymbolDefinition)) children.push(child);
      }

      item.addChildren(children);
      if (isClip) item = applyAttributes(item.reduce(), node, isRoot);
      project._currentStyle = currentStyle;

      if (isClip || isDefs) {
        item.remove();
        item = null;
      }

      return item;
    }

    function importPoly(node, type) {
      var coords = node.getAttribute('points').match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
          points = [];

      for (var i = 0, l = coords.length; i < l; i += 2) points.push(new Point(parseFloat(coords[i]), parseFloat(coords[i + 1])));

      var path = new Path(points);
      if (type === 'polygon') path.closePath();
      return path;
    }

    function importPath(node) {
      return PathItem.create(node.getAttribute('d'));
    }

    function importGradient(node, type) {
      var id = (getValue(node, 'href', true) || '').substring(1),
          radial = type === 'radialgradient',
          gradient;

      if (id) {
        gradient = definitions[id].getGradient();

        if (gradient._radial ^ radial) {
          gradient = gradient.clone();
          gradient._radial = radial;
        }
      } else {
        var nodes = node.childNodes,
            stops = [];

        for (var i = 0, l = nodes.length; i < l; i++) {
          var child = nodes[i];
          if (child.nodeType === 1) stops.push(applyAttributes(new GradientStop(), child));
        }

        gradient = new Gradient(stops, radial);
      }

      var origin,
          destination,
          highlight,
          scaleToBounds = getValue(node, 'gradientUnits', true) !== 'userSpaceOnUse';

      if (radial) {
        origin = getPoint(node, 'cx', 'cy', false, scaleToBounds, '50%', '50%');
        destination = origin.add(getValue(node, 'r', false, false, scaleToBounds, '50%'), 0);
        highlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);
      } else {
        origin = getPoint(node, 'x1', 'y1', false, scaleToBounds, '0%', '0%');
        destination = getPoint(node, 'x2', 'y2', false, scaleToBounds, '100%', '0%');
      }

      var color = applyAttributes(new Color(gradient, origin, destination, highlight), node);
      color._scaleToBounds = scaleToBounds;
      return null;
    }

    var importers = {
      '#document': function (node, type, options, isRoot) {
        var nodes = node.childNodes;

        for (var i = 0, l = nodes.length; i < l; i++) {
          var child = nodes[i];
          if (child.nodeType === 1) return importNode(child, options, isRoot);
        }
      },
      g: importGroup,
      svg: importGroup,
      clippath: importGroup,
      polygon: importPoly,
      polyline: importPoly,
      path: importPath,
      lineargradient: importGradient,
      radialgradient: importGradient,
      image: function (node) {
        var raster = new Raster(getValue(node, 'href', true));
        raster.on('load', function () {
          var size = getSize(node);
          this.setSize(size);
          var center = getPoint(node).add(size.divide(2));

          this._matrix.append(new Matrix().translate(center));
        });
        return raster;
      },
      symbol: function (node, type, options, isRoot) {
        return new SymbolDefinition(importGroup(node, type, options, isRoot), true);
      },
      defs: importGroup,
      use: function (node) {
        var id = (getValue(node, 'href', true) || '').substring(1),
            definition = definitions[id],
            point = getPoint(node);
        return definition ? definition instanceof SymbolDefinition ? definition.place(point) : definition.clone().translate(point) : null;
      },
      circle: function (node) {
        return new Shape.Circle(getPoint(node, 'cx', 'cy'), getValue(node, 'r'));
      },
      ellipse: function (node) {
        return new Shape.Ellipse({
          center: getPoint(node, 'cx', 'cy'),
          radius: getSize(node, 'rx', 'ry')
        });
      },
      rect: function (node) {
        return new Shape.Rectangle(new Rectangle(getPoint(node), getSize(node)), getSize(node, 'rx', 'ry'));
      },
      line: function (node) {
        return new Path.Line(getPoint(node, 'x1', 'y1'), getPoint(node, 'x2', 'y2'));
      },
      text: function (node) {
        var text = new PointText(getPoint(node).add(getPoint(node, 'dx', 'dy')));
        text.setContent(node.textContent.trim() || '');
        return text;
      },
      switch: importGroup
    };

    function applyTransform(item, value, name, node) {
      if (item.transform) {
        var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
            matrix = new Matrix();

        for (var i = 0, l = transforms.length; i < l; i++) {
          var transform = transforms[i];
          if (!transform) break;
          var parts = transform.split(/\(\s*/),
              command = parts[0],
              v = parts[1].split(/[\s,]+/g);

          for (var j = 0, m = v.length; j < m; j++) v[j] = parseFloat(v[j]);

          switch (command) {
            case 'matrix':
              matrix.append(new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
              break;

            case 'rotate':
              matrix.rotate(v[0], v[1] || 0, v[2] || 0);
              break;

            case 'translate':
              matrix.translate(v[0], v[1] || 0);
              break;

            case 'scale':
              matrix.scale(v);
              break;

            case 'skewX':
              matrix.skew(v[0], 0);
              break;

            case 'skewY':
              matrix.skew(0, v[0]);
              break;
          }
        }

        item.transform(matrix);
      }
    }

    function applyOpacity(item, value, name) {
      var key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',
          color = item[key] && item[key]();
      if (color) color.setAlpha(parseFloat(value));
    }

    var attributes = Base.set(Base.each(SvgStyles, function (entry) {
      this[entry.attribute] = function (item, value) {
        if (item[entry.set]) {
          item[entry.set](convertValue(value, entry.type, entry.fromSVG));

          if (entry.type === 'color') {
            var color = item[entry.get]();

            if (color) {
              if (color._scaleToBounds) {
                var bounds = item.getBounds();
                color.transform(new Matrix().translate(bounds.getPoint()).scale(bounds.getSize()));
              }
            }
          }
        }
      };
    }, {}), {
      id: function (item, value) {
        definitions[value] = item;
        if (item.setName) item.setName(value);
      },
      'clip-path': function (item, value) {
        var clip = getDefinition(value);

        if (clip) {
          clip = clip.clone();
          clip.setClipMask(true);

          if (item instanceof Group) {
            item.insertChild(0, clip);
          } else {
            return new Group(clip, item);
          }
        }
      },
      gradientTransform: applyTransform,
      transform: applyTransform,
      'fill-opacity': applyOpacity,
      'stroke-opacity': applyOpacity,
      visibility: function (item, value) {
        if (item.setVisible) item.setVisible(value === 'visible');
      },
      display: function (item, value) {
        if (item.setVisible) item.setVisible(value !== null);
      },
      'stop-color': function (item, value) {
        if (item.setColor) item.setColor(value);
      },
      'stop-opacity': function (item, value) {
        if (item._color) item._color.setAlpha(parseFloat(value));
      },
      offset: function (item, value) {
        if (item.setOffset) {
          var percent = value.match(/(.*)%$/);
          item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
        }
      },
      viewBox: function (item, value, name, node, styles) {
        var rect = new Rectangle(convertValue(value, 'array')),
            size = getSize(node, null, null, true),
            group,
            matrix;

        if (item instanceof Group) {
          var scale = size ? size.divide(rect.getSize()) : 1,
              matrix = new Matrix().scale(scale).translate(rect.getPoint().negate());
          group = item;
        } else if (item instanceof SymbolDefinition) {
          if (size) rect.setSize(size);
          group = item._item;
        }

        if (group) {
          if (getAttribute(node, 'overflow', styles) !== 'visible') {
            var clip = new Shape.Rectangle(rect);
            clip.setClipMask(true);
            group.addChild(clip);
          }

          if (matrix) group.transform(matrix);
        }
      }
    });

    function getAttribute(node, name, styles) {
      var attr = node.attributes[name],
          value = attr && attr.value;

      if (!value && node.style) {
        var style = Base.camelize(name);
        value = node.style[style];
        if (!value && styles.node[style] !== styles.parent[style]) value = styles.node[style];
      }

      return !value ? undefined : value === 'none' ? null : value;
    }

    function applyAttributes(item, node, isRoot) {
      var parent = node.parentNode,
          styles = {
        node: DomElement.getStyles(node) || {},
        parent: !isRoot && !/^defs$/i.test(parent.tagName) && DomElement.getStyles(parent) || {}
      };
      Base.each(attributes, function (apply, name) {
        var value = getAttribute(node, name, styles);
        item = value !== undefined && apply(item, value, name, node, styles) || item;
      });
      return item;
    }

    function getDefinition(value) {
      var match = value && value.match(/\((?:["'#]*)([^"')]+)/),
          name = match && match[1],
          res = name && definitions[window ? name.replace(window.location.href.split('#')[0] + '#', '') : name];

      if (res && res._scaleToBounds) {
        res = res.clone();
        res._scaleToBounds = true;
      }

      return res;
    }

    function importNode(node, options, isRoot) {
      var type = node.nodeName.toLowerCase(),
          isElement = type !== '#document',
          body = document.body,
          container,
          parent,
          next;

      if (isRoot && isElement) {
        rootSize = paper.getView().getSize();
        rootSize = getSize(node, null, null, true) || rootSize;
        container = SvgElement.create('svg', {
          style: 'stroke-width: 1px; stroke-miterlimit: 10'
        });
        parent = node.parentNode;
        next = node.nextSibling;
        container.appendChild(node);
        body.appendChild(container);
      }

      var settings = paper.settings,
          applyMatrix = settings.applyMatrix,
          insertItems = settings.insertItems;
      settings.applyMatrix = false;
      settings.insertItems = false;
      var importer = importers[type],
          item = importer && importer(node, type, options, isRoot) || null;
      settings.insertItems = insertItems;
      settings.applyMatrix = applyMatrix;

      if (item) {
        if (isElement && !(item instanceof Group)) item = applyAttributes(item, node, isRoot);
        var onImport = options.onImport,
            data = isElement && node.getAttribute('data-paper-data');
        if (onImport) item = onImport(node, item, options) || item;

        if (options.expandShapes && item instanceof Shape) {
          item.remove();
          item = item.toPath();
        }

        if (data) item._data = JSON.parse(data);
      }

      if (container) {
        body.removeChild(container);

        if (parent) {
          if (next) {
            parent.insertBefore(node, next);
          } else {
            parent.appendChild(node);
          }
        }
      }

      if (isRoot) {
        definitions = {};
        if (item && Base.pick(options.applyMatrix, applyMatrix)) item.matrix.apply(true, true);
      }

      return item;
    }

    function importSVG(source, options, owner) {
      if (!source) return null;
      options = typeof options === 'function' ? {
        onLoad: options
      } : options || {};
      var scope = paper,
          item = null;

      function onLoad(svg) {
        try {
          var node = typeof svg === 'object' ? svg : new self.DOMParser().parseFromString(svg.trim(), 'image/svg+xml');

          if (!node.nodeName) {
            node = null;
            throw new Error('Unsupported SVG source: ' + source);
          }

          paper = scope;
          item = importNode(node, options, true);

          if (!options || options.insert !== false) {
            owner._insertItem(undefined, item);
          }

          var onLoad = options.onLoad;
          if (onLoad) onLoad(item, svg);
        } catch (e) {
          onError(e);
        }
      }

      function onError(message, status) {
        var onError = options.onError;

        if (onError) {
          onError(message, status);
        } else {
          throw new Error(message);
        }
      }

      if (typeof source === 'string' && !/^[\s\S]*</.test(source)) {
        var node = document.getElementById(source);

        if (node) {
          onLoad(node);
        } else {
          Http.request({
            url: source,
            async: true,
            onLoad: onLoad,
            onError: onError
          });
        }
      } else if (typeof File !== 'undefined' && source instanceof File) {
        var reader = new FileReader();

        reader.onload = function () {
          onLoad(reader.result);
        };

        reader.onerror = function () {
          onError(reader.error);
        };

        return reader.readAsText(source);
      } else {
        onLoad(source);
      }

      return item;
    }

    Item.inject({
      importSVG: function (node, options) {
        return importSVG(node, options, this);
      }
    });
    Project.inject({
      importSVG: function (node, options) {
        this.activate();
        return importSVG(node, options, this);
      }
    });
  }();

  Base.exports.PaperScript = function () {
    var global = this,
        acorn = global.acorn;

    if (!acorn && "function" !== 'undefined') {
      try {
        acorn = __webpack_require__(/*! acorn */ "./node_modules/acorn/dist/acorn.mjs");
      } catch (e) {}
    }

    if (!acorn) {
      var exports, module;
      acorn = exports = module = {};

      (function (root, mod) {
        if (typeof exports == "object" && typeof module == "object") return mod(exports);
        if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        mod(root.acorn || (root.acorn = {}));
      })(this, function (exports) {
        "use strict";

        exports.version = "0.5.0";
        var options, input, inputLen, sourceFile;

        exports.parse = function (inpt, opts) {
          input = String(inpt);
          inputLen = input.length;
          setOptions(opts);
          initTokenState();
          return parseTopLevel(options.program);
        };

        var defaultOptions = exports.defaultOptions = {
          ecmaVersion: 5,
          strictSemicolons: false,
          allowTrailingCommas: true,
          forbidReserved: false,
          allowReturnOutsideFunction: false,
          locations: false,
          onComment: null,
          ranges: false,
          program: null,
          sourceFile: null,
          directSourceFile: null
        };

        function setOptions(opts) {
          options = opts || {};

          for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt)) options[opt] = defaultOptions[opt];

          sourceFile = options.sourceFile || null;
        }

        var getLineInfo = exports.getLineInfo = function (input, offset) {
          for (var line = 1, cur = 0;;) {
            lineBreak.lastIndex = cur;
            var match = lineBreak.exec(input);

            if (match && match.index < offset) {
              ++line;
              cur = match.index + match[0].length;
            } else break;
          }

          return {
            line: line,
            column: offset - cur
          };
        };

        exports.tokenize = function (inpt, opts) {
          input = String(inpt);
          inputLen = input.length;
          setOptions(opts);
          initTokenState();
          var t = {};

          function getToken(forceRegexp) {
            lastEnd = tokEnd;
            readToken(forceRegexp);
            t.start = tokStart;
            t.end = tokEnd;
            t.startLoc = tokStartLoc;
            t.endLoc = tokEndLoc;
            t.type = tokType;
            t.value = tokVal;
            return t;
          }

          getToken.jumpTo = function (pos, reAllowed) {
            tokPos = pos;

            if (options.locations) {
              tokCurLine = 1;
              tokLineStart = lineBreak.lastIndex = 0;
              var match;

              while ((match = lineBreak.exec(input)) && match.index < pos) {
                ++tokCurLine;
                tokLineStart = match.index + match[0].length;
              }
            }

            tokRegexpAllowed = reAllowed;
            skipSpace();
          };

          return getToken;
        };

        var tokPos;
        var tokStart, tokEnd;
        var tokStartLoc, tokEndLoc;
        var tokType, tokVal;
        var tokRegexpAllowed;
        var tokCurLine, tokLineStart;
        var lastStart, lastEnd, lastEndLoc;
        var inFunction, labels, strict;

        function raise(pos, message) {
          var loc = getLineInfo(input, pos);
          message += " (" + loc.line + ":" + loc.column + ")";
          var err = new SyntaxError(message);
          err.pos = pos;
          err.loc = loc;
          err.raisedAt = tokPos;
          throw err;
        }

        var empty = [];
        var _num = {
          type: "num"
        },
            _regexp = {
          type: "regexp"
        },
            _string = {
          type: "string"
        };
        var _name = {
          type: "name"
        },
            _eof = {
          type: "eof"
        };
        var _break = {
          keyword: "break"
        },
            _case = {
          keyword: "case",
          beforeExpr: true
        },
            _catch = {
          keyword: "catch"
        };
        var _continue = {
          keyword: "continue"
        },
            _debugger = {
          keyword: "debugger"
        },
            _default = {
          keyword: "default"
        };
        var _do = {
          keyword: "do",
          isLoop: true
        },
            _else = {
          keyword: "else",
          beforeExpr: true
        };
        var _finally = {
          keyword: "finally"
        },
            _for = {
          keyword: "for",
          isLoop: true
        },
            _function = {
          keyword: "function"
        };
        var _if = {
          keyword: "if"
        },
            _return = {
          keyword: "return",
          beforeExpr: true
        },
            _switch = {
          keyword: "switch"
        };
        var _throw = {
          keyword: "throw",
          beforeExpr: true
        },
            _try = {
          keyword: "try"
        },
            _var = {
          keyword: "var"
        };
        var _while = {
          keyword: "while",
          isLoop: true
        },
            _with = {
          keyword: "with"
        },
            _new = {
          keyword: "new",
          beforeExpr: true
        };
        var _this = {
          keyword: "this"
        };
        var _null = {
          keyword: "null",
          atomValue: null
        },
            _true = {
          keyword: "true",
          atomValue: true
        };
        var _false = {
          keyword: "false",
          atomValue: false
        };
        var _in = {
          keyword: "in",
          binop: 7,
          beforeExpr: true
        };
        var keywordTypes = {
          "break": _break,
          "case": _case,
          "catch": _catch,
          "continue": _continue,
          "debugger": _debugger,
          "default": _default,
          "do": _do,
          "else": _else,
          "finally": _finally,
          "for": _for,
          "function": _function,
          "if": _if,
          "return": _return,
          "switch": _switch,
          "throw": _throw,
          "try": _try,
          "var": _var,
          "while": _while,
          "with": _with,
          "null": _null,
          "true": _true,
          "false": _false,
          "new": _new,
          "in": _in,
          "instanceof": {
            keyword: "instanceof",
            binop: 7,
            beforeExpr: true
          },
          "this": _this,
          "typeof": {
            keyword: "typeof",
            prefix: true,
            beforeExpr: true
          },
          "void": {
            keyword: "void",
            prefix: true,
            beforeExpr: true
          },
          "delete": {
            keyword: "delete",
            prefix: true,
            beforeExpr: true
          }
        };
        var _bracketL = {
          type: "[",
          beforeExpr: true
        },
            _bracketR = {
          type: "]"
        },
            _braceL = {
          type: "{",
          beforeExpr: true
        };
        var _braceR = {
          type: "}"
        },
            _parenL = {
          type: "(",
          beforeExpr: true
        },
            _parenR = {
          type: ")"
        };
        var _comma = {
          type: ",",
          beforeExpr: true
        },
            _semi = {
          type: ";",
          beforeExpr: true
        };
        var _colon = {
          type: ":",
          beforeExpr: true
        },
            _dot = {
          type: "."
        },
            _question = {
          type: "?",
          beforeExpr: true
        };
        var _slash = {
          binop: 10,
          beforeExpr: true
        },
            _eq = {
          isAssign: true,
          beforeExpr: true
        };
        var _assign = {
          isAssign: true,
          beforeExpr: true
        };
        var _incDec = {
          postfix: true,
          prefix: true,
          isUpdate: true
        },
            _prefix = {
          prefix: true,
          beforeExpr: true
        };
        var _logicalOR = {
          binop: 1,
          beforeExpr: true
        };
        var _logicalAND = {
          binop: 2,
          beforeExpr: true
        };
        var _bitwiseOR = {
          binop: 3,
          beforeExpr: true
        };
        var _bitwiseXOR = {
          binop: 4,
          beforeExpr: true
        };
        var _bitwiseAND = {
          binop: 5,
          beforeExpr: true
        };
        var _equality = {
          binop: 6,
          beforeExpr: true
        };
        var _relational = {
          binop: 7,
          beforeExpr: true
        };
        var _bitShift = {
          binop: 8,
          beforeExpr: true
        };
        var _plusMin = {
          binop: 9,
          prefix: true,
          beforeExpr: true
        };
        var _multiplyModulo = {
          binop: 10,
          beforeExpr: true
        };
        exports.tokTypes = {
          bracketL: _bracketL,
          bracketR: _bracketR,
          braceL: _braceL,
          braceR: _braceR,
          parenL: _parenL,
          parenR: _parenR,
          comma: _comma,
          semi: _semi,
          colon: _colon,
          dot: _dot,
          question: _question,
          slash: _slash,
          eq: _eq,
          name: _name,
          eof: _eof,
          num: _num,
          regexp: _regexp,
          string: _string
        };

        for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

        function makePredicate(words) {
          words = words.split(" ");
          var f = "",
              cats = [];

          out: for (var i = 0; i < words.length; ++i) {
            for (var j = 0; j < cats.length; ++j) if (cats[j][0].length == words[i].length) {
              cats[j].push(words[i]);
              continue out;
            }

            cats.push([words[i]]);
          }

          function compareTo(arr) {
            if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
            f += "switch(str){";

            for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";

            f += "return true}return false;";
          }

          if (cats.length > 3) {
            cats.sort(function (a, b) {
              return b.length - a.length;
            });
            f += "switch(str.length){";

            for (var i = 0; i < cats.length; ++i) {
              var cat = cats[i];
              f += "case " + cat[0].length + ":";
              compareTo(cat);
            }

            f += "}";
          } else {
            compareTo(words);
          }

          return new Function("str", f);
        }

        var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");
        var isReservedWord5 = makePredicate("class enum extends super const export import");
        var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");
        var isStrictBadIdWord = makePredicate("eval arguments");
        var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");
        var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
        var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
        var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        var newline = /[\n\r\u2028\u2029]/;
        var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

        var isIdentifierStart = exports.isIdentifierStart = function (code) {
          if (code < 65) return code === 36;
          if (code < 91) return true;
          if (code < 97) return code === 95;
          if (code < 123) return true;
          return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
        };

        var isIdentifierChar = exports.isIdentifierChar = function (code) {
          if (code < 48) return code === 36;
          if (code < 58) return true;
          if (code < 65) return false;
          if (code < 91) return true;
          if (code < 97) return code === 95;
          if (code < 123) return true;
          return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
        };

        function line_loc_t() {
          this.line = tokCurLine;
          this.column = tokPos - tokLineStart;
        }

        function initTokenState() {
          tokCurLine = 1;
          tokPos = tokLineStart = 0;
          tokRegexpAllowed = true;
          skipSpace();
        }

        function finishToken(type, val) {
          tokEnd = tokPos;
          if (options.locations) tokEndLoc = new line_loc_t();
          tokType = type;
          skipSpace();
          tokVal = val;
          tokRegexpAllowed = type.beforeExpr;
        }

        function skipBlockComment() {
          var startLoc = options.onComment && options.locations && new line_loc_t();
          var start = tokPos,
              end = input.indexOf("*/", tokPos += 2);
          if (end === -1) raise(tokPos - 2, "Unterminated comment");
          tokPos = end + 2;

          if (options.locations) {
            lineBreak.lastIndex = start;
            var match;

            while ((match = lineBreak.exec(input)) && match.index < tokPos) {
              ++tokCurLine;
              tokLineStart = match.index + match[0].length;
            }
          }

          if (options.onComment) options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new line_loc_t());
        }

        function skipLineComment() {
          var start = tokPos;
          var startLoc = options.onComment && options.locations && new line_loc_t();
          var ch = input.charCodeAt(tokPos += 2);

          while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
            ++tokPos;
            ch = input.charCodeAt(tokPos);
          }

          if (options.onComment) options.onComment(false, input.slice(start + 2, tokPos), start, tokPos, startLoc, options.locations && new line_loc_t());
        }

        function skipSpace() {
          while (tokPos < inputLen) {
            var ch = input.charCodeAt(tokPos);

            if (ch === 32) {
              ++tokPos;
            } else if (ch === 13) {
              ++tokPos;
              var next = input.charCodeAt(tokPos);

              if (next === 10) {
                ++tokPos;
              }

              if (options.locations) {
                ++tokCurLine;
                tokLineStart = tokPos;
              }
            } else if (ch === 10 || ch === 8232 || ch === 8233) {
              ++tokPos;

              if (options.locations) {
                ++tokCurLine;
                tokLineStart = tokPos;
              }
            } else if (ch > 8 && ch < 14) {
              ++tokPos;
            } else if (ch === 47) {
              var next = input.charCodeAt(tokPos + 1);

              if (next === 42) {
                skipBlockComment();
              } else if (next === 47) {
                skipLineComment();
              } else break;
            } else if (ch === 160) {
              ++tokPos;
            } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
              ++tokPos;
            } else {
              break;
            }
          }
        }

        function readToken_dot() {
          var next = input.charCodeAt(tokPos + 1);
          if (next >= 48 && next <= 57) return readNumber(true);
          ++tokPos;
          return finishToken(_dot);
        }

        function readToken_slash() {
          var next = input.charCodeAt(tokPos + 1);

          if (tokRegexpAllowed) {
            ++tokPos;
            return readRegexp();
          }

          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_slash, 1);
        }

        function readToken_mult_modulo() {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_multiplyModulo, 1);
        }

        function readToken_pipe_amp(code) {
          var next = input.charCodeAt(tokPos + 1);
          if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
        }

        function readToken_caret() {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_bitwiseXOR, 1);
        }

        function readToken_plus_min(code) {
          var next = input.charCodeAt(tokPos + 1);

          if (next === code) {
            if (next == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd, tokPos))) {
              tokPos += 3;
              skipLineComment();
              skipSpace();
              return readToken();
            }

            return finishOp(_incDec, 2);
          }

          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_plusMin, 1);
        }

        function readToken_lt_gt(code) {
          var next = input.charCodeAt(tokPos + 1);
          var size = 1;

          if (next === code) {
            size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
            if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
            return finishOp(_bitShift, size);
          }

          if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45) {
            tokPos += 4;
            skipLineComment();
            skipSpace();
            return readToken();
          }

          if (next === 61) size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
          return finishOp(_relational, size);
        }

        function readToken_eq_excl(code) {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
          return finishOp(code === 61 ? _eq : _prefix, 1);
        }

        function getTokenFromCode(code) {
          switch (code) {
            case 46:
              return readToken_dot();

            case 40:
              ++tokPos;
              return finishToken(_parenL);

            case 41:
              ++tokPos;
              return finishToken(_parenR);

            case 59:
              ++tokPos;
              return finishToken(_semi);

            case 44:
              ++tokPos;
              return finishToken(_comma);

            case 91:
              ++tokPos;
              return finishToken(_bracketL);

            case 93:
              ++tokPos;
              return finishToken(_bracketR);

            case 123:
              ++tokPos;
              return finishToken(_braceL);

            case 125:
              ++tokPos;
              return finishToken(_braceR);

            case 58:
              ++tokPos;
              return finishToken(_colon);

            case 63:
              ++tokPos;
              return finishToken(_question);

            case 48:
              var next = input.charCodeAt(tokPos + 1);
              if (next === 120 || next === 88) return readHexNumber();

            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return readNumber(false);

            case 34:
            case 39:
              return readString(code);

            case 47:
              return readToken_slash(code);

            case 37:
            case 42:
              return readToken_mult_modulo();

            case 124:
            case 38:
              return readToken_pipe_amp(code);

            case 94:
              return readToken_caret();

            case 43:
            case 45:
              return readToken_plus_min(code);

            case 60:
            case 62:
              return readToken_lt_gt(code);

            case 61:
            case 33:
              return readToken_eq_excl(code);

            case 126:
              return finishOp(_prefix, 1);
          }

          return false;
        }

        function readToken(forceRegexp) {
          if (!forceRegexp) tokStart = tokPos;else tokPos = tokStart + 1;
          if (options.locations) tokStartLoc = new line_loc_t();
          if (forceRegexp) return readRegexp();
          if (tokPos >= inputLen) return finishToken(_eof);
          var code = input.charCodeAt(tokPos);
          if (isIdentifierStart(code) || code === 92) return readWord();
          var tok = getTokenFromCode(code);

          if (tok === false) {
            var ch = String.fromCharCode(code);
            if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
            raise(tokPos, "Unexpected character '" + ch + "'");
          }

          return tok;
        }

        function finishOp(type, size) {
          var str = input.slice(tokPos, tokPos + size);
          tokPos += size;
          finishToken(type, str);
        }

        function readRegexp() {
          var content = "",
              escaped,
              inClass,
              start = tokPos;

          for (;;) {
            if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
            var ch = input.charAt(tokPos);
            if (newline.test(ch)) raise(start, "Unterminated regular expression");

            if (!escaped) {
              if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
              escaped = ch === "\\";
            } else escaped = false;

            ++tokPos;
          }

          var content = input.slice(start, tokPos);
          ++tokPos;
          var mods = readWord1();
          if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");

          try {
            var value = new RegExp(content, mods);
          } catch (e) {
            if (e instanceof SyntaxError) raise(start, e.message);
            raise(e);
          }

          return finishToken(_regexp, value);
        }

        function readInt(radix, len) {
          var start = tokPos,
              total = 0;

          for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
            var code = input.charCodeAt(tokPos),
                val;
            if (code >= 97) val = code - 97 + 10;else if (code >= 65) val = code - 65 + 10;else if (code >= 48 && code <= 57) val = code - 48;else val = Infinity;
            if (val >= radix) break;
            ++tokPos;
            total = total * radix + val;
          }

          if (tokPos === start || len != null && tokPos - start !== len) return null;
          return total;
        }

        function readHexNumber() {
          tokPos += 2;
          var val = readInt(16);
          if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
          if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
          return finishToken(_num, val);
        }

        function readNumber(startsWithDot) {
          var start = tokPos,
              isFloat = false,
              octal = input.charCodeAt(tokPos) === 48;
          if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");

          if (input.charCodeAt(tokPos) === 46) {
            ++tokPos;
            readInt(10);
            isFloat = true;
          }

          var next = input.charCodeAt(tokPos);

          if (next === 69 || next === 101) {
            next = input.charCodeAt(++tokPos);
            if (next === 43 || next === 45) ++tokPos;
            if (readInt(10) === null) raise(start, "Invalid number");
            isFloat = true;
          }

          if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
          var str = input.slice(start, tokPos),
              val;
          if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || strict) raise(start, "Invalid number");else val = parseInt(str, 8);
          return finishToken(_num, val);
        }

        function readString(quote) {
          tokPos++;
          var out = "";

          for (;;) {
            if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
            var ch = input.charCodeAt(tokPos);

            if (ch === quote) {
              ++tokPos;
              return finishToken(_string, out);
            }

            if (ch === 92) {
              ch = input.charCodeAt(++tokPos);
              var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
              if (octal) octal = octal[0];

              while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);

              if (octal === "0") octal = null;
              ++tokPos;

              if (octal) {
                if (strict) raise(tokPos - 2, "Octal literal in strict mode");
                out += String.fromCharCode(parseInt(octal, 8));
                tokPos += octal.length - 1;
              } else {
                switch (ch) {
                  case 110:
                    out += "\n";
                    break;

                  case 114:
                    out += "\r";
                    break;

                  case 120:
                    out += String.fromCharCode(readHexChar(2));
                    break;

                  case 117:
                    out += String.fromCharCode(readHexChar(4));
                    break;

                  case 85:
                    out += String.fromCharCode(readHexChar(8));
                    break;

                  case 116:
                    out += "\t";
                    break;

                  case 98:
                    out += "\b";
                    break;

                  case 118:
                    out += "\u000b";
                    break;

                  case 102:
                    out += "\f";
                    break;

                  case 48:
                    out += "\0";
                    break;

                  case 13:
                    if (input.charCodeAt(tokPos) === 10) ++tokPos;

                  case 10:
                    if (options.locations) {
                      tokLineStart = tokPos;
                      ++tokCurLine;
                    }

                    break;

                  default:
                    out += String.fromCharCode(ch);
                    break;
                }
              }
            } else {
              if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, "Unterminated string constant");
              out += String.fromCharCode(ch);
              ++tokPos;
            }
          }
        }

        function readHexChar(len) {
          var n = readInt(16, len);
          if (n === null) raise(tokStart, "Bad character escape sequence");
          return n;
        }

        var containsEsc;

        function readWord1() {
          containsEsc = false;
          var word,
              first = true,
              start = tokPos;

          for (;;) {
            var ch = input.charCodeAt(tokPos);

            if (isIdentifierChar(ch)) {
              if (containsEsc) word += input.charAt(tokPos);
              ++tokPos;
            } else if (ch === 92) {
              if (!containsEsc) word = input.slice(start, tokPos);
              containsEsc = true;
              if (input.charCodeAt(++tokPos) != 117) raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
              ++tokPos;
              var esc = readHexChar(4);
              var escStr = String.fromCharCode(esc);
              if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
              if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) raise(tokPos - 4, "Invalid Unicode escape");
              word += escStr;
            } else {
              break;
            }

            first = false;
          }

          return containsEsc ? word : input.slice(start, tokPos);
        }

        function readWord() {
          var word = readWord1();
          var type = _name;
          if (!containsEsc && isKeyword(word)) type = keywordTypes[word];
          return finishToken(type, word);
        }

        function next() {
          lastStart = tokStart;
          lastEnd = tokEnd;
          lastEndLoc = tokEndLoc;
          readToken();
        }

        function setStrict(strct) {
          strict = strct;
          tokPos = tokStart;

          if (options.locations) {
            while (tokPos < tokLineStart) {
              tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
              --tokCurLine;
            }
          }

          skipSpace();
          readToken();
        }

        function node_t() {
          this.type = null;
          this.start = tokStart;
          this.end = null;
        }

        function node_loc_t() {
          this.start = tokStartLoc;
          this.end = null;
          if (sourceFile !== null) this.source = sourceFile;
        }

        function startNode() {
          var node = new node_t();
          if (options.locations) node.loc = new node_loc_t();
          if (options.directSourceFile) node.sourceFile = options.directSourceFile;
          if (options.ranges) node.range = [tokStart, 0];
          return node;
        }

        function startNodeFrom(other) {
          var node = new node_t();
          node.start = other.start;

          if (options.locations) {
            node.loc = new node_loc_t();
            node.loc.start = other.loc.start;
          }

          if (options.ranges) node.range = [other.range[0], 0];
          return node;
        }

        function finishNode(node, type) {
          node.type = type;
          node.end = lastEnd;
          if (options.locations) node.loc.end = lastEndLoc;
          if (options.ranges) node.range[1] = lastEnd;
          return node;
        }

        function isUseStrict(stmt) {
          return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
        }

        function eat(type) {
          if (tokType === type) {
            next();
            return true;
          }
        }

        function canInsertSemicolon() {
          return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
        }

        function semicolon() {
          if (!eat(_semi) && !canInsertSemicolon()) unexpected();
        }

        function expect(type) {
          if (tokType === type) next();else unexpected();
        }

        function unexpected() {
          raise(tokStart, "Unexpected token");
        }

        function checkLVal(expr) {
          if (expr.type !== "Identifier" && expr.type !== "MemberExpression") raise(expr.start, "Assigning to rvalue");
          if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name)) raise(expr.start, "Assigning to " + expr.name + " in strict mode");
        }

        function parseTopLevel(program) {
          lastStart = lastEnd = tokPos;
          if (options.locations) lastEndLoc = new line_loc_t();
          inFunction = strict = null;
          labels = [];
          readToken();
          var node = program || startNode(),
              first = true;
          if (!program) node.body = [];

          while (tokType !== _eof) {
            var stmt = parseStatement();
            node.body.push(stmt);
            if (first && isUseStrict(stmt)) setStrict(true);
            first = false;
          }

          return finishNode(node, "Program");
        }

        var loopLabel = {
          kind: "loop"
        },
            switchLabel = {
          kind: "switch"
        };

        function parseStatement() {
          if (tokType === _slash || tokType === _assign && tokVal == "/=") readToken(true);
          var starttype = tokType,
              node = startNode();

          switch (starttype) {
            case _break:
            case _continue:
              next();
              var isBreak = starttype === _break;
              if (eat(_semi) || canInsertSemicolon()) node.label = null;else if (tokType !== _name) unexpected();else {
                node.label = parseIdent();
                semicolon();
              }

              for (var i = 0; i < labels.length; ++i) {
                var lab = labels[i];

                if (node.label == null || lab.name === node.label.name) {
                  if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
                  if (node.label && isBreak) break;
                }
              }

              if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
              return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

            case _debugger:
              next();
              semicolon();
              return finishNode(node, "DebuggerStatement");

            case _do:
              next();
              labels.push(loopLabel);
              node.body = parseStatement();
              labels.pop();
              expect(_while);
              node.test = parseParenExpression();
              semicolon();
              return finishNode(node, "DoWhileStatement");

            case _for:
              next();
              labels.push(loopLabel);
              expect(_parenL);
              if (tokType === _semi) return parseFor(node, null);

              if (tokType === _var) {
                var init = startNode();
                next();
                parseVar(init, true);
                finishNode(init, "VariableDeclaration");
                if (init.declarations.length === 1 && eat(_in)) return parseForIn(node, init);
                return parseFor(node, init);
              }

              var init = parseExpression(false, true);

              if (eat(_in)) {
                checkLVal(init);
                return parseForIn(node, init);
              }

              return parseFor(node, init);

            case _function:
              next();
              return parseFunction(node, true);

            case _if:
              next();
              node.test = parseParenExpression();
              node.consequent = parseStatement();
              node.alternate = eat(_else) ? parseStatement() : null;
              return finishNode(node, "IfStatement");

            case _return:
              if (!inFunction && !options.allowReturnOutsideFunction) raise(tokStart, "'return' outside of function");
              next();
              if (eat(_semi) || canInsertSemicolon()) node.argument = null;else {
                node.argument = parseExpression();
                semicolon();
              }
              return finishNode(node, "ReturnStatement");

            case _switch:
              next();
              node.discriminant = parseParenExpression();
              node.cases = [];
              expect(_braceL);
              labels.push(switchLabel);

              for (var cur, sawDefault; tokType != _braceR;) {
                if (tokType === _case || tokType === _default) {
                  var isCase = tokType === _case;
                  if (cur) finishNode(cur, "SwitchCase");
                  node.cases.push(cur = startNode());
                  cur.consequent = [];
                  next();
                  if (isCase) cur.test = parseExpression();else {
                    if (sawDefault) raise(lastStart, "Multiple default clauses");
                    sawDefault = true;
                    cur.test = null;
                  }
                  expect(_colon);
                } else {
                  if (!cur) unexpected();
                  cur.consequent.push(parseStatement());
                }
              }

              if (cur) finishNode(cur, "SwitchCase");
              next();
              labels.pop();
              return finishNode(node, "SwitchStatement");

            case _throw:
              next();
              if (newline.test(input.slice(lastEnd, tokStart))) raise(lastEnd, "Illegal newline after throw");
              node.argument = parseExpression();
              semicolon();
              return finishNode(node, "ThrowStatement");

            case _try:
              next();
              node.block = parseBlock();
              node.handler = null;

              if (tokType === _catch) {
                var clause = startNode();
                next();
                expect(_parenL);
                clause.param = parseIdent();
                if (strict && isStrictBadIdWord(clause.param.name)) raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
                expect(_parenR);
                clause.guard = null;
                clause.body = parseBlock();
                node.handler = finishNode(clause, "CatchClause");
              }

              node.guardedHandlers = empty;
              node.finalizer = eat(_finally) ? parseBlock() : null;
              if (!node.handler && !node.finalizer) raise(node.start, "Missing catch or finally clause");
              return finishNode(node, "TryStatement");

            case _var:
              next();
              parseVar(node);
              semicolon();
              return finishNode(node, "VariableDeclaration");

            case _while:
              next();
              node.test = parseParenExpression();
              labels.push(loopLabel);
              node.body = parseStatement();
              labels.pop();
              return finishNode(node, "WhileStatement");

            case _with:
              if (strict) raise(tokStart, "'with' in strict mode");
              next();
              node.object = parseParenExpression();
              node.body = parseStatement();
              return finishNode(node, "WithStatement");

            case _braceL:
              return parseBlock();

            case _semi:
              next();
              return finishNode(node, "EmptyStatement");

            default:
              var maybeName = tokVal,
                  expr = parseExpression();

              if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
                for (var i = 0; i < labels.length; ++i) if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");

                var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
                labels.push({
                  name: maybeName,
                  kind: kind
                });
                node.body = parseStatement();
                labels.pop();
                node.label = expr;
                return finishNode(node, "LabeledStatement");
              } else {
                node.expression = expr;
                semicolon();
                return finishNode(node, "ExpressionStatement");
              }

          }
        }

        function parseParenExpression() {
          expect(_parenL);
          var val = parseExpression();
          expect(_parenR);
          return val;
        }

        function parseBlock(allowStrict) {
          var node = startNode(),
              first = true,
              strict = false,
              oldStrict;
          node.body = [];
          expect(_braceL);

          while (!eat(_braceR)) {
            var stmt = parseStatement();
            node.body.push(stmt);

            if (first && allowStrict && isUseStrict(stmt)) {
              oldStrict = strict;
              setStrict(strict = true);
            }

            first = false;
          }

          if (strict && !oldStrict) setStrict(false);
          return finishNode(node, "BlockStatement");
        }

        function parseFor(node, init) {
          node.init = init;
          expect(_semi);
          node.test = tokType === _semi ? null : parseExpression();
          expect(_semi);
          node.update = tokType === _parenR ? null : parseExpression();
          expect(_parenR);
          node.body = parseStatement();
          labels.pop();
          return finishNode(node, "ForStatement");
        }

        function parseForIn(node, init) {
          node.left = init;
          node.right = parseExpression();
          expect(_parenR);
          node.body = parseStatement();
          labels.pop();
          return finishNode(node, "ForInStatement");
        }

        function parseVar(node, noIn) {
          node.declarations = [];
          node.kind = "var";

          for (;;) {
            var decl = startNode();
            decl.id = parseIdent();
            if (strict && isStrictBadIdWord(decl.id.name)) raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
            decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
            node.declarations.push(finishNode(decl, "VariableDeclarator"));
            if (!eat(_comma)) break;
          }

          return node;
        }

        function parseExpression(noComma, noIn) {
          var expr = parseMaybeAssign(noIn);

          if (!noComma && tokType === _comma) {
            var node = startNodeFrom(expr);
            node.expressions = [expr];

            while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));

            return finishNode(node, "SequenceExpression");
          }

          return expr;
        }

        function parseMaybeAssign(noIn) {
          var left = parseMaybeConditional(noIn);

          if (tokType.isAssign) {
            var node = startNodeFrom(left);
            node.operator = tokVal;
            node.left = left;
            next();
            node.right = parseMaybeAssign(noIn);
            checkLVal(left);
            return finishNode(node, "AssignmentExpression");
          }

          return left;
        }

        function parseMaybeConditional(noIn) {
          var expr = parseExprOps(noIn);

          if (eat(_question)) {
            var node = startNodeFrom(expr);
            node.test = expr;
            node.consequent = parseExpression(true);
            expect(_colon);
            node.alternate = parseExpression(true, noIn);
            return finishNode(node, "ConditionalExpression");
          }

          return expr;
        }

        function parseExprOps(noIn) {
          return parseExprOp(parseMaybeUnary(), -1, noIn);
        }

        function parseExprOp(left, minPrec, noIn) {
          var prec = tokType.binop;

          if (prec != null && (!noIn || tokType !== _in)) {
            if (prec > minPrec) {
              var node = startNodeFrom(left);
              node.left = left;
              node.operator = tokVal;
              var op = tokType;
              next();
              node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
              var exprNode = finishNode(node, op === _logicalOR || op === _logicalAND ? "LogicalExpression" : "BinaryExpression");
              return parseExprOp(exprNode, minPrec, noIn);
            }
          }

          return left;
        }

        function parseMaybeUnary() {
          if (tokType.prefix) {
            var node = startNode(),
                update = tokType.isUpdate;
            node.operator = tokVal;
            node.prefix = true;
            tokRegexpAllowed = true;
            next();
            node.argument = parseMaybeUnary();
            if (update) checkLVal(node.argument);else if (strict && node.operator === "delete" && node.argument.type === "Identifier") raise(node.start, "Deleting local variable in strict mode");
            return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
          }

          var expr = parseExprSubscripts();

          while (tokType.postfix && !canInsertSemicolon()) {
            var node = startNodeFrom(expr);
            node.operator = tokVal;
            node.prefix = false;
            node.argument = expr;
            checkLVal(expr);
            next();
            expr = finishNode(node, "UpdateExpression");
          }

          return expr;
        }

        function parseExprSubscripts() {
          return parseSubscripts(parseExprAtom());
        }

        function parseSubscripts(base, noCalls) {
          if (eat(_dot)) {
            var node = startNodeFrom(base);
            node.object = base;
            node.property = parseIdent(true);
            node.computed = false;
            return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
          } else if (eat(_bracketL)) {
            var node = startNodeFrom(base);
            node.object = base;
            node.property = parseExpression();
            node.computed = true;
            expect(_bracketR);
            return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
          } else if (!noCalls && eat(_parenL)) {
            var node = startNodeFrom(base);
            node.callee = base;
            node.arguments = parseExprList(_parenR, false);
            return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
          } else return base;
        }

        function parseExprAtom() {
          switch (tokType) {
            case _this:
              var node = startNode();
              next();
              return finishNode(node, "ThisExpression");

            case _name:
              return parseIdent();

            case _num:
            case _string:
            case _regexp:
              var node = startNode();
              node.value = tokVal;
              node.raw = input.slice(tokStart, tokEnd);
              next();
              return finishNode(node, "Literal");

            case _null:
            case _true:
            case _false:
              var node = startNode();
              node.value = tokType.atomValue;
              node.raw = tokType.keyword;
              next();
              return finishNode(node, "Literal");

            case _parenL:
              var tokStartLoc1 = tokStartLoc,
                  tokStart1 = tokStart;
              next();
              var val = parseExpression();
              val.start = tokStart1;
              val.end = tokEnd;

              if (options.locations) {
                val.loc.start = tokStartLoc1;
                val.loc.end = tokEndLoc;
              }

              if (options.ranges) val.range = [tokStart1, tokEnd];
              expect(_parenR);
              return val;

            case _bracketL:
              var node = startNode();
              next();
              node.elements = parseExprList(_bracketR, true, true);
              return finishNode(node, "ArrayExpression");

            case _braceL:
              return parseObj();

            case _function:
              var node = startNode();
              next();
              return parseFunction(node, false);

            case _new:
              return parseNew();

            default:
              unexpected();
          }
        }

        function parseNew() {
          var node = startNode();
          next();
          node.callee = parseSubscripts(parseExprAtom(), true);
          if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);else node.arguments = empty;
          return finishNode(node, "NewExpression");
        }

        function parseObj() {
          var node = startNode(),
              first = true,
              sawGetSet = false;
          node.properties = [];
          next();

          while (!eat(_braceR)) {
            if (!first) {
              expect(_comma);
              if (options.allowTrailingCommas && eat(_braceR)) break;
            } else first = false;

            var prop = {
              key: parsePropertyName()
            },
                isGetSet = false,
                kind;

            if (eat(_colon)) {
              prop.value = parseExpression(true);
              kind = prop.kind = "init";
            } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set")) {
              isGetSet = sawGetSet = true;
              kind = prop.kind = prop.key.name;
              prop.key = parsePropertyName();
              if (tokType !== _parenL) unexpected();
              prop.value = parseFunction(startNode(), false);
            } else unexpected();

            if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
              for (var i = 0; i < node.properties.length; ++i) {
                var other = node.properties[i];

                if (other.key.name === prop.key.name) {
                  var conflict = kind == other.kind || isGetSet && other.kind === "init" || kind === "init" && (other.kind === "get" || other.kind === "set");
                  if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
                  if (conflict) raise(prop.key.start, "Redefinition of property");
                }
              }
            }

            node.properties.push(prop);
          }

          return finishNode(node, "ObjectExpression");
        }

        function parsePropertyName() {
          if (tokType === _num || tokType === _string) return parseExprAtom();
          return parseIdent(true);
        }

        function parseFunction(node, isStatement) {
          if (tokType === _name) node.id = parseIdent();else if (isStatement) unexpected();else node.id = null;
          node.params = [];
          var first = true;
          expect(_parenL);

          while (!eat(_parenR)) {
            if (!first) expect(_comma);else first = false;
            node.params.push(parseIdent());
          }

          var oldInFunc = inFunction,
              oldLabels = labels;
          inFunction = true;
          labels = [];
          node.body = parseBlock(true);
          inFunction = oldInFunc;
          labels = oldLabels;

          if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
            for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
              var id = i < 0 ? node.id : node.params[i];
              if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name)) raise(id.start, "Defining '" + id.name + "' in strict mode");
              if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name) raise(id.start, "Argument name clash in strict mode");
            }
          }

          return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
        }

        function parseExprList(close, allowTrailingComma, allowEmpty) {
          var elts = [],
              first = true;

          while (!eat(close)) {
            if (!first) {
              expect(_comma);
              if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
            } else first = false;

            if (allowEmpty && tokType === _comma) elts.push(null);else elts.push(parseExpression(true));
          }

          return elts;
        }

        function parseIdent(liberal) {
          var node = startNode();
          if (liberal && options.forbidReserved == "everywhere") liberal = false;

          if (tokType === _name) {
            if (!liberal && (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) || strict && isStrictReservedWord(tokVal)) && input.slice(tokStart, tokEnd).indexOf("\\") == -1) raise(tokStart, "The keyword '" + tokVal + "' is reserved");
            node.name = tokVal;
          } else if (liberal && tokType.keyword) {
            node.name = tokType.keyword;
          } else {
            unexpected();
          }

          tokRegexpAllowed = false;
          next();
          return finishNode(node, "Identifier");
        }
      });

      if (!acorn.version) acorn = null;
    }

    function parse(code, options) {
      return (global.acorn || acorn).parse(code, options);
    }

    var binaryOperators = {
      '+': '__add',
      '-': '__subtract',
      '*': '__multiply',
      '/': '__divide',
      '%': '__modulo',
      '==': '__equals',
      '!=': '__equals'
    };
    var unaryOperators = {
      '-': '__negate',
      '+': '__self'
    };
    var fields = Base.each(['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'], function (name) {
      this['__' + name] = '#' + name;
    }, {
      __self: function () {
        return this;
      }
    });
    Point.inject(fields);
    Size.inject(fields);
    Color.inject(fields);

    function __$__(left, operator, right) {
      var handler = binaryOperators[operator];

      if (left && left[handler]) {
        var res = left[handler](right);
        return operator === '!=' ? !res : res;
      }

      switch (operator) {
        case '+':
          return left + right;

        case '-':
          return left - right;

        case '*':
          return left * right;

        case '/':
          return left / right;

        case '%':
          return left % right;

        case '==':
          return left == right;

        case '!=':
          return left != right;
      }
    }

    function $__(operator, value) {
      var handler = unaryOperators[operator];
      if (value && value[handler]) return value[handler]();

      switch (operator) {
        case '+':
          return +value;

        case '-':
          return -value;
      }
    }

    function compile(code, options) {
      if (!code) return '';
      options = options || {};
      var insertions = [];

      function getOffset(offset) {
        for (var i = 0, l = insertions.length; i < l; i++) {
          var insertion = insertions[i];
          if (insertion[0] >= offset) break;
          offset += insertion[1];
        }

        return offset;
      }

      function getCode(node) {
        return code.substring(getOffset(node.range[0]), getOffset(node.range[1]));
      }

      function getBetween(left, right) {
        return code.substring(getOffset(left.range[1]), getOffset(right.range[0]));
      }

      function replaceCode(node, str) {
        var start = getOffset(node.range[0]),
            end = getOffset(node.range[1]),
            insert = 0;

        for (var i = insertions.length - 1; i >= 0; i--) {
          if (start > insertions[i][0]) {
            insert = i + 1;
            break;
          }
        }

        insertions.splice(insert, 0, [start, str.length - end + start]);
        code = code.substring(0, start) + str + code.substring(end);
      }

      function handleOverloading(node, parent) {
        switch (node.type) {
          case 'UnaryExpression':
            if (node.operator in unaryOperators && node.argument.type !== 'Literal') {
              var arg = getCode(node.argument);
              replaceCode(node, '$__("' + node.operator + '", ' + arg + ')');
            }

            break;

          case 'BinaryExpression':
            if (node.operator in binaryOperators && node.left.type !== 'Literal') {
              var left = getCode(node.left),
                  right = getCode(node.right),
                  between = getBetween(node.left, node.right),
                  operator = node.operator;
              replaceCode(node, '__$__(' + left + ',' + between.replace(new RegExp('\\' + operator), '"' + operator + '"') + ', ' + right + ')');
            }

            break;

          case 'UpdateExpression':
          case 'AssignmentExpression':
            var parentType = parent && parent.type;

            if (!(parentType === 'ForStatement' || parentType === 'BinaryExpression' && /^[=!<>]/.test(parent.operator) || parentType === 'MemberExpression' && parent.computed)) {
              if (node.type === 'UpdateExpression') {
                var arg = getCode(node.argument),
                    exp = '__$__(' + arg + ', "' + node.operator[0] + '", 1)',
                    str = arg + ' = ' + exp;

                if (node.prefix) {
                  str = '(' + str + ')';
                } else if (parentType === 'AssignmentExpression' || parentType === 'VariableDeclarator' || parentType === 'BinaryExpression') {
                  if (getCode(parent.left || parent.id) === arg) str = exp;
                  str = arg + '; ' + str;
                }

                replaceCode(node, str);
              } else {
                if (/^.=$/.test(node.operator) && node.left.type !== 'Literal') {
                  var left = getCode(node.left),
                      right = getCode(node.right),
                      exp = left + ' = __$__(' + left + ', "' + node.operator[0] + '", ' + right + ')';
                  replaceCode(node, /^\(.*\)$/.test(getCode(node)) ? '(' + exp + ')' : exp);
                }
              }
            }

            break;
        }
      }

      function handleExports(node) {
        switch (node.type) {
          case 'ExportDefaultDeclaration':
            replaceCode({
              range: [node.start, node.declaration.start]
            }, 'module.exports = ');
            break;

          case 'ExportNamedDeclaration':
            var declaration = node.declaration;
            var specifiers = node.specifiers;

            if (declaration) {
              var declarations = declaration.declarations;

              if (declarations) {
                declarations.forEach(function (dec) {
                  replaceCode(dec, 'module.exports.' + getCode(dec));
                });
                replaceCode({
                  range: [node.start, declaration.start + declaration.kind.length]
                }, '');
              }
            } else if (specifiers) {
              var exports = specifiers.map(function (specifier) {
                var name = getCode(specifier);
                return 'module.exports.' + name + ' = ' + name + '; ';
              }).join('');

              if (exports) {
                replaceCode(node, exports);
              }
            }

            break;
        }
      }

      function walkAST(node, parent, paperFeatures) {
        if (node) {
          for (var key in node) {
            if (key !== 'range' && key !== 'loc') {
              var value = node[key];

              if (Array.isArray(value)) {
                for (var i = 0, l = value.length; i < l; i++) {
                  walkAST(value[i], node, paperFeatures);
                }
              } else if (value && typeof value === 'object') {
                walkAST(value, node, paperFeatures);
              }
            }
          }

          if (paperFeatures.operatorOverloading !== false) {
            handleOverloading(node, parent);
          }

          if (paperFeatures.moduleExports !== false) {
            handleExports(node);
          }
        }
      }

      function encodeVLQ(value) {
        var res = '',
            base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);

        while (value || !res) {
          var next = value & 32 - 1;
          value >>= 5;
          if (value) next |= 32;
          res += base64[next];
        }

        return res;
      }

      var url = options.url || '',
          sourceMaps = options.sourceMaps,
          paperFeatures = options.paperFeatures || {},
          source = options.source || code,
          offset = options.offset || 0,
          agent = paper.agent,
          version = agent.versionNumber,
          offsetCode = false,
          lineBreaks = /\r\n|\n|\r/mg,
          map;

      if (sourceMaps && (agent.chrome && version >= 30 || agent.webkit && version >= 537.76 || agent.firefox && version >= 23 || agent.node)) {
        if (agent.node) {
          offset -= 2;
        } else if (window && url && !window.location.href.indexOf(url)) {
          var html = document.getElementsByTagName('html')[0].innerHTML;
          offset = html.substr(0, html.indexOf(code) + 1).match(lineBreaks).length + 1;
        }

        offsetCode = offset > 0 && !(agent.chrome && version >= 36 || agent.safari && version >= 600 || agent.firefox && version >= 40 || agent.node);
        var mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];
        mappings.length = (code.match(lineBreaks) || []).length + 1 + (offsetCode ? offset : 0);
        map = {
          version: 3,
          file: url,
          names: [],
          mappings: mappings.join(';AACA'),
          sourceRoot: '',
          sources: [url],
          sourcesContent: [source]
        };
      }

      if (paperFeatures.operatorOverloading !== false || paperFeatures.moduleExports !== false) {
        walkAST(parse(code, {
          ranges: true,
          preserveParens: true,
          sourceType: 'module'
        }), null, paperFeatures);
      }

      if (map) {
        if (offsetCode) {
          code = new Array(offset + 1).join('\n') + code;
        }

        if (/^(inline|both)$/.test(sourceMaps)) {
          code += "\n//# sourceMappingURL=data:application/json;base64," + self.btoa(unescape(encodeURIComponent(JSON.stringify(map))));
        }

        code += "\n//# sourceURL=" + (url || 'paperscript');
      }

      return {
        url: url,
        source: source,
        code: code,
        map: map
      };
    }

    function execute(code, scope, options) {
      paper = scope;
      var view = scope.getView(),
          tool = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code) && !/\bnew\s+Tool\b/.test(code) ? new Tool() : null,
          toolHandlers = tool ? tool._events : [],
          handlers = ['onFrame', 'onResize'].concat(toolHandlers),
          params = [],
          args = [],
          func,
          compiled = typeof code === 'object' ? code : compile(code, options);
      code = compiled.code;

      function expose(scope, hidden) {
        for (var key in scope) {
          if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)' + key.replace(/\$/g, '\\$') + '\\b').test(code)) {
            params.push(key);
            args.push(scope[key]);
          }
        }
      }

      expose({
        __$__: __$__,
        $__: $__,
        paper: scope,
        tool: tool
      }, true);
      expose(scope);
      code = 'var module = { exports: {} }; ' + code;
      var exports = Base.each(handlers, function (key) {
        if (new RegExp('\\s+' + key + '\\b').test(code)) {
          params.push(key);
          this.push('module.exports.' + key + ' = ' + key + ';');
        }
      }, []).join('\n');

      if (exports) {
        code += '\n' + exports;
      }

      code += '\nreturn module.exports;';
      var agent = paper.agent;

      if (document && (agent.chrome || agent.firefox && agent.versionNumber < 40)) {
        var script = document.createElement('script'),
            head = document.head || document.getElementsByTagName('head')[0];
        if (agent.firefox) code = '\n' + code;
        script.appendChild(document.createTextNode('document.__paperscript__ = function(' + params + ') {' + code + '\n}'));
        head.appendChild(script);
        func = document.__paperscript__;
        delete document.__paperscript__;
        head.removeChild(script);
      } else {
        func = Function(params, code);
      }

      var exports = func && func.apply(scope, args);
      var obj = exports || {};
      Base.each(toolHandlers, function (key) {
        var value = obj[key];
        if (value) tool[key] = value;
      });

      if (view) {
        if (obj.onResize) view.setOnResize(obj.onResize);
        view.emit('resize', {
          size: view.size,
          delta: new Point()
        });
        if (obj.onFrame) view.setOnFrame(obj.onFrame);
        view.requestUpdate();
      }

      return exports;
    }

    function loadScript(script) {
      if (/^text\/(?:x-|)paperscript$/.test(script.type) && PaperScope.getAttribute(script, 'ignore') !== 'true') {
        var canvasId = PaperScope.getAttribute(script, 'canvas'),
            canvas = document.getElementById(canvasId),
            src = script.src || script.getAttribute('data-src'),
            async = PaperScope.hasAttribute(script, 'async'),
            scopeAttribute = 'data-paper-scope';
        if (!canvas) throw new Error('Unable to find canvas with id "' + canvasId + '"');
        var scope = PaperScope.get(canvas.getAttribute(scopeAttribute)) || new PaperScope().setup(canvas);
        canvas.setAttribute(scopeAttribute, scope._id);

        if (src) {
          Http.request({
            url: src,
            async: async,
            mimeType: 'text/plain',
            onLoad: function (code) {
              execute(code, scope, src);
            }
          });
        } else {
          execute(script.innerHTML, scope, script.baseURI);
        }

        script.setAttribute('data-paper-ignore', 'true');
        return scope;
      }
    }

    function loadAll() {
      Base.each(document && document.getElementsByTagName('script'), loadScript);
    }

    function load(script) {
      return script ? loadScript(script) : loadAll();
    }

    if (window) {
      if (document.readyState === 'complete') {
        setTimeout(loadAll);
      } else {
        DomEvent.add(window, {
          load: loadAll
        });
      }
    }

    return {
      compile: compile,
      execute: execute,
      load: load,
      parse: parse,
      calculateBinary: __$__,
      calculateUnary: $__
    };
  }.call(this);

  var paper = new (PaperScope.inject(Base.exports, {
    Base: Base,
    Numerical: Numerical,
    Key: Key,
    DomEvent: DomEvent,
    DomElement: DomElement,
    document: document,
    window: window,
    Symbol: SymbolDefinition,
    PlacedSymbol: SymbolItem
  }))();

  if (paper.agent.node) {
    __webpack_require__(/*! ./node/extend.js */ 1)(paper);
  }

  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

  return paper;
}.call(this, typeof self === 'object' ? self : null);

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/index.scss */ "./src/styles/index.scss");
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_index_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-full.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _scripts_sidebar_sidebar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/sidebar/sidebar */ "./src/scripts/sidebar/sidebar.js");
/* harmony import */ var _scripts_util_sidebar_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/util/sidebar_data */ "./src/scripts/util/sidebar_data.js");
/* harmony import */ var _scripts_canvas_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scripts/canvas/canvas */ "./src/scripts/canvas/canvas.js");
/* harmony import */ var _scripts_intro_info__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scripts/intro/info */ "./src/scripts/intro/info.js");
/* harmony import */ var _scripts_intro_messsag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scripts/intro/messsag */ "./src/scripts/intro/messsag.js");







window.addEventListener("DOMContentLoaded", function (main) {
  // canvas
  var canvasElement = document.getElementById('myCanvas');
  var myCanvas = new _scripts_canvas_canvas__WEBPACK_IMPORTED_MODULE_4__["default"](canvasElement); //sidebar

  var sidebarElement = document.getElementById('section-content-sidebar');
  var sidebar = new _scripts_sidebar_sidebar__WEBPACK_IMPORTED_MODULE_2__["default"](_scripts_util_sidebar_data__WEBPACK_IMPORTED_MODULE_3__["default"][0], sidebarElement, myCanvas.drawShapes); //info side bar

  var infoSidebar = new _scripts_intro_info__WEBPACK_IMPORTED_MODULE_5__["default"]("Tips", _scripts_intro_messsag__WEBPACK_IMPORTED_MODULE_6__["message"]);
});

/***/ }),

/***/ "./src/scripts/canvas/canvas.js":
/*!**************************************!*\
  !*** ./src/scripts/canvas/canvas.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constants */ "./src/scripts/util/constants.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-full.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _modal_modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modal/modal */ "./src/scripts/modal/modal.js");
/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/util */ "./src/scripts/util/util.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





var boundsIdentifierObj = {
  1: 'topLeft',
  2: 'topRight',
  3: 'bottomRight',
  0: 'bottomLeft'
};
var LINE = 'line';

var MyCanvas =
/*#__PURE__*/
function () {
  function MyCanvas(canvasElement) {
    _classCallCheck(this, MyCanvas);

    this.canvasElement = canvasElement;
    this.centerPosition = this.getCenterPosition();
    this.strokeColor = 'black';
    this.fillColor = "white";
    this.defaultSize = [100, 100];
    this.currentActiveItem = null;
    this.strokeWidth = 2; // sets up paper js on canvas

    paper__WEBPACK_IMPORTED_MODULE_1___default.a.setup(canvasElement); //creates new project in paper

    this.project = new paper__WEBPACK_IMPORTED_MODULE_1__["Project"](canvasElement); //canvas scale value

    this.canvasScaleValue = 1; //creating tool

    this.tool = new paper__WEBPACK_IMPORTED_MODULE_1__["Tool"](); // has moved at least 10 points:

    paper__WEBPACK_IMPORTED_MODULE_1__["tool"].minDistance = 2; //binds methods
    //shapes method binding

    this.drawShapes = this.drawShapes.bind(this);
    this.drawClassShape = this.drawClassShape.bind(this);
    this.drawLineShape = this.drawLineShape.bind(this);
    this.drawObjectShape = this.drawObjectShape.bind(this);
    this.drawTextShape = this.drawTextShape.bind(this);
    this.drawUserCaseShape = this.drawUseCaseShape.bind(this);
    this.drawComponentShape = this.drawComponentShape.bind(this);
    this.drawModuleShape = this.drawModuleShape.bind(this);
    this.drawActivityShape = this.drawActivityShape.bind(this);
    this.drawDecisionShape = this.drawDecisionShape.bind(this);
    this.drawActorShape = this.drawActorShape.bind(this); //general method binding

    this.getCenterPosition = this.getCenterPosition.bind(this); //user interaction method binding

    this.onToolDoubleClick = this.onToolDoubleClick.bind(this);
    this.onToolMouseDown = this.onToolMouseDown.bind(this);
    this.setOneItemSelected = this.setOneItemSelected.bind(this);
    this.onToolDrag = this.onToolDrag.bind(this);
    this.onToolKeyDown = this.onToolKeyDown.bind(this); //tool level clicklistener

    this.tool.onMouseDown = this.onToolMouseDown;
    this.tool.onMouseUp = this.onToolMouseUp;
    this.tool.onMouseDrag = this.onToolDrag;
    this.tool.onKeyDown = this.onToolKeyDown; //add double click listener on canvas because tool have no double click listener

    this.canvasElement.addEventListener("dblclick", this.onToolDoubleClick); //set right menu liteners

    this.setMenuClickListener = this.setMenuClickListener.bind(this);
    this.setMenuClickListener();
  } //set right menu click listener


  _createClass(MyCanvas, [{
    key: "setMenuClickListener",
    value: function setMenuClickListener() {
      var openFileElement = document.getElementById('open-file');
      var downloadFileElement = document.getElementById('download-file');
      var bringToFrontElement = document.getElementById('bring-to-front');
      var moveToBackElement = document.getElementById('move-to-back');
      openFileElement.addEventListener('click', this.openFile.bind(this));
      downloadFileElement.addEventListener('click', this.downloadAsSVG.bind(this));
      bringToFrontElement.addEventListener('click', this.bringToFront.bind(this));
      moveToBackElement.addEventListener('click', this.moveToBack.bind(this));
    } //set input to open file picker dialog

  }, {
    key: "openFile",
    value: function openFile() {
      var _this = this;

      var input = document.createElement('input');
      input.type = 'file';
      input.multiple = false;
      input.accept = 'image/svg+xml';

      input.onchange = function () {
        _this.project.importSVG(URL.createObjectURL(input.files[0]), function (group, svg) {
          _this.project.clear();

          var that = _this;

          while (group.children[1].children.length > 0) {
            that.project.activeLayer.addChild(group.children[1].children[0]);
          }
        });
      };

      input.click();
    } // set download project as svg

  }, {
    key: "downloadAsSVG",
    value: function downloadAsSVG() {
      if (this.project.activeLayer.children.length == 0) return;
      var fileName = "umlchart_".concat(Date.now(), ".svg");
      var url = "data:image/svg+xml;utf8," + encodeURIComponent(this.project.exportSVG({
        asString: true
      }));
      var downloadLinkElement = document.createElement("a");
      downloadLinkElement.download = fileName;
      downloadLinkElement.href = url;
      downloadLinkElement.click();
    } //set bring to front listener for items

  }, {
    key: "bringToFront",
    value: function bringToFront() {
      this.currentActiveItem.bringToFront();
    } //set move to back listener for items

  }, {
    key: "moveToBack",
    value: function moveToBack() {
      this.currentActiveItem.sendToBack();
    } //shape draw distributor

  }, {
    key: "drawShapes",
    value: function drawShapes(shapeName) {
      switch (shapeName) {
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CLASS:
          this.drawClassShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ASSOCIATION:
          var startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 50, this.centerPosition.y);
          var endPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 50, this.centerPosition.y);
          this.drawLineShape(startPoint, endPoint, shapeName);
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].SQUARE:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].OBJECT:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].INTERFACE:
          this.drawObjectShape(shapeName);
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].TITLE:
          startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 25, this.centerPosition.y - 25);
          this.drawTextShape(startPoint, "Add Text");
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CIRCLE:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].USECASE:
          this.drawUseCaseShape(shapeName);
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPONENT:
          this.drawComponentShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].MODULE:
          this.drawModuleShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTIVITY:
          this.drawActivityShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DECISION:
          this.drawDecisionShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTOR:
          this.drawActorShape();

        default:
          break;
      }
    } // Creates three rectangle to make a class UML

  }, {
    key: "drawClassShape",
    value: function drawClassShape() {
      //creates group and add shapes
      //create class rectangle
      var groupClass = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      var firstRectX = this.centerPosition.x - 50;
      var firstRectY = this.centerPosition.y - 50;
      var firstRectHeight = 20;
      var fristRectWidth = this.defaultSize[1];
      var classNameRectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(firstRectX, firstRectY, fristRectWidth, firstRectHeight);
      this.setStrokeAndFill(classNameRectangle);
      groupClass.addChild(classNameRectangle); //create varaible rectangle

      var secRectX = firstRectX;
      var secRectY = firstRectY + firstRectHeight;
      var secRectHeight = 50;
      var secRectWidth = this.defaultSize[1];
      var variableNameRectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(secRectX, secRectY, secRectWidth, secRectHeight);
      this.setStrokeAndFill(variableNameRectangle);
      groupClass.addChild(variableNameRectangle); //create method rectangle

      var thirdRectX = firstRectX;
      var thirdRectY = secRectY + secRectHeight;
      var thirdRectHeight = 30;
      var thirdRectWidth = this.defaultSize[1];
      var methodNameRectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(thirdRectX, thirdRectY, thirdRectWidth, thirdRectHeight);
      this.setStrokeAndFill(methodNameRectangle);
      groupClass.addChild(methodNameRectangle);
    } // adds text to the clicked area

  }, {
    key: "drawTextShape",
    value: function drawTextShape(position, text) {
      //create text shape
      var textShape = new paper__WEBPACK_IMPORTED_MODULE_1__["PointText"](position);
      textShape.fillColor = this.strokeColor;
      textShape.content = text; //adds doubleclick listner to text

      textShape.onDoubleClick = function (e) {
        //show modal to update text
        if (textShape.bounds.selected) {
          new _modal_modal__WEBPACK_IMPORTED_MODULE_2__["default"](function (updatedText) {
            textShape.content = updatedText;
          }).show();
        }
      };

      return textShape;
    } //add Divider/Association/Compositioin/Aggregation with head shape and three circles (to aid movement and drag)

  }, {
    key: "drawLineShape",
    value: function drawLineShape(startPoint, endPoint, lineType) {
      var mainGroup = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"](); //draw line

      var line = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(startPoint, endPoint);
      this.setStrokeAndFill(line); // draw head circle

      var headCircle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(endPoint, 5);
      headCircle.fillColor = 'black';
      headCircle.strokeWidth = 1; //draw middle circle

      var midPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"]((startPoint.x + endPoint.x) / 2, (startPoint.y + endPoint.y) / 2);
      var midCircle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(midPoint, 4);
      midCircle.fillColor = 'black';
      midCircle.strokeWidth = 1; //draw tail circle

      var tailCircle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(startPoint, 5);
      tailCircle.fillColor = 'black';
      tailCircle.strokeWidth = 1; //add circles and line to group

      group.addChild(line);
      group.addChild(tailCircle);
      group.addChild(midCircle);
      group.addChild(headCircle); //draw arrow shape

      var headShape = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"]();
      headShape.strokeColor = this.strokeColor;
      headShape.strokeWidth = this.strokeWidth;
      var arrowCenter = endPoint; //based on line type draw shape

      if (lineType !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER) {
        var leftEdge = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](arrowCenter.x - 10, arrowCenter.y - 10);
        var rightEdge = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](arrowCenter.x - 10, arrowCenter.y + 10);
        headShape.add(leftEdge);
        headShape.add(arrowCenter);
        headShape.add(rightEdge);

        if (lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION || lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION) {
          var bottomRightEdge = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](arrowCenter.x - 20, arrowCenter.y);
          var bottomLeftEdge = leftEdge;
          headShape.add(bottomRightEdge);
          headShape.add(bottomLeftEdge);

          if (lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION) {
            headShape.strokeColor = 'white';
            headShape.fillColor = 'white';
            headShape.shadowColor = 'gray';
            headShape.shadowOffset = 1;
          }

          if (lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION) {
            headShape.fillColor = 'black';
          }
        }
      } //rotate the head shape


      if (lineType !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER) headShape.rotate(Object(_util_util__WEBPACK_IMPORTED_MODULE_3__["getAngleDeg"])(endPoint.x, endPoint.y, startPoint.x, startPoint.y), arrowCenter); //add group to main group

      mainGroup.addChild(group);
      if (lineType !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER) mainGroup.addChild(headShape);
      mainGroup.data.type = LINE;
      mainGroup.data.lineType = lineType;
      return mainGroup;
    } //add Object/Interface shape

  }, {
    key: "drawObjectShape",
    value: function drawObjectShape(type) {
      //creates object rectangle
      var startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 50, this.centerPosition.y - 25);
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(startPoint.x, startPoint.y, this.defaultSize[0], this.defaultSize[0] / 2);
      this.setStrokeAndFill(rectangle); //create textshape

      if (type !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].SQUARE) {
        var textShapeStartPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](startPoint.x + 30, startPoint.y + 30);
        var textShape = this.drawTextShape(textShapeStartPoint, type);
      }
    } //add Usecase/Activity shape

  }, {
    key: "drawUseCaseShape",
    value: function drawUseCaseShape(type) {
      //draw circle
      var circlePath = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(this.centerPosition, 25);
      circlePath.scale(2, 1.2); //scale to make it an oval

      this.setStrokeAndFill(circlePath);

      if (type === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].USECASE) {
        //add Text
        var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 25, this.centerPosition.y + 5), type);
      }
    } //add Component shape

  }, {
    key: "drawComponentShape",
    value: function drawComponentShape() {
      //draw main rectangle
      var startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 50, this.centerPosition.y - 25);
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(startPoint.x, startPoint.y, this.defaultSize[0] + 20, this.defaultSize[0] - 45);
      this.setStrokeAndFill(rectangle); // draw sub part of the shape

      var subRect = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topRight.x - 25, startPoint.y + 6, 20, 25);
      this.setStrokeAndFill(subRect);
      subRect.strokeWidth = 2 / this.strokeWidth; //draw two sub rec

      var subRect1 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topRight.x - 28, startPoint.y + 9, 7, 7);
      this.setStrokeAndFill(subRect1);
      subRect1.strokeWidth = 2 / this.strokeWidth;
      var subRect2 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topRight.x - 28, startPoint.y + 20, 7, 7);
      this.setStrokeAndFill(subRect2);
      subRect2.strokeWidth = 2 / this.strokeWidth; //create group and add shapes

      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      group.addChild(rectangle);
      group.addChild(subRect);
      group.addChild(subRect1);
      group.addChild(subRect2); //add text to shape

      var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 25, this.centerPosition.y + 8), _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPONENT);
    } //add module shape

  }, {
    key: "drawModuleShape",
    value: function drawModuleShape() {
      // draw main rect
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(this.centerPosition.x - 50, this.centerPosition.y - 50, this.defaultSize[0] + 20, this.defaultSize[0] - 40);
      this.setStrokeAndFill(rectangle); //draw two sub rec

      var subRect1 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topLeft.x - 7, rectangle.bounds.topLeft.y + 12, 15, 12);
      this.setStrokeAndFill(subRect1);
      var subRect2 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topLeft.x - 7, rectangle.bounds.topLeft.y + 35, 15, 12);
      this.setStrokeAndFill(subRect2); //create group and add shapes

      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      group.addChild(rectangle);
      group.addChild(subRect1);
      group.addChild(subRect2); //add text to shape

      var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 10, this.centerPosition.y - 15), _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].MODULE);
    } //add activity shape

  }, {
    key: "drawActivityShape",
    value: function drawActivityShape() {
      //create rounded shape rectangle
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](this.centerPosition.subtract(50), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 70, this.centerPosition.y));
      var radius = new paper__WEBPACK_IMPORTED_MODULE_1__["Size"](30, 30);
      var path = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle, radius);
      this.setStrokeAndFill(path); //add text to shape

      var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 10, this.centerPosition.y - 20), _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTIVITY);
    } //add decision shape

  }, {
    key: "drawDecisionShape",
    value: function drawDecisionShape() {
      //create rectangle
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(this.centerPosition.x - 20, this.centerPosition.y - 20, this.defaultSize[0] / 2.5, this.defaultSize[0] / 2.5);
      this.setStrokeAndFill(rectangle); //rotate

      rectangle.rotate(45);
    } //on tool click

  }, {
    key: "onToolMouseDown",
    value: function onToolMouseDown(e) {
      //toggle item selected
      this.setOneItemSelected(e); //return if no currentActiveItem

      if (!this.currentActiveItem) return; //clearing currentActiveItem data to fix the issue of unintended moves

      this.currentActiveItem.data.state = null;

      if (this.currentActiveItem.contains(e.point)) {
        this.currentActiveItem.data.state = 'move';
      } //set items data based on item mouseDown point


      if (this.currentActiveItem.data.type !== LINE) {
        if (this.currentActiveItem.hitTest(e.point, {
          bounds: true,
          tolerance: 5
        })) {
          //get bounds of the shape
          var bounds = this.currentActiveItem.bounds; //itrating to find the exact bound point

          for (var _i = 0, _Object$entries = Object.entries(boundsIdentifierObj); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                key = _Object$entries$_i[0],
                value = _Object$entries$_i[1];

            if (bounds[value].isClose(e.point, 5)) {
              var oppositeBound = bounds[boundsIdentifierObj[(parseInt(key) + 2) % 4]]; //get opposite bound point

              var oppositePoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](oppositeBound.x, oppositeBound.y); //get current bound point

              var currentPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](bounds[value].x, bounds[value].y); //set shape data to be used for resizing later

              this.currentActiveItem.data.state = 'resize';
              this.currentActiveItem.data.from = oppositePoint;
              this.currentActiveItem.data.to = currentPoint;
              break;
            }
          }
        }
      } else {
        //only for shapes with type LINE
        var headCircleItem = this.currentActiveItem.firstChild.children[3];

        if (headCircleItem.contains(e.point)) {
          this.currentActiveItem.data.state = 'resize';
        }
      }
    } //draw actor shape

  }, {
    key: "drawActorShape",
    value: function drawActorShape() {
      //draw actor head
      var head = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 50), 7);
      this.setStrokeAndFill(head); //draw actor body

      var body = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 43), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 10));
      this.setStrokeAndFill(body); //draw actor arms

      var arms = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 20, this.centerPosition.y - 38), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 20, this.centerPosition.y - 38));
      this.setStrokeAndFill(arms); //draw feet

      var leftFeet = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 20, this.centerPosition.y + 5), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 10));
      this.setStrokeAndFill(leftFeet);
      var rightFeet = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 10), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 20, this.centerPosition.y + 5));
      this.setStrokeAndFill(rightFeet); //add shapes to group to make full actor

      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      group.addChild(head);
      group.addChild(body);
      group.addChild(arms);
      group.addChild(leftFeet);
      group.addChild(rightFeet);
    } //item drag listener

  }, {
    key: "onToolDrag",
    value: function onToolDrag(e) {
      // debugger
      if (this.currentActiveItem == null) return;

      if (this.currentActiveItem.data.state === 'move') {
        this.currentActiveItem.position = e.point;
      } else if (this.currentActiveItem.data.state === 'resize') {
        if (this.currentActiveItem.data.type === LINE) {
          //shapes with type line, re-rendering line on each user move
          var lineStartPoint = this.currentActiveItem.firstChild.firstChild.segments[0].point;
          var lineType = this.currentActiveItem.data.lineType;
          this.currentActiveItem.remove();
          this.currentActiveItem = this.drawLineShape(lineStartPoint, e.point, lineType);
          this.currentActiveItem.data.state = 'resize';
        } else {
          //shapes other than line, updating the bounds
          this.currentActiveItem.bounds = new paper__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](this.currentActiveItem.data.from, e.point);
        }

        this.currentActiveItem.bounds.selected = true;
      }
    } //on tool double click

  }, {
    key: "onToolDoubleClick",
    value: function onToolDoubleClick(e) {
      if (e.ctrlKey) {
        this.drawTextShape({
          x: e.layerX,
          y: e.layerY
        }, "Add Text");
      }
    } //toggle item selecteion and saving currentActiveItem

  }, {
    key: "setOneItemSelected",
    value: function setOneItemSelected(e) {
      var position = e.point;
      var clickedItems = [];
      this.project.activeLayer.children.forEach(function (child) {
        if (child.contains(position)) {
          clickedItems.push(child);
        } else {
          child.bounds.selected = false;
        }
      }); //return if no item is selected

      if (clickedItems.length === 0) return; //select the clicked item

      var latestItem = clickedItems[0];

      for (var i = 0; i < clickedItems.length; i++) {
        if (latestItem.id < clickedItems[i].id) {
          latestItem = clickedItems[i];
        } else {
          clickedItems[i].bounds.selected = false;
        }
      }

      this.currentActiveItem = latestItem;
      latestItem.bounds.selected = true;
    } // keyboard intraction to move shapes

  }, {
    key: "onToolKeyDown",
    value: function onToolKeyDown(e) {
      if (!this.currentActiveItem) return;
      var position = this.currentActiveItem.position;
      var step = 5;

      switch (e.key) {
        case 'left':
          position.x -= step;
          break;

        case 'right':
          position.x += step;
          break;

        case 'up':
          position.y -= step;
          break;

        case 'down':
          position.y += step;
          break;

        case 'delete':
          this.currentActiveItem.remove();
          break;
      }

      this.currentActiveItem.position = position;
    } //----------------------- general methods --------------------------------------
    // return center position of canvas

  }, {
    key: "getCenterPosition",
    value: function getCenterPosition() {
      return new paper__WEBPACK_IMPORTED_MODULE_1__["Point"]({
        x: this.canvasElement.clientWidth / 2,
        y: this.canvasElement.clientHeight / 2
      });
    } // helper to set stroke and fill

  }, {
    key: "setStrokeAndFill",
    value: function setStrokeAndFill(item) {
      item.strokeWidth = this.strokeWidth;
      item.strokeColor = this.strokeColor;
      item.fillColor = this.fillColor;
    }
  }]);

  return MyCanvas;
}();

/* harmony default export */ __webpack_exports__["default"] = (MyCanvas);

/***/ }),

/***/ "./src/scripts/intro/info.js":
/*!***********************************!*\
  !*** ./src/scripts/intro/info.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Info; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Info =
/*#__PURE__*/
function () {
  function Info(title, text) {
    _classCallCheck(this, Info);

    this.title = title;
    this.text = text;
    this.show = this.show.bind(this);
    this.show();
  }

  _createClass(Info, [{
    key: "show",
    value: function show() {
      //set up info view
      var infoSectionContainerElement = document.getElementById('info-sidebar');
      var topBarConatinerElement = document.createElement('div');
      topBarConatinerElement.setAttribute('class', 'top-bar-container');
      var titleElement = document.createElement('h1');
      titleElement.setAttribute('class', 'info-title');
      titleElement.innerHTML = this.title;
      var closeElement = document.createElement('span');
      closeElement.setAttribute('class', 'info-close');
      closeElement.innerHTML = 'X';
      topBarConatinerElement.appendChild(titleElement);
      topBarConatinerElement.appendChild(closeElement);
      var bodyElement = document.createElement('div');
      bodyElement.setAttribute('class', 'info-body');
      bodyElement.innerHTML = this.text;
      infoSectionContainerElement.appendChild(topBarConatinerElement);
      infoSectionContainerElement.appendChild(bodyElement); //set up listener

      closeElement.addEventListener('click', function () {
        infoSectionContainerElement.setAttribute('class', 'hidden');
      });
    }
  }]);

  return Info;
}();



/***/ }),

/***/ "./src/scripts/intro/messsag.js":
/*!**************************************!*\
  !*** ./src/scripts/intro/messsag.js ***!
  \**************************************/
/*! exports provided: message */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "message", function() { return message; });
var message = "<p> - Click any shape from the UML section to add it to the canvas.<br/> </p>" + "<p> - Then select a shape and drag it form any corner to resize.<br/> </p>" + "<p> - You can also move a shape with arrow keys form the keyboard.<br/> </p>" + "<p> - Select any line shape and use middle circle to move the line around and the head circle to rotate it at different angles.<br/> </p>" + "<p> - Select a shape and press 'delete' key to delete the shape.<br/> </p>" + "<p> - Press 'Ctrl + Mouse Double Click' to add text.<br/> </p>" + "<p> - Use 'Move-To-Front' and 'Send-To-Back' icon to move the shapes.<br/> </p>" + "<p> - For saving and opening exisiting project utilize the menu bar.<br/> </p>";

/***/ }),

/***/ "./src/scripts/modal/modal.js":
/*!************************************!*\
  !*** ./src/scripts/modal/modal.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Modal; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Modal =
/*#__PURE__*/
function () {
  function Modal(textCallback) {
    _classCallCheck(this, Modal);

    this.textCallback = textCallback;
    this.show = this.show.bind(this);
  }

  _createClass(Modal, [{
    key: "show",
    value: function show() {
      var _this = this;

      var bodyElement = document.getElementById('body');
      var modalMainContainerElement = document.createElement('div');
      modalMainContainerElement.setAttribute('class', 'modal-main-container');
      var modalContainerElement = document.createElement('div');
      modalContainerElement.setAttribute('class', 'modal-container');
      var modalTitleConainerElement = document.createElement('div');
      modalTitleConainerElement.setAttribute('class', 'modal-title-container');
      var modalTitleElement = document.createElement('h1');
      modalTitleElement.innerHTML = "Add Text";
      modalTitleElement.setAttribute('class', 'modal-title');
      var modalCloseElement = document.createElement('span');
      modalCloseElement.innerHTML = "X";
      modalCloseElement.setAttribute('class', 'modal-close');
      var modalInputElement = document.createElement('input');
      modalInputElement.placeholder = "Add text here";
      modalInputElement.setAttribute('class', 'modal-input');
      var modalSubmitElement = document.createElement('button');
      modalSubmitElement.innerHTML = "Submit";
      modalSubmitElement.setAttribute('class', 'modal-submit');
      modalTitleConainerElement.appendChild(modalTitleElement);
      modalTitleConainerElement.appendChild(modalCloseElement);
      modalContainerElement.appendChild(modalTitleConainerElement);
      modalContainerElement.appendChild(modalInputElement);
      modalContainerElement.appendChild(modalSubmitElement);
      modalMainContainerElement.appendChild(modalContainerElement);
      bodyElement.appendChild(modalMainContainerElement); //adds listeners
      //close modal on outside click

      modalMainContainerElement.addEventListener('click', function (e) {
        modalMainContainerElement.setAttribute('class', 'hiddden');
      }); //stops modal from closing if clicked inside modal

      modalContainerElement.addEventListener('click', function (e) {
        e.stopPropagation();
      }); //closes modal on click

      modalCloseElement.addEventListener('click', function (e) {
        modalMainContainerElement.setAttribute('class', 'hiddden');
      }); //gets text form input on submit and sending to callback

      modalSubmitElement.addEventListener('click', function (e) {
        var inputText = modalInputElement.value;

        _this.textCallback(inputText);

        modalMainContainerElement.setAttribute('class', 'hiddden');
      });
    }
  }]);

  return Modal;
}();



/***/ }),

/***/ "./src/scripts/sidebar/sidebar.js":
/*!****************************************!*\
  !*** ./src/scripts/sidebar/sidebar.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Sidebar; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Sidebar =
/*#__PURE__*/
function () {
  function Sidebar(categoryObj, sidebarElement, onShapeClickCallback) {
    _classCallCheck(this, Sidebar);

    this.categoryTitle = categoryObj.categoryName;
    this.shapes = categoryObj.shapes;
    this.sidebarElement = sidebarElement;
    this.onShapeClickCallback = onShapeClickCallback;
    this.draw();
    this.shapeClickListener = this.shapeClickListener.bind(this);
  }

  _createClass(Sidebar, [{
    key: "shapeClickListener",
    value: function shapeClickListener(shapeName) {
      var _this = this;

      return function (e) {
        _this.onShapeClickCallback(shapeName);
      };
    }
  }, {
    key: "draw",
    value: function draw() {
      //adds category title in sidebar
      var categoryTitleElement = document.createElement('h1');
      categoryTitleElement.innerHTML = this.categoryTitle;
      categoryTitleElement.setAttribute('class', 'sidebar-category-title');
      this.sidebarElement.appendChild(categoryTitleElement); //adds category shapes in sidebar

      var shapesUlElement = document.createElement('ul');
      shapesUlElement.setAttribute('class', "sidebar-category-shapes-ul");

      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];
        var shapeLiElement = document.createElement('li');
        shapeLiElement.setAttribute('class', "sidebar-category-shapes-li");
        shapeLiElement.addEventListener("click", this.shapeClickListener(shape.name));
        var shapeImageElement = document.createElement('img');
        shapeImageElement.setAttribute('class', "sidebar-category-images");
        shapeImageElement.src = shape.uri;
        shapeLiElement.appendChild(shapeImageElement);
        shapesUlElement.appendChild(shapeLiElement);
      }

      this.sidebarElement.appendChild(shapesUlElement);
    }
  }]);

  return Sidebar;
}();



/***/ }),

/***/ "./src/scripts/util/constants.js":
/*!***************************************!*\
  !*** ./src/scripts/util/constants.js ***!
  \***************************************/
/*! exports provided: SHAPES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHAPES", function() { return SHAPES; });
var SHAPES = {
  CLASS: 'Class',
  SQUARE: 'Square',
  DIVIDER: 'Divider',
  CIRCLE: 'Circle',
  OBJECT: 'Object',
  INTERFACE: 'Interface',
  ACTOR: 'Actor',
  AGGREGATION: 'Aggregation',
  COMPOSITION: 'Composition',
  ASSOCIATION: 'Association',
  COMPONENT: 'Component',
  MODULE: 'Module',
  TITLE: 'Title',
  ACTIVITY: 'Activity',
  USECASE: 'Use Case',
  DECISION: 'Decision'
};

/***/ }),

/***/ "./src/scripts/util/sidebar_data.js":
/*!******************************************!*\
  !*** ./src/scripts/util/sidebar_data.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/scripts/util/constants.js");

var sidebarData = [{
  categoryName: "UML",
  shapes: [{
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].OBJECT,
    uri: './src/images/object.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].INTERFACE,
    uri: './src/images/interface.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CLASS,
    uri: './src/images/class.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER,
    uri: './src/images/divider.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].TITLE,
    uri: './src/images/title.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPONENT,
    uri: './src/images/component.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].MODULE,
    uri: './src/images/module.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTOR,
    uri: './src/images/actor.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].USECASE,
    uri: './src/images/usercase.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTIVITY,
    uri: './src/images/activity.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DECISION,
    uri: './src/images/decision.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION,
    uri: './src/images/aggregation.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION,
    uri: './src/images/composition.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ASSOCIATION,
    uri: './src/images/association.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CIRCLE,
    uri: './src/images/circle.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].SQUARE,
    uri: './src/images/square.svg'
  }]
}];
/* harmony default export */ __webpack_exports__["default"] = (sidebarData);

/***/ }),

/***/ "./src/scripts/util/util.js":
/*!**********************************!*\
  !*** ./src/scripts/util/util.js ***!
  \**********************************/
/*! exports provided: getAngleDeg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngleDeg", function() { return getAngleDeg; });
function getAngleDeg(ex, ey, cx, cy) {
  var dy = ey - cy;
  var dx = ex - cx;
  var theta = Math.atan2(dy, dx);
  theta *= 180 / Math.PI;
  return theta;
}

/***/ }),

/***/ "./src/styles/index.scss":
/*!*******************************!*\
  !*** ./src/styles/index.scss ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 0:
/*!********************************!*\
  !*** ./node/self.js (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************************!*\
  !*** ./node/extend.js (ignored) ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fjb3JuL2Rpc3QvYWNvcm4ubWpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWZ1bGwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NhbnZhcy9jYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvaW50cm8vaW5mby5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9pbnRyby9tZXNzc2FnLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL21vZGFsL21vZGFsLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3NpZGViYXIvc2lkZWJhci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy91dGlsL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy91dGlsL3NpZGViYXJfZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9pbmRleC5zY3NzP2M4MDciLCJ3ZWJwYWNrOi8vLy4vbm9kZS9zZWxmLmpzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9ub2RlL2V4dGVuZC5qcyAoaWdub3JlZCkiXSwibmFtZXMiOlsid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1haW4iLCJjYW52YXNFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm15Q2FudmFzIiwiTXlDYW52YXMiLCJzaWRlYmFyRWxlbWVudCIsInNpZGViYXIiLCJTaWRlYmFyIiwic2lkZWJhckRhdGEiLCJkcmF3U2hhcGVzIiwiaW5mb1NpZGViYXIiLCJJbmZvIiwibWVzc2FnZSIsImJvdW5kc0lkZW50aWZpZXJPYmoiLCJMSU5FIiwiY2VudGVyUG9zaXRpb24iLCJnZXRDZW50ZXJQb3NpdGlvbiIsInN0cm9rZUNvbG9yIiwiZmlsbENvbG9yIiwiZGVmYXVsdFNpemUiLCJjdXJyZW50QWN0aXZlSXRlbSIsInN0cm9rZVdpZHRoIiwicGFwZXIiLCJzZXR1cCIsInByb2plY3QiLCJQcm9qZWN0IiwiY2FudmFzU2NhbGVWYWx1ZSIsInRvb2wiLCJUb29sIiwibWluRGlzdGFuY2UiLCJiaW5kIiwiZHJhd0NsYXNzU2hhcGUiLCJkcmF3TGluZVNoYXBlIiwiZHJhd09iamVjdFNoYXBlIiwiZHJhd1RleHRTaGFwZSIsImRyYXdVc2VyQ2FzZVNoYXBlIiwiZHJhd1VzZUNhc2VTaGFwZSIsImRyYXdDb21wb25lbnRTaGFwZSIsImRyYXdNb2R1bGVTaGFwZSIsImRyYXdBY3Rpdml0eVNoYXBlIiwiZHJhd0RlY2lzaW9uU2hhcGUiLCJkcmF3QWN0b3JTaGFwZSIsIm9uVG9vbERvdWJsZUNsaWNrIiwib25Ub29sTW91c2VEb3duIiwic2V0T25lSXRlbVNlbGVjdGVkIiwib25Ub29sRHJhZyIsIm9uVG9vbEtleURvd24iLCJvbk1vdXNlRG93biIsIm9uTW91c2VVcCIsIm9uVG9vbE1vdXNlVXAiLCJvbk1vdXNlRHJhZyIsIm9uS2V5RG93biIsInNldE1lbnVDbGlja0xpc3RlbmVyIiwib3BlbkZpbGVFbGVtZW50IiwiZG93bmxvYWRGaWxlRWxlbWVudCIsImJyaW5nVG9Gcm9udEVsZW1lbnQiLCJtb3ZlVG9CYWNrRWxlbWVudCIsIm9wZW5GaWxlIiwiZG93bmxvYWRBc1NWRyIsImJyaW5nVG9Gcm9udCIsIm1vdmVUb0JhY2siLCJpbnB1dCIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwibXVsdGlwbGUiLCJhY2NlcHQiLCJvbmNoYW5nZSIsImltcG9ydFNWRyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImZpbGVzIiwiZ3JvdXAiLCJzdmciLCJjbGVhciIsInRoYXQiLCJjaGlsZHJlbiIsImxlbmd0aCIsImFjdGl2ZUxheWVyIiwiYWRkQ2hpbGQiLCJjbGljayIsImZpbGVOYW1lIiwiRGF0ZSIsIm5vdyIsInVybCIsImVuY29kZVVSSUNvbXBvbmVudCIsImV4cG9ydFNWRyIsImFzU3RyaW5nIiwiZG93bmxvYWRMaW5rRWxlbWVudCIsImRvd25sb2FkIiwiaHJlZiIsInNlbmRUb0JhY2siLCJzaGFwZU5hbWUiLCJTSEFQRVMiLCJDTEFTUyIsIkFHR1JFR0FUSU9OIiwiQ09NUE9TSVRJT04iLCJESVZJREVSIiwiQVNTT0NJQVRJT04iLCJzdGFydFBvaW50IiwiUG9pbnQiLCJ4IiwieSIsImVuZFBvaW50IiwiU1FVQVJFIiwiT0JKRUNUIiwiSU5URVJGQUNFIiwiVElUTEUiLCJDSVJDTEUiLCJVU0VDQVNFIiwiQ09NUE9ORU5UIiwiTU9EVUxFIiwiQUNUSVZJVFkiLCJERUNJU0lPTiIsIkFDVE9SIiwiZ3JvdXBDbGFzcyIsIkdyb3VwIiwiZmlyc3RSZWN0WCIsImZpcnN0UmVjdFkiLCJmaXJzdFJlY3RIZWlnaHQiLCJmcmlzdFJlY3RXaWR0aCIsImNsYXNzTmFtZVJlY3RhbmdsZSIsIlBhdGgiLCJSZWN0YW5nbGUiLCJzZXRTdHJva2VBbmRGaWxsIiwic2VjUmVjdFgiLCJzZWNSZWN0WSIsInNlY1JlY3RIZWlnaHQiLCJzZWNSZWN0V2lkdGgiLCJ2YXJpYWJsZU5hbWVSZWN0YW5nbGUiLCJ0aGlyZFJlY3RYIiwidGhpcmRSZWN0WSIsInRoaXJkUmVjdEhlaWdodCIsInRoaXJkUmVjdFdpZHRoIiwibWV0aG9kTmFtZVJlY3RhbmdsZSIsInBvc2l0aW9uIiwidGV4dCIsInRleHRTaGFwZSIsIlBvaW50VGV4dCIsImNvbnRlbnQiLCJvbkRvdWJsZUNsaWNrIiwiZSIsImJvdW5kcyIsInNlbGVjdGVkIiwiTW9kYWwiLCJ1cGRhdGVkVGV4dCIsInNob3ciLCJsaW5lVHlwZSIsIm1haW5Hcm91cCIsImxpbmUiLCJMaW5lIiwiaGVhZENpcmNsZSIsIkNpcmNsZSIsIm1pZFBvaW50IiwibWlkQ2lyY2xlIiwidGFpbENpcmNsZSIsImhlYWRTaGFwZSIsImFycm93Q2VudGVyIiwibGVmdEVkZ2UiLCJyaWdodEVkZ2UiLCJhZGQiLCJib3R0b21SaWdodEVkZ2UiLCJib3R0b21MZWZ0RWRnZSIsInNoYWRvd0NvbG9yIiwic2hhZG93T2Zmc2V0Iiwicm90YXRlIiwiZ2V0QW5nbGVEZWciLCJkYXRhIiwicmVjdGFuZ2xlIiwidGV4dFNoYXBlU3RhcnRQb2ludCIsImNpcmNsZVBhdGgiLCJzY2FsZSIsInN1YlJlY3QiLCJ0b3BSaWdodCIsInN1YlJlY3QxIiwic3ViUmVjdDIiLCJ0b3BMZWZ0Iiwic3VidHJhY3QiLCJyYWRpdXMiLCJTaXplIiwicGF0aCIsInN0YXRlIiwiY29udGFpbnMiLCJwb2ludCIsImhpdFRlc3QiLCJ0b2xlcmFuY2UiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJpc0Nsb3NlIiwib3Bwb3NpdGVCb3VuZCIsInBhcnNlSW50Iiwib3Bwb3NpdGVQb2ludCIsImN1cnJlbnRQb2ludCIsImZyb20iLCJ0byIsImhlYWRDaXJjbGVJdGVtIiwiZmlyc3RDaGlsZCIsImhlYWQiLCJib2R5IiwiYXJtcyIsImxlZnRGZWV0IiwicmlnaHRGZWV0IiwibGluZVN0YXJ0UG9pbnQiLCJzZWdtZW50cyIsInJlbW92ZSIsImN0cmxLZXkiLCJsYXllclgiLCJsYXllclkiLCJjbGlja2VkSXRlbXMiLCJmb3JFYWNoIiwiY2hpbGQiLCJwdXNoIiwibGF0ZXN0SXRlbSIsImkiLCJpZCIsInN0ZXAiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIml0ZW0iLCJ0aXRsZSIsImluZm9TZWN0aW9uQ29udGFpbmVyRWxlbWVudCIsInRvcEJhckNvbmF0aW5lckVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJ0aXRsZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJjbG9zZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImJvZHlFbGVtZW50IiwidGV4dENhbGxiYWNrIiwibW9kYWxNYWluQ29udGFpbmVyRWxlbWVudCIsIm1vZGFsQ29udGFpbmVyRWxlbWVudCIsIm1vZGFsVGl0bGVDb25haW5lckVsZW1lbnQiLCJtb2RhbFRpdGxlRWxlbWVudCIsIm1vZGFsQ2xvc2VFbGVtZW50IiwibW9kYWxJbnB1dEVsZW1lbnQiLCJwbGFjZWhvbGRlciIsIm1vZGFsU3VibWl0RWxlbWVudCIsInN0b3BQcm9wYWdhdGlvbiIsImlucHV0VGV4dCIsImNhdGVnb3J5T2JqIiwib25TaGFwZUNsaWNrQ2FsbGJhY2siLCJjYXRlZ29yeVRpdGxlIiwiY2F0ZWdvcnlOYW1lIiwic2hhcGVzIiwiZHJhdyIsInNoYXBlQ2xpY2tMaXN0ZW5lciIsImNhdGVnb3J5VGl0bGVFbGVtZW50Iiwic2hhcGVzVWxFbGVtZW50Iiwic2hhcGUiLCJzaGFwZUxpRWxlbWVudCIsIm5hbWUiLCJzaGFwZUltYWdlRWxlbWVudCIsInNyYyIsInVyaSIsImV4IiwiZXkiLCJjeCIsImN5IiwiZHkiLCJkeCIsInRoZXRhIiwiTWF0aCIsImF0YW4yIiwiUEkiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7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QTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzQ0FBc0M7QUFDM0M7QUFDQSxLQUFLLHVDQUF1QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLLHNDQUFzQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0RBQXdEO0FBQzdEO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUssdUNBQXVDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0Msb0NBQW9DLFFBQVE7QUFDNUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUEsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsMEJBQTBCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLDJEQUEyRDtBQUMxRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLDZFQUE2RTtBQUM1RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLHVJQUF1STtBQUN0SixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0MsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQkFBa0I7QUFDbEI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkRBQTZELE9BQU87QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RCxPQUFPOztBQUUvRDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQSxzREFBc0QsT0FBTztBQUM3RCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FB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S0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBK0QsT0FBTztBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGlHQUFpRztBQUNqRztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLE9BQU87QUFDaEM7O0FBRUEsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixZQUFZOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixPQUFPOztBQUU5QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlO0FBQ2Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixXQUFXO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsWUFBWTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7O0FBRUE7O0FBRUE7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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRSxVQUFVO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVCQUF1QixpQkFBaUI7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7O0FBRUEsOENBQThDLE9BQU87QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFlBQVk7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLE9BQU87QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EOztBQUVBOztBQUVBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUM5Rjs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FB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QUNBO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxPQUFPO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztB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Q0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLGtJQUFrSTtBQUNqSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsMktBQTJLO0FBQzFMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLGtJQUFrSTtBQUNqSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxzREFBc0QsY0FBYztBQUNwRTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFlBQVk7QUFDckM7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQWM7QUFDaEM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBTztBQUMvQixPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLElBQXlDLFNBQVMsaUNBQU8sQ0FBQyxPQUFTLENBQUMsb0NBQUUsR0FBRztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUN0RiwwQ0FBMEM7QUFDMUMsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLGtCQUFrQjtBQUNoRCwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEZBQTRGO0FBQzVGLDhCQUE4Qjs7QUFFOUIsMkJBQTJCLGdCQUFnQjs7QUFFM0MsOEJBQThCLGFBQWE7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHFDQUFxQzs7QUFFckMsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxnREFBZ0Q7QUFDN0Y7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELE9BQU87QUFDbEU7QUFDQTtBQUNBLGlEQUFpRCwwQ0FBMEMsbURBQW1EO0FBQzlJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2REFBNkQsb0VBQW9FO0FBQzlLO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UseUNBQXlDO0FBQ2pIO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsbUJBQW1CO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixtQkFBbUI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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REFBTSxDQUFDb0IsUUFEakI7QUFFSThJLE9BQUcsRUFBRTtBQUZULEdBekNJLEVBNkNKO0FBQ0lILFFBQUksRUFBRS9KLGlEQUFNLENBQUNFLFdBRGpCO0FBRUlnSyxPQUFHLEVBQUU7QUFGVCxHQTdDSSxFQWlESjtBQUNJSCxRQUFJLEVBQUUvSixpREFBTSxDQUFDRyxXQURqQjtBQUVJK0osT0FBRyxFQUFFO0FBRlQsR0FqREksRUFxREo7QUFDSUgsUUFBSSxFQUFFL0osaURBQU0sQ0FBQ0ssV0FEakI7QUFFSTZKLE9BQUcsRUFBRTtBQUZULEdBckRJLEVBeURKO0FBQ0lILFFBQUksRUFBRS9KLGlEQUFNLENBQUNlLE1BRGpCO0FBRUltSixPQUFHLEVBQUU7QUFGVCxHQXpESSxFQTZESjtBQUNJSCxRQUFJLEVBQUUvSixpREFBTSxDQUFDVyxNQURqQjtBQUVJdUosT0FBRyxFQUFFO0FBRlQsR0E3REk7QUFGWCxDQURvQixDQUFyQjtBQXdFZXRQLDBFQUFmLEU7Ozs7Ozs7Ozs7OztBQzFFQTtBQUFBO0FBQU8sU0FBUzZKLFdBQVQsQ0FBcUIwRixFQUFyQixFQUF3QkMsRUFBeEIsRUFBMkJDLEVBQTNCLEVBQThCQyxFQUE5QixFQUFrQztBQUN2QyxNQUFJQyxFQUFFLEdBQUdILEVBQUUsR0FBR0UsRUFBZDtBQUNBLE1BQUlFLEVBQUUsR0FBR0wsRUFBRSxHQUFHRSxFQUFkO0FBQ0EsTUFBSUksS0FBSyxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0osRUFBWCxFQUFlQyxFQUFmLENBQVo7QUFDQUMsT0FBSyxJQUFJLE1BQU1DLElBQUksQ0FBQ0UsRUFBcEI7QUFDQSxTQUFPSCxLQUFQO0FBQ0QsQzs7Ozs7Ozs7Ozs7QUNORCx1Qzs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGUiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3QvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LmpzXCIpO1xuIiwiLy8gUmVzZXJ2ZWQgd29yZCBsaXN0cyBmb3IgdmFyaW91cyBkaWFsZWN0cyBvZiB0aGUgbGFuZ3VhZ2VcblxudmFyIHJlc2VydmVkV29yZHMgPSB7XG4gIDM6IFwiYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZVwiLFxuICA1OiBcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIsXG4gIDY6IFwiZW51bVwiLFxuICBzdHJpY3Q6IFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiLFxuICBzdHJpY3RCaW5kOiBcImV2YWwgYXJndW1lbnRzXCJcbn07XG5cbi8vIEFuZCB0aGUga2V5d29yZHNcblxudmFyIGVjbWE1QW5kTGVzc0tleXdvcmRzID0gXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIjtcblxudmFyIGtleXdvcmRzID0ge1xuICA1OiBlY21hNUFuZExlc3NLZXl3b3JkcyxcbiAgXCI1bW9kdWxlXCI6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgZXhwb3J0IGltcG9ydFwiLFxuICA2OiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGNvbnN0IGNsYXNzIGV4dGVuZHMgZXhwb3J0IGltcG9ydCBzdXBlclwiXG59O1xuXG52YXIga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9eaW4oc3RhbmNlb2YpPyQvO1xuXG4vLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cbi8vIEdlbmVyYXRlZCBieSBgYmluL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNgLlxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNWQwLVxcdTA1ZWFcXHUwNWVmLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDhhMC1cXHUwOGI0XFx1MDhiNi1cXHUwOGJkXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmVmXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3YmZcXHVhN2MyLVxcdWE3YzZcXHVhN2Y3LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY3XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTIwMGNcXHUyMDBkXFx4YjdcXHUwMzAwLVxcdTAzNmZcXHUwMzg3XFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjY5XFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDZmMC1cXHUwNmY5XFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3YzAtXFx1MDdjOVxcdTA3ZWItXFx1MDdmM1xcdTA3ZmRcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODU5LVxcdTA4NWJcXHUwOGQzLVxcdTA4ZTFcXHUwOGUzLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTA5ZTYtXFx1MDllZlxcdTA5ZmVcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBhZmEtXFx1MGFmZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDAtXFx1MGMwNFxcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZTYtXFx1MGRlZlxcdTBkZjJcXHUwZGYzXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlYjFcXHUwZWI0LVxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmM2VcXHUwZjNmXFx1MGY3MS1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyYi1cXHUxMDNlXFx1MTA0MC1cXHUxMDQ5XFx1MTA1Ni1cXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTM2OS1cXHUxMzcxXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjQtXFx1MTdkM1xcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOGE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk0Ni1cXHUxOTRmXFx1MTlkMC1cXHUxOWRhXFx1MWExNy1cXHUxYTFiXFx1MWE1NS1cXHUxYTVlXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWFiMC1cXHUxYWJkXFx1MWIwMC1cXHUxYjA0XFx1MWIzNC1cXHUxYjQ0XFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWI4MC1cXHUxYjgyXFx1MWJhMS1cXHUxYmFkXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMyNC1cXHUxYzM3XFx1MWM0MC1cXHUxYzQ5XFx1MWM1MC1cXHUxYzU5XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2U4XFx1MWNlZFxcdTFjZjRcXHUxY2Y3LVxcdTFjZjlcXHUxZGMwLVxcdTFkZjlcXHUxZGZiLVxcdTFkZmZcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTYyMC1cXHVhNjI5XFx1YTY2ZlxcdWE2NzQtXFx1YTY3ZFxcdWE2OWVcXHVhNjlmXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbnZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG5ub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBudWxsO1xuXG4vLyBUaGVzZSBhcmUgYSBydW4tbGVuZ3RoIGFuZCBvZmZzZXQgZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbi8vID4weGZmZmYgY29kZSBwb2ludHMgdGhhdCBhcmUgYSB2YWxpZCBwYXJ0IG9mIGlkZW50aWZpZXJzLiBUaGVcbi8vIG9mZnNldCBzdGFydHMgYXQgMHgxMDAwMCwgYW5kIGVhY2ggcGFpciBvZiBudW1iZXJzIHJlcHJlc2VudHMgYW5cbi8vIG9mZnNldCB0byB0aGUgbmV4dCByYW5nZSwgYW5kIHRoZW4gYSBzaXplIG9mIHRoZSByYW5nZS4gVGhleSB3ZXJlXG4vLyBnZW5lcmF0ZWQgYnkgYmluL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbW1hLXNwYWNpbmdcbnZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLDExLDIsMjUsMiwxOCwyLDEsMiwxNCwzLDEzLDM1LDEyMiw3MCw1MiwyNjgsMjgsNCw0OCw0OCwzMSwxNCwyOSw2LDM3LDExLDI5LDMsMzUsNSw3LDIsNCw0MywxNTcsMTksMzUsNSwzNSw1LDM5LDksNTEsMTU3LDMxMCwxMCwyMSwxMSw3LDE1Myw1LDMsMCwyLDQzLDIsMSw0LDAsMywyMiwxMSwyMiwxMCwzMCw2NiwxOCwyLDEsMTEsMjEsMTEsMjUsNzEsNTUsNywxLDY1LDAsMTYsMywyLDIsMiwyOCw0MywyOCw0LDI4LDM2LDcsMiwyNywyOCw1MywxMSwyMSwxMSwxOCwxNCwxNywxMTEsNzIsNTYsNTAsMTQsNTAsMTQsMzUsNDc3LDI4LDExLDAsOSwyMSwxNTUsMjIsMTMsNTIsNzYsNDQsMzMsMjQsMjcsMzUsMzAsMCwxMiwzNCw0LDAsMTMsNDcsMTUsMywyMiwwLDIsMCwzNiwxNywyLDI0LDg1LDYsMiwwLDIsMywyLDE0LDIsOSw4LDQ2LDM5LDcsMywxLDMsMjEsMiw2LDIsMSwyLDQsNCwwLDE5LDAsMTMsNCwxNTksNTIsMTksMywyMSwwLDMzLDQ3LDIxLDEsMiwwLDE4NSw0Niw0MiwzLDM3LDQ3LDIxLDAsNjAsNDIsMTQsMCw3MiwyNiwyMzAsNDMsMTE3LDYzLDMyLDAsMTYxLDcsMywzOCwxNywwLDIsMCwyOSwwLDExLDM5LDgsMCwyMiwwLDEyLDQ1LDIwLDAsMzUsNTYsMjY0LDgsMiwzNiwxOCwwLDUwLDI5LDExMyw2LDIsMSwyLDM3LDIyLDAsMjYsNSwyLDEsMiwzMSwxNSwwLDMyOCwxOCwyNzAsOTIxLDEwMywxMTAsMTgsMTk1LDI3NDksMTA3MCw0MDUwLDU4Miw4NjM0LDU2OCw4LDMwLDExNCwyOSwxOSw0NywxNywzLDMyLDIwLDYsMTgsNjg5LDYzLDEyOSw3NCw2LDAsNjcsMTIsNjUsMSwyLDAsMjksNjEzNSw5LDc1NCw5NDg2LDI4Niw1MCwyLDE4LDMsOSwzOTUsMjMwOSwxMDYsNiwxMiw0LDgsOCw5LDU5OTEsODQsMiw3MCwyLDEsMywwLDMsMSwzLDMsMiwxMSwyLDAsMiw2LDIsNjQsMiwzLDMsNywyLDYsMiwyNywyLDMsMiw0LDIsMCw0LDYsMiwzMzksMywyNCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDcsMjM1Nyw0NCwxMSw2LDE3LDAsMzcwLDQzLDEzMDEsMTk2LDYwLDY3LDgsMCwxMjA1LDMsMiwyNiwyLDEsMiwwLDMsMCwyLDksMiwzLDIsMCwyLDAsNywwLDUsMCwyLDAsMiwwLDIsMiwyLDEsMiwwLDMsMCwyLDAsMiwwLDIsMCwyLDAsMiwxLDIsMCwzLDMsMiw2LDIsMywyLDMsMiwwLDIsOSwyLDE2LDYsMiwyLDQsMiwxNiw0NDIxLDQyNzEwLDQyLDQxNDgsMTIsMjIxLDMsNTc2MSwxNSw3NDcyLDMxMDQsNTQxXTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbW1hLXNwYWNpbmdcbnZhciBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LDAsMjI3LDAsMTUwLDQsMjk0LDksMTM2OCwyLDIsMSw2LDMsNDEsMiw1LDAsMTY2LDEsNTc0LDMsOSw5LDUyNSwxMCwxNzYsMiw1NCwxNCwzMiw5LDE2LDMsNDYsMTAsNTQsOSw3LDIsMzcsMTMsMiw5LDYsMSw0NSwwLDEzLDIsNDksMTMsOSwzLDQsOSw4MywxMSw3LDAsMTYxLDExLDYsOSw3LDMsNTYsMSwyLDYsMywxLDMsMiwxMCwwLDExLDEsMyw2LDQsNCwxOTMsMTcsMTAsOSw1LDAsODIsMTksMTMsOSwyMTQsNiwzLDgsMjgsMSw4MywxNiwxNiw5LDgyLDEyLDksOSw4NCwxNCw1LDksMjQzLDE0LDE2Niw5LDIzMiw2LDMsNiw0LDAsMjksOSw0MSw2LDIsMyw5LDAsMTAsMTAsNDcsMTUsNDA2LDcsMiw3LDE3LDksNTcsMjEsMiwxMywxMjMsNSw0LDAsMiwxLDIsNiwyLDAsOSw5LDQ5LDQsMiwxLDIsNCw5LDksMzMwLDMsMTkzMDYsOSwxMzUsNCw2MCw2LDI2LDksMTAxNCwwLDIsNTQsOCwzLDE5NzIzLDEsNTMxOSw0LDQsNSw5LDcsMyw2LDMxLDMsMTQ5LDIsMTQxOCw0OSw1MTMsNTQsNSw0OSw5LDAsMTUsMCwyMyw0LDIsMTQsMTM2MSw2LDIsMTYsMyw2LDIsMSwyLDQsMjYyLDYsMTAsOSw0MTksMTMsMTQ5NSw2LDExMCw2LDYsOSw3OTI0ODcsMjM5XTtcblxuLy8gVGhpcyBoYXMgYSBjb21wbGV4aXR5IGxpbmVhciB0byB0aGUgdmFsdWUgb2YgdGhlIGNvZGUuIFRoZVxuLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuLy8gcmFyZS5cbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIHZhciBwb3MgPSAweDEwMDAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHBvcyArPSBzZXRbaV07XG4gICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICBpZiAocG9zID49IGNvZGUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBjb2RlIHN0YXJ0cyBhbiBpZGVudGlmaWVyLlxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlLCBhc3RyYWwpIHtcbiAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2Rlcylcbn1cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlLCBhc3RyYWwpIHtcbiAgaWYgKGNvZGUgPCA0OCkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICBpZiAoY29kZSA8IDU4KSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKVxufVxuXG4vLyAjIyBUb2tlbiB0eXBlc1xuXG4vLyBUaGUgYXNzaWdubWVudCBvZiBmaW5lLWdyYWluZWQsIGluZm9ybWF0aW9uLWNhcnJ5aW5nIHR5cGUgb2JqZWN0c1xuLy8gYWxsb3dzIHRoZSB0b2tlbml6ZXIgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGl0IGhhcyBhYm91dCBhXG4vLyB0b2tlbiBpbiBhIHdheSB0aGF0IGlzIHZlcnkgY2hlYXAgZm9yIHRoZSBwYXJzZXIgdG8gbG9vayB1cC5cblxuLy8gQWxsIHRva2VuIHR5cGUgdmFyaWFibGVzIHN0YXJ0IHdpdGggYW4gdW5kZXJzY29yZSwgdG8gbWFrZSB0aGVtXG4vLyBlYXN5IHRvIHJlY29nbml6ZS5cblxuLy8gVGhlIGBiZWZvcmVFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuIHJlZ3VsYXJcbi8vIGV4cHJlc3Npb25zIGFuZCBkaXZpc2lvbnMuIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBjYW5cbi8vIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gKHRodXMsIGEgc2xhc2ggYWZ0ZXIgdGhlbSB3b3VsZCBiZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24pLlxuLy9cbi8vIFRoZSBgc3RhcnRzRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBjaGVjayBpZiB0aGUgdG9rZW4gZW5kcyBhXG4vLyBgeWllbGRgIGV4cHJlc3Npb24uIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBlaXRoZXIgY2FuXG4vLyBkaXJlY3RseSBzdGFydCBhbiBleHByZXNzaW9uIChsaWtlIGEgcXVvdGF0aW9uIG1hcmspIG9yIGNhblxuLy8gY29udGludWUgYW4gZXhwcmVzc2lvbiAobGlrZSB0aGUgYm9keSBvZiBhIHN0cmluZykuXG4vL1xuLy8gYGlzTG9vcGAgbWFya3MgYSBrZXl3b3JkIGFzIHN0YXJ0aW5nIGEgbG9vcCwgd2hpY2ggaXMgaW1wb3J0YW50XG4vLyB0byBrbm93IHdoZW4gcGFyc2luZyBhIGxhYmVsLCBpbiBvcmRlciB0byBhbGxvdyBvciBkaXNhbGxvd1xuLy8gY29udGludWUganVtcHMgdG8gdGhhdCBsYWJlbC5cblxudmFyIFRva2VuVHlwZSA9IGZ1bmN0aW9uIFRva2VuVHlwZShsYWJlbCwgY29uZikge1xuICBpZiAoIGNvbmYgPT09IHZvaWQgMCApIGNvbmYgPSB7fTtcblxuICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZDtcbiAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICB0aGlzLmlzTG9vcCA9ICEhY29uZi5pc0xvb3A7XG4gIHRoaXMuaXNBc3NpZ24gPSAhIWNvbmYuaXNBc3NpZ247XG4gIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgdGhpcy5wb3N0Zml4ID0gISFjb25mLnBvc3RmaXg7XG4gIHRoaXMuYmlub3AgPSBjb25mLmJpbm9wIHx8IG51bGw7XG4gIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG59O1xuXG5mdW5jdGlvbiBiaW5vcChuYW1lLCBwcmVjKSB7XG4gIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogcHJlY30pXG59XG52YXIgYmVmb3JlRXhwciA9IHtiZWZvcmVFeHByOiB0cnVlfSwgc3RhcnRzRXhwciA9IHtzdGFydHNFeHByOiB0cnVlfTtcblxuLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbnZhciBrZXl3b3JkcyQxID0ge307XG5cbi8vIFN1Y2NpbmN0IGRlZmluaXRpb25zIG9mIGtleXdvcmQgdG9rZW4gdHlwZXNcbmZ1bmN0aW9uIGt3KG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgcmV0dXJuIGtleXdvcmRzJDFbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG59XG5cbnZhciB0eXBlcyA9IHtcbiAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHN0YXJ0c0V4cHIpLFxuICByZWdleHA6IG5ldyBUb2tlblR5cGUoXCJyZWdleHBcIiwgc3RhcnRzRXhwciksXG4gIHN0cmluZzogbmV3IFRva2VuVHlwZShcInN0cmluZ1wiLCBzdGFydHNFeHByKSxcbiAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgc3RhcnRzRXhwciksXG4gIGVvZjogbmV3IFRva2VuVHlwZShcImVvZlwiKSxcblxuICAvLyBQdW5jdHVhdGlvbiB0b2tlbiB0eXBlcy5cbiAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGJyYWNrZXRSOiBuZXcgVG9rZW5UeXBlKFwiXVwiKSxcbiAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICBwYXJlbkw6IG5ldyBUb2tlblR5cGUoXCIoXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgc2VtaTogbmV3IFRva2VuVHlwZShcIjtcIiwgYmVmb3JlRXhwciksXG4gIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgcXVlc3Rpb246IG5ldyBUb2tlblR5cGUoXCI/XCIsIGJlZm9yZUV4cHIpLFxuICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIGJlZm9yZUV4cHIpLFxuICB0ZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcInRlbXBsYXRlXCIpLFxuICBpbnZhbGlkVGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJpbnZhbGlkVGVtcGxhdGVcIiksXG4gIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHN0YXJ0c0V4cHIpLFxuICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG4gIC8vIE9wZXJhdG9ycy4gVGhlc2UgY2Fycnkgc2V2ZXJhbCBraW5kcyBvZiBwcm9wZXJ0aWVzIHRvIGhlbHAgdGhlXG4gIC8vIHBhcnNlciB1c2UgdGhlbSBwcm9wZXJseSAodGhlIHByZXNlbmNlIG9mIHRoZXNlIHByb3BlcnRpZXMgaXNcbiAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gIC8vXG4gIC8vIGBiaW5vcGAsIHdoZW4gcHJlc2VudCwgc3BlY2lmaWVzIHRoYXQgdGhpcyBvcGVyYXRvciBpcyBhIGJpbmFyeVxuICAvLyBvcGVyYXRvciwgYW5kIHdpbGwgcmVmZXIgdG8gaXRzIHByZWNlZGVuY2UuXG4gIC8vXG4gIC8vIGBwcmVmaXhgIGFuZCBgcG9zdGZpeGAgbWFyayB0aGUgb3BlcmF0b3IgYXMgYSBwcmVmaXggb3IgcG9zdGZpeFxuICAvLyB1bmFyeSBvcGVyYXRvci5cbiAgLy9cbiAgLy8gYGlzQXNzaWduYCBtYXJrcyBhbGwgb2YgYD1gLCBgKz1gLCBgLT1gIGV0Y2V0ZXJhLCB3aGljaCBhY3QgYXNcbiAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gIC8vIGluIEFzc2lnbm1lbnRFeHByZXNzaW9uIG5vZGVzLlxuXG4gIGVxOiBuZXcgVG9rZW5UeXBlKFwiPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHtwcmVmaXg6IHRydWUsIHBvc3RmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgcHJlZml4OiBuZXcgVG9rZW5UeXBlKFwiIS9+XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICBsb2dpY2FsQU5EOiBiaW5vcChcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IGJpbm9wKFwifFwiLCAzKSxcbiAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICBiaXR3aXNlQU5EOiBiaW5vcChcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBiaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICBiaXRTaGlmdDogYmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA5LCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICBzbGFzaDogYmlub3AoXCIvXCIsIDEwKSxcbiAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuXG4gIC8vIEtleXdvcmQgdG9rZW4gdHlwZXMuXG4gIF9icmVhazoga3coXCJicmVha1wiKSxcbiAgX2Nhc2U6IGt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKSxcbiAgX2NhdGNoOiBrdyhcImNhdGNoXCIpLFxuICBfY29udGludWU6IGt3KFwiY29udGludWVcIiksXG4gIF9kZWJ1Z2dlcjoga3coXCJkZWJ1Z2dlclwiKSxcbiAgX2RlZmF1bHQ6IGt3KFwiZGVmYXVsdFwiLCBiZWZvcmVFeHByKSxcbiAgX2RvOiBrdyhcImRvXCIsIHtpc0xvb3A6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9KSxcbiAgX2Vsc2U6IGt3KFwiZWxzZVwiLCBiZWZvcmVFeHByKSxcbiAgX2ZpbmFsbHk6IGt3KFwiZmluYWxseVwiKSxcbiAgX2Zvcjoga3coXCJmb3JcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICBfZnVuY3Rpb246IGt3KFwiZnVuY3Rpb25cIiwgc3RhcnRzRXhwciksXG4gIF9pZjoga3coXCJpZlwiKSxcbiAgX3JldHVybjoga3coXCJyZXR1cm5cIiwgYmVmb3JlRXhwciksXG4gIF9zd2l0Y2g6IGt3KFwic3dpdGNoXCIpLFxuICBfdGhyb3c6IGt3KFwidGhyb3dcIiwgYmVmb3JlRXhwciksXG4gIF90cnk6IGt3KFwidHJ5XCIpLFxuICBfdmFyOiBrdyhcInZhclwiKSxcbiAgX2NvbnN0OiBrdyhcImNvbnN0XCIpLFxuICBfd2hpbGU6IGt3KFwid2hpbGVcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICBfd2l0aDoga3coXCJ3aXRoXCIpLFxuICBfbmV3OiBrdyhcIm5ld1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfdGhpczoga3coXCJ0aGlzXCIsIHN0YXJ0c0V4cHIpLFxuICBfc3VwZXI6IGt3KFwic3VwZXJcIiwgc3RhcnRzRXhwciksXG4gIF9jbGFzczoga3coXCJjbGFzc1wiLCBzdGFydHNFeHByKSxcbiAgX2V4dGVuZHM6IGt3KFwiZXh0ZW5kc1wiLCBiZWZvcmVFeHByKSxcbiAgX2V4cG9ydDoga3coXCJleHBvcnRcIiksXG4gIF9pbXBvcnQ6IGt3KFwiaW1wb3J0XCIsIHN0YXJ0c0V4cHIpLFxuICBfbnVsbDoga3coXCJudWxsXCIsIHN0YXJ0c0V4cHIpLFxuICBfdHJ1ZToga3coXCJ0cnVlXCIsIHN0YXJ0c0V4cHIpLFxuICBfZmFsc2U6IGt3KFwiZmFsc2VcIiwgc3RhcnRzRXhwciksXG4gIF9pbjoga3coXCJpblwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgX2luc3RhbmNlb2Y6IGt3KFwiaW5zdGFuY2VvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgX3R5cGVvZjoga3coXCJ0eXBlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfdm9pZDoga3coXCJ2b2lkXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgX2RlbGV0ZToga3coXCJkZWxldGVcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pXG59O1xuXG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxudmFyIGxpbmVCcmVhayA9IC9cXHJcXG4/fFxcbnxcXHUyMDI4fFxcdTIwMjkvO1xudmFyIGxpbmVCcmVha0cgPSBuZXcgUmVnRXhwKGxpbmVCcmVhay5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUsIGVjbWEyMDE5U3RyaW5nKSB7XG4gIHJldHVybiBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMyB8fCAoIWVjbWEyMDE5U3RyaW5nICYmIChjb2RlID09PSAweDIwMjggfHwgY29kZSA9PT0gMHgyMDI5KSlcbn1cblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLztcblxudmFyIHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5cbnZhciByZWYgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGhhc093blByb3BlcnR5ID0gcmVmLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gcmVmLnRvU3RyaW5nO1xuXG4vLyBDaGVja3MgaWYgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuXG5mdW5jdGlvbiBoYXMob2JqLCBwcm9wTmFtZSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BOYW1lKVxufVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChcbiAgdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCJcbik7IH0pO1xuXG5mdW5jdGlvbiB3b3Jkc1JlZ2V4cCh3b3Jkcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLnJlcGxhY2UoLyAvZywgXCJ8XCIpICsgXCIpJFwiKVxufVxuXG4vLyBUaGVzZSBhcmUgdXNlZCB3aGVuIGBvcHRpb25zLmxvY2F0aW9uc2AgaXMgb24sIGZvciB0aGVcbi8vIGBzdGFydExvY2AgYW5kIGBlbmRMb2NgIHByb3BlcnRpZXMuXG5cbnZhciBQb3NpdGlvbiA9IGZ1bmN0aW9uIFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuICB0aGlzLmxpbmUgPSBsaW5lO1xuICB0aGlzLmNvbHVtbiA9IGNvbDtcbn07XG5cblBvc2l0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQgKG4pIHtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmxpbmUsIHRoaXMuY29sdW1uICsgbilcbn07XG5cbnZhciBTb3VyY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHAsIHN0YXJ0LCBlbmQpIHtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICB0aGlzLmVuZCA9IGVuZDtcbiAgaWYgKHAuc291cmNlRmlsZSAhPT0gbnVsbCkgeyB0aGlzLnNvdXJjZSA9IHAuc291cmNlRmlsZTsgfVxufTtcblxuLy8gVGhlIGBnZXRMaW5lSW5mb2AgZnVuY3Rpb24gaXMgbW9zdGx5IHVzZWZ1bCB3aGVuIHRoZVxuLy8gYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9mZiAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpIGFuZCB5b3Vcbi8vIHdhbnQgdG8gZmluZCB0aGUgbGluZS9jb2x1bW4gcG9zaXRpb24gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4vLyBvZmZzZXQuIGBpbnB1dGAgc2hvdWxkIGJlIHRoZSBjb2RlIHN0cmluZyB0aGF0IHRoZSBvZmZzZXQgcmVmZXJzXG4vLyBpbnRvLlxuXG5mdW5jdGlvbiBnZXRMaW5lSW5mbyhpbnB1dCwgb2Zmc2V0KSB7XG4gIGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IGN1cjtcbiAgICB2YXIgbWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA8IG9mZnNldCkge1xuICAgICAgKytsaW5lO1xuICAgICAgY3VyID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obGluZSwgb2Zmc2V0IC0gY3VyKVxuICAgIH1cbiAgfVxufVxuXG4vLyBBIHNlY29uZCBvcHRpb25hbCBhcmd1bWVudCBjYW4gYmUgZ2l2ZW4gdG8gZnVydGhlciBjb25maWd1cmVcbi8vIHRoZSBwYXJzZXIgcHJvY2Vzcy4gVGhlc2Ugb3B0aW9ucyBhcmUgcmVjb2duaXplZDpcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAvLyBgZWNtYVZlcnNpb25gIGluZGljYXRlcyB0aGUgRUNNQVNjcmlwdCB2ZXJzaW9uIHRvIHBhcnNlLiBNdXN0IGJlXG4gIC8vIGVpdGhlciAzLCA1LCA2ICgyMDE1KSwgNyAoMjAxNiksIDggKDIwMTcpLCA5ICgyMDE4KSwgb3IgMTBcbiAgLy8gKDIwMTkpLiBUaGlzIGluZmx1ZW5jZXMgc3VwcG9ydCBmb3Igc3RyaWN0IG1vZGUsIHRoZSBzZXQgb2ZcbiAgLy8gcmVzZXJ2ZWQgd29yZHMsIGFuZCBzdXBwb3J0IGZvciBuZXcgc3ludGF4IGZlYXR1cmVzLiBUaGUgZGVmYXVsdFxuICAvLyBpcyA5LlxuICBlY21hVmVyc2lvbjogOSxcbiAgLy8gYHNvdXJjZVR5cGVgIGluZGljYXRlcyB0aGUgbW9kZSB0aGUgY29kZSBzaG91bGQgYmUgcGFyc2VkIGluLlxuICAvLyBDYW4gYmUgZWl0aGVyIGBcInNjcmlwdFwiYCBvciBgXCJtb2R1bGVcImAuIFRoaXMgaW5mbHVlbmNlcyBnbG9iYWxcbiAgLy8gc3RyaWN0IG1vZGUgYW5kIHBhcnNpbmcgb2YgYGltcG9ydGAgYW5kIGBleHBvcnRgIGRlY2xhcmF0aW9ucy5cbiAgc291cmNlVHlwZTogXCJzY3JpcHRcIixcbiAgLy8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gIGNhbiBiZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWRcbiAgLy8gd2hlbiBhIHNlbWljb2xvbiBpcyBhdXRvbWF0aWNhbGx5IGluc2VydGVkLiBJdCB3aWxsIGJlIHBhc3NlZFxuICAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbW1hIGFzIGFuIG9mZnNldCwgYW5kIGlmIGBsb2NhdGlvbnNgIGlzXG4gIC8vIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSwgY29sdW1ufWAgb2JqZWN0XG4gIC8vIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gIC8vIGFuIG9mZi4gV2hlbiB0aGlzIG9wdGlvbiBoYXMgdGhlIHZhbHVlIFwibmV2ZXJcIiwgcmVzZXJ2ZWQgd29yZHNcbiAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIGEgcmV0dXJuIGF0IHRoZSB0b3AgbGV2ZWwgaXMgbm90IGNvbnNpZGVyZWQgYW5cbiAgLy8gZXJyb3IuXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBpbXBvcnQvZXhwb3J0IHN0YXRlbWVudHMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbS5cbiAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBhd2FpdCBpZGVudGlmaWVycyBhcmUgYWxsb3dlZCB0byBhcHBlYXIgYXQgdGhlIHRvcC1sZXZlbCBzY29wZSxcbiAgLy8gYnV0IHRoZXkgYXJlIHN0aWxsIG5vdCBhbGxvd2VkIGluIG5vbi1hc3luYyBmdW5jdGlvbnMuXG4gIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAvLyBXaGVuIGVuYWJsZWQsIGhhc2hiYW5nIGRpcmVjdGl2ZSBpbiB0aGUgYmVnaW5uaW5nIG9mIGZpbGVcbiAgLy8gaXMgYWxsb3dlZCBhbmQgdHJlYXRlZCBhcyBhIGxpbmUgY29tbWVudC5cbiAgYWxsb3dIYXNoQmFuZzogZmFsc2UsXG4gIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIGBsb2NgIHByb3BlcnRpZXMgaG9sZGluZyBvYmplY3RzIHdpdGhcbiAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyBpbiBge2xpbmUsIGNvbHVtbn1gIGZvcm0gKHdpdGhcbiAgLy8gbGluZSBiZWluZyAxLWJhc2VkIGFuZCBjb2x1bW4gMC1iYXNlZCkgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGVcbiAgLy8gbm9kZXMuXG4gIGxvY2F0aW9uczogZmFsc2UsXG4gIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Ub2tlbmAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIG9iamVjdCBpbiB0aGUgc2FtZVxuICAvLyBmb3JtYXQgYXMgdG9rZW5zIHJldHVybmVkIGZyb20gYHRva2VuaXplcigpLmdldFRva2VuKClgLiBOb3RlXG4gIC8vIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZSBwYXJzZXIgZnJvbSB0aGVcbiAgLy8gY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gIG9uVG9rZW46IG51bGwsXG4gIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Db21tZW50YCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggYChibG9jaywgdGV4dCwgc3RhcnQsXG4gIC8vIGVuZClgIHBhcmFtZXRlcnMgd2hlbmV2ZXIgYSBjb21tZW50IGlzIHNraXBwZWQuIGBibG9ja2AgaXMgYVxuICAvLyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGlzIGEgYmxvY2sgKGAvKiAqL2ApIGNvbW1lbnQsXG4gIC8vIGB0ZXh0YCBpcyB0aGUgY29udGVudCBvZiB0aGUgY29tbWVudCwgYW5kIGBzdGFydGAgYW5kIGBlbmRgIGFyZVxuICAvLyBjaGFyYWN0ZXIgb2Zmc2V0cyB0aGF0IGRlbm90ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgY29tbWVudC5cbiAgLy8gV2hlbiB0aGUgYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9uLCB0d28gbW9yZSBwYXJhbWV0ZXJzIGFyZVxuICAvLyBwYXNzZWQsIHRoZSBmdWxsIGB7bGluZSwgY29sdW1ufWAgbG9jYXRpb25zIG9mIHRoZSBzdGFydCBhbmRcbiAgLy8gZW5kIG9mIHRoZSBjb21tZW50cy4gTm90ZSB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGVcbiAgLy8gcGFyc2VyIGZyb20gdGhlIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvbkNvbW1lbnQ6IG51bGwsXG4gIC8vIE5vZGVzIGhhdmUgdGhlaXIgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXJzIG9mZnNldHMgcmVjb3JkZWQgaW5cbiAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyAoZGlyZWN0bHkgb24gdGhlIG5vZGUsIHJhdGhlciB0aGFuXG4gIC8vIHRoZSBgbG9jYCBvYmplY3QsIHdoaWNoIGhvbGRzIGxpbmUvY29sdW1uIGRhdGEuIFRvIGFsc28gYWRkIGFcbiAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgLy8gZW5kXWAgYXJyYXkgd2l0aCB0aGUgc2FtZSBudW1iZXJzLCBzZXQgdGhlIGByYW5nZXNgIG9wdGlvbiB0b1xuICAvLyBgdHJ1ZWAuXG4gIC8vXG4gIC8vIFtyYW5nZV06IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc0NTY3OFxuICByYW5nZXM6IGZhbHNlLFxuICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAvLyBwYXNzaW5nIHRoZSB0cmVlIHByb2R1Y2VkIGJ5IHBhcnNpbmcgdGhlIGZpcnN0IGZpbGUgYXNcbiAgLy8gYHByb2dyYW1gIG9wdGlvbiBpbiBzdWJzZXF1ZW50IHBhcnNlcy4gVGhpcyB3aWxsIGFkZCB0aGVcbiAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAvLyBvZiBhbiBleGlzdGluZyBwYXJzZSB0cmVlLlxuICBwcm9ncmFtOiBudWxsLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAvLyBmaWxlIGluIGV2ZXJ5IG5vZGUncyBgbG9jYCBvYmplY3QuXG4gIHNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAvLyBgbG9jYXRpb25zYCBpcyBvbiBvciBvZmYuXG4gIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgLy8gKG5vbi1zdGFuZGFyZCkgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gbm9kZXNcbiAgcHJlc2VydmVQYXJlbnM6IGZhbHNlXG59O1xuXG4vLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gIHZhciBvcHRpb25zID0ge307XG5cbiAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgIHsgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBoYXMob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF07IH1cblxuICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSAyMDE1KVxuICAgIHsgb3B0aW9ucy5lY21hVmVyc2lvbiAtPSAyMDA5OyB9XG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PSBudWxsKVxuICAgIHsgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID0gb3B0aW9ucy5lY21hVmVyc2lvbiA8IDU7IH1cblxuICBpZiAoaXNBcnJheShvcHRpb25zLm9uVG9rZW4pKSB7XG4gICAgdmFyIHRva2VucyA9IG9wdGlvbnMub25Ub2tlbjtcbiAgICBvcHRpb25zLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2Vucy5wdXNoKHRva2VuKTsgfTtcbiAgfVxuICBpZiAoaXNBcnJheShvcHRpb25zLm9uQ29tbWVudCkpXG4gICAgeyBvcHRpb25zLm9uQ29tbWVudCA9IHB1c2hDb21tZW50KG9wdGlvbnMsIG9wdGlvbnMub25Db21tZW50KTsgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHB1c2hDb21tZW50KG9wdGlvbnMsIGFycmF5KSB7XG4gIHJldHVybiBmdW5jdGlvbihibG9jaywgdGV4dCwgc3RhcnQsIGVuZCwgc3RhcnRMb2MsIGVuZExvYykge1xuICAgIHZhciBjb21tZW50ID0ge1xuICAgICAgdHlwZTogYmxvY2sgPyBcIkJsb2NrXCIgOiBcIkxpbmVcIixcbiAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmRcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgY29tbWVudC5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24odGhpcywgc3RhcnRMb2MsIGVuZExvYyk7IH1cbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IGNvbW1lbnQucmFuZ2UgPSBbc3RhcnQsIGVuZF07IH1cbiAgICBhcnJheS5wdXNoKGNvbW1lbnQpO1xuICB9XG59XG5cbi8vIEVhY2ggc2NvcGUgZ2V0cyBhIGJpdHNldCB0aGF0IG1heSBjb250YWluIHRoZXNlIGZsYWdzXG52YXJcbiAgICBTQ09QRV9UT1AgPSAxLFxuICAgIFNDT1BFX0ZVTkNUSU9OID0gMixcbiAgICBTQ09QRV9WQVIgPSBTQ09QRV9UT1AgfCBTQ09QRV9GVU5DVElPTixcbiAgICBTQ09QRV9BU1lOQyA9IDQsXG4gICAgU0NPUEVfR0VORVJBVE9SID0gOCxcbiAgICBTQ09QRV9BUlJPVyA9IDE2LFxuICAgIFNDT1BFX1NJTVBMRV9DQVRDSCA9IDMyLFxuICAgIFNDT1BFX1NVUEVSID0gNjQsXG4gICAgU0NPUEVfRElSRUNUX1NVUEVSID0gMTI4O1xuXG5mdW5jdGlvbiBmdW5jdGlvbkZsYWdzKGFzeW5jLCBnZW5lcmF0b3IpIHtcbiAgcmV0dXJuIFNDT1BFX0ZVTkNUSU9OIHwgKGFzeW5jID8gU0NPUEVfQVNZTkMgOiAwKSB8IChnZW5lcmF0b3IgPyBTQ09QRV9HRU5FUkFUT1IgOiAwKVxufVxuXG4vLyBVc2VkIGluIGNoZWNrTFZhbCBhbmQgZGVjbGFyZU5hbWUgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgYmluZGluZ1xudmFyXG4gICAgQklORF9OT05FID0gMCwgLy8gTm90IGEgYmluZGluZ1xuICAgIEJJTkRfVkFSID0gMSwgLy8gVmFyLXN0eWxlIGJpbmRpbmdcbiAgICBCSU5EX0xFWElDQUwgPSAyLCAvLyBMZXQtIG9yIGNvbnN0LXN0eWxlIGJpbmRpbmdcbiAgICBCSU5EX0ZVTkNUSU9OID0gMywgLy8gRnVuY3Rpb24gZGVjbGFyYXRpb25cbiAgICBCSU5EX1NJTVBMRV9DQVRDSCA9IDQsIC8vIFNpbXBsZSAoaWRlbnRpZmllciBwYXR0ZXJuKSBjYXRjaCBiaW5kaW5nXG4gICAgQklORF9PVVRTSURFID0gNTsgLy8gU3BlY2lhbCBjYXNlIGZvciBmdW5jdGlvbiBuYW1lcyBhcyBib3VuZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG5cbnZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gIHRoaXMua2V5d29yZHMgPSB3b3Jkc1JlZ2V4cChrZXl3b3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiID8gXCI1bW9kdWxlXCIgOiA1XSk7XG4gIHZhciByZXNlcnZlZCA9IFwiXCI7XG4gIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IHRydWUpIHtcbiAgICBmb3IgKHZhciB2ID0gb3B0aW9ucy5lY21hVmVyc2lvbjs7IHYtLSlcbiAgICAgIHsgaWYgKHJlc2VydmVkID0gcmVzZXJ2ZWRXb3Jkc1t2XSkgeyBicmVhayB9IH1cbiAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgfVxuICB0aGlzLnJlc2VydmVkV29yZHMgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZCk7XG4gIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0O1xuICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCk7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbiAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgLy8gVXNlZCB0byBzaWduYWwgdG8gY2FsbGVycyBvZiBgcmVhZFdvcmQxYCB3aGV0aGVyIHRoZSB3b3JkXG4gIC8vIGNvbnRhaW5lZCBhbnkgZXNjYXBlIHNlcXVlbmNlcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB3b3JkcyB3aXRoXG4gIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgdG9rZW4gc3RhdGVcblxuICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgdG9rZW5pemVyIGluIHRoZSBpbnB1dC5cbiAgaWYgKHN0YXJ0UG9zKSB7XG4gICAgdGhpcy5wb3MgPSBzdGFydFBvcztcbiAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MgLSAxKSArIDE7XG4gICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pbnB1dC5zbGljZSgwLCB0aGlzLmxpbmVTdGFydCkuc3BsaXQobGluZUJyZWFrKS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgdGhpcy5jdXJMaW5lID0gMTtcbiAgfVxuXG4gIC8vIFByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdG9rZW46XG4gIC8vIEl0cyB0eXBlXG4gIHRoaXMudHlwZSA9IHR5cGVzLmVvZjtcbiAgLy8gRm9yIHRva2VucyB0aGF0IGluY2x1ZGUgbW9yZSBpbmZvcm1hdGlvbiB0aGFuIHRoZWlyIHR5cGUsIHRoZSB2YWx1ZVxuICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgLy8gSXRzIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0XG4gIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAvLyBBbmQsIGlmIGxvY2F0aW9ucyBhcmUgdXNlZCwgdGhlIHtsaW5lLCBjb2x1bW59IG9iamVjdFxuICAvLyBjb3JyZXNwb25kaW5nIHRvIHRob3NlIG9mZnNldHNcbiAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpO1xuXG4gIC8vIFBvc2l0aW9uIGluZm9ybWF0aW9uIGZvciB0aGUgcHJldmlvdXMgdG9rZW5cbiAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSBudWxsO1xuICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMubGFzdFRva0VuZCA9IHRoaXMucG9zO1xuXG4gIC8vIFRoZSBjb250ZXh0IHN0YWNrIGlzIHVzZWQgdG8gc3VwZXJmaWNpYWxseSB0cmFjayBzeW50YWN0aWNcbiAgLy8gY29udGV4dCB0byBwcmVkaWN0IHdoZXRoZXIgYSByZWd1bGFyIGV4cHJlc3Npb24gaXMgYWxsb3dlZCBpbiBhXG4gIC8vIGdpdmVuIHBvc2l0aW9uLlxuICB0aGlzLmNvbnRleHQgPSB0aGlzLmluaXRpYWxDb250ZXh0KCk7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgaXQncyBhIG1vZHVsZSBjb2RlLlxuICB0aGlzLmluTW9kdWxlID0gb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiO1xuICB0aGlzLnN0cmljdCA9IHRoaXMuaW5Nb2R1bGUgfHwgdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5wb3MpO1xuXG4gIC8vIFVzZWQgdG8gc2lnbmlmeSB0aGUgc3RhcnQgb2YgYSBwb3RlbnRpYWwgYXJyb3cgZnVuY3Rpb25cbiAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gLTE7XG5cbiAgLy8gUG9zaXRpb25zIHRvIGRlbGF5ZWQtY2hlY2sgdGhhdCB5aWVsZC9hd2FpdCBkb2VzIG5vdCBleGlzdCBpbiBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gIHRoaXMueWllbGRQb3MgPSB0aGlzLmF3YWl0UG9zID0gdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgLy8gTGFiZWxzIGluIHNjb3BlLlxuICB0aGlzLmxhYmVscyA9IFtdO1xuICAvLyBUaHVzLWZhciB1bmRlZmluZWQgZXhwb3J0cy5cbiAgdGhpcy51bmRlZmluZWRFeHBvcnRzID0ge307XG5cbiAgLy8gSWYgZW5hYmxlZCwgc2tpcCBsZWFkaW5nIGhhc2hiYW5nIGxpbmUuXG4gIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gXCIjIVwiKVxuICAgIHsgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7IH1cblxuICAvLyBTY29wZSB0cmFja2luZyBmb3IgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWVzIChzZWUgc2NvcGUuanMpXG4gIHRoaXMuc2NvcGVTdGFjayA9IFtdO1xuICB0aGlzLmVudGVyU2NvcGUoU0NPUEVfVE9QKTtcblxuICAvLyBGb3IgUmVnRXhwIHZhbGlkYXRpb25cbiAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBpbkZ1bmN0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluR2VuZXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQXN5bmM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd0RpcmVjdFN1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRyZWF0RnVuY3Rpb25zQXNWYXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLm9wdGlvbnMucHJvZ3JhbSB8fCB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHRUb2tlbigpO1xuICByZXR1cm4gdGhpcy5wYXJzZVRvcExldmVsKG5vZGUpXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuaW5GdW5jdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA+IDAgfTtcbnByb3RvdHlwZUFjY2Vzc29ycy5pbkdlbmVyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0dFTkVSQVRPUikgPiAwIH07XG5wcm90b3R5cGVBY2Nlc3NvcnMuaW5Bc3luYy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0FTWU5DKSA+IDAgfTtcbnByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd1N1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX1NVUEVSKSA+IDAgfTtcbnByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd0RpcmVjdFN1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0RJUkVDVF9TVVBFUikgPiAwIH07XG5wcm90b3R5cGVBY2Nlc3NvcnMudHJlYXRGdW5jdGlvbnNBc1Zhci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHRoaXMuY3VycmVudFNjb3BlKCkpIH07XG5cbi8vIFN3aXRjaCB0byBhIGdldHRlciBmb3IgNy4wLjAuXG5QYXJzZXIucHJvdG90eXBlLmluTm9uQXJyb3dGdW5jdGlvbiA9IGZ1bmN0aW9uIGluTm9uQXJyb3dGdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5cblBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKCkge1xuICAgIHZhciBwbHVnaW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIHBsdWdpbnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICB2YXIgY2xzID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7IGNscyA9IHBsdWdpbnNbaV0oY2xzKTsgfVxuICByZXR1cm4gY2xzXG59O1xuXG5QYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpXG59O1xuXG5QYXJzZXIucGFyc2VFeHByZXNzaW9uQXQgPSBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdCAoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICB2YXIgcGFyc2VyID0gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQsIHBvcyk7XG4gIHBhcnNlci5uZXh0VG9rZW4oKTtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZUV4cHJlc3Npb24oKVxufTtcblxuUGFyc2VyLnRva2VuaXplciA9IGZ1bmN0aW9uIHRva2VuaXplciAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFBhcnNlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgcHAgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbnZhciBsaXRlcmFsID0gL14oPzonKCg/OlxcXFwufFteJ10pKj8pJ3xcIigoPzpcXFxcLnxbXlwiXSkqPylcIikvO1xucHAuc3RyaWN0RGlyZWN0aXZlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgZm9yICg7Oykge1xuICAgIC8vIFRyeSB0byBmaW5kIHN0cmluZyBsaXRlcmFsLlxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgIHZhciBtYXRjaCA9IGxpdGVyYWwuZXhlYyh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0KSk7XG4gICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICgobWF0Y2hbMV0gfHwgbWF0Y2hbMl0pID09PSBcInVzZSBzdHJpY3RcIikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgc3RhcnQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuXG4gICAgLy8gU2tpcCBzZW1pY29sb24sIGlmIGFueS5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICBpZiAodGhpcy5pbnB1dFtzdGFydF0gPT09IFwiO1wiKVxuICAgICAgeyBzdGFydCsrOyB9XG4gIH1cbn07XG5cbi8vIFByZWRpY2F0ZSB0aGF0IHRlc3RzIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgb2YgdGhlIGdpdmVuXG4vLyB0eXBlLCBhbmQgaWYgeWVzLCBjb25zdW1lcyBpdCBhcyBhIHNpZGUgZWZmZWN0LlxuXG5wcC5lYXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG4vLyBUZXN0cyB3aGV0aGVyIHBhcnNlZCB0b2tlbiBpcyBhIGNvbnRleHR1YWwga2V5d29yZC5cblxucHAuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMudmFsdWUgPT09IG5hbWUgJiYgIXRoaXMuY29udGFpbnNFc2Ncbn07XG5cbi8vIENvbnN1bWVzIGNvbnRleHR1YWwga2V5d29yZCBpZiBwb3NzaWJsZS5cblxucHAuZWF0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbChuYW1lKSkgeyByZXR1cm4gZmFsc2UgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIEFzc2VydHMgdGhhdCBmb2xsb3dpbmcgdG9rZW4gaXMgZ2l2ZW4gY29udGV4dHVhbCBrZXl3b3JkLlxuXG5wcC5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbChuYW1lKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxuLy8gVGVzdCB3aGV0aGVyIGEgc2VtaWNvbG9uIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxucHAuY2FuSW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLmVvZiB8fFxuICAgIHRoaXMudHlwZSA9PT0gdHlwZXMuYnJhY2VSIHx8XG4gICAgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxufTtcblxucHAuaW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbih0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYyk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59O1xuXG4vLyBDb25zdW1lIGEgc2VtaWNvbG9uLCBvciwgZmFpbGluZyB0aGF0LCBzZWUgaWYgd2UgYXJlIGFsbG93ZWQgdG9cbi8vIHByZXRlbmQgdGhhdCB0aGVyZSBpcyBhIHNlbWljb2xvbiBhdCB0aGlzIHBvc2l0aW9uLlxuXG5wcC5zZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmVhdCh0eXBlcy5zZW1pKSAmJiAhdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxucHAuYWZ0ZXJUcmFpbGluZ0NvbW1hID0gZnVuY3Rpb24odG9rVHlwZSwgbm90TmV4dCkge1xuICBpZiAodGhpcy50eXBlID09PSB0b2tUeXBlKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEpXG4gICAgICB7IHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTsgfVxuICAgIGlmICghbm90TmV4dClcbiAgICAgIHsgdGhpcy5uZXh0KCk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59O1xuXG4vLyBFeHBlY3QgYSB0b2tlbiBvZiBhIGdpdmVuIHR5cGUuIElmIGZvdW5kLCBjb25zdW1lIGl0LCBvdGhlcndpc2UsXG4vLyByYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG5wcC5leHBlY3QgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHRoaXMuZWF0KHR5cGUpIHx8IHRoaXMudW5leHBlY3RlZCgpO1xufTtcblxuLy8gUmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxucHAudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xufTtcblxuZnVuY3Rpb24gRGVzdHJ1Y3R1cmluZ0Vycm9ycygpIHtcbiAgdGhpcy5zaG9ydGhhbmRBc3NpZ24gPVxuICB0aGlzLnRyYWlsaW5nQ29tbWEgPVxuICB0aGlzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPVxuICB0aGlzLnBhcmVudGhlc2l6ZWRCaW5kID1cbiAgdGhpcy5kb3VibGVQcm90byA9XG4gICAgLTE7XG59XG5cbnBwLmNoZWNrUGF0dGVybkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGlzQXNzaWduKSB7XG4gIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gfVxuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID4gLTEpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hLCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICB2YXIgcGFyZW5zID0gaXNBc3NpZ24gPyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gOiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kO1xuICBpZiAocGFyZW5zID4gLTEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBhcmVucywgXCJQYXJlbnRoZXNpemVkIHBhdHRlcm5cIik7IH1cbn07XG5cbnBwLmNoZWNrRXhwcmVzc2lvbkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFuZFRocm93KSB7XG4gIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgc2hvcnRoYW5kQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gIHZhciBkb3VibGVQcm90byA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG87XG4gIGlmICghYW5kVGhyb3cpIHsgcmV0dXJuIHNob3J0aGFuZEFzc2lnbiA+PSAwIHx8IGRvdWJsZVByb3RvID49IDAgfVxuICBpZiAoc2hvcnRoYW5kQXNzaWduID49IDApXG4gICAgeyB0aGlzLnJhaXNlKHNob3J0aGFuZEFzc2lnbiwgXCJTaG9ydGhhbmQgcHJvcGVydHkgYXNzaWdubWVudHMgYXJlIHZhbGlkIG9ubHkgaW4gZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuc1wiKTsgfVxuICBpZiAoZG91YmxlUHJvdG8gPj0gMClcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShkb3VibGVQcm90bywgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG59O1xuXG5wcC5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMueWllbGRQb3MgJiYgKCF0aGlzLmF3YWl0UG9zIHx8IHRoaXMueWllbGRQb3MgPCB0aGlzLmF3YWl0UG9zKSlcbiAgICB7IHRoaXMucmFpc2UodGhpcy55aWVsZFBvcywgXCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgaWYgKHRoaXMuYXdhaXRQb3MpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRQb3MsIFwiQXdhaXQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG59O1xuXG5wcC5pc1NpbXBsZUFzc2lnblRhcmdldCA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgaWYgKGV4cHIudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIHsgcmV0dXJuIHRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwci5leHByZXNzaW9uKSB9XG4gIHJldHVybiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGV4cHIudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCJcbn07XG5cbnZhciBwcCQxID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMjIFN0YXRlbWVudCBwYXJzaW5nXG5cbi8vIFBhcnNlIGEgcHJvZ3JhbS4gSW5pdGlhbGl6ZXMgdGhlIHBhcnNlciwgcmVhZHMgYW55IG51bWJlciBvZlxuLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbi8vIGBwcm9ncmFtYCBhcmd1bWVudC4gIElmIHByZXNlbnQsIHRoZSBzdGF0ZW1lbnRzIHdpbGwgYmUgYXBwZW5kZWRcbi8vIHRvIGl0cyBib2R5IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgbm9kZS5cblxucHAkMS5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgZXhwb3J0cyA9IHt9O1xuICBpZiAoIW5vZGUuYm9keSkgeyBub2RlLmJvZHkgPSBbXTsgfVxuICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5lb2YpIHtcbiAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCwgdHJ1ZSwgZXhwb3J0cyk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgaWYgKHRoaXMuaW5Nb2R1bGUpXG4gICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IE9iamVjdC5rZXlzKHRoaXMudW5kZWZpbmVkRXhwb3J0cyk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXS5zdGFydCwgKFwiRXhwb3J0ICdcIiArIG5hbWUgKyBcIicgaXMgbm90IGRlZmluZWRcIikpO1xuICAgICAgfSB9XG4gIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5zb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpXG59O1xuXG52YXIgbG9vcExhYmVsID0ge2tpbmQ6IFwibG9vcFwifSwgc3dpdGNoTGFiZWwgPSB7a2luZDogXCJzd2l0Y2hcIn07XG5cbnBwJDEuaXNMZXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgLy8gRm9yIGFtYmlndW91cyBjYXNlcywgZGV0ZXJtaW5lIGlmIGEgTGV4aWNhbERlY2xhcmF0aW9uIChvciBvbmx5IGFcbiAgLy8gU3RhdGVtZW50KSBpcyBhbGxvd2VkIGhlcmUuIElmIGNvbnRleHQgaXMgbm90IGVtcHR5IHRoZW4gb25seSBhIFN0YXRlbWVudFxuICAvLyBpcyBhbGxvd2VkLiBIb3dldmVyLCBgbGV0IFtgIGlzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIGxvb2thaGVhZCBmb3JcbiAgLy8gRXhwcmVzc2lvblN0YXRlbWVudCwgc28gc3BlY2lhbC1jYXNlIGl0IGZpcnN0LlxuICBpZiAobmV4dENoID09PSA5MSkgeyByZXR1cm4gdHJ1ZSB9IC8vICdbJ1xuICBpZiAoY29udGV4dCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGlmIChuZXh0Q2ggPT09IDEyMykgeyByZXR1cm4gdHJ1ZSB9IC8vICd7J1xuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoLCB0cnVlKSkge1xuICAgIHZhciBwb3MgPSBuZXh0ICsgMTtcbiAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICB2YXIgaWRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKG5leHQsIHBvcyk7XG4gICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGNoZWNrICdhc3luYyBbbm8gTGluZVRlcm1pbmF0b3IgaGVyZV0gZnVuY3Rpb24nXG4vLyAtICdhc3luYyAvKmZvbyovIGZ1bmN0aW9uJyBpcyBPSy5cbi8vIC0gJ2FzeW5jIC8qXFxuKi8gZnVuY3Rpb24nIGlzIGludmFsaWQuXG5wcCQxLmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJhc3luY1wiKSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoO1xuICByZXR1cm4gIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIG5leHQpKSAmJlxuICAgIHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgbmV4dCArIDgpID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAobmV4dCArIDggPT09IHRoaXMuaW5wdXQubGVuZ3RoIHx8ICFpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckF0KG5leHQgKyA4KSkpXG59O1xuXG4vLyBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4vL1xuLy8gSWYgZXhwZWN0aW5nIGEgc3RhdGVtZW50IGFuZCBmaW5kaW5nIGEgc2xhc2ggb3BlcmF0b3IsIHBhcnNlIGFcbi8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsLiBUaGlzIGlzIHRvIGhhbmRsZSBjYXNlcyBsaWtlXG4vLyBgaWYgKGZvbykgL2JsYWgvLmV4ZWMoZm9vKWAsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4vLyBkb2VzIG5vdCBoZWxwLlxuXG5wcCQxLnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oY29udGV4dCwgdG9wTGV2ZWwsIGV4cG9ydHMpIHtcbiAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgaWYgKHRoaXMuaXNMZXQoY29udGV4dCkpIHtcbiAgICBzdGFydHR5cGUgPSB0eXBlcy5fdmFyO1xuICAgIGtpbmQgPSBcImxldFwiO1xuICB9XG5cbiAgLy8gTW9zdCB0eXBlcyBvZiBzdGF0ZW1lbnRzIGFyZSByZWNvZ25pemVkIGJ5IHRoZSBrZXl3b3JkIHRoZXlcbiAgLy8gc3RhcnQgd2l0aC4gTWFueSBhcmUgdHJpdmlhbCB0byBwYXJzZSwgc29tZSByZXF1aXJlIGEgYml0IG9mXG4gIC8vIGNvbXBsZXhpdHkuXG5cbiAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgY2FzZSB0eXBlcy5fYnJlYWs6IGNhc2UgdHlwZXMuX2NvbnRpbnVlOiByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpXG4gIGNhc2UgdHlwZXMuX2RlYnVnZ2VyOiByZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2RvOiByZXR1cm4gdGhpcy5wYXJzZURvU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2ZvcjogcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgLy8gRnVuY3Rpb24gYXMgc29sZSBib2R5IG9mIGVpdGhlciBhbiBpZiBzdGF0ZW1lbnQgb3IgYSBsYWJlbGVkIHN0YXRlbWVudFxuICAgIC8vIHdvcmtzLCBidXQgbm90IHdoZW4gaXQgaXMgcGFydCBvZiBhIGxhYmVsZWQgc3RhdGVtZW50IHRoYXQgaXMgdGhlIHNvbGVcbiAgICAvLyBib2R5IG9mIGFuIGlmIHN0YXRlbWVudC5cbiAgICBpZiAoKGNvbnRleHQgJiYgKHRoaXMuc3RyaWN0IHx8IGNvbnRleHQgIT09IFwiaWZcIiAmJiBjb250ZXh0ICE9PSBcImxhYmVsXCIpKSAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgZmFsc2UsICFjb250ZXh0KVxuICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSlcbiAgY2FzZSB0eXBlcy5faWY6IHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fcmV0dXJuOiByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9zd2l0Y2g6IHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3Rocm93OiByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3RyeTogcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fY29uc3Q6IGNhc2UgdHlwZXMuX3ZhcjpcbiAgICBraW5kID0ga2luZCB8fCB0aGlzLnZhbHVlO1xuICAgIGlmIChjb250ZXh0ICYmIGtpbmQgIT09IFwidmFyXCIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICBjYXNlIHR5cGVzLl93aGlsZTogcmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl93aXRoOiByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgbm9kZSlcbiAgY2FzZSB0eXBlcy5zZW1pOiByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2V4cG9ydDpcbiAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQpIHtcbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICBpZiAobmV4dENoID09PSA0MCkgLy8gJygnXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIHRoaXMucGFyc2VFeHByZXNzaW9uKCkpIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpIHtcbiAgICAgIGlmICghdG9wTGV2ZWwpXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbFwiKTsgfVxuICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IGFwcGVhciBvbmx5IHdpdGggJ3NvdXJjZVR5cGU6IG1vZHVsZSdcIik7IH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0dHlwZSA9PT0gdHlwZXMuX2ltcG9ydCA/IHRoaXMucGFyc2VJbXBvcnQobm9kZSkgOiB0aGlzLnBhcnNlRXhwb3J0KG5vZGUsIGV4cG9ydHMpXG5cbiAgICAvLyBJZiB0aGUgc3RhdGVtZW50IGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdGF0ZW1lbnQga2V5d29yZCBvciBhXG4gICAgLy8gYnJhY2UsIGl0J3MgYW4gRXhwcmVzc2lvblN0YXRlbWVudCBvciBMYWJlbGVkU3RhdGVtZW50LiBXZVxuICAgIC8vIHNpbXBseSBzdGFydCBwYXJzaW5nIGFuIGV4cHJlc3Npb24sIGFuZCBhZnRlcndhcmRzLCBpZiB0aGVcbiAgICAvLyBuZXh0IHRva2VuIGlzIGEgY29sb24gYW5kIHRoZSBleHByZXNzaW9uIHdhcyBhIHNpbXBsZVxuICAgIC8vIElkZW50aWZpZXIgbm9kZSwgd2Ugc3dpdGNoIHRvIGludGVycHJldGluZyBpdCBhcyBhIGxhYmVsLlxuICBkZWZhdWx0OlxuICAgIGlmICh0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIHRydWUsICFjb250ZXh0KVxuICAgIH1cblxuICAgIHZhciBtYXliZU5hbWUgPSB0aGlzLnZhbHVlLCBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICBpZiAoc3RhcnR0eXBlID09PSB0eXBlcy5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMuY29sb24pKVxuICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB9XG4gICAgZWxzZSB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB9XG4gIH1cbn07XG5cbnBwJDEucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2V5d29yZCkge1xuICB2YXIgaXNCcmVhayA9IGtleXdvcmQgPT09IFwiYnJlYWtcIjtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IG5vZGUubGFiZWwgPSBudWxsOyB9XG4gIGVsc2UgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICBlbHNlIHtcbiAgICBub2RlLmxhYmVsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGFuIGFjdHVhbCBkZXN0aW5hdGlvbiB0byBicmVhayBvclxuICAvLyBjb250aW51ZSB0by5cbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGxhYiA9IHRoaXMubGFiZWxzW2ldO1xuICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgeyBicmVhayB9XG4gICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICB9XG4gIH1cbiAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImRvXCIpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgeyB0aGlzLmVhdCh0eXBlcy5zZW1pKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLnNlbWljb2xvbigpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG59O1xuXG4vLyBEaXNhbWJpZ3VhdGluZyBiZXR3ZWVuIGEgYGZvcmAgYW5kIGEgYGZvcmAvYGluYCBvciBgZm9yYC9gb2ZgXG4vLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbi8vIHN0YXRlbWVudCBvciBleHByZXNzaW9uLCBkaXNhbGxvd2luZyB0aGUgYGluYCBvcGVyYXRvciAoc2VlXG4vLyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBgcGFyc2VFeHByZXNzaW9uYCksIGFuZCB0aGVuIGNoZWNrXG4vLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4vLyBwYXJ0IChzZW1pY29sb24gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMpLCBpdFxuLy8gaXMgYSByZWd1bGFyIGBmb3JgIGxvb3AuXG5cbnBwJDEucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB2YXIgYXdhaXRBdCA9ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSkgJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXdhaXRcIikpID8gdGhpcy5sYXN0VG9rU3RhcnQgOiAtMTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkpIHtcbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gIH1cbiAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fdmFyIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgaWYgKCh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0JDEpXG4gICAgfVxuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCQxKVxuICB9XG4gIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gIHZhciBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbikge1xuICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgIH1cbiAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgdGhpcy5jaGVja0xWYWwoaW5pdCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICB9XG4gIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpXG59O1xuXG5wcCQxLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBpc0FzeW5jLCBkZWNsYXJhdGlvblBvc2l0aW9uKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgKGRlY2xhcmF0aW9uUG9zaXRpb24gPyAwIDogRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCksIGZhbHNlLCBpc0FzeW5jKVxufTtcblxucHAkMS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAvLyBhbGxvdyBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgaW4gYnJhbmNoZXMsIGJ1dCBvbmx5IGluIG5vbi1zdHJpY3QgbW9kZVxuICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIik7XG4gIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQodHlwZXMuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpIDogbnVsbDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7IH1cbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gSW4gYHJldHVybmAgKGFuZCBgYnJlYWtgL2Bjb250aW51ZWApLCB0aGUga2V5d29yZHMgd2l0aFxuICAvLyBvcHRpb25hbCBhcmd1bWVudHMsIHdlIGVhZ2VybHkgbG9vayBmb3IgYSBzZW1pY29sb24gb3IgdGhlXG4gIC8vIHBvc3NpYmlsaXR5IHRvIGluc2VydCBvbmUuXG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgZWxzZSB7IG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpOyB0aGlzLnNlbWljb2xvbigpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5jYXNlcyA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB0aGlzLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcbiAgdGhpcy5lbnRlclNjb3BlKDApO1xuXG4gIC8vIFN0YXRlbWVudHMgdW5kZXIgbXVzdCBiZSBncm91cGVkIChieSBsYWJlbCkgaW4gU3dpdGNoQ2FzZVxuICAvLyBub2Rlcy4gYGN1cmAgaXMgdXNlZCB0byBrZWVwIHRoZSBub2RlIHRoYXQgd2UgYXJlIGN1cnJlbnRseVxuICAvLyBhZGRpbmcgc3RhdGVtZW50cyB0by5cblxuICB2YXIgY3VyO1xuICBmb3IgKHZhciBzYXdEZWZhdWx0ID0gZmFsc2U7IHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSOykge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXNlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuX2RlZmF1bHQpIHtcbiAgICAgIHZhciBpc0Nhc2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXNlO1xuICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgIG5vZGUuY2FzZXMucHVzaChjdXIgPSB0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmIChpc0Nhc2UpIHtcbiAgICAgICAgY3VyLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNhd0RlZmF1bHQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgfVxuICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWN1cikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgdGhpcy5uZXh0KCk7IC8vIENsb3NpbmcgYnJhY2VcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmIChsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpOyB9XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFJldXNlZCBlbXB0eSBhcnJheSBhZGRlZCBmb3Igbm9kZSBmaWVsZHMgdGhhdCBhcmUgYWx3YXlzIGVtcHR5LlxuXG52YXIgZW1wdHkgPSBbXTtcblxucHAkMS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NhdGNoKSB7XG4gICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgICAgdmFyIHNpbXBsZSA9IGNsYXVzZS5wYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIjtcbiAgICAgIHRoaXMuZW50ZXJTY29wZShzaW1wbGUgPyBTQ09QRV9TSU1QTEVfQ0FUQ0ggOiAwKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGNsYXVzZS5wYXJhbSwgc2ltcGxlID8gQklORF9TSU1QTEVfQ0FUQ0ggOiBCSU5EX0xFWElDQUwpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDEwKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgdGhpcy5lbnRlclNjb3BlKDApO1xuICAgIH1cbiAgICBjbGF1c2UuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICB9XG4gIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQodHlwZXMuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlVmFyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2luZCkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndoaWxlXCIpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2l0aFwiKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIHtcbiAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCA9IHRoaXMubGFiZWxzOyBpJDEgPCBsaXN0Lmxlbmd0aDsgaSQxICs9IDEpXG4gICAge1xuICAgIHZhciBsYWJlbCA9IGxpc3RbaSQxXTtcblxuICAgIGlmIChsYWJlbC5uYW1lID09PSBtYXliZU5hbWUpXG4gICAgICB7IHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJMYWJlbCAnXCIgKyBtYXliZU5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgfSB9XG4gIHZhciBraW5kID0gdGhpcy50eXBlLmlzTG9vcCA/IFwibG9vcFwiIDogdGhpcy50eXBlID09PSB0eXBlcy5fc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYWJlbCQxID0gdGhpcy5sYWJlbHNbaV07XG4gICAgaWYgKGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgIC8vIFVwZGF0ZSBpbmZvcm1hdGlvbiBhYm91dCBwcmV2aW91cyBsYWJlbHMgb24gdGhpcyBub2RlXG4gICAgICBsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgIGxhYmVsJDEua2luZCA9IGtpbmQ7XG4gICAgfSBlbHNlIHsgYnJlYWsgfVxuICB9XG4gIHRoaXMubGFiZWxzLnB1c2goe25hbWU6IG1heWJlTmFtZSwga2luZDoga2luZCwgc3RhdGVtZW50U3RhcnQ6IHRoaXMuc3RhcnR9KTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChjb250ZXh0ID8gY29udGV4dC5pbmRleE9mKFwibGFiZWxcIikgPT09IC0xID8gY29udGV4dCArIFwibGFiZWxcIiA6IGNvbnRleHQgOiBcImxhYmVsXCIpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGV4cHIpIHtcbiAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgc2VtaWNvbG9uLWVuY2xvc2VkIGJsb2NrIG9mIHN0YXRlbWVudHMsIGhhbmRsaW5nIGBcInVzZVxuLy8gc3RyaWN0XCJgIGRlY2xhcmF0aW9ucyB3aGVuIGBhbGxvd1N0cmljdGAgaXMgdHJ1ZSAodXNlZCBmb3Jcbi8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbnBwJDEucGFyc2VCbG9jayA9IGZ1bmN0aW9uKGNyZWF0ZU5ld0xleGljYWxTY29wZSwgbm9kZSkge1xuICBpZiAoIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9PT0gdm9pZCAwICkgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZTtcbiAgaWYgKCBub2RlID09PSB2b2lkIDAgKSBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICBub2RlLmJvZHkgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmVudGVyU2NvcGUoMCk7IH1cbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICB9XG4gIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHsgdGhpcy5leGl0U2NvcGUoKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgcmVndWxhciBgZm9yYCBsb29wLiBUaGUgZGlzYW1iaWd1YXRpb24gY29kZSBpblxuLy8gYHBhcnNlU3RhdGVtZW50YCB3aWxsIGFscmVhZHkgaGF2ZSBwYXJzZWQgdGhlIGluaXQgc3RhdGVtZW50IG9yXG4vLyBleHByZXNzaW9uLlxuXG5wcCQxLnBhcnNlRm9yID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICBub2RlLmluaXQgPSBpbml0O1xuICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy50eXBlID09PSB0eXBlcy5zZW1pID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICBub2RlLnVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5SID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIGBmb3JgL2BpbmAgYW5kIGBmb3JgL2BvZmAgbG9vcCwgd2hpY2ggYXJlIGFsbW9zdFxuLy8gc2FtZSBmcm9tIHBhcnNlcidzIHBlcnNwZWN0aXZlLlxuXG5wcCQxLnBhcnNlRm9ySW4gPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIHZhciBpc0ZvckluID0gdGhpcy50eXBlID09PSB0eXBlcy5faW47XG4gIHRoaXMubmV4dCgpO1xuXG4gIGlmIChcbiAgICBpbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmXG4gICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAhPSBudWxsICYmXG4gICAgKFxuICAgICAgIWlzRm9ySW4gfHxcbiAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHxcbiAgICAgIHRoaXMuc3RyaWN0IHx8XG4gICAgICBpbml0LmtpbmQgIT09IFwidmFyXCIgfHxcbiAgICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiXG4gICAgKVxuICApIHtcbiAgICB0aGlzLnJhaXNlKFxuICAgICAgaW5pdC5zdGFydCxcbiAgICAgICgoaXNGb3JJbiA/IFwiZm9yLWluXCIgOiBcImZvci1vZlwiKSArIFwiIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyXCIpXG4gICAgKTtcbiAgfSBlbHNlIGlmIChpbml0LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikge1xuICAgIHRoaXMucmFpc2UoaW5pdC5zdGFydCwgXCJJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1sb29wXCIpO1xuICB9XG4gIG5vZGUubGVmdCA9IGluaXQ7XG4gIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICB0aGlzLmV4aXRTY29wZSgpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSBsaXN0IG9mIHZhcmlhYmxlIGRlY2xhcmF0aW9ucy5cblxucHAkMS5wYXJzZVZhciA9IGZ1bmN0aW9uKG5vZGUsIGlzRm9yLCBraW5kKSB7XG4gIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gIG5vZGUua2luZCA9IGtpbmQ7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZGVjbCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5lcSkpIHtcbiAgICAgIGRlY2wuaW5pdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihpc0Zvcik7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcImNvbnN0XCIgJiYgISh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9IGVsc2UgaWYgKGRlY2wuaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgIShpc0ZvciAmJiAodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjbC5pbml0ID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IGJyZWFrIH1cbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxucHAkMS5wYXJzZVZhcklkID0gZnVuY3Rpb24oZGVjbCwga2luZCkge1xuICBkZWNsLmlkID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIHRoaXMuY2hlY2tMVmFsKGRlY2wuaWQsIGtpbmQgPT09IFwidmFyXCIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCwgZmFsc2UpO1xufTtcblxudmFyIEZVTkNfU1RBVEVNRU5UID0gMSwgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCA9IDIsIEZVTkNfTlVMTEFCTEVfSUQgPSA0O1xuXG4vLyBQYXJzZSBhIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbi8vIGBzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVGApLlxuXG4vLyBSZW1vdmUgYGFsbG93RXhwcmVzc2lvbkJvZHlgIGZvciA3LjAuMCwgYXMgaXQgaXMgb25seSBjYWxsZWQgd2l0aCBmYWxzZVxucHAkMS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSwgc3RhdGVtZW50LCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBpc0FzeW5jKSB7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgfHwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIWlzQXN5bmMpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdGFyICYmIChzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICBpZiAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpIHtcbiAgICBub2RlLmlkID0gKHN0YXRlbWVudCAmIEZVTkNfTlVMTEFCTEVfSUQpICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICBpZiAobm9kZS5pZCAmJiAhKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgLy8gSWYgaXQgaXMgYSByZWd1bGFyIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIGluIHNsb3BweSBtb2RlLCB0aGVuIGl0IGlzXG4gICAgICAvLyBzdWJqZWN0IHRvIEFubmV4IEIgc2VtYW50aWNzIChCSU5EX0ZVTkNUSU9OKS4gT3RoZXJ3aXNlLCB0aGUgYmluZGluZ1xuICAgICAgLy8gbW9kZSBkZXBlbmRzIG9uIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgc2NvcGUgKHNlZVxuICAgICAgLy8gdHJlYXRGdW5jdGlvbnNBc1ZhcikuXG4gICAgICB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsICh0aGlzLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jKSA/IHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhciA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMIDogQklORF9GVU5DVElPTik7IH1cbiAgfVxuXG4gIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgdGhpcy55aWVsZFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRQb3MgPSAwO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhub2RlLmFzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuXG4gIGlmICghKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSlcbiAgICB7IG5vZGUuaWQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7IH1cblxuICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSwgZmFsc2UpO1xuXG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlRnVuY3Rpb25QYXJhbXMgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbn07XG5cbi8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG5wcCQxLnBhcnNlQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICB0aGlzLm5leHQoKTtcblxuICAvLyBlY21hLTI2MiAxNC42IENsYXNzIERlZmluaXRpb25zXG4gIC8vIEEgY2xhc3MgZGVmaW5pdGlvbiBpcyBhbHdheXMgc3RyaWN0IG1vZGUgY29kZS5cbiAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0O1xuICB0aGlzLnN0cmljdCA9IHRydWU7XG5cbiAgdGhpcy5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQpO1xuICB0aGlzLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgdmFyIGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBoYWRDb25zdHJ1Y3RvciA9IGZhbHNlO1xuICBjbGFzc0JvZHkuYm9keSA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnQobm9kZS5zdXBlckNsYXNzICE9PSBudWxsKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgY2xhc3NCb2R5LmJvZHkucHVzaChlbGVtZW50KTtcbiAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIGVsZW1lbnQua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIGlmIChoYWRDb25zdHJ1Y3RvcikgeyB0aGlzLnJhaXNlKGVsZW1lbnQuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpOyB9XG4gICAgICAgIGhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKVxufTtcblxucHAkMS5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpKSB7IHJldHVybiBudWxsIH1cblxuICB2YXIgbWV0aG9kID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIHRyeUNvbnRleHR1YWwgPSBmdW5jdGlvbiAoaywgbm9MaW5lQnJlYWspIHtcbiAgICBpZiAoIG5vTGluZUJyZWFrID09PSB2b2lkIDAgKSBub0xpbmVCcmVhayA9IGZhbHNlO1xuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcyQxLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMkMS5zdGFydExvYztcbiAgICBpZiAoIXRoaXMkMS5lYXRDb250ZXh0dWFsKGspKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRoaXMkMS50eXBlICE9PSB0eXBlcy5wYXJlbkwgJiYgKCFub0xpbmVCcmVhayB8fCAhdGhpcyQxLmNhbkluc2VydFNlbWljb2xvbigpKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKG1ldGhvZC5rZXkpIHsgdGhpcyQxLnVuZXhwZWN0ZWQoKTsgfVxuICAgIG1ldGhvZC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIG1ldGhvZC5rZXkgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnQsIHN0YXJ0TG9jKTtcbiAgICBtZXRob2Qua2V5Lm5hbWUgPSBrO1xuICAgIHRoaXMkMS5maW5pc2hOb2RlKG1ldGhvZC5rZXksIFwiSWRlbnRpZmllclwiKTtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gIG1ldGhvZC5zdGF0aWMgPSB0cnlDb250ZXh0dWFsKFwic3RhdGljXCIpO1xuICB2YXIgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcbiAgaWYgKCFpc0dlbmVyYXRvcikge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiB0cnlDb250ZXh0dWFsKFwiYXN5bmNcIiwgdHJ1ZSkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJnZXRcIikpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJnZXRcIjtcbiAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJzZXRcIikpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJzZXRcIjtcbiAgICB9XG4gIH1cbiAgaWYgKCFtZXRob2Qua2V5KSB7IHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTsgfVxuICB2YXIga2V5ID0gbWV0aG9kLmtleTtcbiAgdmFyIGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG4gIGlmICghbWV0aG9kLmNvbXB1dGVkICYmICFtZXRob2Quc3RhdGljICYmIChrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgIGlmIChtZXRob2Qua2luZCAhPT0gXCJtZXRob2RcIikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICBpZiAoaXNHZW5lcmF0b3IpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICBpZiAoaXNBc3luYykgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhbiBhc3luYyBtZXRob2RcIik7IH1cbiAgICBtZXRob2Qua2luZCA9IFwiY29uc3RydWN0b3JcIjtcbiAgICBhbGxvd3NEaXJlY3RTdXBlciA9IGNvbnN0cnVjdG9yQWxsb3dzU3VwZXI7XG4gIH0gZWxzZSBpZiAobWV0aG9kLnN0YXRpYyAmJiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwicHJvdG90eXBlXCIpIHtcbiAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gIH1cbiAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAwKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5zdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUuc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gIHJldHVybiBtZXRob2Rcbn07XG5cbnBwJDEucGFyc2VDbGFzc01ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gIG1ldGhvZC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiTWV0aG9kRGVmaW5pdGlvblwiKVxufTtcblxucHAkMS5wYXJzZUNsYXNzSWQgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChpc1N0YXRlbWVudClcbiAgICAgIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgQklORF9MRVhJQ0FMLCBmYWxzZSk7IH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gIH1cbn07XG5cbnBwJDEucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcy5fZXh0ZW5kcykgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG59O1xuXG4vLyBQYXJzZXMgbW9kdWxlIGV4cG9ydCBkZWNsYXJhdGlvbi5cblxucHAkMS5wYXJzZUV4cG9ydCA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGV4cG9ydCAqIGZyb20gJy4uLidcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnN0YXIpKSB7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLl9kZWZhdWx0KSkgeyAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgdmFyIGlzQXN5bmM7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2Z1bmN0aW9uIHx8IChpc0FzeW5jID0gdGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkpIHtcbiAgICAgIHZhciBmTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMubmV4dCgpOyB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGZOb2RlLCBGVU5DX1NUQVRFTUVOVCB8IEZVTkNfTlVMTEFCTEVfSUQsIGZhbHNlLCBpc0FzeW5jKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NsYXNzKSB7XG4gICAgICB2YXIgY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzcyhjTm9kZSwgXCJudWxsYWJsZUlEXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgLy8gZXhwb3J0IHZhcnxjb25zdHxsZXR8ZnVuY3Rpb258Y2xhc3MgLi4uXG4gIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgIHsgdGhpcy5jaGVja1ZhcmlhYmxlRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLm5hbWUsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICB9IGVsc2UgeyAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhleHBvcnRzKTtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuc3BlY2lmaWVyczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGtleXdvcmRzIHVzZWQgYXMgbG9jYWwgbmFtZXNcbiAgICAgICAgdmFyIHNwZWMgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHNwZWMubG9jYWwpO1xuICAgICAgICAvLyBjaGVjayBpZiBleHBvcnQgaXMgZGVmaW5lZFxuICAgICAgICB0aGlzLmNoZWNrTG9jYWxFeHBvcnQoc3BlYy5sb2NhbCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKVxufTtcblxucHAkMS5jaGVja0V4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIHBvcykge1xuICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgaWYgKGhhcyhleHBvcnRzLCBuYW1lKSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIFwiRHVwbGljYXRlIGV4cG9ydCAnXCIgKyBuYW1lICsgXCInXCIpOyB9XG4gIGV4cG9ydHNbbmFtZV0gPSB0cnVlO1xufTtcblxucHAkMS5jaGVja1BhdHRlcm5FeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBwYXQpIHtcbiAgdmFyIHR5cGUgPSBwYXQudHlwZTtcbiAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBwYXQubmFtZSwgcGF0LnN0YXJ0KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGF0LnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcCk7XG4gICAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHBhdC5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICBpZiAoZWx0KSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGVsdCk7IH1cbiAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJQcm9wZXJ0eVwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LnZhbHVlKTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQubGVmdCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmFyZ3VtZW50KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuZXhwcmVzc2lvbik7IH1cbn07XG5cbnBwJDEuY2hlY2tWYXJpYWJsZUV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlY2xzKSB7XG4gIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGRlY2xzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIGRlY2wgPSBsaXN0W2ldO1xuXG4gICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZGVjbC5pZCk7XG4gIH1cbn07XG5cbnBwJDEuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZS5rZXl3b3JkID09PSBcInZhclwiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY29uc3RcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNsYXNzXCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgdGhpcy5pc0xldCgpIHx8XG4gICAgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGV4cG9ydHMuXG5cbnBwJDEucGFyc2VFeHBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oZXhwb3J0cykge1xuICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudCh0cnVlKSA6IG5vZGUubG9jYWw7XG4gICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLm5hbWUsIG5vZGUuZXhwb3J0ZWQuc3RhcnQpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpKTtcbiAgfVxuICByZXR1cm4gbm9kZXNcbn07XG5cbi8vIFBhcnNlcyBpbXBvcnQgZGVjbGFyYXRpb24uXG5cbnBwJDEucGFyc2VJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICAvLyBpbXBvcnQgJy4uLidcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nKSB7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gZW1wdHk7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVycygpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpXG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgaW1wb3J0cy5cblxucHAkMS5wYXJzZUltcG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgIC8vIGltcG9ydCBkZWZhdWx0T2JqLCB7IHgsIHkgYXMgeiB9IGZyb20gJy4uLidcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpKTtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyByZXR1cm4gbm9kZXMgfVxuICB9XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpIHtcbiAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICBub2RlJDEubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbChub2RlJDEubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSk7XG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBub2RlJDIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUkMi5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgIG5vZGUkMi5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlJDIuaW1wb3J0ZWQpO1xuICAgICAgbm9kZSQyLmxvY2FsID0gbm9kZSQyLmltcG9ydGVkO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrTFZhbChub2RlJDIubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQyLCBcIkltcG9ydFNwZWNpZmllclwiKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzXG59O1xuXG4vLyBTZXQgYEV4cHJlc3Npb25TdGF0ZW1lbnQjZGlyZWN0aXZlYCBwcm9wZXJ0eSBmb3IgZGlyZWN0aXZlIHByb2xvZ3Vlcy5cbnBwJDEuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZSA9IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aCAmJiB0aGlzLmlzRGlyZWN0aXZlQ2FuZGlkYXRlKHN0YXRlbWVudHNbaV0pOyArK2kpIHtcbiAgICBzdGF0ZW1lbnRzW2ldLmRpcmVjdGl2ZSA9IHN0YXRlbWVudHNbaV0uZXhwcmVzc2lvbi5yYXcuc2xpY2UoMSwgLTEpO1xuICB9XG59O1xucHAkMS5pc0RpcmVjdGl2ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKHN0YXRlbWVudCkge1xuICByZXR1cm4gKFxuICAgIHN0YXRlbWVudC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJlxuICAgIHN0YXRlbWVudC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmXG4gICAgdHlwZW9mIHN0YXRlbWVudC5leHByZXNzaW9uLnZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgLy8gUmVqZWN0IHBhcmVudGhlc2l6ZWQgc3RyaW5ncy5cbiAgICAodGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIlxcXCJcIiB8fCB0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiJ1wiKVxuICApXG59O1xuXG52YXIgcHAkMiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIENvbnZlcnQgZXhpc3RpbmcgZXhwcmVzc2lvbiBhdG9tIHRvIGFzc2lnbmFibGUgcGF0dGVyblxuLy8gaWYgcG9zc2libGUuXG5cbnBwJDIudG9Bc3NpZ25hYmxlID0gZnVuY3Rpb24obm9kZSwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgaWYgKHRoaXMuaW5Bc3luYyAmJiBub2RlLm5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHByb3AsIGlzQmluZGluZyk7XG4gICAgICAgIC8vIEVhcmx5IGVycm9yOlxuICAgICAgICAvLyAgIEFzc2lnbm1lbnRSZXN0UHJvcGVydHlbWWllbGQsIEF3YWl0XSA6XG4gICAgICAgIC8vICAgICBgLi4uYCBEZXN0cnVjdHVyaW5nQXNzaWdubWVudFRhcmdldFtZaWVsZCwgQXdhaXRdXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgSXQgaXMgYSBTeW50YXggRXJyb3IgaWYgfERlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0fCBpcyBhbiB8QXJyYXlMaXRlcmFsfCBvciBhbiB8T2JqZWN0TGl0ZXJhbHwuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJlxuICAgICAgICAgIChwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIgfHwgcHJvcC5hcmd1bWVudC50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShwcm9wLmFyZ3VtZW50LnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAgIC8vIEFzc2lnbm1lbnRQcm9wZXJ0eSBoYXMgdHlwZSA9PT0gXCJQcm9wZXJ0eVwiXG4gICAgICBpZiAobm9kZS5raW5kICE9PSBcImluaXRcIikgeyB0aGlzLnJhaXNlKG5vZGUua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTsgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICBub2RlLnR5cGUgPSBcIkFycmF5UGF0dGVyblwiO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICBub2RlLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmFyZ3VtZW50LCBpc0JpbmRpbmcpO1xuICAgICAgaWYgKG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5hcmd1bWVudC5zdGFydCwgXCJSZXN0IGVsZW1lbnRzIGNhbm5vdCBoYXZlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7IHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTsgfVxuICAgICAgbm9kZS50eXBlID0gXCJBc3NpZ25tZW50UGF0dGVyblwiO1xuICAgICAgZGVsZXRlIG5vZGUub3BlcmF0b3I7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmxlZnQsIGlzQmluZGluZyk7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoIHRvIEFzc2lnbm1lbnRQYXR0ZXJuXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKCFpc0JpbmRpbmcpIHsgYnJlYWsgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gIHJldHVybiBub2RlXG59O1xuXG4vLyBDb252ZXJ0IGxpc3Qgb2YgZXhwcmVzc2lvbiBhdG9tcyB0byBiaW5kaW5nIGxpc3QuXG5cbnBwJDIudG9Bc3NpZ25hYmxlTGlzdCA9IGZ1bmN0aW9uKGV4cHJMaXN0LCBpc0JpbmRpbmcpIHtcbiAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciBlbHQgPSBleHByTGlzdFtpXTtcbiAgICBpZiAoZWx0KSB7IHRoaXMudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICB9XG4gIGlmIChlbmQpIHtcbiAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2VuZCAtIDFdO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgaXNCaW5kaW5nICYmIGxhc3QgJiYgbGFzdC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiYgbGFzdC5hcmd1bWVudC50eXBlICE9PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKGxhc3QuYXJndW1lbnQuc3RhcnQpOyB9XG4gIH1cbiAgcmV0dXJuIGV4cHJMaXN0XG59O1xuXG4vLyBQYXJzZXMgc3ByZWFkIGVsZW1lbnQuXG5cbnBwJDIucGFyc2VTcHJlYWQgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKVxufTtcblxucHAkMi5wYXJzZVJlc3RCaW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gUmVzdEVsZW1lbnQgaW5zaWRlIG9mIGEgZnVuY3Rpb24gcGFyYW1ldGVyIG11c3QgYmUgYW4gaWRlbnRpZmllclxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSlcbiAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxufTtcblxuLy8gUGFyc2VzIGx2YWx1ZSAoYXNzaWduYWJsZSkgYXRvbS5cblxucHAkMi5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpXG5cbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxufTtcblxucHAkMi5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93RW1wdHksIGFsbG93VHJhaWxpbmdDb21tYSkge1xuICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgaWYgKGZpcnN0KSB7IGZpcnN0ID0gZmFsc2U7IH1cbiAgICBlbHNlIHsgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpOyB9XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgIH0gZWxzZSBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkge1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgIHZhciByZXN0ID0gdGhpcy5wYXJzZVJlc3RCaW5kaW5nKCk7XG4gICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgZWx0cy5wdXNoKHJlc3QpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgdGhpcy5leHBlY3QoY2xvc2UpO1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsZW0gPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShlbGVtKTtcbiAgICAgIGVsdHMucHVzaChlbGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsdHNcbn07XG5cbnBwJDIucGFyc2VCaW5kaW5nTGlzdEl0ZW0gPSBmdW5jdGlvbihwYXJhbSkge1xuICByZXR1cm4gcGFyYW1cbn07XG5cbi8vIFBhcnNlcyBhc3NpZ25tZW50IHBhdHRlcm4gYXJvdW5kIGdpdmVuIGF0b20gaWYgcG9zc2libGUuXG5cbnBwJDIucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmVhdCh0eXBlcy5lcSkpIHsgcmV0dXJuIGxlZnQgfVxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIilcbn07XG5cbi8vIFZlcmlmeSB0aGF0IGEgbm9kZSBpcyBhbiBsdmFsIOKAlCBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYXNzaWduZWRcbi8vIHRvLlxuLy8gYmluZGluZ1R5cGUgY2FuIGJlIGVpdGhlcjpcbi8vICd2YXInIGluZGljYXRpbmcgdGhhdCB0aGUgbHZhbCBjcmVhdGVzIGEgJ3ZhcicgYmluZGluZ1xuLy8gJ2xldCcgaW5kaWNhdGluZyB0aGF0IHRoZSBsdmFsIGNyZWF0ZXMgYSBsZXhpY2FsICgnbGV0JyBvciAnY29uc3QnKSBiaW5kaW5nXG4vLyAnbm9uZScgaW5kaWNhdGluZyB0aGF0IHRoZSBiaW5kaW5nIHNob3VsZCBiZSBjaGVja2VkIGZvciBpbGxlZ2FsIGlkZW50aWZpZXJzLCBidXQgbm90IGZvciBkdXBsaWNhdGUgcmVmZXJlbmNlc1xuXG5wcCQyLmNoZWNrTFZhbCA9IGZ1bmN0aW9uKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpIHtcbiAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCAmJiBleHByLm5hbWUgPT09IFwibGV0XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcImxldCBpcyBkaXNhbGxvd2VkIGFzIGEgbGV4aWNhbGx5IGJvdW5kIG5hbWVcIik7IH1cbiAgICBpZiAodGhpcy5zdHJpY3QgJiYgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZC50ZXN0KGV4cHIubmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgIGlmIChjaGVja0NsYXNoZXMpIHtcbiAgICAgIGlmIChoYXMoY2hlY2tDbGFzaGVzLCBleHByLm5hbWUpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgIGNoZWNrQ2xhc2hlc1tleHByLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX05PTkUgJiYgYmluZGluZ1R5cGUgIT09IEJJTkRfT1VUU0lERSkgeyB0aGlzLmRlY2xhcmVOYW1lKGV4cHIubmFtZSwgYmluZGluZ1R5cGUsIGV4cHIuc3RhcnQpOyB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGlmIChiaW5kaW5nVHlwZSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIG1lbWJlciBleHByZXNzaW9uXCIpOyB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZXhwci5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICB0aGlzLmNoZWNrTFZhbChwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLnZhbHVlLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBleHByLmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgdmFyIGVsZW0gPSBsaXN0JDFbaSQxXTtcblxuICAgIGlmIChlbGVtKSB7IHRoaXMuY2hlY2tMVmFsKGVsZW0sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpOyB9XG4gICAgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci5sZWZ0LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuYXJndW1lbnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci5leHByZXNzaW9uLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5yYWlzZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICB9XG59O1xuXG4vLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuXG52YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIENoZWNrIGlmIHByb3BlcnR5IG5hbWUgY2xhc2hlcyB3aXRoIGFscmVhZHkgYWRkZWQuXG4vLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4vLyBlaXRoZXIgd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggYW4gaW5pdCBwcm9wZXJ0eSDigJQgYW5kIGluXG4vLyBzdHJpY3QgbW9kZSwgaW5pdCBwcm9wZXJ0aWVzIGFyZSBhbHNvIG5vdCBhbGxvd2VkIHRvIGJlIHJlcGVhdGVkLlxuXG5wcCQzLmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgeyByZXR1cm4gfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgIHsgcmV0dXJuIH1cbiAgdmFyIGtleSA9IHByb3Aua2V5O1xuICB2YXIgbmFtZTtcbiAgc3dpdGNoIChrZXkudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOiBuYW1lID0ga2V5Lm5hbWU7IGJyZWFrXG4gIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgZGVmYXVsdDogcmV0dXJuXG4gIH1cbiAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiICYmIGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA8IDApIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IGtleS5zdGFydDsgfVxuICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGtsdWRnZS4gQ2FuIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA2LjBcbiAgICAgICAgZWxzZSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxuICAgICAgfVxuICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBuYW1lID0gXCIkXCIgKyBuYW1lO1xuICB2YXIgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXTtcbiAgaWYgKG90aGVyKSB7XG4gICAgdmFyIHJlZGVmaW5pdGlvbjtcbiAgICBpZiAoa2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIHJlZGVmaW5pdGlvbiA9IHRoaXMuc3RyaWN0ICYmIG90aGVyLmluaXQgfHwgb3RoZXIuZ2V0IHx8IG90aGVyLnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkZWZpbml0aW9uID0gb3RoZXIuaW5pdCB8fCBvdGhlcltraW5kXTtcbiAgICB9XG4gICAgaWYgKHJlZGVmaW5pdGlvbilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7IH1cbiAgfSBlbHNlIHtcbiAgICBvdGhlciA9IHByb3BIYXNoW25hbWVdID0ge1xuICAgICAgaW5pdDogZmFsc2UsXG4gICAgICBnZXQ6IGZhbHNlLFxuICAgICAgc2V0OiBmYWxzZVxuICAgIH07XG4gIH1cbiAgb3RoZXJba2luZF0gPSB0cnVlO1xufTtcblxuLy8gIyMjIEV4cHJlc3Npb24gcGFyc2luZ1xuXG4vLyBUaGVzZSBuZXN0LCBmcm9tIHRoZSBtb3N0IGdlbmVyYWwgZXhwcmVzc2lvbiB0eXBlIGF0IHRoZSB0b3AgdG9cbi8vICdhdG9taWMnLCBub25kaXZpc2libGUgZXhwcmVzc2lvbiB0eXBlcyBhdCB0aGUgYm90dG9tLiBNb3N0IG9mXG4vLyB0aGUgZnVuY3Rpb25zIHdpbGwgc2ltcGx5IGxldCB0aGUgZnVuY3Rpb24ocykgYmVsb3cgdGhlbSBwYXJzZSxcbi8vIGFuZCwgKmlmKiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCB0aGV5IGhhbmRsZSBpcyBwcmVzZW50LCB3cmFwXG4vLyB0aGUgQVNUIG5vZGUgdGhhdCB0aGUgaW5uZXIgcGFyc2VyIGdhdmUgdGhlbSBpbiBhbm90aGVyIG5vZGUuXG5cbi8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4vLyBmb3JiaWQgdGhlIGBpbmAgb3BlcmF0b3IgKGluIGZvciBsb29wcyBpbml0YWxpemF0aW9uIGV4cHJlc3Npb25zKVxuLy8gYW5kIHByb3ZpZGUgcmVmZXJlbmNlIGZvciBzdG9yaW5nICc9JyBvcGVyYXRvciBpbnNpZGUgc2hvcnRoYW5kXG4vLyBwcm9wZXJ0eSBhc3NpZ25tZW50IGluIGNvbnRleHRzIHdoZXJlIGJvdGggb2JqZWN0IGV4cHJlc3Npb25cbi8vIGFuZCBvYmplY3QgcGF0dGVybiBtaWdodCBhcHBlYXIgKHNvIGl0J3MgcG9zc2libGUgdG8gcmFpc2Vcbi8vIGRlbGF5ZWQgc3ludGF4IGVycm9yIGF0IGNvcnJlY3QgcG9zaXRpb24pLlxuXG5wcCQzLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgIHdoaWxlICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gIH1cbiAgcmV0dXJuIGV4cHJcbn07XG5cbi8vIFBhcnNlIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi4gVGhpcyBpbmNsdWRlcyBhcHBsaWNhdGlvbnMgb2Zcbi8vIG9wZXJhdG9ycyBsaWtlIGArPWAuXG5cbnBwJDMucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7XG4gICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IpIHsgcmV0dXJuIHRoaXMucGFyc2VZaWVsZChub0luKSB9XG4gICAgLy8gVGhlIHRva2VuaXplciB3aWxsIGFzc3VtZSBhbiBleHByZXNzaW9uIGlzIGFsbG93ZWQgYWZ0ZXJcbiAgICAvLyBgeWllbGRgLCBidXQgdGhpcyBpc24ndCB0aGF0IGtpbmQgb2YgeWllbGRcbiAgICBlbHNlIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gIH1cblxuICB2YXIgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZhbHNlLCBvbGRQYXJlbkFzc2lnbiA9IC0xLCBvbGRUcmFpbGluZ0NvbW1hID0gLTEsIG9sZFNob3J0aGFuZEFzc2lnbiA9IC0xO1xuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIG9sZFBhcmVuQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduO1xuICAgIG9sZFRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWE7XG4gICAgb2xkU2hvcnRoYW5kQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gICAgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IHRydWU7XG4gIH1cblxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpXG4gICAgeyB0aGlzLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXJ0OyB9XG4gIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmIChhZnRlckxlZnRQYXJzZSkgeyBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpOyB9XG4gIGlmICh0aGlzLnR5cGUuaXNBc3NpZ24pIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmVxID8gdGhpcy50b0Fzc2lnbmFibGUobGVmdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIDogbGVmdDtcbiAgICBpZiAoIW93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgRGVzdHJ1Y3R1cmluZ0Vycm9ycy5jYWxsKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSAtMTsgLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICB0aGlzLmNoZWNrTFZhbChsZWZ0KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIGlmIChvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gIH1cbiAgaWYgKG9sZFBhcmVuQXNzaWduID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gb2xkUGFyZW5Bc3NpZ247IH1cbiAgaWYgKG9sZFRyYWlsaW5nQ29tbWEgPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSBvbGRUcmFpbGluZ0NvbW1hOyB9XG4gIGlmIChvbGRTaG9ydGhhbmRBc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IG9sZFNob3J0aGFuZEFzc2lnbjsgfVxuICByZXR1cm4gbGVmdFxufTtcblxuLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxucHAkMy5wYXJzZU1heWJlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIilcbiAgfVxuICByZXR1cm4gZXhwclxufTtcblxuLy8gU3RhcnQgdGhlIHByZWNlZGVuY2UgcGFyc2VyLlxuXG5wcCQzLnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgcmV0dXJuIGV4cHIuc3RhcnQgPT09IHN0YXJ0UG9zICYmIGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID8gZXhwciA6IHRoaXMucGFyc2VFeHByT3AoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCAtMSwgbm9Jbilcbn07XG5cbi8vIFBhcnNlIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCB0aGUgb3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzaW5nXG4vLyBhbGdvcml0aG0uIGBsZWZ0YCBpcyB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIG9wZXJhdG9yLlxuLy8gYG1pblByZWNgIHByb3ZpZGVzIGNvbnRleHQgdGhhdCBhbGxvd3MgdGhlIGZ1bmN0aW9uIHRvIHN0b3AgYW5kXG4vLyBkZWZlciBmdXJ0aGVyIHBhcnNlciB0byBvbmUgb2YgaXRzIGNhbGxlcnMgd2hlbiBpdCBlbmNvdW50ZXJzIGFuXG4vLyBvcGVyYXRvciB0aGF0IGhhcyBhIGxvd2VyIHByZWNlZGVuY2UgdGhhbiB0aGUgc2V0IGl0IGlzIHBhcnNpbmcuXG5cbnBwJDMucGFyc2VFeHByT3AgPSBmdW5jdGlvbihsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbikge1xuICB2YXIgcHJlYyA9IHRoaXMudHlwZS5iaW5vcDtcbiAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdGhpcy50eXBlICE9PSB0eXBlcy5faW4pKSB7XG4gICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICB2YXIgbG9naWNhbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMubG9naWNhbE9SIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubG9naWNhbEFORDtcbiAgICAgIHZhciBvcCA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBzdGFydFBvcywgc3RhcnRMb2MsIHByZWMsIG5vSW4pO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG5wcCQzLmJ1aWxkQmluYXJ5ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgbm9kZS5yaWdodCA9IHJpZ2h0O1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGxvZ2ljYWwgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIHVuYXJ5IG9wZXJhdG9ycywgYm90aCBwcmVmaXggYW5kIHBvc3RmaXguXG5cbnBwJDMucGFyc2VNYXliZVVuYXJ5ID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgc2F3VW5hcnkpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBleHByO1xuICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJhd2FpdFwiKSAmJiAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSkpIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0KCk7XG4gICAgc2F3VW5hcnkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZS5wcmVmaXgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIHVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuaW5jRGVjO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgaWYgKHVwZGF0ZSkgeyB0aGlzLmNoZWNrTFZhbChub2RlLmFyZ3VtZW50KTsgfVxuICAgIGVsc2UgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiZcbiAgICAgICAgICAgICBub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgIGVsc2UgeyBzYXdVbmFyeSA9IHRydWU7IH1cbiAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSB7XG4gICAgZXhwciA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUucG9zdGZpeCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlJDEucHJlZml4ID0gZmFsc2U7XG4gICAgICBub2RlJDEuYXJndW1lbnQgPSBleHByO1xuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwcik7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIlVwZGF0ZUV4cHJlc3Npb25cIik7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzYXdVbmFyeSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyc3RhcikpXG4gICAgeyByZXR1cm4gdGhpcy5idWlsZEJpbmFyeShzdGFydFBvcywgc3RhcnRMb2MsIGV4cHIsIHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgXCIqKlwiLCBmYWxzZSkgfVxuICBlbHNlXG4gICAgeyByZXR1cm4gZXhwciB9XG59O1xuXG4vLyBQYXJzZSBjYWxsLCBkb3QsIGFuZCBgW11gLXN1YnNjcmlwdCBleHByZXNzaW9ucy5cblxucHAkMy5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJBdG9tKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICB2YXIgc2tpcEFycm93U3Vic2NyaXB0cyA9IGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva0VuZCkgIT09IFwiKVwiO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgfHwgc2tpcEFycm93U3Vic2NyaXB0cykgeyByZXR1cm4gZXhwciB9XG4gIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyhleHByLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZXN1bHQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gLTE7IH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuXG5wcCQzLnBhcnNlU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscykge1xuICB2YXIgbWF5YmVBc3luY0Fycm93ID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgYmFzZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBiYXNlLm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICAgdGhpcy5sYXN0VG9rRW5kID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmlucHV0LnNsaWNlKGJhc2Uuc3RhcnQsIGJhc2UuZW5kKSA9PT0gXCJhc3luY1wiO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIG1heWJlQXN5bmNBcnJvdyk7XG4gICAgaWYgKGVsZW1lbnQgPT09IGJhc2UgfHwgZWxlbWVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHsgcmV0dXJuIGVsZW1lbnQgfVxuICAgIGJhc2UgPSBlbGVtZW50O1xuICB9XG59O1xuXG5wcCQzLnBhcnNlU3Vic2NyaXB0ID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3cpIHtcbiAgdmFyIGNvbXB1dGVkID0gdGhpcy5lYXQodHlwZXMuYnJhY2tldEwpO1xuICBpZiAoY29tcHV0ZWQgfHwgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICBub2RlLnByb3BlcnR5ID0gY29tcHV0ZWQgPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpO1xuICAgIG5vZGUuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICAgIGlmIChjb21wdXRlZCkgeyB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7IH1cbiAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycywgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB2YXIgZXhwckxpc3QgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgIT09IFwiSW1wb3J0XCIsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAobWF5YmVBc3luY0Fycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgIGlmICh0aGlzLmF3YWl0SWRlbnRQb3MgPiAwKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5hd2FpdElkZW50UG9zLCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QsIHRydWUpXG4gICAgfVxuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcyB8fCB0aGlzLnlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3MgfHwgdGhpcy5hd2FpdElkZW50UG9zO1xuICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZSQxLmNhbGxlZSA9IGJhc2U7XG4gICAgbm9kZSQxLmFyZ3VtZW50cyA9IGV4cHJMaXN0O1xuICAgIGlmIChub2RlJDEuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICAgIGlmIChub2RlJDEuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aGlzLnJhaXNlKG5vZGUkMS5zdGFydCwgXCJpbXBvcnQoKSByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGltcG9ydEFyZyA9IG5vZGUkMS5hcmd1bWVudHNbMF07XG4gICAgICBpZiAoaW1wb3J0QXJnICYmIGltcG9ydEFyZy50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgICB0aGlzLnJhaXNlKGltcG9ydEFyZy5zdGFydCwgXCIuLi4gaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KClcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlKSB7XG4gICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlJDIudGFnID0gYmFzZTtcbiAgICBub2RlJDIucXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGUoe2lzVGFnZ2VkOiB0cnVlfSk7XG4gICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICB9XG4gIHJldHVybiBiYXNlXG59O1xuXG4vLyBQYXJzZSBhbiBhdG9taWMgZXhwcmVzc2lvbiDigJQgZWl0aGVyIGEgc2luZ2xlIHRva2VuIHRoYXQgaXMgYW5cbi8vIGV4cHJlc3Npb24sIGFuIGV4cHJlc3Npb24gc3RhcnRlZCBieSBhIGtleXdvcmQgbGlrZSBgZnVuY3Rpb25gIG9yXG4vLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbi8vIG9yIGB7fWAuXG5cbnBwJDMucGFyc2VFeHByQXRvbSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgLy8gSWYgYSBkaXZpc2lvbiBvcGVyYXRvciBhcHBlYXJzIGluIGFuIGV4cHJlc3Npb24gcG9zaXRpb24sIHRoZVxuICAvLyB0b2tlbml6ZXIgZ290IGNvbmZ1c2VkLCBhbmQgd2UgZm9yY2UgaXQgdG8gcmVhZCBhIHJlZ2V4cCBpbnN0ZWFkLlxuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zbGFzaCkgeyB0aGlzLnJlYWRSZWdleHAoKTsgfVxuXG4gIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXJ0O1xuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICBjYXNlIHR5cGVzLl9zdXBlcjpcbiAgICBpZiAoIXRoaXMuYWxsb3dTdXBlcilcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidzdXBlcicga2V5d29yZCBvdXRzaWRlIGEgbWV0aG9kXCIpOyB9XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MICYmICF0aGlzLmFsbG93RGlyZWN0U3VwZXIpXG4gICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJzdXBlcigpIGNhbGwgb3V0c2lkZSBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzXCIpOyB9XG4gICAgLy8gVGhlIGBzdXBlcmAga2V5d29yZCBjYW4gYXBwZWFyIGF0IGJlbG93OlxuICAgIC8vIFN1cGVyUHJvcGVydHk6XG4gICAgLy8gICAgIHN1cGVyIFsgRXhwcmVzc2lvbiBdXG4gICAgLy8gICAgIHN1cGVyIC4gSWRlbnRpZmllck5hbWVcbiAgICAvLyBTdXBlckNhbGw6XG4gICAgLy8gICAgIHN1cGVyIEFyZ3VtZW50c1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLmRvdCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNrZXRMICYmIHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdXBlclwiKVxuXG4gIGNhc2UgdHlwZXMuX3RoaXM6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpXG5cbiAgY2FzZSB0eXBlcy5uYW1lOlxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuX2Z1bmN0aW9uKSlcbiAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIDAsIGZhbHNlLCB0cnVlKSB9XG4gICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCBmYWxzZSkgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgIWNvbnRhaW5zRXNjKSB7XG4gICAgICAgIGlkID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkXG5cbiAgY2FzZSB0eXBlcy5yZWdleHA6XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgIG5vZGUucmVnZXggPSB7cGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzfTtcbiAgICByZXR1cm4gbm9kZVxuXG4gIGNhc2UgdHlwZXMubnVtOiBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSlcblxuICBjYXNlIHR5cGVzLl9udWxsOiBjYXNlIHR5cGVzLl90cnVlOiBjYXNlIHR5cGVzLl9mYWxzZTpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0eXBlcy5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl90cnVlO1xuICAgIG5vZGUucmF3ID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcblxuICBjYXNlIHR5cGVzLnBhcmVuTDpcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LCBleHByID0gdGhpcy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cpO1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCAmJiAhdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByKSlcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBzdGFydDsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSBzdGFydDsgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuXG4gIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5RXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgMClcblxuICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRoaXMuc3RhcnROb2RlKCksIGZhbHNlKVxuXG4gIGNhc2UgdHlwZXMuX25ldzpcbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldygpXG5cbiAgY2FzZSB0eXBlcy5iYWNrUXVvdGU6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZSgpXG5cbiAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VEeW5hbWljSW1wb3J0KClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudW5leHBlY3RlZCgpXG4gICAgfVxuXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbn07XG5cbnBwJDMucGFyc2VEeW5hbWljSW1wb3J0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuTCkge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRcIilcbn07XG5cbnBwJDMucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLnZhbHVlID0gdmFsdWU7XG4gIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gIGlmIChub2RlLnJhdy5jaGFyQ29kZUF0KG5vZGUucmF3Lmxlbmd0aCAtIDEpID09PSAxMTApIHsgbm9kZS5iaWdpbnQgPSBub2RlLnJhdy5zbGljZSgwLCAtMSk7IH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG59O1xuXG5wcCQzLnBhcnNlUGFyZW5FeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICByZXR1cm4gdmFsXG59O1xuXG5wcCQzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24gPSBmdW5jdGlvbihjYW5CZUFycm93KSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgdmFsLCBhbGxvd1RyYWlsaW5nQ29tbWEgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gODtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICB2YXIgaW5uZXJTdGFydFBvcyA9IHRoaXMuc3RhcnQsIGlubmVyU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByTGlzdCA9IFtdLCBmaXJzdCA9IHRydWUsIGxhc3RJc0NvbW1hID0gZmFsc2U7XG4gICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycywgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIHNwcmVhZFN0YXJ0O1xuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIC8vIERvIG5vdCBzYXZlIGF3YWl0SWRlbnRQb3MgdG8gYWxsb3cgY2hlY2tpbmcgYXdhaXRzIG5lc3RlZCBpbiBwYXJhbWV0ZXJzXG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5SKSB7XG4gICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLnBhcmVuUiwgdHJ1ZSkpIHtcbiAgICAgICAgbGFzdElzQ29tbWEgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0aGlzLnBhcnNlUGFyZW5JdGVtKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbm5lckVuZFBvcyA9IHRoaXMuc3RhcnQsIGlubmVyRW5kTG9jID0gdGhpcy5zdGFydExvYztcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuXG4gICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KVxuICAgIH1cblxuICAgIGlmICghZXhwckxpc3QubGVuZ3RoIHx8IGxhc3RJc0NvbW1hKSB7IHRoaXMudW5leHBlY3RlZCh0aGlzLmxhc3RUb2tTdGFydCk7IH1cbiAgICBpZiAoc3ByZWFkU3RhcnQpIHsgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTsgfVxuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcyB8fCB0aGlzLnlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuXG4gICAgaWYgKGV4cHJMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhbCA9IHRoaXMuc3RhcnROb2RlQXQoaW5uZXJTdGFydFBvcywgaW5uZXJTdGFydExvYyk7XG4gICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgIHRoaXMuZmluaXNoTm9kZUF0KHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgaW5uZXJFbmRQb3MsIGlubmVyRW5kTG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMucHJlc2VydmVQYXJlbnMpIHtcbiAgICB2YXIgcGFyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIHBhci5leHByZXNzaW9uID0gdmFsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocGFyLCBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbFxuICB9XG59O1xuXG5wcCQzLnBhcnNlUGFyZW5JdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICByZXR1cm4gaXRlbVxufTtcblxucHAkMy5wYXJzZVBhcmVuQXJyb3dMaXN0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCkge1xuICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0KVxufTtcblxuLy8gTmV3J3MgcHJlY2VkZW5jZSBpcyBzbGlnaHRseSB0cmlja3kuIEl0IG11c3QgYWxsb3cgaXRzIGFyZ3VtZW50IHRvXG4vLyBiZSBhIGBbXWAgb3IgZG90IHN1YnNjcmlwdCBleHByZXNzaW9uLCBidXQgbm90IGEgY2FsbCDigJQgYXQgbGVhc3QsXG4vLyBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGUgbm9DYWxsc1xuLy8gYXJndW1lbnQgdG8gcGFyc2VTdWJzY3JpcHRzIHRvIHByZXZlbnQgaXQgZnJvbSBjb25zdW1pbmcgdGhlXG4vLyBhcmd1bWVudCBsaXN0LlxuXG52YXIgZW1wdHkkMSA9IFtdO1xuXG5wcCQzLnBhcnNlTmV3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIG1ldGEgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJ0YXJnZXRcIiB8fCBjb250YWluc0VzYylcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzIG5ldy50YXJnZXRcIik7IH1cbiAgICBpZiAoIXRoaXMuaW5Ob25BcnJvd0Z1bmN0aW9uKCkpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIm5ldy50YXJnZXQgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnNcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gIH1cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbSgpLCBzdGFydFBvcywgc3RhcnRMb2MsIHRydWUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID4gMTAgJiYgbm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgIHRoaXMucmFpc2Uobm9kZS5jYWxsZWUuc3RhcnQsIFwiQ2Fubm90IHVzZSBuZXcgd2l0aCBpbXBvcnQoLi4uKVwiKTtcbiAgfVxuICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkgeyBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5wYXJlblIsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIG5vZGUuY2FsbGVlLnR5cGUgIT09IFwiSW1wb3J0XCIsIGZhbHNlKTsgfVxuICBlbHNlIHsgbm9kZS5hcmd1bWVudHMgPSBlbXB0eSQxOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSB0ZW1wbGF0ZSBleHByZXNzaW9uLlxuXG5wcCQzLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24ocmVmKSB7XG4gIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDtcblxuICB2YXIgZWxlbSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmludmFsaWRUZW1wbGF0ZSkge1xuICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkJhZCBlc2NhcGUgc2VxdWVuY2UgaW4gdW50YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICB9XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy52YWx1ZSxcbiAgICAgIGNvb2tlZDogbnVsbFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdGhpcy52YWx1ZVxuICAgIH07XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIGVsZW0udGFpbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGVsZW0sIFwiVGVtcGxhdGVFbGVtZW50XCIpXG59O1xuXG5wcCQzLnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbihyZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7IGlmICggaXNUYWdnZWQgPT09IHZvaWQgMCApIGlzVGFnZ2VkID0gZmFsc2U7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSk7XG4gIG5vZGUucXVhc2lzID0gW2N1ckVsdF07XG4gIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lb2YpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTsgfVxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmRvbGxhckJyYWNlTCk7XG4gICAgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgbm9kZS5xdWFzaXMucHVzaChjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KSk7XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUZW1wbGF0ZUxpdGVyYWxcIilcbn07XG5cbnBwJDMuaXNBc3luY1Byb3AgPSBmdW5jdGlvbihwcm9wKSB7XG4gIHJldHVybiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBwcm9wLmtleS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuYnJhY2tldEwgfHwgdGhpcy50eXBlLmtleXdvcmQgfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuc3RhcikpICYmXG4gICAgIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbn07XG5cbi8vIFBhcnNlIGFuIG9iamVjdCBsaXRlcmFsIG9yIGJpbmRpbmcgcGF0dGVybi5cblxucHAkMy5wYXJzZU9iaiA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgcHJvcEhhc2ggPSB7fTtcbiAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gIHRoaXMubmV4dCgpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHkoaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAoIWlzUGF0dGVybikgeyB0aGlzLmNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUmVzdEVsZW1lbnRcIilcbiAgICB9XG4gICAgLy8gVG8gZGlzYWxsb3cgcGFyZW50aGVzaXplZCBpZGVudGlmaWVyIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnNlIGFyZ3VtZW50LlxuICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIC8vIFRvIGRpc2FsbG93IHRyYWlsaW5nIGNvbW1hIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKSB7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICAvLyBGaW5pc2hcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgcHJvcC5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB9XG4gICAgaWYgKCFpc1BhdHRlcm4pXG4gICAgICB7IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7IH1cbiAgfVxuICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIH0gZWxzZSB7XG4gICAgaXNBc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIilcbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYykge1xuICBpZiAoKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29sb24pXG4gICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5jb2xvbikpIHtcbiAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwpIHtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgfSBlbHNlIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJlxuICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAodGhpcy50eXBlICE9PSB0eXBlcy5jb21tYSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChmYWxzZSk7XG4gICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICBpZiAocHJvcC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICB2YXIgc3RhcnQgPSBwcm9wLnZhbHVlLnN0YXJ0O1xuICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJzZXRcIiAmJiBwcm9wLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3AudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChwcm9wLmtleSk7XG4gICAgaWYgKHByb3Aua2V5Lm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBzdGFydFBvczsgfVxuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lcSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGFydDsgfVxuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AudmFsdWUgPSBwcm9wLmtleTtcbiAgICB9XG4gICAgcHJvcC5zaG9ydGhhbmQgPSB0cnVlO1xuICB9IGVsc2UgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxucHAkMy5wYXJzZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKSkge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpO1xuICAgICAgcmV0dXJuIHByb3Aua2V5XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3Aua2V5ID0gdGhpcy50eXBlID09PSB0eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKVxufTtcblxuLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG5wcCQzLmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZS5pZCA9IG51bGw7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyBub2RlLmdlbmVyYXRvciA9IG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gZmFsc2U7IH1cbn07XG5cbi8vIFBhcnNlIG9iamVjdCBvciBjbGFzcyBtZXRob2QuXG5cbnBwJDMucGFyc2VNZXRob2QgPSBmdW5jdGlvbihpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dEaXJlY3RTdXBlcikge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgeyBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSB8IFNDT1BFX1NVUEVSIHwgKGFsbG93RGlyZWN0U3VwZXIgPyBTQ09QRV9ESVJFQ1RfU1VQRVIgOiAwKSk7XG5cbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCB0cnVlKTtcblxuICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMuXG5cbnBwJDMucGFyc2VBcnJvd0V4cHJlc3Npb24gPSBmdW5jdGlvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMpIHtcbiAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIGZhbHNlKSB8IFNDT1BFX0FSUk9XKTtcbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgdGhpcy55aWVsZFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRQb3MgPSAwO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuXG4gIG5vZGUucGFyYW1zID0gdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSwgZmFsc2UpO1xuXG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIGZ1bmN0aW9uIGJvZHkgYW5kIGNoZWNrIHBhcmFtZXRlcnMuXG5cbnBwJDMucGFyc2VGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbihub2RlLCBpc0Fycm93RnVuY3Rpb24sIGlzTWV0aG9kKSB7XG4gIHZhciBpc0V4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZUw7XG4gIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdCwgdXNlU3RyaWN0ID0gZmFsc2U7XG5cbiAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vblNpbXBsZSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmICF0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKTtcbiAgICBpZiAoIW9sZFN0cmljdCB8fCBub25TaW1wbGUpIHtcbiAgICAgIHVzZVN0cmljdCA9IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMuZW5kKTtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBzdHJpY3QgbW9kZSBmdW5jdGlvbiwgdmVyaWZ5IHRoYXQgYXJndW1lbnQgbmFtZXNcbiAgICAgIC8vIGFyZSBub3QgcmVwZWF0ZWQsIGFuZCBpdCBkb2VzIG5vdCB0cnkgdG8gYmluZCB0aGUgd29yZHMgYGV2YWxgXG4gICAgICAvLyBvciBgYXJndW1lbnRzYC5cbiAgICAgIGlmICh1c2VTdHJpY3QgJiYgbm9uU2ltcGxlKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIklsbGVnYWwgJ3VzZSBzdHJpY3QnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3RcIik7IH1cbiAgICB9XG4gICAgLy8gU3RhcnQgYSBuZXcgc2NvcGUgd2l0aCByZWdhcmQgdG8gbGFiZWxzIGFuZCB0aGUgYGluRnVuY3Rpb25gXG4gICAgLy8gZmxhZyAocmVzdG9yZSB0aGVtIHRvIHRoZWlyIG9sZCB2YWx1ZSBhZnRlcndhcmRzKS5cbiAgICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICBpZiAodXNlU3RyaWN0KSB7IHRoaXMuc3RyaWN0ID0gdHJ1ZTsgfVxuXG4gICAgLy8gQWRkIHRoZSBwYXJhbXMgdG8gdmFyRGVjbGFyZWROYW1lcyB0byBlbnN1cmUgdGhhdCBhbiBlcnJvciBpcyB0aHJvd25cbiAgICAvLyBpZiBhIGxldC9jb25zdCBkZWNsYXJhdGlvbiBpbiB0aGUgZnVuY3Rpb24gY2xhc2hlcyB3aXRoIG9uZSBvZiB0aGUgcGFyYW1zLlxuICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgIW9sZFN0cmljdCAmJiAhdXNlU3RyaWN0ICYmICFpc0Fycm93RnVuY3Rpb24gJiYgIWlzTWV0aG9kICYmIHRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkuYm9keSk7XG4gICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gIH1cbiAgdGhpcy5leGl0U2NvcGUoKTtcblxuICAvLyBFbnN1cmUgdGhlIGZ1bmN0aW9uIG5hbWUgaXNuJ3QgYSBmb3JiaWRkZW4gaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZSwgZS5nLiAnZXZhbCdcbiAgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUuaWQpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgQklORF9PVVRTSURFKTsgfVxuICB0aGlzLnN0cmljdCA9IG9sZFN0cmljdDtcbn07XG5cbnBwJDMuaXNTaW1wbGVQYXJhbUxpc3QgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7IHJldHVybiBmYWxzZVxuICB9IH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIENoZWNrcyBmdW5jdGlvbiBwYXJhbXMgZm9yIHZhcmlvdXMgZGlzYWxsb3dlZCBwYXR0ZXJucyBzdWNoIGFzIHVzaW5nIFwiZXZhbFwiXG4vLyBvciBcImFyZ3VtZW50c1wiIGFuZCBkdXBsaWNhdGUgcGFyYW1ldGVycy5cblxucHAkMy5jaGVja1BhcmFtcyA9IGZ1bmN0aW9uKG5vZGUsIGFsbG93RHVwbGljYXRlcykge1xuICB2YXIgbmFtZUhhc2ggPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICB0aGlzLmNoZWNrTFZhbChwYXJhbSwgQklORF9WQVIsIGFsbG93RHVwbGljYXRlcyA/IG51bGwgOiBuYW1lSGFzaCk7XG4gIH1cbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGV4cHJlc3Npb25zLCBhbmQgcmV0dXJucyB0aGVtIGFzXG4vLyBhbiBhcnJheS4gYGNsb3NlYCBpcyB0aGUgdG9rZW4gdHlwZSB0aGF0IGVuZHMgdGhlIGxpc3QsIGFuZFxuLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuLy8gbm90aGluZyBpbiBiZXR3ZWVuIHRoZW0gdG8gYmUgcGFyc2VkIGFzIGBudWxsYCAod2hpY2ggaXMgbmVlZGVkXG4vLyBmb3IgYXJyYXkgbGl0ZXJhbHMpLlxuXG5wcCQzLnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIGVsdCA9ICh2b2lkIDApO1xuICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpXG4gICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICBlbHQgPSB0aGlzLnBhcnNlU3ByZWFkKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWx0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICB9XG4gICAgZWx0cy5wdXNoKGVsdCk7XG4gIH1cbiAgcmV0dXJuIGVsdHNcbn07XG5cbnBwJDMuY2hlY2tVbnJlc2VydmVkID0gZnVuY3Rpb24ocmVmKSB7XG4gIHZhciBzdGFydCA9IHJlZi5zdGFydDtcbiAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gIHZhciBuYW1lID0gcmVmLm5hbWU7XG5cbiAgaWYgKHRoaXMuaW5HZW5lcmF0b3IgJiYgbmFtZSA9PT0gXCJ5aWVsZFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ3lpZWxkJyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIGdlbmVyYXRvclwiKTsgfVxuICBpZiAodGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgaWYgKHRoaXMua2V5d29yZHMudGVzdChuYW1lKSlcbiAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIlVuZXhwZWN0ZWQga2V5d29yZCAnXCIgKyBuYW1lICsgXCInXCIpKTsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiAmJlxuICAgIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkuaW5kZXhPZihcIlxcXFxcIikgIT09IC0xKSB7IHJldHVybiB9XG4gIHZhciByZSA9IHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzO1xuICBpZiAocmUudGVzdChuYW1lKSkge1xuICAgIGlmICghdGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2Uga2V5d29yZCAnYXdhaXQnIG91dHNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIChcIlRoZSBrZXl3b3JkICdcIiArIG5hbWUgKyBcIicgaXMgcmVzZXJ2ZWRcIikpO1xuICB9XG59O1xuXG4vLyBQYXJzZSB0aGUgbmV4dCB0b2tlbiBhcyBhbiBpZGVudGlmaWVyLiBJZiBgbGliZXJhbGAgaXMgdHJ1ZSAodXNlZFxuLy8gd2hlbiBwYXJzaW5nIHByb3BlcnRpZXMpLCBpdCB3aWxsIGFsc28gY29udmVydCBrZXl3b3JkcyBpbnRvXG4vLyBpZGVudGlmaWVycy5cblxucHAkMy5wYXJzZUlkZW50ID0gZnVuY3Rpb24obGliZXJhbCwgaXNCaW5kaW5nKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMudmFsdWU7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlLmtleXdvcmQpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnR5cGUua2V5d29yZDtcblxuICAgIC8vIFRvIGZpeCBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi9pc3N1ZXMvNTc1XG4gICAgLy8gYGNsYXNzYCBhbmQgYGZ1bmN0aW9uYCBrZXl3b3JkcyBwdXNoIG5ldyBjb250ZXh0IGludG8gdGhpcy5jb250ZXh0LlxuICAgIC8vIEJ1dCB0aGVyZSBpcyBubyBjaGFuY2UgdG8gcG9wIHRoZSBjb250ZXh0IGlmIHRoZSBrZXl3b3JkIGlzIGNvbnN1bWVkIGFzIGFuIGlkZW50aWZpZXIgc3VjaCBhcyBhIHByb3BlcnR5IG5hbWUuXG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIHRva2VuIGlzIGEgZG90LCB0aGlzIGRvZXMgbm90IGFwcGx5IGJlY2F1c2UgdGhlIGNvbnRleHQtbWFuYWdpbmcgY29kZSBhbHJlYWR5IGlnbm9yZWQgdGhlIGtleXdvcmRcbiAgICBpZiAoKG5vZGUubmFtZSA9PT0gXCJjbGFzc1wiIHx8IG5vZGUubmFtZSA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAodGhpcy5sYXN0VG9rRW5kICE9PSB0aGlzLmxhc3RUb2tTdGFydCArIDEgfHwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubGFzdFRva1N0YXJ0KSAhPT0gNDYpKSB7XG4gICAgICB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICBpZiAoIWxpYmVyYWwpIHtcbiAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlKTtcbiAgICBpZiAobm9kZS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gbm9kZS5zdGFydDsgfVxuICB9XG4gIHJldHVybiBub2RlXG59O1xuXG4vLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG5wcCQzLnBhcnNlWWllbGQgPSBmdW5jdGlvbihub0luKSB7XG4gIGlmICghdGhpcy55aWVsZFBvcykgeyB0aGlzLnlpZWxkUG9zID0gdGhpcy5zdGFydDsgfVxuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAodGhpcy50eXBlICE9PSB0eXBlcy5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxufTtcblxucHAkMy5wYXJzZUF3YWl0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5hd2FpdFBvcykgeyB0aGlzLmF3YWl0UG9zID0gdGhpcy5zdGFydDsgfVxuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkF3YWl0RXhwcmVzc2lvblwiKVxufTtcblxudmFyIHBwJDQgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmFpc2UgZXhjZXB0aW9ucyBvbiBwYXJzZSBlcnJvcnMuIEl0XG4vLyB0YWtlcyBhbiBvZmZzZXQgaW50ZWdlciAoaW50byB0aGUgY3VycmVudCBgaW5wdXRgKSB0byBpbmRpY2F0ZVxuLy8gdGhlIGxvY2F0aW9uIG9mIHRoZSBlcnJvciwgYXR0YWNoZXMgdGhlIHBvc2l0aW9uIHRvIHRoZSBlbmRcbi8vIG9mIHRoZSBlcnJvciBtZXNzYWdlLCBhbmQgdGhlbiByYWlzZXMgYSBgU3ludGF4RXJyb3JgIHdpdGggdGhhdFxuLy8gbWVzc2FnZS5cblxucHAkNC5yYWlzZSA9IGZ1bmN0aW9uKHBvcywgbWVzc2FnZSkge1xuICB2YXIgbG9jID0gZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcG9zKTtcbiAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICBlcnIucG9zID0gcG9zOyBlcnIubG9jID0gbG9jOyBlcnIucmFpc2VkQXQgPSB0aGlzLnBvcztcbiAgdGhyb3cgZXJyXG59O1xuXG5wcCQ0LnJhaXNlUmVjb3ZlcmFibGUgPSBwcCQ0LnJhaXNlO1xuXG5wcCQ0LmN1clBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpXG4gIH1cbn07XG5cbnZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxudmFyIFNjb3BlID0gZnVuY3Rpb24gU2NvcGUoZmxhZ3MpIHtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAvLyBBIGxpc3Qgb2YgdmFyLWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgdGhpcy52YXIgPSBbXTtcbiAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIHRoaXMubGV4aWNhbCA9IFtdO1xuICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIEZ1bmN0aW9uRGVjbGFyYXRpb24gbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xufTtcblxuLy8gVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBrZWVwIHRyYWNrIG9mIGRlY2xhcmVkIHZhcmlhYmxlcyBpbiB0aGUgY3VycmVudCBzY29wZSBpbiBvcmRlciB0byBkZXRlY3QgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWVzLlxuXG5wcCQ1LmVudGVyU2NvcGUgPSBmdW5jdGlvbihmbGFncykge1xuICB0aGlzLnNjb3BlU3RhY2sucHVzaChuZXcgU2NvcGUoZmxhZ3MpKTtcbn07XG5cbnBwJDUuZXhpdFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2NvcGVTdGFjay5wb3AoKTtcbn07XG5cbi8vIFRoZSBzcGVjIHNheXM6XG4vLyA+IEF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmdW5jdGlvbiwgb3Igc2NyaXB0LCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgYXJlXG4vLyA+IHRyZWF0ZWQgbGlrZSB2YXIgZGVjbGFyYXRpb25zIHJhdGhlciB0aGFuIGxpa2UgbGV4aWNhbCBkZWNsYXJhdGlvbnMuXG5wcCQ1LnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlID0gZnVuY3Rpb24oc2NvcGUpIHtcbiAgcmV0dXJuIChzY29wZS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSB8fCAhdGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApXG59O1xuXG5wcCQ1LmRlY2xhcmVOYW1lID0gZnVuY3Rpb24obmFtZSwgYmluZGluZ1R5cGUsIHBvcykge1xuICB2YXIgcmVkZWNsYXJlZCA9IGZhbHNlO1xuICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCkge1xuICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgcmVkZWNsYXJlZCA9IHNjb3BlLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLmZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUudmFyLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgICBzY29wZS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX1NJTVBMRV9DQVRDSCkge1xuICAgIHZhciBzY29wZSQxID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBzY29wZSQxLmxleGljYWwucHVzaChuYW1lKTtcbiAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9GVU5DVElPTikge1xuICAgIHZhciBzY29wZSQyID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBpZiAodGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyKVxuICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUkMi52YXIuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgc2NvcGUkMi5mdW5jdGlvbnMucHVzaChuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgc2NvcGUkMyA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChzY29wZSQzLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xICYmICEoKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9TSU1QTEVfQ0FUQ0gpICYmIHNjb3BlJDMubGV4aWNhbFswXSA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSQzKSAmJiBzY29wZSQzLmZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgcmVkZWNsYXJlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBzY29wZSQzLnZhci5wdXNoKG5hbWUpO1xuICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgICAgIGlmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVkFSKSB7IGJyZWFrIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlZGVjbGFyZWQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgKFwiSWRlbnRpZmllciAnXCIgKyBuYW1lICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWRcIikpOyB9XG59O1xuXG5wcCQ1LmNoZWNrTG9jYWxFeHBvcnQgPSBmdW5jdGlvbihpZCkge1xuICAvLyBzY29wZS5mdW5jdGlvbnMgbXVzdCBiZSBlbXB0eSBhcyBNb2R1bGUgY29kZSBpcyBhbHdheXMgc3RyaWN0LlxuICBpZiAodGhpcy5zY29wZVN0YWNrWzBdLmxleGljYWwuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEgJiZcbiAgICAgIHRoaXMuc2NvcGVTdGFja1swXS52YXIuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEpIHtcbiAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbaWQubmFtZV0gPSBpZDtcbiAgfVxufTtcblxucHAkNS5jdXJyZW50U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV1cbn07XG5cbnBwJDUuY3VycmVudFZhclNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9WQVIpIHsgcmV0dXJuIHNjb3BlIH1cbiAgfVxufTtcblxuLy8gQ291bGQgYmUgdXNlZnVsIGZvciBgdGhpc2AsIGBuZXcudGFyZ2V0YCwgYHN1cGVyKClgLCBgc3VwZXIucHJvcGVydHlgLCBhbmQgYHN1cGVyW3Byb3BlcnR5XWAuXG5wcCQ1LmN1cnJlbnRUaGlzU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUiAmJiAhKHNjb3BlLmZsYWdzICYgU0NPUEVfQVJST1cpKSB7IHJldHVybiBzY29wZSB9XG4gIH1cbn07XG5cbnZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShwYXJzZXIsIHBvcywgbG9jKSB7XG4gIHRoaXMudHlwZSA9IFwiXCI7XG4gIHRoaXMuc3RhcnQgPSBwb3M7XG4gIHRoaXMuZW5kID0gMDtcbiAgaWYgKHBhcnNlci5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHBhcnNlciwgbG9jKTsgfVxuICBpZiAocGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcbiAgICB7IHRoaXMuc291cmNlRmlsZSA9IHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGU7IH1cbiAgaWYgKHBhcnNlci5vcHRpb25zLnJhbmdlcylcbiAgICB7IHRoaXMucmFuZ2UgPSBbcG9zLCAwXTsgfVxufTtcblxuLy8gU3RhcnQgYW4gQVNUIG5vZGUsIGF0dGFjaGluZyBhIHN0YXJ0IG9mZnNldC5cblxudmFyIHBwJDYgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5wcCQ2LnN0YXJ0Tm9kZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5zdGFydCwgdGhpcy5zdGFydExvYylcbn07XG5cbnBwJDYuc3RhcnROb2RlQXQgPSBmdW5jdGlvbihwb3MsIGxvYykge1xuICByZXR1cm4gbmV3IE5vZGUodGhpcywgcG9zLCBsb2MpXG59O1xuXG4vLyBGaW5pc2ggYW4gQVNUIG5vZGUsIGFkZGluZyBgdHlwZWAgYW5kIGBlbmRgIHByb3BlcnRpZXMuXG5cbmZ1bmN0aW9uIGZpbmlzaE5vZGVBdChub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICBub2RlLnR5cGUgPSB0eXBlO1xuICBub2RlLmVuZCA9IHBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyBub2RlLmxvYy5lbmQgPSBsb2M7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpXG4gICAgeyBub2RlLnJhbmdlWzFdID0gcG9zOyB9XG4gIHJldHVybiBub2RlXG59XG5cbnBwJDYuZmluaXNoTm9kZSA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUpIHtcbiAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKVxufTtcblxuLy8gRmluaXNoIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cblxucHAkNi5maW5pc2hOb2RlQXQgPSBmdW5jdGlvbihub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgcG9zLCBsb2MpXG59O1xuXG4vLyBUaGUgYWxnb3JpdGhtIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSByZWdleHAgY2FuIGFwcGVhciBhdCBhXG5cbnZhciBUb2tDb250ZXh0ID0gZnVuY3Rpb24gVG9rQ29udGV4dCh0b2tlbiwgaXNFeHByLCBwcmVzZXJ2ZVNwYWNlLCBvdmVycmlkZSwgZ2VuZXJhdG9yKSB7XG4gIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgdGhpcy5pc0V4cHIgPSAhIWlzRXhwcjtcbiAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gISFwcmVzZXJ2ZVNwYWNlO1xuICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gIHRoaXMuZ2VuZXJhdG9yID0gISFnZW5lcmF0b3I7XG59O1xuXG52YXIgdHlwZXMkMSA9IHtcbiAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICBiX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwie1wiLCB0cnVlKSxcbiAgYl90bXBsOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIGZhbHNlKSxcbiAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICBwX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCB0cnVlKSxcbiAgcV90bXBsOiBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudHJ5UmVhZFRlbXBsYXRlVG9rZW4oKTsgfSksXG4gIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gIGZfZXhwcjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlKSxcbiAgZl9leHByX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlLCBmYWxzZSwgbnVsbCwgdHJ1ZSksXG4gIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbn07XG5cbnZhciBwcCQ3ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkNy5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW3R5cGVzJDEuYl9zdGF0XVxufTtcblxucHAkNy5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gIGlmIChwYXJlbnQgPT09IHR5cGVzJDEuZl9leHByIHx8IHBhcmVudCA9PT0gdHlwZXMkMS5mX3N0YXQpXG4gICAgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfHwgcGFyZW50ID09PSB0eXBlcyQxLmJfZXhwcikpXG4gICAgeyByZXR1cm4gIXBhcmVudC5pc0V4cHIgfVxuXG4gIC8vIFRoZSBjaGVjayBmb3IgYHR0Lm5hbWUgJiYgZXhwckFsbG93ZWRgIGRldGVjdHMgd2hldGhlciB3ZSBhcmVcbiAgLy8gYWZ0ZXIgYSBgeWllbGRgIG9yIGBvZmAgY29uc3RydWN0LiBTZWUgdGhlIGB1cGRhdGVDb250ZXh0YCBmb3JcbiAgLy8gYHR0Lm5hbWVgLlxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy5leHByQWxsb3dlZClcbiAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fZWxzZSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuc2VtaSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuZW9mIHx8IHByZXZUeXBlID09PSB0eXBlcy5wYXJlblIgfHwgcHJldlR5cGUgPT09IHR5cGVzLmFycm93KVxuICAgIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTClcbiAgICB7IHJldHVybiBwYXJlbnQgPT09IHR5cGVzJDEuYl9zdGF0IH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fdmFyIHx8IHByZXZUeXBlID09PSB0eXBlcy5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUpXG4gICAgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gIXRoaXMuZXhwckFsbG93ZWRcbn07XG5cbnBwJDcuaW5HZW5lcmF0b3JDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTsgaSA+PSAxOyBpLS0pIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFtpXTtcbiAgICBpZiAoY29udGV4dC50b2tlbiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgeyByZXR1cm4gY29udGV4dC5nZW5lcmF0b3IgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxucHAkNy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIHVwZGF0ZSwgdHlwZSA9IHRoaXMudHlwZTtcbiAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PT0gdHlwZXMuZG90KVxuICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICB7IHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG59O1xuXG4vLyBUb2tlbi1zcGVjaWZpYyBjb250ZXh0IHVwZGF0ZSBjb2RlXG5cbnR5cGVzLnBhcmVuUi51cGRhdGVDb250ZXh0ID0gdHlwZXMuYnJhY2VSLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICBpZiAob3V0ID09PSB0eXBlcyQxLmJfc3RhdCAmJiB0aGlzLmN1ckNvbnRleHQoKS50b2tlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSAhb3V0LmlzRXhwcjtcbn07XG5cbnR5cGVzLmJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdGhpcy5jb250ZXh0LnB1c2godGhpcy5icmFjZUlzQmxvY2socHJldlR5cGUpID8gdHlwZXMkMS5iX3N0YXQgOiB0eXBlcyQxLmJfZXhwcik7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5iX3RtcGwpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLnBhcmVuTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcy5faWYgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9mb3IgfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2hpbGU7XG4gIHRoaXMuY29udGV4dC5wdXNoKHN0YXRlbWVudFBhcmVucyA/IHR5cGVzJDEucF9zdGF0IDogdHlwZXMkMS5wX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLmluY0RlYy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHRva0V4cHJBbGxvd2VkIHN0YXlzIHVuY2hhbmdlZFxufTtcblxudHlwZXMuX2Z1bmN0aW9uLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIGlmIChwcmV2VHlwZS5iZWZvcmVFeHByICYmIHByZXZUeXBlICE9PSB0eXBlcy5zZW1pICYmIHByZXZUeXBlICE9PSB0eXBlcy5fZWxzZSAmJlxuICAgICAgIShwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKSAmJlxuICAgICAgISgocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uIHx8IHByZXZUeXBlID09PSB0eXBlcy5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLmJfc3RhdCkpXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmZfZXhwcik7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX3N0YXQpOyB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzLmJhY2tRdW90ZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5xX3RtcGwpXG4gICAgeyB0aGlzLmNvbnRleHQucG9wKCk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5xX3RtcGwpOyB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzLnN0YXIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Z1bmN0aW9uKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7XG4gICAgaWYgKHRoaXMuY29udGV4dFtpbmRleF0gPT09IHR5cGVzJDEuZl9leHByKVxuICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2V4cHJfZ2VuOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2dlbjsgfVxuICB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMubmFtZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcy5kb3QpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJvZlwiICYmICF0aGlzLmV4cHJBbGxvd2VkIHx8XG4gICAgICAgIHRoaXMudmFsdWUgPT09IFwieWllbGRcIiAmJiB0aGlzLmluR2VuZXJhdG9yQ29udGV4dCgpKVxuICAgICAgeyBhbGxvd2VkID0gdHJ1ZTsgfVxuICB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBhbGxvd2VkO1xufTtcblxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIFVuaWNvZGUgcHJvcGVydGllcyBleHRyYWN0ZWQgZnJvbSB0aGUgRUNNQVNjcmlwdFxuLy8gc3BlY2lmaWNhdGlvbi4gVGhlIGxpc3RzIGFyZSBleHRyYWN0ZWQgbGlrZSBzbzpcbi8vICQkKCcjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllcyA+IGZpZ3VyZSA+IHRhYmxlID4gdGJvZHkgPiB0ciA+IHRkOm50aC1jaGlsZCgxKSBjb2RlJykubWFwKGVsID0+IGVsLmlubmVyVGV4dClcblxuLy8gI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXNcbnZhciBlY21hOUJpbmFyeVByb3BlcnRpZXMgPSBcIkFTQ0lJIEFTQ0lJX0hleF9EaWdpdCBBSGV4IEFscGhhYmV0aWMgQWxwaGEgQW55IEFzc2lnbmVkIEJpZGlfQ29udHJvbCBCaWRpX0MgQmlkaV9NaXJyb3JlZCBCaWRpX00gQ2FzZV9JZ25vcmFibGUgQ0kgQ2FzZWQgQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQgQ1dDRiBDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNIENoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkIENXTCBDaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkIENXS0NGIENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVCBDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZCBDV1UgRGFzaCBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJIERlcHJlY2F0ZWQgRGVwIERpYWNyaXRpYyBEaWEgRW1vamkgRW1vamlfQ29tcG9uZW50IEVtb2ppX01vZGlmaWVyIEVtb2ppX01vZGlmaWVyX0Jhc2UgRW1vamlfUHJlc2VudGF0aW9uIEV4dGVuZGVyIEV4dCBHcmFwaGVtZV9CYXNlIEdyX0Jhc2UgR3JhcGhlbWVfRXh0ZW5kIEdyX0V4dCBIZXhfRGlnaXQgSGV4IElEU19CaW5hcnlfT3BlcmF0b3IgSURTQiBJRFNfVHJpbmFyeV9PcGVyYXRvciBJRFNUIElEX0NvbnRpbnVlIElEQyBJRF9TdGFydCBJRFMgSWRlb2dyYXBoaWMgSWRlbyBKb2luX0NvbnRyb2wgSm9pbl9DIExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRSBMb3dlcmNhc2UgTG93ZXIgTWF0aCBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhciBQYXR0ZXJuX1N5bnRheCBQYXRfU3luIFBhdHRlcm5fV2hpdGVfU3BhY2UgUGF0X1dTIFF1b3RhdGlvbl9NYXJrIFFNYXJrIFJhZGljYWwgUmVnaW9uYWxfSW5kaWNhdG9yIFJJIFNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtIFNvZnRfRG90dGVkIFNEIFRlcm1pbmFsX1B1bmN0dWF0aW9uIFRlcm0gVW5pZmllZF9JZGVvZ3JhcGggVUlkZW8gVXBwZXJjYXNlIFVwcGVyIFZhcmlhdGlvbl9TZWxlY3RvciBWUyBXaGl0ZV9TcGFjZSBzcGFjZSBYSURfQ29udGludWUgWElEQyBYSURfU3RhcnQgWElEU1wiO1xudmFyIGVjbWExMEJpbmFyeVByb3BlcnRpZXMgPSBlY21hOUJpbmFyeVByb3BlcnRpZXMgKyBcIiBFeHRlbmRlZF9QaWN0b2dyYXBoaWNcIjtcbnZhciBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTEwQmluYXJ5UHJvcGVydGllcztcbnZhciB1bmljb2RlQmluYXJ5UHJvcGVydGllcyA9IHtcbiAgOTogZWNtYTlCaW5hcnlQcm9wZXJ0aWVzLFxuICAxMDogZWNtYTEwQmluYXJ5UHJvcGVydGllcyxcbiAgMTE6IGVjbWExMUJpbmFyeVByb3BlcnRpZXNcbn07XG5cbi8vICN0YWJsZS11bmljb2RlLWdlbmVyYWwtY2F0ZWdvcnktdmFsdWVzXG52YXIgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyA9IFwiQ2FzZWRfTGV0dGVyIExDIENsb3NlX1B1bmN0dWF0aW9uIFBlIENvbm5lY3Rvcl9QdW5jdHVhdGlvbiBQYyBDb250cm9sIENjIGNudHJsIEN1cnJlbmN5X1N5bWJvbCBTYyBEYXNoX1B1bmN0dWF0aW9uIFBkIERlY2ltYWxfTnVtYmVyIE5kIGRpZ2l0IEVuY2xvc2luZ19NYXJrIE1lIEZpbmFsX1B1bmN0dWF0aW9uIFBmIEZvcm1hdCBDZiBJbml0aWFsX1B1bmN0dWF0aW9uIFBpIExldHRlciBMIExldHRlcl9OdW1iZXIgTmwgTGluZV9TZXBhcmF0b3IgWmwgTG93ZXJjYXNlX0xldHRlciBMbCBNYXJrIE0gQ29tYmluaW5nX01hcmsgTWF0aF9TeW1ib2wgU20gTW9kaWZpZXJfTGV0dGVyIExtIE1vZGlmaWVyX1N5bWJvbCBTayBOb25zcGFjaW5nX01hcmsgTW4gTnVtYmVyIE4gT3Blbl9QdW5jdHVhdGlvbiBQcyBPdGhlciBDIE90aGVyX0xldHRlciBMbyBPdGhlcl9OdW1iZXIgTm8gT3RoZXJfUHVuY3R1YXRpb24gUG8gT3RoZXJfU3ltYm9sIFNvIFBhcmFncmFwaF9TZXBhcmF0b3IgWnAgUHJpdmF0ZV9Vc2UgQ28gUHVuY3R1YXRpb24gUCBwdW5jdCBTZXBhcmF0b3IgWiBTcGFjZV9TZXBhcmF0b3IgWnMgU3BhY2luZ19NYXJrIE1jIFN1cnJvZ2F0ZSBDcyBTeW1ib2wgUyBUaXRsZWNhc2VfTGV0dGVyIEx0IFVuYXNzaWduZWQgQ24gVXBwZXJjYXNlX0xldHRlciBMdVwiO1xuXG4vLyAjdGFibGUtdW5pY29kZS1zY3JpcHQtdmFsdWVzXG52YXIgZWNtYTlTY3JpcHRWYWx1ZXMgPSBcIkFkbGFtIEFkbG0gQWhvbSBBaG9tIEFuYXRvbGlhbl9IaWVyb2dseXBocyBIbHV3IEFyYWJpYyBBcmFiIEFybWVuaWFuIEFybW4gQXZlc3RhbiBBdnN0IEJhbGluZXNlIEJhbGkgQmFtdW0gQmFtdSBCYXNzYV9WYWggQmFzcyBCYXRhayBCYXRrIEJlbmdhbGkgQmVuZyBCaGFpa3N1a2kgQmhrcyBCb3BvbW9mbyBCb3BvIEJyYWhtaSBCcmFoIEJyYWlsbGUgQnJhaSBCdWdpbmVzZSBCdWdpIEJ1aGlkIEJ1aGQgQ2FuYWRpYW5fQWJvcmlnaW5hbCBDYW5zIENhcmlhbiBDYXJpIENhdWNhc2lhbl9BbGJhbmlhbiBBZ2hiIENoYWttYSBDYWttIENoYW0gQ2hhbSBDaGVyb2tlZSBDaGVyIENvbW1vbiBaeXl5IENvcHRpYyBDb3B0IFFhYWMgQ3VuZWlmb3JtIFhzdXggQ3lwcmlvdCBDcHJ0IEN5cmlsbGljIEN5cmwgRGVzZXJldCBEc3J0IERldmFuYWdhcmkgRGV2YSBEdXBsb3lhbiBEdXBsIEVneXB0aWFuX0hpZXJvZ2x5cGhzIEVneXAgRWxiYXNhbiBFbGJhIEV0aGlvcGljIEV0aGkgR2VvcmdpYW4gR2VvciBHbGFnb2xpdGljIEdsYWcgR290aGljIEdvdGggR3JhbnRoYSBHcmFuIEdyZWVrIEdyZWsgR3VqYXJhdGkgR3VqciBHdXJtdWtoaSBHdXJ1IEhhbiBIYW5pIEhhbmd1bCBIYW5nIEhhbnVub28gSGFubyBIYXRyYW4gSGF0ciBIZWJyZXcgSGViciBIaXJhZ2FuYSBIaXJhIEltcGVyaWFsX0FyYW1haWMgQXJtaSBJbmhlcml0ZWQgWmluaCBRYWFpIEluc2NyaXB0aW9uYWxfUGFobGF2aSBQaGxpIEluc2NyaXB0aW9uYWxfUGFydGhpYW4gUHJ0aSBKYXZhbmVzZSBKYXZhIEthaXRoaSBLdGhpIEthbm5hZGEgS25kYSBLYXRha2FuYSBLYW5hIEtheWFoX0xpIEthbGkgS2hhcm9zaHRoaSBLaGFyIEtobWVyIEtobXIgS2hvamtpIEtob2ogS2h1ZGF3YWRpIFNpbmQgTGFvIExhb28gTGF0aW4gTGF0biBMZXBjaGEgTGVwYyBMaW1idSBMaW1iIExpbmVhcl9BIExpbmEgTGluZWFyX0IgTGluYiBMaXN1IExpc3UgTHljaWFuIEx5Y2kgTHlkaWFuIEx5ZGkgTWFoYWphbmkgTWFoaiBNYWxheWFsYW0gTWx5bSBNYW5kYWljIE1hbmQgTWFuaWNoYWVhbiBNYW5pIE1hcmNoZW4gTWFyYyBNYXNhcmFtX0dvbmRpIEdvbm0gTWVldGVpX01heWVrIE10ZWkgTWVuZGVfS2lrYWt1aSBNZW5kIE1lcm9pdGljX0N1cnNpdmUgTWVyYyBNZXJvaXRpY19IaWVyb2dseXBocyBNZXJvIE1pYW8gUGxyZCBNb2RpIE1vZGkgTW9uZ29saWFuIE1vbmcgTXJvIE1yb28gTXVsdGFuaSBNdWx0IE15YW5tYXIgTXltciBOYWJhdGFlYW4gTmJhdCBOZXdfVGFpX0x1ZSBUYWx1IE5ld2EgTmV3YSBOa28gTmtvbyBOdXNodSBOc2h1IE9naGFtIE9nYW0gT2xfQ2hpa2kgT2xjayBPbGRfSHVuZ2FyaWFuIEh1bmcgT2xkX0l0YWxpYyBJdGFsIE9sZF9Ob3J0aF9BcmFiaWFuIE5hcmIgT2xkX1Blcm1pYyBQZXJtIE9sZF9QZXJzaWFuIFhwZW8gT2xkX1NvdXRoX0FyYWJpYW4gU2FyYiBPbGRfVHVya2ljIE9ya2ggT3JpeWEgT3J5YSBPc2FnZSBPc2dlIE9zbWFueWEgT3NtYSBQYWhhd2hfSG1vbmcgSG1uZyBQYWxteXJlbmUgUGFsbSBQYXVfQ2luX0hhdSBQYXVjIFBoYWdzX1BhIFBoYWcgUGhvZW5pY2lhbiBQaG54IFBzYWx0ZXJfUGFobGF2aSBQaGxwIFJlamFuZyBSam5nIFJ1bmljIFJ1bnIgU2FtYXJpdGFuIFNhbXIgU2F1cmFzaHRyYSBTYXVyIFNoYXJhZGEgU2hyZCBTaGF2aWFuIFNoYXcgU2lkZGhhbSBTaWRkIFNpZ25Xcml0aW5nIFNnbncgU2luaGFsYSBTaW5oIFNvcmFfU29tcGVuZyBTb3JhIFNveW9tYm8gU295byBTdW5kYW5lc2UgU3VuZCBTeWxvdGlfTmFncmkgU3lsbyBTeXJpYWMgU3lyYyBUYWdhbG9nIFRnbGcgVGFnYmFud2EgVGFnYiBUYWlfTGUgVGFsZSBUYWlfVGhhbSBMYW5hIFRhaV9WaWV0IFRhdnQgVGFrcmkgVGFrciBUYW1pbCBUYW1sIFRhbmd1dCBUYW5nIFRlbHVndSBUZWx1IFRoYWFuYSBUaGFhIFRoYWkgVGhhaSBUaWJldGFuIFRpYnQgVGlmaW5hZ2ggVGZuZyBUaXJodXRhIFRpcmggVWdhcml0aWMgVWdhciBWYWkgVmFpaSBXYXJhbmdfQ2l0aSBXYXJhIFlpIFlpaWkgWmFuYWJhemFyX1NxdWFyZSBaYW5iXCI7XG52YXIgZWNtYTEwU2NyaXB0VmFsdWVzID0gZWNtYTlTY3JpcHRWYWx1ZXMgKyBcIiBEb2dyYSBEb2dyIEd1bmphbGFfR29uZGkgR29uZyBIYW5pZmlfUm9oaW5neWEgUm9oZyBNYWthc2FyIE1ha2EgTWVkZWZhaWRyaW4gTWVkZiBPbGRfU29nZGlhbiBTb2dvIFNvZ2RpYW4gU29nZFwiO1xudmFyIGVjbWExMVNjcmlwdFZhbHVlcyA9IGVjbWExMFNjcmlwdFZhbHVlcyArIFwiIEVseW1haWMgRWx5bSBOYW5kaW5hZ2FyaSBOYW5kIE55aWFrZW5nX1B1YWNodWVfSG1vbmcgSG1ucCBXYW5jaG8gV2Nob1wiO1xudmFyIHVuaWNvZGVTY3JpcHRWYWx1ZXMgPSB7XG4gIDk6IGVjbWE5U2NyaXB0VmFsdWVzLFxuICAxMDogZWNtYTEwU2NyaXB0VmFsdWVzLFxuICAxMTogZWNtYTExU2NyaXB0VmFsdWVzXG59O1xuXG52YXIgZGF0YSA9IHt9O1xuZnVuY3Rpb24gYnVpbGRVbmljb2RlRGF0YShlY21hVmVyc2lvbikge1xuICB2YXIgZCA9IGRhdGFbZWNtYVZlcnNpb25dID0ge1xuICAgIGJpbmFyeTogd29yZHNSZWdleHAodW5pY29kZUJpbmFyeVByb3BlcnRpZXNbZWNtYVZlcnNpb25dICsgXCIgXCIgKyB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICBub25CaW5hcnk6IHtcbiAgICAgIEdlbmVyYWxfQ2F0ZWdvcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgU2NyaXB0OiB3b3Jkc1JlZ2V4cCh1bmljb2RlU2NyaXB0VmFsdWVzW2VjbWFWZXJzaW9uXSlcbiAgICB9XG4gIH07XG4gIGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuXG4gIGQubm9uQmluYXJ5LmdjID0gZC5ub25CaW5hcnkuR2VuZXJhbF9DYXRlZ29yeTtcbiAgZC5ub25CaW5hcnkuc2MgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG4gIGQubm9uQmluYXJ5LnNjeCA9IGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zO1xufVxuYnVpbGRVbmljb2RlRGF0YSg5KTtcbmJ1aWxkVW5pY29kZURhdGEoMTApO1xuYnVpbGRVbmljb2RlRGF0YSgxMSk7XG5cbnZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxudmFyIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZSA9IGZ1bmN0aW9uIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZShwYXJzZXIpIHtcbiAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIHRoaXMudmFsaWRGbGFncyA9IFwiZ2ltXCIgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IFwidXlcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgPyBcInNcIiA6IFwiXCIpO1xuICB0aGlzLnVuaWNvZGVQcm9wZXJ0aWVzID0gZGF0YVtwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSA/IDExIDogcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb25dO1xuICB0aGlzLnNvdXJjZSA9IFwiXCI7XG4gIHRoaXMuZmxhZ3MgPSBcIlwiO1xuICB0aGlzLnN0YXJ0ID0gMDtcbiAgdGhpcy5zd2l0Y2hVID0gZmFsc2U7XG4gIHRoaXMuc3dpdGNoTiA9IGZhbHNlO1xuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMubGFzdEludFZhbHVlID0gMDtcbiAgdGhpcy5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB0aGlzLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICB0aGlzLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gIHRoaXMubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gIHRoaXMuZ3JvdXBOYW1lcyA9IFtdO1xuICB0aGlzLmJhY2tSZWZlcmVuY2VOYW1lcyA9IFtdO1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0IChzdGFydCwgcGF0dGVybiwgZmxhZ3MpIHtcbiAgdmFyIHVuaWNvZGUgPSBmbGFncy5pbmRleE9mKFwidVwiKSAhPT0gLTE7XG4gIHRoaXMuc3RhcnQgPSBzdGFydCB8IDA7XG4gIHRoaXMuc291cmNlID0gcGF0dGVybiArIFwiXCI7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgdGhpcy5zd2l0Y2hVID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gIHRoaXMuc3dpdGNoTiA9IHVuaWNvZGUgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5O1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uIHJhaXNlIChtZXNzYWdlKSB7XG4gIHRoaXMucGFyc2VyLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgKFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC9cIiArICh0aGlzLnNvdXJjZSkgKyBcIi86IFwiICsgbWVzc2FnZSkpO1xufTtcblxuLy8gSWYgdSBmbGFnIGlzIGdpdmVuLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgcG9pbnQgYXQgdGhlIGluZGV4IChpdCBjb21iaW5lcyBhIHN1cnJvZ2F0ZSBwYWlyKS5cbi8vIE90aGVyd2lzZSwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgdGhlIGluZGV4IChjYW4gYmUgYSBwYXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIpLlxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0IChpKSB7XG4gIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gIHZhciBsID0gcy5sZW5ndGg7XG4gIGlmIChpID49IGwpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgaWYgKCF0aGlzLnN3aXRjaFUgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCkge1xuICAgIHJldHVybiBjXG4gIH1cbiAgdmFyIG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICByZXR1cm4gbmV4dCA+PSAweERDMDAgJiYgbmV4dCA8PSAweERGRkYgPyAoYyA8PCAxMCkgKyBuZXh0IC0gMHgzNUZEQzAwIDogY1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5uZXh0SW5kZXggPSBmdW5jdGlvbiBuZXh0SW5kZXggKGkpIHtcbiAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgaWYgKGkgPj0gbCkge1xuICAgIHJldHVybiBsXG4gIH1cbiAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSksIG5leHQ7XG4gIGlmICghdGhpcy5zd2l0Y2hVIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwgfHxcbiAgICAgIChuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweERDMDAgfHwgbmV4dCA+IDB4REZGRikge1xuICAgIHJldHVybiBpICsgMVxuICB9XG4gIHJldHVybiBpICsgMlxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCAoKSB7XG4gIHJldHVybiB0aGlzLmF0KHRoaXMucG9zKVxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5sb29rYWhlYWQgPSBmdW5jdGlvbiBsb29rYWhlYWQgKCkge1xuICByZXR1cm4gdGhpcy5hdCh0aGlzLm5leHRJbmRleCh0aGlzLnBvcykpXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiBhZHZhbmNlICgpIHtcbiAgdGhpcy5wb3MgPSB0aGlzLm5leHRJbmRleCh0aGlzLnBvcyk7XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIGVhdCAoY2gpIHtcbiAgaWYgKHRoaXMuY3VycmVudCgpID09PSBjaCkge1xuICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG5mdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjaCkge1xuICBpZiAoY2ggPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSB9XG4gIGNoIC09IDB4MTAwMDA7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaCA+PiAxMCkgKyAweEQ4MDAsIChjaCAmIDB4MDNGRikgKyAweERDMDApXG59XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIGZsYWdzIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbnBwJDgudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgdmFyIGZsYWdzID0gc3RhdGUuZmxhZ3M7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgIGlmICh2YWxpZEZsYWdzLmluZGV4T2YoZmxhZykgPT09IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgfVxuICAgIGlmIChmbGFncy5pbmRleE9mKGZsYWcsIGkgKyAxKSA+IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHBhdHRlcm4gcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gKlxuICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xucHAkOC52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcblxuICAvLyBUaGUgZ29hbCBzeW1ib2wgZm9yIHRoZSBwYXJzZSBpcyB8UGF0dGVyblt+VSwgfk5dfC4gSWYgdGhlIHJlc3VsdCBvZlxuICAvLyBwYXJzaW5nIGNvbnRhaW5zIGEgfEdyb3VwTmFtZXwsIHJlcGFyc2Ugd2l0aCB0aGUgZ29hbCBzeW1ib2xcbiAgLy8gfFBhdHRlcm5bflUsICtOXXwgYW5kIHVzZSB0aGlzIHJlc3VsdCBpbnN0ZWFkLiBUaHJvdyBhICpTeW50YXhFcnJvcipcbiAgLy8gZXhjZXB0aW9uIGlmIF9QXyBkaWQgbm90IGNvbmZvcm0gdG8gdGhlIGdyYW1tYXIsIGlmIGFueSBlbGVtZW50cyBvZiBfUF9cbiAgLy8gd2VyZSBub3QgbWF0Y2hlZCBieSB0aGUgcGFyc2UsIG9yIGlmIGFueSBFYXJseSBFcnJvciBjb25kaXRpb25zIGV4aXN0LlxuICBpZiAoIXN0YXRlLnN3aXRjaE4gJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgc3RhdGUuc3dpdGNoTiA9IHRydWU7XG4gICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5cbnBwJDgucmVnZXhwX3BhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5wb3MgPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID0gMDtcbiAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG5cbiAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuXG4gIGlmIChzdGF0ZS5wb3MgIT09IHN0YXRlLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2VzIGFzIFY4LlxuICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJVbm1hdGNoZWQgJyknXCIpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogWyAqLykgfHwgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGUubWF4QmFja1JlZmVyZW5jZSA+IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCBjYXB0dXJlIHJlZmVyZW5jZWRcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EaXNqdW5jdGlvblxucHAkOC5yZWdleHBfZGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgfVxuXG4gIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgfVxuICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQWx0ZXJuYXRpdmVcbnBwJDgucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXRlLnNvdXJjZS5sZW5ndGggJiYgdGhpcy5yZWdleHBfZWF0VGVybShzdGF0ZSkpXG4gICAgeyB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItVGVybVxucHAkOC5yZWdleHBfZWF0VGVybSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oc3RhdGUpKSB7XG4gICAgLy8gSGFuZGxlIGBRdWFudGlmaWFibGVBc3NlcnRpb24gUXVhbnRpZmllcmAgYWx0ZXJuYXRpdmUuXG4gICAgLy8gYHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZWAgaXMgdHJ1ZSBpZiB0aGUgbGFzdCBlYXRlbiBBc3NlcnRpb25cbiAgICAvLyBpcyBhIFF1YW50aWZpYWJsZUFzc2VydGlvbi5cbiAgICBpZiAoc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlICYmIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcXVhbnRpZmllclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdGF0ZS5zd2l0Y2hVID8gdGhpcy5yZWdleHBfZWF0QXRvbShzdGF0ZSkgOiB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20oc3RhdGUpKSB7XG4gICAgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUFzc2VydGlvblxucHAkOC5yZWdleHBfZWF0QXNzZXJ0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcblxuICAvLyBeLCAkXG4gIGlmIChzdGF0ZS5lYXQoMHg1RSAvKiBeICovKSB8fCBzdGF0ZS5lYXQoMHgyNCAvKiAkICovKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBcXGIgXFxCXG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NDIgLyogQiAqLykgfHwgc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgLy8gTG9va2FoZWFkIC8gTG9va2JlaGluZFxuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykgJiYgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICB2YXIgbG9va2JlaGluZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgbG9va2JlaGluZCA9IHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4M0QgLyogPSAqLykgfHwgc3RhdGUuZWF0KDB4MjEgLyogISAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmICghc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSAhbG9va2JlaGluZDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclxucHAkOC5yZWdleHBfZWF0UXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIGlmICggbm9FcnJvciA9PT0gdm9pZCAwICkgbm9FcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4KHN0YXRlLCBub0Vycm9yKSkge1xuICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyUHJlZml4XG5wcCQ4LnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4ID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyQSAvKiAqICovKSB8fFxuICAgIHN0YXRlLmVhdCgweDJCIC8qICsgKi8pIHx8XG4gICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCBub0Vycm9yKVxuICApXG59O1xucHAkOC5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgdmFyIG1pbiA9IDAsIG1heCA9IC0xO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgbWluID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDJDIC8qICwgKi8pICYmIHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgIG1heCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICAvLyBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLXRlcm1cbiAgICAgICAgaWYgKG1heCAhPT0gLTEgJiYgbWF4IDwgbWluICYmICFub0Vycm9yKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmICFub0Vycm9yKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkluY29tcGxldGUgcXVhbnRpZmllclwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BdG9tXG5wcCQ4LnJlZ2V4cF9lYXRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyhzdGF0ZSkgfHxcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKVxuICApXG59O1xucHAkOC5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEF0b21Fc2NhcGUoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgJiYgc3RhdGUuZWF0KDB4M0EgLyogOiAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDgucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICB0aGlzLnJlZ2V4cF9ncm91cFNwZWNpZmllcihzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgLyogPyAqLykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgIH1cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgKz0gMTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkQXRvbVxucHAkOC5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUludmFsaWRCcmFjZWRRdWFudGlmaWVyXG5wcCQ4LnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1TeW50YXhDaGFyYWN0ZXJcbnBwJDgucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzU3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4MjQgLyogJCAqLyB8fFxuICAgIGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8gfHxcbiAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgY2ggPT09IDB4M0YgLyogPyAqLyB8fFxuICAgIGNoID49IDB4NUIgLyogWyAqLyAmJiBjaCA8PSAweDVFIC8qIF4gKi8gfHxcbiAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVybkNoYXJhY3RlclxuLy8gQnV0IGVhdCBlYWdlci5cbnBwJDgucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgIWlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkUGF0dGVybkNoYXJhY3RlclxucHAkOC5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoXG4gICAgY2ggIT09IC0xICYmXG4gICAgY2ggIT09IDB4MjQgLyogJCAqLyAmJlxuICAgICEoY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLykgJiZcbiAgICBjaCAhPT0gMHgyRSAvKiAuICovICYmXG4gICAgY2ggIT09IDB4M0YgLyogPyAqLyAmJlxuICAgIGNoICE9PSAweDVCIC8qIFsgKi8gJiZcbiAgICBjaCAhPT0gMHg1RSAvKiBeICovICYmXG4gICAgY2ggIT09IDB4N0MgLyogfCAqL1xuICApIHtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIEdyb3VwU3BlY2lmaWVyW1VdIDo6XG4vLyAgIFtlbXB0eV1cbi8vICAgYD9gIEdyb3VwTmFtZVs/VV1cbnBwJDgucmVnZXhwX2dyb3VwU3BlY2lmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2Yoc3RhdGUubGFzdFN0cmluZ1ZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUuZ3JvdXBOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICB9XG59O1xuXG4vLyBHcm91cE5hbWVbVV0gOjpcbi8vICAgYDxgIFJlZ0V4cElkZW50aWZpZXJOYW1lWz9VXSBgPmBcbi8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxucHAkOC5yZWdleHBfZWF0R3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgaWYgKHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRSAvKiA+ICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJOYW1lW1VdIDo6XG4vLyAgIFJlZ0V4cElkZW50aWZpZXJTdGFydFs/VV1cbi8vICAgUmVnRXhwSWRlbnRpZmllck5hbWVbP1VdIFJlZ0V4cElkZW50aWZpZXJQYXJ0Wz9VXVxuLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG5wcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQoc3RhdGUpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0KHN0YXRlKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZWdFeHBJZGVudGlmaWVyU3RhcnRbVV0gOjpcbi8vICAgVW5pY29kZUlEU3RhcnRcbi8vICAgYCRgXG4vLyAgIGBfYFxuLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVs/VV1cbnBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBzdGF0ZS5hZHZhbmNlKCk7XG5cbiAgaWYgKGNoID09PSAweDVDIC8qIFxcICovICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHtcbiAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgfVxuICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkge1xuICByZXR1cm4gaXNJZGVudGlmaWVyU3RhcnQoY2gsIHRydWUpIHx8IGNoID09PSAweDI0IC8qICQgKi8gfHwgY2ggPT09IDB4NUYgLyogXyAqL1xufVxuXG4vLyBSZWdFeHBJZGVudGlmaWVyUGFydFtVXSA6OlxuLy8gICBVbmljb2RlSURDb250aW51ZVxuLy8gICBgJGBcbi8vICAgYF9gXG4vLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWz9VXVxuLy8gICA8WldOSj5cbi8vICAgPFpXSj5cbnBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIHN0YXRlLmFkdmFuY2UoKTtcblxuICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSkge1xuICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICB9XG4gIGlmIChpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkge1xuICByZXR1cm4gaXNJZGVudGlmaWVyQ2hhcihjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovIHx8IGNoID09PSAweDIwMEMgLyogPFpXTko+ICovIHx8IGNoID09PSAweDIwMEQgLyogPFpXSj4gKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUF0b21Fc2NhcGVcbnBwJDgucmVnZXhwX2VhdEF0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoXG4gICAgdGhpcy5yZWdleHBfZWF0QmFja1JlZmVyZW5jZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpIHx8XG4gICAgKHN0YXRlLnN3aXRjaE4gJiYgdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShzdGF0ZSkpXG4gICkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg2MyAvKiBjICovKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOC5yZWdleHBfZWF0QmFja1JlZmVyZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUoc3RhdGUpKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIEZvciBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLWF0b21lc2NhcGVcbiAgICAgIGlmIChuID4gc3RhdGUubWF4QmFja1JlZmVyZW5jZSkge1xuICAgICAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChuIDw9IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOC5yZWdleHBfZWF0S0dyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHg2QiAvKiBrICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIHJlZmVyZW5jZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DaGFyYWN0ZXJFc2NhcGVcbnBwJDgucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0Q29udHJvbEVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlcihzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRaZXJvKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAoIXN0YXRlLnN3aXRjaFUgJiYgdGhpcy5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUoc3RhdGUpXG4gIClcbn07XG5wcCQ4LnJlZ2V4cF9lYXRDQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF9lYXRaZXJvID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzMCAvKiAwICovICYmICFpc0RlY2ltYWxEaWdpdChzdGF0ZS5sb29rYWhlYWQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbEVzY2FwZVxucHAkOC5yZWdleHBfZWF0Q29udHJvbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoID09PSAweDc0IC8qIHQgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA5OyAvKiBcXHQgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NkUgLyogbiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEE7IC8qIFxcbiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg3NiAvKiB2ICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQjsgLyogXFx2ICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDY2IC8qIGYgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBDOyAvKiBcXGYgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NzIgLyogciAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEQ7IC8qIFxcciAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbExldHRlclxucHAkOC5yZWdleHBfZWF0Q29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzQ29udHJvbExldHRlcihjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNDb250cm9sTGV0dGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDVBIC8qIFogKi8pIHx8XG4gICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDdBIC8qIHogKi8pXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlXG5wcCQ4LnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgdmFyIGxlYWQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiBsZWFkID49IDB4RDgwMCAmJiBsZWFkIDw9IDB4REJGRikge1xuICAgICAgICB2YXIgbGVhZFN1cnJvZ2F0ZUVuZCA9IHN0YXRlLnBvcztcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSAmJiBzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgICB2YXIgdHJhaWwgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgICAgaWYgKHRyYWlsID49IDB4REMwMCAmJiB0cmFpbCA8PSAweERGRkYpIHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgPSBsZWFkU3Vycm9nYXRlRW5kO1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBsZWFkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKFxuICAgICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgIHRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhzdGF0ZSkgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pICYmXG4gICAgICBpc1ZhbGlkVW5pY29kZShzdGF0ZS5sYXN0SW50VmFsdWUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzVmFsaWRVbmljb2RlKGNoKSB7XG4gIHJldHVybiBjaCA+PSAwICYmIGNoIDw9IDB4MTBGRkZGXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JZGVudGl0eUVzY2FwZVxucHAkOC5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4MkYgLyogLyAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkY7IC8qIC8gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggIT09IDB4NjMgLyogYyAqLyAmJiAoIXN0YXRlLnN3aXRjaE4gfHwgY2ggIT09IDB4NkIgLyogayAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbEVzY2FwZVxucHAkOC5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoID49IDB4MzEgLyogMSAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICBkbyB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfSB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc0VzY2FwZVxucHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG5cbiAgaWYgKGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoXG4gICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmXG4gICAgKGNoID09PSAweDUwIC8qIFAgKi8gfHwgY2ggPT09IDB4NzAgLyogcCAqLylcbiAgKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIGlmIChcbiAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24oc3RhdGUpICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4NjQgLyogZCAqLyB8fFxuICAgIGNoID09PSAweDQ0IC8qIEQgKi8gfHxcbiAgICBjaCA9PT0gMHg3MyAvKiBzICovIHx8XG4gICAgY2ggPT09IDB4NTMgLyogUyAqLyB8fFxuICAgIGNoID09PSAweDc3IC8qIHcgKi8gfHxcbiAgICBjaCA9PT0gMHg1NyAvKiBXICovXG4gIClcbn1cblxuLy8gVW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eU5hbWUgYD1gIFVuaWNvZGVQcm9wZXJ0eVZhbHVlXG4vLyAgIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxucHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIC8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgYD1gIFVuaWNvZGVQcm9wZXJ0eVZhbHVlXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSkge1xuICAgIHZhciBuYW1lID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlKHN0YXRlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICBzdGF0ZS5wb3MgPSBzdGFydDtcblxuICAvLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbiAgaWYgKHRoaXMucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSkpIHtcbiAgICB2YXIgbmFtZU9yVmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSwgbmFtZU9yVmFsdWUpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOC5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFoYXMoc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5LCBuYW1lKSlcbiAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG4gIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5W25hbWVdLnRlc3QodmFsdWUpKVxuICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IHZhbHVlXCIpOyB9XG59O1xucHAkOC5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lT3JWYWx1ZSkge1xuICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLmJpbmFyeS50ZXN0KG5hbWVPclZhbHVlKSlcbiAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG59O1xuXG4vLyBVbmljb2RlUHJvcGVydHlOYW1lIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXJzXG5wcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG59O1xuZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbn1cblxuLy8gVW5pY29kZVByb3BlcnR5VmFsdWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG5wcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbn07XG5mdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKVxufVxuXG4vLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG5wcCQ4LnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc1xucHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4NUIgLyogWyAqLykpIHtcbiAgICBzdGF0ZS5lYXQoMHg1RSAvKiBeICovKTtcbiAgICB0aGlzLnJlZ2V4cF9jbGFzc1JhbmdlcyhzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVEIC8qIFsgKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBVbnJlYWNoYWJsZSBzaW5jZSBpdCB0aHJldyBcInVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIiBlcnJvciBiZWZvcmUuXG4gICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NSYW5nZXNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2hcbnBwJDgucmVnZXhwX2NsYXNzUmFuZ2VzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MkQgLyogLSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgKGxlZnQgPT09IC0xIHx8IHJpZ2h0ID09PSAtMSkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICE9PSAtMSAmJiByaWdodCAhPT0gLTEgJiYgbGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbVxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tTm9EYXNoXG5wcCQ4LnJlZ2V4cF9lYXRDbGFzc0F0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICB2YXIgY2gkMSA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgIGlmIChjaCQxID09PSAweDYzIC8qIGMgKi8gfHwgaXNPY3RhbERpZ2l0KGNoJDEpKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjbGFzcyBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoICE9PSAweDVEIC8qIFsgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzRXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXRDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyAvKiA8QlM+ICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRDsgLyogLSAqL1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoIXN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzQ29udHJvbExldHRlclxucHAkOC5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxucHAkOC5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg3OCAvKiB4ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgMikpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxEaWdpdHNcbnBwJDgucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHdoaWxlIChpc0RlY2ltYWxEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RGlnaXRzXG5wcCQ4LnJlZ2V4cF9lYXRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHdoaWxlIChpc0hleERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcbmZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgcmV0dXJuIChcbiAgICAoY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykgfHxcbiAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykgfHxcbiAgICAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLylcbiAgKVxufVxuZnVuY3Rpb24gaGV4VG9JbnQoY2gpIHtcbiAgaWYgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDQ2IC8qIEYgKi8pIHtcbiAgICByZXR1cm4gMTAgKyAoY2ggLSAweDQxIC8qIEEgKi8pXG4gIH1cbiAgaWYgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pIHtcbiAgICByZXR1cm4gMTAgKyAoY2ggLSAweDYxIC8qIGEgKi8pXG4gIH1cbiAgcmV0dXJuIGNoIC0gMHgzMCAvKiAwICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1MZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlXG4vLyBBbGxvd3Mgb25seSAwLTM3NyhvY3RhbCkgaS5lLiAwLTI1NShkZWNpbWFsKS5cbnBwJDgucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICB2YXIgbjEgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICB2YXIgbjIgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAobjEgPD0gMyAmJiB0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDY0ICsgbjIgKiA4ICsgc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA4ICsgbjI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtT2N0YWxEaWdpdFxucHAkOC5yZWdleHBfZWF0T2N0YWxEaWdpdCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAtIDB4MzA7IC8qIDAgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM3IC8qIDcgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4NERpZ2l0c1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RGlnaXRcbi8vIEFuZCBIZXhEaWdpdCBIZXhEaWdpdCBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxucHAkOC5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSwgbGVuZ3RoKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIE9iamVjdCB0eXBlIHVzZWQgdG8gcmVwcmVzZW50IHRva2Vucy4gTm90ZSB0aGF0IG5vcm1hbGx5LCB0b2tlbnNcbi8vIHNpbXBseSBleGlzdCBhcyBwcm9wZXJ0aWVzIG9uIHRoZSBwYXJzZXIgb2JqZWN0LiBUaGlzIGlzIG9ubHlcbi8vIHVzZWQgZm9yIHRoZSBvblRva2VuIGNhbGxiYWNrIGFuZCB0aGUgZXh0ZXJuYWwgdG9rZW5pemVyLlxuXG52YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihwKSB7XG4gIHRoaXMudHlwZSA9IHAudHlwZTtcbiAgdGhpcy52YWx1ZSA9IHAudmFsdWU7XG4gIHRoaXMuc3RhcnQgPSBwLnN0YXJ0O1xuICB0aGlzLmVuZCA9IHAuZW5kO1xuICBpZiAocC5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHAsIHAuc3RhcnRMb2MsIHAuZW5kTG9jKTsgfVxuICBpZiAocC5vcHRpb25zLnJhbmdlcylcbiAgICB7IHRoaXMucmFuZ2UgPSBbcC5zdGFydCwgcC5lbmRdOyB9XG59O1xuXG4vLyAjIyBUb2tlbml6ZXJcblxudmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBNb3ZlIHRvIHRoZSBuZXh0IHRva2VuXG5cbnBwJDkubmV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgeyB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpOyB9XG5cbiAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5lbmRMb2M7XG4gIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbn07XG5cbnBwJDkuZ2V0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiBuZXcgVG9rZW4odGhpcylcbn07XG5cbi8vIElmIHdlJ3JlIGluIGFuIEVTNiBlbnZpcm9ubWVudCwgbWFrZSBwYXJzZXJzIGl0ZXJhYmxlXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgeyBwcCQ5W1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMkMS5nZXRUb2tlbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzLmVvZixcbiAgICAgICAgICB2YWx1ZTogdG9rZW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTsgfVxuXG4vLyBUb2dnbGUgc3RyaWN0IG1vZGUuIFJlLXJlYWRzIHRoZSBuZXh0IG51bWJlciBvciBzdHJpbmcgdG8gcGxlYXNlXG4vLyBwZWRhbnRpYyB0ZXN0cyAoYFwidXNlIHN0cmljdFwiOyAwMTA7YCBzaG91bGQgZmFpbCkuXG5cbnBwJDkuY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb250ZXh0W3RoaXMuY29udGV4dC5sZW5ndGggLSAxXVxufTtcblxuLy8gUmVhZCBhIHNpbmdsZSB0b2tlbiwgdXBkYXRpbmcgdGhlIHBhcnNlciBvYmplY3QncyB0b2tlbi1yZWxhdGVkXG4vLyBwcm9wZXJ0aWVzLlxuXG5wcCQ5Lm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICBpZiAoIWN1ckNvbnRleHQgfHwgIWN1ckNvbnRleHQucHJlc2VydmVTcGFjZSkgeyB0aGlzLnNraXBTcGFjZSgpOyB9XG5cbiAgdGhpcy5zdGFydCA9IHRoaXMucG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLnN0YXJ0TG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lb2YpIH1cblxuICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gIGVsc2UgeyB0aGlzLnJlYWRUb2tlbih0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpOyB9XG59O1xuXG5wcCQ5LnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgLy8gSWRlbnRpZmllciBvciBrZXl3b3JkLiAnXFx1WFhYWCcgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIGluXG4gIC8vIGlkZW50aWZpZXJzLCBzbyAnXFwnIGFsc28gZGlzcGF0Y2hlcyB0byB0aGF0LlxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pXG4gICAgeyByZXR1cm4gdGhpcy5yZWFkV29yZCgpIH1cblxuICByZXR1cm4gdGhpcy5nZXRUb2tlbkZyb21Db2RlKGNvZGUpXG59O1xuXG5wcCQ5LmZ1bGxDaGFyQ29kZUF0UG9zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgaWYgKGNvZGUgPD0gMHhkN2ZmIHx8IGNvZGUgPj0gMHhlMDAwKSB7IHJldHVybiBjb2RlIH1cbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgcmV0dXJuIChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDBcbn07XG5cbnBwJDkuc2tpcEJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICBpZiAoZW5kID09PSAtMSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTsgfVxuICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBzdGFydDtcbiAgICB2YXIgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyh0aGlzLmlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCB0aGlzLnBvcykge1xuICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICB0aGlzLmxpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG59O1xuXG5wcCQ5LnNraXBMaW5lQ29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0U2tpcCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArPSBzdGFydFNraXApO1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuLy8gd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGFuZC5cblxucHAkOS5za2lwU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgbG9vcDogd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDMyOiBjYXNlIDE2MDogLy8gJyAnXG4gICAgICArK3RoaXMucG9zO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDEzOlxuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfVxuICAgIGNhc2UgMTA6IGNhc2UgODIzMjogY2FzZSA4MjMzOlxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDQ3OiAvLyAnLydcbiAgICAgIHN3aXRjaCAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkpIHtcbiAgICAgIGNhc2UgNDI6IC8vICcqJ1xuICAgICAgICB0aGlzLnNraXBCbG9ja0NvbW1lbnQoKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDc6XG4gICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhayBsb29wXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBDYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSB0b2tlbi4gU2V0cyBgZW5kYCwgYHZhbGAsIGFuZFxuLy8gbWFpbnRhaW5zIGBjb250ZXh0YCBhbmQgYGV4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlclxuLy8gdGhlIHRva2VuLCBzbyB0aGF0IHRoZSBuZXh0IG9uZSdzIGBzdGFydGAgd2lsbCBwb2ludCBhdCB0aGVcbi8vIHJpZ2h0IHBvc2l0aW9uLlxuXG5wcCQ5LmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSB7XG4gIHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gIHZhciBwcmV2VHlwZSA9IHRoaXMudHlwZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICB0aGlzLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xufTtcblxuLy8gIyMjIFRva2VuIHJlYWRpbmdcblxuLy8gVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdG8gZmV0Y2ggdGhlIG5leHQgdG9rZW4uIEl0XG4vLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbi8vIHRoYW4gY2hhcmFjdGVycywgYW5kIGJlY2F1c2Ugb3BlcmF0b3IgcGFyc2luZyBoYXMgYmVlbiBpbmxpbmVkXG4vLyBpbnRvIGl0LlxuLy9cbi8vIEFsbCBpbiB0aGUgbmFtZSBvZiBzcGVlZC5cbi8vXG5wcCQ5LnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgdGhpcy5wb3MgKz0gMztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lbGxpcHNpcylcbiAgfSBlbHNlIHtcbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmRvdClcbiAgfVxufTtcblxucHAkOS5yZWFkVG9rZW5fc2xhc2ggPSBmdW5jdGlvbigpIHsgLy8gJy8nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmICh0aGlzLmV4cHJBbGxvd2VkKSB7ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLnJlYWRSZWdleHAoKSB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuc2xhc2gsIDEpXG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICclKidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgdmFyIHNpemUgPSAxO1xuICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0eXBlcy5zdGFyIDogdHlwZXMubW9kdWxvO1xuXG4gIC8vIGV4cG9uZW50aWF0aW9uIG9wZXJhdG9yICoqIGFuZCAqKj1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQyKSB7XG4gICAgKytzaXplO1xuICAgIHRva2VudHlwZSA9IHR5cGVzLnN0YXJzdGFyO1xuICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbn07XG5cbnBwJDkucmVhZFRva2VuX3BpcGVfYW1wID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnfCYnXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmxvZ2ljYWxPUiA6IHR5cGVzLmxvZ2ljYWxBTkQsIDIpIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5iaXR3aXNlT1IgOiB0eXBlcy5iaXR3aXNlQU5ELCAxKVxufTtcblxucHAkOS5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbigpIHsgLy8gJ14nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYml0d2lzZVhPUiwgMSlcbn07XG5cbnBwJDkucmVhZFRva2VuX3BsdXNfbWluID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnKy0nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgaWYgKG5leHQgPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiAmJlxuICAgICAgICAodGhpcy5sYXN0VG9rRW5kID09PSAwIHx8IGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnBvcykpKSkge1xuICAgICAgLy8gQSBgLS0+YCBsaW5lIGNvbW1lbnRcbiAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDMpO1xuICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmluY0RlYywgMilcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnBsdXNNaW4sIDEpXG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJzw+J1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdFNoaWZ0LCBzaXplKVxuICB9XG4gIGlmIChuZXh0ID09PSAzMyAmJiBjb2RlID09PSA2MCAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNDUgJiZcbiAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09PSA0NSkge1xuICAgIC8vIGA8IS0tYCwgYW4gWE1MLXN0eWxlIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBsaW5lIGNvbW1lbnRcbiAgICB0aGlzLnNraXBMaW5lQ29tbWVudCg0KTtcbiAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHNpemUgPSAyOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnJlbGF0aW9uYWwsIHNpemUpXG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9lcV9leGNsID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPSEnXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IC8vICc9PidcbiAgICB0aGlzLnBvcyArPSAyO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmFycm93KVxuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gdHlwZXMuZXEgOiB0eXBlcy5wcmVmaXgsIDEpXG59O1xuXG5wcCQ5LmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gIHN3aXRjaCAoY29kZSkge1xuICAvLyBUaGUgaW50ZXJwcmV0YXRpb24gb2YgYSBkb3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGlzIGZvbGxvd2VkXG4gIC8vIGJ5IGEgZGlnaXQgb3IgYW5vdGhlciB0d28gZG90cy5cbiAgY2FzZSA0NjogLy8gJy4nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW5zLlxuICBjYXNlIDQwOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlbkwpXG4gIGNhc2UgNDE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuUilcbiAgY2FzZSA1OTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc2VtaSlcbiAgY2FzZSA0NDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29tbWEpXG4gIGNhc2UgOTE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRMKVxuICBjYXNlIDkzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0UilcbiAgY2FzZSAxMjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlTClcbiAgY2FzZSAxMjU6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlUilcbiAgY2FzZSA1ODogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29sb24pXG4gIGNhc2UgNjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnF1ZXN0aW9uKVxuXG4gIGNhc2UgOTY6IC8vICdgJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSlcblxuICBjYXNlIDQ4OiAvLyAnMCdcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KSB9IC8vICcweCcsICcwWCcgLSBoZXggbnVtYmVyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KSB9IC8vICcwbycsICcwTycgLSBvY3RhbCBudW1iZXJcbiAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMikgfSAvLyAnMGInLCAnMEInIC0gYmluYXJ5IG51bWJlclxuICAgIH1cblxuICAvLyBBbnl0aGluZyBlbHNlIGJlZ2lubmluZyB3aXRoIGEgZGlnaXQgaXMgYW4gaW50ZWdlciwgb2N0YWxcbiAgLy8gbnVtYmVyLCBvciBmbG9hdC5cbiAgY2FzZSA0OTogY2FzZSA1MDogY2FzZSA1MTogY2FzZSA1MjogY2FzZSA1MzogY2FzZSA1NDogY2FzZSA1NTogY2FzZSA1NjogY2FzZSA1NzogLy8gMS05XG4gICAgcmV0dXJuIHRoaXMucmVhZE51bWJlcihmYWxzZSlcblxuICAvLyBRdW90ZXMgcHJvZHVjZSBzdHJpbmdzLlxuICBjYXNlIDM0OiBjYXNlIDM5OiAvLyAnXCInLCBcIidcIlxuICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSlcblxuICAvLyBPcGVyYXRvcnMgYXJlIHBhcnNlZCBpbmxpbmUgaW4gdGlueSBzdGF0ZSBtYWNoaW5lcy4gJz0nICg2MSkgaXNcbiAgLy8gb2Z0ZW4gcmVmZXJyZWQgdG8uIGBmaW5pc2hPcGAgc2ltcGx5IHNraXBzIHRoZSBhbW91bnQgb2ZcbiAgLy8gY2hhcmFjdGVycyBpdCBpcyBnaXZlbiBhcyBzZWNvbmQgYXJndW1lbnQsIGFuZCByZXR1cm5zIGEgdG9rZW5cbiAgLy8gb2YgdGhlIHR5cGUgZ2l2ZW4gYnkgaXRzIGZpcnN0IGFyZ3VtZW50LlxuXG4gIGNhc2UgNDc6IC8vICcvJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpXG5cbiAgY2FzZSAzNzogY2FzZSA0MjogLy8gJyUqJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSlcblxuICBjYXNlIDEyNDogY2FzZSAzODogLy8gJ3wmJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKVxuXG4gIGNhc2UgOTQ6IC8vICdeJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpXG5cbiAgY2FzZSA0MzogY2FzZSA0NTogLy8gJystJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gIGNhc2UgNjA6IGNhc2UgNjI6IC8vICc8PidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICBjYXNlIDYxOiBjYXNlIDMzOiAvLyAnPSEnXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSlcblxuICBjYXNlIDEyNjogLy8gJ34nXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucHJlZml4LCAxKVxuICB9XG5cbiAgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjb2RlUG9pbnRUb1N0cmluZyQxKGNvZGUpICsgXCInXCIpO1xufTtcblxucHAkOS5maW5pc2hPcCA9IGZ1bmN0aW9uKHR5cGUsIHNpemUpIHtcbiAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgc2l6ZSk7XG4gIHRoaXMucG9zICs9IHNpemU7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHN0cilcbn07XG5cbnBwJDkucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0aGlzLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KGNoKSkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgIGlmIChjaCA9PT0gXCJbXCIpIHsgaW5DbGFzcyA9IHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbkNsYXNzKSB7IGluQ2xhc3MgPSBmYWxzZTsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSB7IGJyZWFrIH1cbiAgICAgIGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCI7XG4gICAgfSBlbHNlIHsgZXNjYXBlZCA9IGZhbHNlOyB9XG4gICAgKyt0aGlzLnBvcztcbiAgfVxuICB2YXIgcGF0dGVybiA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgKyt0aGlzLnBvcztcbiAgdmFyIGZsYWdzU3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIGZsYWdzID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy51bmV4cGVjdGVkKGZsYWdzU3RhcnQpOyB9XG5cbiAgLy8gVmFsaWRhdGUgcGF0dGVyblxuICB2YXIgc3RhdGUgPSB0aGlzLnJlZ2V4cFN0YXRlIHx8ICh0aGlzLnJlZ2V4cFN0YXRlID0gbmV3IFJlZ0V4cFZhbGlkYXRpb25TdGF0ZSh0aGlzKSk7XG4gIHN0YXRlLnJlc2V0KHN0YXJ0LCBwYXR0ZXJuLCBmbGFncyk7XG4gIHRoaXMudmFsaWRhdGVSZWdFeHBGbGFncyhzdGF0ZSk7XG4gIHRoaXMudmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHN0YXRlKTtcblxuICAvLyBDcmVhdGUgTGl0ZXJhbCN2YWx1ZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgdmFyIHZhbHVlID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRVNUcmVlIHJlcXVpcmVzIG51bGwgaWYgaXQgZmFpbGVkIHRvIGluc3RhbnRpYXRlIFJlZ0V4cCBvYmplY3QuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWUvYmxvYi9hMjcwMDNhZGY0ZmQ3YmZhZDQ0ZGU5Y2VmMzcyYTJlYWNkNTI3YjFjL2VzNS5tZCNyZWdleHBsaXRlcmFsXG4gIH1cblxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5yZWdleHAsIHtwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZX0pXG59O1xuXG4vLyBSZWFkIGFuIGludGVnZXIgaW4gdGhlIGdpdmVuIHJhZGl4LiBSZXR1cm4gbnVsbCBpZiB6ZXJvIGRpZ2l0c1xuLy8gd2VyZSByZWFkLCB0aGUgaW50ZWdlciB2YWx1ZSBvdGhlcndpc2UuIFdoZW4gYGxlbmAgaXMgZ2l2ZW4sIHRoaXNcbi8vIHdpbGwgcmV0dXJuIGBudWxsYCB1bmxlc3MgdGhlIGludGVnZXIgaGFzIGV4YWN0bHkgYGxlbmAgZGlnaXRzLlxuXG5wcCQ5LnJlYWRJbnQgPSBmdW5jdGlvbihyYWRpeCwgbGVuKSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zLCB0b3RhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgdmFsID0gKHZvaWQgMCk7XG4gICAgaWYgKGNvZGUgPj0gOTcpIHsgdmFsID0gY29kZSAtIDk3ICsgMTA7IH0gLy8gYVxuICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHsgdmFsID0gY29kZSAtIDY1ICsgMTA7IH0gLy8gQVxuICAgIGVsc2UgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgeyB2YWwgPSBjb2RlIC0gNDg7IH0gLy8gMC05XG4gICAgZWxzZSB7IHZhbCA9IEluZmluaXR5OyB9XG4gICAgaWYgKHZhbCA+PSByYWRpeCkgeyBicmVhayB9XG4gICAgKyt0aGlzLnBvcztcbiAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gIH1cbiAgaWYgKHRoaXMucG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0aGlzLnBvcyAtIHN0YXJ0ICE9PSBsZW4pIHsgcmV0dXJuIG51bGwgfVxuXG4gIHJldHVybiB0b3RhbFxufTtcblxucHAkOS5yZWFkUmFkaXhOdW1iZXIgPSBmdW5jdGlvbihyYWRpeCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgdGhpcy5wb3MgKz0gMjsgLy8gMHhcbiAgdmFyIHZhbCA9IHRoaXMucmVhZEludChyYWRpeCk7XG4gIGlmICh2YWwgPT0gbnVsbCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQgKyAyLCBcIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCBcIiArIHJhZGl4KTsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDExMCkge1xuICAgIHZhbCA9IHR5cGVvZiBCaWdJbnQgIT09IFwidW5kZWZpbmVkXCIgPyBCaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKSA6IG51bGw7XG4gICAgKyt0aGlzLnBvcztcbiAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpXG59O1xuXG4vLyBSZWFkIGFuIGludGVnZXIsIG9jdGFsIGludGVnZXIsIG9yIGZsb2F0aW5nLXBvaW50IG51bWJlci5cblxucHAkOS5yZWFkTnVtYmVyID0gZnVuY3Rpb24oc3RhcnRzV2l0aERvdCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB2YXIgb2N0YWwgPSB0aGlzLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gIGlmIChvY3RhbCAmJiB0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAoIW9jdGFsICYmICFzdGFydHNXaXRoRG90ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSAmJiBuZXh0ID09PSAxMTApIHtcbiAgICB2YXIgc3RyJDEgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgdmFyIHZhbCQxID0gdHlwZW9mIEJpZ0ludCAhPT0gXCJ1bmRlZmluZWRcIiA/IEJpZ0ludChzdHIkMSkgOiBudWxsO1xuICAgICsrdGhpcy5wb3M7XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsJDEpXG4gIH1cbiAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyAvLyAnLidcbiAgICArK3RoaXMucG9zO1xuICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSAvLyAnKy0nXG4gICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICB2YXIgdmFsID0gb2N0YWwgPyBwYXJzZUludChzdHIsIDgpIDogcGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbn07XG5cbi8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxucHAkOS5yZWFkQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIGNvZGU7XG5cbiAgaWYgKGNoID09PSAxMjMpIHsgLy8gJ3snXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICB2YXIgY29kZVBvcyA9ICsrdGhpcy5wb3M7XG4gICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIodGhpcy5pbnB1dC5pbmRleE9mKFwifVwiLCB0aGlzLnBvcykgLSB0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpOyB9XG4gIH0gZWxzZSB7XG4gICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIoNCk7XG4gIH1cbiAgcmV0dXJuIGNvZGVcbn07XG5cbmZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nJDEoY29kZSkge1xuICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgY29kZSAtPSAweDEwMDAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG59XG5cbnBwJDkucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGNoID09PSBxdW90ZSkgeyBicmVhayB9XG4gICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIoZmFsc2UpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOZXdMaW5lKGNoLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTApKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICArK3RoaXMucG9zO1xuICAgIH1cbiAgfVxuICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcysrKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc3RyaW5nLCBvdXQpXG59O1xuXG4vLyBSZWFkcyB0ZW1wbGF0ZSBzdHJpbmcgdG9rZW5zLlxuXG52YXIgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IgPSB7fTtcblxucHAkOS50cnlSZWFkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICB0aGlzLnJlYWRUbXBsVG9rZW4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciA9PT0gSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IpIHtcbiAgICAgIHRoaXMucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSBmYWxzZTtcbn07XG5cbnBwJDkuaW52YWxpZFN0cmluZ1Rva2VuID0gZnVuY3Rpb24ocG9zaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICB0aHJvdyBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUlxuICB9IGVsc2Uge1xuICAgIHRoaXMucmFpc2UocG9zaXRpb24sIG1lc3NhZ2UpO1xuICB9XG59O1xuXG5wcCQ5LnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTIzKSB7IC8vICdgJywgJyR7J1xuICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLnN0YXJ0ICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLnRlbXBsYXRlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSkge1xuICAgICAgICBpZiAoY2ggPT09IDM2KSB7XG4gICAgICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb2xsYXJCcmFjZUwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnRlbXBsYXRlLCBvdXQpXG4gICAgfVxuICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKHRydWUpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9XG4gICAgICBjYXNlIDEwOlxuICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfVxuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMucG9zO1xuICAgIH1cbiAgfVxufTtcblxuLy8gUmVhZHMgYSB0ZW1wbGF0ZSB0b2tlbiB0byBzZWFyY2ggZm9yIHRoZSBlbmQsIHdpdGhvdXQgdmFsaWRhdGluZyBhbnkgZXNjYXBlIHNlcXVlbmNlc1xucHAkOS5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgZm9yICg7IHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHRoaXMucG9zKyspIHtcbiAgICBzd2l0Y2ggKHRoaXMuaW5wdXRbdGhpcy5wb3NdKSB7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIiRcIjpcbiAgICAgIGlmICh0aGlzLmlucHV0W3RoaXMucG9zICsgMV0gIT09IFwie1wiKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgY2FzZSBcImBcIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmludmFsaWRUZW1wbGF0ZSwgdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcykpXG5cbiAgICAvLyBubyBkZWZhdWx0XG4gICAgfVxuICB9XG4gIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7XG59O1xuXG4vLyBVc2VkIHRvIHJlYWQgZXNjYXBlZCBjaGFyYWN0ZXJzXG5cbnBwJDkucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24oaW5UZW1wbGF0ZSkge1xuICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICsrdGhpcy5wb3M7XG4gIHN3aXRjaCAoY2gpIHtcbiAgY2FzZSAxMTA6IHJldHVybiBcIlxcblwiIC8vICduJyAtPiAnXFxuJ1xuICBjYXNlIDExNDogcmV0dXJuIFwiXFxyXCIgLy8gJ3InIC0+ICdcXHInXG4gIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSAvLyAneCdcbiAgY2FzZSAxMTc6IHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyQxKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgY2FzZSAxMTY6IHJldHVybiBcIlxcdFwiIC8vICd0JyAtPiAnXFx0J1xuICBjYXNlIDk4OiByZXR1cm4gXCJcXGJcIiAvLyAnYicgLT4gJ1xcYidcbiAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gIGNhc2UgMTAyOiByZXR1cm4gXCJcXGZcIiAvLyAnZicgLT4gJ1xcZidcbiAgY2FzZSAxMzogaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH0gLy8gJ1xcclxcbidcbiAgY2FzZSAxMDogLy8gJyBcXG4nXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmU7IH1cbiAgICByZXR1cm4gXCJcIlxuICBkZWZhdWx0OlxuICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgdmFyIG9jdGFsU3RyID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MgLSAxLCAzKS5tYXRjaCgvXlswLTddKy8pWzBdO1xuICAgICAgdmFyIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBjaCA9PT0gNTYgfHwgY2ggPT09IDU3KSAmJiAodGhpcy5zdHJpY3QgfHwgaW5UZW1wbGF0ZSkpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgdGhpcy5wb3MgLSAxIC0gb2N0YWxTdHIubGVuZ3RoLFxuICAgICAgICAgIGluVGVtcGxhdGVcbiAgICAgICAgICAgID8gXCJPY3RhbCBsaXRlcmFsIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICAgICA6IFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbClcbiAgICB9XG4gICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgIC8vIFVuaWNvZGUgbmV3IGxpbmUgY2hhcmFjdGVycyBhZnRlciBcXCBnZXQgcmVtb3ZlZCBmcm9tIG91dHB1dCBpbiBib3RoXG4gICAgICAvLyB0ZW1wbGF0ZSBsaXRlcmFscyBhbmQgc3RyaW5nc1xuICAgICAgcmV0dXJuIFwiXCJcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG4gIH1cbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcyAoJ1xceCcsICdcXHUnLCAnXFxVJykuXG5cbnBwJDkucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbik7XG4gIGlmIChuID09PSBudWxsKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7IH1cbiAgcmV0dXJuIG5cbn07XG5cbi8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2Bcbi8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuLy9cbi8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbi8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG5wcCQ5LnJlYWRXb3JkMSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBhc3RyYWwgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gsIGFzdHJhbCkpIHtcbiAgICAgIHRoaXMucG9zICs9IGNoIDw9IDB4ZmZmZiA/IDEgOiAyO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7IC8vIFwiXFxcIlxuICAgICAgdGhpcy5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICB3b3JkICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpICE9PSAxMTcpIC8vIFwidVwiXG4gICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHZhciBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQoKTtcbiAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyKShlc2MsIGFzdHJhbCkpXG4gICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTsgfVxuICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyQxKGVzYyk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGZpcnN0ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHdvcmQgKyB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKVxufTtcblxuLy8gUmVhZCBhbiBpZGVudGlmaWVyIG9yIGtleXdvcmQgdG9rZW4uIFdpbGwgY2hlY2sgZm9yIHJlc2VydmVkXG4vLyB3b3JkcyB3aGVuIG5lY2Vzc2FyeS5cblxucHAkOS5yZWFkV29yZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd29yZCA9IHRoaXMucmVhZFdvcmQxKCk7XG4gIHZhciB0eXBlID0gdHlwZXMubmFtZTtcbiAgaWYgKHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIFwiICsgd29yZCk7IH1cbiAgICB0eXBlID0ga2V5d29yZHMkMVt3b3JkXTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCB3b3JkKVxufTtcblxuLy8gQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cblxudmFyIHZlcnNpb24gPSBcIjYuNC4wXCI7XG5cblBhcnNlci5hY29ybiA9IHtcbiAgUGFyc2VyOiBQYXJzZXIsXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcbiAgUG9zaXRpb246IFBvc2l0aW9uLFxuICBTb3VyY2VMb2NhdGlvbjogU291cmNlTG9jYXRpb24sXG4gIGdldExpbmVJbmZvOiBnZXRMaW5lSW5mbyxcbiAgTm9kZTogTm9kZSxcbiAgVG9rZW5UeXBlOiBUb2tlblR5cGUsXG4gIHRva1R5cGVzOiB0eXBlcyxcbiAga2V5d29yZFR5cGVzOiBrZXl3b3JkcyQxLFxuICBUb2tDb250ZXh0OiBUb2tDb250ZXh0LFxuICB0b2tDb250ZXh0czogdHlwZXMkMSxcbiAgaXNJZGVudGlmaWVyQ2hhcjogaXNJZGVudGlmaWVyQ2hhcixcbiAgaXNJZGVudGlmaWVyU3RhcnQ6IGlzSWRlbnRpZmllclN0YXJ0LFxuICBUb2tlbjogVG9rZW4sXG4gIGlzTmV3TGluZTogaXNOZXdMaW5lLFxuICBsaW5lQnJlYWs6IGxpbmVCcmVhayxcbiAgbGluZUJyZWFrRzogbGluZUJyZWFrRyxcbiAgbm9uQVNDSUl3aGl0ZXNwYWNlOiBub25BU0NJSXdoaXRlc3BhY2Vcbn07XG5cbi8vIFRoZSBtYWluIGV4cG9ydGVkIGludGVyZmFjZSAodW5kZXIgYHNlbGYuYWNvcm5gIHdoZW4gaW4gdGhlXG4vLyBicm93c2VyKSBpcyBhIGBwYXJzZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGNvZGUgc3RyaW5nIGFuZFxuLy8gcmV0dXJucyBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSBhcyBzcGVjaWZpZWQgYnkgW01vemlsbGEgcGFyc2VyXG4vLyBBUEldW2FwaV0uXG4vL1xuLy8gW2FwaV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvU3BpZGVyTW9ua2V5L1BhcnNlcl9BUElcblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBhcnNlci5wYXJzZShpbnB1dCwgb3B0aW9ucylcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB0cmllcyB0byBwYXJzZSBhIHNpbmdsZSBleHByZXNzaW9uIGF0IGEgZ2l2ZW5cbi8vIG9mZnNldCBpbiBhIHN0cmluZy4gVXNlZnVsIGZvciBwYXJzaW5nIG1peGVkLWxhbmd1YWdlIGZvcm1hdHNcbi8vIHRoYXQgZW1iZWQgSmF2YVNjcmlwdCBleHByZXNzaW9ucy5cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICByZXR1cm4gUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpXG59XG5cbi8vIEFjb3JuIGlzIG9yZ2FuaXplZCBhcyBhIHRva2VuaXplciBhbmQgYSByZWN1cnNpdmUtZGVzY2VudCBwYXJzZXIuXG4vLyBUaGUgYHRva2VuaXplcmAgZXhwb3J0IHByb3ZpZGVzIGFuIGludGVyZmFjZSB0byB0aGUgdG9rZW5pemVyLlxuXG5mdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBhcnNlci50b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpXG59XG5cbmV4cG9ydCB7IE5vZGUsIFBhcnNlciwgUG9zaXRpb24sIFNvdXJjZUxvY2F0aW9uLCBUb2tDb250ZXh0LCBUb2tlbiwgVG9rZW5UeXBlLCBkZWZhdWx0T3B0aW9ucywgZ2V0TGluZUluZm8sIGlzSWRlbnRpZmllckNoYXIsIGlzSWRlbnRpZmllclN0YXJ0LCBpc05ld0xpbmUsIGtleXdvcmRzJDEgYXMga2V5d29yZFR5cGVzLCBsaW5lQnJlYWssIGxpbmVCcmVha0csIG5vbkFTQ0lJd2hpdGVzcGFjZSwgcGFyc2UsIHBhcnNlRXhwcmVzc2lvbkF0LCB0eXBlcyQxIGFzIHRva0NvbnRleHRzLCB0eXBlcyBhcyB0b2tUeXBlcywgdG9rZW5pemVyLCB2ZXJzaW9uIH07XG4iLCIvKiFcbiAqIFBhcGVyLmpzIHYwLjEyLjExIC0gVGhlIFN3aXNzIEFybXkgS25pZmUgb2YgVmVjdG9yIEdyYXBoaWNzIFNjcmlwdGluZy5cbiAqIGh0dHA6Ly9wYXBlcmpzLm9yZy9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgLSAyMDIwLCBKw7xyZyBMZWhuaSAmIEpvbmF0aGFuIFB1Y2tleVxuICogaHR0cDovL2p1ZXJnbGVobmkuY29tLyAmIGh0dHBzOi8vcHVja2V5LnN0dWRpby9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBEYXRlOiBGcmkgSnVuIDE5IDE5OjE0OjMzIDIwMjAgKzAyMDBcbiAqXG4gKioqXG4gKlxuICogU3RyYXBzLmpzIC0gQ2xhc3MgaW5oZXJpdGFuY2UgbGlicmFyeSB3aXRoIHN1cHBvcnQgZm9yIGJlYW4tc3R5bGUgYWNjZXNzb3JzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA2IC0gMjAyMCBKw7xyZyBMZWhuaVxuICogaHR0cDovL2p1ZXJnbGVobmkuY29tL1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKioqXG4gKlxuICogQWNvcm4uanNcbiAqIGh0dHBzOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Fjb3JuL1xuICpcbiAqIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQsXG4gKiBjcmVhdGVkIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuICpcbiAqL1xudmFyIHBhcGVyID0gZnVuY3Rpb24gKHNlbGYsIHVuZGVmaW5lZCkge1xuICBzZWxmID0gc2VsZiB8fCByZXF1aXJlKCcuL25vZGUvc2VsZi5qcycpO1xuICB2YXIgd2luZG93ID0gc2VsZi53aW5kb3csXG4gICAgICBkb2N1bWVudCA9IHNlbGYuZG9jdW1lbnQ7XG4gIHZhciBCYXNlID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGlkZGVuID0gL14oc3RhdGljc3xlbnVtZXJhYmxlfGJlYW5zfHByZXNlcnZlKSQvLFxuICAgICAgICBhcnJheSA9IFtdLFxuICAgICAgICBzbGljZSA9IGFycmF5LnNsaWNlLFxuICAgICAgICBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgICAgICBkZXNjcmliZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICAgIGRlZmluZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgZm9yRWFjaCA9IGFycmF5LmZvckVhY2ggfHwgZnVuY3Rpb24gKGl0ZXIsIGJpbmQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIGZvckluID0gZnVuY3Rpb24gKGl0ZXIsIGJpbmQpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcykge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSkgaXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIHNldCA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKGRzdCkge1xuICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZHN0O1xuICAgIH0sXG4gICAgICAgIGVhY2ggPSBmdW5jdGlvbiAob2JqLCBpdGVyLCBiaW5kKSB7XG4gICAgICBpZiAob2JqKSB7XG4gICAgICAgIHZhciBkZXNjID0gZGVzY3JpYmUob2JqLCAnbGVuZ3RoJyk7XG4gICAgICAgIChkZXNjICYmIHR5cGVvZiBkZXNjLnZhbHVlID09PSAnbnVtYmVyJyA/IGZvckVhY2ggOiBmb3JJbikuY2FsbChvYmosIGl0ZXIsIGJpbmQgPSBiaW5kIHx8IG9iaik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiaW5kO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbmplY3QoZGVzdCwgc3JjLCBlbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpIHtcbiAgICAgIHZhciBiZWFuc05hbWVzID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIGZpZWxkKG5hbWUsIHZhbCkge1xuICAgICAgICB2YWwgPSB2YWwgfHwgKHZhbCA9IGRlc2NyaWJlKHNyYywgbmFtZSkpICYmICh2YWwuZ2V0ID8gdmFsIDogdmFsLnZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyMnKSB2YWwgPSBkZXN0W3ZhbC5zdWJzdHJpbmcoMSldIHx8IHZhbDtcbiAgICAgICAgdmFyIGlzRnVuYyA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICAgICByZXMgPSB2YWwsXG4gICAgICAgICAgICBwcmV2ID0gcHJlc2VydmUgfHwgaXNGdW5jICYmICF2YWwuYmFzZSA/IHZhbCAmJiB2YWwuZ2V0ID8gbmFtZSBpbiBkZXN0IDogZGVzdFtuYW1lXSA6IG51bGwsXG4gICAgICAgICAgICBiZWFuO1xuXG4gICAgICAgIGlmICghcHJlc2VydmUgfHwgIXByZXYpIHtcbiAgICAgICAgICBpZiAoaXNGdW5jICYmIHByZXYpIHZhbC5iYXNlID0gcHJldjtcbiAgICAgICAgICBpZiAoaXNGdW5jICYmIGJlYW5zICE9PSBmYWxzZSAmJiAoYmVhbiA9IG5hbWUubWF0Y2goL14oW2dzXWV0fGlzKSgoW0EtWl0pKC4qKSkkLykpKSBiZWFuc05hbWVzW2JlYW5bM10udG9Mb3dlckNhc2UoKSArIGJlYW5bNF1dID0gYmVhblsyXTtcblxuICAgICAgICAgIGlmICghcmVzIHx8IGlzRnVuYyB8fCAhcmVzLmdldCB8fCB0eXBlb2YgcmVzLmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCAhQmFzZS5pc1BsYWluT2JqZWN0KHJlcykpIHtcbiAgICAgICAgICAgIHJlcyA9IHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJlcyxcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKChkZXNjcmliZShkZXN0LCBuYW1lKSB8fCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9KS5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIHJlcy5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzLmVudW1lcmFibGUgPSBlbnVtZXJhYmxlICE9IG51bGwgPyBlbnVtZXJhYmxlIDogIWJlYW47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmaW5lKGRlc3QsIG5hbWUsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNyYykge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHNyYykge1xuICAgICAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIWhpZGRlbi50ZXN0KG5hbWUpKSBmaWVsZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gYmVhbnNOYW1lcykge1xuICAgICAgICAgIHZhciBwYXJ0ID0gYmVhbnNOYW1lc1tuYW1lXSxcbiAgICAgICAgICAgICAgc2V0ID0gZGVzdFsnc2V0JyArIHBhcnRdLFxuICAgICAgICAgICAgICBnZXQgPSBkZXN0WydnZXQnICsgcGFydF0gfHwgc2V0ICYmIGRlc3RbJ2lzJyArIHBhcnRdO1xuICAgICAgICAgIGlmIChnZXQgJiYgKGJlYW5zID09PSB0cnVlIHx8IGdldC5sZW5ndGggPT09IDApKSBmaWVsZChuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgICAgIHNldDogc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQmFzZSgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoc3JjKSBzZXQodGhpcywgc3JjKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluamVjdChCYXNlLCB7XG4gICAgICBpbmplY3Q6IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIHZhciBzdGF0aWNzID0gc3JjLnN0YXRpY3MgPT09IHRydWUgPyBzcmMgOiBzcmMuc3RhdGljcyxcbiAgICAgICAgICAgICAgYmVhbnMgPSBzcmMuYmVhbnMsXG4gICAgICAgICAgICAgIHByZXNlcnZlID0gc3JjLnByZXNlcnZlO1xuICAgICAgICAgIGlmIChzdGF0aWNzICE9PSBzcmMpIGluamVjdCh0aGlzLnByb3RvdHlwZSwgc3JjLCBzcmMuZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKTtcbiAgICAgICAgICBpbmplY3QodGhpcywgc3RhdGljcywgbnVsbCwgYmVhbnMsIHByZXNlcnZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykgdGhpcy5pbmplY3QoYXJndW1lbnRzW2ldKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBleHRlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLFxuICAgICAgICAgICAgY3RvcixcbiAgICAgICAgICAgIHByb3RvO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvYmosIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbCAmJiAhKGN0b3IgJiYgcHJvdG8pOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgY3RvciA9IGN0b3IgfHwgb2JqLmluaXRpYWxpemU7XG4gICAgICAgICAgcHJvdG8gPSBwcm90byB8fCBvYmoucHJvdG90eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3RvciA9IGN0b3IgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcm90byA9IGN0b3IucHJvdG90eXBlID0gcHJvdG8gfHwgY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcbiAgICAgICAgZGVmaW5lKHByb3RvLCAnY29uc3RydWN0b3InLCB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbmplY3QoY3RvciwgdGhpcyk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB0aGlzLmluamVjdC5hcHBseShjdG9yLCBhcmd1bWVudHMpO1xuICAgICAgICBjdG9yLmJhc2UgPSBiYXNlO1xuICAgICAgICByZXR1cm4gY3RvcjtcbiAgICAgIH1cbiAgICB9KS5pbmplY3Qoe1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBpbml0aWFsaXplOiBCYXNlLFxuICAgICAgc2V0OiBCYXNlLFxuICAgICAgaW5qZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICBpbmplY3QodGhpcywgc3JjLCBzcmMuZW51bWVyYWJsZSwgc3JjLmJlYW5zLCBzcmMucHJlc2VydmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGV4dGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gY3JlYXRlKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVzLmluamVjdC5hcHBseShyZXMsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgZWFjaDogZnVuY3Rpb24gKGl0ZXIsIGJpbmQpIHtcbiAgICAgICAgcmV0dXJuIGVhY2godGhpcywgaXRlciwgYmluZCk7XG4gICAgICB9LFxuICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgc2V0OiBzZXQsXG4gICAgICAgIGVhY2g6IGVhY2gsXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgICAgICBkZWZpbmU6IGRlZmluZSxcbiAgICAgICAgZGVzY3JpYmU6IGRlc2NyaWJlLFxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBzZXQobmV3IG9iai5jb25zdHJ1Y3RvcigpLCBvYmopO1xuICAgICAgICB9LFxuICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgdmFyIGN0b3IgPSBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3I7XG4gICAgICAgICAgcmV0dXJuIGN0b3IgJiYgKGN0b3IgPT09IE9iamVjdCB8fCBjdG9yID09PSBCYXNlIHx8IGN0b3IubmFtZSA9PT0gJ09iamVjdCcpO1xuICAgICAgICB9LFxuICAgICAgICBwaWNrOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhICE9PSB1bmRlZmluZWQgPyBhIDogYjtcbiAgICAgICAgfSxcbiAgICAgICAgc2xpY2U6IGZ1bmN0aW9uIChsaXN0LCBiZWdpbiwgZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwobGlzdCwgYmVnaW4sIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSgpO1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIG1vZHVsZS5leHBvcnRzID0gQmFzZTtcbiAgQmFzZS5pbmplY3Qoe1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faWQgIT0gbnVsbCA/ICh0aGlzLl9jbGFzcyB8fCAnT2JqZWN0JykgKyAodGhpcy5fbmFtZSA/IFwiICdcIiArIHRoaXMuX25hbWUgKyBcIidcIiA6ICcgQCcgKyB0aGlzLl9pZCkgOiAneyAnICsgQmFzZS5lYWNoKHRoaXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICghL15fLy50ZXN0KGtleSkpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnB1c2goa2V5ICsgJzogJyArICh0eXBlID09PSAnbnVtYmVyJyA/IEZvcm1hdHRlci5pbnN0YW5jZS5udW1iZXIodmFsdWUpIDogdHlwZSA9PT0gJ3N0cmluZycgPyBcIidcIiArIHZhbHVlICsgXCInXCIgOiB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9LCBbXSkuam9pbignLCAnKSArICcgfSc7XG4gICAgfSxcbiAgICBnZXRDbGFzc05hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbGFzcyB8fCAnJztcbiAgICB9LFxuICAgIGltcG9ydEpTT046IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICByZXR1cm4gQmFzZS5pbXBvcnRKU09OKGpzb24sIHRoaXMpO1xuICAgIH0sXG4gICAgZXhwb3J0SlNPTjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBCYXNlLmV4cG9ydEpTT04odGhpcywgb3B0aW9ucyk7XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHByb3BzLCBleGNsdWRlKSB7XG4gICAgICBpZiAocHJvcHMpIEJhc2UuZmlsdGVyKHRoaXMsIHByb3BzLCBleGNsdWRlLCB0aGlzLl9wcmlvcml0aXplKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGJlYW5zOiBmYWxzZSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBleHBvcnRzOiB7fSxcbiAgICAgIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgIG5hbWUgPSByZXMucHJvdG90eXBlLl9jbGFzcztcbiAgICAgICAgaWYgKG5hbWUgJiYgIUJhc2UuZXhwb3J0c1tuYW1lXSkgQmFzZS5leHBvcnRzW25hbWVdID0gcmVzO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSxcbiAgICAgIGVxdWFsczogZnVuY3Rpb24gKG9iajEsIG9iajIpIHtcbiAgICAgICAgaWYgKG9iajEgPT09IG9iajIpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2JqMSAmJiBvYmoxLmVxdWFscykgcmV0dXJuIG9iajEuZXF1YWxzKG9iajIpO1xuICAgICAgICBpZiAob2JqMiAmJiBvYmoyLmVxdWFscykgcmV0dXJuIG9iajIuZXF1YWxzKG9iajEpO1xuXG4gICAgICAgIGlmIChvYmoxICYmIG9iajIgJiYgdHlwZW9mIG9iajEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iajEpICYmIEFycmF5LmlzQXJyYXkob2JqMikpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBvYmoxLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT09IG9iajIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgICBpZiAoIUJhc2UuZXF1YWxzKG9iajFbbGVuZ3RoXSwgb2JqMltsZW5ndGhdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iajEpLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICAgICAgICBpZiAoIShvYmoyLmhhc093blByb3BlcnR5KGtleSkgJiYgQmFzZS5lcXVhbHMob2JqMVtrZXldLCBvYmoyW2tleV0pKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIChsaXN0LCBzdGFydCwgb3B0aW9ucywgYW1vdW50KSB7XG4gICAgICAgIGlmICh0aGlzID09PSBCYXNlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wZWVrKGxpc3QsIHN0YXJ0KTtcbiAgICAgICAgICBsaXN0Ll9faW5kZXgrKztcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvdG8gPSB0aGlzLnByb3RvdHlwZSxcbiAgICAgICAgICAgIHJlYWRJbmRleCA9IHByb3RvLl9yZWFkSW5kZXgsXG4gICAgICAgICAgICBiZWdpbiA9IHN0YXJ0IHx8IHJlYWRJbmRleCAmJiBsaXN0Ll9faW5kZXggfHwgMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IGxpc3QubGVuZ3RoLFxuICAgICAgICAgICAgb2JqID0gbGlzdFtiZWdpbl07XG4gICAgICAgIGFtb3VudCA9IGFtb3VudCB8fCBsZW5ndGggLSBiZWdpbjtcblxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgdGhpcyB8fCBvcHRpb25zICYmIG9wdGlvbnMucmVhZE51bGwgJiYgb2JqID09IG51bGwgJiYgYW1vdW50IDw9IDEpIHtcbiAgICAgICAgICBpZiAocmVhZEluZGV4KSBsaXN0Ll9faW5kZXggPSBiZWdpbiArIDE7XG4gICAgICAgICAgcmV0dXJuIG9iaiAmJiBvcHRpb25zICYmIG9wdGlvbnMuY2xvbmUgPyBvYmouY2xvbmUoKSA6IG9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IEJhc2UuY3JlYXRlKHByb3RvKTtcbiAgICAgICAgaWYgKHJlYWRJbmRleCkgb2JqLl9fcmVhZCA9IHRydWU7XG4gICAgICAgIG9iaiA9IG9iai5pbml0aWFsaXplLmFwcGx5KG9iaiwgYmVnaW4gPiAwIHx8IGJlZ2luICsgYW1vdW50IDwgbGVuZ3RoID8gQmFzZS5zbGljZShsaXN0LCBiZWdpbiwgYmVnaW4gKyBhbW91bnQpIDogbGlzdCkgfHwgb2JqO1xuXG4gICAgICAgIGlmIChyZWFkSW5kZXgpIHtcbiAgICAgICAgICBsaXN0Ll9faW5kZXggPSBiZWdpbiArIG9iai5fX3JlYWQ7XG4gICAgICAgICAgdmFyIGZpbHRlcmVkID0gb2JqLl9fZmlsdGVyZWQ7XG5cbiAgICAgICAgICBpZiAoZmlsdGVyZWQpIHtcbiAgICAgICAgICAgIGxpc3QuX19maWx0ZXJlZCA9IGZpbHRlcmVkO1xuICAgICAgICAgICAgb2JqLl9fZmlsdGVyZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JqLl9fcmVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9LFxuICAgICAgcGVlazogZnVuY3Rpb24gKGxpc3QsIHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBsaXN0W2xpc3QuX19pbmRleCA9IHN0YXJ0IHx8IGxpc3QuX19pbmRleCB8fCAwXTtcbiAgICAgIH0sXG4gICAgICByZW1haW46IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHJldHVybiBsaXN0Lmxlbmd0aCAtIChsaXN0Ll9faW5kZXggfHwgMCk7XG4gICAgICB9LFxuICAgICAgcmVhZExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBzdGFydCwgb3B0aW9ucywgYW1vdW50KSB7XG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgICAgYmVnaW4gPSBzdGFydCB8fCAwLFxuICAgICAgICAgICAgZW5kID0gYW1vdW50ID8gYmVnaW4gKyBhbW91bnQgOiBsaXN0Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgIHJlcy5wdXNoKEFycmF5LmlzQXJyYXkoZW50cnkgPSBsaXN0W2ldKSA/IHRoaXMucmVhZChlbnRyeSwgMCwgb3B0aW9ucykgOiB0aGlzLnJlYWQobGlzdCwgaSwgb3B0aW9ucywgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0sXG4gICAgICByZWFkTmFtZWQ6IGZ1bmN0aW9uIChsaXN0LCBuYW1lLCBzdGFydCwgb3B0aW9ucywgYW1vdW50KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSksXG4gICAgICAgICAgICBoYXNWYWx1ZSA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGhhc1ZhbHVlKSB7XG4gICAgICAgICAgdmFyIGZpbHRlcmVkID0gbGlzdC5fX2ZpbHRlcmVkO1xuXG4gICAgICAgICAgaWYgKCFmaWx0ZXJlZCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKGxpc3QpO1xuICAgICAgICAgICAgZmlsdGVyZWQgPSBsaXN0Ll9fZmlsdGVyZWQgPSBCYXNlLmNyZWF0ZShzb3VyY2UpO1xuICAgICAgICAgICAgZmlsdGVyZWQuX191bmZpbHRlcmVkID0gc291cmNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpbHRlcmVkW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZChoYXNWYWx1ZSA/IFt2YWx1ZV0gOiBsaXN0LCBzdGFydCwgb3B0aW9ucywgYW1vdW50KTtcbiAgICAgIH0sXG4gICAgICByZWFkU3VwcG9ydGVkOiBmdW5jdGlvbiAobGlzdCwgZGVzdCkge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UobGlzdCksXG4gICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIHJlYWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gZGVzdCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGF0LnJlYWROYW1lZChsaXN0LCBrZXkpO1xuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVzdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWFkO1xuICAgICAgfSxcbiAgICAgIGdldFNvdXJjZTogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGxpc3QuX19zb3VyY2U7XG5cbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGFyZyA9IGxpc3QubGVuZ3RoID09PSAxICYmIGxpc3RbMF07XG4gICAgICAgICAgc291cmNlID0gbGlzdC5fX3NvdXJjZSA9IGFyZyAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKSA/IGFyZyA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfSxcbiAgICAgIGdldE5hbWVkOiBmdW5jdGlvbiAobGlzdCwgbmFtZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UobGlzdCk7XG5cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBuYW1lID8gc291cmNlW25hbWVdIDogbGlzdC5fX2ZpbHRlcmVkIHx8IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhc05hbWVkOiBmdW5jdGlvbiAobGlzdCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGRlc3QsIHNvdXJjZSwgZXhjbHVkZSwgcHJpb3JpdGl6ZSkge1xuICAgICAgICB2YXIgcHJvY2Vzc2VkO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUtleShrZXkpIHtcbiAgICAgICAgICBpZiAoIShleGNsdWRlICYmIGtleSBpbiBleGNsdWRlKSAmJiAhKHByb2Nlc3NlZCAmJiBrZXkgaW4gcHJvY2Vzc2VkKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgZGVzdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByaW9yaXRpemUpIHtcbiAgICAgICAgICB2YXIga2V5cyA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleSwgbCA9IHByaW9yaXRpemUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGtleSA9IHByaW9yaXRpemVbaV0pIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICBoYW5kbGVLZXkoa2V5KTtcbiAgICAgICAgICAgICAga2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9jZXNzZWQgPSBrZXlzO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMoc291cmNlLl9fdW5maWx0ZXJlZCB8fCBzb3VyY2UpLmZvckVhY2goaGFuZGxlS2V5KTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9LFxuICAgICAgaXNQbGFpblZhbHVlOiBmdW5jdGlvbiAob2JqLCBhc1N0cmluZykge1xuICAgICAgICByZXR1cm4gQmFzZS5pc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopIHx8IGFzU3RyaW5nICYmIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuICAgICAgfSxcbiAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKG9iaiwgb3B0aW9ucywgY29tcGFjdCwgZGljdGlvbmFyeSkge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGlzUm9vdCA9ICFkaWN0aW9uYXJ5LFxuICAgICAgICAgICAgcmVzO1xuXG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICBvcHRpb25zLmZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgICAgIGRpY3Rpb25hcnkgPSB7XG4gICAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgICBkZWZpbml0aW9uczoge30sXG4gICAgICAgICAgICByZWZlcmVuY2VzOiB7fSxcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKGl0ZW0sIGNyZWF0ZSkge1xuICAgICAgICAgICAgICB2YXIgaWQgPSAnIycgKyBpdGVtLl9pZCxcbiAgICAgICAgICAgICAgICAgIHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF07XG5cbiAgICAgICAgICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBjcmVhdGUuY2FsbChpdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGl0ZW0uX2NsYXNzO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lICYmIHJlc1swXSAhPT0gbmFtZSkgcmVzLnVuc2hpZnQobmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uc1tpZF0gPSByZXM7XG4gICAgICAgICAgICAgICAgcmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXSA9IFtpZF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqICYmIG9iai5fc2VyaWFsaXplKSB7XG4gICAgICAgICAgcmVzID0gb2JqLl9zZXJpYWxpemUob3B0aW9ucywgZGljdGlvbmFyeSk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvYmouX2NsYXNzO1xuXG4gICAgICAgICAgaWYgKG5hbWUgJiYgIW9iai5fY29tcGFjdFNlcmlhbGl6ZSAmJiAoaXNSb290IHx8ICFjb21wYWN0KSAmJiByZXNbMF0gIT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJlcy51bnNoaWZ0KG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICByZXMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykgcmVzW2ldID0gQmFzZS5zZXJpYWxpemUob2JqW2ldLCBvcHRpb25zLCBjb21wYWN0LCBkaWN0aW9uYXJ5KTtcbiAgICAgICAgfSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgICAgIHJlcyA9IHt9O1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgcmVzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpba2V5XSwgb3B0aW9ucywgY29tcGFjdCwgZGljdGlvbmFyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmVzID0gb3B0aW9ucy5mb3JtYXR0ZXIubnVtYmVyKG9iaiwgb3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IG9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc1Jvb3QgJiYgZGljdGlvbmFyeS5sZW5ndGggPiAwID8gW1snZGljdGlvbmFyeScsIGRpY3Rpb25hcnkuZGVmaW5pdGlvbnNdLCByZXNdIDogcmVzO1xuICAgICAgfSxcbiAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoanNvbiwgY3JlYXRlLCBfZGF0YSwgX3NldERpY3Rpb25hcnksIF9pc1Jvb3QpIHtcbiAgICAgICAgdmFyIHJlcyA9IGpzb24sXG4gICAgICAgICAgICBpc0ZpcnN0ID0gIV9kYXRhLFxuICAgICAgICAgICAgaGFzRGljdGlvbmFyeSA9IGlzRmlyc3QgJiYganNvbiAmJiBqc29uLmxlbmd0aCAmJiBqc29uWzBdWzBdID09PSAnZGljdGlvbmFyeSc7XG4gICAgICAgIF9kYXRhID0gX2RhdGEgfHwge307XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGpzb25bMF0sXG4gICAgICAgICAgICAgIGlzRGljdGlvbmFyeSA9IHR5cGUgPT09ICdkaWN0aW9uYXJ5JztcblxuICAgICAgICAgIGlmIChqc29uLmxlbmd0aCA9PSAxICYmIC9eIy8udGVzdCh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9kYXRhLmRpY3Rpb25hcnlbdHlwZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHlwZSA9IEJhc2UuZXhwb3J0c1t0eXBlXTtcbiAgICAgICAgICByZXMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSB0eXBlID8gMSA6IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgcmVzLnB1c2goQmFzZS5kZXNlcmlhbGl6ZShqc29uW2ldLCBjcmVhdGUsIF9kYXRhLCBpc0RpY3Rpb25hcnksIGhhc0RpY3Rpb25hcnkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSByZXM7XG5cbiAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHR5cGUsIGFyZ3MsIGlzRmlyc3QgfHwgX2lzUm9vdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXMgPSBuZXcgdHlwZShhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGpzb24pKSB7XG4gICAgICAgICAgcmVzID0ge307XG4gICAgICAgICAgaWYgKF9zZXREaWN0aW9uYXJ5KSBfZGF0YS5kaWN0aW9uYXJ5ID0gcmVzO1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb24pIHJlc1trZXldID0gQmFzZS5kZXNlcmlhbGl6ZShqc29uW2tleV0sIGNyZWF0ZSwgX2RhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc0RpY3Rpb25hcnkgPyByZXNbMV0gOiByZXM7XG4gICAgICB9LFxuICAgICAgZXhwb3J0SlNPTjogZnVuY3Rpb24gKG9iaiwgb3B0aW9ucykge1xuICAgICAgICB2YXIganNvbiA9IEJhc2Uuc2VyaWFsaXplKG9iaiwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuYXNTdHJpbmcgPT0gZmFsc2UgPyBqc29uIDogSlNPTi5zdHJpbmdpZnkoanNvbik7XG4gICAgICB9LFxuICAgICAgaW1wb3J0SlNPTjogZnVuY3Rpb24gKGpzb24sIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gQmFzZS5kZXNlcmlhbGl6ZSh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbiwgZnVuY3Rpb24gKGN0b3IsIGFyZ3MsIGlzUm9vdCkge1xuICAgICAgICAgIHZhciB1c2VUYXJnZXQgPSBpc1Jvb3QgJiYgdGFyZ2V0ICYmIHRhcmdldC5jb25zdHJ1Y3RvciA9PT0gY3RvcixcbiAgICAgICAgICAgICAgb2JqID0gdXNlVGFyZ2V0ID8gdGFyZ2V0IDogQmFzZS5jcmVhdGUoY3Rvci5wcm90b3R5cGUpO1xuXG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIG9iaiBpbnN0YW5jZW9mIEl0ZW0gJiYgKHVzZVRhcmdldCB8fCAhKG9iaiBpbnN0YW5jZW9mIExheWVyKSkpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgICBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGFyZykpIHtcbiAgICAgICAgICAgICAgYXJnLmluc2VydCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmICh1c2VUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQoW3tcbiAgICAgICAgICAgICAgICAgIGluc2VydDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgICh1c2VUYXJnZXQgPyBvYmouc2V0IDogY3RvcikuYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgICAgICBpZiAodXNlVGFyZ2V0KSB0YXJnZXQgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHB1c2g6IGZ1bmN0aW9uIChsaXN0LCBpdGVtcykge1xuICAgICAgICB2YXIgaXRlbXNMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGl0ZW1zTGVuZ3RoIDwgNDA5Nikge1xuICAgICAgICAgIGxpc3QucHVzaC5hcHBseShsaXN0LCBpdGVtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0YXJ0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgbGlzdC5sZW5ndGggKz0gaXRlbXNMZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3Rbc3RhcnRMZW5ndGggKyBpXSA9IGl0ZW1zW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgfSxcbiAgICAgIHNwbGljZTogZnVuY3Rpb24gKGxpc3QsIGl0ZW1zLCBpbmRleCwgcmVtb3ZlKSB7XG4gICAgICAgIHZhciBhbW91bnQgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBhcHBlbmQgPSBpbmRleCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpbmRleCA9IGFwcGVuZCA/IGxpc3QubGVuZ3RoIDogaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA+IGxpc3QubGVuZ3RoKSBpbmRleCA9IGxpc3QubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIGl0ZW1zW2ldLl9pbmRleCA9IGluZGV4ICsgaTtcblxuICAgICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgICAgQmFzZS5wdXNoKGxpc3QsIGl0ZW1zKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbaW5kZXgsIHJlbW92ZV07XG4gICAgICAgICAgaWYgKGl0ZW1zKSBCYXNlLnB1c2goYXJncywgaXRlbXMpO1xuICAgICAgICAgIHZhciByZW1vdmVkID0gbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgYXJncyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSByZW1vdmVkW2ldLl9pbmRleCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSBsaXN0W2ldLl9pbmRleCA9IGk7XG5cbiAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhcGl0YWxpemU6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXGJbYS16XS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2gudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY2FtZWxpemU6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uIChtYXRjaCwgY2hyKSB7XG4gICAgICAgICAgcmV0dXJuIGNoci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoeXBoZW5hdGU6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBFbWl0dGVyID0ge1xuICAgIG9uOiBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICB0aGlzLm9uKGtleSwgdmFsdWUpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG4gICAgICAgICAgICBlbnRyeSA9IHR5cGVzICYmIHR5cGVzW3R5cGVdLFxuICAgICAgICAgICAgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnNbdHlwZV0gPSBoYW5kbGVyc1t0eXBlXSB8fCBbXTtcblxuICAgICAgICBpZiAoaGFuZGxlcnMuaW5kZXhPZihmdW5jKSA9PT0gLTEpIHtcbiAgICAgICAgICBoYW5kbGVycy5wdXNoKGZ1bmMpO1xuICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5pbnN0YWxsICYmIGhhbmRsZXJzLmxlbmd0aCA9PT0gMSkgZW50cnkuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb2ZmOiBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICB0aGlzLm9mZihrZXksIHZhbHVlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcbiAgICAgICAgICBlbnRyeSA9IHR5cGVzICYmIHR5cGVzW3R5cGVdLFxuICAgICAgICAgIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSxcbiAgICAgICAgICBpbmRleDtcblxuICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgIGlmICghZnVuYyB8fCAoaW5kZXggPSBoYW5kbGVycy5pbmRleE9mKGZ1bmMpKSAhPT0gLTEgJiYgaGFuZGxlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5LnVuaW5zdGFsbCkgZW50cnkudW5pbnN0YWxsLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25jZTogZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9uKHR5cGUsIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5vZmYodHlwZSwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uICh0eXBlLCBldmVudCkge1xuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcbiAgICAgIGlmICghaGFuZGxlcnMpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBhcmdzID0gQmFzZS5zbGljZShhcmd1bWVudHMsIDEpLFxuICAgICAgICAgIHNldFRhcmdldCA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiAhZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnMuc2xpY2UoKTtcbiAgICAgIGlmIChzZXRUYXJnZXQpIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoaGFuZGxlcnNbaV0uYXBwbHkodGhpcywgYXJncykgPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuc3RvcCkgZXZlbnQuc3RvcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRUYXJnZXQpIGRlbGV0ZSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICByZXNwb25kczogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdKTtcbiAgICB9LFxuICAgIGF0dGFjaDogJyNvbicsXG4gICAgZGV0YWNoOiAnI29mZicsXG4gICAgZmlyZTogJyNlbWl0JyxcbiAgICBfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24gKGluc3RhbGwpIHtcbiAgICAgIHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG4gICAgICAgICAgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MsXG4gICAgICAgICAga2V5ID0gaW5zdGFsbCA/ICdpbnN0YWxsJyA6ICd1bmluc3RhbGwnO1xuXG4gICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBoYW5kbGVycykge1xuICAgICAgICAgIGlmIChoYW5kbGVyc1t0eXBlXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0eXBlc1t0eXBlXSxcbiAgICAgICAgICAgICAgICBmdW5jID0gZW50cnkgJiYgZW50cnlba2V5XTtcbiAgICAgICAgICAgIGlmIChmdW5jKSBmdW5jLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBpbmplY3Q6IGZ1bmN0aW9uIGluamVjdChzcmMpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHNyYy5fZXZlbnRzO1xuXG4gICAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgICB2YXIgdHlwZXMgPSB7fTtcbiAgICAgICAgICBCYXNlLmVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZW50cnksIGtleSkge1xuICAgICAgICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lID0gaXNTdHJpbmcgPyBlbnRyeSA6IGtleSxcbiAgICAgICAgICAgICAgICBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdHlwZXNbdHlwZV0gPSBpc1N0cmluZyA/IHt9IDogZW50cnk7XG4gICAgICAgICAgICBuYW1lID0gJ18nICsgbmFtZTtcblxuICAgICAgICAgICAgc3JjWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzW25hbWVdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3JjWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgICB2YXIgcHJldiA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgICAgIGlmIChwcmV2KSB0aGlzLm9mZih0eXBlLCBwcmV2KTtcbiAgICAgICAgICAgICAgaWYgKGZ1bmMpIHRoaXMub24odHlwZSwgZnVuYyk7XG4gICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBmdW5jO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzcmMuX2V2ZW50VHlwZXMgPSB0eXBlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmplY3QuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIFBhcGVyU2NvcGUgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUGFwZXJTY29wZScsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUGFwZXJTY29wZSgpIHtcbiAgICAgIHBhcGVyID0gdGhpcztcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgQmFzZSh7XG4gICAgICAgIGFwcGx5TWF0cml4OiB0cnVlLFxuICAgICAgICBpbnNlcnRJdGVtczogdHJ1ZSxcbiAgICAgICAgaGFuZGxlU2l6ZTogNCxcbiAgICAgICAgaGl0VG9sZXJhbmNlOiAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvamVjdCA9IG51bGw7XG4gICAgICB0aGlzLnByb2plY3RzID0gW107XG4gICAgICB0aGlzLnRvb2xzID0gW107XG4gICAgICB0aGlzLl9pZCA9IFBhcGVyU2NvcGUuX2lkKys7XG4gICAgICBQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdID0gdGhpcztcbiAgICAgIHZhciBwcm90byA9IFBhcGVyU2NvcGUucHJvdG90eXBlO1xuXG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydCkge1xuICAgICAgICB2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKSB8fCB7fTtcbiAgICAgICAgcHJvdG8uc3VwcG9ydCA9IHtcbiAgICAgICAgICBuYXRpdmVEYXNoOiAnc2V0TGluZURhc2gnIGluIGN0eCB8fCAnbW96RGFzaCcgaW4gY3R4LFxuICAgICAgICAgIG5hdGl2ZUJsZW5kTW9kZXM6IEJsZW5kTW9kZS5uYXRpdmVNb2Rlc1xuICAgICAgICB9O1xuICAgICAgICBDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5hZ2VudCkge1xuICAgICAgICB2YXIgdXNlciA9IHNlbGYubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgb3MgPSAoLyhkYXJ3aW58d2lufG1hY3xsaW51eHxmcmVlYnNkfHN1bm9zKS8uZXhlYyh1c2VyKSB8fCBbXSlbMF0sXG4gICAgICAgICAgICBwbGF0Zm9ybSA9IG9zID09PSAnZGFyd2luJyA/ICdtYWMnIDogb3MsXG4gICAgICAgICAgICBhZ2VudCA9IHByb3RvLmFnZW50ID0gcHJvdG8uYnJvd3NlciA9IHtcbiAgICAgICAgICBwbGF0Zm9ybTogcGxhdGZvcm1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBsYXRmb3JtKSBhZ2VudFtwbGF0Zm9ybV0gPSB0cnVlO1xuICAgICAgICB1c2VyLnJlcGxhY2UoLyhvcGVyYXxjaHJvbWV8c2FmYXJpfHdlYmtpdHxmaXJlZm94fG1zaWV8dHJpZGVudHxhdG9tfG5vZGV8anNkb20pXFwvP1xccyooWy5cXGRdKykoPzouKnZlcnNpb25cXC8oWy5cXGRdKykpPyg/Oi4qcnZcXDp2PyhbLlxcZF0rKSk/L2csIGZ1bmN0aW9uIChtYXRjaCwgbiwgdjEsIHYyLCBydikge1xuICAgICAgICAgIGlmICghYWdlbnQuY2hyb21lKSB7XG4gICAgICAgICAgICB2YXIgdiA9IG4gPT09ICdvcGVyYScgPyB2MiA6IC9eKG5vZGV8dHJpZGVudCkkLy50ZXN0KG4pID8gcnYgOiB2MTtcbiAgICAgICAgICAgIGFnZW50LnZlcnNpb24gPSB2O1xuICAgICAgICAgICAgYWdlbnQudmVyc2lvbk51bWJlciA9IHBhcnNlRmxvYXQodik7XG4gICAgICAgICAgICBuID0ge1xuICAgICAgICAgICAgICB0cmlkZW50OiAnbXNpZScsXG4gICAgICAgICAgICAgIGpzZG9tOiAnbm9kZSdcbiAgICAgICAgICAgIH1bbl0gfHwgbjtcbiAgICAgICAgICAgIGFnZW50Lm5hbWUgPSBuO1xuICAgICAgICAgICAgYWdlbnRbbl0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhZ2VudC5jaHJvbWUpIGRlbGV0ZSBhZ2VudC53ZWJraXQ7XG4gICAgICAgIGlmIChhZ2VudC5hdG9tKSBkZWxldGUgYWdlbnQuY2hyb21lO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmVyc2lvbjogXCIwLjEyLjExXCIsXG4gICAgZ2V0VmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByb2plY3QgPSB0aGlzLnByb2plY3Q7XG4gICAgICByZXR1cm4gcHJvamVjdCAmJiBwcm9qZWN0Ll92aWV3O1xuICAgIH0sXG4gICAgZ2V0UGFwZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZXhlY3V0ZTogZnVuY3Rpb24gKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBleHBvcnRzID0gcGFwZXIuUGFwZXJTY3JpcHQuZXhlY3V0ZShjb2RlLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIFZpZXcudXBkYXRlRm9jdXMoKTtcbiAgICAgIHJldHVybiBleHBvcnRzO1xuICAgIH0sXG4gICAgaW5zdGFsbDogZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICBCYXNlLmVhY2goWydwcm9qZWN0JywgJ3ZpZXcnLCAndG9vbCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIEJhc2UuZGVmaW5lKHNjb3BlLCBrZXksIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhhdFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIGlmICghL15fLy50ZXN0KGtleSkgJiYgdGhpc1trZXldKSBzY29wZVtrZXldID0gdGhpc1trZXldO1xuICAgIH0sXG4gICAgc2V0dXA6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBwYXBlciA9IHRoaXM7XG4gICAgICB0aGlzLnByb2plY3QgPSBuZXcgUHJvamVjdChlbGVtZW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY3JlYXRlQ2FudmFzOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGFjdGl2YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBwYXBlciA9IHRoaXM7XG4gICAgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByb2plY3RzID0gdGhpcy5wcm9qZWN0cyxcbiAgICAgICAgICB0b29scyA9IHRoaXMudG9vbHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSBwcm9qZWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgcHJvamVjdHNbaV0ucmVtb3ZlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSB0b29scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgdG9vbHNbaV0ucmVtb3ZlKCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIGRlbGV0ZSBQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdO1xuICAgIH0sXG4gICAgc3RhdGljczogbmV3IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIG5hbWUgKz0gJ0F0dHJpYnV0ZSc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWwsIGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gZWxbbmFtZV0oYXR0cikgfHwgZWxbbmFtZV0oJ2RhdGEtcGFwZXItJyArIGF0dHIpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBfc2NvcGVzOiB7fSxcbiAgICAgICAgX2lkOiAwLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zY29wZXNbaWRdIHx8IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEF0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdnZXQnKSxcbiAgICAgICAgaGFzQXR0cmlidXRlOiBoYW5kbGVBdHRyaWJ1dGUoJ2hhcycpXG4gICAgICB9O1xuICAgIH0oKVxuICB9KTtcbiAgdmFyIFBhcGVyU2NvcGVJdGVtID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChhY3RpdmF0ZSkge1xuICAgICAgdGhpcy5fc2NvcGUgPSBwYXBlcjtcbiAgICAgIHRoaXMuX2luZGV4ID0gdGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0ucHVzaCh0aGlzKSAtIDE7XG4gICAgICBpZiAoYWN0aXZhdGUgfHwgIXRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0pIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9LFxuICAgIGFjdGl2YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX3Njb3BlKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgcHJldiA9IHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV07XG4gICAgICBpZiAocHJldiAmJiBwcmV2ICE9PSB0aGlzKSBwcmV2LmVtaXQoJ2RlYWN0aXZhdGUnKTtcbiAgICAgIHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSB0aGlzO1xuICAgICAgdGhpcy5lbWl0KCdhY3RpdmF0ZScsIHByZXYpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT09IHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9pbmRleCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICBCYXNlLnNwbGljZSh0aGlzLl9zY29wZVt0aGlzLl9saXN0XSwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuICAgICAgaWYgKHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT0gdGhpcykgdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IG51bGw7XG4gICAgICB0aGlzLl9zY29wZSA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldFZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY29wZS5nZXRWaWV3KCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIENvbGxpc2lvbkRldGVjdGlvbiA9IHtcbiAgICBmaW5kSXRlbUJvdW5kc0NvbGxpc2lvbnM6IGZ1bmN0aW9uIChpdGVtczEsIGl0ZW1zMiwgdG9sZXJhbmNlKSB7XG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZHMoaXRlbXMpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IG5ldyBBcnJheShpdGVtcy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmVjdCA9IGl0ZW1zW2ldLmdldEJvdW5kcygpO1xuICAgICAgICAgIGJvdW5kc1tpXSA9IFtyZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LnJpZ2h0LCByZWN0LmJvdHRvbV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRzMSA9IGdldEJvdW5kcyhpdGVtczEpLFxuICAgICAgICAgIGJvdW5kczIgPSAhaXRlbXMyIHx8IGl0ZW1zMiA9PT0gaXRlbXMxID8gYm91bmRzMSA6IGdldEJvdW5kcyhpdGVtczIpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluZEJvdW5kc0NvbGxpc2lvbnMoYm91bmRzMSwgYm91bmRzMiwgdG9sZXJhbmNlIHx8IDApO1xuICAgIH0sXG4gICAgZmluZEN1cnZlQm91bmRzQ29sbGlzaW9uczogZnVuY3Rpb24gKGN1cnZlczEsIGN1cnZlczIsIHRvbGVyYW5jZSwgYm90aEF4aXMpIHtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kcyhjdXJ2ZXMpIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluLFxuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgICAgICBib3VuZHMgPSBuZXcgQXJyYXkoY3VydmVzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdiA9IGN1cnZlc1tpXTtcbiAgICAgICAgICBib3VuZHNbaV0gPSBbbWluKHZbMF0sIHZbMl0sIHZbNF0sIHZbNl0pLCBtaW4odlsxXSwgdlszXSwgdls1XSwgdls3XSksIG1heCh2WzBdLCB2WzJdLCB2WzRdLCB2WzZdKSwgbWF4KHZbMV0sIHZbM10sIHZbNV0sIHZbN10pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG5cbiAgICAgIHZhciBib3VuZHMxID0gZ2V0Qm91bmRzKGN1cnZlczEpLFxuICAgICAgICAgIGJvdW5kczIgPSAhY3VydmVzMiB8fCBjdXJ2ZXMyID09PSBjdXJ2ZXMxID8gYm91bmRzMSA6IGdldEJvdW5kcyhjdXJ2ZXMyKTtcblxuICAgICAgaWYgKGJvdGhBeGlzKSB7XG4gICAgICAgIHZhciBob3IgPSB0aGlzLmZpbmRCb3VuZHNDb2xsaXNpb25zKGJvdW5kczEsIGJvdW5kczIsIHRvbGVyYW5jZSB8fCAwLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgICAgICB2ZXIgPSB0aGlzLmZpbmRCb3VuZHNDb2xsaXNpb25zKGJvdW5kczEsIGJvdW5kczIsIHRvbGVyYW5jZSB8fCAwLCB0cnVlLCB0cnVlKSxcbiAgICAgICAgICAgIGxpc3QgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsaXN0W2ldID0ge1xuICAgICAgICAgICAgaG9yOiBob3JbaV0sXG4gICAgICAgICAgICB2ZXI6IHZlcltpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZmluZEJvdW5kc0NvbGxpc2lvbnMoYm91bmRzMSwgYm91bmRzMiwgdG9sZXJhbmNlIHx8IDApO1xuICAgIH0sXG4gICAgZmluZEJvdW5kc0NvbGxpc2lvbnM6IGZ1bmN0aW9uIChib3VuZHNBLCBib3VuZHNCLCB0b2xlcmFuY2UsIHN3ZWVwVmVydGljYWwsIG9ubHlTd2VlcEF4aXNDb2xsaXNpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9ICFib3VuZHNCIHx8IGJvdW5kc0EgPT09IGJvdW5kc0IsXG4gICAgICAgICAgYWxsQm91bmRzID0gc2VsZiA/IGJvdW5kc0EgOiBib3VuZHNBLmNvbmNhdChib3VuZHNCKSxcbiAgICAgICAgICBsZW5ndGhBID0gYm91bmRzQS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoQWxsID0gYWxsQm91bmRzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGluZGljZXMsIGNvb3JkLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbG8gPSAwLFxuICAgICAgICAgICAgaGkgPSBpbmRpY2VzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgIHZhciBtaWQgPSBoaSArIGxvID4+PiAxO1xuXG4gICAgICAgICAgaWYgKGFsbEJvdW5kc1tpbmRpY2VzW21pZF1dW2Nvb3JkXSA8IHZhbHVlKSB7XG4gICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsbyAtIDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmkwID0gc3dlZXBWZXJ0aWNhbCA/IDEgOiAwLFxuICAgICAgICAgIHByaTEgPSBwcmkwICsgMixcbiAgICAgICAgICBzZWMwID0gc3dlZXBWZXJ0aWNhbCA/IDAgOiAxLFxuICAgICAgICAgIHNlYzEgPSBzZWMwICsgMjtcbiAgICAgIHZhciBhbGxJbmRpY2VzQnlQcmkwID0gbmV3IEFycmF5KGxlbmd0aEFsbCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoQWxsOyBpKyspIHtcbiAgICAgICAgYWxsSW5kaWNlc0J5UHJpMFtpXSA9IGk7XG4gICAgICB9XG5cbiAgICAgIGFsbEluZGljZXNCeVByaTAuc29ydChmdW5jdGlvbiAoaTEsIGkyKSB7XG4gICAgICAgIHJldHVybiBhbGxCb3VuZHNbaTFdW3ByaTBdIC0gYWxsQm91bmRzW2kyXVtwcmkwXTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFjdGl2ZUluZGljZXNCeVByaTEgPSBbXSxcbiAgICAgICAgICBhbGxDb2xsaXNpb25zID0gbmV3IEFycmF5KGxlbmd0aEEpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aEFsbDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJJbmRleCA9IGFsbEluZGljZXNCeVByaTBbaV0sXG4gICAgICAgICAgICBjdXJCb3VuZHMgPSBhbGxCb3VuZHNbY3VySW5kZXhdLFxuICAgICAgICAgICAgb3JpZ0luZGV4ID0gc2VsZiA/IGN1ckluZGV4IDogY3VySW5kZXggLSBsZW5ndGhBLFxuICAgICAgICAgICAgaXNDdXJyZW50QSA9IGN1ckluZGV4IDwgbGVuZ3RoQSxcbiAgICAgICAgICAgIGlzQ3VycmVudEIgPSBzZWxmIHx8ICFpc0N1cnJlbnRBLFxuICAgICAgICAgICAgY3VyQ29sbGlzaW9ucyA9IGlzQ3VycmVudEEgPyBbXSA6IG51bGw7XG5cbiAgICAgICAgaWYgKGFjdGl2ZUluZGljZXNCeVByaTEubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBydW5lQ291bnQgPSBiaW5hcnlTZWFyY2goYWN0aXZlSW5kaWNlc0J5UHJpMSwgcHJpMSwgY3VyQm91bmRzW3ByaTBdIC0gdG9sZXJhbmNlKSArIDE7XG4gICAgICAgICAgYWN0aXZlSW5kaWNlc0J5UHJpMS5zcGxpY2UoMCwgcHJ1bmVDb3VudCk7XG5cbiAgICAgICAgICBpZiAoc2VsZiAmJiBvbmx5U3dlZXBBeGlzQ29sbGlzaW9ucykge1xuICAgICAgICAgICAgY3VyQ29sbGlzaW9ucyA9IGN1ckNvbGxpc2lvbnMuY29uY2F0KGFjdGl2ZUluZGljZXNCeVByaTEpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFjdGl2ZUluZGljZXNCeVByaTEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gYWN0aXZlSW5kaWNlc0J5UHJpMVtqXTtcbiAgICAgICAgICAgICAgYWxsQ29sbGlzaW9uc1thY3RpdmVJbmRleF0ucHVzaChvcmlnSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY3VyU2VjMSA9IGN1ckJvdW5kc1tzZWMxXSxcbiAgICAgICAgICAgICAgICBjdXJTZWMwID0gY3VyQm91bmRzW3NlYzBdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFjdGl2ZUluZGljZXNCeVByaTEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gYWN0aXZlSW5kaWNlc0J5UHJpMVtqXSxcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUJvdW5kcyA9IGFsbEJvdW5kc1thY3RpdmVJbmRleF0sXG4gICAgICAgICAgICAgICAgICBpc0FjdGl2ZUEgPSBhY3RpdmVJbmRleCA8IGxlbmd0aEEsXG4gICAgICAgICAgICAgICAgICBpc0FjdGl2ZUIgPSBzZWxmIHx8IGFjdGl2ZUluZGV4ID49IGxlbmd0aEE7XG5cbiAgICAgICAgICAgICAgaWYgKG9ubHlTd2VlcEF4aXNDb2xsaXNpb25zIHx8IChpc0N1cnJlbnRBICYmIGlzQWN0aXZlQiB8fCBpc0N1cnJlbnRCICYmIGlzQWN0aXZlQSkgJiYgY3VyU2VjMSA+PSBhY3RpdmVCb3VuZHNbc2VjMF0gLSB0b2xlcmFuY2UgJiYgY3VyU2VjMCA8PSBhY3RpdmVCb3VuZHNbc2VjMV0gKyB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50QSAmJiBpc0FjdGl2ZUIpIHtcbiAgICAgICAgICAgICAgICAgIGN1ckNvbGxpc2lvbnMucHVzaChzZWxmID8gYWN0aXZlSW5kZXggOiBhY3RpdmVJbmRleCAtIGxlbmd0aEEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRCICYmIGlzQWN0aXZlQSkge1xuICAgICAgICAgICAgICAgICAgYWxsQ29sbGlzaW9uc1thY3RpdmVJbmRleF0ucHVzaChvcmlnSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0N1cnJlbnRBKSB7XG4gICAgICAgICAgaWYgKGJvdW5kc0EgPT09IGJvdW5kc0IpIHtcbiAgICAgICAgICAgIGN1ckNvbGxpc2lvbnMucHVzaChjdXJJbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWxsQ29sbGlzaW9uc1tjdXJJbmRleF0gPSBjdXJDb2xsaXNpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGl2ZUluZGljZXNCeVByaTEubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGN1clByaTEgPSBjdXJCb3VuZHNbcHJpMV0sXG4gICAgICAgICAgICAgIGluZGV4ID0gYmluYXJ5U2VhcmNoKGFjdGl2ZUluZGljZXNCeVByaTEsIHByaTEsIGN1clByaTEpO1xuICAgICAgICAgIGFjdGl2ZUluZGljZXNCeVByaTEuc3BsaWNlKGluZGV4ICsgMSwgMCwgY3VySW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjdGl2ZUluZGljZXNCeVByaTEucHVzaChjdXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxDb2xsaXNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xsaXNpb25zID0gYWxsQ29sbGlzaW9uc1tpXTtcblxuICAgICAgICBpZiAoY29sbGlzaW9ucykge1xuICAgICAgICAgIGNvbGxpc2lvbnMuc29ydChmdW5jdGlvbiAoaTEsIGkyKSB7XG4gICAgICAgICAgICByZXR1cm4gaTEgLSBpMjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsQ29sbGlzaW9ucztcbiAgICB9XG4gIH07XG4gIHZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHByZWNpc2lvbikge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSBCYXNlLnBpY2socHJlY2lzaW9uLCA1KTtcbiAgICAgIHRoaXMubXVsdGlwbGllciA9IE1hdGgucG93KDEwLCB0aGlzLnByZWNpc2lvbik7XG4gICAgfSxcbiAgICBudW1iZXI6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWNpc2lvbiA8IDE2ID8gTWF0aC5yb3VuZCh2YWwgKiB0aGlzLm11bHRpcGxpZXIpIC8gdGhpcy5tdWx0aXBsaWVyIDogdmFsO1xuICAgIH0sXG4gICAgcGFpcjogZnVuY3Rpb24gKHZhbDEsIHZhbDIsIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHRoaXMubnVtYmVyKHZhbDEpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsMik7XG4gICAgfSxcbiAgICBwb2ludDogZnVuY3Rpb24gKHZhbCwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXIodmFsLngpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsLnkpO1xuICAgIH0sXG4gICAgc2l6ZTogZnVuY3Rpb24gKHZhbCwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXIodmFsLndpZHRoKSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbC5oZWlnaHQpO1xuICAgIH0sXG4gICAgcmVjdGFuZ2xlOiBmdW5jdGlvbiAodmFsLCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvaW50KHZhbCwgc2VwYXJhdG9yKSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMuc2l6ZSh2YWwsIHNlcGFyYXRvcik7XG4gICAgfVxuICB9KTtcbiAgRm9ybWF0dGVyLmluc3RhbmNlID0gbmV3IEZvcm1hdHRlcigpO1xuICB2YXIgTnVtZXJpY2FsID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWJzY2lzc2FzID0gW1swLjU3NzM1MDI2OTE4OTYyNTc2NDUwOTE0ODhdLCBbMCwgMC43NzQ1OTY2NjkyNDE0ODMzNzcwMzU4NTMxXSwgWzAuMzM5OTgxMDQzNTg0ODU2MjY0ODAyNjY1OCwgMC44NjExMzYzMTE1OTQwNTI1NzUyMjM5NDY1XSwgWzAsIDAuNTM4NDY5MzEwMTA1NjgzMDkxMDM2MzE0NCwgMC45MDYxNzk4NDU5Mzg2NjM5OTI3OTc2MjY5XSwgWzAuMjM4NjE5MTg2MDgzMTk2OTA4NjMwNTAxNywgMC42NjEyMDkzODY0NjYyNjQ1MTM2NjEzOTk2LCAwLjkzMjQ2OTUxNDIwMzE1MjAyNzgxMjMwMTZdLCBbMCwgMC40MDU4NDUxNTEzNzczOTcxNjY5MDY2MDY0LCAwLjc0MTUzMTE4NTU5OTM5NDQzOTg2Mzg2NDgsIDAuOTQ5MTA3OTEyMzQyNzU4NTI0NTI2MTg5N10sIFswLjE4MzQzNDY0MjQ5NTY0OTgwNDkzOTQ3NjEsIDAuNTI1NTMyNDA5OTE2MzI4OTg1ODE3NzM5MCwgMC43OTY2NjY0Nzc0MTM2MjY3Mzk1OTE1NTM5LCAwLjk2MDI4OTg1NjQ5NzUzNjIzMTY4MzU2MDldLCBbMCwgMC4zMjQyNTM0MjM0MDM4MDg5MjkwMzg1MzgwLCAwLjYxMzM3MTQzMjcwMDU5MDM5NzMwODcwMjAsIDAuODM2MDMxMTA3MzI2NjM1Nzk0Mjk5NDI5OCwgMC45NjgxNjAyMzk1MDc2MjYwODk4MzU1NzYyXSwgWzAuMTQ4ODc0MzM4OTgxNjMxMjEwODg0ODI2MCwgMC40MzMzOTUzOTQxMjkyNDcxOTA3OTkyNjU5LCAwLjY3OTQwOTU2ODI5OTAyNDQwNjIzNDMyNzQsIDAuODY1MDYzMzY2Njg4OTg0NTEwNzMyMDk2NywgMC45NzM5MDY1Mjg1MTcxNzE3MjAwNzc5NjQwXSwgWzAsIDAuMjY5NTQzMTU1OTUyMzQ0OTcyMzMxNTMyMCwgMC41MTkwOTYxMjkyMDY4MTE4MTU5MjU3MjU3LCAwLjczMDE1MjAwNTU3NDA0OTMyNDA5MzQxNjMsIDAuODg3MDYyNTk5NzY4MDk1Mjk5MDc1MTU3OCwgMC45NzgyMjg2NTgxNDYwNTY5OTI4MDM5MzgwXSwgWzAuMTI1MjMzNDA4NTExNDY4OTE1NDcyNDQxNCwgMC4zNjc4MzE0OTg5OTgxODAxOTM3NTI2OTE1LCAwLjU4NzMxNzk1NDI4NjYxNzQ0NzI5NjcwMjQsIDAuNzY5OTAyNjc0MTk0MzA0Njg3MDM2ODkzOCwgMC45MDQxMTcyNTYzNzA0NzQ4NTY2Nzg0NjU5LCAwLjk4MTU2MDYzNDI0NjcxOTI1MDY5MDU0OTFdLCBbMCwgMC4yMzA0NTgzMTU5NTUxMzQ3OTQwNjU1MjgxLCAwLjQ0ODQ5Mjc1MTAzNjQ0Njg1Mjg3NzkxMjksIDAuNjQyMzQ5MzM5NDQwMzQwMjIwNjQzOTg0NiwgMC44MDE1NzgwOTA3MzMzMDk5MTI3OTQyMDY1LCAwLjkxNzU5ODM5OTIyMjk3Nzk2NTIwNjU0NzgsIDAuOTg0MTgzMDU0NzE4NTg4MTQ5NDcyODI5NF0sIFswLjEwODA1NDk0ODcwNzM0MzY2MjA2NjI0NDcsIDAuMzE5MTEyMzY4OTI3ODg5NzYwNDM1NjcxOCwgMC41MTUyNDg2MzYzNTgxNTQwOTE5NjUyOTA3LCAwLjY4NzI5MjkwNDgxMTY4NTQ3MDE0ODAxOTgsIDAuODI3MjAxMzE1MDY5NzY0OTkzMTg5Nzk0NywgMC45Mjg0MzQ4ODM2NjM1NzM1MTczMzYzOTExLCAwLjk4NjI4MzgwODY5NjgxMjMzODg0MTU5NzNdLCBbMCwgMC4yMDExOTQwOTM5OTc0MzQ1MjIzMDA2MjgzLCAwLjM5NDE1MTM0NzA3NzU2MzM2OTg5NzIwNzQsIDAuNTcwOTcyMTcyNjA4NTM4ODQ3NTM3MjI2NywgMC43MjQ0MTc3MzEzNjAxNzAwNDc0MTYxODYxLCAwLjg0ODIwNjU4MzQxMDQyNzIxNjIwMDY0ODMsIDAuOTM3MjczMzkyNDAwNzA1OTA0MzA3NzU4OSwgMC45ODc5OTI1MTgwMjA0ODU0Mjg0ODk1NjU3XSwgWzAuMDk1MDEyNTA5ODM3NjM3NDQwMTg1MzE5MywgMC4yODE2MDM1NTA3NzkyNTg5MTMyMzA0NjA1LCAwLjQ1ODAxNjc3NzY1NzIyNzM4NjM0MjQxOTQsIDAuNjE3ODc2MjQ0NDAyNjQzNzQ4NDQ2NjcxOCwgMC43NTU0MDQ0MDgzNTUwMDMwMzM4OTUxMDEyLCAwLjg2NTYzMTIwMjM4NzgzMTc0Mzg4MDQ2NzksIDAuOTQ0NTc1MDIzMDczMjMyNTc2MDc3OTg4NCwgMC45ODk0MDA5MzQ5OTE2NDk5MzI1OTYxNTQyXV07XG4gICAgdmFyIHdlaWdodHMgPSBbWzFdLCBbMC44ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LCAwLjU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTZdLCBbMC42NTIxNDUxNTQ4NjI1NDYxNDI2MjY5MzYxLCAwLjM0Nzg1NDg0NTEzNzQ1Mzg1NzM3MzA2MzldLCBbMC41Njg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LCAwLjQ3ODYyODY3MDQ5OTM2NjQ2ODA0MTI5MTUsIDAuMjM2OTI2ODg1MDU2MTg5MDg3NTE0MjY0MF0sIFswLjQ2NzkxMzkzNDU3MjY5MTA0NzM4OTg3MDMsIDAuMzYwNzYxNTczMDQ4MTM4NjA3NTY5ODMzNSwgMC4xNzEzMjQ0OTIzNzkxNzAzNDUwNDAyOTYxXSwgWzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwgMC4zODE4MzAwNTA1MDUxMTg5NDQ5NTAzNjk4LCAwLjI3OTcwNTM5MTQ4OTI3NjY2NzkwMTQ2NzgsIDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sIFswLjM2MjY4Mzc4MzM3ODM2MTk4Mjk2NTE1MDQsIDAuMzEzNzA2NjQ1ODc3ODg3Mjg3MzM3OTYyMiwgMC4yMjIzODEwMzQ0NTMzNzQ0NzA1NDQzNTYwLCAwLjEwMTIyODUzNjI5MDM3NjI1OTE1MjUzMTRdLCBbMC4zMzAyMzkzNTUwMDEyNTk3NjMxNjQ1MjUxLCAwLjMxMjM0NzA3NzA0MDAwMjg0MDA2ODYzMDQsIDAuMjYwNjEwNjk2NDAyOTM1NDYyMzE4NzQyOSwgMC4xODA2NDgxNjA2OTQ4NTc0MDQwNTg0NzIwLCAwLjA4MTI3NDM4ODM2MTU3NDQxMTk3MTg5MjJdLCBbMC4yOTU1MjQyMjQ3MTQ3NTI4NzAxNzM4OTMwLCAwLjI2OTI2NjcxOTMwOTk5NjM1NTA5MTIyNjksIDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwgMC4xNDk0NTEzNDkxNTA1ODA1OTMxNDU3NzYzLCAwLjA2NjY3MTM0NDMwODY4ODEzNzU5MzU2ODhdLCBbMC4yNzI5MjUwODY3Nzc5MDA2MzA3MTQ0ODM1LCAwLjI2MjgwNDU0NDUxMDI0NjY2MjE4MDY4ODksIDAuMjMzMTkzNzY0NTkxOTkwNDc5OTE4NTIzNywgMC4xODYyOTAyMTA5Mjc3MzQyNTE0MjYwOTc2LCAwLjEyNTU4MDM2OTQ2NDkwNDYyNDYzNDY5NDMsIDAuMDU1NjY4NTY3MTE2MTczNjY2NDgyNzUzN10sIFswLjI0OTE0NzA0NTgxMzQwMjc4NTAwMDU2MjQsIDAuMjMzNDkyNTM2NTM4MzU0ODA4NzYwODQ5OSwgMC4yMDMxNjc0MjY3MjMwNjU5MjE3NDkwNjQ1LCAwLjE2MDA3ODMyODU0MzM0NjIyNjMzNDY1MjUsIDAuMTA2OTM5MzI1OTk1MzE4NDMwOTYwMjU0NywgMC4wNDcxNzUzMzYzODY1MTE4MjcxOTQ2MTYwXSwgWzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwgMC4yMjYyODMxODAyNjI4OTcyMzg0MTIwOTAyLCAwLjIwNzgxNjA0NzUzNjg4ODUwMjMxMjUyMzIsIDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywgMC4xMzg4NzM1MTAyMTk3ODcyMzg0NjM2MDE4LCAwLjA5MjEyMTQ5OTgzNzcyODQ0NzkxNDQyMTgsIDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sIFswLjIxNTI2Mzg1MzQ2MzE1Nzc5MDE5NTg3NjQsIDAuMjA1MTk4NDYzNzIxMjk1NjAzOTY1OTI0MSwgMC4xODU1MzgzOTc0Nzc5Mzc4MTM3NDE3MTY2LCAwLjE1NzIwMzE2NzE1ODE5MzUzNDU2OTYwMTksIDAuMTIxNTE4NTcwNjg3OTAzMTg0Njg5NDE0OCwgMC4wODAxNTgwODcxNTk3NjAyMDk4MDU2MzMzLCAwLjAzNTExOTQ2MDMzMTc1MTg2MzAzMTgzMjldLCBbMC4yMDI1NzgyNDE5MjU1NjEyNzI4ODA2MjAyLCAwLjE5ODQzMTQ4NTMyNzExMTU3NjQ1NjExODMsIDAuMTg2MTYxMDAwMDE1NTYyMjExMDI2ODAwNiwgMC4xNjYyNjkyMDU4MTY5OTM5MzM1NTMyMDA5LCAwLjEzOTU3MDY3NzkyNjE1NDMxNDQ0NzgwNDgsIDAuMTA3MTU5MjIwNDY3MTcxOTM1MDExODY5NSwgMC4wNzAzNjYwNDc0ODgxMDgxMjQ3MDkyNjc0LCAwLjAzMDc1MzI0MTk5NjExNzI2ODM1NDYyODRdLCBbMC4xODk0NTA2MTA0NTUwNjg0OTYyODUzOTY3LCAwLjE4MjYwMzQxNTA0NDkyMzU4ODg2Njc2MzcsIDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwgMC4xNDk1OTU5ODg4MTY1NzY3MzIwODE1MDE3LCAwLjEyNDYyODk3MTI1NTUzMzg3MjA1MjQ3NjMsIDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwgMC4wNjIyNTM1MjM5Mzg2NDc4OTI4NjI4NDM4LCAwLjAyNzE1MjQ1OTQxMTc1NDA5NDg1MTc4MDZdXTtcblxuICAgIHZhciBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgc3FydCA9IE1hdGguc3FydCxcbiAgICAgICAgcG93ID0gTWF0aC5wb3csXG4gICAgICAgIGxvZzIgPSBNYXRoLmxvZzIgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMkU7XG4gICAgfSxcbiAgICAgICAgRVBTSUxPTiA9IDFlLTEyLFxuICAgICAgICBNQUNISU5FX0VQU0lMT04gPSAxLjEyZS0xNjtcblxuICAgIGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREaXNjcmltaW5hbnQoYSwgYiwgYykge1xuICAgICAgZnVuY3Rpb24gc3BsaXQodikge1xuICAgICAgICB2YXIgeCA9IHYgKiAxMzQyMTc3MjksXG4gICAgICAgICAgICB5ID0gdiAtIHgsXG4gICAgICAgICAgICBoaSA9IHkgKyB4LFxuICAgICAgICAgICAgbG8gPSB2IC0gaGk7XG4gICAgICAgIHJldHVybiBbaGksIGxvXTtcbiAgICAgIH1cblxuICAgICAgdmFyIEQgPSBiICogYiAtIGEgKiBjLFxuICAgICAgICAgIEUgPSBiICogYiArIGEgKiBjO1xuXG4gICAgICBpZiAoYWJzKEQpICogMyA8IEUpIHtcbiAgICAgICAgdmFyIGFkID0gc3BsaXQoYSksXG4gICAgICAgICAgICBiZCA9IHNwbGl0KGIpLFxuICAgICAgICAgICAgY2QgPSBzcGxpdChjKSxcbiAgICAgICAgICAgIHAgPSBiICogYixcbiAgICAgICAgICAgIGRwID0gYmRbMF0gKiBiZFswXSAtIHAgKyAyICogYmRbMF0gKiBiZFsxXSArIGJkWzFdICogYmRbMV0sXG4gICAgICAgICAgICBxID0gYSAqIGMsXG4gICAgICAgICAgICBkcSA9IGFkWzBdICogY2RbMF0gLSBxICsgYWRbMF0gKiBjZFsxXSArIGFkWzFdICogY2RbMF0gKyBhZFsxXSAqIGNkWzFdO1xuICAgICAgICBEID0gcCAtIHEgKyAoZHAgLSBkcSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25GYWN0b3IoKSB7XG4gICAgICB2YXIgbm9ybSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbm9ybSAmJiAobm9ybSA8IDFlLTggfHwgbm9ybSA+IDFlOCkgPyBwb3coMiwgLU1hdGgucm91bmQobG9nMihub3JtKSkpIDogMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgRVBTSUxPTjogRVBTSUxPTixcbiAgICAgIE1BQ0hJTkVfRVBTSUxPTjogTUFDSElORV9FUFNJTE9OLFxuICAgICAgQ1VSVkVUSU1FX0VQU0lMT046IDFlLTgsXG4gICAgICBHRU9NRVRSSUNfRVBTSUxPTjogMWUtNyxcbiAgICAgIFRSSUdPTk9NRVRSSUNfRVBTSUxPTjogMWUtOCxcbiAgICAgIEtBUFBBOiA0ICogKHNxcnQoMikgLSAxKSAvIDMsXG4gICAgICBpc1plcm86IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSAtRVBTSUxPTiAmJiB2YWwgPD0gRVBTSUxPTjtcbiAgICAgIH0sXG4gICAgICBpc01hY2hpbmVaZXJvOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPj0gLU1BQ0hJTkVfRVBTSUxPTiAmJiB2YWwgPD0gTUFDSElORV9FUFNJTE9OO1xuICAgICAgfSxcbiAgICAgIGNsYW1wOiBjbGFtcCxcbiAgICAgIGludGVncmF0ZTogZnVuY3Rpb24gKGYsIGEsIGIsIG4pIHtcbiAgICAgICAgdmFyIHggPSBhYnNjaXNzYXNbbiAtIDJdLFxuICAgICAgICAgICAgdyA9IHdlaWdodHNbbiAtIDJdLFxuICAgICAgICAgICAgQSA9IChiIC0gYSkgKiAwLjUsXG4gICAgICAgICAgICBCID0gQSArIGEsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIG0gPSBuICsgMSA+PiAxLFxuICAgICAgICAgICAgc3VtID0gbiAmIDEgPyB3W2krK10gKiBmKEIpIDogMDtcblxuICAgICAgICB3aGlsZSAoaSA8IG0pIHtcbiAgICAgICAgICB2YXIgQXggPSBBICogeFtpXTtcbiAgICAgICAgICBzdW0gKz0gd1tpKytdICogKGYoQiArIEF4KSArIGYoQiAtIEF4KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQSAqIHN1bTtcbiAgICAgIH0sXG4gICAgICBmaW5kUm9vdDogZnVuY3Rpb24gKGYsIGRmLCB4LCBhLCBiLCBuLCB0b2xlcmFuY2UpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICB2YXIgZnggPSBmKHgpLFxuICAgICAgICAgICAgICBkeCA9IGZ4IC8gZGYoeCksXG4gICAgICAgICAgICAgIG54ID0geCAtIGR4O1xuXG4gICAgICAgICAgaWYgKGFicyhkeCkgPCB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHggPSBueDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmeCA+IDApIHtcbiAgICAgICAgICAgIGIgPSB4O1xuICAgICAgICAgICAgeCA9IG54IDw9IGEgPyAoYSArIGIpICogMC41IDogbng7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGEgPSB4O1xuICAgICAgICAgICAgeCA9IG54ID49IGIgPyAoYSArIGIpICogMC41IDogbng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsYW1wKHgsIGEsIGIpO1xuICAgICAgfSxcbiAgICAgIHNvbHZlUXVhZHJhdGljOiBmdW5jdGlvbiAoYSwgYiwgYywgcm9vdHMsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciB4MSxcbiAgICAgICAgICAgIHgyID0gSW5maW5pdHk7XG5cbiAgICAgICAgaWYgKGFicyhhKSA8IEVQU0lMT04pIHtcbiAgICAgICAgICBpZiAoYWJzKGIpIDwgRVBTSUxPTikgcmV0dXJuIGFicyhjKSA8IEVQU0lMT04gPyAtMSA6IDA7XG4gICAgICAgICAgeDEgPSAtYyAvIGI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYiAqPSAtMC41O1xuICAgICAgICAgIHZhciBEID0gZ2V0RGlzY3JpbWluYW50KGEsIGIsIGMpO1xuXG4gICAgICAgICAgaWYgKEQgJiYgYWJzKEQpIDwgTUFDSElORV9FUFNJTE9OKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGdldE5vcm1hbGl6YXRpb25GYWN0b3IoYWJzKGEpLCBhYnMoYiksIGFicyhjKSk7XG5cbiAgICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICAgIGEgKj0gZjtcbiAgICAgICAgICAgICAgYiAqPSBmO1xuICAgICAgICAgICAgICBjICo9IGY7XG4gICAgICAgICAgICAgIEQgPSBnZXREaXNjcmltaW5hbnQoYSwgYiwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEQgPj0gLU1BQ0hJTkVfRVBTSUxPTikge1xuICAgICAgICAgICAgdmFyIFEgPSBEIDwgMCA/IDAgOiBzcXJ0KEQpLFxuICAgICAgICAgICAgICAgIFIgPSBiICsgKGIgPCAwID8gLVEgOiBRKTtcblxuICAgICAgICAgICAgaWYgKFIgPT09IDApIHtcbiAgICAgICAgICAgICAgeDEgPSBjIC8gYTtcbiAgICAgICAgICAgICAgeDIgPSAteDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB4MSA9IFIgLyBhO1xuICAgICAgICAgICAgICB4MiA9IGMgLyBSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgICBib3VuZGxlc3MgPSBtaW4gPT0gbnVsbCxcbiAgICAgICAgICAgIG1pbkIgPSBtaW4gLSBFUFNJTE9OLFxuICAgICAgICAgICAgbWF4QiA9IG1heCArIEVQU0lMT047XG4gICAgICAgIGlmIChpc0Zpbml0ZSh4MSkgJiYgKGJvdW5kbGVzcyB8fCB4MSA+IG1pbkIgJiYgeDEgPCBtYXhCKSkgcm9vdHNbY291bnQrK10gPSBib3VuZGxlc3MgPyB4MSA6IGNsYW1wKHgxLCBtaW4sIG1heCk7XG4gICAgICAgIGlmICh4MiAhPT0geDEgJiYgaXNGaW5pdGUoeDIpICYmIChib3VuZGxlc3MgfHwgeDIgPiBtaW5CICYmIHgyIDwgbWF4QikpIHJvb3RzW2NvdW50KytdID0gYm91bmRsZXNzID8geDIgOiBjbGFtcCh4MiwgbWluLCBtYXgpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9LFxuICAgICAgc29sdmVDdWJpYzogZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHJvb3RzLCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgZiA9IGdldE5vcm1hbGl6YXRpb25GYWN0b3IoYWJzKGEpLCBhYnMoYiksIGFicyhjKSwgYWJzKGQpKSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBiMSxcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgcWQsXG4gICAgICAgICAgICBxO1xuXG4gICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgYSAqPSBmO1xuICAgICAgICAgIGIgKj0gZjtcbiAgICAgICAgICBjICo9IGY7XG4gICAgICAgICAgZCAqPSBmO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXZhbHVhdGUoeDApIHtcbiAgICAgICAgICB4ID0geDA7XG4gICAgICAgICAgdmFyIHRtcCA9IGEgKiB4O1xuICAgICAgICAgIGIxID0gdG1wICsgYjtcbiAgICAgICAgICBjMiA9IGIxICogeCArIGM7XG4gICAgICAgICAgcWQgPSAodG1wICsgYjEpICogeCArIGMyO1xuICAgICAgICAgIHEgPSBjMiAqIHggKyBkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFicyhhKSA8IEVQU0lMT04pIHtcbiAgICAgICAgICBhID0gYjtcbiAgICAgICAgICBiMSA9IGM7XG4gICAgICAgICAgYzIgPSBkO1xuICAgICAgICAgIHggPSBJbmZpbml0eTtcbiAgICAgICAgfSBlbHNlIGlmIChhYnMoZCkgPCBFUFNJTE9OKSB7XG4gICAgICAgICAgYjEgPSBiO1xuICAgICAgICAgIGMyID0gYztcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmFsdWF0ZSgtKGIgLyBhKSAvIDMpO1xuICAgICAgICAgIHZhciB0ID0gcSAvIGEsXG4gICAgICAgICAgICAgIHIgPSBwb3coYWJzKHQpLCAxIC8gMyksXG4gICAgICAgICAgICAgIHMgPSB0IDwgMCA/IC0xIDogMSxcbiAgICAgICAgICAgICAgdGQgPSAtcWQgLyBhLFxuICAgICAgICAgICAgICByZCA9IHRkID4gMCA/IDEuMzI0NzE3OTU3MjQ0NzQ2ICogTWF0aC5tYXgociwgc3FydCh0ZCkpIDogcixcbiAgICAgICAgICAgICAgeDAgPSB4IC0gcyAqIHJkO1xuXG4gICAgICAgICAgaWYgKHgwICE9PSB4KSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGV2YWx1YXRlKHgwKTtcbiAgICAgICAgICAgICAgeDAgPSBxZCA9PT0gMCA/IHggOiB4IC0gcSAvIHFkIC8gKDEgKyBNQUNISU5FX0VQU0lMT04pO1xuICAgICAgICAgICAgfSB3aGlsZSAocyAqIHgwID4gcyAqIHgpO1xuXG4gICAgICAgICAgICBpZiAoYWJzKGEpICogeCAqIHggPiBhYnMoZCAvIHgpKSB7XG4gICAgICAgICAgICAgIGMyID0gLWQgLyB4O1xuICAgICAgICAgICAgICBiMSA9IChjMiAtIGMpIC8geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY291bnQgPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYjEsIGMyLCByb290cywgbWluLCBtYXgpLFxuICAgICAgICAgICAgYm91bmRsZXNzID0gbWluID09IG51bGw7XG4gICAgICAgIGlmIChpc0Zpbml0ZSh4KSAmJiAoY291bnQgPT09IDAgfHwgY291bnQgPiAwICYmIHggIT09IHJvb3RzWzBdICYmIHggIT09IHJvb3RzWzFdKSAmJiAoYm91bmRsZXNzIHx8IHggPiBtaW4gLSBFUFNJTE9OICYmIHggPCBtYXggKyBFUFNJTE9OKSkgcm9vdHNbY291bnQrK10gPSBib3VuZGxlc3MgPyB4IDogY2xhbXAoeCwgbWluLCBtYXgpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuICB2YXIgVUlEID0ge1xuICAgIF9pZDogMSxcbiAgICBfcG9vbHM6IHt9LFxuICAgIGdldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhciBwb29sID0gdGhpcy5fcG9vbHNbbmFtZV07XG4gICAgICAgIGlmICghcG9vbCkgcG9vbCA9IHRoaXMuX3Bvb2xzW25hbWVdID0ge1xuICAgICAgICAgIF9pZDogMVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcG9vbC5faWQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZCsrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIFBvaW50ID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1BvaW50JyxcbiAgICBfcmVhZEluZGV4OiB0cnVlLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KGFyZzAsIGFyZzEpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGFyZzAsXG4gICAgICAgICAgcmVhZGluZyA9IHRoaXMuX19yZWFkLFxuICAgICAgICAgIHJlYWQgPSAwO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGhhc1kgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cbiAgICAgICAgdGhpcy5fc2V0KGFyZzAsIGhhc1kgPyBhcmcxIDogYXJnMCk7XG5cbiAgICAgICAgaWYgKHJlYWRpbmcpIHJlYWQgPSBoYXNZID8gMiA6IDE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2V0KDAsIDApO1xuXG4gICAgICAgIGlmIChyZWFkaW5nKSByZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9iaiA9IHR5cGUgPT09ICdzdHJpbmcnID8gYXJnMC5zcGxpdCgvW1xccyxdKy8pIHx8IFtdIDogYXJnMDtcbiAgICAgICAgcmVhZCA9IDE7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgIHRoaXMuX3NldCgrb2JqWzBdLCArKG9iai5sZW5ndGggPiAxID8gb2JqWzFdIDogb2JqWzBdKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ3gnIGluIG9iaikge1xuICAgICAgICAgIHRoaXMuX3NldChvYmoueCB8fCAwLCBvYmoueSB8fCAwKTtcbiAgICAgICAgfSBlbHNlIGlmICgnd2lkdGgnIGluIG9iaikge1xuICAgICAgICAgIHRoaXMuX3NldChvYmoud2lkdGggfHwgMCwgb2JqLmhlaWdodCB8fCAwKTtcbiAgICAgICAgfSBlbHNlIGlmICgnYW5nbGUnIGluIG9iaikge1xuICAgICAgICAgIHRoaXMuX3NldChvYmoubGVuZ3RoIHx8IDAsIDApO1xuXG4gICAgICAgICAgdGhpcy5zZXRBbmdsZShvYmouYW5nbGUgfHwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0KDAsIDApO1xuXG4gICAgICAgICAgcmVhZCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWRpbmcpIHRoaXMuX19yZWFkID0gcmVhZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0OiAnI2luaXRpYWxpemUnLFxuICAgIF9zZXQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBwb2ludCB8fCBwb2ludCAmJiAodGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueSB8fCBBcnJheS5pc0FycmF5KHBvaW50KSAmJiB0aGlzLnggPT09IHBvaW50WzBdICYmIHRoaXMueSA9PT0gcG9pbnRbMV0pIHx8IGZhbHNlO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuICAgICAgcmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpICsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSkgKyAnIH0nO1xuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG4gICAgICByZXR1cm4gW2YubnVtYmVyKHRoaXMueCksIGYubnVtYmVyKHRoaXMueSldO1xuICAgIH0sXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICAgfSxcbiAgICBzZXRMZW5ndGg6IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIHZhciBhbmdsZSA9IHRoaXMuX2FuZ2xlIHx8IDA7XG5cbiAgICAgICAgdGhpcy5fc2V0KE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCwgTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzY2FsZSA9IGxlbmd0aCAvIHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIGlmIChOdW1lcmljYWwuaXNaZXJvKHNjYWxlKSkgdGhpcy5nZXRBbmdsZSgpO1xuXG4gICAgICAgIHRoaXMuX3NldCh0aGlzLnggKiBzY2FsZSwgdGhpcy55ICogc2NhbGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0QW5nbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEFuZ2xlSW5SYWRpYW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiAxODAgLyBNYXRoLlBJO1xuICAgIH0sXG4gICAgc2V0QW5nbGU6IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgdGhpcy5zZXRBbmdsZUluUmFkaWFucy5jYWxsKHRoaXMsIGFuZ2xlICogTWF0aC5QSSAvIDE4MCk7XG4gICAgfSxcbiAgICBnZXRBbmdsZUluRGVncmVlczogJyNnZXRBbmdsZScsXG4gICAgc2V0QW5nbGVJbkRlZ3JlZXM6ICcjc2V0QW5nbGUnLFxuICAgIGdldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNaZXJvKCkgPyB0aGlzLl9hbmdsZSB8fCAwIDogdGhpcy5fYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGRpdiA9IHRoaXMuZ2V0TGVuZ3RoKCkgKiBwb2ludC5nZXRMZW5ndGgoKTtcblxuICAgICAgICBpZiAoTnVtZXJpY2FsLmlzWmVybyhkaXYpKSB7XG4gICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuZG90KHBvaW50KSAvIGRpdjtcbiAgICAgICAgICByZXR1cm4gTWF0aC5hY29zKGEgPCAtMSA/IC0xIDogYSA+IDEgPyAxIDogYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgIHRoaXMuX2FuZ2xlID0gYW5nbGU7XG5cbiAgICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcblxuICAgICAgICB0aGlzLl9zZXQoTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLCBNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UXVhZHJhbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggPj0gMCA/IHRoaXMueSA+PSAwID8gMSA6IDQgOiB0aGlzLnkgPj0gMCA/IDIgOiAzO1xuICAgIH1cbiAgfSwge1xuICAgIGJlYW5zOiBmYWxzZSxcbiAgICBnZXREaXJlY3RlZEFuZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLmNyb3NzKHBvaW50KSwgdGhpcy5kb3QocG9pbnQpKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgfSxcbiAgICBnZXREaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgIHggPSBwb2ludC54IC0gdGhpcy54LFxuICAgICAgICAgIHkgPSBwb2ludC55IC0gdGhpcy55LFxuICAgICAgICAgIGQgPSB4ICogeCArIHkgKiB5LFxuICAgICAgICAgIHNxdWFyZWQgPSBCYXNlLnJlYWQoYXJncyk7XG4gICAgICByZXR1cm4gc3F1YXJlZCA/IGQgOiBNYXRoLnNxcnQoZCk7XG4gICAgfSxcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgbGVuZ3RoID0gMTtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRMZW5ndGgoKSxcbiAgICAgICAgICBzY2FsZSA9IGN1cnJlbnQgIT09IDAgPyBsZW5ndGggLyBjdXJyZW50IDogMCxcbiAgICAgICAgICBwb2ludCA9IG5ldyBQb2ludCh0aGlzLnggKiBzY2FsZSwgdGhpcy55ICogc2NhbGUpO1xuICAgICAgaWYgKHNjYWxlID49IDApIHBvaW50Ll9hbmdsZSA9IHRoaXMuX2FuZ2xlO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0sXG4gICAgcm90YXRlOiBmdW5jdGlvbiAoYW5nbGUsIGNlbnRlcikge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgICAgYW5nbGUgPSBhbmdsZSAqIE1hdGguUEkgLyAxODA7XG4gICAgICB2YXIgcG9pbnQgPSBjZW50ZXIgPyB0aGlzLnN1YnRyYWN0KGNlbnRlcikgOiB0aGlzLFxuICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICBwb2ludCA9IG5ldyBQb2ludChwb2ludC54ICogY29zIC0gcG9pbnQueSAqIHNpbiwgcG9pbnQueCAqIHNpbiArIHBvaW50LnkgKiBjb3MpO1xuICAgICAgcmV0dXJuIGNlbnRlciA/IHBvaW50LmFkZChjZW50ZXIpIDogcG9pbnQ7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgIHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHRoaXMpIDogdGhpcztcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwb2ludC54LCB0aGlzLnkgKyBwb2ludC55KTtcbiAgICB9LFxuICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHBvaW50LngsIHRoaXMueSAtIHBvaW50LnkpO1xuICAgIH0sXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XG4gICAgfSxcbiAgICBkaXZpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XG4gICAgfSxcbiAgICBtb2R1bG86IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICUgcG9pbnQueCwgdGhpcy55ICUgcG9pbnQueSk7XG4gICAgfSxcbiAgICBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoLXRoaXMueCwgLXRoaXMueSk7XG4gICAgfSxcbiAgICBpc0luc2lkZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykuY29udGFpbnModGhpcyk7XG4gICAgfSxcbiAgICBpc0Nsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBwb2ludCA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgdG9sZXJhbmNlID0gQmFzZS5yZWFkKGFyZ3MpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UocG9pbnQpIDw9IHRvbGVyYW5jZTtcbiAgICB9LFxuICAgIGlzQ29sbGluZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gUG9pbnQuaXNDb2xsaW5lYXIodGhpcy54LCB0aGlzLnksIHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG4gICAgaXNDb2xpbmVhcjogJyNpc0NvbGxpbmVhcicsXG4gICAgaXNPcnRob2dvbmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gUG9pbnQuaXNPcnRob2dvbmFsKHRoaXMueCwgdGhpcy55LCBwb2ludC54LCBwb2ludC55KTtcbiAgICB9LFxuICAgIGlzWmVybzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG4gICAgICByZXR1cm4gaXNaZXJvKHRoaXMueCkgJiYgaXNaZXJvKHRoaXMueSk7XG4gICAgfSxcbiAgICBpc05hTjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlzTmFOKHRoaXMueCkgfHwgaXNOYU4odGhpcy55KTtcbiAgICB9LFxuICAgIGlzSW5RdWFkcmFudDogZnVuY3Rpb24gKHEpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKiAocSA+IDEgJiYgcSA8IDQgPyAtMSA6IDEpID49IDAgJiYgdGhpcy55ICogKHEgPiAyID8gLTEgOiAxKSA+PSAwO1xuICAgIH0sXG4gICAgZG90OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy54ICogcG9pbnQueCArIHRoaXMueSAqIHBvaW50Lnk7XG4gICAgfSxcbiAgICBjcm9zczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMueCAqIHBvaW50LnkgLSB0aGlzLnkgKiBwb2ludC54O1xuICAgIH0sXG4gICAgcHJvamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIHNjYWxlID0gcG9pbnQuaXNaZXJvKCkgPyAwIDogdGhpcy5kb3QocG9pbnQpIC8gcG9pbnQuZG90KHBvaW50KTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQueCAqIHNjYWxlLCBwb2ludC55ICogc2NhbGUpO1xuICAgIH0sXG4gICAgc3RhdGljczoge1xuICAgICAgbWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgcG9pbnQxID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHBvaW50MiA9IFBvaW50LnJlYWQoYXJncyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5taW4ocG9pbnQxLngsIHBvaW50Mi54KSwgTWF0aC5taW4ocG9pbnQxLnksIHBvaW50Mi55KSk7XG4gICAgICB9LFxuICAgICAgbWF4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgcG9pbnQxID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHBvaW50MiA9IFBvaW50LnJlYWQoYXJncyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5tYXgocG9pbnQxLngsIHBvaW50Mi54KSwgTWF0aC5tYXgocG9pbnQxLnksIHBvaW50Mi55KSk7XG4gICAgICB9LFxuICAgICAgcmFuZG9tOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG4gICAgICB9LFxuICAgICAgaXNDb2xsaW5lYXI6IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoeDEgKiB5MiAtIHkxICogeDIpIDw9IE1hdGguc3FydCgoeDEgKiB4MSArIHkxICogeTEpICogKHgyICogeDIgKyB5MiAqIHkyKSkgKiAxZS04O1xuICAgICAgfSxcbiAgICAgIGlzT3J0aG9nb25hbDogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh4MSAqIHgyICsgeTEgKiB5MikgPD0gTWF0aC5zcXJ0KCh4MSAqIHgxICsgeTEgKiB5MSkgKiAoeDIgKiB4MiArIHkyICogeTIpKSAqIDFlLTg7XG4gICAgICB9XG4gICAgfVxuICB9LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIG9wID0gTWF0aFtrZXldO1xuXG4gICAgdGhpc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChvcCh0aGlzLngpLCBvcCh0aGlzLnkpKTtcbiAgICB9O1xuICB9LCB7fSkpO1xuICB2YXIgTGlua2VkUG9pbnQgPSBQb2ludC5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KHgsIHksIG93bmVyLCBzZXR0ZXIpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLl9vd25lciA9IG93bmVyO1xuICAgICAgdGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuICAgIH0sXG4gICAgX3NldDogZnVuY3Rpb24gKHgsIHksIF9kb250Tm90aWZ5KSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgaWYgKCFfZG9udE5vdGlmeSkgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0WDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfSxcbiAgICBzZXRYOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5feCA9IHg7XG5cbiAgICAgIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgfSxcbiAgICBnZXRZOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9LFxuICAgIHNldFk6IGZ1bmN0aW9uICh5KSB7XG4gICAgICB0aGlzLl95ID0geTtcblxuICAgICAgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICB9LFxuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLl9vd25lci5fc2VsZWN0aW9uICYgdGhpcy5fZ2V0U2VsZWN0aW9uKCkpO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgdGhpcy5fb3duZXIuX2NoYW5nZVNlbGVjdGlvbih0aGlzLl9nZXRTZWxlY3Rpb24oKSwgc2VsZWN0ZWQpO1xuICAgIH0sXG4gICAgX2dldFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldHRlciA9PT0gJ3NldFBvc2l0aW9uJyA/IDQgOiAwO1xuICAgIH1cbiAgfSk7XG4gIHZhciBTaXplID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1NpemUnLFxuICAgIF9yZWFkSW5kZXg6IHRydWUsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZShhcmcwLCBhcmcxKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhcmcwLFxuICAgICAgICAgIHJlYWRpbmcgPSB0aGlzLl9fcmVhZCxcbiAgICAgICAgICByZWFkID0gMDtcblxuICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBoYXNIZWlnaHQgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cbiAgICAgICAgdGhpcy5fc2V0KGFyZzAsIGhhc0hlaWdodCA/IGFyZzEgOiBhcmcwKTtcblxuICAgICAgICBpZiAocmVhZGluZykgcmVhZCA9IGhhc0hlaWdodCA/IDIgOiAxO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NldCgwLCAwKTtcblxuICAgICAgICBpZiAocmVhZGluZykgcmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvYmogPSB0eXBlID09PSAnc3RyaW5nJyA/IGFyZzAuc3BsaXQoL1tcXHMsXSsvKSB8fCBbXSA6IGFyZzA7XG4gICAgICAgIHJlYWQgPSAxO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICB0aGlzLl9zZXQoK29ialswXSwgKyhvYmoubGVuZ3RoID4gMSA/IG9ialsxXSA6IG9ialswXSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCd3aWR0aCcgaW4gb2JqKSB7XG4gICAgICAgICAgdGhpcy5fc2V0KG9iai53aWR0aCB8fCAwLCBvYmouaGVpZ2h0IHx8IDApO1xuICAgICAgICB9IGVsc2UgaWYgKCd4JyBpbiBvYmopIHtcbiAgICAgICAgICB0aGlzLl9zZXQob2JqLnggfHwgMCwgb2JqLnkgfHwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0KDAsIDApO1xuXG4gICAgICAgICAgcmVhZCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWRpbmcpIHRoaXMuX19yZWFkID0gcmVhZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0OiAnI2luaXRpYWxpemUnLFxuICAgIF9zZXQ6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgcmV0dXJuIHNpemUgPT09IHRoaXMgfHwgc2l6ZSAmJiAodGhpcy53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZS5oZWlnaHQgfHwgQXJyYXkuaXNBcnJheShzaXplKSAmJiB0aGlzLndpZHRoID09PSBzaXplWzBdICYmIHRoaXMuaGVpZ2h0ID09PSBzaXplWzFdKSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuICAgICAgcmV0dXJuICd7IHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aCkgKyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodCkgKyAnIH0nO1xuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG4gICAgICByZXR1cm4gW2YubnVtYmVyKHRoaXMud2lkdGgpLCBmLm51bWJlcih0aGlzLmhlaWdodCldO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggKyBzaXplLndpZHRoLCB0aGlzLmhlaWdodCArIHNpemUuaGVpZ2h0KTtcbiAgICB9LFxuICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KTtcbiAgICB9LFxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggKiBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAqIHNpemUuaGVpZ2h0KTtcbiAgICB9LFxuICAgIGRpdmlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoIC8gc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLyBzaXplLmhlaWdodCk7XG4gICAgfSxcbiAgICBtb2R1bG86IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAlIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICUgc2l6ZS5oZWlnaHQpO1xuICAgIH0sXG4gICAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFNpemUoLXRoaXMud2lkdGgsIC10aGlzLmhlaWdodCk7XG4gICAgfSxcbiAgICBpc1plcm86IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuICAgICAgcmV0dXJuIGlzWmVybyh0aGlzLndpZHRoKSAmJiBpc1plcm8odGhpcy5oZWlnaHQpO1xuICAgIH0sXG4gICAgaXNOYU46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpc05hTih0aGlzLndpZHRoKSB8fCBpc05hTih0aGlzLmhlaWdodCk7XG4gICAgfSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBtaW46IGZ1bmN0aW9uIChzaXplMSwgc2l6ZTIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaXplKE1hdGgubWluKHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksIE1hdGgubWluKHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG4gICAgICB9LFxuICAgICAgbWF4OiBmdW5jdGlvbiAoc2l6ZTEsIHNpemUyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZShNYXRoLm1heChzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLCBNYXRoLm1heChzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuICAgICAgfSxcbiAgICAgIHJhbmRvbTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpemUoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIG9wID0gTWF0aFtrZXldO1xuXG4gICAgdGhpc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTaXplKG9wKHRoaXMud2lkdGgpLCBvcCh0aGlzLmhlaWdodCkpO1xuICAgIH07XG4gIH0sIHt9KSk7XG4gIHZhciBMaW5rZWRTaXplID0gU2l6ZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUod2lkdGgsIGhlaWdodCwgb3duZXIsIHNldHRlcikge1xuICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICB0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG4gICAgfSxcbiAgICBfc2V0OiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgX2RvbnROb3RpZnkpIHtcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBpZiAoIV9kb250Tm90aWZ5KSB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgIH0sXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcblxuICAgICAgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICB9LFxuICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9LFxuICAgIHNldEhlaWdodDogZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBSZWN0YW5nbGUgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUmVjdGFuZ2xlJyxcbiAgICBfcmVhZEluZGV4OiB0cnVlLFxuICAgIGJlYW5zOiB0cnVlLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICB0eXBlID0gdHlwZW9mIGFyZzAsXG4gICAgICAgICAgcmVhZDtcblxuICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuX3NldChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcblxuICAgICAgICByZWFkID0gNDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9zZXQoMCwgMCwgMCwgMCk7XG5cbiAgICAgICAgcmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICB0aGlzLl9zZXQuYXBwbHkodGhpcywgYXJnMCk7XG5cbiAgICAgICAgICByZWFkID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmcwLnggIT09IHVuZGVmaW5lZCB8fCBhcmcwLndpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9zZXQoYXJnMC54IHx8IDAsIGFyZzAueSB8fCAwLCBhcmcwLndpZHRoIHx8IDAsIGFyZzAuaGVpZ2h0IHx8IDApO1xuXG4gICAgICAgICAgcmVhZCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnMC5mcm9tID09PSB1bmRlZmluZWQgJiYgYXJnMC50byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fc2V0KDAsIDAsIDAsIDApO1xuXG4gICAgICAgICAgaWYgKEJhc2UucmVhZFN1cHBvcnRlZChhcmdzLCB0aGlzKSkge1xuICAgICAgICAgICAgcmVhZCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZybSA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnZnJvbScpLFxuICAgICAgICAgICAgbmV4dCA9IEJhc2UucGVlayhhcmdzKSxcbiAgICAgICAgICAgIHggPSBmcm0ueCxcbiAgICAgICAgICAgIHkgPSBmcm0ueSxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0O1xuXG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQueCAhPT0gdW5kZWZpbmVkIHx8IEJhc2UuaGFzTmFtZWQoYXJncywgJ3RvJykpIHtcbiAgICAgICAgICB2YXIgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ3RvJyk7XG4gICAgICAgICAgd2lkdGggPSB0by54IC0geDtcbiAgICAgICAgICBoZWlnaHQgPSB0by55IC0geTtcblxuICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIHggPSB0by54O1xuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIHkgPSB0by55O1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJncyk7XG4gICAgICAgICAgd2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICAgIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHJlYWQgPSBhcmdzLl9faW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWx0ZXJlZCA9IGFyZ3MuX19maWx0ZXJlZDtcbiAgICAgIGlmIChmaWx0ZXJlZCkgdGhpcy5fX2ZpbHRlcmVkID0gZmlsdGVyZWQ7XG4gICAgICBpZiAodGhpcy5fX3JlYWQpIHRoaXMuX19yZWFkID0gcmVhZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0OiAnI2luaXRpYWxpemUnLFxuICAgIF9zZXQ6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgIHZhciBydCA9IEJhc2UuaXNQbGFpblZhbHVlKHJlY3QpID8gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSA6IHJlY3Q7XG4gICAgICByZXR1cm4gcnQgPT09IHRoaXMgfHwgcnQgJiYgdGhpcy54ID09PSBydC54ICYmIHRoaXMueSA9PT0gcnQueSAmJiB0aGlzLndpZHRoID09PSBydC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gcnQuaGVpZ2h0IHx8IGZhbHNlO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuICAgICAgcmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpICsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSkgKyAnLCB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpICsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpICsgJyB9JztcbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuICAgICAgcmV0dXJuIFtmLm51bWJlcih0aGlzLngpLCBmLm51bWJlcih0aGlzLnkpLCBmLm51bWJlcih0aGlzLndpZHRoKSwgZi5udW1iZXIodGhpcy5oZWlnaHQpXTtcbiAgICB9LFxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAoX2RvbnRMaW5rKSB7XG4gICAgICB2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG4gICAgICByZXR1cm4gbmV3IGN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMsICdzZXRQb2ludCcpO1xuICAgIH0sXG4gICAgc2V0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHRoaXMueCA9IHBvaW50Lng7XG4gICAgICB0aGlzLnkgPSBwb2ludC55O1xuICAgIH0sXG4gICAgZ2V0U2l6ZTogZnVuY3Rpb24gKF9kb250TGluaykge1xuICAgICAgdmFyIGN0b3IgPSBfZG9udExpbmsgPyBTaXplIDogTGlua2VkU2l6ZTtcbiAgICAgIHJldHVybiBuZXcgY3Rvcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcbiAgICB9LFxuICAgIF9mdzogMSxcbiAgICBfZmg6IDEsXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICBzeCA9IHRoaXMuX3N4LFxuICAgICAgICAgIHN5ID0gdGhpcy5fc3ksXG4gICAgICAgICAgdyA9IHNpemUud2lkdGgsXG4gICAgICAgICAgaCA9IHNpemUuaGVpZ2h0O1xuXG4gICAgICBpZiAoc3gpIHtcbiAgICAgICAgdGhpcy54ICs9ICh0aGlzLndpZHRoIC0gdykgKiBzeDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN5KSB7XG4gICAgICAgIHRoaXMueSArPSAodGhpcy5oZWlnaHQgLSBoKSAqIHN5O1xuICAgICAgfVxuXG4gICAgICB0aGlzLndpZHRoID0gdztcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICAgIHRoaXMuX2Z3ID0gdGhpcy5fZmggPSAxO1xuICAgIH0sXG4gICAgZ2V0TGVmdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICB9LFxuICAgIHNldExlZnQ6IGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICBpZiAoIXRoaXMuX2Z3KSB7XG4gICAgICAgIHZhciBhbW91bnQgPSBsZWZ0IC0gdGhpcy54O1xuICAgICAgICB0aGlzLndpZHRoIC09IHRoaXMuX3N4ID09PSAwLjUgPyBhbW91bnQgKiAyIDogYW1vdW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnggPSBsZWZ0O1xuICAgICAgdGhpcy5fc3ggPSB0aGlzLl9mdyA9IDA7XG4gICAgfSxcbiAgICBnZXRUb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgfSxcbiAgICBzZXRUb3A6IGZ1bmN0aW9uICh0b3ApIHtcbiAgICAgIGlmICghdGhpcy5fZmgpIHtcbiAgICAgICAgdmFyIGFtb3VudCA9IHRvcCAtIHRoaXMueTtcbiAgICAgICAgdGhpcy5oZWlnaHQgLT0gdGhpcy5fc3kgPT09IDAuNSA/IGFtb3VudCAqIDIgOiBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueSA9IHRvcDtcbiAgICAgIHRoaXMuX3N5ID0gdGhpcy5fZmggPSAwO1xuICAgIH0sXG4gICAgZ2V0UmlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgIH0sXG4gICAgc2V0UmlnaHQ6IGZ1bmN0aW9uIChyaWdodCkge1xuICAgICAgaWYgKCF0aGlzLl9mdykge1xuICAgICAgICB2YXIgYW1vdW50ID0gcmlnaHQgLSB0aGlzLng7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9zeCA9PT0gMC41ID8gYW1vdW50ICogMiA6IGFtb3VudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy54ID0gcmlnaHQgLSB0aGlzLndpZHRoO1xuICAgICAgdGhpcy5fc3ggPSAxO1xuICAgICAgdGhpcy5fZncgPSAwO1xuICAgIH0sXG4gICAgZ2V0Qm90dG9tOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfSxcbiAgICBzZXRCb3R0b206IGZ1bmN0aW9uIChib3R0b20pIHtcbiAgICAgIGlmICghdGhpcy5fZmgpIHtcbiAgICAgICAgdmFyIGFtb3VudCA9IGJvdHRvbSAtIHRoaXMueTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9zeSA9PT0gMC41ID8gYW1vdW50ICogMiA6IGFtb3VudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy55ID0gYm90dG9tIC0gdGhpcy5oZWlnaHQ7XG4gICAgICB0aGlzLl9zeSA9IDE7XG4gICAgICB0aGlzLl9maCA9IDA7XG4gICAgfSxcbiAgICBnZXRDZW50ZXJYOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aCAvIDI7XG4gICAgfSxcbiAgICBzZXRDZW50ZXJYOiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX2Z3IHx8IHRoaXMuX3N4ID09PSAwLjUpIHtcbiAgICAgICAgdGhpcy54ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX3N4KSB7XG4gICAgICAgICAgdGhpcy54ICs9ICh4IC0gdGhpcy54KSAqIDIgKiB0aGlzLl9zeDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud2lkdGggPSAoeCAtIHRoaXMueCkgKiAyO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zeCA9IDAuNTtcbiAgICAgIHRoaXMuX2Z3ID0gMDtcbiAgICB9LFxuICAgIGdldENlbnRlclk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDI7XG4gICAgfSxcbiAgICBzZXRDZW50ZXJZOiBmdW5jdGlvbiAoeSkge1xuICAgICAgaWYgKHRoaXMuX2ZoIHx8IHRoaXMuX3N5ID09PSAwLjUpIHtcbiAgICAgICAgdGhpcy55ID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9zeSkge1xuICAgICAgICAgIHRoaXMueSArPSAoeSAtIHRoaXMueSkgKiAyICogdGhpcy5fc3k7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhlaWdodCA9ICh5IC0gdGhpcy55KSAqIDI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N5ID0gMC41O1xuICAgICAgdGhpcy5fZmggPSAwO1xuICAgIH0sXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbiAoX2RvbnRMaW5rKSB7XG4gICAgICB2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG4gICAgICByZXR1cm4gbmV3IGN0b3IodGhpcy5nZXRDZW50ZXJYKCksIHRoaXMuZ2V0Q2VudGVyWSgpLCB0aGlzLCAnc2V0Q2VudGVyJyk7XG4gICAgfSxcbiAgICBzZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuc2V0Q2VudGVyWChwb2ludC54KTtcbiAgICAgIHRoaXMuc2V0Q2VudGVyWShwb2ludC55KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0QXJlYTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSAwIHx8IHRoaXMuaGVpZ2h0ID09PSAwO1xuICAgIH0sXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmcgJiYgYXJnLndpZHRoICE9PSB1bmRlZmluZWQgfHwgKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cykubGVuZ3RoID09PSA0ID8gdGhpcy5fY29udGFpbnNSZWN0YW5nbGUoUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSkgOiB0aGlzLl9jb250YWluc1BvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgICByZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnkgJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfSxcbiAgICBfY29udGFpbnNSZWN0YW5nbGU6IGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICB2YXIgeCA9IHJlY3QueCxcbiAgICAgICAgICB5ID0gcmVjdC55O1xuICAgICAgcmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55ICYmIHggKyByZWN0LndpZHRoIDw9IHRoaXMueCArIHRoaXMud2lkdGggJiYgeSArIHJlY3QuaGVpZ2h0IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgaW50ZXJzZWN0czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIGVwc2lsb24gPSBCYXNlLnJlYWQoYXJndW1lbnRzKSB8fCAwO1xuICAgICAgcmV0dXJuIHJlY3QueCArIHJlY3Qud2lkdGggPiB0aGlzLnggLSBlcHNpbG9uICYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID4gdGhpcy55IC0gZXBzaWxvbiAmJiByZWN0LnggPCB0aGlzLnggKyB0aGlzLndpZHRoICsgZXBzaWxvbiAmJiByZWN0LnkgPCB0aGlzLnkgKyB0aGlzLmhlaWdodCArIGVwc2lsb247XG4gICAgfSxcbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICB4MSA9IE1hdGgubWF4KHRoaXMueCwgcmVjdC54KSxcbiAgICAgICAgICB5MSA9IE1hdGgubWF4KHRoaXMueSwgcmVjdC55KSxcbiAgICAgICAgICB4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuICAgICAgICAgIHkyID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG4gICAgfSxcbiAgICB1bml0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0LngpLFxuICAgICAgICAgIHkxID0gTWF0aC5taW4odGhpcy55LCByZWN0LnkpLFxuICAgICAgICAgIHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG4gICAgICAgICAgeTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICB9LFxuICAgIGluY2x1ZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHZhciB4MSA9IE1hdGgubWluKHRoaXMueCwgcG9pbnQueCksXG4gICAgICAgICAgeTEgPSBNYXRoLm1pbih0aGlzLnksIHBvaW50LnkpLFxuICAgICAgICAgIHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcG9pbnQueCksXG4gICAgICAgICAgeTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcG9pbnQueSk7XG4gICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgIH0sXG4gICAgZXhwYW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYW1vdW50ID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgaG9yID0gYW1vdW50LndpZHRoLFxuICAgICAgICAgIHZlciA9IGFtb3VudC5oZWlnaHQ7XG4gICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSBob3IgLyAyLCB0aGlzLnkgLSB2ZXIgLyAyLCB0aGlzLndpZHRoICsgaG9yLCB0aGlzLmhlaWdodCArIHZlcik7XG4gICAgfSxcbiAgICBzY2FsZTogZnVuY3Rpb24gKGhvciwgdmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBhbmQodGhpcy53aWR0aCAqIGhvciAtIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0ICogKHZlciA9PT0gdW5kZWZpbmVkID8gaG9yIDogdmVyKSAtIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gIH0sIEJhc2UuZWFjaChbWydUb3AnLCAnTGVmdCddLCBbJ1RvcCcsICdSaWdodCddLCBbJ0JvdHRvbScsICdMZWZ0J10sIFsnQm90dG9tJywgJ1JpZ2h0J10sIFsnTGVmdCcsICdDZW50ZXInXSwgWydUb3AnLCAnQ2VudGVyJ10sIFsnUmlnaHQnLCAnQ2VudGVyJ10sIFsnQm90dG9tJywgJ0NlbnRlciddXSwgZnVuY3Rpb24gKHBhcnRzLCBpbmRleCkge1xuICAgIHZhciBwYXJ0ID0gcGFydHMuam9pbignJyksXG4gICAgICAgIHhGaXJzdCA9IC9eW1JMXS8udGVzdChwYXJ0KTtcbiAgICBpZiAoaW5kZXggPj0gNCkgcGFydHNbMV0gKz0geEZpcnN0ID8gJ1knIDogJ1gnO1xuICAgIHZhciB4ID0gcGFydHNbeEZpcnN0ID8gMCA6IDFdLFxuICAgICAgICB5ID0gcGFydHNbeEZpcnN0ID8gMSA6IDBdLFxuICAgICAgICBnZXRYID0gJ2dldCcgKyB4LFxuICAgICAgICBnZXRZID0gJ2dldCcgKyB5LFxuICAgICAgICBzZXRYID0gJ3NldCcgKyB4LFxuICAgICAgICBzZXRZID0gJ3NldCcgKyB5LFxuICAgICAgICBnZXQgPSAnZ2V0JyArIHBhcnQsXG4gICAgICAgIHNldCA9ICdzZXQnICsgcGFydDtcblxuICAgIHRoaXNbZ2V0XSA9IGZ1bmN0aW9uIChfZG9udExpbmspIHtcbiAgICAgIHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcbiAgICAgIHJldHVybiBuZXcgY3Rvcih0aGlzW2dldFhdKCksIHRoaXNbZ2V0WV0oKSwgdGhpcywgc2V0KTtcbiAgICB9O1xuXG4gICAgdGhpc1tzZXRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgdGhpc1tzZXRYXShwb2ludC54KTtcbiAgICAgIHRoaXNbc2V0WV0ocG9pbnQueSk7XG4gICAgfTtcbiAgfSwge1xuICAgIGJlYW5zOiB0cnVlXG4gIH0pKTtcbiAgdmFyIExpbmtlZFJlY3RhbmdsZSA9IFJlY3RhbmdsZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG4gICAgICB0aGlzLl9zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICB0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG4gICAgfSxcbiAgICBfc2V0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgX2RvbnROb3RpZnkpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgaWYgKCFfZG9udE5vdGlmeSkgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvdG8gPSBSZWN0YW5nbGUucHJvdG90eXBlO1xuICAgIHJldHVybiBCYXNlLmVhY2goWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG4gICAgICAgICAgaW50ZXJuYWwgPSAnXycgKyBrZXk7XG5cbiAgICAgIHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbaW50ZXJuYWxdO1xuICAgICAgfTtcblxuICAgICAgdGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXNbaW50ZXJuYWxdID0gdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy5fZG9udE5vdGlmeSkgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICAgIH07XG4gICAgfSwgQmFzZS5lYWNoKFsnUG9pbnQnLCAnU2l6ZScsICdDZW50ZXInLCAnTGVmdCcsICdUb3AnLCAnUmlnaHQnLCAnQm90dG9tJywgJ0NlbnRlclgnLCAnQ2VudGVyWScsICdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLCAnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBuYW1lID0gJ3NldCcgKyBrZXk7XG5cbiAgICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RvbnROb3RpZnkgPSB0cnVlO1xuICAgICAgICBwcm90b1tuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9kb250Tm90aWZ5ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICAgIH07XG4gICAgfSwge1xuICAgICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5fb3duZXIuX3NlbGVjdGlvbiAmIDIpO1xuICAgICAgfSxcbiAgICAgIHNldFNlbGVjdGVkOiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cbiAgICAgICAgaWYgKG93bmVyLl9jaGFuZ2VTZWxlY3Rpb24pIHtcbiAgICAgICAgICBvd25lci5fY2hhbmdlU2VsZWN0aW9uKDIsIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgfSgpKTtcbiAgdmFyIE1hdHJpeCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdNYXRyaXgnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIE1hdHJpeChhcmcsIF9kb250Tm90aWZ5KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBjb3VudCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIG9rID0gdHJ1ZTtcblxuICAgICAgaWYgKGNvdW50ID49IDYpIHtcbiAgICAgICAgdGhpcy5fc2V0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSB8fCBjb3VudCA9PT0gMikge1xuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgdGhpcy5fc2V0KGFyZy5fYSwgYXJnLl9iLCBhcmcuX2MsIGFyZy5fZCwgYXJnLl90eCwgYXJnLl90eSwgX2RvbnROb3RpZnkpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgIHRoaXMuX3NldC5hcHBseSh0aGlzLCBfZG9udE5vdGlmeSA/IGFyZy5jb25jYXQoW19kb250Tm90aWZ5XSkgOiBhcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWNvdW50KSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9rID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghb2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBtYXRyaXggcGFyYW1ldGVycycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNldDogJyNpbml0aWFsaXplJyxcbiAgICBfc2V0OiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgdHgsIHR5LCBfZG9udE5vdGlmeSkge1xuICAgICAgdGhpcy5fYSA9IGE7XG4gICAgICB0aGlzLl9iID0gYjtcbiAgICAgIHRoaXMuX2MgPSBjO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICB0aGlzLl90eCA9IHR4O1xuICAgICAgdGhpcy5fdHkgPSB0eTtcbiAgICAgIGlmICghX2RvbnROb3RpZnkpIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcbiAgICAgIHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmdldFZhbHVlcygpLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblxuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIGlmIChvd25lci5fYXBwbHlNYXRyaXgpIHtcbiAgICAgICAgICBvd25lci50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3duZXIuX2NoYW5nZWQoMjUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYywgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5KTtcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKG14KSB7XG4gICAgICByZXR1cm4gbXggPT09IHRoaXMgfHwgbXggJiYgdGhpcy5fYSA9PT0gbXguX2EgJiYgdGhpcy5fYiA9PT0gbXguX2IgJiYgdGhpcy5fYyA9PT0gbXguX2MgJiYgdGhpcy5fZCA9PT0gbXguX2QgJiYgdGhpcy5fdHggPT09IG14Ll90eCAmJiB0aGlzLl90eSA9PT0gbXguX3R5O1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuICAgICAgcmV0dXJuICdbWycgKyBbZi5udW1iZXIodGhpcy5fYSksIGYubnVtYmVyKHRoaXMuX2MpLCBmLm51bWJlcih0aGlzLl90eCldLmpvaW4oJywgJykgKyAnXSwgWycgKyBbZi5udW1iZXIodGhpcy5fYiksIGYubnVtYmVyKHRoaXMuX2QpLCBmLm51bWJlcih0aGlzLl90eSldLmpvaW4oJywgJykgKyAnXV0nO1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChfZG9udE5vdGlmeSkge1xuICAgICAgdGhpcy5fYSA9IHRoaXMuX2QgPSAxO1xuICAgICAgdGhpcy5fYiA9IHRoaXMuX2MgPSB0aGlzLl90eCA9IHRoaXMuX3R5ID0gMDtcbiAgICAgIGlmICghX2RvbnROb3RpZnkpIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChyZWN1cnNpdmVseSwgX3NldEFwcGx5TWF0cml4KSB7XG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblxuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyLnRyYW5zZm9ybShudWxsLCBCYXNlLnBpY2socmVjdXJzaXZlbHksIHRydWUpLCBfc2V0QXBwbHlNYXRyaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0lkZW50aXR5KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIHggPSBwb2ludC54LFxuICAgICAgICAgIHkgPSBwb2ludC55O1xuICAgICAgdGhpcy5fdHggKz0geCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYztcbiAgICAgIHRoaXMuX3R5ICs9IHggKiB0aGlzLl9iICsgeSAqIHRoaXMuX2Q7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzY2FsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc2NhbGUgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWQoYXJncywgMCwge1xuICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoY2VudGVyKSB0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuICAgICAgdGhpcy5fYSAqPSBzY2FsZS54O1xuICAgICAgdGhpcy5fYiAqPSBzY2FsZS54O1xuICAgICAgdGhpcy5fYyAqPSBzY2FsZS55O1xuICAgICAgdGhpcy5fZCAqPSBzY2FsZS55O1xuICAgICAgaWYgKGNlbnRlcikgdGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJvdGF0ZTogZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICBhbmdsZSAqPSBNYXRoLlBJIC8gMTgwO1xuICAgICAgdmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICB4ID0gY2VudGVyLngsXG4gICAgICAgICAgeSA9IGNlbnRlci55LFxuICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgdHggPSB4IC0geCAqIGNvcyArIHkgKiBzaW4sXG4gICAgICAgICAgdHkgPSB5IC0geCAqIHNpbiAtIHkgKiBjb3MsXG4gICAgICAgICAgYSA9IHRoaXMuX2EsXG4gICAgICAgICAgYiA9IHRoaXMuX2IsXG4gICAgICAgICAgYyA9IHRoaXMuX2MsXG4gICAgICAgICAgZCA9IHRoaXMuX2Q7XG4gICAgICB0aGlzLl9hID0gY29zICogYSArIHNpbiAqIGM7XG4gICAgICB0aGlzLl9iID0gY29zICogYiArIHNpbiAqIGQ7XG4gICAgICB0aGlzLl9jID0gLXNpbiAqIGEgKyBjb3MgKiBjO1xuICAgICAgdGhpcy5fZCA9IC1zaW4gKiBiICsgY29zICogZDtcbiAgICAgIHRoaXMuX3R4ICs9IHR4ICogYSArIHR5ICogYztcbiAgICAgIHRoaXMuX3R5ICs9IHR4ICogYiArIHR5ICogZDtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNoZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBzaGVhciA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZChhcmdzLCAwLCB7XG4gICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChjZW50ZXIpIHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG4gICAgICB2YXIgYSA9IHRoaXMuX2EsXG4gICAgICAgICAgYiA9IHRoaXMuX2I7XG4gICAgICB0aGlzLl9hICs9IHNoZWFyLnkgKiB0aGlzLl9jO1xuICAgICAgdGhpcy5fYiArPSBzaGVhci55ICogdGhpcy5fZDtcbiAgICAgIHRoaXMuX2MgKz0gc2hlYXIueCAqIGE7XG4gICAgICB0aGlzLl9kICs9IHNoZWFyLnggKiBiO1xuICAgICAgaWYgKGNlbnRlcikgdGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNrZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHNrZXcgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWQoYXJncywgMCwge1xuICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgfSksXG4gICAgICAgICAgdG9SYWRpYW5zID0gTWF0aC5QSSAvIDE4MCxcbiAgICAgICAgICBzaGVhciA9IG5ldyBQb2ludChNYXRoLnRhbihza2V3LnggKiB0b1JhZGlhbnMpLCBNYXRoLnRhbihza2V3LnkgKiB0b1JhZGlhbnMpKTtcbiAgICAgIHJldHVybiB0aGlzLnNoZWFyKHNoZWFyLCBjZW50ZXIpO1xuICAgIH0sXG4gICAgYXBwZW5kOiBmdW5jdGlvbiAobXgsIF9kb250Tm90aWZ5KSB7XG4gICAgICBpZiAobXgpIHtcbiAgICAgICAgdmFyIGExID0gdGhpcy5fYSxcbiAgICAgICAgICAgIGIxID0gdGhpcy5fYixcbiAgICAgICAgICAgIGMxID0gdGhpcy5fYyxcbiAgICAgICAgICAgIGQxID0gdGhpcy5fZCxcbiAgICAgICAgICAgIGEyID0gbXguX2EsXG4gICAgICAgICAgICBiMiA9IG14Ll9jLFxuICAgICAgICAgICAgYzIgPSBteC5fYixcbiAgICAgICAgICAgIGQyID0gbXguX2QsXG4gICAgICAgICAgICB0eDIgPSBteC5fdHgsXG4gICAgICAgICAgICB0eTIgPSBteC5fdHk7XG4gICAgICAgIHRoaXMuX2EgPSBhMiAqIGExICsgYzIgKiBjMTtcbiAgICAgICAgdGhpcy5fYyA9IGIyICogYTEgKyBkMiAqIGMxO1xuICAgICAgICB0aGlzLl9iID0gYTIgKiBiMSArIGMyICogZDE7XG4gICAgICAgIHRoaXMuX2QgPSBiMiAqIGIxICsgZDIgKiBkMTtcbiAgICAgICAgdGhpcy5fdHggKz0gdHgyICogYTEgKyB0eTIgKiBjMTtcbiAgICAgICAgdGhpcy5fdHkgKz0gdHgyICogYjEgKyB0eTIgKiBkMTtcbiAgICAgICAgaWYgKCFfZG9udE5vdGlmeSkgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHByZXBlbmQ6IGZ1bmN0aW9uIChteCwgX2RvbnROb3RpZnkpIHtcbiAgICAgIGlmIChteCkge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLl9hLFxuICAgICAgICAgICAgYjEgPSB0aGlzLl9iLFxuICAgICAgICAgICAgYzEgPSB0aGlzLl9jLFxuICAgICAgICAgICAgZDEgPSB0aGlzLl9kLFxuICAgICAgICAgICAgdHgxID0gdGhpcy5fdHgsXG4gICAgICAgICAgICB0eTEgPSB0aGlzLl90eSxcbiAgICAgICAgICAgIGEyID0gbXguX2EsXG4gICAgICAgICAgICBiMiA9IG14Ll9jLFxuICAgICAgICAgICAgYzIgPSBteC5fYixcbiAgICAgICAgICAgIGQyID0gbXguX2QsXG4gICAgICAgICAgICB0eDIgPSBteC5fdHgsXG4gICAgICAgICAgICB0eTIgPSBteC5fdHk7XG4gICAgICAgIHRoaXMuX2EgPSBhMiAqIGExICsgYjIgKiBiMTtcbiAgICAgICAgdGhpcy5fYyA9IGEyICogYzEgKyBiMiAqIGQxO1xuICAgICAgICB0aGlzLl9iID0gYzIgKiBhMSArIGQyICogYjE7XG4gICAgICAgIHRoaXMuX2QgPSBjMiAqIGMxICsgZDIgKiBkMTtcbiAgICAgICAgdGhpcy5fdHggPSBhMiAqIHR4MSArIGIyICogdHkxICsgdHgyO1xuICAgICAgICB0aGlzLl90eSA9IGMyICogdHgxICsgZDIgKiB0eTEgKyB0eTI7XG4gICAgICAgIGlmICghX2RvbnROb3RpZnkpIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhcHBlbmRlZDogZnVuY3Rpb24gKG14KSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmFwcGVuZChteCk7XG4gICAgfSxcbiAgICBwcmVwZW5kZWQ6IGZ1bmN0aW9uIChteCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5wcmVwZW5kKG14KTtcbiAgICB9LFxuICAgIGludmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGEgPSB0aGlzLl9hLFxuICAgICAgICAgIGIgPSB0aGlzLl9iLFxuICAgICAgICAgIGMgPSB0aGlzLl9jLFxuICAgICAgICAgIGQgPSB0aGlzLl9kLFxuICAgICAgICAgIHR4ID0gdGhpcy5fdHgsXG4gICAgICAgICAgdHkgPSB0aGlzLl90eSxcbiAgICAgICAgICBkZXQgPSBhICogZCAtIGIgKiBjLFxuICAgICAgICAgIHJlcyA9IG51bGw7XG5cbiAgICAgIGlmIChkZXQgJiYgIWlzTmFOKGRldCkgJiYgaXNGaW5pdGUodHgpICYmIGlzRmluaXRlKHR5KSkge1xuICAgICAgICB0aGlzLl9hID0gZCAvIGRldDtcbiAgICAgICAgdGhpcy5fYiA9IC1iIC8gZGV0O1xuICAgICAgICB0aGlzLl9jID0gLWMgLyBkZXQ7XG4gICAgICAgIHRoaXMuX2QgPSBhIC8gZGV0O1xuICAgICAgICB0aGlzLl90eCA9IChjICogdHkgLSBkICogdHgpIC8gZGV0O1xuICAgICAgICB0aGlzLl90eSA9IChiICogdHggLSBhICogdHkpIC8gZGV0O1xuICAgICAgICByZXMgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgaW52ZXJ0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW52ZXJ0KCk7XG4gICAgfSxcbiAgICBjb25jYXRlbmF0ZTogJyNhcHBlbmQnLFxuICAgIHByZUNvbmNhdGVuYXRlOiAnI3ByZXBlbmQnLFxuICAgIGNoYWluOiAnI2FwcGVuZGVkJyxcbiAgICBfc2hpZnRsZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9iLCB0aGlzLl9jLCB0aGlzLl9kLCAwLCAwKTtcbiAgICB9LFxuICAgIF9vck51bGxJZklkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0lkZW50aXR5KCkgPyBudWxsIDogdGhpcztcbiAgICB9LFxuICAgIGlzSWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hID09PSAxICYmIHRoaXMuX2IgPT09IDAgJiYgdGhpcy5fYyA9PT0gMCAmJiB0aGlzLl9kID09PSAxICYmIHRoaXMuX3R4ID09PSAwICYmIHRoaXMuX3R5ID09PSAwO1xuICAgIH0sXG4gICAgaXNJbnZlcnRpYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGV0ID0gdGhpcy5fYSAqIHRoaXMuX2QgLSB0aGlzLl9jICogdGhpcy5fYjtcbiAgICAgIHJldHVybiBkZXQgJiYgIWlzTmFOKGRldCkgJiYgaXNGaW5pdGUodGhpcy5fdHgpICYmIGlzRmluaXRlKHRoaXMuX3R5KTtcbiAgICB9LFxuICAgIGlzU2luZ3VsYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5pc0ludmVydGlibGUoKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKHNyYywgZHN0LCBjb3VudCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGhpcy5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKSA6IHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKHNyYywgZHN0LCBjb3VudCk7XG4gICAgfSxcbiAgICBfdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCwgZGVzdCwgX2RvbnROb3RpZnkpIHtcbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgIGlmICghZGVzdCkgZGVzdCA9IG5ldyBQb2ludCgpO1xuICAgICAgcmV0dXJuIGRlc3QuX3NldCh4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9jICsgdGhpcy5fdHgsIHggKiB0aGlzLl9iICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eSwgX2RvbnROb3RpZnkpO1xuICAgIH0sXG4gICAgX3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbiAoc3JjLCBkc3QsIGNvdW50KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gMiAqIGNvdW50OyBpIDwgbWF4OyBpICs9IDIpIHtcbiAgICAgICAgdmFyIHggPSBzcmNbaV0sXG4gICAgICAgICAgICB5ID0gc3JjW2kgKyAxXTtcbiAgICAgICAgZHN0W2ldID0geCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYyArIHRoaXMuX3R4O1xuICAgICAgICBkc3RbaSArIDFdID0geCAqIHRoaXMuX2IgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZHN0O1xuICAgIH0sXG4gICAgX3RyYW5zZm9ybUNvcm5lcnM6IGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICB2YXIgeDEgPSByZWN0LngsXG4gICAgICAgICAgeTEgPSByZWN0LnksXG4gICAgICAgICAgeDIgPSB4MSArIHJlY3Qud2lkdGgsXG4gICAgICAgICAgeTIgPSB5MSArIHJlY3QuaGVpZ2h0LFxuICAgICAgICAgIGNvb3JkcyA9IFt4MSwgeTEsIHgyLCB5MSwgeDIsIHkyLCB4MSwgeTJdO1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCA0KTtcbiAgICB9LFxuICAgIF90cmFuc2Zvcm1Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5fdHJhbnNmb3JtQ29ybmVycyhib3VuZHMpLFxuICAgICAgICAgIG1pbiA9IGNvb3Jkcy5zbGljZSgwLCAyKSxcbiAgICAgICAgICBtYXggPSBtaW4uc2xpY2UoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgdmFyIHZhbCA9IGNvb3Jkc1tpXSxcbiAgICAgICAgICAgIGogPSBpICYgMTtcblxuICAgICAgICBpZiAodmFsIDwgbWluW2pdKSB7XG4gICAgICAgICAgbWluW2pdID0gdmFsO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA+IG1heFtqXSkge1xuICAgICAgICAgIG1heFtqXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRlc3QpIGRlc3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgICByZXR1cm4gZGVzdC5fc2V0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSwgX2RvbnROb3RpZnkpO1xuICAgIH0sXG4gICAgaW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIF9pbnZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG4gICAgICB2YXIgYSA9IHRoaXMuX2EsXG4gICAgICAgICAgYiA9IHRoaXMuX2IsXG4gICAgICAgICAgYyA9IHRoaXMuX2MsXG4gICAgICAgICAgZCA9IHRoaXMuX2QsXG4gICAgICAgICAgdHggPSB0aGlzLl90eCxcbiAgICAgICAgICB0eSA9IHRoaXMuX3R5LFxuICAgICAgICAgIGRldCA9IGEgKiBkIC0gYiAqIGMsXG4gICAgICAgICAgcmVzID0gbnVsbDtcblxuICAgICAgaWYgKGRldCAmJiAhaXNOYU4oZGV0KSAmJiBpc0Zpbml0ZSh0eCkgJiYgaXNGaW5pdGUodHkpKSB7XG4gICAgICAgIHZhciB4ID0gcG9pbnQueCAtIHRoaXMuX3R4LFxuICAgICAgICAgICAgeSA9IHBvaW50LnkgLSB0aGlzLl90eTtcbiAgICAgICAgaWYgKCFkZXN0KSBkZXN0ID0gbmV3IFBvaW50KCk7XG4gICAgICAgIHJlcyA9IGRlc3QuX3NldCgoeCAqIGQgLSB5ICogYykgLyBkZXQsICh5ICogYSAtIHggKiBiKSAvIGRldCwgX2RvbnROb3RpZnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuX2EsXG4gICAgICAgICAgYiA9IHRoaXMuX2IsXG4gICAgICAgICAgYyA9IHRoaXMuX2MsXG4gICAgICAgICAgZCA9IHRoaXMuX2QsXG4gICAgICAgICAgZGV0ID0gYSAqIGQgLSBiICogYyxcbiAgICAgICAgICBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgICAgICBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSSxcbiAgICAgICAgICByb3RhdGUsXG4gICAgICAgICAgc2NhbGUsXG4gICAgICAgICAgc2tldztcblxuICAgICAgaWYgKGEgIT09IDAgfHwgYiAhPT0gMCkge1xuICAgICAgICB2YXIgciA9IHNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICAgIHJvdGF0ZSA9IE1hdGguYWNvcyhhIC8gcikgKiAoYiA+IDAgPyAxIDogLTEpO1xuICAgICAgICBzY2FsZSA9IFtyLCBkZXQgLyByXTtcbiAgICAgICAgc2tldyA9IFthdGFuMihhICogYyArIGIgKiBkLCByICogciksIDBdO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAwIHx8IGQgIT09IDApIHtcbiAgICAgICAgdmFyIHMgPSBzcXJ0KGMgKiBjICsgZCAqIGQpO1xuICAgICAgICByb3RhdGUgPSBNYXRoLmFzaW4oYyAvIHMpICogKGQgPiAwID8gMSA6IC0xKTtcbiAgICAgICAgc2NhbGUgPSBbZGV0IC8gcywgc107XG4gICAgICAgIHNrZXcgPSBbMCwgYXRhbjIoYSAqIGMgKyBiICogZCwgcyAqIHMpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0ZSA9IDA7XG4gICAgICAgIHNrZXcgPSBzY2FsZSA9IFswLCAwXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMuZ2V0VHJhbnNsYXRpb24oKSxcbiAgICAgICAgcm90YXRpb246IHJvdGF0ZSAqIGRlZ3JlZXMsXG4gICAgICAgIHNjYWxpbmc6IG5ldyBQb2ludChzY2FsZSksXG4gICAgICAgIHNrZXdpbmc6IG5ldyBQb2ludChza2V3WzBdICogZGVncmVlcywgc2tld1sxXSAqIGRlZ3JlZXMpXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0VmFsdWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eV07XG4gICAgfSxcbiAgICBnZXRUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl90eCwgdGhpcy5fdHkpO1xuICAgIH0sXG4gICAgZ2V0U2NhbGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb21wb3NlKCkuc2NhbGluZztcbiAgICB9LFxuICAgIGdldFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvbXBvc2UoKS5yb3RhdGlvbjtcbiAgICB9LFxuICAgIGFwcGx5VG9Db250ZXh0OiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuaXNJZGVudGl0eSgpKSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0odGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYywgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIEJhc2UuZWFjaChbJ2EnLCAnYicsICdjJywgJ2QnLCAndHgnLCAndHknXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG4gICAgICAgIHByb3AgPSAnXycgKyBrZXk7XG5cbiAgICB0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1twcm9wXTtcbiAgICB9O1xuXG4gICAgdGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9O1xuICB9LCB7fSkpO1xuICB2YXIgTGluZSA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdMaW5lJyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBMaW5lKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgIHZhciBhc1ZlY3RvciA9IGZhbHNlO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgIHRoaXMuX3B4ID0gYXJnMDtcbiAgICAgICAgdGhpcy5fcHkgPSBhcmcxO1xuICAgICAgICB0aGlzLl92eCA9IGFyZzI7XG4gICAgICAgIHRoaXMuX3Z5ID0gYXJnMztcbiAgICAgICAgYXNWZWN0b3IgPSBhcmc0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHggPSBhcmcwLng7XG4gICAgICAgIHRoaXMuX3B5ID0gYXJnMC55O1xuICAgICAgICB0aGlzLl92eCA9IGFyZzEueDtcbiAgICAgICAgdGhpcy5fdnkgPSBhcmcxLnk7XG4gICAgICAgIGFzVmVjdG9yID0gYXJnMjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhc1ZlY3Rvcikge1xuICAgICAgICB0aGlzLl92eCAtPSB0aGlzLl9weDtcbiAgICAgICAgdGhpcy5fdnkgLT0gdGhpcy5fcHk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl9weCwgdGhpcy5fcHkpO1xuICAgIH0sXG4gICAgZ2V0VmVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuX3Z4LCB0aGlzLl92eSk7XG4gICAgfSxcbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFZlY3RvcigpLmdldExlbmd0aCgpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAobGluZSwgaXNJbmZpbml0ZSkge1xuICAgICAgcmV0dXJuIExpbmUuaW50ZXJzZWN0KHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LCBsaW5lLl9weCwgbGluZS5fcHksIGxpbmUuX3Z4LCBsaW5lLl92eSwgdHJ1ZSwgaXNJbmZpbml0ZSk7XG4gICAgfSxcbiAgICBnZXRTaWRlOiBmdW5jdGlvbiAocG9pbnQsIGlzSW5maW5pdGUpIHtcbiAgICAgIHJldHVybiBMaW5lLmdldFNpZGUodGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksIHBvaW50LngsIHBvaW50LnksIHRydWUsIGlzSW5maW5pdGUpO1xuICAgIH0sXG4gICAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0U2lnbmVkRGlzdGFuY2UocG9pbnQpKTtcbiAgICB9LFxuICAgIGdldFNpZ25lZERpc3RhbmNlOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiBMaW5lLmdldFNpZ25lZERpc3RhbmNlKHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LCBwb2ludC54LCBwb2ludC55LCB0cnVlKTtcbiAgICB9LFxuICAgIGlzQ29sbGluZWFyOiBmdW5jdGlvbiAobGluZSkge1xuICAgICAgcmV0dXJuIFBvaW50LmlzQ29sbGluZWFyKHRoaXMuX3Z4LCB0aGlzLl92eSwgbGluZS5fdngsIGxpbmUuX3Z5KTtcbiAgICB9LFxuICAgIGlzT3J0aG9nb25hbDogZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHJldHVybiBQb2ludC5pc09ydGhvZ29uYWwodGhpcy5fdngsIHRoaXMuX3Z5LCBsaW5lLl92eCwgbGluZS5fdnkpO1xuICAgIH0sXG4gICAgc3RhdGljczoge1xuICAgICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAocDF4LCBwMXksIHYxeCwgdjF5LCBwMngsIHAyeSwgdjJ4LCB2MnksIGFzVmVjdG9yLCBpc0luZmluaXRlKSB7XG4gICAgICAgIGlmICghYXNWZWN0b3IpIHtcbiAgICAgICAgICB2MXggLT0gcDF4O1xuICAgICAgICAgIHYxeSAtPSBwMXk7XG4gICAgICAgICAgdjJ4IC09IHAyeDtcbiAgICAgICAgICB2MnkgLT0gcDJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNyb3NzID0gdjF4ICogdjJ5IC0gdjF5ICogdjJ4O1xuXG4gICAgICAgIGlmICghTnVtZXJpY2FsLmlzTWFjaGluZVplcm8oY3Jvc3MpKSB7XG4gICAgICAgICAgdmFyIGR4ID0gcDF4IC0gcDJ4LFxuICAgICAgICAgICAgICBkeSA9IHAxeSAtIHAyeSxcbiAgICAgICAgICAgICAgdTEgPSAodjJ4ICogZHkgLSB2MnkgKiBkeCkgLyBjcm9zcyxcbiAgICAgICAgICAgICAgdTIgPSAodjF4ICogZHkgLSB2MXkgKiBkeCkgLyBjcm9zcyxcbiAgICAgICAgICAgICAgZXBzaWxvbiA9IDFlLTEyLFxuICAgICAgICAgICAgICB1TWluID0gLWVwc2lsb24sXG4gICAgICAgICAgICAgIHVNYXggPSAxICsgZXBzaWxvbjtcblxuICAgICAgICAgIGlmIChpc0luZmluaXRlIHx8IHVNaW4gPCB1MSAmJiB1MSA8IHVNYXggJiYgdU1pbiA8IHUyICYmIHUyIDwgdU1heCkge1xuICAgICAgICAgICAgaWYgKCFpc0luZmluaXRlKSB7XG4gICAgICAgICAgICAgIHUxID0gdTEgPD0gMCA/IDAgOiB1MSA+PSAxID8gMSA6IHUxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHAxeCArIHUxICogdjF4LCBwMXkgKyB1MSAqIHYxeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0U2lkZTogZnVuY3Rpb24gKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3RvciwgaXNJbmZpbml0ZSkge1xuICAgICAgICBpZiAoIWFzVmVjdG9yKSB7XG4gICAgICAgICAgdnggLT0gcHg7XG4gICAgICAgICAgdnkgLT0gcHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdjJ4ID0geCAtIHB4LFxuICAgICAgICAgICAgdjJ5ID0geSAtIHB5LFxuICAgICAgICAgICAgY2N3ID0gdjJ4ICogdnkgLSB2MnkgKiB2eDtcblxuICAgICAgICBpZiAoIWlzSW5maW5pdGUgJiYgTnVtZXJpY2FsLmlzTWFjaGluZVplcm8oY2N3KSkge1xuICAgICAgICAgIGNjdyA9ICh2MnggKiB2eCArIHYyeCAqIHZ4KSAvICh2eCAqIHZ4ICsgdnkgKiB2eSk7XG4gICAgICAgICAgaWYgKGNjdyA+PSAwICYmIGNjdyA8PSAxKSBjY3cgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNjdyA8IDAgPyAtMSA6IGNjdyA+IDAgPyAxIDogMDtcbiAgICAgIH0sXG4gICAgICBnZXRTaWduZWREaXN0YW5jZTogZnVuY3Rpb24gKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuICAgICAgICBpZiAoIWFzVmVjdG9yKSB7XG4gICAgICAgICAgdnggLT0gcHg7XG4gICAgICAgICAgdnkgLT0gcHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdnggPT09IDAgPyB2eSA+IDAgPyB4IC0gcHggOiBweCAtIHggOiB2eSA9PT0gMCA/IHZ4IDwgMCA/IHkgLSBweSA6IHB5IC0geSA6ICgoeCAtIHB4KSAqIHZ5IC0gKHkgLSBweSkgKiB2eCkgLyAodnkgPiB2eCA/IHZ5ICogTWF0aC5zcXJ0KDEgKyB2eCAqIHZ4IC8gKHZ5ICogdnkpKSA6IHZ4ICogTWF0aC5zcXJ0KDEgKyB2eSAqIHZ5IC8gKHZ4ICogdngpKSk7XG4gICAgICB9LFxuICAgICAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uIChweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIFByb2plY3QgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1Byb2plY3QnLFxuICAgIF9saXN0OiAncHJvamVjdHMnLFxuICAgIF9yZWZlcmVuY2U6ICdwcm9qZWN0JyxcbiAgICBfY29tcGFjdFNlcmlhbGl6ZTogdHJ1ZSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQcm9qZWN0KGVsZW1lbnQpIHtcbiAgICAgIFBhcGVyU2NvcGVJdGVtLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuICAgICAgdGhpcy5fYWN0aXZlTGF5ZXIgPSBudWxsO1xuICAgICAgdGhpcy5fY3VycmVudFN0eWxlID0gbmV3IFN0eWxlKG51bGwsIG51bGwsIHRoaXMpO1xuICAgICAgdGhpcy5fdmlldyA9IFZpZXcuY3JlYXRlKHRoaXMsIGVsZW1lbnQgfHwgQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKDEsIDEpKTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkl0ZW1zID0ge307XG4gICAgICB0aGlzLl9zZWxlY3Rpb25Db3VudCA9IDA7XG4gICAgICB0aGlzLl91cGRhdGVWZXJzaW9uID0gMDtcbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5fY2hpbGRyZW4sIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uIChmbGFncywgaXRlbSkge1xuICAgICAgaWYgKGZsYWdzICYgMSkge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX3ZpZXc7XG5cbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICB2aWV3Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgaWYgKCF2aWV3Ll9yZXF1ZXN0ZWQgJiYgdmlldy5fYXV0b1VwZGF0ZSkgdmlldy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9jaGFuZ2VzO1xuXG4gICAgICBpZiAoY2hhbmdlcyAmJiBpdGVtKSB7XG4gICAgICAgIHZhciBjaGFuZ2VzQnlJZCA9IHRoaXMuX2NoYW5nZXNCeUlkLFxuICAgICAgICAgICAgaWQgPSBpdGVtLl9pZCxcbiAgICAgICAgICAgIGVudHJ5ID0gY2hhbmdlc0J5SWRbaWRdO1xuXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIGVudHJ5LmZsYWdzIHw9IGZsYWdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2VzQnlJZFtpZF0gPSB7XG4gICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgZmxhZ3M6IGZsYWdzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjaGlsZHJlbltpXS5yZW1vdmUoKTtcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBpZiAoIXJlbW92ZS5iYXNlLmNhbGwodGhpcykpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl92aWV3KSB0aGlzLl92aWV3LnJlbW92ZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlldztcbiAgICB9LFxuICAgIGdldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdHlsZTtcbiAgICB9LFxuICAgIHNldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICB0aGlzLl9jdXJyZW50U3R5bGUuc2V0KHN0eWxlKTtcbiAgICB9LFxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgfSxcbiAgICBnZXRPcHRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2NvcGUuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgICB9LFxuICAgIGdldEFjdGl2ZUxheWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlTGF5ZXIgfHwgbmV3IExheWVyKHtcbiAgICAgICAgcHJvamVjdDogdGhpcyxcbiAgICAgICAgaW5zZXJ0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldFN5bWJvbERlZmluaXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVmaW5pdGlvbnMgPSBbXSxcbiAgICAgICAgICBpZHMgPSB7fTtcbiAgICAgIHRoaXMuZ2V0SXRlbXMoe1xuICAgICAgICBjbGFzczogU3ltYm9sSXRlbSxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgdmFyIGRlZmluaXRpb24gPSBpdGVtLl9kZWZpbml0aW9uLFxuICAgICAgICAgICAgICBpZCA9IGRlZmluaXRpb24uX2lkO1xuXG4gICAgICAgICAgaWYgKCFpZHNbaWRdKSB7XG4gICAgICAgICAgICBpZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlZmluaXRpb25zLnB1c2goZGVmaW5pdGlvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZWZpbml0aW9ucztcbiAgICB9LFxuICAgIGdldFN5bWJvbHM6ICdnZXRTeW1ib2xEZWZpbml0aW9ucycsXG4gICAgZ2V0U2VsZWN0ZWRJdGVtczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGVjdGlvbkl0ZW1zID0gdGhpcy5fc2VsZWN0aW9uSXRlbXMsXG4gICAgICAgICAgaXRlbXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaWQgaW4gc2VsZWN0aW9uSXRlbXMpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBzZWxlY3Rpb25JdGVtc1tpZF0sXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBpdGVtLl9zZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmIDEgJiYgaXRlbS5pc0luc2VydGVkKCkpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3Rpb24oaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG4gICAgX3VwZGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBpZCA9IGl0ZW0uX2lkLFxuICAgICAgICAgIHNlbGVjdGlvbkl0ZW1zID0gdGhpcy5fc2VsZWN0aW9uSXRlbXM7XG5cbiAgICAgIGlmIChpdGVtLl9zZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbkl0ZW1zW2lkXSAhPT0gaXRlbSkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkNvdW50Kys7XG4gICAgICAgICAgc2VsZWN0aW9uSXRlbXNbaWRdID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb25JdGVtc1tpZF0gPT09IGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uQ291bnQtLTtcbiAgICAgICAgZGVsZXRlIHNlbGVjdGlvbkl0ZW1zW2lkXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBjaGlsZHJlbltpXS5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuICAgIH0sXG4gICAgZGVzZWxlY3RBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25JdGVtcyA9IHRoaXMuX3NlbGVjdGlvbkl0ZW1zO1xuXG4gICAgICBmb3IgKHZhciBpIGluIHNlbGVjdGlvbkl0ZW1zKSBzZWxlY3Rpb25JdGVtc1tpXS5zZXRGdWxseVNlbGVjdGVkKGZhbHNlKTtcbiAgICB9LFxuICAgIGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydExheWVyKHVuZGVmaW5lZCwgbGF5ZXIpO1xuICAgIH0sXG4gICAgaW5zZXJ0TGF5ZXI6IGZ1bmN0aW9uIChpbmRleCwgbGF5ZXIpIHtcbiAgICAgIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgICAgIGxheWVyLl9yZW1vdmUoZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIEJhc2Uuc3BsaWNlKHRoaXMuX2NoaWxkcmVuLCBbbGF5ZXJdLCBpbmRleCwgMCk7XG5cbiAgICAgICAgbGF5ZXIuX3NldFByb2plY3QodGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBsYXllci5fbmFtZTtcbiAgICAgICAgaWYgKG5hbWUpIGxheWVyLnNldE5hbWUobmFtZSk7XG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VzKSBsYXllci5fY2hhbmdlZCg1KTtcbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmVMYXllcikgdGhpcy5fYWN0aXZlTGF5ZXIgPSBsYXllcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxheWVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH0sXG4gICAgX2luc2VydEl0ZW06IGZ1bmN0aW9uIChpbmRleCwgaXRlbSwgX2NyZWF0ZWQpIHtcbiAgICAgIGl0ZW0gPSB0aGlzLmluc2VydExheWVyKGluZGV4LCBpdGVtKSB8fCAodGhpcy5fYWN0aXZlTGF5ZXIgfHwgdGhpcy5faW5zZXJ0SXRlbSh1bmRlZmluZWQsIG5ldyBMYXllcihJdGVtLk5PX0lOU0VSVCksIHRydWUpKS5pbnNlcnRDaGlsZChpbmRleCwgaXRlbSk7XG4gICAgICBpZiAoX2NyZWF0ZWQgJiYgaXRlbS5hY3RpdmF0ZSkgaXRlbS5hY3RpdmF0ZSgpO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSxcbiAgICBnZXRJdGVtczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGdldEl0ZW06IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcywgb3B0aW9ucywgbnVsbCwgbnVsbCwgdHJ1ZSlbMF0gfHwgbnVsbDtcbiAgICB9LFxuICAgIGltcG9ydEpTT046IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9hY3RpdmVMYXllcjtcbiAgICAgIHJldHVybiBCYXNlLmltcG9ydEpTT04oanNvbiwgbGF5ZXIgJiYgbGF5ZXIuaXNFbXB0eSgpICYmIGxheWVyKTtcbiAgICB9LFxuICAgIHJlbW92ZU9uOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIHNldHMgPSB0aGlzLl9yZW1vdmVTZXRzO1xuXG4gICAgICBpZiAoc2V0cykge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ21vdXNldXAnKSBzZXRzLm1vdXNlZHJhZyA9IG51bGw7XG4gICAgICAgIHZhciBzZXQgPSBzZXRzW3R5cGVdO1xuXG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpZCBpbiBzZXQpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gc2V0W2lkXTtcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNldHMpIHtcbiAgICAgICAgICAgICAgdmFyIG90aGVyID0gc2V0c1trZXldO1xuICAgICAgICAgICAgICBpZiAob3RoZXIgJiYgb3RoZXIgIT0gc2V0KSBkZWxldGUgb3RoZXJbaXRlbS5faWRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldHNbdHlwZV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiAoY3R4LCBtYXRyaXgsIHBpeGVsUmF0aW8pIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVZlcnNpb24rKztcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgIHBhcmFtID0gbmV3IEJhc2Uoe1xuICAgICAgICBvZmZzZXQ6IG5ldyBQb2ludCgwLCAwKSxcbiAgICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpbyxcbiAgICAgICAgdmlld01hdHJpeDogbWF0cml4LmlzSWRlbnRpdHkoKSA/IG51bGwgOiBtYXRyaXgsXG4gICAgICAgIG1hdHJpY2VzOiBbbmV3IE1hdHJpeCgpXSxcbiAgICAgICAgdXBkYXRlTWF0cml4OiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2hpbGRyZW5baV0uZHJhdyhjdHgsIHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbkNvdW50ID4gMCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc3Ryb2tlV2lkdGggPSAxO1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLl9zZWxlY3Rpb25JdGVtcyxcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLl9zY29wZS5zZXR0aW5ncy5oYW5kbGVTaXplLFxuICAgICAgICAgICAgdmVyc2lvbiA9IHRoaXMuX3VwZGF0ZVZlcnNpb247XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gaXRlbXMpIHtcbiAgICAgICAgICBpdGVtc1tpZF0uX2RyYXdTZWxlY3Rpb24oY3R4LCBtYXRyaXgsIHNpemUsIGl0ZW1zLCB2ZXJzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIEl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG4gICAgc3RhdGljczoge1xuICAgICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoc3JjKSB7XG4gICAgICAgIGlmIChzcmMuX3NlcmlhbGl6ZUZpZWxkcykgc3JjLl9zZXJpYWxpemVGaWVsZHMgPSBCYXNlLnNldCh7fSwgdGhpcy5wcm90b3R5cGUuX3NlcmlhbGl6ZUZpZWxkcywgc3JjLl9zZXJpYWxpemVGaWVsZHMpO1xuICAgICAgICByZXR1cm4gZXh0ZW5kLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBOT19JTlNFUlQ6IHtcbiAgICAgICAgaW5zZXJ0OiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAgX2NsYXNzOiAnSXRlbScsXG4gICAgX25hbWU6IG51bGwsXG4gICAgX2FwcGx5TWF0cml4OiB0cnVlLFxuICAgIF9jYW5BcHBseU1hdHJpeDogdHJ1ZSxcbiAgICBfY2FuU2NhbGVTdHJva2U6IGZhbHNlLFxuICAgIF9waXZvdDogbnVsbCxcbiAgICBfdmlzaWJsZTogdHJ1ZSxcbiAgICBfYmxlbmRNb2RlOiAnbm9ybWFsJyxcbiAgICBfb3BhY2l0eTogMSxcbiAgICBfbG9ja2VkOiBmYWxzZSxcbiAgICBfZ3VpZGU6IGZhbHNlLFxuICAgIF9jbGlwTWFzazogZmFsc2UsXG4gICAgX3NlbGVjdGlvbjogMCxcbiAgICBfc2VsZWN0Qm91bmRzOiB0cnVlLFxuICAgIF9zZWxlY3RDaGlsZHJlbjogZmFsc2UsXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIGFwcGx5TWF0cml4OiBudWxsLFxuICAgICAgbWF0cml4OiBuZXcgTWF0cml4KCksXG4gICAgICBwaXZvdDogbnVsbCxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBibGVuZE1vZGU6ICdub3JtYWwnLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIGxvY2tlZDogZmFsc2UsXG4gICAgICBndWlkZTogZmFsc2UsXG4gICAgICBjbGlwTWFzazogZmFsc2UsXG4gICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICBkYXRhOiB7fVxuICAgIH0sXG4gICAgX3ByaW9yaXRpemU6IFsnYXBwbHlNYXRyaXgnXVxuICB9LCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVycyA9IFsnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uQ2xpY2snLCAnb25Eb3VibGVDbGljaycsICdvbk1vdXNlTW92ZScsICdvbk1vdXNlRW50ZXInLCAnb25Nb3VzZUxlYXZlJ107XG4gICAgcmV0dXJuIEJhc2UuZWFjaChoYW5kbGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRoaXMuX2V2ZW50c1tuYW1lXSA9IHtcbiAgICAgICAgaW5zdGFsbDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICB0aGlzLmdldFZpZXcoKS5fY291bnRJdGVtRXZlbnQodHlwZSwgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICB0aGlzLmdldFZpZXcoKS5fY291bnRJdGVtRXZlbnQodHlwZSwgLTEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIHtcbiAgICAgIF9ldmVudHM6IHtcbiAgICAgICAgb25GcmFtZToge1xuICAgICAgICAgIGluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCB0cnVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5nZXRWaWV3KCkuX2FuaW1hdGVJdGVtKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uTG9hZDoge30sXG4gICAgICAgIG9uRXJyb3I6IHt9XG4gICAgICB9LFxuICAgICAgc3RhdGljczoge1xuICAgICAgICBfaXRlbUhhbmRsZXJzOiBoYW5kbGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9KCksIHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBJdGVtKCkge30sXG4gICAgX2luaXRpYWxpemU6IGZ1bmN0aW9uIChwcm9wcywgcG9pbnQpIHtcbiAgICAgIHZhciBoYXNQcm9wcyA9IHByb3BzICYmIEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcyksXG4gICAgICAgICAgaW50ZXJuYWwgPSBoYXNQcm9wcyAmJiBwcm9wcy5pbnRlcm5hbCA9PT0gdHJ1ZSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCksXG4gICAgICAgICAgcHJvamVjdCA9IGhhc1Byb3BzICYmIHByb3BzLnByb2plY3QgfHwgcGFwZXIucHJvamVjdCxcbiAgICAgICAgICBzZXR0aW5ncyA9IHBhcGVyLnNldHRpbmdzO1xuICAgICAgdGhpcy5faWQgPSBpbnRlcm5hbCA/IG51bGwgOiBVSUQuZ2V0KCk7XG4gICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9pbmRleCA9IG51bGw7XG4gICAgICB0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmIHNldHRpbmdzLmFwcGx5TWF0cml4O1xuICAgICAgaWYgKHBvaW50KSBtYXRyaXgudHJhbnNsYXRlKHBvaW50KTtcbiAgICAgIG1hdHJpeC5fb3duZXIgPSB0aGlzO1xuICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgU3R5bGUocHJvamVjdC5fY3VycmVudFN0eWxlLCB0aGlzLCBwcm9qZWN0KTtcblxuICAgICAgaWYgKGludGVybmFsIHx8IGhhc1Byb3BzICYmIHByb3BzLmluc2VydCA9PSBmYWxzZSB8fCAhc2V0dGluZ3MuaW5zZXJ0SXRlbXMgJiYgIShoYXNQcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT09IHRydWUpKSB7XG4gICAgICAgIHRoaXMuX3NldFByb2plY3QocHJvamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoaGFzUHJvcHMgJiYgcHJvcHMucGFyZW50IHx8IHByb2plY3QpLl9pbnNlcnRJdGVtKHVuZGVmaW5lZCwgdGhpcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNQcm9wcyAmJiBwcm9wcyAhPT0gSXRlbS5OT19JTlNFUlQpIHtcbiAgICAgICAgdGhpcy5zZXQocHJvcHMsIHtcbiAgICAgICAgICBpbnRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICBpbnNlcnQ6IHRydWUsXG4gICAgICAgICAgcHJvamVjdDogdHJ1ZSxcbiAgICAgICAgICBwYXJlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNQcm9wcztcbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICB2YXIgcHJvcHMgPSB7fSxcbiAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZmllbGRzKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhhdFtrZXldO1xuXG4gICAgICAgICAgaWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwga2V5ID09PSAnbGVhZGluZycgPyBmaWVsZHMuZm9udFNpemUgKiAxLjIgOiBmaWVsZHNba2V5XSkpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucywga2V5ICE9PSAnZGF0YScsIGRpY3Rpb25hcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXJpYWxpemUodGhpcy5fc2VyaWFsaXplRmllbGRzKTtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHcm91cCkpIHNlcmlhbGl6ZSh0aGlzLl9zdHlsZS5fZGVmYXVsdHMpO1xuICAgICAgcmV0dXJuIFt0aGlzLl9jbGFzcywgcHJvcHNdO1xuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uIChmbGFncykge1xuICAgICAgdmFyIHN5bWJvbCA9IHRoaXMuX3N5bWJvbCxcbiAgICAgICAgICBjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCBzeW1ib2wsXG4gICAgICAgICAgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cbiAgICAgIGlmIChmbGFncyAmIDgpIHtcbiAgICAgICAgdGhpcy5fYm91bmRzID0gdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2VkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxhZ3MgJiAxNikge1xuICAgICAgICB0aGlzLl9nbG9iYWxNYXRyaXggPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWNoZVBhcmVudCAmJiBmbGFncyAmIDcyKSB7XG4gICAgICAgIEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUoY2FjaGVQYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICAgIEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9qZWN0KSBwcm9qZWN0Ll9jaGFuZ2VkKGZsYWdzLCB0aGlzKTtcbiAgICAgIGlmIChzeW1ib2wpIHN5bWJvbC5fY2hhbmdlZChmbGFncyk7XG4gICAgfSxcbiAgICBnZXRJZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH0sXG4gICAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfSxcbiAgICBzZXROYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKHRoaXMuX25hbWUpIHRoaXMuX3JlbW92ZU5hbWVkKCk7XG4gICAgICBpZiAobmFtZSA9PT0gK25hbWUgKyAnJykgdGhyb3cgbmV3IEVycm9yKCdOYW1lcyBjb25zaXN0aW5nIG9ubHkgb2YgbnVtYmVycyBhcmUgbm90IHN1cHBvcnRlZC4nKTtcblxuICAgICAgdmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblxuICAgICAgaWYgKG5hbWUgJiYgb3duZXIpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gb3duZXIuX2NoaWxkcmVuLFxuICAgICAgICAgICAgbmFtZWRDaGlsZHJlbiA9IG93bmVyLl9uYW1lZENoaWxkcmVuO1xuICAgICAgICAobmFtZWRDaGlsZHJlbltuYW1lXSA9IG5hbWVkQ2hpbGRyZW5bbmFtZV0gfHwgW10pLnB1c2godGhpcyk7XG4gICAgICAgIGlmICghKG5hbWUgaW4gY2hpbGRyZW4pKSBjaGlsZHJlbltuYW1lXSA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgyNTYpO1xuICAgIH0sXG4gICAgZ2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICB9LFxuICAgIHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIHRoaXMuZ2V0U3R5bGUoKS5zZXQoc3R5bGUpO1xuICAgIH1cbiAgfSwgQmFzZS5lYWNoKFsnbG9ja2VkJywgJ3Zpc2libGUnLCAnYmxlbmRNb2RlJywgJ29wYWNpdHknLCAnZ3VpZGUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcbiAgICAgICAga2V5ID0gJ18nICsgbmFtZSxcbiAgICAgICAgZmxhZ3MgPSB7XG4gICAgICBsb2NrZWQ6IDI1NixcbiAgICAgIHZpc2libGU6IDI2NVxuICAgIH07XG5cbiAgICB0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgIH07XG5cbiAgICB0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSB0aGlzW2tleV0pIHtcbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZChmbGFnc1tuYW1lXSB8fCAyNTcpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIHt9KSwge1xuICAgIGJlYW5zOiB0cnVlLFxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbjtcbiAgICB9LFxuICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gdGhpcy5fc2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXG4gICAgICAgIGlmIChwcm9qZWN0KSB7XG4gICAgICAgICAgcHJvamVjdC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMpO1xuXG4gICAgICAgICAgdGhpcy5fY2hhbmdlZCgyNTcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2hhbmdlU2VsZWN0aW9uOiBmdW5jdGlvbiAoZmxhZywgc2VsZWN0ZWQpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb247XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3RlZCA/IHNlbGVjdGlvbiB8IGZsYWcgOiBzZWxlY3Rpb24gJiB+ZmxhZyk7XG4gICAgfSxcbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGlmIChjaGlsZHJlbltpXS5pc1NlbGVjdGVkKCkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gISEodGhpcy5fc2VsZWN0aW9uICYgMSk7XG4gICAgfSxcbiAgICBzZXRTZWxlY3RlZDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICBpZiAodGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGNoaWxkcmVuW2ldLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hhbmdlU2VsZWN0aW9uKDEsIHNlbGVjdGVkKTtcbiAgICB9LFxuICAgIGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgc2VsZWN0ZWQgPSAhISh0aGlzLl9zZWxlY3Rpb24gJiAxKTtcblxuICAgICAgaWYgKGNoaWxkcmVuICYmIHNlbGVjdGVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBpZiAoIWNoaWxkcmVuW2ldLmlzRnVsbHlTZWxlY3RlZCgpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9LFxuICAgIHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgY2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZChzZWxlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoYW5nZVNlbGVjdGlvbigxLCBzZWxlY3RlZCk7XG4gICAgfSxcbiAgICBpc0NsaXBNYXNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xpcE1hc2s7XG4gICAgfSxcbiAgICBzZXRDbGlwTWFzazogZnVuY3Rpb24gKGNsaXBNYXNrKSB7XG4gICAgICBpZiAodGhpcy5fY2xpcE1hc2sgIT0gKGNsaXBNYXNrID0gISFjbGlwTWFzaykpIHtcbiAgICAgICAgdGhpcy5fY2xpcE1hc2sgPSBjbGlwTWFzaztcblxuICAgICAgICBpZiAoY2xpcE1hc2spIHtcbiAgICAgICAgICB0aGlzLnNldEZpbGxDb2xvcihudWxsKTtcbiAgICAgICAgICB0aGlzLnNldFN0cm9rZUNvbG9yKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCgyNTcpO1xuXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHRoaXMuX3BhcmVudC5fY2hhbmdlZCgyMDQ4KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fZGF0YSkgdGhpcy5fZGF0YSA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfSxcbiAgICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfSxcbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gKF9kb250TGluaykge1xuICAgICAgdmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbiB8fCAodGhpcy5fcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbkZyb21Cb3VuZHMoKSk7XG5cbiAgICAgIHJldHVybiBuZXcgY3Rvcihwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB0aGlzLCAnc2V0UG9zaXRpb24nKTtcbiAgICB9LFxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykuc3VidHJhY3QodGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuICAgIH0sXG4gICAgX2dldFBvc2l0aW9uRnJvbUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90ID8gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh0aGlzLl9waXZvdCkgOiAoYm91bmRzIHx8IHRoaXMuZ2V0Qm91bmRzKCkpLmdldENlbnRlcih0cnVlKTtcbiAgICB9LFxuICAgIGdldFBpdm90OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcbiAgICAgIHJldHVybiBwaXZvdCA/IG5ldyBMaW5rZWRQb2ludChwaXZvdC54LCBwaXZvdC55LCB0aGlzLCAnc2V0UGl2b3QnKSA6IG51bGw7XG4gICAgfSxcbiAgICBzZXRQaXZvdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcGl2b3QgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwge1xuICAgICAgICBjbG9uZTogdHJ1ZSxcbiAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCBCYXNlLmVhY2goe1xuICAgIGdldFN0cm9rZUJvdW5kczoge1xuICAgICAgc3Ryb2tlOiB0cnVlXG4gICAgfSxcbiAgICBnZXRIYW5kbGVCb3VuZHM6IHtcbiAgICAgIGhhbmRsZTogdHJ1ZVxuICAgIH0sXG4gICAgZ2V0SW50ZXJuYWxCb3VuZHM6IHtcbiAgICAgIGludGVybmFsOiB0cnVlXG4gICAgfVxuICB9LCBmdW5jdGlvbiAob3B0aW9ucywga2V5KSB7XG4gICAgdGhpc1trZXldID0gZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKG1hdHJpeCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfSwge1xuICAgIGJlYW5zOiB0cnVlLFxuICAgIGdldEJvdW5kczogZnVuY3Rpb24gKG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgdmFyIGhhc01hdHJpeCA9IG9wdGlvbnMgfHwgbWF0cml4IGluc3RhbmNlb2YgTWF0cml4LFxuICAgICAgICAgIG9wdHMgPSBCYXNlLnNldCh7fSwgaGFzTWF0cml4ID8gb3B0aW9ucyA6IG1hdHJpeCwgdGhpcy5fYm91bmRzT3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdHMuc3Ryb2tlIHx8IHRoaXMuZ2V0U3Ryb2tlU2NhbGluZygpKSBvcHRzLmNhY2hlSXRlbSA9IHRoaXM7XG5cbiAgICAgIHZhciByZWN0ID0gdGhpcy5fZ2V0Q2FjaGVkQm91bmRzKGhhc01hdHJpeCAmJiBtYXRyaXgsIG9wdHMpLnJlY3Q7XG5cbiAgICAgIHJldHVybiAhYXJndW1lbnRzLmxlbmd0aCA/IG5ldyBMaW5rZWRSZWN0YW5nbGUocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCB0aGlzLCAnc2V0Qm91bmRzJykgOiByZWN0O1xuICAgIH0sXG4gICAgc2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcbiAgICAgICAgICBfbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgoKSxcbiAgICAgICAgICBjZW50ZXIgPSByZWN0LmdldENlbnRlcigpO1xuICAgICAgbWF0cml4LnRyYW5zbGF0ZShjZW50ZXIpO1xuXG4gICAgICBpZiAocmVjdC53aWR0aCAhPSBib3VuZHMud2lkdGggfHwgcmVjdC5oZWlnaHQgIT0gYm91bmRzLmhlaWdodCkge1xuICAgICAgICBpZiAoIV9tYXRyaXguaXNJbnZlcnRpYmxlKCkpIHtcbiAgICAgICAgICBfbWF0cml4LnNldChfbWF0cml4Ll9iYWNrdXAgfHwgbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShfbWF0cml4LmdldFRyYW5zbGF0aW9uKCkpKTtcblxuICAgICAgICAgIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXguc2NhbGUoYm91bmRzLndpZHRoICE9PSAwID8gcmVjdC53aWR0aCAvIGJvdW5kcy53aWR0aCA6IDAsIGJvdW5kcy5oZWlnaHQgIT09IDAgPyByZWN0LmhlaWdodCAvIGJvdW5kcy5oZWlnaHQgOiAwKTtcbiAgICAgIH1cblxuICAgICAgY2VudGVyID0gYm91bmRzLmdldENlbnRlcigpO1xuICAgICAgbWF0cml4LnRyYW5zbGF0ZSgtY2VudGVyLngsIC1jZW50ZXIueSk7XG4gICAgICB0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuICAgIH0sXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24gKG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cbiAgICAgIEl0ZW0uX3VwZGF0ZUJvdW5kc0NhY2hlKHRoaXMsIG9wdGlvbnMuY2FjaGVJdGVtKTtcblxuICAgICAgcmV0dXJuIEl0ZW0uX2dldEJvdW5kcyhjaGlsZHJlbiwgbWF0cml4LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIF9nZXRCb3VuZHNDYWNoZUtleTogZnVuY3Rpb24gKG9wdGlvbnMsIGludGVybmFsKSB7XG4gICAgICByZXR1cm4gW29wdGlvbnMuc3Ryb2tlID8gMSA6IDAsIG9wdGlvbnMuaGFuZGxlID8gMSA6IDAsIGludGVybmFsID8gMSA6IDBdLmpvaW4oJycpO1xuICAgIH0sXG4gICAgX2dldENhY2hlZEJvdW5kczogZnVuY3Rpb24gKG1hdHJpeCwgb3B0aW9ucywgbm9JbnRlcm5hbCkge1xuICAgICAgbWF0cml4ID0gbWF0cml4ICYmIG1hdHJpeC5fb3JOdWxsSWZJZGVudGl0eSgpO1xuXG4gICAgICB2YXIgaW50ZXJuYWwgPSBvcHRpb25zLmludGVybmFsICYmICFub0ludGVybmFsLFxuICAgICAgICAgIGNhY2hlSXRlbSA9IG9wdGlvbnMuY2FjaGVJdGVtLFxuICAgICAgICAgIF9tYXRyaXggPSBpbnRlcm5hbCA/IG51bGwgOiB0aGlzLl9tYXRyaXguX29yTnVsbElmSWRlbnRpdHkoKSxcbiAgICAgICAgICBjYWNoZUtleSA9IGNhY2hlSXRlbSAmJiAoIW1hdHJpeCB8fCBtYXRyaXguZXF1YWxzKF9tYXRyaXgpKSAmJiB0aGlzLl9nZXRCb3VuZHNDYWNoZUtleShvcHRpb25zLCBpbnRlcm5hbCksXG4gICAgICAgICAgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgICBJdGVtLl91cGRhdGVCb3VuZHNDYWNoZSh0aGlzLl9wYXJlbnQgfHwgdGhpcy5fc3ltYm9sLCBjYWNoZUl0ZW0pO1xuXG4gICAgICBpZiAoY2FjaGVLZXkgJiYgYm91bmRzICYmIGNhY2hlS2V5IGluIGJvdW5kcykge1xuICAgICAgICB2YXIgY2FjaGVkID0gYm91bmRzW2NhY2hlS2V5XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWN0OiBjYWNoZWQucmVjdC5jbG9uZSgpLFxuICAgICAgICAgIG5vbnNjYWxpbmc6IGNhY2hlZC5ub25zY2FsaW5nXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXMgPSB0aGlzLl9nZXRCb3VuZHMobWF0cml4IHx8IF9tYXRyaXgsIG9wdGlvbnMpLFxuICAgICAgICAgIHJlY3QgPSByZXMucmVjdCB8fCByZXMsXG4gICAgICAgICAgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICBub25zY2FsaW5nID0gcmVzLm5vbnNjYWxpbmcgfHwgc3R5bGUuaGFzU3Ryb2tlKCkgJiYgIXN0eWxlLmdldFN0cm9rZVNjYWxpbmcoKTtcblxuICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgICAgdGhpcy5fYm91bmRzID0gYm91bmRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FjaGVkID0gYm91bmRzW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICByZWN0OiByZWN0LmNsb25lKCksXG4gICAgICAgICAgbm9uc2NhbGluZzogbm9uc2NhbGluZyxcbiAgICAgICAgICBpbnRlcm5hbDogaW50ZXJuYWxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVjdDogcmVjdCxcbiAgICAgICAgbm9uc2NhbGluZzogbm9uc2NhbGluZ1xuICAgICAgfTtcbiAgICB9LFxuICAgIF9nZXRTdHJva2VNYXRyaXg6IGZ1bmN0aW9uIChtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFN0cm9rZVNjYWxpbmcoKSA/IG51bGwgOiBvcHRpb25zICYmIG9wdGlvbnMuaW50ZXJuYWwgPyB0aGlzIDogdGhpcy5fcGFyZW50IHx8IHRoaXMuX3N5bWJvbCAmJiB0aGlzLl9zeW1ib2wuX2l0ZW0sXG4gICAgICAgICAgbXggPSBwYXJlbnQgPyBwYXJlbnQuZ2V0Vmlld01hdHJpeCgpLmludmVydCgpIDogbWF0cml4O1xuICAgICAgcmV0dXJuIG14ICYmIG14Ll9zaGlmdGxlc3MoKTtcbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIF91cGRhdGVCb3VuZHNDYWNoZTogZnVuY3Rpb24gKHBhcmVudCwgaXRlbSkge1xuICAgICAgICBpZiAocGFyZW50ICYmIGl0ZW0pIHtcbiAgICAgICAgICB2YXIgaWQgPSBpdGVtLl9pZCxcbiAgICAgICAgICAgICAgcmVmID0gcGFyZW50Ll9ib3VuZHNDYWNoZSA9IHBhcmVudC5fYm91bmRzQ2FjaGUgfHwge1xuICAgICAgICAgICAgaWRzOiB7fSxcbiAgICAgICAgICAgIGxpc3Q6IFtdXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICghcmVmLmlkc1tpZF0pIHtcbiAgICAgICAgICAgIHJlZi5saXN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICByZWYuaWRzW2lkXSA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2NsZWFyQm91bmRzQ2FjaGU6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGl0ZW0uX2JvdW5kc0NhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIGl0ZW0uX2JvdW5kcyA9IGl0ZW0uX3Bvc2l0aW9uID0gaXRlbS5fYm91bmRzQ2FjaGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNhY2hlLmxpc3QsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgaWYgKG90aGVyICE9PSBpdGVtKSB7XG4gICAgICAgICAgICAgIG90aGVyLl9ib3VuZHMgPSBvdGhlci5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGlmIChvdGhlci5fYm91bmRzQ2FjaGUpIEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUob3RoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uIChpdGVtcywgbWF0cml4LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB4MSA9IEluZmluaXR5LFxuICAgICAgICAgICAgeDIgPSAteDEsXG4gICAgICAgICAgICB5MSA9IHgxLFxuICAgICAgICAgICAgeTIgPSB4MixcbiAgICAgICAgICAgIG5vbnNjYWxpbmcgPSBmYWxzZTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgICAgaWYgKGl0ZW0uX3Zpc2libGUgJiYgIWl0ZW0uaXNFbXB0eSh0cnVlKSkge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGl0ZW0uX2dldENhY2hlZEJvdW5kcyhtYXRyaXggJiYgbWF0cml4LmFwcGVuZGVkKGl0ZW0uX21hdHJpeCksIG9wdGlvbnMsIHRydWUpLFxuICAgICAgICAgICAgICAgIHJlY3QgPSBib3VuZHMucmVjdDtcblxuICAgICAgICAgICAgeDEgPSBNYXRoLm1pbihyZWN0LngsIHgxKTtcbiAgICAgICAgICAgIHkxID0gTWF0aC5taW4ocmVjdC55LCB5MSk7XG4gICAgICAgICAgICB4MiA9IE1hdGgubWF4KHJlY3QueCArIHJlY3Qud2lkdGgsIHgyKTtcbiAgICAgICAgICAgIHkyID0gTWF0aC5tYXgocmVjdC55ICsgcmVjdC5oZWlnaHQsIHkyKTtcbiAgICAgICAgICAgIGlmIChib3VuZHMubm9uc2NhbGluZykgbm9uc2NhbGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWN0OiBpc0Zpbml0ZSh4MSkgPyBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSkgOiBuZXcgUmVjdGFuZ2xlKCksXG4gICAgICAgICAgbm9uc2NhbGluZzogbm9uc2NhbGluZ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSksIHtcbiAgICBiZWFuczogdHJ1ZSxcbiAgICBfZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlNYXRyaXggPyBudWxsIDogdGhpcy5fZGVjb21wb3NlZCB8fCAodGhpcy5fZGVjb21wb3NlZCA9IHRoaXMuX21hdHJpeC5kZWNvbXBvc2UoKSk7XG4gICAgfSxcbiAgICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2UoKTtcblxuICAgICAgcmV0dXJuIGRlY29tcG9zZWQgPyBkZWNvbXBvc2VkLnJvdGF0aW9uIDogMDtcbiAgICB9LFxuICAgIHNldFJvdGF0aW9uOiBmdW5jdGlvbiAocm90YXRpb24pIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXG4gICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIHJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkO1xuICAgICAgICB0aGlzLnJvdGF0ZShyb3RhdGlvbiAtIGN1cnJlbnQpO1xuXG4gICAgICAgIGlmIChkZWNvbXBvc2VkKSB7XG4gICAgICAgICAgZGVjb21wb3NlZC5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgICAgIHRoaXMuX2RlY29tcG9zZWQgPSBkZWNvbXBvc2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRTY2FsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZSgpLFxuICAgICAgICAgIHMgPSBkZWNvbXBvc2VkICYmIGRlY29tcG9zZWQuc2NhbGluZztcblxuICAgICAgcmV0dXJuIG5ldyBMaW5rZWRQb2ludChzID8gcy54IDogMSwgcyA/IHMueSA6IDEsIHRoaXMsICdzZXRTY2FsaW5nJyk7XG4gICAgfSxcbiAgICBzZXRTY2FsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpLFxuICAgICAgICAgIHNjYWxpbmcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwge1xuICAgICAgICBjbG9uZTogdHJ1ZSxcbiAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY3VycmVudCAmJiBzY2FsaW5nICYmICFjdXJyZW50LmVxdWFscyhzY2FsaW5nKSkge1xuICAgICAgICB2YXIgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICAgICAgICBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZCxcbiAgICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgoKSxcbiAgICAgICAgICAgIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cbiAgICAgICAgaWYgKGlzWmVybyhjdXJyZW50LngpIHx8IGlzWmVybyhjdXJyZW50LnkpKSB7XG4gICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShkZWNvbXBvc2VkLnRyYW5zbGF0aW9uKTtcblxuICAgICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgICAgbWF0cml4LnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWF0cml4LnNjYWxlKHNjYWxpbmcueCwgc2NhbGluZy55KTtcblxuICAgICAgICAgIHRoaXMuX21hdHJpeC5zZXQobWF0cml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKTtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKGNlbnRlcik7XG4gICAgICAgICAgaWYgKHJvdGF0aW9uKSBtYXRyaXgucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgICAgICBtYXRyaXguc2NhbGUoc2NhbGluZy54IC8gY3VycmVudC54LCBzY2FsaW5nLnkgLyBjdXJyZW50LnkpO1xuICAgICAgICAgIGlmIChyb3RhdGlvbikgbWF0cml4LnJvdGF0ZSgtcm90YXRpb24pO1xuICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlY29tcG9zZWQpIHtcbiAgICAgICAgICBkZWNvbXBvc2VkLnNjYWxpbmcgPSBzY2FsaW5nO1xuICAgICAgICAgIHRoaXMuX2RlY29tcG9zZWQgPSBkZWNvbXBvc2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXRyaXg7XG4gICAgfSxcbiAgICBzZXRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG4gICAgICBtYXRyaXguc2V0LmFwcGx5KG1hdHJpeCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdldEdsb2JhbE1hdHJpeDogZnVuY3Rpb24gKF9kb250Q2xvbmUpIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXg7XG5cbiAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgdmFyIHBhcmVudHMgPSBbXTtcblxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKCFwYXJlbnQuX2dsb2JhbE1hdHJpeCkge1xuICAgICAgICAgICAgbWF0cml4ID0gbnVsbDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJlbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICBwYXJlbnRzW2ldLl9nbG9iYWxNYXRyaXggPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW1hdHJpeCkge1xuICAgICAgICBtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9tYXRyaXguY2xvbmUoKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkgbWF0cml4LnByZXBlbmQocGFyZW50LmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZG9udENsb25lID8gbWF0cml4IDogbWF0cml4LmNsb25lKCk7XG4gICAgfSxcbiAgICBnZXRWaWV3TWF0cml4OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgoKS5wcmVwZW5kKHRoaXMuZ2V0VmlldygpLl9tYXRyaXgpO1xuICAgIH0sXG4gICAgZ2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseU1hdHJpeDtcbiAgICB9LFxuICAgIHNldEFwcGx5TWF0cml4OiBmdW5jdGlvbiAoYXBwbHkpIHtcbiAgICAgIGlmICh0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmICEhYXBwbHkpIHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0VHJhbnNmb3JtQ29udGVudDogJyNnZXRBcHBseU1hdHJpeCcsXG4gICAgc2V0VHJhbnNmb3JtQ29udGVudDogJyNzZXRBcHBseU1hdHJpeCdcbiAgfSwge1xuICAgIGdldFByb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0O1xuICAgIH0sXG4gICAgX3NldFByb2plY3Q6IGZ1bmN0aW9uIChwcm9qZWN0LCBpbnN0YWxsRXZlbnRzKSB7XG4gICAgICBpZiAodGhpcy5fcHJvamVjdCAhPT0gcHJvamVjdCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvamVjdCkgdGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG4gICAgICAgIHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgY2hpbGRyZW5baV0uX3NldFByb2plY3QocHJvamVjdCk7XG5cbiAgICAgICAgaW5zdGFsbEV2ZW50cyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnN0YWxsRXZlbnRzKSB0aGlzLl9pbnN0YWxsRXZlbnRzKHRydWUpO1xuICAgIH0sXG4gICAgZ2V0VmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3QuX3ZpZXc7XG4gICAgfSxcbiAgICBfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24gX2luc3RhbGxFdmVudHMoaW5zdGFsbCkge1xuICAgICAgX2luc3RhbGxFdmVudHMuYmFzZS5jYWxsKHRoaXMsIGluc3RhbGwpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGNoaWxkcmVuW2ldLl9pbnN0YWxsRXZlbnRzKGluc3RhbGwpO1xuICAgIH0sXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50Ll9wYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIExheWVyKSByZXR1cm4gcGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldFBhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICB9LFxuICAgIHNldFBhcmVudDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmFkZENoaWxkKHRoaXMpO1xuICAgIH0sXG4gICAgX2dldE93bmVyOiAnI2dldFBhcmVudCcsXG4gICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgICB9LFxuICAgIHNldENoaWxkcmVuOiBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcbiAgICAgIHRoaXMuYWRkQ2hpbGRyZW4oaXRlbXMpO1xuICAgIH0sXG4gICAgZ2V0Rmlyc3RDaGlsZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuWzBdIHx8IG51bGw7XG4gICAgfSxcbiAgICBnZXRMYXN0Q2hpbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblt0aGlzLl9jaGlsZHJlbi5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH0sXG4gICAgZ2V0TmV4dFNpYmxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cbiAgICAgIHJldHVybiBvd25lciAmJiBvd25lci5fY2hpbGRyZW5bdGhpcy5faW5kZXggKyAxXSB8fCBudWxsO1xuICAgIH0sXG4gICAgZ2V0UHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXG4gICAgICByZXR1cm4gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuW3RoaXMuX2luZGV4IC0gMV0gfHwgbnVsbDtcbiAgICB9LFxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSA9PT0gdGhpcyB8fCBpdGVtICYmIHRoaXMuX2NsYXNzID09PSBpdGVtLl9jbGFzcyAmJiB0aGlzLl9zdHlsZS5lcXVhbHMoaXRlbS5fc3R5bGUpICYmIHRoaXMuX21hdHJpeC5lcXVhbHMoaXRlbS5fbWF0cml4KSAmJiB0aGlzLl9sb2NrZWQgPT09IGl0ZW0uX2xvY2tlZCAmJiB0aGlzLl92aXNpYmxlID09PSBpdGVtLl92aXNpYmxlICYmIHRoaXMuX2JsZW5kTW9kZSA9PT0gaXRlbS5fYmxlbmRNb2RlICYmIHRoaXMuX29wYWNpdHkgPT09IGl0ZW0uX29wYWNpdHkgJiYgdGhpcy5fY2xpcE1hc2sgPT09IGl0ZW0uX2NsaXBNYXNrICYmIHRoaXMuX2d1aWRlID09PSBpdGVtLl9ndWlkZSAmJiB0aGlzLl9lcXVhbHMoaXRlbSkgfHwgZmFsc2U7XG4gICAgfSxcbiAgICBfZXF1YWxzOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIEJhc2UuZXF1YWxzKHRoaXMuX2NoaWxkcmVuLCBpdGVtLl9jaGlsZHJlbik7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjb3B5ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoSXRlbS5OT19JTlNFUlQpLFxuICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgaW5zZXJ0ID0gQmFzZS5waWNrKG9wdGlvbnMgPyBvcHRpb25zLmluc2VydCA6IHVuZGVmaW5lZCwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMgPT09IHRydWUpLFxuICAgICAgICAgIGRlZXAgPSBCYXNlLnBpY2sob3B0aW9ucyA/IG9wdGlvbnMuZGVlcCA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICBpZiAoY2hpbGRyZW4pIGNvcHkuY29weUF0dHJpYnV0ZXModGhpcyk7XG4gICAgICBpZiAoIWNoaWxkcmVuIHx8IGRlZXApIGNvcHkuY29weUNvbnRlbnQodGhpcyk7XG4gICAgICBpZiAoIWNoaWxkcmVuKSBjb3B5LmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuICAgICAgaWYgKGluc2VydCkgY29weS5pbnNlcnRBYm92ZSh0aGlzKTtcbiAgICAgIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cbiAgICAgIGlmIChuYW1lICYmIHBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NoaWxkcmVuLFxuICAgICAgICAgICAgb3JpZyA9IG5hbWUsXG4gICAgICAgICAgICBpID0gMTtcblxuICAgICAgICB3aGlsZSAoY2hpbGRyZW5bbmFtZV0pIG5hbWUgPSBvcmlnICsgJyAnICsgaSsrO1xuXG4gICAgICAgIGlmIChuYW1lICE9PSBvcmlnKSBjb3B5LnNldE5hbWUobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sXG4gICAgY29weUNvbnRlbnQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHNvdXJjZS5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoY2hpbGRyZW5baV0uY2xvbmUoZmFsc2UpLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvcHlBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoc291cmNlLCBleGNsdWRlTWF0cml4KSB7XG4gICAgICB0aGlzLnNldFN0eWxlKHNvdXJjZS5fc3R5bGUpO1xuICAgICAgdmFyIGtleXMgPSBbJ19sb2NrZWQnLCAnX3Zpc2libGUnLCAnX2JsZW5kTW9kZScsICdfb3BhY2l0eScsICdfY2xpcE1hc2snLCAnX2d1aWRlJ107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkgdGhpc1trZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhjbHVkZU1hdHJpeCkgdGhpcy5fbWF0cml4LnNldChzb3VyY2UuX21hdHJpeCwgdHJ1ZSk7XG4gICAgICB0aGlzLnNldEFwcGx5TWF0cml4KHNvdXJjZS5fYXBwbHlNYXRyaXgpO1xuICAgICAgdGhpcy5zZXRQaXZvdChzb3VyY2UuX3Bpdm90KTtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNvdXJjZS5fc2VsZWN0aW9uKTtcbiAgICAgIHZhciBkYXRhID0gc291cmNlLl9kYXRhLFxuICAgICAgICAgIG5hbWUgPSBzb3VyY2UuX25hbWU7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YSA/IEJhc2UuY2xvbmUoZGF0YSkgOiBudWxsO1xuICAgICAgaWYgKG5hbWUpIHRoaXMuc2V0TmFtZShuYW1lKTtcbiAgICB9LFxuICAgIHJhc3Rlcml6ZTogZnVuY3Rpb24gKHJlc29sdXRpb24sIGluc2VydCkge1xuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKCksXG4gICAgICAgICAgc2NhbGUgPSAocmVzb2x1dGlvbiB8fCB0aGlzLmdldFZpZXcoKS5nZXRSZXNvbHV0aW9uKCkpIC8gNzIsXG4gICAgICAgICAgdG9wTGVmdCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKSxcbiAgICAgICAgICBib3R0b21SaWdodCA9IGJvdW5kcy5nZXRCb3R0b21SaWdodCgpLmNlaWwoKSxcbiAgICAgICAgICBzaXplID0gbmV3IFNpemUoYm90dG9tUmlnaHQuc3VidHJhY3QodG9wTGVmdCkpLFxuICAgICAgICAgIHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXG4gICAgICBpZiAoIXNpemUuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplLm11bHRpcGx5KHNjYWxlKSksXG4gICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZShzY2FsZSkudHJhbnNsYXRlKHRvcExlZnQubmVnYXRlKCkpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcbiAgICAgICAgdGhpcy5kcmF3KGN0eCwgbmV3IEJhc2Uoe1xuICAgICAgICAgIG1hdHJpY2VzOiBbbWF0cml4XVxuICAgICAgICB9KSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHJhc3Rlci5zZXRDYW52YXMoY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgcmFzdGVyLnRyYW5zZm9ybShuZXcgTWF0cml4KCkudHJhbnNsYXRlKHRvcExlZnQuYWRkKHNpemUuZGl2aWRlKDIpKSkuc2NhbGUoMSAvIHNjYWxlKSk7XG4gICAgICBpZiAoaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgaW5zZXJ0KSByYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICByZXR1cm4gcmFzdGVyO1xuICAgIH0sXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG4gICAgICByZXR1cm4gbWF0cml4LmlzSW52ZXJ0aWJsZSgpICYmICEhdGhpcy5fY29udGFpbnMobWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuICAgIH0sXG4gICAgX2NvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmNvbnRhaW5zKHBvaW50KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb2ludC5pc0luc2lkZSh0aGlzLmdldEludGVybmFsQm91bmRzKCkpO1xuICAgIH0sXG4gICAgaXNJbnNpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMuZ2V0Qm91bmRzKCkpO1xuICAgIH0sXG4gICAgX2FzUGF0aEl0ZW06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUGF0aC5SZWN0YW5nbGUoe1xuICAgICAgICByZWN0YW5nbGU6IHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSxcbiAgICAgICAgbWF0cml4OiB0aGlzLl9tYXRyaXgsXG4gICAgICAgIGluc2VydDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0czogZnVuY3Rpb24gKGl0ZW0sIF9tYXRyaXgpIHtcbiAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBJdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuX2FzUGF0aEl0ZW0oKS5nZXRJbnRlcnNlY3Rpb25zKGl0ZW0uX2FzUGF0aEl0ZW0oKSwgbnVsbCwgX21hdHJpeCwgdHJ1ZSkubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaGl0VGVzdCgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIHRoaXMuX2hpdFRlc3QoUG9pbnQucmVhZChhcmdzKSwgSGl0UmVzdWx0LmdldE9wdGlvbnMoYXJncykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhpdFRlc3RBbGwoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBwb2ludCA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgb3B0aW9ucyA9IEhpdFJlc3VsdC5nZXRPcHRpb25zKGFyZ3MpLFxuICAgICAgICAgIGFsbCA9IFtdO1xuXG4gICAgICB0aGlzLl9oaXRUZXN0KHBvaW50LCBuZXcgQmFzZSh7XG4gICAgICAgIGFsbDogYWxsXG4gICAgICB9LCBvcHRpb25zKSk7XG5cbiAgICAgIHJldHVybiBhbGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGl0VGVzdENoaWxkcmVuKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LCBfZXhjbHVkZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgIHZhciByZXMgPSBjaGlsZCAhPT0gX2V4Y2x1ZGUgJiYgY2hpbGQuX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpO1xuXG4gICAgICAgICAgaWYgKHJlcyAmJiAhb3B0aW9ucy5hbGwpIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgUHJvamVjdC5pbmplY3Qoe1xuICAgICAgaGl0VGVzdDogaGl0VGVzdCxcbiAgICAgIGhpdFRlc3RBbGw6IGhpdFRlc3RBbGwsXG4gICAgICBfaGl0VGVzdDogaGl0VGVzdENoaWxkcmVuXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpdFRlc3Q6IGhpdFRlc3QsXG4gICAgICBoaXRUZXN0QWxsOiBoaXRUZXN0QWxsLFxuICAgICAgX2hpdFRlc3RDaGlsZHJlbjogaGl0VGVzdENoaWxkcmVuXG4gICAgfTtcbiAgfSgpLCB7XG4gICAgX2hpdFRlc3Q6IGZ1bmN0aW9uIChwb2ludCwgb3B0aW9ucywgcGFyZW50Vmlld01hdHJpeCkge1xuICAgICAgaWYgKHRoaXMuX2xvY2tlZCB8fCAhdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9ndWlkZSAmJiAhb3B0aW9ucy5ndWlkZXMgfHwgdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG4gICAgICAgICAgdmlld01hdHJpeCA9IHBhcmVudFZpZXdNYXRyaXggPyBwYXJlbnRWaWV3TWF0cml4LmFwcGVuZGVkKG1hdHJpeCkgOiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLnByZXBlbmQodGhpcy5nZXRWaWV3KCkuX21hdHJpeCksXG4gICAgICAgICAgdG9sZXJhbmNlID0gTWF0aC5tYXgob3B0aW9ucy50b2xlcmFuY2UsIDFlLTEyKSxcbiAgICAgICAgICB0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyA9IG5ldyBTaXplKFBhdGguX2dldFN0cm9rZVBhZGRpbmcodG9sZXJhbmNlLCBtYXRyaXguX3NoaWZ0bGVzcygpLmludmVydCgpKSk7XG4gICAgICBwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShwb2ludCk7XG5cbiAgICAgIGlmICghcG9pbnQgfHwgIXRoaXMuX2NoaWxkcmVuICYmICF0aGlzLmdldEJvdW5kcyh7XG4gICAgICAgIGludGVybmFsOiB0cnVlLFxuICAgICAgICBzdHJva2U6IHRydWUsXG4gICAgICAgIGhhbmRsZTogdHJ1ZVxuICAgICAgfSkuZXhwYW5kKHRvbGVyYW5jZVBhZGRpbmcubXVsdGlwbHkoMikpLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoZWNrU2VsZiA9ICEob3B0aW9ucy5ndWlkZXMgJiYgIXRoaXMuX2d1aWRlIHx8IG9wdGlvbnMuc2VsZWN0ZWQgJiYgIXRoaXMuaXNTZWxlY3RlZCgpIHx8IG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgIT09IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKSB8fCBvcHRpb25zLmNsYXNzICYmICEodGhpcyBpbnN0YW5jZW9mIG9wdGlvbnMuY2xhc3MpKSxcbiAgICAgICAgICBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgYm91bmRzLFxuICAgICAgICAgIHJlcztcblxuICAgICAgZnVuY3Rpb24gZmlsdGVyKGhpdCkge1xuICAgICAgICBpZiAoaGl0ICYmIG1hdGNoICYmICFtYXRjaChoaXQpKSBoaXQgPSBudWxsO1xuICAgICAgICBpZiAoaGl0ICYmIG9wdGlvbnMuYWxsKSBvcHRpb25zLmFsbC5wdXNoKGhpdCk7XG4gICAgICAgIHJldHVybiBoaXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUG9pbnQodHlwZSwgcGFydCkge1xuICAgICAgICB2YXIgcHQgPSBwYXJ0ID8gYm91bmRzWydnZXQnICsgcGFydF0oKSA6IHRoYXQuZ2V0UG9zaXRpb24oKTtcblxuICAgICAgICBpZiAocG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZSh0b2xlcmFuY2VQYWRkaW5nKS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgSGl0UmVzdWx0KHR5cGUsIHRoYXQsIHtcbiAgICAgICAgICAgIG5hbWU6IHBhcnQgPyBCYXNlLmh5cGhlbmF0ZShwYXJ0KSA6IHR5cGUsXG4gICAgICAgICAgICBwb2ludDogcHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2hlY2tQb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb24sXG4gICAgICAgICAgY2hlY2tDZW50ZXIgPSBvcHRpb25zLmNlbnRlcixcbiAgICAgICAgICBjaGVja0JvdW5kcyA9IG9wdGlvbnMuYm91bmRzO1xuXG4gICAgICBpZiAoY2hlY2tTZWxmICYmIHRoaXMuX3BhcmVudCAmJiAoY2hlY2tQb3NpdGlvbiB8fCBjaGVja0NlbnRlciB8fCBjaGVja0JvdW5kcykpIHtcbiAgICAgICAgaWYgKGNoZWNrQ2VudGVyIHx8IGNoZWNrQm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzID0gdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzID0gY2hlY2tQb3NpdGlvbiAmJiBjaGVja1BvaW50KCdwb3NpdGlvbicpIHx8IGNoZWNrQ2VudGVyICYmIGNoZWNrUG9pbnQoJ2NlbnRlcicsICdDZW50ZXInKTtcblxuICAgICAgICBpZiAoIXJlcyAmJiBjaGVja0JvdW5kcykge1xuICAgICAgICAgIHZhciBwb2ludHMgPSBbJ1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsICdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgOCAmJiAhcmVzOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyA9IGNoZWNrUG9pbnQoJ2JvdW5kcycsIHBvaW50c1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzID0gZmlsdGVyKHJlcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJlcyA9IHRoaXMuX2hpdFRlc3RDaGlsZHJlbihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCkgfHwgY2hlY2tTZWxmICYmIGZpbHRlcih0aGlzLl9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCwgdGhpcy5nZXRTdHJva2VTY2FsaW5nKCkgPyBudWxsIDogdmlld01hdHJpeC5fc2hpZnRsZXNzKCkuaW52ZXJ0KCkpKSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzICYmIHJlcy5wb2ludCkge1xuICAgICAgICByZXMucG9pbnQgPSBtYXRyaXgudHJhbnNmb3JtKHJlcy5wb2ludCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uIChwb2ludCwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuZmlsbCAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLl9jb250YWlucyhwb2ludCkpIHJldHVybiBuZXcgSGl0UmVzdWx0KCdmaWxsJywgdGhpcyk7XG4gICAgfSxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiAobmFtZSwgY29tcGFyZSkge1xuICAgICAgZnVuY3Rpb24gbWF0Y2hPYmplY3Qob2JqMSwgb2JqMikge1xuICAgICAgICBmb3IgKHZhciBpIGluIG9iajEpIHtcbiAgICAgICAgICBpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgdmFyIHZhbDEgPSBvYmoxW2ldLFxuICAgICAgICAgICAgICAgIHZhbDIgPSBvYmoyW2ldO1xuXG4gICAgICAgICAgICBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KHZhbDEpICYmIEJhc2UuaXNQbGFpbk9iamVjdCh2YWwyKSkge1xuICAgICAgICAgICAgICBpZiAoIW1hdGNoT2JqZWN0KHZhbDEsIHZhbDIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWwxLCB2YWwyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIG5hbWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRoaXMubWF0Y2hlcyhrZXksIG5hbWVba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuYW1lKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnbWF0Y2gnKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlID0gL14oZW1wdHl8ZWRpdGFibGUpJC8udGVzdChuYW1lKSA/IHRoaXNbJ2lzJyArIEJhc2UuY2FwaXRhbGl6ZShuYW1lKV0oKSA6IG5hbWUgPT09ICd0eXBlJyA/IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKSA6IHRoaXNbbmFtZV07XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzIGluc3RhbmNlb2YgY29tcGFyZTtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2NsYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuICEhY29tcGFyZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcGFyZSkge1xuICAgICAgICAgIGlmIChjb21wYXJlLnRlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlLnRlc3QodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGNvbXBhcmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hPYmplY3QoY29tcGFyZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBCYXNlLmVxdWFscyh2YWx1ZSwgY29tcGFyZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRJdGVtczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLCBvcHRpb25zLCB0aGlzLl9tYXRyaXgpO1xuICAgIH0sXG4gICAgZ2V0SXRlbTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLCBvcHRpb25zLCB0aGlzLl9tYXRyaXgsIG51bGwsIHRydWUpWzBdIHx8IG51bGw7XG4gICAgfSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBfZ2V0SXRlbXM6IGZ1bmN0aW9uIF9nZXRJdGVtcyhpdGVtLCBvcHRpb25zLCBtYXRyaXgsIHBhcmFtLCBmaXJzdE9ubHkpIHtcbiAgICAgICAgaWYgKCFwYXJhbSkge1xuICAgICAgICAgIHZhciBvYmogPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyxcbiAgICAgICAgICAgICAgb3ZlcmxhcHBpbmcgPSBvYmogJiYgb2JqLm92ZXJsYXBwaW5nLFxuICAgICAgICAgICAgICBpbnNpZGUgPSBvYmogJiYgb2JqLmluc2lkZSxcbiAgICAgICAgICAgICAgYm91bmRzID0gb3ZlcmxhcHBpbmcgfHwgaW5zaWRlLFxuICAgICAgICAgICAgICByZWN0ID0gYm91bmRzICYmIFJlY3RhbmdsZS5yZWFkKFtib3VuZHNdKTtcbiAgICAgICAgICBwYXJhbSA9IHtcbiAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZTogb2JqICYmIG9iai5yZWN1cnNpdmUgIT09IGZhbHNlLFxuICAgICAgICAgICAgaW5zaWRlOiAhIWluc2lkZSxcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nOiAhIW92ZXJsYXBwaW5nLFxuICAgICAgICAgICAgcmVjdDogcmVjdCxcbiAgICAgICAgICAgIHBhdGg6IG92ZXJsYXBwaW5nICYmIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG4gICAgICAgICAgICAgIHJlY3RhbmdsZTogcmVjdCxcbiAgICAgICAgICAgICAgaW5zZXJ0OiBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IEJhc2UuZmlsdGVyKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgaW5zaWRlOiB0cnVlLFxuICAgICAgICAgICAgICBvdmVybGFwcGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbS5fY2hpbGRyZW4sXG4gICAgICAgICAgICBpdGVtcyA9IHBhcmFtLml0ZW1zLFxuICAgICAgICAgICAgcmVjdCA9IHBhcmFtLnJlY3Q7XG4gICAgICAgIG1hdHJpeCA9IHJlY3QgJiYgKG1hdHJpeCB8fCBuZXcgTWF0cml4KCkpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG4gICAgICAgICAgICAgIGNoaWxkTWF0cml4ID0gbWF0cml4ICYmIG1hdHJpeC5hcHBlbmRlZChjaGlsZC5fbWF0cml4KSxcbiAgICAgICAgICAgICAgYWRkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gY2hpbGQuZ2V0Qm91bmRzKGNoaWxkTWF0cml4KTtcbiAgICAgICAgICAgIGlmICghcmVjdC5pbnRlcnNlY3RzKGJvdW5kcykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCEocmVjdC5jb250YWlucyhib3VuZHMpIHx8IHBhcmFtLm92ZXJsYXBwaW5nICYmIChib3VuZHMuY29udGFpbnMocmVjdCkgfHwgcGFyYW0ucGF0aC5pbnRlcnNlY3RzKGNoaWxkLCBjaGlsZE1hdHJpeCkpKSkgYWRkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFkZCAmJiBjaGlsZC5tYXRjaGVzKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChmaXJzdE9ubHkpIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJhbS5yZWN1cnNpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfZ2V0SXRlbXMoY2hpbGQsIG9wdGlvbnMsIGNoaWxkTWF0cml4LCBwYXJhbSwgZmlyc3RPbmx5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmlyc3RPbmx5ICYmIGl0ZW1zLmxlbmd0aCA+IDApIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGltcG9ydEpTT046IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICB2YXIgcmVzID0gQmFzZS5pbXBvcnRKU09OKGpzb24sIHRoaXMpO1xuICAgICAgcmV0dXJuIHJlcyAhPT0gdGhpcyA/IHRoaXMuYWRkQ2hpbGQocmVzKSA6IHJlcztcbiAgICB9LFxuICAgIGFkZENoaWxkOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQodW5kZWZpbmVkLCBpdGVtKTtcbiAgICB9LFxuICAgIGluc2VydENoaWxkOiBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgIHZhciByZXMgPSBpdGVtID8gdGhpcy5pbnNlcnRDaGlsZHJlbihpbmRleCwgW2l0ZW1dKSA6IG51bGw7XG4gICAgICByZXR1cm4gcmVzICYmIHJlc1swXTtcbiAgICB9LFxuICAgIGFkZENoaWxkcmVuOiBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydENoaWxkcmVuKHRoaXMuX2NoaWxkcmVuLmxlbmd0aCwgaXRlbXMpO1xuICAgIH0sXG4gICAgaW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uIChpbmRleCwgaXRlbXMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gJiYgaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpdGVtcyA9IEJhc2Uuc2xpY2UoaXRlbXMpO1xuICAgICAgICB2YXIgaW5zZXJ0ZWQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldLFxuICAgICAgICAgICAgICBpZCA9IGl0ZW0gJiYgaXRlbS5faWQ7XG5cbiAgICAgICAgICBpZiAoIWl0ZW0gfHwgaW5zZXJ0ZWRbaWRdKSB7XG4gICAgICAgICAgICBpdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0uX3JlbW92ZShmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGluc2VydGVkW2lkXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgQmFzZS5zcGxpY2UoY2hpbGRyZW4sIGl0ZW1zLCBpbmRleCwgMCk7XG4gICAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcbiAgICAgICAgICAgIG5vdGlmeVNlbGYgPSBwcm9qZWN0Ll9jaGFuZ2VzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXSxcbiAgICAgICAgICAgICAgbmFtZSA9IGl0ZW0uX25hbWU7XG4gICAgICAgICAgaXRlbS5fcGFyZW50ID0gdGhpcztcblxuICAgICAgICAgIGl0ZW0uX3NldFByb2plY3QocHJvamVjdCwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAobmFtZSkgaXRlbS5zZXROYW1lKG5hbWUpO1xuICAgICAgICAgIGlmIChub3RpZnlTZWxmKSBpdGVtLl9jaGFuZ2VkKDUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCgxMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuICAgIF9pbnNlcnRJdGVtOiAnI2luc2VydENoaWxkJyxcbiAgICBfaW5zZXJ0QXQ6IGZ1bmN0aW9uIChpdGVtLCBvZmZzZXQpIHtcbiAgICAgIHZhciBvd25lciA9IGl0ZW0gJiYgaXRlbS5fZ2V0T3duZXIoKSxcbiAgICAgICAgICByZXMgPSBpdGVtICE9PSB0aGlzICYmIG93bmVyID8gdGhpcyA6IG51bGw7XG5cbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgcmVzLl9yZW1vdmUoZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIG93bmVyLl9pbnNlcnRJdGVtKGl0ZW0uX2luZGV4ICsgb2Zmc2V0LCByZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgaW5zZXJ0QWJvdmU6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5zZXJ0QXQoaXRlbSwgMSk7XG4gICAgfSxcbiAgICBpbnNlcnRCZWxvdzogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRBdChpdGVtLCAwKTtcbiAgICB9LFxuICAgIHNlbmRUb0JhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cbiAgICAgIHJldHVybiBvd25lciA/IG93bmVyLl9pbnNlcnRJdGVtKDAsIHRoaXMpIDogbnVsbDtcbiAgICB9LFxuICAgIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblxuICAgICAgcmV0dXJuIG93bmVyID8gb3duZXIuX2luc2VydEl0ZW0odW5kZWZpbmVkLCB0aGlzKSA6IG51bGw7XG4gICAgfSxcbiAgICBhcHBlbmRUb3A6ICcjYWRkQ2hpbGQnLFxuICAgIGFwcGVuZEJvdHRvbTogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydENoaWxkKDAsIGl0ZW0pO1xuICAgIH0sXG4gICAgbW92ZUFib3ZlOiAnI2luc2VydEFib3ZlJyxcbiAgICBtb3ZlQmVsb3c6ICcjaW5zZXJ0QmVsb3cnLFxuICAgIGFkZFRvOiBmdW5jdGlvbiAob3duZXIpIHtcbiAgICAgIHJldHVybiBvd25lci5faW5zZXJ0SXRlbSh1bmRlZmluZWQsIHRoaXMpO1xuICAgIH0sXG4gICAgY29weVRvOiBmdW5jdGlvbiAob3duZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKGZhbHNlKS5hZGRUbyhvd25lcik7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlblswXS5yZWR1Y2Uob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgIGNoaWxkLmluc2VydEFib3ZlKHRoaXMpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX3JlbW92ZU5hbWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gb3duZXIuX2NoaWxkcmVuLFxuICAgICAgICAgICAgbmFtZWRDaGlsZHJlbiA9IG93bmVyLl9uYW1lZENoaWxkcmVuLFxuICAgICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICAgICAgICBuYW1lZEFycmF5ID0gbmFtZWRDaGlsZHJlbltuYW1lXSxcbiAgICAgICAgICAgIGluZGV4ID0gbmFtZWRBcnJheSA/IG5hbWVkQXJyYXkuaW5kZXhPZih0aGlzKSA6IC0xO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5bbmFtZV0gPT0gdGhpcykgZGVsZXRlIGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIG5hbWVkQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgIGlmIChuYW1lZEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgY2hpbGRyZW5bbmFtZV0gPSBuYW1lZEFycmF5WzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgbmFtZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9yZW1vdmU6IGZ1bmN0aW9uIChub3RpZnlTZWxmLCBub3RpZnlQYXJlbnQpIHtcbiAgICAgIHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCksXG4gICAgICAgICAgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG4gICAgICAgICAgaW5kZXggPSB0aGlzLl9pbmRleDtcblxuICAgICAgaWYgKHRoaXMuX3N0eWxlKSB0aGlzLl9zdHlsZS5fZGlzcG9zZSgpO1xuXG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX25hbWUpIHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAocHJvamVjdC5fYWN0aXZlTGF5ZXIgPT09IHRoaXMpIHByb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcy5nZXROZXh0U2libGluZygpIHx8IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgICAgQmFzZS5zcGxpY2Uob3duZXIuX2NoaWxkcmVuLCBudWxsLCBpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblxuICAgICAgICBpZiAobm90aWZ5U2VsZiAmJiBwcm9qZWN0Ll9jaGFuZ2VzKSB0aGlzLl9jaGFuZ2VkKDUpO1xuICAgICAgICBpZiAobm90aWZ5UGFyZW50KSBvd25lci5fY2hhbmdlZCgxMSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBvayA9IGl0ZW0gJiYgaXRlbS5pbnNlcnRCZWxvdyh0aGlzKTtcbiAgICAgIGlmIChvaykgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybiBvaztcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkcmVuOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCF0aGlzLl9jaGlsZHJlbikgcmV0dXJuIG51bGw7XG4gICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICBlbmQgPSBCYXNlLnBpY2soZW5kLCB0aGlzLl9jaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgdmFyIHJlbW92ZWQgPSBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgbnVsbCwgc3RhcnQsIGVuZCAtIHN0YXJ0KTtcblxuICAgICAgZm9yICh2YXIgaSA9IHJlbW92ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVtb3ZlZFtpXS5fcmVtb3ZlKHRydWUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoID4gMCkgdGhpcy5fY2hhbmdlZCgxMSk7XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuICAgIGNsZWFyOiAnI3JlbW92ZUNoaWxkcmVuJyxcbiAgICByZXZlcnNlQ2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbi5yZXZlcnNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHRoaXMuX2NoaWxkcmVuW2ldLl9pbmRleCA9IGk7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCgxMSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAocmVjdXJzaXZlbHkpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgdmFyIG51bUNoaWxkcmVuID0gY2hpbGRyZW4gPyBjaGlsZHJlbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAocmVjdXJzaXZlbHkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1DaGlsZHJlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFjaGlsZHJlbltpXS5pc0VtcHR5KHJlY3Vyc2l2ZWx5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIW51bUNoaWxkcmVuO1xuICAgIH0sXG4gICAgaXNFZGl0YWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzO1xuXG4gICAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0uX3Zpc2libGUgfHwgaXRlbS5fbG9ja2VkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGl0ZW0gPSBpdGVtLl9wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaGFzRmlsbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNGaWxsKCk7XG4gICAgfSxcbiAgICBoYXNTdHJva2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU3Ryb2tlKCk7XG4gICAgfSxcbiAgICBoYXNTaGFkb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU2hhZG93KCk7XG4gICAgfSxcbiAgICBfZ2V0T3JkZXI6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBmdW5jdGlvbiBnZXRMaXN0KGl0ZW0pIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgbGlzdC51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICB9IHdoaWxlIChpdGVtID0gaXRlbS5fcGFyZW50KTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpc3QxID0gZ2V0TGlzdCh0aGlzKSxcbiAgICAgICAgICBsaXN0MiA9IGdldExpc3QoaXRlbSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gTWF0aC5taW4obGlzdDEubGVuZ3RoLCBsaXN0Mi5sZW5ndGgpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0MVtpXSAhPSBsaXN0MltpXSkge1xuICAgICAgICAgIHJldHVybiBsaXN0MVtpXS5faW5kZXggPCBsaXN0MltpXS5faW5kZXggPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBoYXNDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA+IDA7XG4gICAgfSxcbiAgICBpc0luc2VydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmlzSW5zZXJ0ZWQoKSA6IGZhbHNlO1xuICAgIH0sXG4gICAgaXNBYm92ZTogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRPcmRlcihpdGVtKSA9PT0gLTE7XG4gICAgfSxcbiAgICBpc0JlbG93OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAxO1xuICAgIH0sXG4gICAgaXNQYXJlbnQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID09PSBpdGVtO1xuICAgIH0sXG4gICAgaXNDaGlsZDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtICYmIGl0ZW0uX3BhcmVudCA9PT0gdGhpcztcbiAgICB9LFxuICAgIGlzRGVzY2VuZGFudDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50Ll9wYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gaXRlbSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGlzQW5jZXN0b3I6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaXNEZXNjZW5kYW50KHRoaXMpIDogZmFsc2U7XG4gICAgfSxcbiAgICBpc1NpYmxpbmc6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID09PSBpdGVtLl9wYXJlbnQ7XG4gICAgfSxcbiAgICBpc0dyb3VwZWRXaXRoOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblxuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50Ll9wYXJlbnQgJiYgL14oR3JvdXB8TGF5ZXJ8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcykgJiYgaXRlbS5pc0Rlc2NlbmRhbnQocGFyZW50KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBCYXNlLmVhY2goWydyb3RhdGUnLCAnc2NhbGUnLCAnc2hlYXInLCAnc2tldyddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJvdGF0ZSA9IGtleSA9PT0gJ3JvdGF0ZSc7XG5cbiAgICB0aGlzW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICB2YWx1ZSA9IChyb3RhdGUgPyBCYXNlIDogUG9pbnQpLnJlYWQoYXJncyksXG4gICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZChhcmdzLCAwLCB7XG4gICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KClba2V5XSh2YWx1ZSwgY2VudGVyIHx8IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcbiAgICB9O1xuICB9LCB7XG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbXggPSBuZXcgTWF0cml4KCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obXgudHJhbnNsYXRlLmFwcGx5KG14LCBhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKG1hdHJpeCwgX2FwcGx5UmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkge1xuICAgICAgdmFyIF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG4gICAgICAgICAgdHJhbnNmb3JtTWF0cml4ID0gbWF0cml4ICYmICFtYXRyaXguaXNJZGVudGl0eSgpLFxuICAgICAgICAgIGFwcGx5TWF0cml4ID0gX3NldEFwcGx5TWF0cml4ICYmIHRoaXMuX2NhbkFwcGx5TWF0cml4IHx8IHRoaXMuX2FwcGx5TWF0cml4ICYmICh0cmFuc2Zvcm1NYXRyaXggfHwgIV9tYXRyaXguaXNJZGVudGl0eSgpIHx8IF9hcHBseVJlY3Vyc2l2ZWx5ICYmIHRoaXMuX2NoaWxkcmVuKTtcbiAgICAgIGlmICghdHJhbnNmb3JtTWF0cml4ICYmICFhcHBseU1hdHJpeCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgaWYgKCFtYXRyaXguaXNJbnZlcnRpYmxlKCkgJiYgX21hdHJpeC5pc0ludmVydGlibGUoKSkgX21hdHJpeC5fYmFja3VwID0gX21hdHJpeC5nZXRWYWx1ZXMoKTtcblxuICAgICAgICBfbWF0cml4LnByZXBlbmQobWF0cml4LCB0cnVlKTtcblxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICAgIGZpbGxDb2xvciA9IHN0eWxlLmdldEZpbGxDb2xvcih0cnVlKSxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IodHJ1ZSk7XG4gICAgICAgIGlmIChmaWxsQ29sb3IpIGZpbGxDb2xvci50cmFuc2Zvcm0obWF0cml4KTtcbiAgICAgICAgaWYgKHN0cm9rZUNvbG9yKSBzdHJva2VDb2xvci50cmFuc2Zvcm0obWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFwcGx5TWF0cml4ICYmIChhcHBseU1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybUNvbnRlbnQoX21hdHJpeCwgX2FwcGx5UmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkpKSB7XG4gICAgICAgIHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuICAgICAgICBpZiAocGl2b3QpIF9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90LCBwaXZvdCwgdHJ1ZSk7XG5cbiAgICAgICAgX21hdHJpeC5yZXNldCh0cnVlKTtcblxuICAgICAgICBpZiAoX3NldEFwcGx5TWF0cml4ICYmIHRoaXMuX2NhbkFwcGx5TWF0cml4KSB0aGlzLl9hcHBseU1hdHJpeCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHMsXG4gICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcblxuICAgICAgaWYgKHRyYW5zZm9ybU1hdHJpeCB8fCBhcHBseU1hdHJpeCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKDI1KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlY29tcCA9IHRyYW5zZm9ybU1hdHJpeCAmJiBib3VuZHMgJiYgbWF0cml4LmRlY29tcG9zZSgpO1xuXG4gICAgICBpZiAoZGVjb21wICYmIGRlY29tcC5za2V3aW5nLmlzWmVybygpICYmIGRlY29tcC5yb3RhdGlvbiAlIDkwID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBib3VuZHMpIHtcbiAgICAgICAgICB2YXIgY2FjaGUgPSBib3VuZHNba2V5XTtcblxuICAgICAgICAgIGlmIChjYWNoZS5ub25zY2FsaW5nKSB7XG4gICAgICAgICAgICBkZWxldGUgYm91bmRzW2tleV07XG4gICAgICAgICAgfSBlbHNlIGlmIChhcHBseU1hdHJpeCB8fCAhY2FjaGUuaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gY2FjaGUucmVjdDtcblxuICAgICAgICAgICAgbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCwgcmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYm91bmRzID0gYm91bmRzO1xuXG4gICAgICAgIHZhciBjYWNoZWQgPSBib3VuZHNbdGhpcy5fZ2V0Qm91bmRzQ2FjaGVLZXkodGhpcy5fYm91bmRzT3B0aW9ucyB8fCB7fSldO1xuXG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uRnJvbUJvdW5kcyhjYWNoZWQucmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtTWF0cml4ICYmIHBvc2l0aW9uICYmIHRoaXMuX3Bpdm90KSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb3NpdGlvbiwgcG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbiAobWF0cml4LCBhcHBseVJlY3Vyc2l2ZWx5LCBzZXRBcHBseU1hdHJpeCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnRyYW5zZm9ybShtYXRyaXgsIGFwcGx5UmVjdXJzaXZlbHksIHNldEFwcGx5TWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2xvYmFsVG9Mb2NhbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpLl9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBsb2NhbFRvR2xvYmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkuX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBwYXJlbnRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBsb2NhbFRvUGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbiAocmVjdGFuZ2xlLCBmaWxsKSB7XG4gICAgICByZWN0YW5nbGUgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG4gICAgICAgICAgaXRlbVJhdGlvID0gYm91bmRzLmhlaWdodCAvIGJvdW5kcy53aWR0aCxcbiAgICAgICAgICByZWN0UmF0aW8gPSByZWN0YW5nbGUuaGVpZ2h0IC8gcmVjdGFuZ2xlLndpZHRoLFxuICAgICAgICAgIHNjYWxlID0gKGZpbGwgPyBpdGVtUmF0aW8gPiByZWN0UmF0aW8gOiBpdGVtUmF0aW8gPCByZWN0UmF0aW8pID8gcmVjdGFuZ2xlLndpZHRoIC8gYm91bmRzLndpZHRoIDogcmVjdGFuZ2xlLmhlaWdodCAvIGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgbmV3Qm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSwgbmV3IFNpemUoYm91bmRzLndpZHRoICogc2NhbGUsIGJvdW5kcy5oZWlnaHQgKiBzY2FsZSkpO1xuICAgICAgbmV3Qm91bmRzLnNldENlbnRlcihyZWN0YW5nbGUuZ2V0Q2VudGVyKCkpO1xuICAgICAgdGhpcy5zZXRCb3VuZHMobmV3Qm91bmRzKTtcbiAgICB9XG4gIH0pLCB7XG4gICAgX3NldFN0eWxlczogZnVuY3Rpb24gKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuICAgICAgICAgIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcblxuICAgICAgaWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuZ2V0RmlsbENvbG9yKCkudG9DYW52YXNTdHlsZShjdHgsIG1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5nZXRTdHJva2VDb2xvcigpLnRvQ2FudmFzU3R5bGUoY3R4LCBtYXRyaXgpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKTtcbiAgICAgICAgdmFyIHN0cm9rZUpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG4gICAgICAgICAgICBzdHJva2VDYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcbiAgICAgICAgICAgIG1pdGVyTGltaXQgPSBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgIGlmIChzdHJva2VKb2luKSBjdHgubGluZUpvaW4gPSBzdHJva2VKb2luO1xuICAgICAgICBpZiAoc3Ryb2tlQ2FwKSBjdHgubGluZUNhcCA9IHN0cm9rZUNhcDtcbiAgICAgICAgaWYgKG1pdGVyTGltaXQpIGN0eC5taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcblxuICAgICAgICBpZiAocGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoKSB7XG4gICAgICAgICAgdmFyIGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuICAgICAgICAgICAgICBkYXNoT2Zmc2V0ID0gc3R5bGUuZ2V0RGFzaE9mZnNldCgpO1xuXG4gICAgICAgICAgaWYgKGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoJ3NldExpbmVEYXNoJyBpbiBjdHgpIHtcbiAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdHgubW96RGFzaCA9IGRhc2hBcnJheTtcbiAgICAgICAgICAgICAgY3R4Lm1vekRhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUuaGFzU2hhZG93KCkpIHtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSBwYXJhbS5waXhlbFJhdGlvIHx8IDEsXG4gICAgICAgICAgICBteCA9IHZpZXdNYXRyaXguX3NoaWZ0bGVzcygpLnByZXBlbmQobmV3IE1hdHJpeCgpLnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pKSxcbiAgICAgICAgICAgIGJsdXIgPSBteC50cmFuc2Zvcm0obmV3IFBvaW50KHN0eWxlLmdldFNoYWRvd0JsdXIoKSwgMCkpLFxuICAgICAgICAgICAgb2Zmc2V0ID0gbXgudHJhbnNmb3JtKHRoaXMuZ2V0U2hhZG93T2Zmc2V0KCkpO1xuXG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHN0eWxlLmdldFNoYWRvd0NvbG9yKCkudG9DYW52YXNTdHlsZShjdHgpO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IGJsdXIuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gb2Zmc2V0Lng7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gb2Zmc2V0Lnk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiAoY3R4LCBwYXJhbSwgcGFyZW50U3Ryb2tlTWF0cml4KSB7XG4gICAgICB2YXIgdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3VwZGF0ZVZlcnNpb24gPSB0aGlzLl9wcm9qZWN0Ll91cGRhdGVWZXJzaW9uO1xuICAgICAgaWYgKCF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX29wYWNpdHkgPT09IDApIHJldHVybjtcbiAgICAgIHZhciBtYXRyaWNlcyA9IHBhcmFtLm1hdHJpY2VzLFxuICAgICAgICAgIHZpZXdNYXRyaXggPSBwYXJhbS52aWV3TWF0cml4LFxuICAgICAgICAgIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcbiAgICAgICAgICBnbG9iYWxNYXRyaXggPSBtYXRyaWNlc1ttYXRyaWNlcy5sZW5ndGggLSAxXS5hcHBlbmRlZChtYXRyaXgpO1xuICAgICAgaWYgKCFnbG9iYWxNYXRyaXguaXNJbnZlcnRpYmxlKCkpIHJldHVybjtcbiAgICAgIHZpZXdNYXRyaXggPSB2aWV3TWF0cml4ID8gdmlld01hdHJpeC5hcHBlbmRlZChnbG9iYWxNYXRyaXgpIDogZ2xvYmFsTWF0cml4O1xuICAgICAgbWF0cmljZXMucHVzaChnbG9iYWxNYXRyaXgpO1xuXG4gICAgICBpZiAocGFyYW0udXBkYXRlTWF0cml4KSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbE1hdHJpeCA9IGdsb2JhbE1hdHJpeDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJsZW5kTW9kZSA9IHRoaXMuX2JsZW5kTW9kZSxcbiAgICAgICAgICBvcGFjaXR5ID0gTnVtZXJpY2FsLmNsYW1wKHRoaXMuX29wYWNpdHksIDAsIDEpLFxuICAgICAgICAgIG5vcm1hbEJsZW5kID0gYmxlbmRNb2RlID09PSAnbm9ybWFsJyxcbiAgICAgICAgICBuYXRpdmVCbGVuZCA9IEJsZW5kTW9kZS5uYXRpdmVNb2Rlc1tibGVuZE1vZGVdLFxuICAgICAgICAgIGRpcmVjdCA9IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPT09IDEgfHwgcGFyYW0uZG9udFN0YXJ0IHx8IHBhcmFtLmNsaXAgfHwgKG5hdGl2ZUJsZW5kIHx8IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPCAxKSAmJiB0aGlzLl9jYW5Db21wb3NpdGUoKSxcbiAgICAgICAgICBwaXhlbFJhdGlvID0gcGFyYW0ucGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICAgIG1haW5DdHgsXG4gICAgICAgICAgaXRlbU9mZnNldCxcbiAgICAgICAgICBwcmV2T2Zmc2V0O1xuXG4gICAgICBpZiAoIWRpcmVjdCkge1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHModmlld01hdHJpeCk7XG5cbiAgICAgICAgaWYgKCFib3VuZHMud2lkdGggfHwgIWJvdW5kcy5oZWlnaHQpIHtcbiAgICAgICAgICBtYXRyaWNlcy5wb3AoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2T2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuICAgICAgICBpdGVtT2Zmc2V0ID0gcGFyYW0ub2Zmc2V0ID0gYm91bmRzLmdldFRvcExlZnQoKS5mbG9vcigpO1xuICAgICAgICBtYWluQ3R4ID0gY3R4O1xuICAgICAgICBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KGJvdW5kcy5nZXRTaXplKCkuY2VpbCgpLmFkZCgxKS5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG4gICAgICAgIGlmIChwaXhlbFJhdGlvICE9PSAxKSBjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgc3Ryb2tlTWF0cml4ID0gcGFyZW50U3Ryb2tlTWF0cml4ID8gcGFyZW50U3Ryb2tlTWF0cml4LmFwcGVuZGVkKG1hdHJpeCkgOiB0aGlzLl9jYW5TY2FsZVN0cm9rZSAmJiAhdGhpcy5nZXRTdHJva2VTY2FsaW5nKHRydWUpICYmIHZpZXdNYXRyaXgsXG4gICAgICAgICAgY2xpcCA9ICFkaXJlY3QgJiYgcGFyYW0uY2xpcEl0ZW0sXG4gICAgICAgICAgdHJhbnNmb3JtID0gIXN0cm9rZU1hdHJpeCB8fCBjbGlwO1xuXG4gICAgICBpZiAoZGlyZWN0KSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgIGlmIChuYXRpdmVCbGVuZCkgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZTtcbiAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLWl0ZW1PZmZzZXQueCwgLWl0ZW1PZmZzZXQueSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgKGRpcmVjdCA/IG1hdHJpeCA6IHZpZXdNYXRyaXgpLmFwcGx5VG9Db250ZXh0KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgIHBhcmFtLmNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoe1xuICAgICAgICAgIGNsaXA6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3Ryb2tlTWF0cml4KSB7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJhbS5vZmZzZXQ7XG4gICAgICAgIGlmIChvZmZzZXQpIGN0eC50cmFuc2xhdGUoLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kcmF3KGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBtYXRyaWNlcy5wb3AoKTtcblxuICAgICAgaWYgKHBhcmFtLmNsaXAgJiYgIXBhcmFtLmRvbnRGaW5pc2gpIHtcbiAgICAgICAgY3R4LmNsaXAodGhpcy5nZXRGaWxsUnVsZSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3QpIHtcbiAgICAgICAgQmxlbmRNb2RlLnByb2Nlc3MoYmxlbmRNb2RlLCBjdHgsIG1haW5DdHgsIG9wYWNpdHksIGl0ZW1PZmZzZXQuc3VidHJhY3QocHJldk9mZnNldCkubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuICAgICAgICBDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG4gICAgICAgIHBhcmFtLm9mZnNldCA9IHByZXZPZmZzZXQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBfaXNVcGRhdGVkOiBmdW5jdGlvbiAodXBkYXRlVmVyc2lvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpIHJldHVybiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKTtcbiAgICAgIHZhciB1cGRhdGVkID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9PT0gdXBkYXRlVmVyc2lvbjtcblxuICAgICAgaWYgKCF1cGRhdGVkICYmIHBhcmVudCAmJiBwYXJlbnQuX3Zpc2libGUgJiYgcGFyZW50Ll9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG4gICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9LFxuICAgIF9kcmF3U2VsZWN0aW9uOiBmdW5jdGlvbiAoY3R4LCBtYXRyaXgsIHNpemUsIHNlbGVjdGlvbkl0ZW1zLCB1cGRhdGVWZXJzaW9uKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uLFxuICAgICAgICAgIGl0ZW1TZWxlY3RlZCA9IHNlbGVjdGlvbiAmIDEsXG4gICAgICAgICAgYm91bmRzU2VsZWN0ZWQgPSBzZWxlY3Rpb24gJiAyIHx8IGl0ZW1TZWxlY3RlZCAmJiB0aGlzLl9zZWxlY3RCb3VuZHMsXG4gICAgICAgICAgcG9zaXRpb25TZWxlY3RlZCA9IHNlbGVjdGlvbiAmIDQ7XG4gICAgICBpZiAoIXRoaXMuX2RyYXdTZWxlY3RlZCkgaXRlbVNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgIGlmICgoaXRlbVNlbGVjdGVkIHx8IGJvdW5kc1NlbGVjdGVkIHx8IHBvc2l0aW9uU2VsZWN0ZWQpICYmIHRoaXMuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuICAgICAgICB2YXIgbGF5ZXIsXG4gICAgICAgICAgICBjb2xvciA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2xvcih0cnVlKSB8fCAobGF5ZXIgPSB0aGlzLmdldExheWVyKCkpICYmIGxheWVyLmdldFNlbGVjdGVkQ29sb3IodHJ1ZSksXG4gICAgICAgICAgICBteCA9IG1hdHJpeC5hcHBlbmRlZCh0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKSksXG4gICAgICAgICAgICBoYWxmID0gc2l6ZSAvIDI7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvciA/IGNvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KSA6ICcjMDA5ZGVjJztcbiAgICAgICAgaWYgKGl0ZW1TZWxlY3RlZCkgdGhpcy5fZHJhd1NlbGVjdGVkKGN0eCwgbXgsIHNlbGVjdGlvbkl0ZW1zKTtcblxuICAgICAgICBpZiAocG9zaXRpb25TZWxlY3RlZCkge1xuICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpLFxuICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLl9wYXJlbnQsXG4gICAgICAgICAgICAgIHBvaW50ID0gcGFyZW50ID8gcGFyZW50LmxvY2FsVG9HbG9iYWwocG9zKSA6IHBvcyxcbiAgICAgICAgICAgICAgeCA9IHBvaW50LngsXG4gICAgICAgICAgICAgIHkgPSBwb2ludC55O1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHguYXJjKHgsIHksIGhhbGYsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgdmFyIGRlbHRhcyA9IFtbMCwgLTFdLCBbMSwgMF0sIFswLCAxXSwgWy0xLCAwXV0sXG4gICAgICAgICAgICAgIHN0YXJ0ID0gaGFsZixcbiAgICAgICAgICAgICAgZW5kID0gc2l6ZSArIDE7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gZGVsdGFzW2ldLFxuICAgICAgICAgICAgICAgIGR4ID0gZGVsdGFbMF0sXG4gICAgICAgICAgICAgICAgZHkgPSBkZWx0YVsxXTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIGR4ICogc3RhcnQsIHkgKyBkeSAqIHN0YXJ0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGR4ICogZW5kLCB5ICsgZHkgKiBlbmQpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib3VuZHNTZWxlY3RlZCkge1xuICAgICAgICAgIHZhciBjb29yZHMgPSBteC5fdHJhbnNmb3JtQ29ybmVycyh0aGlzLmdldEludGVybmFsQm91bmRzKCkpO1xuXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIGN0eFshaSA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGNvb3Jkc1tpXSwgY29vcmRzWysraV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGNvb3Jkc1tpXSAtIGhhbGYsIGNvb3Jkc1srK2ldIC0gaGFsZiwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBCYXNlLmVhY2goWydkb3duJywgJ2RyYWcnLCAndXAnLCAnbW92ZSddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpc1sncmVtb3ZlT24nICsgQmFzZS5jYXBpdGFsaXplKGtleSldID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhhc2ggPSB7fTtcbiAgICAgIGhhc2hba2V5XSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVPbihoYXNoKTtcbiAgICB9O1xuICB9LCB7XG4gICAgcmVtb3ZlT246IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmpbbmFtZV0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gJ21vdXNlJyArIG5hbWUsXG4gICAgICAgICAgICAgIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuICAgICAgICAgICAgICBzZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyA9IHByb2plY3QuX3JlbW92ZVNldHMgfHwge307XG4gICAgICAgICAgc2V0c1trZXldID0gc2V0c1trZXldIHx8IHt9O1xuICAgICAgICAgIHNldHNba2V5XVt0aGlzLl9pZF0gPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSksIHtcbiAgICB0d2VlbjogZnVuY3Rpb24gKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRvO1xuICAgICAgICB0byA9IGZyb207XG4gICAgICAgIGZyb20gPSBudWxsO1xuXG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgIG9wdGlvbnMgPSB0bztcbiAgICAgICAgICB0byA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGVhc2luZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lYXNpbmcsXG4gICAgICAgICAgc3RhcnQgPSBvcHRpb25zICYmIG9wdGlvbnMuc3RhcnQsXG4gICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zICE9IG51bGwgJiYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJyA/IG9wdGlvbnMgOiBvcHRpb25zLmR1cmF0aW9uKSxcbiAgICAgICAgICB0d2VlbiA9IG5ldyBUd2Vlbih0aGlzLCBmcm9tLCB0bywgZHVyYXRpb24sIGVhc2luZywgc3RhcnQpO1xuXG4gICAgICBmdW5jdGlvbiBvbkZyYW1lKGV2ZW50KSB7XG4gICAgICAgIHR3ZWVuLl9oYW5kbGVGcmFtZShldmVudC50aW1lICogMTAwMCk7XG5cbiAgICAgICAgaWYgKCF0d2Vlbi5ydW5uaW5nKSB7XG4gICAgICAgICAgdGhpcy5vZmYoJ2ZyYW1lJywgb25GcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMub24oJ2ZyYW1lJywgb25GcmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0d2VlbjtcbiAgICB9LFxuICAgIHR3ZWVuVG86IGZ1bmN0aW9uICh0bywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMudHdlZW4obnVsbCwgdG8sIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgdHdlZW5Gcm9tOiBmdW5jdGlvbiAoZnJvbSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMudHdlZW4oZnJvbSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbiAgdmFyIEdyb3VwID0gSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0dyb3VwJyxcbiAgICBfc2VsZWN0Qm91bmRzOiBmYWxzZSxcbiAgICBfc2VsZWN0Q2hpbGRyZW46IHRydWUsXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBHcm91cChhcmcpIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICB0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG4gICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnKSkgdGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG4gICAgICBfY2hhbmdlZC5iYXNlLmNhbGwodGhpcywgZmxhZ3MpO1xuXG4gICAgICBpZiAoZmxhZ3MgJiAyMDUwKSB7XG4gICAgICAgIHRoaXMuX2NsaXBJdGVtID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldENsaXBJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2xpcEl0ZW0gPSB0aGlzLl9jbGlwSXRlbTtcblxuICAgICAgaWYgKGNsaXBJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2xpcEl0ZW0gPSBudWxsO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5fY2xpcE1hc2spIHtcbiAgICAgICAgICAgIGNsaXBJdGVtID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jbGlwSXRlbSA9IGNsaXBJdGVtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xpcEl0ZW07XG4gICAgfSxcbiAgICBpc0NsaXBwZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX2dldENsaXBJdGVtKCk7XG4gICAgfSxcbiAgICBzZXRDbGlwcGVkOiBmdW5jdGlvbiAoY2xpcHBlZCkge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoY2hpbGQpIGNoaWxkLnNldENsaXBNYXNrKGNsaXBwZWQpO1xuICAgIH0sXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24gX2dldEJvdW5kcyhtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjbGlwSXRlbSA9IHRoaXMuX2dldENsaXBJdGVtKCk7XG5cbiAgICAgIHJldHVybiBjbGlwSXRlbSA/IGNsaXBJdGVtLl9nZXRDYWNoZWRCb3VuZHMoY2xpcEl0ZW0uX21hdHJpeC5wcmVwZW5kZWQobWF0cml4KSwgQmFzZS5zZXQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgc3Ryb2tlOiBmYWxzZVxuICAgICAgfSkpIDogX2dldEJvdW5kcy5iYXNlLmNhbGwodGhpcywgbWF0cml4LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIF9oaXRUZXN0Q2hpbGRyZW46IGZ1bmN0aW9uIF9oaXRUZXN0Q2hpbGRyZW4ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpIHtcbiAgICAgIHZhciBjbGlwSXRlbSA9IHRoaXMuX2dldENsaXBJdGVtKCk7XG5cbiAgICAgIHJldHVybiAoIWNsaXBJdGVtIHx8IGNsaXBJdGVtLmNvbnRhaW5zKHBvaW50KSkgJiYgX2hpdFRlc3RDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgcG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgsIGNsaXBJdGVtKTtcbiAgICB9LFxuICAgIF9kcmF3OiBmdW5jdGlvbiAoY3R4LCBwYXJhbSkge1xuICAgICAgdmFyIGNsaXAgPSBwYXJhbS5jbGlwLFxuICAgICAgICAgIGNsaXBJdGVtID0gIWNsaXAgJiYgdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblxuICAgICAgcGFyYW0gPSBwYXJhbS5leHRlbmQoe1xuICAgICAgICBjbGlwSXRlbTogY2xpcEl0ZW0sXG4gICAgICAgIGNsaXA6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBwYXJhbS5kb250U3RhcnQgPSBwYXJhbS5kb250RmluaXNoID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2xpcEl0ZW0pIHtcbiAgICAgICAgY2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7XG4gICAgICAgICAgY2xpcDogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXRlbSAhPT0gY2xpcEl0ZW0pIGl0ZW0uZHJhdyhjdHgsIHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgTGF5ZXIgPSBHcm91cC5leHRlbmQoe1xuICAgIF9jbGFzczogJ0xheWVyJyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBMYXllcigpIHtcbiAgICAgIEdyb3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBfZ2V0T3duZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5faW5kZXggIT0gbnVsbCAmJiB0aGlzLl9wcm9qZWN0O1xuICAgIH0sXG4gICAgaXNJbnNlcnRlZDogZnVuY3Rpb24gaXNJbnNlcnRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBpc0luc2VydGVkLmJhc2UuY2FsbCh0aGlzKSA6IHRoaXMuX2luZGV4ICE9IG51bGw7XG4gICAgfSxcbiAgICBhY3RpdmF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzO1xuICAgIH0sXG4gICAgX2hpdFRlc3RTZWxmOiBmdW5jdGlvbiAoKSB7fVxuICB9KTtcbiAgdmFyIFNoYXBlID0gSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1NoYXBlJyxcbiAgICBfYXBwbHlNYXRyaXg6IGZhbHNlLFxuICAgIF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX2NhblNjYWxlU3Ryb2tlOiB0cnVlLFxuICAgIF9zZXJpYWxpemVGaWVsZHM6IHtcbiAgICAgIHR5cGU6IG51bGwsXG4gICAgICBzaXplOiBudWxsLFxuICAgICAgcmFkaXVzOiBudWxsXG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBTaGFwZShwcm9wcywgcG9pbnQpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpemUocHJvcHMsIHBvaW50KTtcbiAgICB9LFxuICAgIF9lcXVhbHM6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZSA9PT0gaXRlbS5fdHlwZSAmJiB0aGlzLl9zaXplLmVxdWFscyhpdGVtLl9zaXplKSAmJiBCYXNlLmVxdWFscyh0aGlzLl9yYWRpdXMsIGl0ZW0uX3JhZGl1cyk7XG4gICAgfSxcbiAgICBjb3B5Q29udGVudDogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgdGhpcy5zZXRUeXBlKHNvdXJjZS5fdHlwZSk7XG4gICAgICB0aGlzLnNldFNpemUoc291cmNlLl9zaXplKTtcbiAgICAgIHRoaXMuc2V0UmFkaXVzKHNvdXJjZS5fcmFkaXVzKTtcbiAgICB9LFxuICAgIGdldFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH0sXG4gICAgc2V0VHlwZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIH0sXG4gICAgZ2V0U2hhcGU6ICcjZ2V0VHlwZScsXG4gICAgc2V0U2hhcGU6ICcjc2V0VHlwZScsXG4gICAgZ2V0U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgICAgcmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuICAgIH0sXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblxuICAgICAgaWYgKCF0aGlzLl9zaXplKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9zaXplLmVxdWFscyhzaXplKSkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG4gICAgICAgICAgICB3aWR0aCA9IHNpemUud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBzaXplLmhlaWdodDtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcbiAgICAgICAgICB0aGlzLl9yYWRpdXMuc2V0KFNpemUubWluKHRoaXMuX3JhZGl1cywgc2l6ZS5kaXZpZGUoMikuYWJzKCkpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgdGhpcy5fcmFkaXVzID0gd2lkdGggLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlbGxpcHNlJykge1xuICAgICAgICAgIHRoaXMuX3JhZGl1cy5fc2V0KHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaXplLl9zZXQod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCg5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJhZCA9IHRoaXMuX3JhZGl1cztcbiAgICAgIHJldHVybiB0aGlzLl90eXBlID09PSAnY2lyY2xlJyA/IHJhZCA6IG5ldyBMaW5rZWRTaXplKHJhZC53aWR0aCwgcmFkLmhlaWdodCwgdGhpcywgJ3NldFJhZGl1cycpO1xuICAgIH0sXG4gICAgc2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuICAgICAgICBpZiAocmFkaXVzID09PSB0aGlzLl9yYWRpdXMpIHJldHVybjtcbiAgICAgICAgdmFyIHNpemUgPSByYWRpdXMgKiAyO1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cbiAgICAgICAgdGhpcy5fc2l6ZS5fc2V0KHNpemUsIHNpemUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yYWRpdXMpIHtcbiAgICAgICAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXMuY2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5fcmFkaXVzLmVxdWFscyhyYWRpdXMpKSByZXR1cm47XG5cbiAgICAgICAgICB0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cyk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gU2l6ZS5tYXgodGhpcy5fc2l6ZSwgcmFkaXVzLm11bHRpcGx5KDIpKTtcblxuICAgICAgICAgICAgdGhpcy5fc2l6ZS5zZXQoc2l6ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpemUuX3NldChyYWRpdXMud2lkdGggKiAyLCByYWRpdXMuaGVpZ2h0ICogMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoOSk7XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICB0b1BhdGg6IGZ1bmN0aW9uIChpbnNlcnQpIHtcbiAgICAgIHZhciBwYXRoID0gbmV3IFBhdGhbQmFzZS5jYXBpdGFsaXplKHRoaXMuX3R5cGUpXSh7XG4gICAgICAgIGNlbnRlcjogbmV3IFBvaW50KCksXG4gICAgICAgIHNpemU6IHRoaXMuX3NpemUsXG4gICAgICAgIHJhZGl1czogdGhpcy5fcmFkaXVzLFxuICAgICAgICBpbnNlcnQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHBhdGguY29weUF0dHJpYnV0ZXModGhpcyk7XG4gICAgICBpZiAocGFwZXIuc2V0dGluZ3MuYXBwbHlNYXRyaXgpIHBhdGguc2V0QXBwbHlNYXRyaXgodHJ1ZSk7XG4gICAgICBpZiAoaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgaW5zZXJ0KSBwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcbiAgICB0b1NoYXBlOiAnI2Nsb25lJyxcbiAgICBfYXNQYXRoSXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9QYXRoKGZhbHNlKTtcbiAgICB9LFxuICAgIF9kcmF3OiBmdW5jdGlvbiAoY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuICAgICAgICAgIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpLFxuICAgICAgICAgIGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcCxcbiAgICAgICAgICB1bnRyYW5zZm9ybWVkID0gIXN0cm9rZU1hdHJpeDtcblxuICAgICAgaWYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlIHx8IGRvbnRQYWludCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG4gICAgICAgICAgICByYWRpdXMgPSB0aGlzLl9yYWRpdXMsXG4gICAgICAgICAgICBpc0NpcmNsZSA9IHR5cGUgPT09ICdjaXJjbGUnO1xuICAgICAgICBpZiAoIXBhcmFtLmRvbnRTdGFydCkgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmICh1bnRyYW5zZm9ybWVkICYmIGlzQ2lyY2xlKSB7XG4gICAgICAgICAgY3R4LmFyYygwLCAwLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcnggPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy53aWR0aCxcbiAgICAgICAgICAgICAgcnkgPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy5oZWlnaHQsXG4gICAgICAgICAgICAgIHNpemUgPSB0aGlzLl9zaXplLFxuICAgICAgICAgICAgICB3aWR0aCA9IHNpemUud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKHVudHJhbnNmb3JtZWQgJiYgdHlwZSA9PT0gJ3JlY3RhbmdsZScgJiYgcnggPT09IDAgJiYgcnkgPT09IDApIHtcbiAgICAgICAgICAgIGN0eC5yZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHggPSB3aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgeSA9IGhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAga2FwcGEgPSAxIC0gMC41NTIyODQ3NDk4MzA3OTM2LFxuICAgICAgICAgICAgICAgIGN4ID0gcnggKiBrYXBwYSxcbiAgICAgICAgICAgICAgICBjeSA9IHJ5ICoga2FwcGEsXG4gICAgICAgICAgICAgICAgYyA9IFsteCwgLXkgKyByeSwgLXgsIC15ICsgY3ksIC14ICsgY3gsIC15LCAteCArIHJ4LCAteSwgeCAtIHJ4LCAteSwgeCAtIGN4LCAteSwgeCwgLXkgKyBjeSwgeCwgLXkgKyByeSwgeCwgeSAtIHJ5LCB4LCB5IC0gY3ksIHggLSBjeCwgeSwgeCAtIHJ4LCB5LCAteCArIHJ4LCB5LCAteCArIGN4LCB5LCAteCwgeSAtIGN5LCAteCwgeSAtIHJ5XTtcbiAgICAgICAgICAgIGlmIChzdHJva2VNYXRyaXgpIHN0cm9rZU1hdHJpeC50cmFuc2Zvcm0oYywgYywgMzIpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjWzBdLCBjWzFdKTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl0sIGNbN10pO1xuICAgICAgICAgICAgaWYgKHggIT09IHJ4KSBjdHgubGluZVRvKGNbOF0sIGNbOV0pO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY1sxMF0sIGNbMTFdLCBjWzEyXSwgY1sxM10sIGNbMTRdLCBjWzE1XSk7XG4gICAgICAgICAgICBpZiAoeSAhPT0gcnkpIGN0eC5saW5lVG8oY1sxNl0sIGNbMTddKTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNbMThdLCBjWzE5XSwgY1syMF0sIGNbMjFdLCBjWzIyXSwgY1syM10pO1xuICAgICAgICAgICAgaWYgKHggIT09IHJ4KSBjdHgubGluZVRvKGNbMjRdLCBjWzI1XSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjWzI2XSwgY1syN10sIGNbMjhdLCBjWzI5XSwgY1szMF0sIGNbMzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcbiAgICAgICAgdGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXG4gICAgICAgIGlmIChoYXNGaWxsKSB7XG4gICAgICAgICAgY3R4LmZpbGwoc3R5bGUuZ2V0RmlsbFJ1bGUoKSk7XG4gICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1N0cm9rZSkgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG4gICAgfSxcbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbiAobWF0cml4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApLFxuICAgICAgICAgIHN0eWxlID0gdGhpcy5fc3R5bGUsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSAmJiBzdHlsZS5nZXRTdHJva2VXaWR0aCgpO1xuICAgICAgaWYgKG1hdHJpeCkgcmVjdCA9IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpO1xuICAgICAgcmV0dXJuIHN0cm9rZVdpZHRoID8gcmVjdC5leHBhbmQoUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VXaWR0aCwgdGhpcy5fZ2V0U3Ryb2tlTWF0cml4KG1hdHJpeCwgb3B0aW9ucykpKSA6IHJlY3Q7XG4gICAgfVxuICB9LCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldENvcm5lckNlbnRlcih0aGF0LCBwb2ludCwgZXhwYW5kKSB7XG4gICAgICB2YXIgcmFkaXVzID0gdGhhdC5fcmFkaXVzO1xuXG4gICAgICBpZiAoIXJhZGl1cy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgaGFsZlNpemUgPSB0aGF0Ll9zaXplLmRpdmlkZSgyKTtcblxuICAgICAgICBmb3IgKHZhciBxID0gMTsgcSA8PSA0OyBxKyspIHtcbiAgICAgICAgICB2YXIgZGlyID0gbmV3IFBvaW50KHEgPiAxICYmIHEgPCA0ID8gLTEgOiAxLCBxID4gMiA/IC0xIDogMSksXG4gICAgICAgICAgICAgIGNvcm5lciA9IGRpci5tdWx0aXBseShoYWxmU2l6ZSksXG4gICAgICAgICAgICAgIGNlbnRlciA9IGNvcm5lci5zdWJ0cmFjdChkaXIubXVsdGlwbHkocmFkaXVzKSksXG4gICAgICAgICAgICAgIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGV4cGFuZCA/IGNvcm5lci5hZGQoZGlyLm11bHRpcGx5KGV4cGFuZCkpIDogY29ybmVyLCBjZW50ZXIpO1xuICAgICAgICAgIGlmIChyZWN0LmNvbnRhaW5zKHBvaW50KSkgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBjZW50ZXIsXG4gICAgICAgICAgICBxdWFkcmFudDogcVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09uRWxsaXBzZVN0cm9rZShwb2ludCwgcmFkaXVzLCBwYWRkaW5nLCBxdWFkcmFudCkge1xuICAgICAgdmFyIHZlY3RvciA9IHBvaW50LmRpdmlkZShyYWRpdXMpO1xuICAgICAgcmV0dXJuICghcXVhZHJhbnQgfHwgdmVjdG9yLmlzSW5RdWFkcmFudChxdWFkcmFudCkpICYmIHZlY3Rvci5zdWJ0cmFjdCh2ZWN0b3Iubm9ybWFsaXplKCkpLm11bHRpcGx5KHJhZGl1cykuZGl2aWRlKHBhZGRpbmcpLmxlbmd0aCA8PSAxO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBfY29udGFpbnM6IGZ1bmN0aW9uIF9jb250YWlucyhwb2ludCkge1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcbiAgICAgICAgICB2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50KTtcbiAgICAgICAgICByZXR1cm4gY2VudGVyID8gcG9pbnQuc3VidHJhY3QoY2VudGVyLnBvaW50KS5kaXZpZGUodGhpcy5fcmFkaXVzKS5nZXRMZW5ndGgoKSA8PSAxIDogX2NvbnRhaW5zLmJhc2UuY2FsbCh0aGlzLCBwb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBvaW50LmRpdmlkZSh0aGlzLnNpemUpLmdldExlbmd0aCgpIDw9IDAuNTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9oaXRUZXN0U2VsZjogZnVuY3Rpb24gX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcbiAgICAgICAgdmFyIGhpdCA9IGZhbHNlLFxuICAgICAgICAgICAgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICAgIGhpdFN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuICAgICAgICAgICAgaGl0RmlsbCA9IG9wdGlvbnMuZmlsbCAmJiBzdHlsZS5oYXNGaWxsKCk7XG5cbiAgICAgICAgaWYgKGhpdFN0cm9rZSB8fCBoaXRGaWxsKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuICAgICAgICAgICAgICByYWRpdXMgPSB0aGlzLl9yYWRpdXMsXG4gICAgICAgICAgICAgIHN0cm9rZVJhZGl1cyA9IGhpdFN0cm9rZSA/IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyIDogMCxcbiAgICAgICAgICAgICAgc3Ryb2tlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcuYWRkKFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlUmFkaXVzLCAhc3R5bGUuZ2V0U3Ryb2tlU2NhbGluZygpICYmIHN0cm9rZU1hdHJpeCkpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IHN0cm9rZVBhZGRpbmcubXVsdGlwbHkoMiksXG4gICAgICAgICAgICAgICAgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50LCBwYWRkaW5nKTtcblxuICAgICAgICAgICAgaWYgKGNlbnRlcikge1xuICAgICAgICAgICAgICBoaXQgPSBpc09uRWxsaXBzZVN0cm9rZShwb2ludC5zdWJ0cmFjdChjZW50ZXIucG9pbnQpLCByYWRpdXMsIHN0cm9rZVBhZGRpbmcsIGNlbnRlci5xdWFkcmFudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApLFxuICAgICAgICAgICAgICAgICAgb3V0ZXIgPSByZWN0LmV4cGFuZChwYWRkaW5nKSxcbiAgICAgICAgICAgICAgICAgIGlubmVyID0gcmVjdC5leHBhbmQocGFkZGluZy5uZWdhdGUoKSk7XG4gICAgICAgICAgICAgIGhpdCA9IG91dGVyLl9jb250YWluc1BvaW50KHBvaW50KSAmJiAhaW5uZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaXQgPSBpc09uRWxsaXBzZVN0cm9rZShwb2ludCwgcmFkaXVzLCBzdHJva2VQYWRkaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGl0ID8gbmV3IEhpdFJlc3VsdChoaXRTdHJva2UgPyAnc3Ryb2tlJyA6ICdmaWxsJywgdGhpcykgOiBfaGl0VGVzdFNlbGYuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKSwge1xuICAgIHN0YXRpY3M6IG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBwb2ludCwgc2l6ZSwgcmFkaXVzLCBhcmdzKSB7XG4gICAgICAgIHZhciBpdGVtID0gQmFzZS5jcmVhdGUoU2hhcGUucHJvdG90eXBlKTtcbiAgICAgICAgaXRlbS5fdHlwZSA9IHR5cGU7XG4gICAgICAgIGl0ZW0uX3NpemUgPSBzaXplO1xuICAgICAgICBpdGVtLl9yYWRpdXMgPSByYWRpdXM7XG5cbiAgICAgICAgaXRlbS5faW5pdGlhbGl6ZShCYXNlLmdldE5hbWVkKGFyZ3MpLCBwb2ludCk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIENpcmNsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpLFxuICAgICAgICAgICAgICByYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVNoYXBlKCdjaXJjbGUnLCBjZW50ZXIsIG5ldyBTaXplKHJhZGl1cyAqIDIpLCByYWRpdXMsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBSZWN0YW5nbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJncywgJ3JlY3RhbmdsZScpLFxuICAgICAgICAgICAgICByYWRpdXMgPSBTaXplLm1pbihTaXplLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyksIHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVTaGFwZSgncmVjdGFuZ2xlJywgcmVjdC5nZXRDZW50ZXIodHJ1ZSksIHJlY3QuZ2V0U2l6ZSh0cnVlKSwgcmFkaXVzLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgRWxsaXBzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3MpLFxuICAgICAgICAgICAgICByYWRpdXMgPSBlbGxpcHNlLnJhZGl1cztcblxuICAgICAgICAgIHJldHVybiBjcmVhdGVTaGFwZSgnZWxsaXBzZScsIGVsbGlwc2UuY2VudGVyLCByYWRpdXMubXVsdGlwbHkoMiksIHJhZGl1cywgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9yZWFkRWxsaXBzZTogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgY2VudGVyLCByYWRpdXM7XG5cbiAgICAgICAgICBpZiAoQmFzZS5oYXNOYW1lZChhcmdzLCAncmFkaXVzJykpIHtcbiAgICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyk7XG4gICAgICAgICAgICByYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyk7XG4gICAgICAgICAgICBjZW50ZXIgPSByZWN0LmdldENlbnRlcih0cnVlKTtcbiAgICAgICAgICAgIHJhZGl1cyA9IHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgICAgcmFkaXVzOiByYWRpdXNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKVxuICB9KTtcbiAgdmFyIFJhc3RlciA9IEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdSYXN0ZXInLFxuICAgIF9hcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfYm91bmRzT3B0aW9uczoge1xuICAgICAgc3Ryb2tlOiBmYWxzZSxcbiAgICAgIGhhbmRsZTogZmFsc2VcbiAgICB9LFxuICAgIF9zZXJpYWxpemVGaWVsZHM6IHtcbiAgICAgIGNyb3NzT3JpZ2luOiBudWxsLFxuICAgICAgc291cmNlOiBudWxsXG4gICAgfSxcbiAgICBfcHJpb3JpdGl6ZTogWydjcm9zc09yaWdpbiddLFxuICAgIF9zbW9vdGhpbmc6IHRydWUsXG4gICAgYmVhbnM6IHRydWUsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUmFzdGVyKHNvdXJjZSwgcG9zaXRpb24pIHtcbiAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZShzb3VyY2UsIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMpKSkge1xuICAgICAgICB2YXIgaW1hZ2UsXG4gICAgICAgICAgICB0eXBlID0gdHlwZW9mIHNvdXJjZSxcbiAgICAgICAgICAgIG9iamVjdCA9IHR5cGUgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc291cmNlKSA6IHR5cGUgPT09ICdvYmplY3QnID8gc291cmNlIDogbnVsbDtcblxuICAgICAgICBpZiAob2JqZWN0ICYmIG9iamVjdCAhPT0gSXRlbS5OT19JTlNFUlQpIHtcbiAgICAgICAgICBpZiAob2JqZWN0LmdldENvbnRleHQgfHwgb2JqZWN0Lm5hdHVyYWxIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW1hZ2UgPSBvYmplY3Q7XG4gICAgICAgICAgfSBlbHNlIGlmIChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICghc2l6ZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICBpbWFnZSA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICB0aGlzLnNldEltYWdlKGltYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fc2l6ZSkge1xuICAgICAgICB0aGlzLl9zaXplID0gbmV3IFNpemUoKTtcbiAgICAgICAgdGhpcy5fbG9hZGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZXF1YWxzOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlKCkgPT09IGl0ZW0uZ2V0U291cmNlKCk7XG4gICAgfSxcbiAgICBjb3B5Q29udGVudDogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgdmFyIGltYWdlID0gc291cmNlLl9pbWFnZSxcbiAgICAgICAgICBjYW52YXMgPSBzb3VyY2UuX2NhbnZhcztcblxuICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgIHRoaXMuX3NldEltYWdlKGltYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FudmFzKSB7XG4gICAgICAgIHZhciBjb3B5Q2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNvdXJjZS5fc2l6ZSk7XG4gICAgICAgIGNvcHlDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblxuICAgICAgICB0aGlzLl9zZXRJbWFnZShjb3B5Q2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3Jvc3NPcmlnaW4gPSBzb3VyY2UuX2Nyb3NzT3JpZ2luO1xuICAgIH0sXG4gICAgZ2V0U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgICAgcmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUgPyBzaXplLndpZHRoIDogMCwgc2l6ZSA/IHNpemUuaGVpZ2h0IDogMCwgdGhpcywgJ3NldFNpemUnKTtcbiAgICB9LFxuICAgIHNldFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICghc2l6ZS5lcXVhbHModGhpcy5fc2l6ZSkpIHtcbiAgICAgICAgaWYgKHNpemUud2lkdGggPiAwICYmIHNpemUuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cbiAgICAgICAgICB0aGlzLl9zZXRJbWFnZShDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZSkpO1xuXG4gICAgICAgICAgaWYgKGVsZW1lbnQpIHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoZWxlbWVudCwgMCwgMCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLl9jYW52YXMpIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UodGhpcy5fY2FudmFzKTtcbiAgICAgICAgICB0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NpemUgPyB0aGlzLl9zaXplLndpZHRoIDogMDtcbiAgICB9LFxuICAgIHNldFdpZHRoOiBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgdGhpcy5nZXRIZWlnaHQoKSk7XG4gICAgfSxcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaXplID8gdGhpcy5fc2l6ZS5oZWlnaHQgOiAwO1xuICAgIH0sXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gICAgICB0aGlzLnNldFNpemUodGhpcy5nZXRXaWR0aCgpLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgZ2V0TG9hZGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZGVkO1xuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgICAgcmV0dXJuICFzaXplIHx8IHNpemUud2lkdGggPT09IDAgJiYgc2l6ZS5oZWlnaHQgPT09IDA7XG4gICAgfSxcbiAgICBnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuICAgICAgICAgIG9yaWcgPSBuZXcgUG9pbnQoMCwgMCkudHJhbnNmb3JtKG1hdHJpeCksXG4gICAgICAgICAgdSA9IG5ldyBQb2ludCgxLCAwKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKSxcbiAgICAgICAgICB2ID0gbmV3IFBvaW50KDAsIDEpLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpO1xuICAgICAgcmV0dXJuIG5ldyBTaXplKDcyIC8gdS5nZXRMZW5ndGgoKSwgNzIgLyB2LmdldExlbmd0aCgpKTtcbiAgICB9LFxuICAgIGdldFBwaTogJyNnZXRSZXNvbHV0aW9uJyxcbiAgICBnZXRJbWFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlO1xuICAgIH0sXG4gICAgc2V0SW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhhdC5nZXRWaWV3KCksXG4gICAgICAgICAgICB0eXBlID0gZXZlbnQgJiYgZXZlbnQudHlwZSB8fCAnbG9hZCc7XG5cbiAgICAgICAgaWYgKHZpZXcgJiYgdGhhdC5yZXNwb25kcyh0eXBlKSkge1xuICAgICAgICAgIHBhcGVyID0gdmlldy5fc2NvcGU7XG4gICAgICAgICAgdGhhdC5lbWl0KHR5cGUsIG5ldyBFdmVudChldmVudCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldEltYWdlKGltYWdlKTtcblxuICAgICAgaWYgKHRoaXMuX2xvYWRlZCkge1xuICAgICAgICBzZXRUaW1lb3V0KGVtaXQsIDApO1xuICAgICAgfSBlbHNlIGlmIChpbWFnZSkge1xuICAgICAgICBEb21FdmVudC5hZGQoaW1hZ2UsIHtcbiAgICAgICAgICBsb2FkOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoYXQuX3NldEltYWdlKGltYWdlKTtcblxuICAgICAgICAgICAgZW1pdChldmVudCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZW1pdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9zZXRJbWFnZTogZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICBpZiAodGhpcy5fY2FudmFzKSBDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG5cbiAgICAgIGlmIChpbWFnZSAmJiBpbWFnZS5nZXRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2ltYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gaW1hZ2U7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSAhIShpbWFnZSAmJiBpbWFnZS5zcmMgJiYgaW1hZ2UuY29tcGxldGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zaXplID0gbmV3IFNpemUoaW1hZ2UgPyBpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2Uud2lkdGggOiAwLCBpbWFnZSA/IGltYWdlLm5hdHVyYWxIZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0IDogMCk7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgxMDMzKTtcbiAgICB9LFxuICAgIGdldENhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgdmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQodGhpcy5fc2l6ZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodGhpcy5faW1hZ2UpIGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDApO1xuICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgICB9LFxuICAgIHNldENhbnZhczogJyNzZXRJbWFnZScsXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKF9jaGFuZ2UpIHtcbiAgICAgIGlmICghdGhpcy5fY29udGV4dCkgdGhpcy5fY29udGV4dCA9IHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgaWYgKF9jaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5faW1hZ2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoMTAyNSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICAgIH0sXG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH0sXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcbiAgICAgIHJldHVybiBpbWFnZSAmJiBpbWFnZS5zcmMgfHwgdGhpcy50b0RhdGFVUkwoKTtcbiAgICB9LFxuICAgIHNldFNvdXJjZTogZnVuY3Rpb24gKHNyYykge1xuICAgICAgdmFyIGltYWdlID0gbmV3IHNlbGYuSW1hZ2UoKSxcbiAgICAgICAgICBjcm9zc09yaWdpbiA9IHRoaXMuX2Nyb3NzT3JpZ2luO1xuICAgICAgaWYgKGNyb3NzT3JpZ2luKSBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgaWYgKHNyYykgaW1hZ2Uuc3JjID0gc3JjO1xuICAgICAgdGhpcy5zZXRJbWFnZShpbWFnZSk7XG4gICAgfSxcbiAgICBnZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5faW1hZ2U7XG4gICAgICByZXR1cm4gaW1hZ2UgJiYgaW1hZ2UuY3Jvc3NPcmlnaW4gfHwgdGhpcy5fY3Jvc3NPcmlnaW4gfHwgJyc7XG4gICAgfSxcbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKGNyb3NzT3JpZ2luKSB7XG4gICAgICB0aGlzLl9jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5faW1hZ2U7XG4gICAgICBpZiAoaW1hZ2UpIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgfSxcbiAgICBnZXRTbW9vdGhpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zbW9vdGhpbmc7XG4gICAgfSxcbiAgICBzZXRTbW9vdGhpbmc6IGZ1bmN0aW9uIChzbW9vdGhpbmcpIHtcbiAgICAgIHRoaXMuX3Ntb290aGluZyA9IHNtb290aGluZztcblxuICAgICAgdGhpcy5fY2hhbmdlZCgyNTcpO1xuICAgIH0sXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcyB8fCB0aGlzLl9sb2FkZWQgJiYgdGhpcy5faW1hZ2U7XG4gICAgfVxuICB9LCB7XG4gICAgYmVhbnM6IGZhbHNlLFxuICAgIGdldFN1YkNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQocmVjdC5nZXRTaXplKCkpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmdldENhbnZhcygpLCByZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIDAsIDAsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIHJldHVybiBjdHguY2FudmFzO1xuICAgIH0sXG4gICAgZ2V0U3ViUmFzdGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgcmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cbiAgICAgIHJhc3Rlci5fc2V0SW1hZ2UodGhpcy5nZXRTdWJDYW52YXMocmVjdCkpO1xuXG4gICAgICByYXN0ZXIudHJhbnNsYXRlKHJlY3QuZ2V0Q2VudGVyKCkuc3VidHJhY3QodGhpcy5nZXRTaXplKCkuZGl2aWRlKDIpKSk7XG5cbiAgICAgIHJhc3Rlci5fbWF0cml4LnByZXBlbmQodGhpcy5fbWF0cml4KTtcblxuICAgICAgcmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuICAgICAgcmV0dXJuIHJhc3RlcjtcbiAgICB9LFxuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5faW1hZ2UsXG4gICAgICAgICAgc3JjID0gaW1hZ2UgJiYgaW1hZ2Uuc3JjO1xuICAgICAgaWYgKC9eZGF0YTovLnRlc3Qoc3JjKSkgcmV0dXJuIHNyYztcbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgcmV0dXJuIGNhbnZhcyA/IGNhbnZhcy50b0RhdGFVUkwuYXBwbHkoY2FudmFzLCBhcmd1bWVudHMpIDogbnVsbDtcbiAgICB9LFxuICAgIGRyYXdJbWFnZTogZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG4gICAgICB0aGlzLmdldENvbnRleHQodHJ1ZSkuZHJhd0ltYWdlKGltYWdlLCBwb2ludC54LCBwb2ludC55KTtcbiAgICB9LFxuICAgIGdldEF2ZXJhZ2VDb2xvcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgdmFyIGJvdW5kcywgcGF0aDtcblxuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgUGF0aEl0ZW0pIHtcbiAgICAgICAgcGF0aCA9IG9iamVjdDtcbiAgICAgICAgYm91bmRzID0gb2JqZWN0LmdldEJvdW5kcygpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoJ3dpZHRoJyBpbiBvYmplY3QpIHtcbiAgICAgICAgICBib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ3gnIGluIG9iamVjdCkge1xuICAgICAgICAgIGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0LnggLSAwLjUsIG9iamVjdC55IC0gMC41LCAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWJvdW5kcykgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc2FtcGxlU2l6ZSA9IDMyLFxuICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4oYm91bmRzLndpZHRoLCBzYW1wbGVTaXplKSxcbiAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuaGVpZ2h0LCBzYW1wbGVTaXplKTtcbiAgICAgIHZhciBjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQ7XG5cbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQobmV3IFNpemUoc2FtcGxlU2l6ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBzYW1wbGVTaXplICsgMSwgc2FtcGxlU2l6ZSArIDEpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZSh3aWR0aCAvIGJvdW5kcy53aWR0aCwgaGVpZ2h0IC8gYm91bmRzLmhlaWdodCkudHJhbnNsYXRlKC1ib3VuZHMueCwgLWJvdW5kcy55KTtcbiAgICAgIG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuICAgICAgaWYgKHBhdGgpIHBhdGguZHJhdyhjdHgsIG5ldyBCYXNlKHtcbiAgICAgICAgY2xpcDogdHJ1ZSxcbiAgICAgICAgbWF0cmljZXM6IFttYXRyaXhdXG4gICAgICB9KSk7XG5cbiAgICAgIHRoaXMuX21hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpLFxuICAgICAgICAgIHNpemUgPSB0aGlzLl9zaXplO1xuICAgICAgaWYgKGVsZW1lbnQpIGN0eC5kcmF3SW1hZ2UoZWxlbWVudCwgLXNpemUud2lkdGggLyAyLCAtc2l6ZS5oZWlnaHQgLyAyKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB2YXIgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLjUsIDAuNSwgTWF0aC5jZWlsKHdpZHRoKSwgTWF0aC5jZWlsKGhlaWdodCkpLmRhdGEsXG4gICAgICAgICAgY2hhbm5lbHMgPSBbMCwgMCwgMF0sXG4gICAgICAgICAgdG90YWwgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBpeGVscy5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgICAgdmFyIGFscGhhID0gcGl4ZWxzW2kgKyAzXTtcbiAgICAgICAgdG90YWwgKz0gYWxwaGE7XG4gICAgICAgIGFscGhhIC89IDI1NTtcbiAgICAgICAgY2hhbm5lbHNbMF0gKz0gcGl4ZWxzW2ldICogYWxwaGE7XG4gICAgICAgIGNoYW5uZWxzWzFdICs9IHBpeGVsc1tpICsgMV0gKiBhbHBoYTtcbiAgICAgICAgY2hhbm5lbHNbMl0gKz0gcGl4ZWxzW2kgKyAyXSAqIGFscGhhO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykgY2hhbm5lbHNbaV0gLz0gdG90YWw7XG5cbiAgICAgIHJldHVybiB0b3RhbCA/IENvbG9yLnJlYWQoY2hhbm5lbHMpIDogbnVsbDtcbiAgICB9LFxuICAgIGdldFBpeGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShwb2ludC54LCBwb2ludC55LCAxLCAxKS5kYXRhO1xuICAgICAgcmV0dXJuIG5ldyBDb2xvcigncmdiJywgW2RhdGFbMF0gLyAyNTUsIGRhdGFbMV0gLyAyNTUsIGRhdGFbMl0gLyAyNTVdLCBkYXRhWzNdIC8gMjU1KTtcbiAgICB9LFxuICAgIHNldFBpeGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBwb2ludCA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgY29sb3IgPSBDb2xvci5yZWFkKGFyZ3MpLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBjb2xvci5fY29udmVydCgncmdiJyksXG4gICAgICAgICAgYWxwaGEgPSBjb2xvci5fYWxwaGEsXG4gICAgICAgICAgY3R4ID0gdGhpcy5nZXRDb250ZXh0KHRydWUpLFxuICAgICAgICAgIGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoMSwgMSksXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gICAgICBkYXRhWzBdID0gY29tcG9uZW50c1swXSAqIDI1NTtcbiAgICAgIGRhdGFbMV0gPSBjb21wb25lbnRzWzFdICogMjU1O1xuICAgICAgZGF0YVsyXSA9IGNvbXBvbmVudHNbMl0gKiAyNTU7XG4gICAgICBkYXRhWzNdID0gYWxwaGEgIT0gbnVsbCA/IGFscGhhICogMjU1IDogMjU1O1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICAgIHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCArIDEsIHNpemUuaGVpZ2h0ICsgMSk7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDb250ZXh0KCkuY3JlYXRlSW1hZ2VEYXRhKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICB9LFxuICAgIGdldEltYWdlRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlY3QuaXNFbXB0eSgpKSByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKTtcbiAgICAgIHJldHVybiB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICB9LFxuICAgIHNldEltYWdlRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKTtcbiAgICAgIHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5wdXRJbWFnZURhdGEoZGF0YSwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgfSxcbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbiAobWF0cml4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuICAgICAgcmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpIDogcmVjdDtcbiAgICB9LFxuICAgIF9oaXRUZXN0U2VsZjogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICBpZiAodGhpcy5fY29udGFpbnMocG9pbnQpKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBIaXRSZXN1bHQoJ3BpeGVsJywgdGhhdCwge1xuICAgICAgICAgIG9mZnNldDogcG9pbnQuYWRkKHRoYXQuX3NpemUuZGl2aWRlKDIpKS5yb3VuZCgpLFxuICAgICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZ2V0UGl4ZWwodGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZHJhdzogZnVuY3Rpb24gKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cbiAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQud2lkdGggPiAwICYmIGVsZW1lbnQuaGVpZ2h0ID4gMCkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBOdW1lcmljYWwuY2xhbXAodGhpcy5fb3BhY2l0eSwgMCwgMSk7XG5cbiAgICAgICAgdGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXG4gICAgICAgIERvbUVsZW1lbnQuc2V0UHJlZml4ZWQoY3R4LCAnaW1hZ2VTbW9vdGhpbmdFbmFibGVkJywgdGhpcy5fc21vb3RoaW5nKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShlbGVtZW50LCAtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgdmFyIFN5bWJvbEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnU3ltYm9sSXRlbScsXG4gICAgX2FwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuICAgIF9ib3VuZHNPcHRpb25zOiB7XG4gICAgICBzdHJva2U6IHRydWVcbiAgICB9LFxuICAgIF9zZXJpYWxpemVGaWVsZHM6IHtcbiAgICAgIHN5bWJvbDogbnVsbFxuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gU3ltYm9sSXRlbShhcmcwLCBhcmcxKSB7XG4gICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnMCwgYXJnMSAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpIHRoaXMuc2V0RGVmaW5pdGlvbihhcmcwIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvbiA/IGFyZzAgOiBuZXcgU3ltYm9sRGVmaW5pdGlvbihhcmcwKSk7XG4gICAgfSxcbiAgICBfZXF1YWxzOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24gPT09IGl0ZW0uX2RlZmluaXRpb247XG4gICAgfSxcbiAgICBjb3B5Q29udGVudDogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgdGhpcy5zZXREZWZpbml0aW9uKHNvdXJjZS5fZGVmaW5pdGlvbik7XG4gICAgfSxcbiAgICBnZXREZWZpbml0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcbiAgICB9LFxuICAgIHNldERlZmluaXRpb246IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgICB0aGlzLl9kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcblxuICAgICAgdGhpcy5fY2hhbmdlZCg5KTtcbiAgICB9LFxuICAgIGdldFN5bWJvbDogJyNnZXREZWZpbml0aW9uJyxcbiAgICBzZXRTeW1ib2w6ICcjc2V0RGVmaW5pdGlvbicsXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24uX2l0ZW0uaXNFbXB0eSgpO1xuICAgIH0sXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24gKG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9kZWZpbml0aW9uLl9pdGVtO1xuICAgICAgcmV0dXJuIGl0ZW0uX2dldENhY2hlZEJvdW5kcyhpdGVtLl9tYXRyaXgucHJlcGVuZGVkKG1hdHJpeCksIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgX2hpdFRlc3RTZWxmOiBmdW5jdGlvbiAocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpIHtcbiAgICAgIHZhciBvcHRzID0gb3B0aW9ucy5leHRlbmQoe1xuICAgICAgICBhbGw6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgdmFyIHJlcyA9IHRoaXMuX2RlZmluaXRpb24uX2l0ZW0uX2hpdFRlc3QocG9pbnQsIG9wdHMsIHZpZXdNYXRyaXgpO1xuXG4gICAgICBpZiAocmVzKSByZXMuaXRlbSA9IHRoaXM7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgX2RyYXc6IGZ1bmN0aW9uIChjdHgsIHBhcmFtKSB7XG4gICAgICB0aGlzLl9kZWZpbml0aW9uLl9pdGVtLmRyYXcoY3R4LCBwYXJhbSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIFN5bWJvbERlZmluaXRpb24gPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnU3ltYm9sRGVmaW5pdGlvbicsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gU3ltYm9sRGVmaW5pdGlvbihpdGVtLCBkb250Q2VudGVyKSB7XG4gICAgICB0aGlzLl9pZCA9IFVJRC5nZXQoKTtcbiAgICAgIHRoaXMucHJvamVjdCA9IHBhcGVyLnByb2plY3Q7XG4gICAgICBpZiAoaXRlbSkgdGhpcy5zZXRJdGVtKGl0ZW0sIGRvbnRDZW50ZXIpO1xuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcbiAgICAgIHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fY2xhc3MsIHRoaXMuX2l0ZW1dLCBvcHRpb25zLCBmYWxzZSwgZGljdGlvbmFyeSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgIGlmIChmbGFncyAmIDgpIEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG4gICAgICBpZiAoZmxhZ3MgJiAxKSB0aGlzLnByb2plY3QuX2NoYW5nZWQoZmxhZ3MpO1xuICAgIH0sXG4gICAgZ2V0SXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZW07XG4gICAgfSxcbiAgICBzZXRJdGVtOiBmdW5jdGlvbiAoaXRlbSwgX2RvbnRDZW50ZXIpIHtcbiAgICAgIGlmIChpdGVtLl9zeW1ib2wpIGl0ZW0gPSBpdGVtLmNsb25lKCk7XG4gICAgICBpZiAodGhpcy5faXRlbSkgdGhpcy5faXRlbS5fc3ltYm9sID0gbnVsbDtcbiAgICAgIHRoaXMuX2l0ZW0gPSBpdGVtO1xuICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICAgIGl0ZW0uc2V0U2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgaWYgKCFfZG9udENlbnRlcikgaXRlbS5zZXRQb3NpdGlvbihuZXcgUG9pbnQoKSk7XG4gICAgICBpdGVtLl9zeW1ib2wgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKDkpO1xuICAgIH0sXG4gICAgZ2V0RGVmaW5pdGlvbjogJyNnZXRJdGVtJyxcbiAgICBzZXREZWZpbml0aW9uOiAnI3NldEl0ZW0nLFxuICAgIHBsYWNlOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBuZXcgU3ltYm9sSXRlbSh0aGlzLCBwb3NpdGlvbik7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTeW1ib2xEZWZpbml0aW9uKHRoaXMuX2l0ZW0uY2xvbmUoZmFsc2UpKTtcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbCA9PT0gdGhpcyB8fCBzeW1ib2wgJiYgdGhpcy5faXRlbS5lcXVhbHMoc3ltYm9sLl9pdGVtKSB8fCBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgSGl0UmVzdWx0ID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0hpdFJlc3VsdCcsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gSGl0UmVzdWx0KHR5cGUsIGl0ZW0sIHZhbHVlcykge1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgICBpZiAodmFsdWVzKSB0aGlzLmluamVjdCh2YWx1ZXMpO1xuICAgIH0sXG4gICAgc3RhdGljczoge1xuICAgICAgZ2V0T3B0aW9uczogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzICYmIEJhc2UucmVhZChhcmdzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlKHtcbiAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgIHRvbGVyYW5jZTogcGFwZXIuc2V0dGluZ3MuaGl0VG9sZXJhbmNlLFxuICAgICAgICAgIGZpbGw6ICFvcHRpb25zLFxuICAgICAgICAgIHN0cm9rZTogIW9wdGlvbnMsXG4gICAgICAgICAgc2VnbWVudHM6ICFvcHRpb25zLFxuICAgICAgICAgIGhhbmRsZXM6IGZhbHNlLFxuICAgICAgICAgIGVuZHM6IGZhbHNlLFxuICAgICAgICAgIHBvc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgICBjZW50ZXI6IGZhbHNlLFxuICAgICAgICAgIGJvdW5kczogZmFsc2UsXG4gICAgICAgICAgZ3VpZGVzOiBmYWxzZSxcbiAgICAgICAgICBzZWxlY3RlZDogZmFsc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIFNlZ21lbnQgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnU2VnbWVudCcsXG4gICAgYmVhbnM6IHRydWUsXG4gICAgX3NlbGVjdGlvbjogMCxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBTZWdtZW50KGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgICAgIHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgaGFuZGxlSW4sXG4gICAgICAgICAgaGFuZGxlT3V0LFxuICAgICAgICAgIHNlbGVjdGlvbjtcblxuICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICBpZiAoYXJnMCA9PSBudWxsIHx8IHR5cGVvZiBhcmcwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChjb3VudCA9PT0gMSAmJiBhcmcwICYmICdwb2ludCcgaW4gYXJnMCkge1xuICAgICAgICAgICAgcG9pbnQgPSBhcmcwLnBvaW50O1xuICAgICAgICAgICAgaGFuZGxlSW4gPSBhcmcwLmhhbmRsZUluO1xuICAgICAgICAgICAgaGFuZGxlT3V0ID0gYXJnMC5oYW5kbGVPdXQ7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBhcmcwLnNlbGVjdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnQgPSBhcmcwO1xuICAgICAgICAgICAgaGFuZGxlSW4gPSBhcmcxO1xuICAgICAgICAgICAgaGFuZGxlT3V0ID0gYXJnMjtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IGFyZzM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50ID0gW2FyZzAsIGFyZzFdO1xuICAgICAgICAgIGhhbmRsZUluID0gYXJnMiAhPT0gdW5kZWZpbmVkID8gW2FyZzIsIGFyZzNdIDogbnVsbDtcbiAgICAgICAgICBoYW5kbGVPdXQgPSBhcmc0ICE9PSB1bmRlZmluZWQgPyBbYXJnNCwgYXJnNV0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ldyBTZWdtZW50UG9pbnQocG9pbnQsIHRoaXMsICdfcG9pbnQnKTtcbiAgICAgIG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlSW4sIHRoaXMsICdfaGFuZGxlSW4nKTtcbiAgICAgIG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlT3V0LCB0aGlzLCAnX2hhbmRsZU91dCcpO1xuICAgICAgaWYgKHNlbGVjdGlvbikgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLl9wb2ludCxcbiAgICAgICAgICBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb24sXG4gICAgICAgICAgb2JqID0gc2VsZWN0aW9uIHx8IHRoaXMuaGFzSGFuZGxlcygpID8gW3BvaW50LCB0aGlzLl9oYW5kbGVJbiwgdGhpcy5faGFuZGxlT3V0XSA6IHBvaW50O1xuICAgICAgaWYgKHNlbGVjdGlvbikgb2JqLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgIHJldHVybiBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgaWYgKCFwYXRoKSByZXR1cm47XG4gICAgICB2YXIgY3VydmVzID0gcGF0aC5fY3VydmVzLFxuICAgICAgICAgIGluZGV4ID0gdGhpcy5faW5kZXgsXG4gICAgICAgICAgY3VydmU7XG5cbiAgICAgIGlmIChjdXJ2ZXMpIHtcbiAgICAgICAgaWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVJbikgJiYgKGN1cnZlID0gaW5kZXggPiAwID8gY3VydmVzW2luZGV4IC0gMV0gOiBwYXRoLl9jbG9zZWQgPyBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdIDogbnVsbCkpIGN1cnZlLl9jaGFuZ2VkKCk7XG4gICAgICAgIGlmICgoIXBvaW50IHx8IHBvaW50ID09PSB0aGlzLl9wb2ludCB8fCBwb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0KSAmJiAoY3VydmUgPSBjdXJ2ZXNbaW5kZXhdKSkgY3VydmUuX2NoYW5nZWQoKTtcbiAgICAgIH1cblxuICAgICAgcGF0aC5fY2hhbmdlZCg0MSk7XG4gICAgfSxcbiAgICBnZXRQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BvaW50O1xuICAgIH0sXG4gICAgc2V0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3BvaW50LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZ2V0SGFuZGxlSW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVJbjtcbiAgICB9LFxuICAgIHNldEhhbmRsZUluOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9oYW5kbGVJbi5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGdldEhhbmRsZU91dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU91dDtcbiAgICB9LFxuICAgIHNldEhhbmRsZU91dDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5faGFuZGxlT3V0LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgaGFzSGFuZGxlczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpO1xuICAgIH0sXG4gICAgaXNTbW9vdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoYW5kbGVJbiA9IHRoaXMuX2hhbmRsZUluLFxuICAgICAgICAgIGhhbmRsZU91dCA9IHRoaXMuX2hhbmRsZU91dDtcbiAgICAgIHJldHVybiAhaGFuZGxlSW4uaXNaZXJvKCkgJiYgIWhhbmRsZU91dC5pc1plcm8oKSAmJiBoYW5kbGVJbi5pc0NvbGxpbmVhcihoYW5kbGVPdXQpO1xuICAgIH0sXG4gICAgY2xlYXJIYW5kbGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9oYW5kbGVJbi5fc2V0KDAsIDApO1xuXG4gICAgICB0aGlzLl9oYW5kbGVPdXQuX3NldCgwLCAwKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbjtcbiAgICB9LFxuICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgdmFyIG9sZFNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbixcbiAgICAgICAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IHNlbGVjdGlvbiA9IHNlbGVjdGlvbiB8fCAwO1xuXG4gICAgICBpZiAocGF0aCAmJiBzZWxlY3Rpb24gIT09IG9sZFNlbGVjdGlvbikge1xuICAgICAgICBwYXRoLl91cGRhdGVTZWxlY3Rpb24odGhpcywgb2xkU2VsZWN0aW9uLCBzZWxlY3Rpb24pO1xuXG4gICAgICAgIHBhdGguX2NoYW5nZWQoMjU3KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jaGFuZ2VTZWxlY3Rpb246IGZ1bmN0aW9uIChmbGFnLCBzZWxlY3RlZCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbjtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGVkID8gc2VsZWN0aW9uIHwgZmxhZyA6IHNlbGVjdGlvbiAmIH5mbGFnKTtcbiAgICB9LFxuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLl9zZWxlY3Rpb24gJiA3KTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGVkOiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuX2NoYW5nZVNlbGVjdGlvbig3LCBzZWxlY3RlZCk7XG4gICAgfSxcbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLl9pbmRleCA6IG51bGw7XG4gICAgfSxcbiAgICBnZXRQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGF0aCB8fCBudWxsO1xuICAgIH0sXG4gICAgZ2V0Q3VydmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aCxcbiAgICAgICAgICBpbmRleCA9IHRoaXMuX2luZGV4O1xuXG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBpZiAoaW5kZXggPiAwICYmICFwYXRoLl9jbG9zZWQgJiYgaW5kZXggPT09IHBhdGguX3NlZ21lbnRzLmxlbmd0aCAtIDEpIGluZGV4LS07XG4gICAgICAgIHJldHVybiBwYXRoLmdldEN1cnZlcygpW2luZGV4XSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG4gICAgICByZXR1cm4gY3VydmUgPyBuZXcgQ3VydmVMb2NhdGlvbihjdXJ2ZSwgdGhpcyA9PT0gY3VydmUuX3NlZ21lbnQxID8gMCA6IDEpIDogbnVsbDtcbiAgICB9LFxuICAgIGdldE5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG4gICAgICByZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4ICsgMV0gfHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzWzBdKSB8fCBudWxsO1xuICAgIH0sXG4gICAgc21vb3RoOiBmdW5jdGlvbiAob3B0aW9ucywgX2ZpcnN0LCBfbGFzdCkge1xuICAgICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICAgIHR5cGUgPSBvcHRzLnR5cGUsXG4gICAgICAgICAgZmFjdG9yID0gb3B0cy5mYWN0b3IsXG4gICAgICAgICAgcHJldiA9IHRoaXMuZ2V0UHJldmlvdXMoKSxcbiAgICAgICAgICBuZXh0ID0gdGhpcy5nZXROZXh0KCksXG4gICAgICAgICAgcDAgPSAocHJldiB8fCB0aGlzKS5fcG9pbnQsXG4gICAgICAgICAgcDEgPSB0aGlzLl9wb2ludCxcbiAgICAgICAgICBwMiA9IChuZXh0IHx8IHRoaXMpLl9wb2ludCxcbiAgICAgICAgICBkMSA9IHAwLmdldERpc3RhbmNlKHAxKSxcbiAgICAgICAgICBkMiA9IHAxLmdldERpc3RhbmNlKHAyKTtcblxuICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdjYXRtdWxsLXJvbScpIHtcbiAgICAgICAgdmFyIGEgPSBmYWN0b3IgPT09IHVuZGVmaW5lZCA/IDAuNSA6IGZhY3RvcixcbiAgICAgICAgICAgIGQxX2EgPSBNYXRoLnBvdyhkMSwgYSksXG4gICAgICAgICAgICBkMV8yYSA9IGQxX2EgKiBkMV9hLFxuICAgICAgICAgICAgZDJfYSA9IE1hdGgucG93KGQyLCBhKSxcbiAgICAgICAgICAgIGQyXzJhID0gZDJfYSAqIGQyX2E7XG5cbiAgICAgICAgaWYgKCFfZmlyc3QgJiYgcHJldikge1xuICAgICAgICAgIHZhciBBID0gMiAqIGQyXzJhICsgMyAqIGQyX2EgKiBkMV9hICsgZDFfMmEsXG4gICAgICAgICAgICAgIE4gPSAzICogZDJfYSAqIChkMl9hICsgZDFfYSk7XG4gICAgICAgICAgdGhpcy5zZXRIYW5kbGVJbihOICE9PSAwID8gbmV3IFBvaW50KChkMl8yYSAqIHAwLl94ICsgQSAqIHAxLl94IC0gZDFfMmEgKiBwMi5feCkgLyBOIC0gcDEuX3gsIChkMl8yYSAqIHAwLl95ICsgQSAqIHAxLl95IC0gZDFfMmEgKiBwMi5feSkgLyBOIC0gcDEuX3kpIDogbmV3IFBvaW50KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFfbGFzdCAmJiBuZXh0KSB7XG4gICAgICAgICAgdmFyIEEgPSAyICogZDFfMmEgKyAzICogZDFfYSAqIGQyX2EgKyBkMl8yYSxcbiAgICAgICAgICAgICAgTiA9IDMgKiBkMV9hICogKGQxX2EgKyBkMl9hKTtcbiAgICAgICAgICB0aGlzLnNldEhhbmRsZU91dChOICE9PSAwID8gbmV3IFBvaW50KChkMV8yYSAqIHAyLl94ICsgQSAqIHAxLl94IC0gZDJfMmEgKiBwMC5feCkgLyBOIC0gcDEuX3gsIChkMV8yYSAqIHAyLl95ICsgQSAqIHAxLl95IC0gZDJfMmEgKiBwMC5feSkgLyBOIC0gcDEuX3kpIDogbmV3IFBvaW50KCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdnZW9tZXRyaWMnKSB7XG4gICAgICAgIGlmIChwcmV2ICYmIG5leHQpIHtcbiAgICAgICAgICB2YXIgdmVjdG9yID0gcDAuc3VidHJhY3QocDIpLFxuICAgICAgICAgICAgICB0ID0gZmFjdG9yID09PSB1bmRlZmluZWQgPyAwLjQgOiBmYWN0b3IsXG4gICAgICAgICAgICAgIGsgPSB0ICogZDEgLyAoZDEgKyBkMik7XG4gICAgICAgICAgaWYgKCFfZmlyc3QpIHRoaXMuc2V0SGFuZGxlSW4odmVjdG9yLm11bHRpcGx5KGspKTtcbiAgICAgICAgICBpZiAoIV9sYXN0KSB0aGlzLnNldEhhbmRsZU91dCh2ZWN0b3IubXVsdGlwbHkoayAtIHQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTbW9vdGhpbmcgbWV0aG9kIFxcJycgKyB0eXBlICsgJ1xcJyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UHJldmlvdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG4gICAgICByZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4IC0gMV0gfHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuICAgIH0sXG4gICAgaXNGaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9pbmRleDtcbiAgICB9LFxuICAgIGlzTGFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgcmV0dXJuIHBhdGggJiYgdGhpcy5faW5kZXggPT09IHBhdGguX3NlZ21lbnRzLmxlbmd0aCAtIDEgfHwgZmFsc2U7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGFuZGxlSW4gPSB0aGlzLl9oYW5kbGVJbixcbiAgICAgICAgICBoYW5kbGVPdXQgPSB0aGlzLl9oYW5kbGVPdXQsXG4gICAgICAgICAgdG1wID0gaGFuZGxlSW4uY2xvbmUoKTtcbiAgICAgIGhhbmRsZUluLnNldChoYW5kbGVPdXQpO1xuICAgICAgaGFuZGxlT3V0LnNldCh0bXApO1xuICAgIH0sXG4gICAgcmV2ZXJzZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlT3V0LCB0aGlzLl9oYW5kbGVJbik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXRoID8gISF0aGlzLl9wYXRoLnJlbW92ZVNlZ21lbnQodGhpcy5faW5kZXgpIDogZmFsc2U7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTZWdtZW50KHRoaXMuX3BvaW50LCB0aGlzLl9oYW5kbGVJbiwgdGhpcy5faGFuZGxlT3V0KTtcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgIHJldHVybiBzZWdtZW50ID09PSB0aGlzIHx8IHNlZ21lbnQgJiYgdGhpcy5fY2xhc3MgPT09IHNlZ21lbnQuX2NsYXNzICYmIHRoaXMuX3BvaW50LmVxdWFscyhzZWdtZW50Ll9wb2ludCkgJiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKSAmJiB0aGlzLl9oYW5kbGVPdXQuZXF1YWxzKHNlZ21lbnQuX2hhbmRsZU91dCkgfHwgZmFsc2U7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcnRzID0gWydwb2ludDogJyArIHRoaXMuX3BvaW50XTtcbiAgICAgIGlmICghdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkpIHBhcnRzLnB1c2goJ2hhbmRsZUluOiAnICsgdGhpcy5faGFuZGxlSW4pO1xuICAgICAgaWYgKCF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkpIHBhcnRzLnB1c2goJ2hhbmRsZU91dDogJyArIHRoaXMuX2hhbmRsZU91dCk7XG4gICAgICByZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9LFxuICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgICAgdmFyIHUgPSAxIC0gZmFjdG9yLFxuICAgICAgICAgIHYgPSBmYWN0b3IsXG4gICAgICAgICAgcG9pbnQxID0gZnJvbS5fcG9pbnQsXG4gICAgICAgICAgcG9pbnQyID0gdG8uX3BvaW50LFxuICAgICAgICAgIGhhbmRsZUluMSA9IGZyb20uX2hhbmRsZUluLFxuICAgICAgICAgIGhhbmRsZUluMiA9IHRvLl9oYW5kbGVJbixcbiAgICAgICAgICBoYW5kbGVPdXQyID0gdG8uX2hhbmRsZU91dCxcbiAgICAgICAgICBoYW5kbGVPdXQxID0gZnJvbS5faGFuZGxlT3V0O1xuXG4gICAgICB0aGlzLl9wb2ludC5fc2V0KHUgKiBwb2ludDEuX3ggKyB2ICogcG9pbnQyLl94LCB1ICogcG9pbnQxLl95ICsgdiAqIHBvaW50Mi5feSwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuX2hhbmRsZUluLl9zZXQodSAqIGhhbmRsZUluMS5feCArIHYgKiBoYW5kbGVJbjIuX3gsIHUgKiBoYW5kbGVJbjEuX3kgKyB2ICogaGFuZGxlSW4yLl95LCB0cnVlKTtcblxuICAgICAgdGhpcy5faGFuZGxlT3V0Ll9zZXQodSAqIGhhbmRsZU91dDEuX3ggKyB2ICogaGFuZGxlT3V0Mi5feCwgdSAqIGhhbmRsZU91dDEuX3kgKyB2ICogaGFuZGxlT3V0Mi5feSwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9LFxuICAgIF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24gKG1hdHJpeCwgY29vcmRzLCBjaGFuZ2UpIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMuX3BvaW50LFxuICAgICAgICAgIGhhbmRsZUluID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkgPyB0aGlzLl9oYW5kbGVJbiA6IG51bGwsXG4gICAgICAgICAgaGFuZGxlT3V0ID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpID8gdGhpcy5faGFuZGxlT3V0IDogbnVsbCxcbiAgICAgICAgICB4ID0gcG9pbnQuX3gsXG4gICAgICAgICAgeSA9IHBvaW50Ll95LFxuICAgICAgICAgIGkgPSAyO1xuICAgICAgY29vcmRzWzBdID0geDtcbiAgICAgIGNvb3Jkc1sxXSA9IHk7XG5cbiAgICAgIGlmIChoYW5kbGVJbikge1xuICAgICAgICBjb29yZHNbaSsrXSA9IGhhbmRsZUluLl94ICsgeDtcbiAgICAgICAgY29vcmRzW2krK10gPSBoYW5kbGVJbi5feSArIHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYW5kbGVPdXQpIHtcbiAgICAgICAgY29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3ggKyB4O1xuICAgICAgICBjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feSArIHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgbWF0cml4Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIGNvb3JkcywgaSAvIDIpO1xuXG4gICAgICAgIHggPSBjb29yZHNbMF07XG4gICAgICAgIHkgPSBjb29yZHNbMV07XG5cbiAgICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICAgIHBvaW50Ll94ID0geDtcbiAgICAgICAgICBwb2ludC5feSA9IHk7XG4gICAgICAgICAgaSA9IDI7XG5cbiAgICAgICAgICBpZiAoaGFuZGxlSW4pIHtcbiAgICAgICAgICAgIGhhbmRsZUluLl94ID0gY29vcmRzW2krK10gLSB4O1xuICAgICAgICAgICAgaGFuZGxlSW4uX3kgPSBjb29yZHNbaSsrXSAtIHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhbmRsZU91dCkge1xuICAgICAgICAgICAgaGFuZGxlT3V0Ll94ID0gY29vcmRzW2krK10gLSB4O1xuICAgICAgICAgICAgaGFuZGxlT3V0Ll95ID0gY29vcmRzW2krK10gLSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWhhbmRsZUluKSB7XG4gICAgICAgICAgICBjb29yZHNbaSsrXSA9IHg7XG4gICAgICAgICAgICBjb29yZHNbaSsrXSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFoYW5kbGVPdXQpIHtcbiAgICAgICAgICAgIGNvb3Jkc1tpKytdID0geDtcbiAgICAgICAgICAgIGNvb3Jkc1tpKytdID0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9XG4gIH0pO1xuICB2YXIgU2VnbWVudFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBTZWdtZW50UG9pbnQocG9pbnQsIG93bmVyLCBrZXkpIHtcbiAgICAgIHZhciB4LCB5LCBzZWxlY3RlZDtcblxuICAgICAgaWYgKCFwb2ludCkge1xuICAgICAgICB4ID0geSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCh4ID0gcG9pbnRbMF0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeSA9IHBvaW50WzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnQ7XG5cbiAgICAgICAgaWYgKCh4ID0gcHQueCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHB0ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICAgIHggPSBwdC54O1xuICAgICAgICB9XG5cbiAgICAgICAgeSA9IHB0Lnk7XG4gICAgICAgIHNlbGVjdGVkID0gcHQuc2VsZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLl9vd25lciA9IG93bmVyO1xuICAgICAgb3duZXJba2V5XSA9IHRoaXM7XG4gICAgICBpZiAoc2VsZWN0ZWQpIHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG4gICAgfSxcbiAgICBfc2V0OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcblxuICAgICAgdGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0WDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfSxcbiAgICBzZXRYOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5feCA9IHg7XG5cbiAgICAgIHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0WTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfSxcbiAgICBzZXRZOiBmdW5jdGlvbiAoeSkge1xuICAgICAgdGhpcy5feSA9IHk7XG5cbiAgICAgIHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuICAgIH0sXG4gICAgaXNaZXJvOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcbiAgICAgIHJldHVybiBpc1plcm8odGhpcy5feCkgJiYgaXNaZXJvKHRoaXMuX3kpO1xuICAgIH0sXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuX293bmVyLl9zZWxlY3Rpb24gJiB0aGlzLl9nZXRTZWxlY3Rpb24oKSk7XG4gICAgfSxcbiAgICBzZXRTZWxlY3RlZDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICB0aGlzLl9vd25lci5fY2hhbmdlU2VsZWN0aW9uKHRoaXMuX2dldFNlbGVjdGlvbigpLCBzZWxlY3RlZCk7XG4gICAgfSxcbiAgICBfZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcbiAgICAgIHJldHVybiB0aGlzID09PSBvd25lci5fcG9pbnQgPyAxIDogdGhpcyA9PT0gb3duZXIuX2hhbmRsZUluID8gMiA6IHRoaXMgPT09IG93bmVyLl9oYW5kbGVPdXQgPyA0IDogMDtcbiAgICB9XG4gIH0pO1xuICB2YXIgQ3VydmUgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnQ3VydmUnLFxuICAgIGJlYW5zOiB0cnVlLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcpIHtcbiAgICAgIHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgc2VnMSxcbiAgICAgICAgICBzZWcyLFxuICAgICAgICAgIHBvaW50MSxcbiAgICAgICAgICBwb2ludDIsXG4gICAgICAgICAgaGFuZGxlMSxcbiAgICAgICAgICBoYW5kbGUyO1xuXG4gICAgICBpZiAoY291bnQgPT09IDMpIHtcbiAgICAgICAgdGhpcy5fcGF0aCA9IGFyZzA7XG4gICAgICAgIHNlZzEgPSBhcmcxO1xuICAgICAgICBzZWcyID0gYXJnMjtcbiAgICAgIH0gZWxzZSBpZiAoIWNvdW50KSB7XG4gICAgICAgIHNlZzEgPSBuZXcgU2VnbWVudCgpO1xuICAgICAgICBzZWcyID0gbmV3IFNlZ21lbnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgaWYgKCdzZWdtZW50MScgaW4gYXJnMCkge1xuICAgICAgICAgIHNlZzEgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQxKTtcbiAgICAgICAgICBzZWcyID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50Mik7XG4gICAgICAgIH0gZWxzZSBpZiAoJ3BvaW50MScgaW4gYXJnMCkge1xuICAgICAgICAgIHBvaW50MSA9IGFyZzAucG9pbnQxO1xuICAgICAgICAgIGhhbmRsZTEgPSBhcmcwLmhhbmRsZTE7XG4gICAgICAgICAgaGFuZGxlMiA9IGFyZzAuaGFuZGxlMjtcbiAgICAgICAgICBwb2ludDIgPSBhcmcwLnBvaW50MjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG4gICAgICAgICAgcG9pbnQxID0gW2FyZzBbMF0sIGFyZzBbMV1dO1xuICAgICAgICAgIHBvaW50MiA9IFthcmcwWzZdLCBhcmcwWzddXTtcbiAgICAgICAgICBoYW5kbGUxID0gW2FyZzBbMl0gLSBhcmcwWzBdLCBhcmcwWzNdIC0gYXJnMFsxXV07XG4gICAgICAgICAgaGFuZGxlMiA9IFthcmcwWzRdIC0gYXJnMFs2XSwgYXJnMFs1XSAtIGFyZzBbN11dO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAyKSB7XG4gICAgICAgIHNlZzEgPSBuZXcgU2VnbWVudChhcmcwKTtcbiAgICAgICAgc2VnMiA9IG5ldyBTZWdtZW50KGFyZzEpO1xuICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gNCkge1xuICAgICAgICBwb2ludDEgPSBhcmcwO1xuICAgICAgICBoYW5kbGUxID0gYXJnMTtcbiAgICAgICAgaGFuZGxlMiA9IGFyZzI7XG4gICAgICAgIHBvaW50MiA9IGFyZzM7XG4gICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSA4KSB7XG4gICAgICAgIHBvaW50MSA9IFthcmcwLCBhcmcxXTtcbiAgICAgICAgcG9pbnQyID0gW2FyZzYsIGFyZzddO1xuICAgICAgICBoYW5kbGUxID0gW2FyZzIgLSBhcmcwLCBhcmczIC0gYXJnMV07XG4gICAgICAgIGhhbmRsZTIgPSBbYXJnNCAtIGFyZzYsIGFyZzUgLSBhcmc3XTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VnbWVudDEgPSBzZWcxIHx8IG5ldyBTZWdtZW50KHBvaW50MSwgbnVsbCwgaGFuZGxlMSk7XG4gICAgICB0aGlzLl9zZWdtZW50MiA9IHNlZzIgfHwgbmV3IFNlZ21lbnQocG9pbnQyLCBoYW5kbGUyLCBudWxsKTtcbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5oYXNIYW5kbGVzKCkgPyBbdGhpcy5nZXRQb2ludDEoKSwgdGhpcy5nZXRIYW5kbGUxKCksIHRoaXMuZ2V0SGFuZGxlMigpLCB0aGlzLmdldFBvaW50MigpXSA6IFt0aGlzLmdldFBvaW50MSgpLCB0aGlzLmdldFBvaW50MigpXSwgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgQ3VydmUodGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFydHMgPSBbJ3BvaW50MTogJyArIHRoaXMuX3NlZ21lbnQxLl9wb2ludF07XG4gICAgICBpZiAoIXRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKCkpIHBhcnRzLnB1c2goJ2hhbmRsZTE6ICcgKyB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0KTtcbiAgICAgIGlmICghdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLmlzWmVybygpKSBwYXJ0cy5wdXNoKCdoYW5kbGUyOiAnICsgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluKTtcbiAgICAgIHBhcnRzLnB1c2goJ3BvaW50MjogJyArIHRoaXMuX3NlZ21lbnQyLl9wb2ludCk7XG4gICAgICByZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH0sXG4gICAgY2xhc3NpZnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBDdXJ2ZS5jbGFzc2lmeSh0aGlzLmdldFZhbHVlcygpKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlbW92ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX3BhdGgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQyID0gdGhpcy5fc2VnbWVudDIsXG4gICAgICAgICAgICBoYW5kbGVPdXQgPSBzZWdtZW50Mi5faGFuZGxlT3V0O1xuICAgICAgICByZW1vdmVkID0gc2VnbWVudDIucmVtb3ZlKCk7XG4gICAgICAgIGlmIChyZW1vdmVkKSB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChoYW5kbGVPdXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuICAgIGdldFBvaW50MTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9wb2ludDtcbiAgICB9LFxuICAgIHNldFBvaW50MTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc2VnbWVudDEuX3BvaW50LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZ2V0UG9pbnQyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VnbWVudDIuX3BvaW50O1xuICAgIH0sXG4gICAgc2V0UG9pbnQyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zZWdtZW50Mi5fcG9pbnQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBnZXRIYW5kbGUxOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dDtcbiAgICB9LFxuICAgIHNldEhhbmRsZTE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBnZXRIYW5kbGUyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluO1xuICAgIH0sXG4gICAgc2V0SGFuZGxlMjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZ2V0U2VnbWVudDE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50MTtcbiAgICB9LFxuICAgIGdldFNlZ21lbnQyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VnbWVudDI7XG4gICAgfSxcbiAgICBnZXRQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGF0aDtcbiAgICB9LFxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VnbWVudDEuX2luZGV4O1xuICAgIH0sXG4gICAgZ2V0TmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuICAgICAgcmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCArIDFdIHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbMF0pIHx8IG51bGw7XG4gICAgfSxcbiAgICBnZXRQcmV2aW91czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuICAgICAgcmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCAtIDFdIHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuICAgIH0sXG4gICAgaXNGaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9zZWdtZW50MS5faW5kZXg7XG4gICAgfSxcbiAgICBpc0xhc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgIHJldHVybiBwYXRoICYmIHRoaXMuX3NlZ21lbnQxLl9pbmRleCA9PT0gcGF0aC5fY3VydmVzLmxlbmd0aCAtIDEgfHwgZmFsc2U7XG4gICAgfSxcbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQb2ludDEoKS5pc1NlbGVjdGVkKCkgJiYgdGhpcy5nZXRIYW5kbGUxKCkuaXNTZWxlY3RlZCgpICYmIHRoaXMuZ2V0SGFuZGxlMigpLmlzU2VsZWN0ZWQoKSAmJiB0aGlzLmdldFBvaW50MigpLmlzU2VsZWN0ZWQoKTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGVkOiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuZ2V0UG9pbnQxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuICAgICAgdGhpcy5nZXRIYW5kbGUxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuICAgICAgdGhpcy5nZXRIYW5kbGUyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuICAgICAgdGhpcy5nZXRQb2ludDIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG4gICAgfSxcbiAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgIHJldHVybiBDdXJ2ZS5nZXRWYWx1ZXModGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyLCBtYXRyaXgpO1xuICAgIH0sXG4gICAgZ2V0UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5nZXRWYWx1ZXMoKSxcbiAgICAgICAgICBwb2ludHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpIHBvaW50cy5wdXNoKG5ldyBQb2ludChjb29yZHNbaV0sIGNvb3Jkc1tpICsgMV0pKTtcblxuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gIH0sIHtcbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkgdGhpcy5fbGVuZ3RoID0gQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIDAsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9LFxuICAgIGdldEFyZWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBDdXJ2ZS5nZXRBcmVhKHRoaXMuZ2V0VmFsdWVzKCkpO1xuICAgIH0sXG4gICAgZ2V0TGluZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBMaW5lKHRoaXMuX3NlZ21lbnQxLl9wb2ludCwgdGhpcy5fc2VnbWVudDIuX3BvaW50KTtcbiAgICB9LFxuICAgIGdldFBhcnQ6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIG5ldyBDdXJ2ZShDdXJ2ZS5nZXRQYXJ0KHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKSk7XG4gICAgfSxcbiAgICBnZXRQYXJ0TGVuZ3RoOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pO1xuICAgIH0sXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlQXRUaW1lKGxvY2F0aW9uICYmIGxvY2F0aW9uLmN1cnZlID09PSB0aGlzID8gbG9jYXRpb24udGltZSA6IHRoaXMuZ2V0VGltZUF0KGxvY2F0aW9uKSk7XG4gICAgfSxcbiAgICBkaXZpZGVBdFRpbWU6IGZ1bmN0aW9uICh0aW1lLCBfc2V0SGFuZGxlcykge1xuICAgICAgdmFyIHRNaW4gPSAxZS04LFxuICAgICAgICAgIHRNYXggPSAxIC0gdE1pbixcbiAgICAgICAgICByZXMgPSBudWxsO1xuXG4gICAgICBpZiAodGltZSA+PSB0TWluICYmIHRpbWUgPD0gdE1heCkge1xuICAgICAgICB2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodGhpcy5nZXRWYWx1ZXMoKSwgdGltZSksXG4gICAgICAgICAgICBsZWZ0ID0gcGFydHNbMF0sXG4gICAgICAgICAgICByaWdodCA9IHBhcnRzWzFdLFxuICAgICAgICAgICAgc2V0SGFuZGxlcyA9IF9zZXRIYW5kbGVzIHx8IHRoaXMuaGFzSGFuZGxlcygpLFxuICAgICAgICAgICAgc2VnMSA9IHRoaXMuX3NlZ21lbnQxLFxuICAgICAgICAgICAgc2VnMiA9IHRoaXMuX3NlZ21lbnQyLFxuICAgICAgICAgICAgcGF0aCA9IHRoaXMuX3BhdGg7XG5cbiAgICAgICAgaWYgKHNldEhhbmRsZXMpIHtcbiAgICAgICAgICBzZWcxLl9oYW5kbGVPdXQuX3NldChsZWZ0WzJdIC0gbGVmdFswXSwgbGVmdFszXSAtIGxlZnRbMV0pO1xuXG4gICAgICAgICAgc2VnMi5faGFuZGxlSW4uX3NldChyaWdodFs0XSAtIHJpZ2h0WzZdLCByaWdodFs1XSAtIHJpZ2h0WzddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gbGVmdFs2XSxcbiAgICAgICAgICAgIHkgPSBsZWZ0WzddLFxuICAgICAgICAgICAgc2VnbWVudCA9IG5ldyBTZWdtZW50KG5ldyBQb2ludCh4LCB5KSwgc2V0SGFuZGxlcyAmJiBuZXcgUG9pbnQobGVmdFs0XSAtIHgsIGxlZnRbNV0gLSB5KSwgc2V0SGFuZGxlcyAmJiBuZXcgUG9pbnQocmlnaHRbMl0gLSB4LCByaWdodFszXSAtIHkpKTtcblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHBhdGguaW5zZXJ0KHNlZzEuX2luZGV4ICsgMSwgc2VnbWVudCk7XG4gICAgICAgICAgcmVzID0gdGhpcy5nZXROZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2VnbWVudDIgPSBzZWdtZW50O1xuXG4gICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuXG4gICAgICAgICAgcmVzID0gbmV3IEN1cnZlKHNlZ21lbnQsIHNlZzIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBzcGxpdEF0OiBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgIHJldHVybiBwYXRoID8gcGF0aC5zcGxpdEF0KGxvY2F0aW9uKSA6IG51bGw7XG4gICAgfSxcbiAgICBzcGxpdEF0VGltZTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGl0QXQodGhpcy5nZXRMb2NhdGlvbkF0VGltZSh0aW1lKSk7XG4gICAgfSxcbiAgICBkaXZpZGU6IGZ1bmN0aW9uIChvZmZzZXQsIGlzVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlQXRUaW1lKG9mZnNldCA9PT0gdW5kZWZpbmVkID8gMC41IDogaXNUaW1lID8gb2Zmc2V0IDogdGhpcy5nZXRUaW1lQXQob2Zmc2V0KSk7XG4gICAgfSxcbiAgICBzcGxpdDogZnVuY3Rpb24gKG9mZnNldCwgaXNUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpdEF0VGltZShvZmZzZXQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IGlzVGltZSA/IG9mZnNldCA6IHRoaXMuZ2V0VGltZUF0KG9mZnNldCkpO1xuICAgIH0sXG4gICAgcmV2ZXJzZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgQ3VydmUodGhpcy5fc2VnbWVudDIucmV2ZXJzZWQoKSwgdGhpcy5fc2VnbWVudDEucmV2ZXJzZWQoKSk7XG4gICAgfSxcbiAgICBjbGVhckhhbmRsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuX3NldCgwLCAwKTtcblxuICAgICAgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLl9zZXQoMCwgMCk7XG4gICAgfSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uIChzZWdtZW50MSwgc2VnbWVudDIsIG1hdHJpeCwgc3RyYWlnaHQpIHtcbiAgICAgICAgdmFyIHAxID0gc2VnbWVudDEuX3BvaW50LFxuICAgICAgICAgICAgaDEgPSBzZWdtZW50MS5faGFuZGxlT3V0LFxuICAgICAgICAgICAgaDIgPSBzZWdtZW50Mi5faGFuZGxlSW4sXG4gICAgICAgICAgICBwMiA9IHNlZ21lbnQyLl9wb2ludCxcbiAgICAgICAgICAgIHgxID0gcDEueCxcbiAgICAgICAgICAgIHkxID0gcDEueSxcbiAgICAgICAgICAgIHgyID0gcDIueCxcbiAgICAgICAgICAgIHkyID0gcDIueSxcbiAgICAgICAgICAgIHZhbHVlcyA9IHN0cmFpZ2h0ID8gW3gxLCB5MSwgeDEsIHkxLCB4MiwgeTIsIHgyLCB5Ml0gOiBbeDEsIHkxLCB4MSArIGgxLl94LCB5MSArIGgxLl95LCB4MiArIGgyLl94LCB5MiArIGgyLl95LCB4MiwgeTJdO1xuICAgICAgICBpZiAobWF0cml4KSBtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKHZhbHVlcywgdmFsdWVzLCA0KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0sXG4gICAgICBzdWJkaXZpZGU6IGZ1bmN0aW9uICh2LCB0KSB7XG4gICAgICAgIHZhciB4MCA9IHZbMF0sXG4gICAgICAgICAgICB5MCA9IHZbMV0sXG4gICAgICAgICAgICB4MSA9IHZbMl0sXG4gICAgICAgICAgICB5MSA9IHZbM10sXG4gICAgICAgICAgICB4MiA9IHZbNF0sXG4gICAgICAgICAgICB5MiA9IHZbNV0sXG4gICAgICAgICAgICB4MyA9IHZbNl0sXG4gICAgICAgICAgICB5MyA9IHZbN107XG4gICAgICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHQgPSAwLjU7XG4gICAgICAgIHZhciB1ID0gMSAtIHQsXG4gICAgICAgICAgICB4NCA9IHUgKiB4MCArIHQgKiB4MSxcbiAgICAgICAgICAgIHk0ID0gdSAqIHkwICsgdCAqIHkxLFxuICAgICAgICAgICAgeDUgPSB1ICogeDEgKyB0ICogeDIsXG4gICAgICAgICAgICB5NSA9IHUgKiB5MSArIHQgKiB5MixcbiAgICAgICAgICAgIHg2ID0gdSAqIHgyICsgdCAqIHgzLFxuICAgICAgICAgICAgeTYgPSB1ICogeTIgKyB0ICogeTMsXG4gICAgICAgICAgICB4NyA9IHUgKiB4NCArIHQgKiB4NSxcbiAgICAgICAgICAgIHk3ID0gdSAqIHk0ICsgdCAqIHk1LFxuICAgICAgICAgICAgeDggPSB1ICogeDUgKyB0ICogeDYsXG4gICAgICAgICAgICB5OCA9IHUgKiB5NSArIHQgKiB5NixcbiAgICAgICAgICAgIHg5ID0gdSAqIHg3ICsgdCAqIHg4LFxuICAgICAgICAgICAgeTkgPSB1ICogeTcgKyB0ICogeTg7XG4gICAgICAgIHJldHVybiBbW3gwLCB5MCwgeDQsIHk0LCB4NywgeTcsIHg5LCB5OV0sIFt4OSwgeTksIHg4LCB5OCwgeDYsIHk2LCB4MywgeTNdXTtcbiAgICAgIH0sXG4gICAgICBnZXRNb25vQ3VydmVzOiBmdW5jdGlvbiAodiwgZGlyKSB7XG4gICAgICAgIHZhciBjdXJ2ZXMgPSBbXSxcbiAgICAgICAgICAgIGlvID0gZGlyID8gMCA6IDEsXG4gICAgICAgICAgICBvMCA9IHZbaW8gKyAwXSxcbiAgICAgICAgICAgIG8xID0gdltpbyArIDJdLFxuICAgICAgICAgICAgbzIgPSB2W2lvICsgNF0sXG4gICAgICAgICAgICBvMyA9IHZbaW8gKyA2XTtcblxuICAgICAgICBpZiAobzAgPj0gbzEgPT09IG8xID49IG8yICYmIG8xID49IG8yID09PSBvMiA+PSBvMyB8fCBDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG4gICAgICAgICAgY3VydmVzLnB1c2godik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGEgPSAzICogKG8xIC0gbzIpIC0gbzAgKyBvMyxcbiAgICAgICAgICAgICAgYiA9IDIgKiAobzAgKyBvMikgLSA0ICogbzEsXG4gICAgICAgICAgICAgIGMgPSBvMSAtIG8wLFxuICAgICAgICAgICAgICB0TWluID0gMWUtOCxcbiAgICAgICAgICAgICAgdE1heCA9IDEgLSB0TWluLFxuICAgICAgICAgICAgICByb290cyA9IFtdLFxuICAgICAgICAgICAgICBuID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzLCB0TWluLCB0TWF4KTtcblxuICAgICAgICAgIGlmICghbikge1xuICAgICAgICAgICAgY3VydmVzLnB1c2godik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3RzLnNvcnQoKTtcbiAgICAgICAgICAgIHZhciB0ID0gcm9vdHNbMF0sXG4gICAgICAgICAgICAgICAgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgdCk7XG4gICAgICAgICAgICBjdXJ2ZXMucHVzaChwYXJ0c1swXSk7XG5cbiAgICAgICAgICAgIGlmIChuID4gMSkge1xuICAgICAgICAgICAgICB0ID0gKHJvb3RzWzFdIC0gdCkgLyAoMSAtIHQpO1xuICAgICAgICAgICAgICBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZShwYXJ0c1sxXSwgdCk7XG4gICAgICAgICAgICAgIGN1cnZlcy5wdXNoKHBhcnRzWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VydmVzLnB1c2gocGFydHNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJ2ZXM7XG4gICAgICB9LFxuICAgICAgc29sdmVDdWJpYzogZnVuY3Rpb24gKHYsIGNvb3JkLCB2YWwsIHJvb3RzLCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgdjAgPSB2W2Nvb3JkXSxcbiAgICAgICAgICAgIHYxID0gdltjb29yZCArIDJdLFxuICAgICAgICAgICAgdjIgPSB2W2Nvb3JkICsgNF0sXG4gICAgICAgICAgICB2MyA9IHZbY29vcmQgKyA2XSxcbiAgICAgICAgICAgIHJlcyA9IDA7XG5cbiAgICAgICAgaWYgKCEodjAgPCB2YWwgJiYgdjMgPCB2YWwgJiYgdjEgPCB2YWwgJiYgdjIgPCB2YWwgfHwgdjAgPiB2YWwgJiYgdjMgPiB2YWwgJiYgdjEgPiB2YWwgJiYgdjIgPiB2YWwpKSB7XG4gICAgICAgICAgdmFyIGMgPSAzICogKHYxIC0gdjApLFxuICAgICAgICAgICAgICBiID0gMyAqICh2MiAtIHYxKSAtIGMsXG4gICAgICAgICAgICAgIGEgPSB2MyAtIHYwIC0gYyAtIGI7XG4gICAgICAgICAgcmVzID0gTnVtZXJpY2FsLnNvbHZlQ3ViaWMoYSwgYiwgYywgdjAgLSB2YWwsIHJvb3RzLCBtaW4sIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSxcbiAgICAgIGdldFRpbWVPZjogZnVuY3Rpb24gKHYsIHBvaW50KSB7XG4gICAgICAgIHZhciBwMCA9IG5ldyBQb2ludCh2WzBdLCB2WzFdKSxcbiAgICAgICAgICAgIHAzID0gbmV3IFBvaW50KHZbNl0sIHZbN10pLFxuICAgICAgICAgICAgZXBzaWxvbiA9IDFlLTEyLFxuICAgICAgICAgICAgZ2VvbUVwc2lsb24gPSAxZS03LFxuICAgICAgICAgICAgdCA9IHBvaW50LmlzQ2xvc2UocDAsIGVwc2lsb24pID8gMCA6IHBvaW50LmlzQ2xvc2UocDMsIGVwc2lsb24pID8gMSA6IG51bGw7XG5cbiAgICAgICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgY29vcmRzID0gW3BvaW50LngsIHBvaW50LnldLFxuICAgICAgICAgICAgICByb290cyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCAyOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IEN1cnZlLnNvbHZlQ3ViaWModiwgYywgY29vcmRzW2NdLCByb290cywgMCwgMSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgdSA9IHJvb3RzW2ldO1xuICAgICAgICAgICAgICBpZiAocG9pbnQuaXNDbG9zZShDdXJ2ZS5nZXRQb2ludCh2LCB1KSwgZ2VvbUVwc2lsb24pKSByZXR1cm4gdTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnQuaXNDbG9zZShwMCwgZ2VvbUVwc2lsb24pID8gMCA6IHBvaW50LmlzQ2xvc2UocDMsIGdlb21FcHNpbG9uKSA/IDEgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGdldE5lYXJlc3RUaW1lOiBmdW5jdGlvbiAodiwgcG9pbnQpIHtcbiAgICAgICAgaWYgKEN1cnZlLmlzU3RyYWlnaHQodikpIHtcbiAgICAgICAgICB2YXIgeDAgPSB2WzBdLFxuICAgICAgICAgICAgICB5MCA9IHZbMV0sXG4gICAgICAgICAgICAgIHgzID0gdls2XSxcbiAgICAgICAgICAgICAgeTMgPSB2WzddLFxuICAgICAgICAgICAgICB2eCA9IHgzIC0geDAsXG4gICAgICAgICAgICAgIHZ5ID0geTMgLSB5MCxcbiAgICAgICAgICAgICAgZGV0ID0gdnggKiB2eCArIHZ5ICogdnk7XG4gICAgICAgICAgaWYgKGRldCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIHUgPSAoKHBvaW50LnggLSB4MCkgKiB2eCArIChwb2ludC55IC0geTApICogdnkpIC8gZGV0O1xuICAgICAgICAgIHJldHVybiB1IDwgMWUtMTIgPyAwIDogdSA+IDAuOTk5OTk5OTk5OTk5ID8gMSA6IEN1cnZlLmdldFRpbWVPZih2LCBuZXcgUG9pbnQoeDAgKyB1ICogdngsIHkwICsgdSAqIHZ5KSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY291bnQgPSAxMDAsXG4gICAgICAgICAgICBtaW5EaXN0ID0gSW5maW5pdHksXG4gICAgICAgICAgICBtaW5UID0gMDtcblxuICAgICAgICBmdW5jdGlvbiByZWZpbmUodCkge1xuICAgICAgICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IHBvaW50LmdldERpc3RhbmNlKEN1cnZlLmdldFBvaW50KHYsIHQpLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICBtaW5UID0gdDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKykgcmVmaW5lKGkgLyBjb3VudCk7XG5cbiAgICAgICAgdmFyIHN0ZXAgPSAxIC8gKGNvdW50ICogMik7XG5cbiAgICAgICAgd2hpbGUgKHN0ZXAgPiAxZS04KSB7XG4gICAgICAgICAgaWYgKCFyZWZpbmUobWluVCAtIHN0ZXApICYmICFyZWZpbmUobWluVCArIHN0ZXApKSBzdGVwIC89IDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluVDtcbiAgICAgIH0sXG4gICAgICBnZXRQYXJ0OiBmdW5jdGlvbiAodiwgZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGZsaXAgPSBmcm9tID4gdG87XG5cbiAgICAgICAgaWYgKGZsaXApIHtcbiAgICAgICAgICB2YXIgdG1wID0gZnJvbTtcbiAgICAgICAgICBmcm9tID0gdG87XG4gICAgICAgICAgdG8gPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJvbSA+IDApIHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgZnJvbSlbMV07XG4gICAgICAgIGlmICh0byA8IDEpIHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgKHRvIC0gZnJvbSkgLyAoMSAtIGZyb20pKVswXTtcbiAgICAgICAgcmV0dXJuIGZsaXAgPyBbdls2XSwgdls3XSwgdls0XSwgdls1XSwgdlsyXSwgdlszXSwgdlswXSwgdlsxXV0gOiB2O1xuICAgICAgfSxcbiAgICAgIGlzRmxhdEVub3VnaDogZnVuY3Rpb24gKHYsIGZsYXRuZXNzKSB7XG4gICAgICAgIHZhciB4MCA9IHZbMF0sXG4gICAgICAgICAgICB5MCA9IHZbMV0sXG4gICAgICAgICAgICB4MSA9IHZbMl0sXG4gICAgICAgICAgICB5MSA9IHZbM10sXG4gICAgICAgICAgICB4MiA9IHZbNF0sXG4gICAgICAgICAgICB5MiA9IHZbNV0sXG4gICAgICAgICAgICB4MyA9IHZbNl0sXG4gICAgICAgICAgICB5MyA9IHZbN10sXG4gICAgICAgICAgICB1eCA9IDMgKiB4MSAtIDIgKiB4MCAtIHgzLFxuICAgICAgICAgICAgdXkgPSAzICogeTEgLSAyICogeTAgLSB5MyxcbiAgICAgICAgICAgIHZ4ID0gMyAqIHgyIC0gMiAqIHgzIC0geDAsXG4gICAgICAgICAgICB2eSA9IDMgKiB5MiAtIDIgKiB5MyAtIHkwO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodXggKiB1eCwgdnggKiB2eCkgKyBNYXRoLm1heCh1eSAqIHV5LCB2eSAqIHZ5KSA8PSAxNiAqIGZsYXRuZXNzICogZmxhdG5lc3M7XG4gICAgICB9LFxuICAgICAgZ2V0QXJlYTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIHgwID0gdlswXSxcbiAgICAgICAgICAgIHkwID0gdlsxXSxcbiAgICAgICAgICAgIHgxID0gdlsyXSxcbiAgICAgICAgICAgIHkxID0gdlszXSxcbiAgICAgICAgICAgIHgyID0gdls0XSxcbiAgICAgICAgICAgIHkyID0gdls1XSxcbiAgICAgICAgICAgIHgzID0gdls2XSxcbiAgICAgICAgICAgIHkzID0gdls3XTtcbiAgICAgICAgcmV0dXJuIDMgKiAoKHkzIC0geTApICogKHgxICsgeDIpIC0gKHgzIC0geDApICogKHkxICsgeTIpICsgeTEgKiAoeDAgLSB4MikgLSB4MSAqICh5MCAtIHkyKSArIHkzICogKHgyICsgeDAgLyAzKSAtIHgzICogKHkyICsgeTAgLyAzKSkgLyAyMDtcbiAgICAgIH0sXG4gICAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBtaW4gPSB2LnNsaWNlKDAsIDIpLFxuICAgICAgICAgICAgbWF4ID0gbWluLnNsaWNlKCksXG4gICAgICAgICAgICByb290cyA9IFswLCAwXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykgQ3VydmUuX2FkZEJvdW5kcyh2W2ldLCB2W2kgKyAyXSwgdltpICsgNF0sIHZbaSArIDZdLCBpLCAwLCBtaW4sIG1heCwgcm9vdHMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG4gICAgICB9LFxuICAgICAgX2FkZEJvdW5kczogZnVuY3Rpb24gKHYwLCB2MSwgdjIsIHYzLCBjb29yZCwgcGFkZGluZywgbWluLCBtYXgsIHJvb3RzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFkZCh2YWx1ZSwgcGFkZGluZykge1xuICAgICAgICAgIHZhciBsZWZ0ID0gdmFsdWUgLSBwYWRkaW5nLFxuICAgICAgICAgICAgICByaWdodCA9IHZhbHVlICsgcGFkZGluZztcbiAgICAgICAgICBpZiAobGVmdCA8IG1pbltjb29yZF0pIG1pbltjb29yZF0gPSBsZWZ0O1xuICAgICAgICAgIGlmIChyaWdodCA+IG1heFtjb29yZF0pIG1heFtjb29yZF0gPSByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhZGRpbmcgLz0gMjtcbiAgICAgICAgdmFyIG1pblBhZCA9IG1pbltjb29yZF0gKyBwYWRkaW5nLFxuICAgICAgICAgICAgbWF4UGFkID0gbWF4W2Nvb3JkXSAtIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKHYwIDwgbWluUGFkIHx8IHYxIDwgbWluUGFkIHx8IHYyIDwgbWluUGFkIHx8IHYzIDwgbWluUGFkIHx8IHYwID4gbWF4UGFkIHx8IHYxID4gbWF4UGFkIHx8IHYyID4gbWF4UGFkIHx8IHYzID4gbWF4UGFkKSB7XG4gICAgICAgICAgaWYgKHYxIDwgdjAgIT0gdjEgPCB2MyAmJiB2MiA8IHYwICE9IHYyIDwgdjMpIHtcbiAgICAgICAgICAgIGFkZCh2MCwgMCk7XG4gICAgICAgICAgICBhZGQodjMsIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYSA9IDMgKiAodjEgLSB2MikgLSB2MCArIHYzLFxuICAgICAgICAgICAgICAgIGIgPSAyICogKHYwICsgdjIpIC0gNCAqIHYxLFxuICAgICAgICAgICAgICAgIGMgPSB2MSAtIHYwLFxuICAgICAgICAgICAgICAgIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzKSxcbiAgICAgICAgICAgICAgICB0TWluID0gMWUtOCxcbiAgICAgICAgICAgICAgICB0TWF4ID0gMSAtIHRNaW47XG4gICAgICAgICAgICBhZGQodjMsIDApO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSByb290c1tpXSxcbiAgICAgICAgICAgICAgICAgIHUgPSAxIC0gdDtcbiAgICAgICAgICAgICAgaWYgKHRNaW4gPD0gdCAmJiB0IDw9IHRNYXgpIGFkZCh1ICogdSAqIHUgKiB2MCArIDMgKiB1ICogdSAqIHQgKiB2MSArIDMgKiB1ICogdCAqIHQgKiB2MiArIHQgKiB0ICogdCAqIHYzLCBwYWRkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIEJhc2UuZWFjaChbJ2dldEJvdW5kcycsICdnZXRTdHJva2VCb3VuZHMnLCAnZ2V0SGFuZGxlQm91bmRzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fYm91bmRzKSB0aGlzLl9ib3VuZHMgPSB7fTtcbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV07XG5cbiAgICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgIGJvdW5kcyA9IHRoaXMuX2JvdW5kc1tuYW1lXSA9IFBhdGhbbmFtZV0oW3RoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Ml0sIGZhbHNlLCB0aGlzLl9wYXRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJvdW5kcy5jbG9uZSgpO1xuICAgIH07XG4gIH0sIHt9KSwgQmFzZS5lYWNoKHtcbiAgICBpc1N0cmFpZ2h0OiBmdW5jdGlvbiAocDEsIGgxLCBoMiwgcDIpIHtcbiAgICAgIGlmIChoMS5pc1plcm8oKSAmJiBoMi5pc1plcm8oKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2ID0gcDIuc3VidHJhY3QocDEpO1xuXG4gICAgICAgIGlmICh2LmlzWmVybygpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHYuaXNDb2xsaW5lYXIoaDEpICYmIHYuaXNDb2xsaW5lYXIoaDIpKSB7XG4gICAgICAgICAgdmFyIGwgPSBuZXcgTGluZShwMSwgcDIpLFxuICAgICAgICAgICAgICBlcHNpbG9uID0gMWUtNztcblxuICAgICAgICAgIGlmIChsLmdldERpc3RhbmNlKHAxLmFkZChoMSkpIDwgZXBzaWxvbiAmJiBsLmdldERpc3RhbmNlKHAyLmFkZChoMikpIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgdmFyIGRpdiA9IHYuZG90KHYpLFxuICAgICAgICAgICAgICAgIHMxID0gdi5kb3QoaDEpIC8gZGl2LFxuICAgICAgICAgICAgICAgIHMyID0gdi5kb3QoaDIpIC8gZGl2O1xuICAgICAgICAgICAgcmV0dXJuIHMxID49IDAgJiYgczEgPD0gMSAmJiBzMiA8PSAwICYmIHMyID49IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBpc0xpbmVhcjogZnVuY3Rpb24gKHAxLCBoMSwgaDIsIHAyKSB7XG4gICAgICB2YXIgdGhpcmQgPSBwMi5zdWJ0cmFjdChwMSkuZGl2aWRlKDMpO1xuICAgICAgcmV0dXJuIGgxLmVxdWFscyh0aGlyZCkgJiYgaDIubmVnYXRlKCkuZXF1YWxzKHRoaXJkKTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uICh0ZXN0LCBuYW1lKSB7XG4gICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uIChlcHNpbG9uKSB7XG4gICAgICB2YXIgc2VnMSA9IHRoaXMuX3NlZ21lbnQxLFxuICAgICAgICAgIHNlZzIgPSB0aGlzLl9zZWdtZW50MjtcbiAgICAgIHJldHVybiB0ZXN0KHNlZzEuX3BvaW50LCBzZWcxLl9oYW5kbGVPdXQsIHNlZzIuX2hhbmRsZUluLCBzZWcyLl9wb2ludCwgZXBzaWxvbik7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhdGljc1tuYW1lXSA9IGZ1bmN0aW9uICh2LCBlcHNpbG9uKSB7XG4gICAgICB2YXIgeDAgPSB2WzBdLFxuICAgICAgICAgIHkwID0gdlsxXSxcbiAgICAgICAgICB4MyA9IHZbNl0sXG4gICAgICAgICAgeTMgPSB2WzddO1xuICAgICAgcmV0dXJuIHRlc3QobmV3IFBvaW50KHgwLCB5MCksIG5ldyBQb2ludCh2WzJdIC0geDAsIHZbM10gLSB5MCksIG5ldyBQb2ludCh2WzRdIC0geDMsIHZbNV0gLSB5MyksIG5ldyBQb2ludCh4MywgeTMpLCBlcHNpbG9uKTtcbiAgICB9O1xuICB9LCB7XG4gICAgc3RhdGljczoge30sXG4gICAgaGFzSGFuZGxlczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LmlzWmVybygpIHx8ICF0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCk7XG4gICAgfSxcbiAgICBoYXNMZW5ndGg6IGZ1bmN0aW9uIChlcHNpbG9uKSB7XG4gICAgICByZXR1cm4gKCF0aGlzLmdldFBvaW50MSgpLmVxdWFscyh0aGlzLmdldFBvaW50MigpKSB8fCB0aGlzLmhhc0hhbmRsZXMoKSkgJiYgdGhpcy5nZXRMZW5ndGgoKSA+IChlcHNpbG9uIHx8IDApO1xuICAgIH0sXG4gICAgaXNDb2xsaW5lYXI6IGZ1bmN0aW9uIChjdXJ2ZSkge1xuICAgICAgcmV0dXJuIGN1cnZlICYmIHRoaXMuaXNTdHJhaWdodCgpICYmIGN1cnZlLmlzU3RyYWlnaHQoKSAmJiB0aGlzLmdldExpbmUoKS5pc0NvbGxpbmVhcihjdXJ2ZS5nZXRMaW5lKCkpO1xuICAgIH0sXG4gICAgaXNIb3Jpem9udGFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1N0cmFpZ2h0KCkgJiYgTWF0aC5hYnModGhpcy5nZXRUYW5nZW50QXRUaW1lKDAuNSkueSkgPCAxZS04O1xuICAgIH0sXG4gICAgaXNWZXJ0aWNhbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTdHJhaWdodCgpICYmIE1hdGguYWJzKHRoaXMuZ2V0VGFuZ2VudEF0VGltZSgwLjUpLngpIDwgMWUtODtcbiAgICB9XG4gIH0pLCB7XG4gICAgYmVhbnM6IGZhbHNlLFxuICAgIGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uIChvZmZzZXQsIF9pc1RpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExvY2F0aW9uQXRUaW1lKF9pc1RpbWUgPyBvZmZzZXQgOiB0aGlzLmdldFRpbWVBdChvZmZzZXQpKTtcbiAgICB9LFxuICAgIGdldExvY2F0aW9uQXRUaW1lOiBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQgIT0gbnVsbCAmJiB0ID49IDAgJiYgdCA8PSAxID8gbmV3IEN1cnZlTG9jYXRpb24odGhpcywgdCkgOiBudWxsO1xuICAgIH0sXG4gICAgZ2V0VGltZUF0OiBmdW5jdGlvbiAob2Zmc2V0LCBzdGFydCkge1xuICAgICAgcmV0dXJuIEN1cnZlLmdldFRpbWVBdCh0aGlzLmdldFZhbHVlcygpLCBvZmZzZXQsIHN0YXJ0KTtcbiAgICB9LFxuICAgIGdldFBhcmFtZXRlckF0OiAnI2dldFRpbWVBdCcsXG4gICAgZ2V0VGltZXNXaXRoVGFuZ2VudDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRhbmdlbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGFuZ2VudC5pc1plcm8oKSA/IFtdIDogQ3VydmUuZ2V0VGltZXNXaXRoVGFuZ2VudCh0aGlzLmdldFZhbHVlcygpLCB0YW5nZW50KTtcbiAgICB9LFxuICAgIGdldE9mZnNldEF0VGltZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBhcnRMZW5ndGgoMCwgdCk7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbk9mOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMb2NhdGlvbkF0VGltZSh0aGlzLmdldFRpbWVPZihQb2ludC5yZWFkKGFyZ3VtZW50cykpKTtcbiAgICB9LFxuICAgIGdldE9mZnNldE9mOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbG9jID8gbG9jLmdldE9mZnNldCgpIDogbnVsbDtcbiAgICB9LFxuICAgIGdldFRpbWVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEN1cnZlLmdldFRpbWVPZih0aGlzLmdldFZhbHVlcygpLCBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZ2V0UGFyYW1ldGVyT2Y6ICcjZ2V0VGltZU9mJyxcbiAgICBnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpLFxuICAgICAgICAgIHQgPSBDdXJ2ZS5nZXROZWFyZXN0VGltZSh2YWx1ZXMsIHBvaW50KSxcbiAgICAgICAgICBwdCA9IEN1cnZlLmdldFBvaW50KHZhbHVlcywgdCk7XG4gICAgICByZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24odGhpcywgdCwgcHQsIG51bGwsIHBvaW50LmdldERpc3RhbmNlKHB0KSk7XG4gICAgfSxcbiAgICBnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGxvYyA/IGxvYy5nZXRQb2ludCgpIDogbG9jO1xuICAgIH1cbiAgfSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0aG9kcyA9IFsnZ2V0UG9pbnQnLCAnZ2V0VGFuZ2VudCcsICdnZXROb3JtYWwnLCAnZ2V0V2VpZ2h0ZWRUYW5nZW50JywgJ2dldFdlaWdodGVkTm9ybWFsJywgJ2dldEN1cnZhdHVyZSddO1xuICAgIHJldHVybiBCYXNlLmVhY2gobWV0aG9kcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBfaXNUaW1lKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuICAgICAgICByZXR1cm4gQ3VydmVbbmFtZV0odmFsdWVzLCBfaXNUaW1lID8gbG9jYXRpb24gOiBDdXJ2ZS5nZXRUaW1lQXQodmFsdWVzLCBsb2NhdGlvbikpO1xuICAgICAgfTtcblxuICAgICAgdGhpc1tuYW1lICsgJ0F0VGltZSddID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIEN1cnZlW25hbWVdKHRoaXMuZ2V0VmFsdWVzKCksIHRpbWUpO1xuICAgICAgfTtcbiAgICB9LCB7XG4gICAgICBzdGF0aWNzOiB7XG4gICAgICAgIF9ldmFsdWF0ZU1ldGhvZHM6IG1ldGhvZHNcbiAgICAgIH1cbiAgICB9KTtcbiAgfSgpLCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldExlbmd0aEludGVncmFuZCh2KSB7XG4gICAgICB2YXIgeDAgPSB2WzBdLFxuICAgICAgICAgIHkwID0gdlsxXSxcbiAgICAgICAgICB4MSA9IHZbMl0sXG4gICAgICAgICAgeTEgPSB2WzNdLFxuICAgICAgICAgIHgyID0gdls0XSxcbiAgICAgICAgICB5MiA9IHZbNV0sXG4gICAgICAgICAgeDMgPSB2WzZdLFxuICAgICAgICAgIHkzID0gdls3XSxcbiAgICAgICAgICBheCA9IDkgKiAoeDEgLSB4MikgKyAzICogKHgzIC0geDApLFxuICAgICAgICAgIGJ4ID0gNiAqICh4MCArIHgyKSAtIDEyICogeDEsXG4gICAgICAgICAgY3ggPSAzICogKHgxIC0geDApLFxuICAgICAgICAgIGF5ID0gOSAqICh5MSAtIHkyKSArIDMgKiAoeTMgLSB5MCksXG4gICAgICAgICAgYnkgPSA2ICogKHkwICsgeTIpIC0gMTIgKiB5MSxcbiAgICAgICAgICBjeSA9IDMgKiAoeTEgLSB5MCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGR4ID0gKGF4ICogdCArIGJ4KSAqIHQgKyBjeCxcbiAgICAgICAgICAgIGR5ID0gKGF5ICogdCArIGJ5KSAqIHQgKyBjeTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGlvbnMoYSwgYikge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDIsIE1hdGgubWluKDE2LCBNYXRoLmNlaWwoTWF0aC5hYnMoYiAtIGEpICogMzIpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXZhbHVhdGUodiwgdCwgdHlwZSwgbm9ybWFsaXplZCkge1xuICAgICAgaWYgKHQgPT0gbnVsbCB8fCB0IDwgMCB8fCB0ID4gMSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgeDAgPSB2WzBdLFxuICAgICAgICAgIHkwID0gdlsxXSxcbiAgICAgICAgICB4MSA9IHZbMl0sXG4gICAgICAgICAgeTEgPSB2WzNdLFxuICAgICAgICAgIHgyID0gdls0XSxcbiAgICAgICAgICB5MiA9IHZbNV0sXG4gICAgICAgICAgeDMgPSB2WzZdLFxuICAgICAgICAgIHkzID0gdls3XSxcbiAgICAgICAgICBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXG4gICAgICBpZiAoaXNaZXJvKHgxIC0geDApICYmIGlzWmVybyh5MSAtIHkwKSkge1xuICAgICAgICB4MSA9IHgwO1xuICAgICAgICB5MSA9IHkwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNaZXJvKHgyIC0geDMpICYmIGlzWmVybyh5MiAtIHkzKSkge1xuICAgICAgICB4MiA9IHgzO1xuICAgICAgICB5MiA9IHkzO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3ggPSAzICogKHgxIC0geDApLFxuICAgICAgICAgIGJ4ID0gMyAqICh4MiAtIHgxKSAtIGN4LFxuICAgICAgICAgIGF4ID0geDMgLSB4MCAtIGN4IC0gYngsXG4gICAgICAgICAgY3kgPSAzICogKHkxIC0geTApLFxuICAgICAgICAgIGJ5ID0gMyAqICh5MiAtIHkxKSAtIGN5LFxuICAgICAgICAgIGF5ID0geTMgLSB5MCAtIGN5IC0gYnksXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5O1xuXG4gICAgICBpZiAodHlwZSA9PT0gMCkge1xuICAgICAgICB4ID0gdCA9PT0gMCA/IHgwIDogdCA9PT0gMSA/IHgzIDogKChheCAqIHQgKyBieCkgKiB0ICsgY3gpICogdCArIHgwO1xuICAgICAgICB5ID0gdCA9PT0gMCA/IHkwIDogdCA9PT0gMSA/IHkzIDogKChheSAqIHQgKyBieSkgKiB0ICsgY3kpICogdCArIHkwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRNaW4gPSAxZS04LFxuICAgICAgICAgICAgdE1heCA9IDEgLSB0TWluO1xuXG4gICAgICAgIGlmICh0IDwgdE1pbikge1xuICAgICAgICAgIHggPSBjeDtcbiAgICAgICAgICB5ID0gY3k7XG4gICAgICAgIH0gZWxzZSBpZiAodCA+IHRNYXgpIHtcbiAgICAgICAgICB4ID0gMyAqICh4MyAtIHgyKTtcbiAgICAgICAgICB5ID0gMyAqICh5MyAtIHkyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0gKDMgKiBheCAqIHQgKyAyICogYngpICogdCArIGN4O1xuICAgICAgICAgIHkgPSAoMyAqIGF5ICogdCArIDIgKiBieSkgKiB0ICsgY3k7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICAgIGlmICh4ID09PSAwICYmIHkgPT09IDAgJiYgKHQgPCB0TWluIHx8IHQgPiB0TWF4KSkge1xuICAgICAgICAgICAgeCA9IHgyIC0geDE7XG4gICAgICAgICAgICB5ID0geTIgLSB5MTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgeCAvPSBsZW47XG4gICAgICAgICAgICB5IC89IGxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gMykge1xuICAgICAgICAgIHZhciB4MiA9IDYgKiBheCAqIHQgKyAyICogYngsXG4gICAgICAgICAgICAgIHkyID0gNiAqIGF5ICogdCArIDIgKiBieSxcbiAgICAgICAgICAgICAgZCA9IE1hdGgucG93KHggKiB4ICsgeSAqIHksIDMgLyAyKTtcbiAgICAgICAgICB4ID0gZCAhPT0gMCA/ICh4ICogeTIgLSB5ICogeDIpIC8gZCA6IDA7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUgPT09IDIgPyBuZXcgUG9pbnQoeSwgLXgpIDogbmV3IFBvaW50KHgsIHkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGF0aWNzOiB7XG4gICAgICAgIGNsYXNzaWZ5OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHZhciB4MCA9IHZbMF0sXG4gICAgICAgICAgICAgIHkwID0gdlsxXSxcbiAgICAgICAgICAgICAgeDEgPSB2WzJdLFxuICAgICAgICAgICAgICB5MSA9IHZbM10sXG4gICAgICAgICAgICAgIHgyID0gdls0XSxcbiAgICAgICAgICAgICAgeTIgPSB2WzVdLFxuICAgICAgICAgICAgICB4MyA9IHZbNl0sXG4gICAgICAgICAgICAgIHkzID0gdls3XSxcbiAgICAgICAgICAgICAgYTEgPSB4MCAqICh5MyAtIHkyKSArIHkwICogKHgyIC0geDMpICsgeDMgKiB5MiAtIHkzICogeDIsXG4gICAgICAgICAgICAgIGEyID0geDEgKiAoeTAgLSB5MykgKyB5MSAqICh4MyAtIHgwKSArIHgwICogeTMgLSB5MCAqIHgzLFxuICAgICAgICAgICAgICBhMyA9IHgyICogKHkxIC0geTApICsgeTIgKiAoeDAgLSB4MSkgKyB4MSAqIHkwIC0geTEgKiB4MCxcbiAgICAgICAgICAgICAgZDMgPSAzICogYTMsXG4gICAgICAgICAgICAgIGQyID0gZDMgLSBhMixcbiAgICAgICAgICAgICAgZDEgPSBkMiAtIGEyICsgYTEsXG4gICAgICAgICAgICAgIGwgPSBNYXRoLnNxcnQoZDEgKiBkMSArIGQyICogZDIgKyBkMyAqIGQzKSxcbiAgICAgICAgICAgICAgcyA9IGwgIT09IDAgPyAxIC8gbCA6IDAsXG4gICAgICAgICAgICAgIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm8sXG4gICAgICAgICAgICAgIHNlcnBlbnRpbmUgPSAnc2VycGVudGluZSc7XG4gICAgICAgICAgZDEgKj0gcztcbiAgICAgICAgICBkMiAqPSBzO1xuICAgICAgICAgIGQzICo9IHM7XG5cbiAgICAgICAgICBmdW5jdGlvbiB0eXBlKHR5cGUsIHQxLCB0Mikge1xuICAgICAgICAgICAgdmFyIGhhc1Jvb3RzID0gdDEgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0MU9rID0gaGFzUm9vdHMgJiYgdDEgPiAwICYmIHQxIDwgMSxcbiAgICAgICAgICAgICAgICB0Mk9rID0gaGFzUm9vdHMgJiYgdDIgPiAwICYmIHQyIDwgMTtcblxuICAgICAgICAgICAgaWYgKGhhc1Jvb3RzICYmICghKHQxT2sgfHwgdDJPaykgfHwgdHlwZSA9PT0gJ2xvb3AnICYmICEodDFPayAmJiB0Mk9rKSkpIHtcbiAgICAgICAgICAgICAgdHlwZSA9ICdhcmNoJztcbiAgICAgICAgICAgICAgdDFPayA9IHQyT2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgcm9vdHM6IHQxT2sgfHwgdDJPayA/IHQxT2sgJiYgdDJPayA/IHQxIDwgdDIgPyBbdDEsIHQyXSA6IFt0MiwgdDFdIDogW3QxT2sgPyB0MSA6IHQyXSA6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzWmVybyhkMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1plcm8oZDIpID8gdHlwZShpc1plcm8oZDMpID8gJ2xpbmUnIDogJ3F1YWRyYXRpYycpIDogdHlwZShzZXJwZW50aW5lLCBkMyAvICgzICogZDIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZCA9IDMgKiBkMiAqIGQyIC0gNCAqIGQxICogZDM7XG5cbiAgICAgICAgICBpZiAoaXNaZXJvKGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSgnY3VzcCcsIGQyIC8gKDIgKiBkMSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBmMSA9IGQgPiAwID8gTWF0aC5zcXJ0KGQgLyAzKSA6IE1hdGguc3FydCgtZCksXG4gICAgICAgICAgICAgIGYyID0gMiAqIGQxO1xuICAgICAgICAgIHJldHVybiB0eXBlKGQgPiAwID8gc2VycGVudGluZSA6ICdsb29wJywgKGQyICsgZjEpIC8gZjIsIChkMiAtIGYxKSAvIGYyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiAodiwgYSwgYiwgZHMpIHtcbiAgICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMDtcbiAgICAgICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSBiID0gMTtcblxuICAgICAgICAgIGlmIChDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHY7XG5cbiAgICAgICAgICAgIGlmIChiIDwgMSkge1xuICAgICAgICAgICAgICBjID0gQ3VydmUuc3ViZGl2aWRlKGMsIGIpWzBdO1xuICAgICAgICAgICAgICBhIC89IGI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhID4gMCkge1xuICAgICAgICAgICAgICBjID0gQ3VydmUuc3ViZGl2aWRlKGMsIGEpWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZHggPSBjWzZdIC0gY1swXSxcbiAgICAgICAgICAgICAgICBkeSA9IGNbN10gLSBjWzFdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIE51bWVyaWNhbC5pbnRlZ3JhdGUoZHMgfHwgZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpLCBhLCBiLCBnZXRJdGVyYXRpb25zKGEsIGIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VGltZUF0OiBmdW5jdGlvbiAodiwgb2Zmc2V0LCBzdGFydCkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSBzdGFydCA9IG9mZnNldCA8IDAgPyAxIDogMDtcbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgICBlcHNpbG9uID0gMWUtMTIsXG4gICAgICAgICAgICAgIGZvcndhcmQgPSBvZmZzZXQgPiAwLFxuICAgICAgICAgICAgICBhID0gZm9yd2FyZCA/IHN0YXJ0IDogMCxcbiAgICAgICAgICAgICAgYiA9IGZvcndhcmQgPyAxIDogc3RhcnQsXG4gICAgICAgICAgICAgIGRzID0gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpLFxuICAgICAgICAgICAgICByYW5nZUxlbmd0aCA9IEN1cnZlLmdldExlbmd0aCh2LCBhLCBiLCBkcyksXG4gICAgICAgICAgICAgIGRpZmYgPSBhYnMob2Zmc2V0KSAtIHJhbmdlTGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGFicyhkaWZmKSA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmb3J3YXJkID8gYiA6IGE7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmID4gZXBzaWxvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGd1ZXNzID0gb2Zmc2V0IC8gcmFuZ2VMZW5ndGgsXG4gICAgICAgICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgICBmdW5jdGlvbiBmKHQpIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBzdGFydCwgdCwgZ2V0SXRlcmF0aW9ucyhzdGFydCwgdCkpO1xuICAgICAgICAgICAgc3RhcnQgPSB0O1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gTnVtZXJpY2FsLmZpbmRSb290KGYsIGRzLCBzdGFydCArIGd1ZXNzLCBhLCBiLCAzMiwgMWUtMTIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRQb2ludDogZnVuY3Rpb24gKHYsIHQpIHtcbiAgICAgICAgICByZXR1cm4gZXZhbHVhdGUodiwgdCwgMCwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRUYW5nZW50OiBmdW5jdGlvbiAodiwgdCkge1xuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSh2LCB0LCAxLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2VpZ2h0ZWRUYW5nZW50OiBmdW5jdGlvbiAodiwgdCkge1xuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSh2LCB0LCAxLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE5vcm1hbDogZnVuY3Rpb24gKHYsIHQpIHtcbiAgICAgICAgICByZXR1cm4gZXZhbHVhdGUodiwgdCwgMiwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFdlaWdodGVkTm9ybWFsOiBmdW5jdGlvbiAodiwgdCkge1xuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSh2LCB0LCAyLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEN1cnZhdHVyZTogZnVuY3Rpb24gKHYsIHQpIHtcbiAgICAgICAgICByZXR1cm4gZXZhbHVhdGUodiwgdCwgMywgZmFsc2UpLng7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBlYWtzOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHZhciB4MCA9IHZbMF0sXG4gICAgICAgICAgICAgIHkwID0gdlsxXSxcbiAgICAgICAgICAgICAgeDEgPSB2WzJdLFxuICAgICAgICAgICAgICB5MSA9IHZbM10sXG4gICAgICAgICAgICAgIHgyID0gdls0XSxcbiAgICAgICAgICAgICAgeTIgPSB2WzVdLFxuICAgICAgICAgICAgICB4MyA9IHZbNl0sXG4gICAgICAgICAgICAgIHkzID0gdls3XSxcbiAgICAgICAgICAgICAgYXggPSAteDAgKyAzICogeDEgLSAzICogeDIgKyB4MyxcbiAgICAgICAgICAgICAgYnggPSAzICogeDAgLSA2ICogeDEgKyAzICogeDIsXG4gICAgICAgICAgICAgIGN4ID0gLTMgKiB4MCArIDMgKiB4MSxcbiAgICAgICAgICAgICAgYXkgPSAteTAgKyAzICogeTEgLSAzICogeTIgKyB5MyxcbiAgICAgICAgICAgICAgYnkgPSAzICogeTAgLSA2ICogeTEgKyAzICogeTIsXG4gICAgICAgICAgICAgIGN5ID0gLTMgKiB5MCArIDMgKiB5MSxcbiAgICAgICAgICAgICAgdE1pbiA9IDFlLTgsXG4gICAgICAgICAgICAgIHRNYXggPSAxIC0gdE1pbixcbiAgICAgICAgICAgICAgcm9vdHMgPSBbXTtcbiAgICAgICAgICBOdW1lcmljYWwuc29sdmVDdWJpYyg5ICogKGF4ICogYXggKyBheSAqIGF5KSwgOSAqIChheCAqIGJ4ICsgYnkgKiBheSksIDIgKiAoYnggKiBieCArIGJ5ICogYnkpICsgMyAqIChjeCAqIGF4ICsgY3kgKiBheSksIGN4ICogYnggKyBieSAqIGN5LCByb290cywgdE1pbiwgdE1heCk7XG4gICAgICAgICAgcmV0dXJuIHJvb3RzLnNvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0oKSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGMxLCB0MSwgYzIsIHQyLCBvdmVybGFwKSB7XG4gICAgICB2YXIgZXhjbHVkZVN0YXJ0ID0gIW92ZXJsYXAgJiYgYzEuZ2V0UHJldmlvdXMoKSA9PT0gYzIsXG4gICAgICAgICAgZXhjbHVkZUVuZCA9ICFvdmVybGFwICYmIGMxICE9PSBjMiAmJiBjMS5nZXROZXh0KCkgPT09IGMyLFxuICAgICAgICAgIHRNaW4gPSAxZS04LFxuICAgICAgICAgIHRNYXggPSAxIC0gdE1pbjtcblxuICAgICAgaWYgKHQxICE9PSBudWxsICYmIHQxID49IChleGNsdWRlU3RhcnQgPyB0TWluIDogMCkgJiYgdDEgPD0gKGV4Y2x1ZGVFbmQgPyB0TWF4IDogMSkpIHtcbiAgICAgICAgaWYgKHQyICE9PSBudWxsICYmIHQyID49IChleGNsdWRlRW5kID8gdE1pbiA6IDApICYmIHQyIDw9IChleGNsdWRlU3RhcnQgPyB0TWF4IDogMSkpIHtcbiAgICAgICAgICB2YXIgbG9jMSA9IG5ldyBDdXJ2ZUxvY2F0aW9uKGMxLCB0MSwgbnVsbCwgb3ZlcmxhcCksXG4gICAgICAgICAgICAgIGxvYzIgPSBuZXcgQ3VydmVMb2NhdGlvbihjMiwgdDIsIG51bGwsIG92ZXJsYXApO1xuICAgICAgICAgIGxvYzEuX2ludGVyc2VjdGlvbiA9IGxvYzI7XG4gICAgICAgICAgbG9jMi5faW50ZXJzZWN0aW9uID0gbG9jMTtcblxuICAgICAgICAgIGlmICghaW5jbHVkZSB8fCBpbmNsdWRlKGxvYzEpKSB7XG4gICAgICAgICAgICBDdXJ2ZUxvY2F0aW9uLmluc2VydChsb2NhdGlvbnMsIGxvYzEsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlLCBmbGlwLCByZWN1cnNpb24sIGNhbGxzLCB0TWluLCB0TWF4LCB1TWluLCB1TWF4KSB7XG4gICAgICBpZiAoKytjYWxscyA+PSA0MDk2IHx8ICsrcmVjdXJzaW9uID49IDQwKSByZXR1cm4gY2FsbHM7XG4gICAgICB2YXIgZmF0TGluZUVwc2lsb24gPSAxZS05LFxuICAgICAgICAgIHEweCA9IHYyWzBdLFxuICAgICAgICAgIHEweSA9IHYyWzFdLFxuICAgICAgICAgIHEzeCA9IHYyWzZdLFxuICAgICAgICAgIHEzeSA9IHYyWzddLFxuICAgICAgICAgIGdldFNpZ25lZERpc3RhbmNlID0gTGluZS5nZXRTaWduZWREaXN0YW5jZSxcbiAgICAgICAgICBkMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjJbMl0sIHYyWzNdKSxcbiAgICAgICAgICBkMiA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjJbNF0sIHYyWzVdKSxcbiAgICAgICAgICBmYWN0b3IgPSBkMSAqIGQyID4gMCA/IDMgLyA0IDogNCAvIDksXG4gICAgICAgICAgZE1pbiA9IGZhY3RvciAqIE1hdGgubWluKDAsIGQxLCBkMiksXG4gICAgICAgICAgZE1heCA9IGZhY3RvciAqIE1hdGgubWF4KDAsIGQxLCBkMiksXG4gICAgICAgICAgZHAwID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVswXSwgdjFbMV0pLFxuICAgICAgICAgIGRwMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbMl0sIHYxWzNdKSxcbiAgICAgICAgICBkcDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzRdLCB2MVs1XSksXG4gICAgICAgICAgZHAzID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs2XSwgdjFbN10pLFxuICAgICAgICAgIGh1bGwgPSBnZXRDb252ZXhIdWxsKGRwMCwgZHAxLCBkcDIsIGRwMyksXG4gICAgICAgICAgdG9wID0gaHVsbFswXSxcbiAgICAgICAgICBib3R0b20gPSBodWxsWzFdLFxuICAgICAgICAgIHRNaW5DbGlwLFxuICAgICAgICAgIHRNYXhDbGlwO1xuICAgICAgaWYgKGQxID09PSAwICYmIGQyID09PSAwICYmIGRwMCA9PT0gMCAmJiBkcDEgPT09IDAgJiYgZHAyID09PSAwICYmIGRwMyA9PT0gMCB8fCAodE1pbkNsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AsIGJvdHRvbSwgZE1pbiwgZE1heCkpID09IG51bGwgfHwgKHRNYXhDbGlwID0gY2xpcENvbnZleEh1bGwodG9wLnJldmVyc2UoKSwgYm90dG9tLnJldmVyc2UoKSwgZE1pbiwgZE1heCkpID09IG51bGwpIHJldHVybiBjYWxscztcbiAgICAgIHZhciB0TWluTmV3ID0gdE1pbiArICh0TWF4IC0gdE1pbikgKiB0TWluQ2xpcCxcbiAgICAgICAgICB0TWF4TmV3ID0gdE1pbiArICh0TWF4IC0gdE1pbikgKiB0TWF4Q2xpcDtcblxuICAgICAgaWYgKE1hdGgubWF4KHVNYXggLSB1TWluLCB0TWF4TmV3IC0gdE1pbk5ldykgPCBmYXRMaW5lRXBzaWxvbikge1xuICAgICAgICB2YXIgdCA9ICh0TWluTmV3ICsgdE1heE5ldykgLyAyLFxuICAgICAgICAgICAgdSA9ICh1TWluICsgdU1heCkgLyAyO1xuICAgICAgICBhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGZsaXAgPyBjMiA6IGMxLCBmbGlwID8gdSA6IHQsIGZsaXAgPyBjMSA6IGMyLCBmbGlwID8gdCA6IHUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdjEgPSBDdXJ2ZS5nZXRQYXJ0KHYxLCB0TWluQ2xpcCwgdE1heENsaXApO1xuICAgICAgICB2YXIgdURpZmYgPSB1TWF4IC0gdU1pbjtcblxuICAgICAgICBpZiAodE1heENsaXAgLSB0TWluQ2xpcCA+IDAuOCkge1xuICAgICAgICAgIGlmICh0TWF4TmV3IC0gdE1pbk5ldyA+IHVEaWZmKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodjEsIDAuNSksXG4gICAgICAgICAgICAgICAgdCA9ICh0TWluTmV3ICsgdE1heE5ldykgLyAyO1xuICAgICAgICAgICAgY2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjIsIHBhcnRzWzBdLCBjMiwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSwgIWZsaXAsIHJlY3Vyc2lvbiwgY2FsbHMsIHVNaW4sIHVNYXgsIHRNaW5OZXcsIHQpO1xuICAgICAgICAgICAgY2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjIsIHBhcnRzWzFdLCBjMiwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSwgIWZsaXAsIHJlY3Vyc2lvbiwgY2FsbHMsIHVNaW4sIHVNYXgsIHQsIHRNYXhOZXcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodjIsIDAuNSksXG4gICAgICAgICAgICAgICAgdSA9ICh1TWluICsgdU1heCkgLyAyO1xuICAgICAgICAgICAgY2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnMocGFydHNbMF0sIHYxLCBjMiwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSwgIWZsaXAsIHJlY3Vyc2lvbiwgY2FsbHMsIHVNaW4sIHUsIHRNaW5OZXcsIHRNYXhOZXcpO1xuICAgICAgICAgICAgY2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnMocGFydHNbMV0sIHYxLCBjMiwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSwgIWZsaXAsIHJlY3Vyc2lvbiwgY2FsbHMsIHUsIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodURpZmYgPT09IDAgfHwgdURpZmYgPj0gZmF0TGluZUVwc2lsb24pIHtcbiAgICAgICAgICAgIGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYyLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLCByZWN1cnNpb24sIGNhbGxzLCB1TWluLCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCwgcmVjdXJzaW9uLCBjYWxscywgdE1pbk5ldywgdE1heE5ldywgdU1pbiwgdU1heCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxscztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb252ZXhIdWxsKGRxMCwgZHExLCBkcTIsIGRxMykge1xuICAgICAgdmFyIHAwID0gWzAsIGRxMF0sXG4gICAgICAgICAgcDEgPSBbMSAvIDMsIGRxMV0sXG4gICAgICAgICAgcDIgPSBbMiAvIDMsIGRxMl0sXG4gICAgICAgICAgcDMgPSBbMSwgZHEzXSxcbiAgICAgICAgICBkaXN0MSA9IGRxMSAtICgyICogZHEwICsgZHEzKSAvIDMsXG4gICAgICAgICAgZGlzdDIgPSBkcTIgLSAoZHEwICsgMiAqIGRxMykgLyAzLFxuICAgICAgICAgIGh1bGw7XG5cbiAgICAgIGlmIChkaXN0MSAqIGRpc3QyIDwgMCkge1xuICAgICAgICBodWxsID0gW1twMCwgcDEsIHAzXSwgW3AwLCBwMiwgcDNdXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXN0UmF0aW8gPSBkaXN0MSAvIGRpc3QyO1xuICAgICAgICBodWxsID0gW2Rpc3RSYXRpbyA+PSAyID8gW3AwLCBwMSwgcDNdIDogZGlzdFJhdGlvIDw9IDAuNSA/IFtwMCwgcDIsIHAzXSA6IFtwMCwgcDEsIHAyLCBwM10sIFtwMCwgcDNdXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChkaXN0MSB8fCBkaXN0MikgPCAwID8gaHVsbC5yZXZlcnNlKCkgOiBodWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsKGh1bGxUb3AsIGh1bGxCb3R0b20sIGRNaW4sIGRNYXgpIHtcbiAgICAgIGlmIChodWxsVG9wWzBdWzFdIDwgZE1pbikge1xuICAgICAgICByZXR1cm4gY2xpcENvbnZleEh1bGxQYXJ0KGh1bGxUb3AsIHRydWUsIGRNaW4pO1xuICAgICAgfSBlbHNlIGlmIChodWxsQm90dG9tWzBdWzFdID4gZE1heCkge1xuICAgICAgICByZXR1cm4gY2xpcENvbnZleEh1bGxQYXJ0KGh1bGxCb3R0b20sIGZhbHNlLCBkTWF4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBodWxsVG9wWzBdWzBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsUGFydChwYXJ0LCB0b3AsIHRocmVzaG9sZCkge1xuICAgICAgdmFyIHB4ID0gcGFydFswXVswXSxcbiAgICAgICAgICBweSA9IHBhcnRbMF1bMV07XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcGFydC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHF4ID0gcGFydFtpXVswXSxcbiAgICAgICAgICAgIHF5ID0gcGFydFtpXVsxXTtcblxuICAgICAgICBpZiAodG9wID8gcXkgPj0gdGhyZXNob2xkIDogcXkgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuIHF5ID09PSB0aHJlc2hvbGQgPyBxeCA6IHB4ICsgKHRocmVzaG9sZCAtIHB5KSAqIChxeCAtIHB4KSAvIChxeSAtIHB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB4ID0gcXg7XG4gICAgICAgIHB5ID0gcXk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEN1cnZlTGluZUludGVyc2VjdGlvbnModiwgcHgsIHB5LCB2eCwgdnkpIHtcbiAgICAgIHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXG4gICAgICBpZiAoaXNaZXJvKHZ4KSAmJiBpc1plcm8odnkpKSB7XG4gICAgICAgIHZhciB0ID0gQ3VydmUuZ2V0VGltZU9mKHYsIG5ldyBQb2ludChweCwgcHkpKTtcbiAgICAgICAgcmV0dXJuIHQgPT09IG51bGwgPyBbXSA6IFt0XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMigtdnksIHZ4KSxcbiAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIHJ2ID0gW10sXG4gICAgICAgICAgcm9vdHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpIHtcbiAgICAgICAgdmFyIHggPSB2W2ldIC0gcHgsXG4gICAgICAgICAgICB5ID0gdltpICsgMV0gLSBweTtcbiAgICAgICAgcnYucHVzaCh4ICogY29zIC0geSAqIHNpbiwgeCAqIHNpbiArIHkgKiBjb3MpO1xuICAgICAgfVxuXG4gICAgICBDdXJ2ZS5zb2x2ZUN1YmljKHJ2LCAxLCAwLCByb290cywgMCwgMSk7XG4gICAgICByZXR1cm4gcm9vdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ3VydmVMaW5lSW50ZXJzZWN0aW9ucyh2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlLCBmbGlwKSB7XG4gICAgICB2YXIgeDEgPSB2MlswXSxcbiAgICAgICAgICB5MSA9IHYyWzFdLFxuICAgICAgICAgIHgyID0gdjJbNl0sXG4gICAgICAgICAgeTIgPSB2Mls3XSxcbiAgICAgICAgICByb290cyA9IGdldEN1cnZlTGluZUludGVyc2VjdGlvbnModjEsIHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciB0MSA9IHJvb3RzW2ldLFxuICAgICAgICAgICAgcDEgPSBDdXJ2ZS5nZXRQb2ludCh2MSwgdDEpLFxuICAgICAgICAgICAgdDIgPSBDdXJ2ZS5nZXRUaW1lT2YodjIsIHAxKTtcblxuICAgICAgICBpZiAodDIgIT09IG51bGwpIHtcbiAgICAgICAgICBhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGZsaXAgPyBjMiA6IGMxLCBmbGlwID8gdDIgOiB0MSwgZmxpcCA/IGMxIDogYzIsIGZsaXAgPyB0MSA6IHQyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpbmVJbnRlcnNlY3Rpb24odjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuICAgICAgdmFyIHB0ID0gTGluZS5pbnRlcnNlY3QodjFbMF0sIHYxWzFdLCB2MVs2XSwgdjFbN10sIHYyWzBdLCB2MlsxXSwgdjJbNl0sIHYyWzddKTtcblxuICAgICAgaWYgKHB0KSB7XG4gICAgICAgIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgYzEsIEN1cnZlLmdldFRpbWVPZih2MSwgcHQpLCBjMiwgQ3VydmUuZ2V0VGltZU9mKHYyLCBwdCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEN1cnZlSW50ZXJzZWN0aW9ucyh2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IDFlLTEyLFxuICAgICAgICAgIG1pbiA9IE1hdGgubWluLFxuICAgICAgICAgIG1heCA9IE1hdGgubWF4O1xuXG4gICAgICBpZiAobWF4KHYxWzBdLCB2MVsyXSwgdjFbNF0sIHYxWzZdKSArIGVwc2lsb24gPiBtaW4odjJbMF0sIHYyWzJdLCB2Mls0XSwgdjJbNl0pICYmIG1pbih2MVswXSwgdjFbMl0sIHYxWzRdLCB2MVs2XSkgLSBlcHNpbG9uIDwgbWF4KHYyWzBdLCB2MlsyXSwgdjJbNF0sIHYyWzZdKSAmJiBtYXgodjFbMV0sIHYxWzNdLCB2MVs1XSwgdjFbN10pICsgZXBzaWxvbiA+IG1pbih2MlsxXSwgdjJbM10sIHYyWzVdLCB2Mls3XSkgJiYgbWluKHYxWzFdLCB2MVszXSwgdjFbNV0sIHYxWzddKSAtIGVwc2lsb24gPCBtYXgodjJbMV0sIHYyWzNdLCB2Mls1XSwgdjJbN10pKSB7XG4gICAgICAgIHZhciBvdmVybGFwcyA9IGdldE92ZXJsYXBzKHYxLCB2Mik7XG5cbiAgICAgICAgaWYgKG92ZXJsYXBzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvdmVybGFwID0gb3ZlcmxhcHNbaV07XG4gICAgICAgICAgICBhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGMxLCBvdmVybGFwWzBdLCBjMiwgb3ZlcmxhcFsxXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdHJhaWdodDEgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYxKSxcbiAgICAgICAgICAgICAgc3RyYWlnaHQyID0gQ3VydmUuaXNTdHJhaWdodCh2MiksXG4gICAgICAgICAgICAgIHN0cmFpZ2h0ID0gc3RyYWlnaHQxICYmIHN0cmFpZ2h0MixcbiAgICAgICAgICAgICAgZmxpcCA9IHN0cmFpZ2h0MSAmJiAhc3RyYWlnaHQyLFxuICAgICAgICAgICAgICBiZWZvcmUgPSBsb2NhdGlvbnMubGVuZ3RoO1xuICAgICAgICAgIChzdHJhaWdodCA/IGFkZExpbmVJbnRlcnNlY3Rpb24gOiBzdHJhaWdodDEgfHwgc3RyYWlnaHQyID8gYWRkQ3VydmVMaW5lSW50ZXJzZWN0aW9ucyA6IGFkZEN1cnZlSW50ZXJzZWN0aW9ucykoZmxpcCA/IHYyIDogdjEsIGZsaXAgPyB2MSA6IHYyLCBmbGlwID8gYzIgOiBjMSwgZmxpcCA/IGMxIDogYzIsIGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCwgMCwgMCwgMCwgMSwgMCwgMSk7XG5cbiAgICAgICAgICBpZiAoIXN0cmFpZ2h0IHx8IGxvY2F0aW9ucy5sZW5ndGggPT09IGJlZm9yZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHQxID0gaSA+PiAxLFxuICAgICAgICAgICAgICAgICAgdDIgPSBpICYgMSxcbiAgICAgICAgICAgICAgICAgIGkxID0gdDEgKiA2LFxuICAgICAgICAgICAgICAgICAgaTIgPSB0MiAqIDYsXG4gICAgICAgICAgICAgICAgICBwMSA9IG5ldyBQb2ludCh2MVtpMV0sIHYxW2kxICsgMV0pLFxuICAgICAgICAgICAgICAgICAgcDIgPSBuZXcgUG9pbnQodjJbaTJdLCB2MltpMiArIDFdKTtcblxuICAgICAgICAgICAgICBpZiAocDEuaXNDbG9zZShwMiwgZXBzaWxvbikpIHtcbiAgICAgICAgICAgICAgICBhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGMxLCB0MSwgYzIsIHQyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9jYXRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlbGZJbnRlcnNlY3Rpb24odjEsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcbiAgICAgIHZhciBpbmZvID0gQ3VydmUuY2xhc3NpZnkodjEpO1xuXG4gICAgICBpZiAoaW5mby50eXBlID09PSAnbG9vcCcpIHtcbiAgICAgICAgdmFyIHJvb3RzID0gaW5mby5yb290cztcbiAgICAgICAgYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgcm9vdHNbMF0sIGMxLCByb290c1sxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhdGlvbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9ucyhjdXJ2ZXMxLCBjdXJ2ZXMyLCBpbmNsdWRlLCBtYXRyaXgxLCBtYXRyaXgyLCBfcmV0dXJuRmlyc3QpIHtcbiAgICAgIHZhciBlcHNpbG9uID0gMWUtNyxcbiAgICAgICAgICBzZWxmID0gIWN1cnZlczI7XG4gICAgICBpZiAoc2VsZikgY3VydmVzMiA9IGN1cnZlczE7XG4gICAgICB2YXIgbGVuZ3RoMSA9IGN1cnZlczEubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aDIgPSBjdXJ2ZXMyLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZXMxID0gbmV3IEFycmF5KGxlbmd0aDEpLFxuICAgICAgICAgIHZhbHVlczIgPSBzZWxmID8gdmFsdWVzMSA6IG5ldyBBcnJheShsZW5ndGgyKSxcbiAgICAgICAgICBsb2NhdGlvbnMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgdmFsdWVzMVtpXSA9IGN1cnZlczFbaV0uZ2V0VmFsdWVzKG1hdHJpeDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZXMyW2ldID0gY3VydmVzMltpXS5nZXRWYWx1ZXMobWF0cml4Mik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJvdW5kc0NvbGxpc2lvbnMgPSBDb2xsaXNpb25EZXRlY3Rpb24uZmluZEN1cnZlQm91bmRzQ29sbGlzaW9ucyh2YWx1ZXMxLCB2YWx1ZXMyLCBlcHNpbG9uKTtcblxuICAgICAgZm9yICh2YXIgaW5kZXgxID0gMDsgaW5kZXgxIDwgbGVuZ3RoMTsgaW5kZXgxKyspIHtcbiAgICAgICAgdmFyIGN1cnZlMSA9IGN1cnZlczFbaW5kZXgxXSxcbiAgICAgICAgICAgIHYxID0gdmFsdWVzMVtpbmRleDFdO1xuXG4gICAgICAgIGlmIChzZWxmKSB7XG4gICAgICAgICAgZ2V0U2VsZkludGVyc2VjdGlvbih2MSwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbGxpc2lvbnMxID0gYm91bmRzQ29sbGlzaW9uc1tpbmRleDFdO1xuXG4gICAgICAgIGlmIChjb2xsaXNpb25zMSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sbGlzaW9uczEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChfcmV0dXJuRmlyc3QgJiYgbG9jYXRpb25zLmxlbmd0aCkgcmV0dXJuIGxvY2F0aW9ucztcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBjb2xsaXNpb25zMVtqXTtcblxuICAgICAgICAgICAgaWYgKCFzZWxmIHx8IGluZGV4MiA+IGluZGV4MSkge1xuICAgICAgICAgICAgICB2YXIgY3VydmUyID0gY3VydmVzMltpbmRleDJdLFxuICAgICAgICAgICAgICAgICAgdjIgPSB2YWx1ZXMyW2luZGV4Ml07XG4gICAgICAgICAgICAgIGdldEN1cnZlSW50ZXJzZWN0aW9ucyh2MSwgdjIsIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsIGluY2x1ZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9jYXRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE92ZXJsYXBzKHYxLCB2Mikge1xuICAgICAgZnVuY3Rpb24gZ2V0U3F1YXJlZExpbmVMZW5ndGgodikge1xuICAgICAgICB2YXIgeCA9IHZbNl0gLSB2WzBdLFxuICAgICAgICAgICAgeSA9IHZbN10gLSB2WzFdO1xuICAgICAgICByZXR1cm4geCAqIHggKyB5ICogeTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgIGdldERpc3RhbmNlID0gTGluZS5nZXREaXN0YW5jZSxcbiAgICAgICAgICB0aW1lRXBzaWxvbiA9IDFlLTgsXG4gICAgICAgICAgZ2VvbUVwc2lsb24gPSAxZS03LFxuICAgICAgICAgIHN0cmFpZ2h0MSA9IEN1cnZlLmlzU3RyYWlnaHQodjEpLFxuICAgICAgICAgIHN0cmFpZ2h0MiA9IEN1cnZlLmlzU3RyYWlnaHQodjIpLFxuICAgICAgICAgIHN0cmFpZ2h0Qm90aCA9IHN0cmFpZ2h0MSAmJiBzdHJhaWdodDIsXG4gICAgICAgICAgZmxpcCA9IGdldFNxdWFyZWRMaW5lTGVuZ3RoKHYxKSA8IGdldFNxdWFyZWRMaW5lTGVuZ3RoKHYyKSxcbiAgICAgICAgICBsMSA9IGZsaXAgPyB2MiA6IHYxLFxuICAgICAgICAgIGwyID0gZmxpcCA/IHYxIDogdjIsXG4gICAgICAgICAgcHggPSBsMVswXSxcbiAgICAgICAgICBweSA9IGwxWzFdLFxuICAgICAgICAgIHZ4ID0gbDFbNl0gLSBweCxcbiAgICAgICAgICB2eSA9IGwxWzddIC0gcHk7XG5cbiAgICAgIGlmIChnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDJbMF0sIGwyWzFdLCB0cnVlKSA8IGdlb21FcHNpbG9uICYmIGdldERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCBsMls2XSwgbDJbN10sIHRydWUpIDwgZ2VvbUVwc2lsb24pIHtcbiAgICAgICAgaWYgKCFzdHJhaWdodEJvdGggJiYgZ2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwxWzJdLCBsMVszXSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbiAmJiBnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDFbNF0sIGwxWzVdLCB0cnVlKSA8IGdlb21FcHNpbG9uICYmIGdldERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCBsMlsyXSwgbDJbM10sIHRydWUpIDwgZ2VvbUVwc2lsb24gJiYgZ2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzRdLCBsMls1XSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbikge1xuICAgICAgICAgIHN0cmFpZ2h0MSA9IHN0cmFpZ2h0MiA9IHN0cmFpZ2h0Qm90aCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyYWlnaHRCb3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyYWlnaHQxIF4gc3RyYWlnaHQyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdiA9IFt2MSwgdjJdLFxuICAgICAgICAgIHBhaXJzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNCAmJiBwYWlycy5sZW5ndGggPCAyOyBpKyspIHtcbiAgICAgICAgdmFyIGkxID0gaSAmIDEsXG4gICAgICAgICAgICBpMiA9IGkxIF4gMSxcbiAgICAgICAgICAgIHQxID0gaSA+PiAxLFxuICAgICAgICAgICAgdDIgPSBDdXJ2ZS5nZXRUaW1lT2YodltpMV0sIG5ldyBQb2ludCh2W2kyXVt0MSA/IDYgOiAwXSwgdltpMl1bdDEgPyA3IDogMV0pKTtcblxuICAgICAgICBpZiAodDIgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBwYWlyID0gaTEgPyBbdDEsIHQyXSA6IFt0MiwgdDFdO1xuXG4gICAgICAgICAgaWYgKCFwYWlycy5sZW5ndGggfHwgYWJzKHBhaXJbMF0gLSBwYWlyc1swXVswXSkgPiB0aW1lRXBzaWxvbiAmJiBhYnMocGFpclsxXSAtIHBhaXJzWzBdWzFdKSA+IHRpbWVFcHNpbG9uKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID4gMiAmJiAhcGFpcnMubGVuZ3RoKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHBhaXJzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBwYWlycyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJhaWdodEJvdGgpIHtcbiAgICAgICAgdmFyIG8xID0gQ3VydmUuZ2V0UGFydCh2MSwgcGFpcnNbMF1bMF0sIHBhaXJzWzFdWzBdKSxcbiAgICAgICAgICAgIG8yID0gQ3VydmUuZ2V0UGFydCh2MiwgcGFpcnNbMF1bMV0sIHBhaXJzWzFdWzFdKTtcbiAgICAgICAgaWYgKGFicyhvMlsyXSAtIG8xWzJdKSA+IGdlb21FcHNpbG9uIHx8IGFicyhvMlszXSAtIG8xWzNdKSA+IGdlb21FcHNpbG9uIHx8IGFicyhvMls0XSAtIG8xWzRdKSA+IGdlb21FcHNpbG9uIHx8IGFicyhvMls1XSAtIG8xWzVdKSA+IGdlb21FcHNpbG9uKSBwYWlycyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYWlycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUaW1lc1dpdGhUYW5nZW50KHYsIHRhbmdlbnQpIHtcbiAgICAgIHZhciB4MCA9IHZbMF0sXG4gICAgICAgICAgeTAgPSB2WzFdLFxuICAgICAgICAgIHgxID0gdlsyXSxcbiAgICAgICAgICB5MSA9IHZbM10sXG4gICAgICAgICAgeDIgPSB2WzRdLFxuICAgICAgICAgIHkyID0gdls1XSxcbiAgICAgICAgICB4MyA9IHZbNl0sXG4gICAgICAgICAgeTMgPSB2WzddLFxuICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0YW5nZW50Lm5vcm1hbGl6ZSgpLFxuICAgICAgICAgIHR4ID0gbm9ybWFsaXplZC54LFxuICAgICAgICAgIHR5ID0gbm9ybWFsaXplZC55LFxuICAgICAgICAgIGF4ID0gMyAqIHgzIC0gOSAqIHgyICsgOSAqIHgxIC0gMyAqIHgwLFxuICAgICAgICAgIGF5ID0gMyAqIHkzIC0gOSAqIHkyICsgOSAqIHkxIC0gMyAqIHkwLFxuICAgICAgICAgIGJ4ID0gNiAqIHgyIC0gMTIgKiB4MSArIDYgKiB4MCxcbiAgICAgICAgICBieSA9IDYgKiB5MiAtIDEyICogeTEgKyA2ICogeTAsXG4gICAgICAgICAgY3ggPSAzICogeDEgLSAzICogeDAsXG4gICAgICAgICAgY3kgPSAzICogeTEgLSAzICogeTAsXG4gICAgICAgICAgZGVuID0gMiAqIGF4ICogdHkgLSAyICogYXkgKiB0eCxcbiAgICAgICAgICB0aW1lcyA9IFtdO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoZGVuKSA8IE51bWVyaWNhbC5DVVJWRVRJTUVfRVBTSUxPTikge1xuICAgICAgICB2YXIgbnVtID0gYXggKiBjeSAtIGF5ICogY3gsXG4gICAgICAgICAgICBkZW4gPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuICAgICAgICBpZiAoZGVuICE9IDApIHtcbiAgICAgICAgICB2YXIgdCA9IC1udW0gLyBkZW47XG4gICAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHRpbWVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWx0YSA9IChieCAqIGJ4IC0gNCAqIGF4ICogY3gpICogdHkgKiB0eSArICgtMiAqIGJ4ICogYnkgKyA0ICogYXkgKiBjeCArIDQgKiBheCAqIGN5KSAqIHR4ICogdHkgKyAoYnkgKiBieSAtIDQgKiBheSAqIGN5KSAqIHR4ICogdHgsXG4gICAgICAgICAgICBrID0gYnggKiB0eSAtIGJ5ICogdHg7XG5cbiAgICAgICAgaWYgKGRlbHRhID49IDAgJiYgZGVuICE9IDApIHtcbiAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydChkZWx0YSksXG4gICAgICAgICAgICAgIHQwID0gLShrICsgZCkgLyBkZW4sXG4gICAgICAgICAgICAgIHQxID0gKC1rICsgZCkgLyBkZW47XG4gICAgICAgICAgaWYgKHQwID49IDAgJiYgdDAgPD0gMSkgdGltZXMucHVzaCh0MCk7XG4gICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkgdGltZXMucHVzaCh0MSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRpbWVzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbiAoY3VydmUpIHtcbiAgICAgICAgdmFyIHYxID0gdGhpcy5nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAgIHYyID0gY3VydmUgJiYgY3VydmUgIT09IHRoaXMgJiYgY3VydmUuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHJldHVybiB2MiA/IGdldEN1cnZlSW50ZXJzZWN0aW9ucyh2MSwgdjIsIHRoaXMsIGN1cnZlLCBbXSkgOiBnZXRTZWxmSW50ZXJzZWN0aW9uKHYxLCB0aGlzLCBbXSk7XG4gICAgICB9LFxuICAgICAgc3RhdGljczoge1xuICAgICAgICBnZXRPdmVybGFwczogZ2V0T3ZlcmxhcHMsXG4gICAgICAgIGdldEludGVyc2VjdGlvbnM6IGdldEludGVyc2VjdGlvbnMsXG4gICAgICAgIGdldEN1cnZlTGluZUludGVyc2VjdGlvbnM6IGdldEN1cnZlTGluZUludGVyc2VjdGlvbnMsXG4gICAgICAgIGdldFRpbWVzV2l0aFRhbmdlbnQ6IGdldFRpbWVzV2l0aFRhbmdlbnRcbiAgICAgIH1cbiAgICB9O1xuICB9KCkpO1xuICB2YXIgQ3VydmVMb2NhdGlvbiA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdDdXJ2ZUxvY2F0aW9uJyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aW1lLCBwb2ludCwgX292ZXJsYXAsIF9kaXN0YW5jZSkge1xuICAgICAgaWYgKHRpbWUgPj0gMC45OTk5OTk5OSkge1xuICAgICAgICB2YXIgbmV4dCA9IGN1cnZlLmdldE5leHQoKTtcblxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIHRpbWUgPSAwO1xuICAgICAgICAgIGN1cnZlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRDdXJ2ZShjdXJ2ZSk7XG5cbiAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgICAgdGhpcy5fcG9pbnQgPSBwb2ludCB8fCBjdXJ2ZS5nZXRQb2ludEF0VGltZSh0aW1lKTtcbiAgICAgIHRoaXMuX292ZXJsYXAgPSBfb3ZlcmxhcDtcbiAgICAgIHRoaXMuX2Rpc3RhbmNlID0gX2Rpc3RhbmNlO1xuICAgICAgdGhpcy5faW50ZXJzZWN0aW9uID0gdGhpcy5fbmV4dCA9IHRoaXMuX3ByZXZpb3VzID0gbnVsbDtcbiAgICB9LFxuICAgIF9zZXRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgICB0aGlzLl92ZXJzaW9uID0gcGF0aCA/IHBhdGguX3ZlcnNpb24gOiAwO1xuICAgIH0sXG4gICAgX3NldEN1cnZlOiBmdW5jdGlvbiAoY3VydmUpIHtcbiAgICAgIHRoaXMuX3NldFBhdGgoY3VydmUuX3BhdGgpO1xuXG4gICAgICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xuICAgICAgdGhpcy5fc2VnbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9zZWdtZW50MSA9IGN1cnZlLl9zZWdtZW50MTtcbiAgICAgIHRoaXMuX3NlZ21lbnQyID0gY3VydmUuX3NlZ21lbnQyO1xuICAgIH0sXG4gICAgX3NldFNlZ21lbnQ6IGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICB2YXIgY3VydmUgPSBzZWdtZW50LmdldEN1cnZlKCk7XG5cbiAgICAgIGlmIChjdXJ2ZSkge1xuICAgICAgICB0aGlzLl9zZXRDdXJ2ZShjdXJ2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRQYXRoKHNlZ21lbnQuX3BhdGgpO1xuXG4gICAgICAgIHRoaXMuX3NlZ21lbnQxID0gc2VnbWVudDtcbiAgICAgICAgdGhpcy5fc2VnbWVudDIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZWdtZW50ID0gc2VnbWVudDtcbiAgICAgIHRoaXMuX3RpbWUgPSBzZWdtZW50ID09PSB0aGlzLl9zZWdtZW50MSA/IDAgOiAxO1xuICAgICAgdGhpcy5fcG9pbnQgPSBzZWdtZW50Ll9wb2ludC5jbG9uZSgpO1xuICAgIH0sXG4gICAgZ2V0U2VnbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50O1xuXG4gICAgICBpZiAoIXNlZ21lbnQpIHtcbiAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgICAgdGltZSA9IHRoaXMuZ2V0VGltZSgpO1xuXG4gICAgICAgIGlmICh0aW1lID09PSAwKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGN1cnZlLl9zZWdtZW50MTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lID09PSAxKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGN1cnZlLl9zZWdtZW50MjtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lICE9IG51bGwpIHtcbiAgICAgICAgICBzZWdtZW50ID0gY3VydmUuZ2V0UGFydExlbmd0aCgwLCB0aW1lKSA8IGN1cnZlLmdldFBhcnRMZW5ndGgodGltZSwgMSkgPyBjdXJ2ZS5fc2VnbWVudDEgOiBjdXJ2ZS5fc2VnbWVudDI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZWdtZW50ID0gc2VnbWVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgfSxcbiAgICBnZXRDdXJ2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICBpZiAocGF0aCAmJiBwYXRoLl92ZXJzaW9uICE9PSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMuX3RpbWUgPSB0aGlzLl9vZmZzZXQgPSB0aGlzLl9jdXJ2ZU9mZnNldCA9IHRoaXMuX2N1cnZlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJ5U2VnbWVudChzZWdtZW50KSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IHNlZ21lbnQgJiYgc2VnbWVudC5nZXRDdXJ2ZSgpO1xuXG4gICAgICAgIGlmIChjdXJ2ZSAmJiAodGhhdC5fdGltZSA9IGN1cnZlLmdldFRpbWVPZih0aGF0Ll9wb2ludCkpICE9IG51bGwpIHtcbiAgICAgICAgICB0aGF0Ll9zZXRDdXJ2ZShjdXJ2ZSk7XG5cbiAgICAgICAgICByZXR1cm4gY3VydmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2N1cnZlIHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudCkgfHwgdHJ5U2VnbWVudCh0aGlzLl9zZWdtZW50MSkgfHwgdHJ5U2VnbWVudCh0aGlzLl9zZWdtZW50Mi5nZXRQcmV2aW91cygpKTtcbiAgICB9LFxuICAgIGdldFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcbiAgICAgIHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5fcGF0aDtcbiAgICB9LFxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG4gICAgICByZXR1cm4gY3VydmUgJiYgY3VydmUuZ2V0SW5kZXgoKTtcbiAgICB9LFxuICAgIGdldFRpbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcbiAgICAgICAgICB0aW1lID0gdGhpcy5fdGltZTtcbiAgICAgIHJldHVybiBjdXJ2ZSAmJiB0aW1lID09IG51bGwgPyB0aGlzLl90aW1lID0gY3VydmUuZ2V0VGltZU9mKHRoaXMuX3BvaW50KSA6IHRpbWU7XG4gICAgfSxcbiAgICBnZXRQYXJhbWV0ZXI6ICcjZ2V0VGltZScsXG4gICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb2ludDtcbiAgICB9LFxuICAgIGdldE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldDtcblxuICAgICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCksXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblxuICAgICAgICBpZiAocGF0aCAmJiBpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGN1cnZlcyA9IHBhdGguZ2V0Q3VydmVzKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspIG9mZnNldCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQgKz0gdGhpcy5nZXRDdXJ2ZU9mZnNldCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH0sXG4gICAgZ2V0Q3VydmVPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9jdXJ2ZU9mZnNldDtcblxuICAgICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcbiAgICAgICAgICAgIHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5fY3VydmVPZmZzZXQgPSBvZmZzZXQgPSB0aW1lICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmUuZ2V0UGFydExlbmd0aCgwLCB0aW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9LFxuICAgIGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbjtcbiAgICB9LFxuICAgIGdldERpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2U7XG4gICAgfSxcbiAgICBkaXZpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcbiAgICAgICAgICByZXMgPSBjdXJ2ZSAmJiBjdXJ2ZS5kaXZpZGVBdFRpbWUodGhpcy5nZXRUaW1lKCkpO1xuXG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHRoaXMuX3NldFNlZ21lbnQocmVzLl9zZWdtZW50MSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBzcGxpdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgIHBhdGggPSBjdXJ2ZS5fcGF0aCxcbiAgICAgICAgICByZXMgPSBjdXJ2ZSAmJiBjdXJ2ZS5zcGxpdEF0VGltZSh0aGlzLmdldFRpbWUoKSk7XG5cbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgdGhpcy5fc2V0U2VnbWVudChwYXRoLmdldExhc3RTZWdtZW50KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAobG9jLCBfaWdub3JlT3RoZXIpIHtcbiAgICAgIHZhciByZXMgPSB0aGlzID09PSBsb2M7XG5cbiAgICAgIGlmICghcmVzICYmIGxvYyBpbnN0YW5jZW9mIEN1cnZlTG9jYXRpb24pIHtcbiAgICAgICAgdmFyIGMxID0gdGhpcy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgICAgYzIgPSBsb2MuZ2V0Q3VydmUoKSxcbiAgICAgICAgICAgIHAxID0gYzEuX3BhdGgsXG4gICAgICAgICAgICBwMiA9IGMyLl9wYXRoO1xuXG4gICAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgICAgIGVwc2lsb24gPSAxZS03LFxuICAgICAgICAgICAgICBkaWZmID0gYWJzKHRoaXMuZ2V0T2Zmc2V0KCkgLSBsb2MuZ2V0T2Zmc2V0KCkpLFxuICAgICAgICAgICAgICBpMSA9ICFfaWdub3JlT3RoZXIgJiYgdGhpcy5faW50ZXJzZWN0aW9uLFxuICAgICAgICAgICAgICBpMiA9ICFfaWdub3JlT3RoZXIgJiYgbG9jLl9pbnRlcnNlY3Rpb247XG4gICAgICAgICAgcmVzID0gKGRpZmYgPCBlcHNpbG9uIHx8IHAxICYmIGFicyhwMS5nZXRMZW5ndGgoKSAtIGRpZmYpIDwgZXBzaWxvbikgJiYgKCFpMSAmJiAhaTIgfHwgaTEgJiYgaTIgJiYgaTEuZXF1YWxzKGkyLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFydHMgPSBbXSxcbiAgICAgICAgICBwb2ludCA9IHRoaXMuZ2V0UG9pbnQoKSxcbiAgICAgICAgICBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuICAgICAgaWYgKHBvaW50KSBwYXJ0cy5wdXNoKCdwb2ludDogJyArIHBvaW50KTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcbiAgICAgIGlmIChpbmRleCAhPSBudWxsKSBwYXJ0cy5wdXNoKCdpbmRleDogJyArIGluZGV4KTtcbiAgICAgIHZhciB0aW1lID0gdGhpcy5nZXRUaW1lKCk7XG4gICAgICBpZiAodGltZSAhPSBudWxsKSBwYXJ0cy5wdXNoKCd0aW1lOiAnICsgZi5udW1iZXIodGltZSkpO1xuICAgICAgaWYgKHRoaXMuX2Rpc3RhbmNlICE9IG51bGwpIHBhcnRzLnB1c2goJ2Rpc3RhbmNlOiAnICsgZi5udW1iZXIodGhpcy5fZGlzdGFuY2UpKTtcbiAgICAgIHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG4gICAgfSxcbiAgICBpc1RvdWNoaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW50ZXIgPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cbiAgICAgIGlmIChpbnRlciAmJiB0aGlzLmdldFRhbmdlbnQoKS5pc0NvbGxpbmVhcihpbnRlci5nZXRUYW5nZW50KCkpKSB7XG4gICAgICAgIHZhciBjdXJ2ZTEgPSB0aGlzLmdldEN1cnZlKCksXG4gICAgICAgICAgICBjdXJ2ZTIgPSBpbnRlci5nZXRDdXJ2ZSgpO1xuICAgICAgICByZXR1cm4gIShjdXJ2ZTEuaXNTdHJhaWdodCgpICYmIGN1cnZlMi5pc1N0cmFpZ2h0KCkgJiYgY3VydmUxLmdldExpbmUoKS5pbnRlcnNlY3QoY3VydmUyLmdldExpbmUoKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBpc0Nyb3NzaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW50ZXIgPSB0aGlzLl9pbnRlcnNlY3Rpb247XG4gICAgICBpZiAoIWludGVyKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgdDEgPSB0aGlzLmdldFRpbWUoKSxcbiAgICAgICAgICB0MiA9IGludGVyLmdldFRpbWUoKSxcbiAgICAgICAgICB0TWluID0gMWUtOCxcbiAgICAgICAgICB0TWF4ID0gMSAtIHRNaW4sXG4gICAgICAgICAgdDFJbnNpZGUgPSB0MSA+PSB0TWluICYmIHQxIDw9IHRNYXgsXG4gICAgICAgICAgdDJJbnNpZGUgPSB0MiA+PSB0TWluICYmIHQyIDw9IHRNYXg7XG4gICAgICBpZiAodDFJbnNpZGUgJiYgdDJJbnNpZGUpIHJldHVybiAhdGhpcy5pc1RvdWNoaW5nKCk7XG4gICAgICB2YXIgYzIgPSB0aGlzLmdldEN1cnZlKCksXG4gICAgICAgICAgYzEgPSBjMiAmJiB0MSA8IHRNaW4gPyBjMi5nZXRQcmV2aW91cygpIDogYzIsXG4gICAgICAgICAgYzQgPSBpbnRlci5nZXRDdXJ2ZSgpLFxuICAgICAgICAgIGMzID0gYzQgJiYgdDIgPCB0TWluID8gYzQuZ2V0UHJldmlvdXMoKSA6IGM0O1xuICAgICAgaWYgKHQxID4gdE1heCkgYzIgPSBjMi5nZXROZXh0KCk7XG4gICAgICBpZiAodDIgPiB0TWF4KSBjNCA9IGM0LmdldE5leHQoKTtcbiAgICAgIGlmICghYzEgfHwgIWMyIHx8ICFjMyB8fCAhYzQpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBvZmZzZXRzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE9mZnNldHMoY3VydmUsIGVuZCkge1xuICAgICAgICB2YXIgdiA9IGN1cnZlLmdldFZhbHVlcygpLFxuICAgICAgICAgICAgcm9vdHMgPSBDdXJ2ZS5jbGFzc2lmeSh2KS5yb290cyB8fCBDdXJ2ZS5nZXRQZWFrcyh2KSxcbiAgICAgICAgICAgIGNvdW50ID0gcm9vdHMubGVuZ3RoLFxuICAgICAgICAgICAgb2Zmc2V0ID0gQ3VydmUuZ2V0TGVuZ3RoKHYsIGVuZCAmJiBjb3VudCA/IHJvb3RzW2NvdW50IC0gMV0gOiAwLCAhZW5kICYmIGNvdW50ID8gcm9vdHNbMF0gOiAxKTtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKGNvdW50ID8gb2Zmc2V0IDogb2Zmc2V0IC8gMzIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0luUmFuZ2UoYW5nbGUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBtaW4gPCBtYXggPyBhbmdsZSA+IG1pbiAmJiBhbmdsZSA8IG1heCA6IGFuZ2xlID4gbWluIHx8IGFuZ2xlIDwgbWF4O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXQxSW5zaWRlKSB7XG4gICAgICAgIGFkZE9mZnNldHMoYzEsIHRydWUpO1xuICAgICAgICBhZGRPZmZzZXRzKGMyLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdDJJbnNpZGUpIHtcbiAgICAgICAgYWRkT2Zmc2V0cyhjMywgdHJ1ZSk7XG4gICAgICAgIGFkZE9mZnNldHMoYzQsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHB0ID0gdGhpcy5nZXRQb2ludCgpLFxuICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIG9mZnNldHMpLFxuICAgICAgICAgIHYyID0gdDFJbnNpZGUgPyBjMi5nZXRUYW5nZW50QXRUaW1lKHQxKSA6IGMyLmdldFBvaW50QXQob2Zmc2V0KS5zdWJ0cmFjdChwdCksXG4gICAgICAgICAgdjEgPSB0MUluc2lkZSA/IHYyLm5lZ2F0ZSgpIDogYzEuZ2V0UG9pbnRBdCgtb2Zmc2V0KS5zdWJ0cmFjdChwdCksXG4gICAgICAgICAgdjQgPSB0Mkluc2lkZSA/IGM0LmdldFRhbmdlbnRBdFRpbWUodDIpIDogYzQuZ2V0UG9pbnRBdChvZmZzZXQpLnN1YnRyYWN0KHB0KSxcbiAgICAgICAgICB2MyA9IHQySW5zaWRlID8gdjQubmVnYXRlKCkgOiBjMy5nZXRQb2ludEF0KC1vZmZzZXQpLnN1YnRyYWN0KHB0KSxcbiAgICAgICAgICBhMSA9IHYxLmdldEFuZ2xlKCksXG4gICAgICAgICAgYTIgPSB2Mi5nZXRBbmdsZSgpLFxuICAgICAgICAgIGEzID0gdjMuZ2V0QW5nbGUoKSxcbiAgICAgICAgICBhNCA9IHY0LmdldEFuZ2xlKCk7XG4gICAgICByZXR1cm4gISEodDFJbnNpZGUgPyBpc0luUmFuZ2UoYTEsIGEzLCBhNCkgXiBpc0luUmFuZ2UoYTIsIGEzLCBhNCkgJiYgaXNJblJhbmdlKGExLCBhNCwgYTMpIF4gaXNJblJhbmdlKGEyLCBhNCwgYTMpIDogaXNJblJhbmdlKGEzLCBhMSwgYTIpIF4gaXNJblJhbmdlKGE0LCBhMSwgYTIpICYmIGlzSW5SYW5nZShhMywgYTIsIGExKSBeIGlzSW5SYW5nZShhNCwgYTIsIGExKSk7XG4gICAgfSxcbiAgICBoYXNPdmVybGFwOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9vdmVybGFwO1xuICAgIH1cbiAgfSwgQmFzZS5lYWNoKEN1cnZlLl9ldmFsdWF0ZU1ldGhvZHMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGdldCA9IG5hbWUgKyAnQXQnO1xuXG4gICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcbiAgICAgICAgICB0aW1lID0gdGhpcy5nZXRUaW1lKCk7XG4gICAgICByZXR1cm4gdGltZSAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlW2dldF0odGltZSwgdHJ1ZSk7XG4gICAgfTtcbiAgfSwge1xuICAgIHByZXNlcnZlOiB0cnVlXG4gIH0pLCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGluc2VydChsb2NhdGlvbnMsIGxvYywgbWVyZ2UpIHtcbiAgICAgIHZhciBsZW5ndGggPSBsb2NhdGlvbnMubGVuZ3RoLFxuICAgICAgICAgIGwgPSAwLFxuICAgICAgICAgIHIgPSBsZW5ndGggLSAxO1xuXG4gICAgICBmdW5jdGlvbiBzZWFyY2goaW5kZXgsIGRpcikge1xuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyBkaXI7IGkgPj0gLTEgJiYgaSA8PSBsZW5ndGg7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgdmFyIGxvYzIgPSBsb2NhdGlvbnNbKGkgJSBsZW5ndGggKyBsZW5ndGgpICUgbGVuZ3RoXTtcbiAgICAgICAgICBpZiAoIWxvYy5nZXRQb2ludCgpLmlzQ2xvc2UobG9jMi5nZXRQb2ludCgpLCAxZS03KSkgYnJlYWs7XG4gICAgICAgICAgaWYgKGxvYy5lcXVhbHMobG9jMikpIHJldHVybiBsb2MyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChsIDw9IHIpIHtcbiAgICAgICAgdmFyIG0gPSBsICsgciA+Pj4gMSxcbiAgICAgICAgICAgIGxvYzIgPSBsb2NhdGlvbnNbbV0sXG4gICAgICAgICAgICBmb3VuZDtcblxuICAgICAgICBpZiAobWVyZ2UgJiYgKGZvdW5kID0gbG9jLmVxdWFscyhsb2MyKSA/IGxvYzIgOiBzZWFyY2gobSwgLTEpIHx8IHNlYXJjaChtLCAxKSkpIHtcbiAgICAgICAgICBpZiAobG9jLl9vdmVybGFwKSB7XG4gICAgICAgICAgICBmb3VuZC5fb3ZlcmxhcCA9IGZvdW5kLl9pbnRlcnNlY3Rpb24uX292ZXJsYXAgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRoMSA9IGxvYy5nZXRQYXRoKCksXG4gICAgICAgICAgICBwYXRoMiA9IGxvYzIuZ2V0UGF0aCgpLFxuICAgICAgICAgICAgZGlmZiA9IHBhdGgxICE9PSBwYXRoMiA/IHBhdGgxLl9pZCAtIHBhdGgyLl9pZCA6IGxvYy5nZXRJbmRleCgpICsgbG9jLmdldFRpbWUoKSAtIChsb2MyLmdldEluZGV4KCkgKyBsb2MyLmdldFRpbWUoKSk7XG5cbiAgICAgICAgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgciA9IG0gLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGwgPSBtICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsb2NhdGlvbnMuc3BsaWNlKGwsIDAsIGxvYyk7XG4gICAgICByZXR1cm4gbG9jO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGF0aWNzOiB7XG4gICAgICAgIGluc2VydDogaW5zZXJ0LFxuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uIChsb2NhdGlvbnMpIHtcbiAgICAgICAgICB2YXIgZXhwYW5kZWQgPSBsb2NhdGlvbnMuc2xpY2UoKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSBsb2NhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGluc2VydChleHBhbmRlZCwgbG9jYXRpb25zW2ldLl9pbnRlcnNlY3Rpb24sIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KCkpO1xuICB2YXIgUGF0aEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUGF0aEl0ZW0nLFxuICAgIF9zZWxlY3RCb3VuZHM6IGZhbHNlLFxuICAgIF9jYW5TY2FsZVN0cm9rZTogdHJ1ZSxcbiAgICBiZWFuczogdHJ1ZSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoSXRlbSgpIHt9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgZGF0YSwgc2VnbWVudHMsIGNvbXBvdW5kO1xuXG4gICAgICAgIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoYXJnKSkge1xuICAgICAgICAgIHNlZ21lbnRzID0gYXJnLnNlZ21lbnRzO1xuICAgICAgICAgIGRhdGEgPSBhcmcucGF0aERhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgc2VnbWVudHMgPSBhcmc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBkYXRhID0gYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgICAgdmFyIGZpcnN0ID0gc2VnbWVudHNbMF07XG4gICAgICAgICAgY29tcG91bmQgPSBmaXJzdCAmJiBBcnJheS5pc0FycmF5KGZpcnN0WzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgICAgY29tcG91bmQgPSAoZGF0YS5tYXRjaCgvbS9naSkgfHwgW10pLmxlbmd0aCA+IDEgfHwgL3pcXHMqXFxTKy9pLnRlc3QoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3RvciA9IGNvbXBvdW5kID8gQ29tcG91bmRQYXRoIDogUGF0aDtcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKGFyZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfYXNQYXRoSXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBpc0Nsb2Nrd2lzZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXJlYSgpID49IDA7XG4gICAgfSxcbiAgICBzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uIChjbG9ja3dpc2UpIHtcbiAgICAgIGlmICh0aGlzLmlzQ2xvY2t3aXNlKCkgIT0gKGNsb2Nrd2lzZSA9ICEhY2xvY2t3aXNlKSkgdGhpcy5yZXZlcnNlKCk7XG4gICAgfSxcbiAgICBzZXRQYXRoRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGRhdGEgJiYgZGF0YS5tYXRjaCgvW21saHZjc3F0YXpdW15tbGh2Y3NxdGF6XSovaWcpLFxuICAgICAgICAgIGNvb3JkcyxcbiAgICAgICAgICByZWxhdGl2ZSA9IGZhbHNlLFxuICAgICAgICAgIHByZXZpb3VzLFxuICAgICAgICAgIGNvbnRyb2wsXG4gICAgICAgICAgY3VycmVudCA9IG5ldyBQb2ludCgpLFxuICAgICAgICAgIHN0YXJ0ID0gbmV3IFBvaW50KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldENvb3JkKGluZGV4LCBjb29yZCkge1xuICAgICAgICB2YXIgdmFsID0gK2Nvb3Jkc1tpbmRleF07XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdmFsICs9IGN1cnJlbnRbY29vcmRdO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQb2ludChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGdldENvb3JkKGluZGV4LCAneCcpLCBnZXRDb29yZChpbmRleCArIDEsICd5JykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMgJiYgcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV0sXG4gICAgICAgICAgICBjb21tYW5kID0gcGFydFswXSxcbiAgICAgICAgICAgIGxvd2VyID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb29yZHMgPSBwYXJ0Lm1hdGNoKC9bKy1dPyg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPy9nKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoO1xuICAgICAgICByZWxhdGl2ZSA9IGNvbW1hbmQgPT09IGxvd2VyO1xuICAgICAgICBpZiAocHJldmlvdXMgPT09ICd6JyAmJiAhL1ttel0vLnRlc3QobG93ZXIpKSB0aGlzLm1vdmVUbyhjdXJyZW50KTtcblxuICAgICAgICBzd2l0Y2ggKGxvd2VyKSB7XG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICB2YXIgbW92ZSA9IGxvd2VyID09PSAnbSc7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgdGhpc1ttb3ZlID8gJ21vdmVUbycgOiAnbGluZVRvJ10oY3VycmVudCA9IGdldFBvaW50KGopKTtcblxuICAgICAgICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICBtb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udHJvbCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgdmFyIGNvb3JkID0gbG93ZXIgPT09ICdoJyA/ICd4JyA6ICd5JztcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNsb25lKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgY3VycmVudFtjb29yZF0gPSBnZXRDb29yZChqLCBjb29yZCk7XG4gICAgICAgICAgICAgIHRoaXMubGluZVRvKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250cm9sID0gY3VycmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA2KSB7XG4gICAgICAgICAgICAgIHRoaXMuY3ViaWNDdXJ2ZVRvKGdldFBvaW50KGopLCBjb250cm9sID0gZ2V0UG9pbnQoaiArIDIpLCBjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcbiAgICAgICAgICAgICAgdGhpcy5jdWJpY0N1cnZlVG8oL1tjc10vLnRlc3QocHJldmlvdXMpID8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKSA6IGN1cnJlbnQsIGNvbnRyb2wgPSBnZXRQb2ludChqKSwgY3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG4gICAgICAgICAgICAgIHByZXZpb3VzID0gbG93ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA0KSB7XG4gICAgICAgICAgICAgIHRoaXMucXVhZHJhdGljQ3VydmVUbyhjb250cm9sID0gZ2V0UG9pbnQoaiksIGN1cnJlbnQgPSBnZXRQb2ludChqICsgMikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICB0aGlzLnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbCA9IC9bcXRdLy50ZXN0KHByZXZpb3VzKSA/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbCkgOiBjdXJyZW50LCBjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuICAgICAgICAgICAgICBwcmV2aW91cyA9IGxvd2VyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNykge1xuICAgICAgICAgICAgICB0aGlzLmFyY1RvKGN1cnJlbnQgPSBnZXRQb2ludChqICsgNSksIG5ldyBTaXplKCtjb29yZHNbal0sICtjb29yZHNbaiArIDFdKSwgK2Nvb3Jkc1tqICsgMl0sICtjb29yZHNbaiArIDRdLCArY29vcmRzW2ogKyAzXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICB0aGlzLmNsb3NlUGF0aCgxZS0xMik7XG4gICAgICAgICAgICBjdXJyZW50ID0gc3RhcnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzID0gbG93ZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcbiAgICB9LFxuICAgIF9jb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgd2luZGluZyA9IHBvaW50LmlzSW5zaWRlKHRoaXMuZ2V0Qm91bmRzKHtcbiAgICAgICAgaW50ZXJuYWw6IHRydWUsXG4gICAgICAgIGhhbmRsZTogdHJ1ZVxuICAgICAgfSkpID8gdGhpcy5fZ2V0V2luZGluZyhwb2ludCkgOiB7fTtcbiAgICAgIHJldHVybiB3aW5kaW5nLm9uUGF0aCB8fCAhISh0aGlzLmdldEZpbGxSdWxlKCkgPT09ICdldmVub2RkJyA/IHdpbmRpbmcud2luZGluZ0wgJiAxIHx8IHdpbmRpbmcud2luZGluZ1IgJiAxIDogd2luZGluZy53aW5kaW5nKTtcbiAgICB9LFxuICAgIGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uIChwYXRoLCBpbmNsdWRlLCBfbWF0cml4LCBfcmV0dXJuRmlyc3QpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyA9PT0gcGF0aCB8fCAhcGF0aCxcbiAgICAgICAgICBtYXRyaXgxID0gdGhpcy5fbWF0cml4Ll9vck51bGxJZklkZW50aXR5KCksXG4gICAgICAgICAgbWF0cml4MiA9IHNlbGYgPyBtYXRyaXgxIDogKF9tYXRyaXggfHwgcGF0aC5fbWF0cml4KS5fb3JOdWxsSWZJZGVudGl0eSgpO1xuXG4gICAgICByZXR1cm4gc2VsZiB8fCB0aGlzLmdldEJvdW5kcyhtYXRyaXgxKS5pbnRlcnNlY3RzKHBhdGguZ2V0Qm91bmRzKG1hdHJpeDIpLCAxZS0xMikgPyBDdXJ2ZS5nZXRJbnRlcnNlY3Rpb25zKHRoaXMuZ2V0Q3VydmVzKCksICFzZWxmICYmIHBhdGguZ2V0Q3VydmVzKCksIGluY2x1ZGUsIG1hdHJpeDEsIG1hdHJpeDIsIF9yZXR1cm5GaXJzdCkgOiBbXTtcbiAgICB9LFxuICAgIGdldENyb3NzaW5nczogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEludGVyc2VjdGlvbnMocGF0aCwgZnVuY3Rpb24gKGludGVyKSB7XG4gICAgICAgIHJldHVybiBpbnRlci5pc0Nyb3NzaW5nKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldE5lYXJlc3RMb2NhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG4gICAgICAgICAgbWluRGlzdCA9IEluZmluaXR5LFxuICAgICAgICAgIG1pbkxvYyA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbG9jID0gY3VydmVzW2ldLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cbiAgICAgICAgaWYgKGxvYy5fZGlzdGFuY2UgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgbWluRGlzdCA9IGxvYy5fZGlzdGFuY2U7XG4gICAgICAgICAgbWluTG9jID0gbG9jO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaW5Mb2M7XG4gICAgfSxcbiAgICBnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGxvYyA/IGxvYy5nZXRQb2ludCgpIDogbG9jO1xuICAgIH0sXG4gICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgICB2YXIgaXNQYXRoID0gIXRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgIG5hbWUgPSBpc1BhdGggPyAnX3NlZ21lbnRzJyA6ICdfY2hpbGRyZW4nLFxuICAgICAgICAgIGl0ZW1zRnJvbSA9IGZyb21bbmFtZV0sXG4gICAgICAgICAgaXRlbXNUbyA9IHRvW25hbWVdLFxuICAgICAgICAgIGl0ZW1zID0gdGhpc1tuYW1lXTtcblxuICAgICAgaWYgKCFpdGVtc0Zyb20gfHwgIWl0ZW1zVG8gfHwgaXRlbXNGcm9tLmxlbmd0aCAhPT0gaXRlbXNUby5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wZXJhbmRzIGluIGludGVycG9sYXRlKCkgY2FsbDogJyArIGZyb20gKyAnLCAnICsgdG8pO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudCA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpdGVtc1RvLmxlbmd0aDtcblxuICAgICAgaWYgKGN1cnJlbnQgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGN0b3IgPSBpc1BhdGggPyBTZWdtZW50IDogUGF0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gY3VycmVudDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hZGQobmV3IGN0b3IoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCA+IGxlbmd0aCkge1xuICAgICAgICB0aGlzW2lzUGF0aCA/ICdyZW1vdmVTZWdtZW50cycgOiAncmVtb3ZlQ2hpbGRyZW4nXShsZW5ndGgsIGN1cnJlbnQpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW1zW2ldLmludGVycG9sYXRlKGl0ZW1zRnJvbVtpXSwgaXRlbXNUb1tpXSwgZmFjdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUGF0aCkge1xuICAgICAgICB0aGlzLnNldENsb3NlZChmcm9tLl9jbG9zZWQpO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoOSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wYXJlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdmFyIG9rID0gZmFsc2U7XG5cbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHZhciBwYXRoczEgPSB0aGlzLl9jaGlsZHJlbiB8fCBbdGhpc10sXG4gICAgICAgICAgICBwYXRoczIgPSBwYXRoLl9jaGlsZHJlbiA/IHBhdGguX2NoaWxkcmVuLnNsaWNlKCkgOiBbcGF0aF0sXG4gICAgICAgICAgICBsZW5ndGgxID0gcGF0aHMxLmxlbmd0aCxcbiAgICAgICAgICAgIGxlbmd0aDIgPSBwYXRoczIubGVuZ3RoLFxuICAgICAgICAgICAgbWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICBvayA9IHRydWU7XG4gICAgICAgIHZhciBib3VuZHNPdmVybGFwcyA9IENvbGxpc2lvbkRldGVjdGlvbi5maW5kSXRlbUJvdW5kc0NvbGxpc2lvbnMocGF0aHMxLCBwYXRoczIsIE51bWVyaWNhbC5HRU9NRVRSSUNfRVBTSUxPTik7XG5cbiAgICAgICAgZm9yICh2YXIgaTEgPSBsZW5ndGgxIC0gMTsgaTEgPj0gMCAmJiBvazsgaTEtLSkge1xuICAgICAgICAgIHZhciBwYXRoMSA9IHBhdGhzMVtpMV07XG4gICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgcGF0aEJvdW5kc092ZXJsYXBzID0gYm91bmRzT3ZlcmxhcHNbaTFdO1xuXG4gICAgICAgICAgaWYgKHBhdGhCb3VuZHNPdmVybGFwcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaTIgPSBwYXRoQm91bmRzT3ZlcmxhcHMubGVuZ3RoIC0gMTsgaTIgPj0gMCAmJiAhb2s7IGkyLS0pIHtcbiAgICAgICAgICAgICAgaWYgKHBhdGgxLmNvbXBhcmUocGF0aHMyW3BhdGhCb3VuZHNPdmVybGFwc1tpMl1dKSkge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFtwYXRoQm91bmRzT3ZlcmxhcHNbaTJdXSkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hlZFtwYXRoQm91bmRzT3ZlcmxhcHNbaTJdXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9rID0gb2sgJiYgY291bnQgPT09IGxlbmd0aDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvaztcbiAgICB9XG4gIH0pO1xuICB2YXIgUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUGF0aCcsXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgc2VnbWVudHM6IFtdLFxuICAgICAgY2xvc2VkOiBmYWxzZVxuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUGF0aChhcmcpIHtcbiAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fc2VnbWVudHMgPSBbXTtcbiAgICAgIHRoaXMuX3ZlcnNpb24gPSAwO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc2VnbWVudHMgPSBBcnJheS5pc0FycmF5KGFyZykgPyB0eXBlb2YgYXJnWzBdID09PSAnb2JqZWN0JyA/IGFyZyA6IGFyZ3MgOiBhcmcgJiYgYXJnLnNpemUgPT09IHVuZGVmaW5lZCAmJiAoYXJnLnggIT09IHVuZGVmaW5lZCB8fCBhcmcucG9pbnQgIT09IHVuZGVmaW5lZCkgPyBhcmdzIDogbnVsbDtcblxuICAgICAgaWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NlZ21lbnRTZWxlY3Rpb24gPSAwO1xuXG4gICAgICAgIGlmICghc2VnbWVudHMgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG4gICAgICAgICAgYXJnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0aWFsaXplKCFzZWdtZW50cyAmJiBhcmcpO1xuICAgIH0sXG4gICAgX2VxdWFsczogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQgPT09IGl0ZW0uX2Nsb3NlZCAmJiBCYXNlLmVxdWFscyh0aGlzLl9zZWdtZW50cywgaXRlbS5fc2VnbWVudHMpO1xuICAgIH0sXG4gICAgY29weUNvbnRlbnQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc2V0U2VnbWVudHMoc291cmNlLl9zZWdtZW50cyk7XG4gICAgICB0aGlzLl9jbG9zZWQgPSBzb3VyY2UuX2Nsb3NlZDtcbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuICAgICAgX2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblxuICAgICAgaWYgKGZsYWdzICYgOCkge1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB0aGlzLl9hcmVhID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChmbGFncyAmIDMyKSB7XG4gICAgICAgICAgdGhpcy5fdmVyc2lvbisrO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnZlcykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykgdGhpcy5fY3VydmVzW2ldLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgJiA2NCkge1xuICAgICAgICB0aGlzLl9ib3VuZHMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgIHJldHVybiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoID8gcGFyZW50IDogdGhpcykuX3N0eWxlO1xuICAgIH0sXG4gICAgZ2V0U2VnbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50cztcbiAgICB9LFxuICAgIHNldFNlZ21lbnRzOiBmdW5jdGlvbiAoc2VnbWVudHMpIHtcbiAgICAgIHZhciBmdWxseVNlbGVjdGVkID0gdGhpcy5pc0Z1bGx5U2VsZWN0ZWQoKSxcbiAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGg7XG4gICAgICB0aGlzLl9zZWdtZW50cy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5fc2VnbWVudFNlbGVjdGlvbiA9IDA7XG4gICAgICB0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBzZWdtZW50c1tsZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRoaXMuc2V0Q2xvc2VkKGxhc3QpO1xuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3Qoc2VnbWVudHMsIDAsIHt9LCBsZW5ndGgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZ1bGx5U2VsZWN0ZWQpIHRoaXMuc2V0RnVsbHlTZWxlY3RlZCh0cnVlKTtcbiAgICB9LFxuICAgIGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzWzBdO1xuICAgIH0sXG4gICAgZ2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50c1t0aGlzLl9zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9LFxuICAgIGdldEN1cnZlczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcbiAgICAgICAgICBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXG4gICAgICBpZiAoIWN1cnZlcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblxuICAgICAgICBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBjdXJ2ZXNbaV0gPSBuZXcgQ3VydmUodGhpcywgc2VnbWVudHNbaV0sIHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJ2ZXM7XG4gICAgfSxcbiAgICBnZXRGaXJzdEN1cnZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDdXJ2ZXMoKVswXTtcbiAgICB9LFxuICAgIGdldExhc3RDdXJ2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG4gICAgICByZXR1cm4gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXTtcbiAgICB9LFxuICAgIGlzQ2xvc2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH0sXG4gICAgc2V0Q2xvc2VkOiBmdW5jdGlvbiAoY2xvc2VkKSB7XG4gICAgICBpZiAodGhpcy5fY2xvc2VkICE9IChjbG9zZWQgPSAhIWNsb3NlZCkpIHtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gY2xvc2VkO1xuXG4gICAgICAgIGlmICh0aGlzLl9jdXJ2ZXMpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5fY3VydmVzLmxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cbiAgICAgICAgICBpZiAoY2xvc2VkKSB0aGlzLl9jdXJ2ZXNbbGVuZ3RoIC0gMV0gPSBuZXcgQ3VydmUodGhpcywgdGhpcy5fc2VnbWVudHNbbGVuZ3RoIC0gMV0sIHRoaXMuX3NlZ21lbnRzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoNDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGJlYW5zOiB0cnVlLFxuICAgIGdldFBhdGhEYXRhOiBmdW5jdGlvbiAoX21hdHJpeCwgX3ByZWNpc2lvbikge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuICAgICAgICAgIGYgPSBuZXcgRm9ybWF0dGVyKF9wcmVjaXNpb24pLFxuICAgICAgICAgIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcbiAgICAgICAgICBmaXJzdCA9IHRydWUsXG4gICAgICAgICAgY3VyWCxcbiAgICAgICAgICBjdXJZLFxuICAgICAgICAgIHByZXZYLFxuICAgICAgICAgIHByZXZZLFxuICAgICAgICAgIGluWCxcbiAgICAgICAgICBpblksXG4gICAgICAgICAgb3V0WCxcbiAgICAgICAgICBvdXRZLFxuICAgICAgICAgIHBhcnRzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFNlZ21lbnQoc2VnbWVudCwgc2tpcExpbmUpIHtcbiAgICAgICAgc2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoX21hdHJpeCwgY29vcmRzKTtcblxuICAgICAgICBjdXJYID0gY29vcmRzWzBdO1xuICAgICAgICBjdXJZID0gY29vcmRzWzFdO1xuXG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goJ00nICsgZi5wYWlyKGN1clgsIGN1clkpKTtcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluWCA9IGNvb3Jkc1syXTtcbiAgICAgICAgICBpblkgPSBjb29yZHNbM107XG5cbiAgICAgICAgICBpZiAoaW5YID09PSBjdXJYICYmIGluWSA9PT0gY3VyWSAmJiBvdXRYID09PSBwcmV2WCAmJiBvdXRZID09PSBwcmV2WSkge1xuICAgICAgICAgICAgaWYgKCFza2lwTGluZSkge1xuICAgICAgICAgICAgICB2YXIgZHggPSBjdXJYIC0gcHJldlgsXG4gICAgICAgICAgICAgICAgICBkeSA9IGN1clkgLSBwcmV2WTtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChkeCA9PT0gMCA/ICd2JyArIGYubnVtYmVyKGR5KSA6IGR5ID09PSAwID8gJ2gnICsgZi5udW1iZXIoZHgpIDogJ2wnICsgZi5wYWlyKGR4LCBkeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCdjJyArIGYucGFpcihvdXRYIC0gcHJldlgsIG91dFkgLSBwcmV2WSkgKyAnICcgKyBmLnBhaXIoaW5YIC0gcHJldlgsIGluWSAtIHByZXZZKSArICcgJyArIGYucGFpcihjdXJYIC0gcHJldlgsIGN1clkgLSBwcmV2WSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZYID0gY3VyWDtcbiAgICAgICAgcHJldlkgPSBjdXJZO1xuICAgICAgICBvdXRYID0gY29vcmRzWzRdO1xuICAgICAgICBvdXRZID0gY29vcmRzWzVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxlbmd0aCkgcmV0dXJuICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBhZGRTZWdtZW50KHNlZ21lbnRzW2ldKTtcblxuICAgICAgaWYgKHRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwKSB7XG4gICAgICAgIGFkZFNlZ21lbnQoc2VnbWVudHNbMF0sIHRydWUpO1xuICAgICAgICBwYXJ0cy5wdXNoKCd6Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuICAgIH0sXG4gICAgX3RyYW5zZm9ybUNvbnRlbnQ6IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgIGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHNlZ21lbnRzW2ldLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgX2FkZDogZnVuY3Rpb24gKHNlZ3MsIGluZGV4KSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG4gICAgICAgICAgYW1vdW50ID0gc2Vncy5sZW5ndGgsXG4gICAgICAgICAgYXBwZW5kID0gaW5kZXggPT0gbnVsbCxcbiAgICAgICAgICBpbmRleCA9IGFwcGVuZCA/IHNlZ21lbnRzLmxlbmd0aCA6IGluZGV4O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2Vnc1tpXTtcbiAgICAgICAgaWYgKHNlZ21lbnQuX3BhdGgpIHNlZ21lbnQgPSBzZWdzW2ldID0gc2VnbWVudC5jbG9uZSgpO1xuICAgICAgICBzZWdtZW50Ll9wYXRoID0gdGhpcztcbiAgICAgICAgc2VnbWVudC5faW5kZXggPSBpbmRleCArIGk7XG4gICAgICAgIGlmIChzZWdtZW50Ll9zZWxlY3Rpb24pIHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCAwLCBzZWdtZW50Ll9zZWxlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgIEJhc2UucHVzaChzZWdtZW50cywgc2Vncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50cy5zcGxpY2UuYXBwbHkoc2VnbWVudHMsIFtpbmRleCwgMF0uY29uY2F0KHNlZ3MpKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJ2ZXMpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5fY291bnRDdXJ2ZXMoKSxcbiAgICAgICAgICAgIHN0YXJ0ID0gaW5kZXggPiAwICYmIGluZGV4ICsgYW1vdW50IC0gMSA9PT0gdG90YWwgPyBpbmRleCAtIDEgOiBpbmRleCxcbiAgICAgICAgICAgIGluc2VydCA9IHN0YXJ0LFxuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBhbW91bnQsIHRvdGFsKTtcblxuICAgICAgICBpZiAoc2Vncy5fY3VydmVzKSB7XG4gICAgICAgICAgY3VydmVzLnNwbGljZS5hcHBseShjdXJ2ZXMsIFtzdGFydCwgMF0uY29uY2F0KHNlZ3MuX2N1cnZlcykpO1xuICAgICAgICAgIGluc2VydCArPSBzZWdzLl9jdXJ2ZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGluc2VydDsgaSA8IGVuZDsgaSsrKSBjdXJ2ZXMuc3BsaWNlKGksIDAsIG5ldyBDdXJ2ZSh0aGlzLCBudWxsLCBudWxsKSk7XG5cbiAgICAgICAgdGhpcy5fYWRqdXN0Q3VydmVzKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGFuZ2VkKDQxKTtcblxuICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfSxcbiAgICBfYWRqdXN0Q3VydmVzOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuICAgICAgICAgIGN1cnZlO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBjdXJ2ZSA9IGN1cnZlc1tpXTtcbiAgICAgICAgY3VydmUuX3BhdGggPSB0aGlzO1xuICAgICAgICBjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgY3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbaSArIDFdIHx8IHNlZ21lbnRzWzBdO1xuXG4gICAgICAgIGN1cnZlLl9jaGFuZ2VkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJ2ZSA9IGN1cnZlc1t0aGlzLl9jbG9zZWQgJiYgIXN0YXJ0ID8gc2VnbWVudHMubGVuZ3RoIC0gMSA6IHN0YXJ0IC0gMV0pIHtcbiAgICAgICAgY3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbc3RhcnRdIHx8IHNlZ21lbnRzWzBdO1xuXG4gICAgICAgIGN1cnZlLl9jaGFuZ2VkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJ2ZSA9IGN1cnZlc1tlbmRdKSB7XG4gICAgICAgIGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW2VuZF07XG5cbiAgICAgICAgY3VydmUuX2NoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jb3VudEN1cnZlczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcbiAgICAgIHJldHVybiAhdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDAgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiAoc2VnbWVudDEpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoID4gMSAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInID8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3QoYXJncykpIDogdGhpcy5fYWRkKFtTZWdtZW50LnJlYWQoYXJncyldKVswXTtcbiAgICB9LFxuICAgIGluc2VydDogZnVuY3Rpb24gKGluZGV4LCBzZWdtZW50MSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPiAyICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcicgPyB0aGlzLl9hZGQoU2VnbWVudC5yZWFkTGlzdChhcmdzLCAxKSwgaW5kZXgpIDogdGhpcy5fYWRkKFtTZWdtZW50LnJlYWQoYXJncywgMSldLCBpbmRleClbMF07XG4gICAgfSxcbiAgICBhZGRTZWdtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKFtTZWdtZW50LnJlYWQoYXJndW1lbnRzKV0pWzBdO1xuICAgIH0sXG4gICAgaW5zZXJ0U2VnbWVudDogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKFtTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKV0sIGluZGV4KVswXTtcbiAgICB9LFxuICAgIGFkZFNlZ21lbnRzOiBmdW5jdGlvbiAoc2VnbWVudHMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkTGlzdChzZWdtZW50cykpO1xuICAgIH0sXG4gICAgaW5zZXJ0U2VnbWVudHM6IGZ1bmN0aW9uIChpbmRleCwgc2VnbWVudHMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkTGlzdChzZWdtZW50cyksIGluZGV4KTtcbiAgICB9LFxuICAgIHJlbW92ZVNlZ21lbnQ6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIGluZGV4ICsgMSlbMF0gfHwgbnVsbDtcbiAgICB9LFxuICAgIHJlbW92ZVNlZ21lbnRzOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgX2luY2x1ZGVDdXJ2ZXMpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICAgIGVuZCA9IEJhc2UucGljayhlbmQsIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCk7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG4gICAgICAgICAgY291bnQgPSBzZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgcmVtb3ZlZCA9IHNlZ21lbnRzLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpLFxuICAgICAgICAgIGFtb3VudCA9IHJlbW92ZWQubGVuZ3RoO1xuICAgICAgaWYgKCFhbW91bnQpIHJldHVybiByZW1vdmVkO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gcmVtb3ZlZFtpXTtcbiAgICAgICAgaWYgKHNlZ21lbnQuX3NlbGVjdGlvbikgdGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIHNlZ21lbnQuX3NlbGVjdGlvbiwgMCk7XG4gICAgICAgIHNlZ21lbnQuX2luZGV4ID0gc2VnbWVudC5fcGF0aCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykgc2VnbWVudHNbaV0uX2luZGV4ID0gaTtcblxuICAgICAgaWYgKGN1cnZlcykge1xuICAgICAgICB2YXIgaW5kZXggPSBzdGFydCA+IDAgJiYgZW5kID09PSBjb3VudCArICh0aGlzLl9jbG9zZWQgPyAxIDogMCkgPyBzdGFydCAtIDEgOiBzdGFydCxcbiAgICAgICAgICAgIGN1cnZlcyA9IGN1cnZlcy5zcGxpY2UoaW5kZXgsIGFtb3VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGN1cnZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgY3VydmVzW2ldLl9wYXRoID0gbnVsbDtcblxuICAgICAgICBpZiAoX2luY2x1ZGVDdXJ2ZXMpIHJlbW92ZWQuX2N1cnZlcyA9IGN1cnZlcy5zbGljZSgxKTtcblxuICAgICAgICB0aGlzLl9hZGp1c3RDdXJ2ZXMoaW5kZXgsIGluZGV4KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hhbmdlZCg0MSk7XG5cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG4gICAgY2xlYXI6ICcjcmVtb3ZlU2VnbWVudHMnLFxuICAgIGhhc0hhbmRsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoc2VnbWVudHNbaV0uaGFzSGFuZGxlcygpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgY2xlYXJIYW5kbGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHNlZ21lbnRzW2ldLmNsZWFySGFuZGxlcygpO1xuICAgIH0sXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG4gICAgICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykgbGVuZ3RoICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblxuICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgfSxcbiAgICBnZXRBcmVhOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJlYSA9IHRoaXMuX2FyZWE7XG5cbiAgICAgIGlmIChhcmVhID09IG51bGwpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgICBjbG9zZWQgPSB0aGlzLl9jbG9zZWQ7XG4gICAgICAgIGFyZWEgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSBpICsgMSA9PT0gbDtcbiAgICAgICAgICBhcmVhICs9IEN1cnZlLmdldEFyZWEoQ3VydmUuZ2V0VmFsdWVzKHNlZ21lbnRzW2ldLCBzZWdtZW50c1tsYXN0ID8gMCA6IGkgKyAxXSwgbnVsbCwgbGFzdCAmJiAhY2xvc2VkKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hcmVhID0gYXJlYTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfSxcbiAgICBpc0Z1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5pc1NlbGVjdGVkKCkgJiYgbGVuZ3RoID4gMCAmJiB0aGlzLl9zZWdtZW50U2VsZWN0aW9uID09PSBsZW5ndGggKiA3O1xuICAgIH0sXG4gICAgc2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICBpZiAoc2VsZWN0ZWQpIHRoaXMuX3NlbGVjdFNlZ21lbnRzKHRydWUpO1xuICAgICAgdGhpcy5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG4gICAgfSxcbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgIGlmICghKHNlbGVjdGlvbiAmIDEpKSB0aGlzLl9zZWxlY3RTZWdtZW50cyhmYWxzZSk7XG4gICAgICBzZXRTZWxlY3Rpb24uYmFzZS5jYWxsKHRoaXMsIHNlbGVjdGlvbik7XG4gICAgfSxcbiAgICBfc2VsZWN0U2VnbWVudHM6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGVkID8gNyA6IDA7XG4gICAgICB0aGlzLl9zZWdtZW50U2VsZWN0aW9uID0gc2VsZWN0aW9uICogbGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBzZWdtZW50c1tpXS5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgIH0sXG4gICAgX3VwZGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24gKHNlZ21lbnQsIG9sZFNlbGVjdGlvbiwgbmV3U2VsZWN0aW9uKSB7XG4gICAgICBzZWdtZW50Ll9zZWxlY3Rpb24gPSBuZXdTZWxlY3Rpb247XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5fc2VnbWVudFNlbGVjdGlvbiArPSBuZXdTZWxlY3Rpb24gLSBvbGRTZWxlY3Rpb247XG4gICAgICBpZiAoc2VsZWN0aW9uID4gMCkgdGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcbiAgICB9LFxuICAgIGRpdmlkZUF0OiBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uQXQobG9jYXRpb24pLFxuICAgICAgICAgIGN1cnZlO1xuICAgICAgcmV0dXJuIGxvYyAmJiAoY3VydmUgPSBsb2MuZ2V0Q3VydmUoKS5kaXZpZGVBdChsb2MuZ2V0Q3VydmVPZmZzZXQoKSkpID8gY3VydmUuX3NlZ21lbnQxIDogbnVsbDtcbiAgICB9LFxuICAgIHNwbGl0QXQ6IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChsb2NhdGlvbiksXG4gICAgICAgICAgaW5kZXggPSBsb2MgJiYgbG9jLmluZGV4LFxuICAgICAgICAgIHRpbWUgPSBsb2MgJiYgbG9jLnRpbWUsXG4gICAgICAgICAgdE1pbiA9IDFlLTgsXG4gICAgICAgICAgdE1heCA9IDEgLSB0TWluO1xuXG4gICAgICBpZiAodGltZSA+IHRNYXgpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdGltZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IGN1cnZlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRpbWUgPj0gdE1pbikge1xuICAgICAgICAgIGN1cnZlc1tpbmRleCsrXS5kaXZpZGVBdFRpbWUodGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VncyA9IHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCwgdHJ1ZSksXG4gICAgICAgICAgICBwYXRoO1xuXG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICB0aGlzLnNldENsb3NlZChmYWxzZSk7XG4gICAgICAgICAgcGF0aCA9IHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcbiAgICAgICAgICBwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuICAgICAgICAgIHBhdGguY29weUF0dHJpYnV0ZXModGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLl9hZGQoc2VncywgMCk7XG5cbiAgICAgICAgdGhpcy5hZGRTZWdtZW50KHNlZ3NbMF0pO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzcGxpdDogZnVuY3Rpb24gKGluZGV4LCB0aW1lKSB7XG4gICAgICB2YXIgY3VydmUsXG4gICAgICAgICAgbG9jYXRpb24gPSB0aW1lID09PSB1bmRlZmluZWQgPyBpbmRleCA6IChjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmVzKClbaW5kZXhdKSAmJiBjdXJ2ZS5nZXRMb2NhdGlvbkF0VGltZSh0aW1lKTtcbiAgICAgIHJldHVybiBsb2NhdGlvbiAhPSBudWxsID8gdGhpcy5zcGxpdEF0KGxvY2F0aW9uKSA6IG51bGw7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiAocGF0aCwgdG9sZXJhbmNlKSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IHRvbGVyYW5jZSB8fCAwO1xuXG4gICAgICBpZiAocGF0aCAmJiBwYXRoICE9PSB0aGlzKSB7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuICAgICAgICAgICAgbGFzdDEgPSB0aGlzLmdldExhc3RTZWdtZW50KCksXG4gICAgICAgICAgICBsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcbiAgICAgICAgaWYgKCFsYXN0MikgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChsYXN0MSAmJiBsYXN0MS5fcG9pbnQuaXNDbG9zZShsYXN0Mi5fcG9pbnQsIGVwc2lsb24pKSBwYXRoLnJldmVyc2UoKTtcbiAgICAgICAgdmFyIGZpcnN0MiA9IHBhdGguZ2V0Rmlyc3RTZWdtZW50KCk7XG5cbiAgICAgICAgaWYgKGxhc3QxICYmIGxhc3QxLl9wb2ludC5pc0Nsb3NlKGZpcnN0Mi5fcG9pbnQsIGVwc2lsb24pKSB7XG4gICAgICAgICAgbGFzdDEuc2V0SGFuZGxlT3V0KGZpcnN0Mi5faGFuZGxlT3V0KTtcblxuICAgICAgICAgIHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZpcnN0MSA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCk7XG4gICAgICAgICAgaWYgKGZpcnN0MSAmJiBmaXJzdDEuX3BvaW50LmlzQ2xvc2UoZmlyc3QyLl9wb2ludCwgZXBzaWxvbikpIHBhdGgucmV2ZXJzZSgpO1xuICAgICAgICAgIGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXG4gICAgICAgICAgaWYgKGZpcnN0MSAmJiBmaXJzdDEuX3BvaW50LmlzQ2xvc2UobGFzdDIuX3BvaW50LCBlcHNpbG9uKSkge1xuICAgICAgICAgICAgZmlyc3QxLnNldEhhbmRsZUluKGxhc3QyLl9oYW5kbGVJbik7XG5cbiAgICAgICAgICAgIHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgwLCBzZWdtZW50cy5sZW5ndGggLSAxKSwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aC5fY2xvc2VkKSB0aGlzLl9hZGQoW3NlZ21lbnRzWzBdXSk7XG4gICAgICAgIHBhdGgucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCksXG4gICAgICAgICAgbGFzdCA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKTtcblxuICAgICAgaWYgKGZpcnN0ICE9PSBsYXN0ICYmIGZpcnN0Ll9wb2ludC5pc0Nsb3NlKGxhc3QuX3BvaW50LCBlcHNpbG9uKSkge1xuICAgICAgICBmaXJzdC5zZXRIYW5kbGVJbihsYXN0Ll9oYW5kbGVJbik7XG4gICAgICAgIGxhc3QucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc2V0Q2xvc2VkKHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuICAgICAgICAgIHNpbXBsaWZ5ID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpbXBsaWZ5LFxuICAgICAgICAgIHRvbGVyYW5jZSA9IHNpbXBsaWZ5ID8gMWUtNyA6IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSBjdXJ2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGN1cnZlID0gY3VydmVzW2ldO1xuICAgICAgICBpZiAoIWN1cnZlLmhhc0hhbmRsZXMoKSAmJiAoIWN1cnZlLmhhc0xlbmd0aCh0b2xlcmFuY2UpIHx8IHNpbXBsaWZ5ICYmIGN1cnZlLmlzQ29sbGluZWFyKGN1cnZlLmdldE5leHQoKSkpKSBjdXJ2ZS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zZWdtZW50cy5yZXZlcnNlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbaV07XG4gICAgICAgIHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluO1xuICAgICAgICBzZWdtZW50Ll9oYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZU91dDtcbiAgICAgICAgc2VnbWVudC5faGFuZGxlT3V0ID0gaGFuZGxlSW47XG4gICAgICAgIHNlZ21lbnQuX2luZGV4ID0gaTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3VydmVzID0gbnVsbDtcblxuICAgICAgdGhpcy5fY2hhbmdlZCg5KTtcbiAgICB9LFxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uIChmbGF0bmVzcykge1xuICAgICAgdmFyIGZsYXR0ZW5lciA9IG5ldyBQYXRoRmxhdHRlbmVyKHRoaXMsIGZsYXRuZXNzIHx8IDAuMjUsIDI1NiwgdHJ1ZSksXG4gICAgICAgICAgcGFydHMgPSBmbGF0dGVuZXIucGFydHMsXG4gICAgICAgICAgbGVuZ3RoID0gcGFydHMubGVuZ3RoLFxuICAgICAgICAgIHNlZ21lbnRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChuZXcgU2VnbWVudChwYXJ0c1tpXS5jdXJ2ZS5zbGljZSgwLCAyKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocGFydHNbbGVuZ3RoIC0gMV0uY3VydmUuc2xpY2UoNikpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG4gICAgfSxcbiAgICBzaW1wbGlmeTogZnVuY3Rpb24gKHRvbGVyYW5jZSkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gbmV3IFBhdGhGaXR0ZXIodGhpcykuZml0KHRvbGVyYW5jZSB8fCAyLjUpO1xuICAgICAgaWYgKHNlZ21lbnRzKSB0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcbiAgICAgIHJldHVybiAhIXNlZ21lbnRzO1xuICAgIH0sXG4gICAgc21vb3RoOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIG9wdHMgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICAgIHR5cGUgPSBvcHRzLnR5cGUgfHwgJ2FzeW1tZXRyaWMnLFxuICAgICAgICAgIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuICAgICAgICAgIGNsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcblxuICAgICAgZnVuY3Rpb24gZ2V0SW5kZXgodmFsdWUsIF9kZWZhdWx0KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHZhbHVlICYmIHZhbHVlLmluZGV4O1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHBhdGggPSB2YWx1ZS5wYXRoO1xuICAgICAgICAgIGlmIChwYXRoICYmIHBhdGggIT09IHRoYXQpIHRocm93IG5ldyBFcnJvcih2YWx1ZS5fY2xhc3MgKyAnICcgKyBpbmRleCArICcgb2YgJyArIHBhdGggKyAnIGlzIG5vdCBwYXJ0IG9mICcgKyB0aGF0KTtcbiAgICAgICAgICBpZiAoX2RlZmF1bHQgJiYgdmFsdWUgaW5zdGFuY2VvZiBDdXJ2ZSkgaW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IF9kZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGluZGV4IDwgMCAmJiBjbG9zZWQgPyBpbmRleCAlIGxlbmd0aCA6IGluZGV4IDwgMCA/IGluZGV4ICsgbGVuZ3RoIDogaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbG9vcCA9IGNsb3NlZCAmJiBvcHRzLmZyb20gPT09IHVuZGVmaW5lZCAmJiBvcHRzLnRvID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgZnJvbSA9IGdldEluZGV4KG9wdHMuZnJvbSwgMCksXG4gICAgICAgICAgdG8gPSBnZXRJbmRleChvcHRzLnRvLCBsZW5ndGggLSAxKTtcblxuICAgICAgaWYgKGZyb20gPiB0bykge1xuICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgZnJvbSAtPSBsZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRtcCA9IGZyb207XG4gICAgICAgICAgZnJvbSA9IHRvO1xuICAgICAgICAgIHRvID0gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgvXig/OmFzeW1tZXRyaWN8Y29udGludW91cykkLy50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHZhciBhc3ltbWV0cmljID0gdHlwZSA9PT0gJ2FzeW1tZXRyaWMnLFxuICAgICAgICAgICAgbWluID0gTWF0aC5taW4sXG4gICAgICAgICAgICBhbW91bnQgPSB0byAtIGZyb20gKyAxLFxuICAgICAgICAgICAgbiA9IGFtb3VudCAtIDEsXG4gICAgICAgICAgICBwYWRkaW5nID0gbG9vcCA/IG1pbihhbW91bnQsIDQpIDogMSxcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gcGFkZGluZyxcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHBhZGRpbmcsXG4gICAgICAgICAgICBrbm90cyA9IFtdO1xuXG4gICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBtaW4oMSwgZnJvbSk7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbWluKDEsIGxlbmd0aCAtIHRvIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICBuICs9IHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0O1xuICAgICAgICBpZiAobiA8PSAxKSByZXR1cm47XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBmcm9tIC0gcGFkZGluZ0xlZnQ7IGkgPD0gbjsgaSsrLCBqKyspIHtcbiAgICAgICAgICBrbm90c1tpXSA9IHNlZ21lbnRzWyhqIDwgMCA/IGogKyBsZW5ndGggOiBqKSAlIGxlbmd0aF0uX3BvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSBrbm90c1swXS5feCArIDIgKiBrbm90c1sxXS5feCxcbiAgICAgICAgICAgIHkgPSBrbm90c1swXS5feSArIDIgKiBrbm90c1sxXS5feSxcbiAgICAgICAgICAgIGYgPSAyLFxuICAgICAgICAgICAgbl8xID0gbiAtIDEsXG4gICAgICAgICAgICByeCA9IFt4XSxcbiAgICAgICAgICAgIHJ5ID0gW3ldLFxuICAgICAgICAgICAgcmYgPSBbZl0sXG4gICAgICAgICAgICBweCA9IFtdLFxuICAgICAgICAgICAgcHkgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHZhciBpbnRlcm5hbCA9IGkgPCBuXzEsXG4gICAgICAgICAgICAgIGEgPSBpbnRlcm5hbCA/IDEgOiBhc3ltbWV0cmljID8gMSA6IDIsXG4gICAgICAgICAgICAgIGIgPSBpbnRlcm5hbCA/IDQgOiBhc3ltbWV0cmljID8gMiA6IDcsXG4gICAgICAgICAgICAgIHUgPSBpbnRlcm5hbCA/IDQgOiBhc3ltbWV0cmljID8gMyA6IDgsXG4gICAgICAgICAgICAgIHYgPSBpbnRlcm5hbCA/IDIgOiBhc3ltbWV0cmljID8gMCA6IDEsXG4gICAgICAgICAgICAgIG0gPSBhIC8gZjtcbiAgICAgICAgICBmID0gcmZbaV0gPSBiIC0gbTtcbiAgICAgICAgICB4ID0gcnhbaV0gPSB1ICoga25vdHNbaV0uX3ggKyB2ICoga25vdHNbaSArIDFdLl94IC0gbSAqIHg7XG4gICAgICAgICAgeSA9IHJ5W2ldID0gdSAqIGtub3RzW2ldLl95ICsgdiAqIGtub3RzW2kgKyAxXS5feSAtIG0gKiB5O1xuICAgICAgICB9XG5cbiAgICAgICAgcHhbbl8xXSA9IHJ4W25fMV0gLyByZltuXzFdO1xuICAgICAgICBweVtuXzFdID0gcnlbbl8xXSAvIHJmW25fMV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IG4gLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHB4W2ldID0gKHJ4W2ldIC0gcHhbaSArIDFdKSAvIHJmW2ldO1xuICAgICAgICAgIHB5W2ldID0gKHJ5W2ldIC0gcHlbaSArIDFdKSAvIHJmW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcHhbbl0gPSAoMyAqIGtub3RzW25dLl94IC0gcHhbbl8xXSkgLyAyO1xuICAgICAgICBweVtuXSA9ICgzICoga25vdHNbbl0uX3kgLSBweVtuXzFdKSAvIDI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHBhZGRpbmdMZWZ0LCBtYXggPSBuIC0gcGFkZGluZ1JpZ2h0LCBqID0gZnJvbTsgaSA8PSBtYXg7IGkrKywgaisrKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tqIDwgMCA/IGogKyBsZW5ndGggOiBqXSxcbiAgICAgICAgICAgICAgcHQgPSBzZWdtZW50Ll9wb2ludCxcbiAgICAgICAgICAgICAgaHggPSBweFtpXSAtIHB0Ll94LFxuICAgICAgICAgICAgICBoeSA9IHB5W2ldIC0gcHQuX3k7XG4gICAgICAgICAgaWYgKGxvb3AgfHwgaSA8IG1heCkgc2VnbWVudC5zZXRIYW5kbGVPdXQoaHgsIGh5KTtcbiAgICAgICAgICBpZiAobG9vcCB8fCBpID4gcGFkZGluZ0xlZnQpIHNlZ21lbnQuc2V0SGFuZGxlSW4oLWh4LCAtaHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8PSB0bzsgaSsrKSB7XG4gICAgICAgICAgc2VnbWVudHNbaSA8IDAgPyBpICsgbGVuZ3RoIDogaV0uc21vb3RoKG9wdHMsICFsb29wICYmIGkgPT09IGZyb20sICFsb29wICYmIGkgPT09IHRvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdG9TaGFwZTogZnVuY3Rpb24gKGluc2VydCkge1xuICAgICAgaWYgKCF0aGlzLl9jbG9zZWQpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHJhZGl1cyxcbiAgICAgICAgICB0b3BDZW50ZXI7XG5cbiAgICAgIGZ1bmN0aW9uIGlzQ29sbGluZWFyKGksIGopIHtcbiAgICAgICAgdmFyIHNlZzEgPSBzZWdtZW50c1tpXSxcbiAgICAgICAgICAgIHNlZzIgPSBzZWcxLmdldE5leHQoKSxcbiAgICAgICAgICAgIHNlZzMgPSBzZWdtZW50c1tqXSxcbiAgICAgICAgICAgIHNlZzQgPSBzZWczLmdldE5leHQoKTtcbiAgICAgICAgcmV0dXJuIHNlZzEuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWcyLl9oYW5kbGVJbi5pc1plcm8oKSAmJiBzZWczLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnNC5faGFuZGxlSW4uaXNaZXJvKCkgJiYgc2VnMi5fcG9pbnQuc3VidHJhY3Qoc2VnMS5fcG9pbnQpLmlzQ29sbGluZWFyKHNlZzQuX3BvaW50LnN1YnRyYWN0KHNlZzMuX3BvaW50KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzT3J0aG9nb25hbChpKSB7XG4gICAgICAgIHZhciBzZWcyID0gc2VnbWVudHNbaV0sXG4gICAgICAgICAgICBzZWcxID0gc2VnMi5nZXRQcmV2aW91cygpLFxuICAgICAgICAgICAgc2VnMyA9IHNlZzIuZ2V0TmV4dCgpO1xuICAgICAgICByZXR1cm4gc2VnMS5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzIuX2hhbmRsZUluLmlzWmVybygpICYmIHNlZzIuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWczLl9oYW5kbGVJbi5pc1plcm8oKSAmJiBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCkuaXNPcnRob2dvbmFsKHNlZzMuX3BvaW50LnN1YnRyYWN0KHNlZzIuX3BvaW50KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQXJjKGkpIHtcbiAgICAgICAgdmFyIHNlZzEgPSBzZWdtZW50c1tpXSxcbiAgICAgICAgICAgIHNlZzIgPSBzZWcxLmdldE5leHQoKSxcbiAgICAgICAgICAgIGhhbmRsZTEgPSBzZWcxLl9oYW5kbGVPdXQsXG4gICAgICAgICAgICBoYW5kbGUyID0gc2VnMi5faGFuZGxlSW4sXG4gICAgICAgICAgICBrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNjtcblxuICAgICAgICBpZiAoaGFuZGxlMS5pc09ydGhvZ29uYWwoaGFuZGxlMikpIHtcbiAgICAgICAgICB2YXIgcHQxID0gc2VnMS5fcG9pbnQsXG4gICAgICAgICAgICAgIHB0MiA9IHNlZzIuX3BvaW50LFxuICAgICAgICAgICAgICBjb3JuZXIgPSBuZXcgTGluZShwdDEsIGhhbmRsZTEsIHRydWUpLmludGVyc2VjdChuZXcgTGluZShwdDIsIGhhbmRsZTIsIHRydWUpLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gY29ybmVyICYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMS5nZXRMZW5ndGgoKSAvIGNvcm5lci5zdWJ0cmFjdChwdDEpLmdldExlbmd0aCgpIC0ga2FwcGEpICYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMi5nZXRMZW5ndGgoKSAvIGNvcm5lci5zdWJ0cmFjdChwdDIpLmdldExlbmd0aCgpIC0ga2FwcGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXREaXN0YW5jZShpLCBqKSB7XG4gICAgICAgIHJldHVybiBzZWdtZW50c1tpXS5fcG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudHNbal0uX3BvaW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhhc0hhbmRsZXMoKSAmJiBzZWdtZW50cy5sZW5ndGggPT09IDQgJiYgaXNDb2xsaW5lYXIoMCwgMikgJiYgaXNDb2xsaW5lYXIoMSwgMykgJiYgaXNPcnRob2dvbmFsKDEpKSB7XG4gICAgICAgIHR5cGUgPSBTaGFwZS5SZWN0YW5nbGU7XG4gICAgICAgIHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCAzKSwgZ2V0RGlzdGFuY2UoMCwgMSkpO1xuICAgICAgICB0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzJdLl9wb2ludCkuZGl2aWRlKDIpO1xuICAgICAgfSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDggJiYgaXNBcmMoMCkgJiYgaXNBcmMoMikgJiYgaXNBcmMoNCkgJiYgaXNBcmMoNikgJiYgaXNDb2xsaW5lYXIoMSwgNSkgJiYgaXNDb2xsaW5lYXIoMywgNykpIHtcbiAgICAgICAgdHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcbiAgICAgICAgc2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDEsIDYpLCBnZXREaXN0YW5jZSgwLCAzKSk7XG4gICAgICAgIHJhZGl1cyA9IHNpemUuc3VidHJhY3QobmV3IFNpemUoZ2V0RGlzdGFuY2UoMCwgNyksIGdldERpc3RhbmNlKDEsIDIpKSkuZGl2aWRlKDIpO1xuICAgICAgICB0b3BDZW50ZXIgPSBzZWdtZW50c1szXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzRdLl9wb2ludCkuZGl2aWRlKDIpO1xuICAgICAgfSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDQgJiYgaXNBcmMoMCkgJiYgaXNBcmMoMSkgJiYgaXNBcmMoMikgJiYgaXNBcmMoMykpIHtcbiAgICAgICAgaWYgKE51bWVyaWNhbC5pc1plcm8oZ2V0RGlzdGFuY2UoMCwgMikgLSBnZXREaXN0YW5jZSgxLCAzKSkpIHtcbiAgICAgICAgICB0eXBlID0gU2hhcGUuQ2lyY2xlO1xuICAgICAgICAgIHJhZGl1cyA9IGdldERpc3RhbmNlKDAsIDIpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gU2hhcGUuRWxsaXBzZTtcbiAgICAgICAgICByYWRpdXMgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgyLCAwKSAvIDIsIGdldERpc3RhbmNlKDMsIDEpIC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICB0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpLFxuICAgICAgICAgICAgc2hhcGUgPSBuZXcgdHlwZSh7XG4gICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICBpbnNlcnQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBzaGFwZS5jb3B5QXR0cmlidXRlcyh0aGlzLCB0cnVlKTtcblxuICAgICAgICBzaGFwZS5fbWF0cml4LnByZXBlbmQodGhpcy5fbWF0cml4KTtcblxuICAgICAgICBzaGFwZS5yb3RhdGUodG9wQ2VudGVyLnN1YnRyYWN0KGNlbnRlcikuZ2V0QW5nbGUoKSArIDkwKTtcbiAgICAgICAgaWYgKGluc2VydCA9PT0gdW5kZWZpbmVkIHx8IGluc2VydCkgc2hhcGUuaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICB0b1BhdGg6ICcjY2xvbmUnLFxuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUocGF0aCkge1xuICAgICAgaWYgKCFwYXRoIHx8IHBhdGggaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpIHJldHVybiBjb21wYXJlLmJhc2UuY2FsbCh0aGlzLCBwYXRoKTtcbiAgICAgIHZhciBjdXJ2ZXMxID0gdGhpcy5nZXRDdXJ2ZXMoKSxcbiAgICAgICAgICBjdXJ2ZXMyID0gcGF0aC5nZXRDdXJ2ZXMoKSxcbiAgICAgICAgICBsZW5ndGgxID0gY3VydmVzMS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoMiA9IGN1cnZlczIubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbmd0aDEgfHwgIWxlbmd0aDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDEgPT0gbGVuZ3RoMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHYxID0gY3VydmVzMVswXS5nZXRWYWx1ZXMoKSxcbiAgICAgICAgICB2YWx1ZXMyID0gW10sXG4gICAgICAgICAgcG9zMSA9IDAsXG4gICAgICAgICAgcG9zMixcbiAgICAgICAgICBlbmQxID0gMCxcbiAgICAgICAgICBlbmQyO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICB2YXIgdjIgPSBjdXJ2ZXMyW2ldLmdldFZhbHVlcygpO1xuICAgICAgICB2YWx1ZXMyLnB1c2godjIpO1xuICAgICAgICB2YXIgb3ZlcmxhcHMgPSBDdXJ2ZS5nZXRPdmVybGFwcyh2MSwgdjIpO1xuXG4gICAgICAgIGlmIChvdmVybGFwcykge1xuICAgICAgICAgIHBvczIgPSAhaSAmJiBvdmVybGFwc1swXVswXSA+IDAgPyBsZW5ndGgyIC0gMSA6IGk7XG4gICAgICAgICAgZW5kMiA9IG92ZXJsYXBzWzBdWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICBlcHNpbG9uID0gMWUtOCxcbiAgICAgICAgICB2MiA9IHZhbHVlczJbcG9zMl0sXG4gICAgICAgICAgc3RhcnQyO1xuXG4gICAgICB3aGlsZSAodjEgJiYgdjIpIHtcbiAgICAgICAgdmFyIG92ZXJsYXBzID0gQ3VydmUuZ2V0T3ZlcmxhcHModjEsIHYyKTtcblxuICAgICAgICBpZiAob3ZlcmxhcHMpIHtcbiAgICAgICAgICB2YXIgdDEgPSBvdmVybGFwc1swXVswXTtcblxuICAgICAgICAgIGlmIChhYnModDEgLSBlbmQxKSA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIGVuZDEgPSBvdmVybGFwc1sxXVswXTtcblxuICAgICAgICAgICAgaWYgKGVuZDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgdjEgPSArK3BvczEgPCBsZW5ndGgxID8gY3VydmVzMVtwb3MxXS5nZXRWYWx1ZXMoKSA6IG51bGw7XG4gICAgICAgICAgICAgIGVuZDEgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdDIgPSBvdmVybGFwc1swXVsxXTtcblxuICAgICAgICAgICAgaWYgKGFicyh0MiAtIGVuZDIpIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICBpZiAoIXN0YXJ0Mikgc3RhcnQyID0gW3BvczIsIHQyXTtcbiAgICAgICAgICAgICAgZW5kMiA9IG92ZXJsYXBzWzFdWzFdO1xuXG4gICAgICAgICAgICAgIGlmIChlbmQyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrcG9zMiA+PSBsZW5ndGgyKSBwb3MyID0gMDtcbiAgICAgICAgICAgICAgICB2MiA9IHZhbHVlczJbcG9zMl0gfHwgY3VydmVzMltwb3MyXS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgICAgICBlbmQyID0gMDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghdjEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQyWzBdID09PSBwb3MyICYmIHN0YXJ0MlsxXSA9PT0gZW5kMjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uIChwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgc3R5bGUgPSB0aGlzLmdldFN0eWxlKCksXG4gICAgICAgICAgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICBjbG9zZWQgPSB0aGlzLl9jbG9zZWQsXG4gICAgICAgICAgdG9sZXJhbmNlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcsXG4gICAgICAgICAgc3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcsXG4gICAgICAgICAgam9pbixcbiAgICAgICAgICBjYXAsXG4gICAgICAgICAgbWl0ZXJMaW1pdCxcbiAgICAgICAgICBhcmVhLFxuICAgICAgICAgIGxvYyxcbiAgICAgICAgICByZXMsXG4gICAgICAgICAgaGl0U3Ryb2tlID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKCksXG4gICAgICAgICAgaGl0RmlsbCA9IG9wdGlvbnMuZmlsbCAmJiBzdHlsZS5oYXNGaWxsKCksXG4gICAgICAgICAgaGl0Q3VydmVzID0gb3B0aW9ucy5jdXJ2ZXMsXG4gICAgICAgICAgc3Ryb2tlUmFkaXVzID0gaGl0U3Ryb2tlID8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIgOiBoaXRGaWxsICYmIG9wdGlvbnMudG9sZXJhbmNlID4gMCB8fCBoaXRDdXJ2ZXMgPyAwIDogbnVsbDtcblxuICAgICAgaWYgKHN0cm9rZVJhZGl1cyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc3Ryb2tlUmFkaXVzID4gMCkge1xuICAgICAgICAgIGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCk7XG4gICAgICAgICAgY2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCk7XG4gICAgICAgICAgbWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKTtcbiAgICAgICAgICBzdHJva2VQYWRkaW5nID0gc3Ryb2tlUGFkZGluZy5hZGQoUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VSYWRpdXMsIHN0cm9rZU1hdHJpeCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGpvaW4gPSBjYXAgPSAncm91bmQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQ2xvc2VFbm91Z2gocHQsIHBhZGRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50LnN1YnRyYWN0KHB0KS5kaXZpZGUocGFkZGluZykubGVuZ3RoIDw9IDE7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50KHNlZywgcHQsIG5hbWUpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnNlbGVjdGVkIHx8IHB0LmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgIHZhciBhbmNob3IgPSBzZWcuX3BvaW50O1xuICAgICAgICAgIGlmIChwdCAhPT0gYW5jaG9yKSBwdCA9IHB0LmFkZChhbmNob3IpO1xuXG4gICAgICAgICAgaWYgKGlzQ2xvc2VFbm91Z2gocHQsIHN0cm9rZVBhZGRpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhpdFJlc3VsdChuYW1lLCB0aGF0LCB7XG4gICAgICAgICAgICAgIHNlZ21lbnQ6IHNlZyxcbiAgICAgICAgICAgICAgcG9pbnQ6IHB0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnRzKHNlZywgZW5kcykge1xuICAgICAgICByZXR1cm4gKGVuZHMgfHwgb3B0aW9ucy5zZWdtZW50cykgJiYgY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX3BvaW50LCAnc2VnbWVudCcpIHx8ICFlbmRzICYmIG9wdGlvbnMuaGFuZGxlcyAmJiAoY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZUluLCAnaGFuZGxlLWluJykgfHwgY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZU91dCwgJ2hhbmRsZS1vdXQnKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFRvQXJlYShwb2ludCkge1xuICAgICAgICBhcmVhLmFkZChwb2ludCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrU2VnbWVudFN0cm9rZShzZWdtZW50KSB7XG4gICAgICAgIHZhciBpc0pvaW4gPSBjbG9zZWQgfHwgc2VnbWVudC5faW5kZXggPiAwICYmIHNlZ21lbnQuX2luZGV4IDwgbnVtU2VnbWVudHMgLSAxO1xuXG4gICAgICAgIGlmICgoaXNKb2luID8gam9pbiA6IGNhcCkgPT09ICdyb3VuZCcpIHtcbiAgICAgICAgICByZXR1cm4gaXNDbG9zZUVub3VnaChzZWdtZW50Ll9wb2ludCwgc3Ryb2tlUGFkZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJlYSA9IG5ldyBQYXRoKHtcbiAgICAgICAgICAgIGludGVybmFsOiB0cnVlLFxuICAgICAgICAgICAgY2xvc2VkOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoaXNKb2luKSB7XG4gICAgICAgICAgICBpZiAoIXNlZ21lbnQuaXNTbW9vdGgoKSkge1xuICAgICAgICAgICAgICBQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgc3Ryb2tlUmFkaXVzLCBtaXRlckxpbWl0LCBudWxsLCBzdHJva2VNYXRyaXgsIGFkZFRvQXJlYSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjYXAgPT09ICdzcXVhcmUnKSB7XG4gICAgICAgICAgICBQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCBzdHJva2VSYWRpdXMsIG51bGwsIHN0cm9rZU1hdHJpeCwgYWRkVG9BcmVhLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWFyZWEuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgbG9jO1xuICAgICAgICAgICAgcmV0dXJuIGFyZWEuY29udGFpbnMocG9pbnQpIHx8IChsb2MgPSBhcmVhLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCkpICYmIGlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHRvbGVyYW5jZVBhZGRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5lbmRzICYmICFvcHRpb25zLnNlZ21lbnRzICYmICFjbG9zZWQpIHtcbiAgICAgICAgaWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1swXSwgdHJ1ZSkgfHwgY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0sIHRydWUpKSByZXR1cm4gcmVzO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNlZ21lbnRzIHx8IG9wdGlvbnMuaGFuZGxlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbaV0pKSByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3Ryb2tlUmFkaXVzICE9PSBudWxsKSB7XG4gICAgICAgIGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblxuICAgICAgICBpZiAobG9jKSB7XG4gICAgICAgICAgdmFyIHRpbWUgPSBsb2MuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgaWYgKHRpbWUgPT09IDAgfHwgdGltZSA9PT0gMSAmJiBudW1TZWdtZW50cyA+IDEpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tTZWdtZW50U3Ryb2tlKGxvYy5nZXRTZWdtZW50KCkpKSBsb2MgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHN0cm9rZVBhZGRpbmcpKSB7XG4gICAgICAgICAgICBsb2MgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbG9jICYmIGpvaW4gPT09ICdtaXRlcicgJiYgbnVtU2VnbWVudHMgPiAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAocG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudC5fcG9pbnQpIDw9IG1pdGVyTGltaXQgKiBzdHJva2VSYWRpdXMgJiYgY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgIGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhbG9jICYmIGhpdEZpbGwgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpIHx8IGxvYyAmJiAhaGl0U3Ryb2tlICYmICFoaXRDdXJ2ZXMgPyBuZXcgSGl0UmVzdWx0KCdmaWxsJywgdGhpcykgOiBsb2MgPyBuZXcgSGl0UmVzdWx0KGhpdFN0cm9rZSA/ICdzdHJva2UnIDogJ2N1cnZlJywgdGhpcywge1xuICAgICAgICBsb2NhdGlvbjogbG9jLFxuICAgICAgICBwb2ludDogbG9jLmdldFBvaW50KClcbiAgICAgIH0pIDogbnVsbDtcbiAgICB9XG4gIH0sIEJhc2UuZWFjaChDdXJ2ZS5fZXZhbHVhdGVNZXRob2RzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChvZmZzZXQpO1xuICAgICAgcmV0dXJuIGxvYyAmJiBsb2NbbmFtZV0oKTtcbiAgICB9O1xuICB9LCB7XG4gICAgYmVhbnM6IGZhbHNlLFxuICAgIGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGxvYyA9IGN1cnZlc1tpXS5nZXRMb2NhdGlvbk9mKHBvaW50KTtcbiAgICAgICAgaWYgKGxvYykgcmV0dXJuIGxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBnZXRPZmZzZXRPZjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG4gICAgICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBzdGFydCA9IGxlbmd0aCxcbiAgICAgICAgICAgICAgY3VydmUgPSBjdXJ2ZXNbaV07XG4gICAgICAgICAgbGVuZ3RoICs9IGN1cnZlLmdldExlbmd0aCgpO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aCA+IG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnZlLmdldExvY2F0aW9uQXQob2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJ2ZXMubGVuZ3RoID4gMCAmJiBvZmZzZXQgPD0gdGhpcy5nZXRMZW5ndGgoKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ3VydmVMb2NhdGlvbihjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZzZXQgJiYgb2Zmc2V0LmdldFBhdGggJiYgb2Zmc2V0LmdldFBhdGgoKSA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldE9mZnNldHNXaXRoVGFuZ2VudDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRhbmdlbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0YW5nZW50LmlzWmVybygpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICAgIHZhciBjdXJ2ZVN0YXJ0ID0gMDtcbiAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnZlID0gY3VydmVzW2ldO1xuICAgICAgICB2YXIgY3VydmVUaW1lcyA9IGN1cnZlLmdldFRpbWVzV2l0aFRhbmdlbnQodGFuZ2VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBjdXJ2ZVRpbWVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSBjdXJ2ZVN0YXJ0ICsgY3VydmUuZ2V0T2Zmc2V0QXRUaW1lKGN1cnZlVGltZXNbal0pO1xuXG4gICAgICAgICAgaWYgKG9mZnNldHMuaW5kZXhPZihvZmZzZXQpIDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VydmVTdGFydCArPSBjdXJ2ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXRzO1xuICAgIH1cbiAgfSksIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZHJhd0hhbmRsZXMoY3R4LCBzZWdtZW50cywgbWF0cml4LCBzaXplKSB7XG4gICAgICBpZiAoc2l6ZSA8PSAwKSByZXR1cm47XG4gICAgICB2YXIgaGFsZiA9IHNpemUgLyAyLFxuICAgICAgICAgIG1pbmlTaXplID0gc2l6ZSAtIDIsXG4gICAgICAgICAgbWluaUhhbGYgPSBoYWxmIC0gMSxcbiAgICAgICAgICBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG4gICAgICAgICAgcFgsXG4gICAgICAgICAgcFk7XG5cbiAgICAgIGZ1bmN0aW9uIGRyYXdIYW5kbGUoaW5kZXgpIHtcbiAgICAgICAgdmFyIGhYID0gY29vcmRzW2luZGV4XSxcbiAgICAgICAgICAgIGhZID0gY29vcmRzW2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKHBYICE9IGhYIHx8IHBZICE9IGhZKSB7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8ocFgsIHBZKTtcbiAgICAgICAgICBjdHgubGluZVRvKGhYLCBoWSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHguYXJjKGhYLCBoWSwgaGFsZiwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXSxcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlZ21lbnQuX3NlbGVjdGlvbjtcblxuICAgICAgICBzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3Jkcyk7XG5cbiAgICAgICAgcFggPSBjb29yZHNbMF07XG4gICAgICAgIHBZID0gY29vcmRzWzFdO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYgMikgZHJhd0hhbmRsZSgyKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmIDQpIGRyYXdIYW5kbGUoNCk7XG4gICAgICAgIGN0eC5maWxsUmVjdChwWCAtIGhhbGYsIHBZIC0gaGFsZiwgc2l6ZSwgc2l6ZSk7XG5cbiAgICAgICAgaWYgKG1pbmlTaXplID4gMCAmJiAhKHNlbGVjdGlvbiAmIDEpKSB7XG4gICAgICAgICAgdmFyIGZpbGxTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QocFggLSBtaW5pSGFsZiwgcFkgLSBtaW5pSGFsZiwgbWluaVNpemUsIG1pbmlTaXplKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1NlZ21lbnRzKGN0eCwgcGF0aCwgbWF0cml4KSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuICAgICAgICAgIGZpcnN0ID0gdHJ1ZSxcbiAgICAgICAgICBjdXJYLFxuICAgICAgICAgIGN1clksXG4gICAgICAgICAgcHJldlgsXG4gICAgICAgICAgcHJldlksXG4gICAgICAgICAgaW5YLFxuICAgICAgICAgIGluWSxcbiAgICAgICAgICBvdXRYLFxuICAgICAgICAgIG91dFk7XG5cbiAgICAgIGZ1bmN0aW9uIGRyYXdTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgIHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblxuICAgICAgICAgIGN1clggPSBjb29yZHNbMF07XG4gICAgICAgICAgY3VyWSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludDtcbiAgICAgICAgICBjdXJYID0gcG9pbnQuX3g7XG4gICAgICAgICAgY3VyWSA9IHBvaW50Ll95O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhjdXJYLCBjdXJZKTtcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIGluWCA9IGNvb3Jkc1syXTtcbiAgICAgICAgICAgIGluWSA9IGNvb3Jkc1szXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNlZ21lbnQuX2hhbmRsZUluO1xuICAgICAgICAgICAgaW5YID0gY3VyWCArIGhhbmRsZS5feDtcbiAgICAgICAgICAgIGluWSA9IGN1clkgKyBoYW5kbGUuX3k7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1clkgJiYgb3V0WCA9PT0gcHJldlggJiYgb3V0WSA9PT0gcHJldlkpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oY3VyWCwgY3VyWSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKG91dFgsIG91dFksIGluWCwgaW5ZLCBjdXJYLCBjdXJZKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2WCA9IGN1clg7XG4gICAgICAgIHByZXZZID0gY3VyWTtcblxuICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgb3V0WCA9IGNvb3Jkc1s0XTtcbiAgICAgICAgICBvdXRZID0gY29vcmRzWzVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG4gICAgICAgICAgb3V0WCA9IHByZXZYICsgaGFuZGxlLl94O1xuICAgICAgICAgIG91dFkgPSBwcmV2WSArIGhhbmRsZS5feTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBkcmF3U2VnbWVudChzZWdtZW50c1tpXSk7XG5cbiAgICAgIGlmIChwYXRoLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCkgZHJhd1NlZ21lbnQoc2VnbWVudHNbMF0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBfZHJhdzogZnVuY3Rpb24gKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCkge1xuICAgICAgICB2YXIgZG9udFN0YXJ0ID0gcGFyYW0uZG9udFN0YXJ0LFxuICAgICAgICAgICAgZG9udFBhaW50ID0gcGFyYW0uZG9udEZpbmlzaCB8fCBwYXJhbS5jbGlwLFxuICAgICAgICAgICAgc3R5bGUgPSB0aGlzLmdldFN0eWxlKCksXG4gICAgICAgICAgICBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuICAgICAgICAgICAgaGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG4gICAgICAgICAgICBkYXNoQXJyYXkgPSBzdHlsZS5nZXREYXNoQXJyYXkoKSxcbiAgICAgICAgICAgIGRhc2hMZW5ndGggPSAhcGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoICYmIGhhc1N0cm9rZSAmJiBkYXNoQXJyYXkgJiYgZGFzaEFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKCFkb250U3RhcnQpIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgJiYgIWRhc2hMZW5ndGggfHwgZG9udFBhaW50KSB7XG4gICAgICAgICAgZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgc3Ryb2tlTWF0cml4KTtcbiAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRPZmZzZXQoaSkge1xuICAgICAgICAgIHJldHVybiBkYXNoQXJyYXlbKGkgJSBkYXNoTGVuZ3RoICsgZGFzaExlbmd0aCkgJSBkYXNoTGVuZ3RoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRTdHlsZXMoY3R4LCBwYXJhbSwgdmlld01hdHJpeCk7XG5cbiAgICAgICAgICBpZiAoaGFzRmlsbCkge1xuICAgICAgICAgICAgY3R4LmZpbGwoc3R5bGUuZ2V0RmlsbFJ1bGUoKSk7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc1N0cm9rZSkge1xuICAgICAgICAgICAgaWYgKGRhc2hMZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKCFkb250U3RhcnQpIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgdmFyIGZsYXR0ZW5lciA9IG5ldyBQYXRoRmxhdHRlbmVyKHRoaXMsIDAuMjUsIDMyLCBmYWxzZSwgc3Ryb2tlTWF0cml4KSxcbiAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGZsYXR0ZW5lci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBmcm9tID0gLXN0eWxlLmdldERhc2hPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICAgICAgZnJvbSAtPSBnZXRPZmZzZXQoaS0tKSArIGdldE9mZnNldChpLS0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGZyb20gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBnZXRPZmZzZXQoaSsrKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IDAgfHwgdG8gPiAwKSBmbGF0dGVuZXIuZHJhd1BhcnQoY3R4LCBNYXRoLm1heChmcm9tLCAwKSwgTWF0aC5tYXgodG8sIDApKTtcbiAgICAgICAgICAgICAgICBmcm9tID0gdG8gKyBnZXRPZmZzZXQoaSsrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2RyYXdTZWxlY3RlZDogZnVuY3Rpb24gKGN0eCwgbWF0cml4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgbWF0cml4KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBkcmF3SGFuZGxlcyhjdHgsIHRoaXMuX3NlZ21lbnRzLCBtYXRyaXgsIHBhcGVyLnNldHRpbmdzLmhhbmRsZVNpemUpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50U2VnbWVudCh0aGF0KSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGF0Ll9zZWdtZW50cztcbiAgICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIG1vdmVUbygpIGNvbW1hbmQgZmlyc3QnKTtcbiAgICAgIHJldHVybiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbW92ZVRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAxKSB0aGlzLnJlbW92ZVNlZ21lbnQoMCk7XG4gICAgICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB0aGlzLl9hZGQoW25ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSldKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlQnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb3ZlQnkoKSBpcyB1bnN1cHBvcnRlZCBvbiBQYXRoIGl0ZW1zLicpO1xuICAgICAgfSxcbiAgICAgIGxpbmVUbzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hZGQoW25ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSldKTtcbiAgICAgIH0sXG4gICAgICBjdWJpY0N1cnZlVG86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBoYW5kbGUxID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpO1xuICAgICAgICBjdXJyZW50LnNldEhhbmRsZU91dChoYW5kbGUxLnN1YnRyYWN0KGN1cnJlbnQuX3BvaW50KSk7XG5cbiAgICAgICAgdGhpcy5fYWRkKFtuZXcgU2VnbWVudCh0bywgaGFuZGxlMi5zdWJ0cmFjdCh0bykpXSk7XG4gICAgICB9LFxuICAgICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGhhbmRsZSA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXG4gICAgICAgIHRoaXMuY3ViaWNDdXJ2ZVRvKGhhbmRsZS5hZGQoY3VycmVudC5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksIGhhbmRsZS5hZGQodG8uc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLCB0byk7XG4gICAgICB9LFxuICAgICAgY3VydmVUbzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIHRocm91Z2ggPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgdCA9IEJhc2UucGljayhCYXNlLnJlYWQoYXJncyksIDAuNSksXG4gICAgICAgICAgICB0MSA9IDEgLSB0LFxuICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcbiAgICAgICAgICAgIGhhbmRsZSA9IHRocm91Z2guc3VidHJhY3QoY3VycmVudC5tdWx0aXBseSh0MSAqIHQxKSkuc3VidHJhY3QodG8ubXVsdGlwbHkodCAqIHQpKS5kaXZpZGUoMiAqIHQgKiB0MSk7XG5cbiAgICAgICAgaWYgKGhhbmRsZS5pc05hTigpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwdXQgYSBjdXJ2ZSB0aHJvdWdoIHBvaW50cyB3aXRoIHBhcmFtZXRlciA9ICcgKyB0KTtcbiAgICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZSwgdG8pO1xuICAgICAgfSxcbiAgICAgIGFyY1RvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgICBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLFxuICAgICAgICAgICAgZnJvbSA9IGN1cnJlbnQuX3BvaW50LFxuICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgdGhyb3VnaCxcbiAgICAgICAgICAgIHBlZWsgPSBCYXNlLnBlZWsoYXJncyksXG4gICAgICAgICAgICBjbG9ja3dpc2UgPSBCYXNlLnBpY2socGVlaywgdHJ1ZSksXG4gICAgICAgICAgICBjZW50ZXIsXG4gICAgICAgICAgICBleHRlbnQsXG4gICAgICAgICAgICB2ZWN0b3IsXG4gICAgICAgICAgICBtYXRyaXg7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHZhciBtaWRkbGUgPSBmcm9tLmFkZCh0bykuZGl2aWRlKDIpLFxuICAgICAgICAgICAgICB0aHJvdWdoID0gbWlkZGxlLmFkZChtaWRkbGUuc3VidHJhY3QoZnJvbSkucm90YXRlKGNsb2Nrd2lzZSA/IC05MCA6IDkwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQmFzZS5yZW1haW4oYXJncykgPD0gMikge1xuICAgICAgICAgIHRocm91Z2ggPSB0bztcbiAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZyb20uZXF1YWxzKHRvKSkge1xuICAgICAgICAgIHZhciByYWRpdXMgPSBTaXplLnJlYWQoYXJncyksXG4gICAgICAgICAgICAgIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG4gICAgICAgICAgaWYgKGlzWmVybyhyYWRpdXMud2lkdGgpIHx8IGlzWmVybyhyYWRpdXMuaGVpZ2h0KSkgcmV0dXJuIHRoaXMubGluZVRvKHRvKTtcbiAgICAgICAgICB2YXIgcm90YXRpb24gPSBCYXNlLnJlYWQoYXJncyksXG4gICAgICAgICAgICAgIGNsb2Nrd2lzZSA9ICEhQmFzZS5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgICBsYXJnZSA9ICEhQmFzZS5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgICBtaWRkbGUgPSBmcm9tLmFkZCh0bykuZGl2aWRlKDIpLFxuICAgICAgICAgICAgICBwdCA9IGZyb20uc3VidHJhY3QobWlkZGxlKS5yb3RhdGUoLXJvdGF0aW9uKSxcbiAgICAgICAgICAgICAgeCA9IHB0LngsXG4gICAgICAgICAgICAgIHkgPSBwdC55LFxuICAgICAgICAgICAgICByeCA9IGFicyhyYWRpdXMud2lkdGgpLFxuICAgICAgICAgICAgICByeSA9IGFicyhyYWRpdXMuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgcnhTcSA9IHJ4ICogcngsXG4gICAgICAgICAgICAgIHJ5U3EgPSByeSAqIHJ5LFxuICAgICAgICAgICAgICB4U3EgPSB4ICogeCxcbiAgICAgICAgICAgICAgeVNxID0geSAqIHk7XG4gICAgICAgICAgdmFyIGZhY3RvciA9IHNxcnQoeFNxIC8gcnhTcSArIHlTcSAvIHJ5U3EpO1xuXG4gICAgICAgICAgaWYgKGZhY3RvciA+IDEpIHtcbiAgICAgICAgICAgIHJ4ICo9IGZhY3RvcjtcbiAgICAgICAgICAgIHJ5ICo9IGZhY3RvcjtcbiAgICAgICAgICAgIHJ4U3EgPSByeCAqIHJ4O1xuICAgICAgICAgICAgcnlTcSA9IHJ5ICogcnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmFjdG9yID0gKHJ4U3EgKiByeVNxIC0gcnhTcSAqIHlTcSAtIHJ5U3EgKiB4U3EpIC8gKHJ4U3EgKiB5U3EgKyByeVNxICogeFNxKTtcbiAgICAgICAgICBpZiAoYWJzKGZhY3RvcikgPCAxZS0xMikgZmFjdG9yID0gMDtcbiAgICAgICAgICBpZiAoZmFjdG9yIDwgMCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcbiAgICAgICAgICBjZW50ZXIgPSBuZXcgUG9pbnQocnggKiB5IC8gcnksIC1yeSAqIHggLyByeCkubXVsdGlwbHkoKGxhcmdlID09PSBjbG9ja3dpc2UgPyAtMSA6IDEpICogc3FydChmYWN0b3IpKS5yb3RhdGUocm90YXRpb24pLmFkZChtaWRkbGUpO1xuICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoY2VudGVyKS5yb3RhdGUocm90YXRpb24pLnNjYWxlKHJ4LCByeSk7XG4gICAgICAgICAgdmVjdG9yID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKGZyb20pO1xuICAgICAgICAgIGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0bykpO1xuICAgICAgICAgIGlmICghY2xvY2t3aXNlICYmIGV4dGVudCA+IDApIGV4dGVudCAtPSAzNjA7ZWxzZSBpZiAoY2xvY2t3aXNlICYmIGV4dGVudCA8IDApIGV4dGVudCArPSAzNjA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhyb3VnaCkge1xuICAgICAgICAgIHZhciBsMSA9IG5ldyBMaW5lKGZyb20uYWRkKHRocm91Z2gpLmRpdmlkZSgyKSwgdGhyb3VnaC5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoOTApLCB0cnVlKSxcbiAgICAgICAgICAgICAgbDIgPSBuZXcgTGluZSh0aHJvdWdoLmFkZCh0bykuZGl2aWRlKDIpLCB0by5zdWJ0cmFjdCh0aHJvdWdoKS5yb3RhdGUoOTApLCB0cnVlKSxcbiAgICAgICAgICAgICAgbGluZSA9IG5ldyBMaW5lKGZyb20sIHRvKSxcbiAgICAgICAgICAgICAgdGhyb3VnaFNpZGUgPSBsaW5lLmdldFNpZGUodGhyb3VnaCk7XG4gICAgICAgICAgY2VudGVyID0gbDEuaW50ZXJzZWN0KGwyLCB0cnVlKTtcblxuICAgICAgICAgIGlmICghY2VudGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRocm91Z2hTaWRlKSByZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2ZWN0b3IgPSBmcm9tLnN1YnRyYWN0KGNlbnRlcik7XG4gICAgICAgICAgZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUodG8uc3VidHJhY3QoY2VudGVyKSk7XG4gICAgICAgICAgdmFyIGNlbnRlclNpZGUgPSBsaW5lLmdldFNpZGUoY2VudGVyLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChjZW50ZXJTaWRlID09PSAwKSB7XG4gICAgICAgICAgICBleHRlbnQgPSB0aHJvdWdoU2lkZSAqIGFicyhleHRlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhyb3VnaFNpZGUgPT09IGNlbnRlclNpZGUpIHtcbiAgICAgICAgICAgIGV4dGVudCArPSBleHRlbnQgPCAwID8gMzYwIDogLTM2MDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgdmFyIGVwc2lsb24gPSAxZS03LFxuICAgICAgICAgICAgICBleHQgPSBhYnMoZXh0ZW50KSxcbiAgICAgICAgICAgICAgY291bnQgPSBleHQgPj0gMzYwID8gNCA6IE1hdGguY2VpbCgoZXh0IC0gZXBzaWxvbikgLyA5MCksXG4gICAgICAgICAgICAgIGluYyA9IGV4dGVudCAvIGNvdW50LFxuICAgICAgICAgICAgICBoYWxmID0gaW5jICogTWF0aC5QSSAvIDM2MCxcbiAgICAgICAgICAgICAgeiA9IDQgLyAzICogTWF0aC5zaW4oaGFsZikgLyAoMSArIE1hdGguY29zKGhhbGYpKSxcbiAgICAgICAgICAgICAgc2VnbWVudHMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwdCA9IHRvLFxuICAgICAgICAgICAgICAgIG91dCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChpIDwgY291bnQpIHtcbiAgICAgICAgICAgICAgb3V0ID0gdmVjdG9yLnJvdGF0ZSg5MCkubXVsdGlwbHkoeik7XG5cbiAgICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHB0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IpO1xuICAgICAgICAgICAgICAgIG91dCA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChvdXQpKS5zdWJ0cmFjdChwdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHQgPSBjZW50ZXIuYWRkKHZlY3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQuc2V0SGFuZGxlT3V0KG91dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2luID0gdmVjdG9yLnJvdGF0ZSgtOTApLm11bHRpcGx5KHopO1xuXG4gICAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBfaW4gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQoX2luKSkuc3VidHJhY3QocHQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgU2VnbWVudChwdCwgX2luLCBvdXQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVjdG9yID0gdmVjdG9yLnJvdGF0ZShpbmMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2FkZChzZWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaW5lQnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblxuICAgICAgICB0aGlzLmxpbmVUbyhjdXJyZW50LmFkZCh0bykpO1xuICAgICAgfSxcbiAgICAgIGN1cnZlQnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICB0aHJvdWdoID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHRvID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHBhcmFtZXRlciA9IEJhc2UucmVhZChhcmdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cbiAgICAgICAgdGhpcy5jdXJ2ZVRvKGN1cnJlbnQuYWRkKHRocm91Z2gpLCBjdXJyZW50LmFkZCh0byksIHBhcmFtZXRlcik7XG4gICAgICB9LFxuICAgICAgY3ViaWNDdXJ2ZUJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaGFuZGxlMSA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICBoYW5kbGUyID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHRvID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cbiAgICAgICAgdGhpcy5jdWJpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlMSksIGN1cnJlbnQuYWRkKGhhbmRsZTIpLCBjdXJyZW50LmFkZCh0bykpO1xuICAgICAgfSxcbiAgICAgIHF1YWRyYXRpY0N1cnZlQnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblxuICAgICAgICB0aGlzLnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlKSwgY3VycmVudC5hZGQodG8pKTtcbiAgICAgIH0sXG4gICAgICBhcmNCeTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG4gICAgICAgICAgICBwb2ludCA9IGN1cnJlbnQuYWRkKFBvaW50LnJlYWQoYXJncykpLFxuICAgICAgICAgICAgY2xvY2t3aXNlID0gQmFzZS5waWNrKEJhc2UucGVlayhhcmdzKSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRoaXMuYXJjVG8ocG9pbnQsIGNsb2Nrd2lzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hcmNUbyhwb2ludCwgY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmdzKSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAodG9sZXJhbmNlKSB7XG4gICAgICAgIHRoaXMuc2V0Q2xvc2VkKHRydWUpO1xuICAgICAgICB0aGlzLmpvaW4odGhpcywgdG9sZXJhbmNlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCksIHtcbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbiAobWF0cml4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5oYW5kbGUgPyAnZ2V0SGFuZGxlQm91bmRzJyA6IG9wdGlvbnMuc3Ryb2tlID8gJ2dldFN0cm9rZUJvdW5kcycgOiAnZ2V0Qm91bmRzJztcbiAgICAgIHJldHVybiBQYXRoW21ldGhvZF0odGhpcy5fc2VnbWVudHMsIHRoaXMuX2Nsb3NlZCwgdGhpcywgbWF0cml4LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIGdldEJvdW5kczogZnVuY3Rpb24gKHNlZ21lbnRzLCBjbG9zZWQsIHBhdGgsIG1hdHJpeCwgb3B0aW9ucywgc3Ryb2tlUGFkZGluZykge1xuICAgICAgICB2YXIgZmlyc3QgPSBzZWdtZW50c1swXTtcbiAgICAgICAgaWYgKCFmaXJzdCkgcmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblxuICAgICAgICB2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuICAgICAgICAgICAgcHJldkNvb3JkcyA9IGZpcnN0Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSksXG4gICAgICAgICAgICBtaW4gPSBwcmV2Q29vcmRzLnNsaWNlKDAsIDIpLFxuICAgICAgICAgICAgbWF4ID0gbWluLnNsaWNlKCksXG4gICAgICAgICAgICByb290cyA9IG5ldyBBcnJheSgyKTtcblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzU2VnbWVudChzZWdtZW50KSB7XG4gICAgICAgICAgc2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIEN1cnZlLl9hZGRCb3VuZHMocHJldkNvb3Jkc1tpXSwgcHJldkNvb3Jkc1tpICsgNF0sIGNvb3Jkc1tpICsgMl0sIGNvb3Jkc1tpXSwgaSwgc3Ryb2tlUGFkZGluZyA/IHN0cm9rZVBhZGRpbmdbaV0gOiAwLCBtaW4sIG1heCwgcm9vdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0bXAgPSBwcmV2Q29vcmRzO1xuICAgICAgICAgIHByZXZDb29yZHMgPSBjb29yZHM7XG4gICAgICAgICAgY29vcmRzID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHByb2Nlc3NTZWdtZW50KHNlZ21lbnRzW2ldKTtcblxuICAgICAgICBpZiAoY2xvc2VkKSBwcm9jZXNzU2VnbWVudChmaXJzdCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG4gICAgICB9LFxuICAgICAgZ2V0U3Ryb2tlQm91bmRzOiBmdW5jdGlvbiAoc2VnbWVudHMsIGNsb3NlZCwgcGF0aCwgbWF0cml4LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHBhdGguZ2V0U3R5bGUoKSxcbiAgICAgICAgICAgIHN0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpLFxuICAgICAgICAgICAgc3Ryb2tlTWF0cml4ID0gc3Ryb2tlICYmIHBhdGguX2dldFN0cm9rZU1hdHJpeChtYXRyaXgsIG9wdGlvbnMpLFxuICAgICAgICAgICAgc3Ryb2tlUGFkZGluZyA9IHN0cm9rZSAmJiBQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVdpZHRoLCBzdHJva2VNYXRyaXgpLFxuICAgICAgICAgICAgYm91bmRzID0gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgcGF0aCwgbWF0cml4LCBvcHRpb25zLCBzdHJva2VQYWRkaW5nKTtcblxuICAgICAgICBpZiAoIXN0cm9rZSkgcmV0dXJuIGJvdW5kcztcbiAgICAgICAgdmFyIHN0cm9rZVJhZGl1cyA9IHN0cm9rZVdpZHRoIC8gMixcbiAgICAgICAgICAgIGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG4gICAgICAgICAgICBjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcbiAgICAgICAgICAgIG1pdGVyTGltaXQgPSBzdHlsZS5nZXRNaXRlckxpbWl0KCksXG4gICAgICAgICAgICBqb2luQm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgU2l6ZShzdHJva2VQYWRkaW5nKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkUG9pbnQocG9pbnQpIHtcbiAgICAgICAgICBib3VuZHMgPSBib3VuZHMuaW5jbHVkZShwb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRSb3VuZChzZWdtZW50KSB7XG4gICAgICAgICAgYm91bmRzID0gYm91bmRzLnVuaXRlKGpvaW5Cb3VuZHMuc2V0Q2VudGVyKHNlZ21lbnQuX3BvaW50LnRyYW5zZm9ybShtYXRyaXgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRKb2luKHNlZ21lbnQsIGpvaW4pIHtcbiAgICAgICAgICBpZiAoam9pbiA9PT0gJ3JvdW5kJyB8fCBzZWdtZW50LmlzU21vb3RoKCkpIHtcbiAgICAgICAgICAgIGFkZFJvdW5kKHNlZ21lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgc3Ryb2tlUmFkaXVzLCBtaXRlckxpbWl0LCBtYXRyaXgsIHN0cm9rZU1hdHJpeCwgYWRkUG9pbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZENhcChzZWdtZW50LCBjYXApIHtcbiAgICAgICAgICBpZiAoY2FwID09PSAncm91bmQnKSB7XG4gICAgICAgICAgICBhZGRSb3VuZChzZWdtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgc3Ryb2tlUmFkaXVzLCBtYXRyaXgsIHN0cm9rZU1hdHJpeCwgYWRkUG9pbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGggLSAoY2xvc2VkID8gMCA6IDEpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWRkSm9pbihzZWdtZW50c1tpXSwgam9pbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgYWRkSm9pbihzZWdtZW50c1swXSwgam9pbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZENhcChzZWdtZW50c1swXSwgY2FwKTtcbiAgICAgICAgICAgIGFkZENhcChzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSwgY2FwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfSxcbiAgICAgIF9nZXRTdHJva2VQYWRkaW5nOiBmdW5jdGlvbiAocmFkaXVzLCBtYXRyaXgpIHtcbiAgICAgICAgaWYgKCFtYXRyaXgpIHJldHVybiBbcmFkaXVzLCByYWRpdXNdO1xuICAgICAgICB2YXIgaG9yID0gbmV3IFBvaW50KHJhZGl1cywgMCkudHJhbnNmb3JtKG1hdHJpeCksXG4gICAgICAgICAgICB2ZXIgPSBuZXcgUG9pbnQoMCwgcmFkaXVzKS50cmFuc2Zvcm0obWF0cml4KSxcbiAgICAgICAgICAgIHBoaSA9IGhvci5nZXRBbmdsZUluUmFkaWFucygpLFxuICAgICAgICAgICAgYSA9IGhvci5nZXRMZW5ndGgoKSxcbiAgICAgICAgICAgIGIgPSB2ZXIuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihwaGkpLFxuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MocGhpKSxcbiAgICAgICAgICAgIHRhbiA9IE1hdGgudGFuKHBoaSksXG4gICAgICAgICAgICB0eCA9IE1hdGguYXRhbjIoYiAqIHRhbiwgYSksXG4gICAgICAgICAgICB0eSA9IE1hdGguYXRhbjIoYiwgdGFuICogYSk7XG4gICAgICAgIHJldHVybiBbTWF0aC5hYnMoYSAqIE1hdGguY29zKHR4KSAqIGNvcyArIGIgKiBNYXRoLnNpbih0eCkgKiBzaW4pLCBNYXRoLmFicyhiICogTWF0aC5zaW4odHkpICogY29zICsgYSAqIE1hdGguY29zKHR5KSAqIHNpbildO1xuICAgICAgfSxcbiAgICAgIF9hZGRCZXZlbEpvaW46IGZ1bmN0aW9uIChzZWdtZW50LCBqb2luLCByYWRpdXMsIG1pdGVyTGltaXQsIG1hdHJpeCwgc3Ryb2tlTWF0cml4LCBhZGRQb2ludCwgaXNBcmVhKSB7XG4gICAgICAgIHZhciBjdXJ2ZTIgPSBzZWdtZW50LmdldEN1cnZlKCksXG4gICAgICAgICAgICBjdXJ2ZTEgPSBjdXJ2ZTIuZ2V0UHJldmlvdXMoKSxcbiAgICAgICAgICAgIHBvaW50ID0gY3VydmUyLmdldFBvaW50MSgpLnRyYW5zZm9ybShtYXRyaXgpLFxuICAgICAgICAgICAgbm9ybWFsMSA9IGN1cnZlMS5nZXROb3JtYWxBdFRpbWUoMSkubXVsdGlwbHkocmFkaXVzKS50cmFuc2Zvcm0oc3Ryb2tlTWF0cml4KSxcbiAgICAgICAgICAgIG5vcm1hbDIgPSBjdXJ2ZTIuZ2V0Tm9ybWFsQXRUaW1lKDApLm11bHRpcGx5KHJhZGl1cykudHJhbnNmb3JtKHN0cm9rZU1hdHJpeCksXG4gICAgICAgICAgICBhbmdsZSA9IG5vcm1hbDEuZ2V0RGlyZWN0ZWRBbmdsZShub3JtYWwyKTtcblxuICAgICAgICBpZiAoYW5nbGUgPCAwIHx8IGFuZ2xlID49IDE4MCkge1xuICAgICAgICAgIG5vcm1hbDEgPSBub3JtYWwxLm5lZ2F0ZSgpO1xuICAgICAgICAgIG5vcm1hbDIgPSBub3JtYWwyLm5lZ2F0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJlYSkgYWRkUG9pbnQocG9pbnQpO1xuICAgICAgICBhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMSkpO1xuXG4gICAgICAgIGlmIChqb2luID09PSAnbWl0ZXInKSB7XG4gICAgICAgICAgdmFyIGNvcm5lciA9IG5ldyBMaW5lKHBvaW50LmFkZChub3JtYWwxKSwgbmV3IFBvaW50KC1ub3JtYWwxLnksIG5vcm1hbDEueCksIHRydWUpLmludGVyc2VjdChuZXcgTGluZShwb2ludC5hZGQobm9ybWFsMiksIG5ldyBQb2ludCgtbm9ybWFsMi55LCBub3JtYWwyLngpLCB0cnVlKSwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoY29ybmVyICYmIHBvaW50LmdldERpc3RhbmNlKGNvcm5lcikgPD0gbWl0ZXJMaW1pdCAqIHJhZGl1cykge1xuICAgICAgICAgICAgYWRkUG9pbnQoY29ybmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMikpO1xuICAgICAgfSxcbiAgICAgIF9hZGRTcXVhcmVDYXA6IGZ1bmN0aW9uIChzZWdtZW50LCBjYXAsIHJhZGl1cywgbWF0cml4LCBzdHJva2VNYXRyaXgsIGFkZFBvaW50LCBpc0FyZWEpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gc2VnbWVudC5fcG9pbnQudHJhbnNmb3JtKG1hdHJpeCksXG4gICAgICAgICAgICBsb2MgPSBzZWdtZW50LmdldExvY2F0aW9uKCksXG4gICAgICAgICAgICBub3JtYWwgPSBsb2MuZ2V0Tm9ybWFsKCkubXVsdGlwbHkobG9jLmdldFRpbWUoKSA9PT0gMCA/IHJhZGl1cyA6IC1yYWRpdXMpLnRyYW5zZm9ybShzdHJva2VNYXRyaXgpO1xuXG4gICAgICAgIGlmIChjYXAgPT09ICdzcXVhcmUnKSB7XG4gICAgICAgICAgaWYgKGlzQXJlYSkge1xuICAgICAgICAgICAgYWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG4gICAgICAgICAgICBhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9pbnQgPSBwb2ludC5hZGQobm9ybWFsLnJvdGF0ZSgtOTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcbiAgICAgICAgYWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG4gICAgICB9LFxuICAgICAgZ2V0SGFuZGxlQm91bmRzOiBmdW5jdGlvbiAoc2VnbWVudHMsIGNsb3NlZCwgcGF0aCwgbWF0cml4LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHBhdGguZ2V0U3R5bGUoKSxcbiAgICAgICAgICAgIHN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuICAgICAgICAgICAgc3Ryb2tlUGFkZGluZyxcbiAgICAgICAgICAgIGpvaW5QYWRkaW5nO1xuXG4gICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICB2YXIgc3Ryb2tlTWF0cml4ID0gcGF0aC5fZ2V0U3Ryb2tlTWF0cml4KG1hdHJpeCwgb3B0aW9ucyksXG4gICAgICAgICAgICAgIHN0cm9rZVJhZGl1cyA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyLFxuICAgICAgICAgICAgICBqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzO1xuXG4gICAgICAgICAgaWYgKHN0eWxlLmdldFN0cm9rZUpvaW4oKSA9PT0gJ21pdGVyJykgam9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcbiAgICAgICAgICBpZiAoc3R5bGUuZ2V0U3Ryb2tlQ2FwKCkgPT09ICdzcXVhcmUnKSBqb2luUmFkaXVzID0gTWF0aC5tYXgoam9pblJhZGl1cywgc3Ryb2tlUmFkaXVzICogTWF0aC5TUVJUMik7XG4gICAgICAgICAgc3Ryb2tlUGFkZGluZyA9IFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlUmFkaXVzLCBzdHJva2VNYXRyaXgpO1xuICAgICAgICAgIGpvaW5QYWRkaW5nID0gUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhqb2luUmFkaXVzLCBzdHJva2VNYXRyaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcbiAgICAgICAgICAgIHgxID0gSW5maW5pdHksXG4gICAgICAgICAgICB4MiA9IC14MSxcbiAgICAgICAgICAgIHkxID0geDEsXG4gICAgICAgICAgICB5MiA9IHgyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblxuICAgICAgICAgIHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNjsgaiArPSAyKSB7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9ICFqID8gam9pblBhZGRpbmcgOiBzdHJva2VQYWRkaW5nLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmdbMF0gOiAwLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdZID0gcGFkZGluZyA/IHBhZGRpbmdbMV0gOiAwLFxuICAgICAgICAgICAgICAgIHggPSBjb29yZHNbal0sXG4gICAgICAgICAgICAgICAgeSA9IGNvb3Jkc1tqICsgMV0sXG4gICAgICAgICAgICAgICAgeG4gPSB4IC0gcGFkZGluZ1gsXG4gICAgICAgICAgICAgICAgeHggPSB4ICsgcGFkZGluZ1gsXG4gICAgICAgICAgICAgICAgeW4gPSB5IC0gcGFkZGluZ1ksXG4gICAgICAgICAgICAgICAgeXggPSB5ICsgcGFkZGluZ1k7XG4gICAgICAgICAgICBpZiAoeG4gPCB4MSkgeDEgPSB4bjtcbiAgICAgICAgICAgIGlmICh4eCA+IHgyKSB4MiA9IHh4O1xuICAgICAgICAgICAgaWYgKHluIDwgeTEpIHkxID0geW47XG4gICAgICAgICAgICBpZiAoeXggPiB5MikgeTIgPSB5eDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFBhdGguaW5qZWN0KHtcbiAgICBzdGF0aWNzOiBuZXcgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2LFxuICAgICAgICAgIGVsbGlwc2VTZWdtZW50cyA9IFtuZXcgU2VnbWVudChbLTEsIDBdLCBbMCwga2FwcGFdLCBbMCwgLWthcHBhXSksIG5ldyBTZWdtZW50KFswLCAtMV0sIFsta2FwcGEsIDBdLCBba2FwcGEsIDBdKSwgbmV3IFNlZ21lbnQoWzEsIDBdLCBbMCwgLWthcHBhXSwgWzAsIGthcHBhXSksIG5ldyBTZWdtZW50KFswLCAxXSwgW2thcHBhLCAwXSwgWy1rYXBwYSwgMF0pXTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlUGF0aChzZWdtZW50cywgY2xvc2VkLCBhcmdzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJncyksXG4gICAgICAgICAgICBwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09IGZhbHNlICYmIEl0ZW0uTk9fSU5TRVJUKTtcblxuICAgICAgICBwYXRoLl9hZGQoc2VnbWVudHMpO1xuXG4gICAgICAgIHBhdGguX2Nsb3NlZCA9IGNsb3NlZDtcbiAgICAgICAgcmV0dXJuIHBhdGguc2V0KHByb3BzLCB7XG4gICAgICAgICAgaW5zZXJ0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVFbGxpcHNlKGNlbnRlciwgcmFkaXVzLCBhcmdzKSB7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IG5ldyBBcnJheSg0KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgIHZhciBzZWdtZW50ID0gZWxsaXBzZVNlZ21lbnRzW2ldO1xuICAgICAgICAgIHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoc2VnbWVudC5fcG9pbnQubXVsdGlwbHkocmFkaXVzKS5hZGQoY2VudGVyKSwgc2VnbWVudC5faGFuZGxlSW4ubXVsdGlwbHkocmFkaXVzKSwgc2VnbWVudC5faGFuZGxlT3V0Lm11bHRpcGx5KHJhZGl1cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBMaW5lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGgoW25ldyBTZWdtZW50KFBvaW50LnJlYWROYW1lZChhcmdzLCAnZnJvbScpKSwgbmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3MsICd0bycpKV0sIGZhbHNlLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgQ2lyY2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyksXG4gICAgICAgICAgICAgIHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRWxsaXBzZShjZW50ZXIsIG5ldyBTaXplKHJhZGl1cyksIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBSZWN0YW5nbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJncywgJ3JlY3RhbmdsZScpLFxuICAgICAgICAgICAgICByYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJywgMCwge1xuICAgICAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgYmwgPSByZWN0LmdldEJvdHRvbUxlZnQodHJ1ZSksXG4gICAgICAgICAgICAgIHRsID0gcmVjdC5nZXRUb3BMZWZ0KHRydWUpLFxuICAgICAgICAgICAgICB0ciA9IHJlY3QuZ2V0VG9wUmlnaHQodHJ1ZSksXG4gICAgICAgICAgICAgIGJyID0gcmVjdC5nZXRCb3R0b21SaWdodCh0cnVlKSxcbiAgICAgICAgICAgICAgc2VnbWVudHM7XG5cbiAgICAgICAgICBpZiAoIXJhZGl1cyB8fCByYWRpdXMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHNlZ21lbnRzID0gW25ldyBTZWdtZW50KGJsKSwgbmV3IFNlZ21lbnQodGwpLCBuZXcgU2VnbWVudCh0ciksIG5ldyBTZWdtZW50KGJyKV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IFNpemUubWluKHJhZGl1cywgcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG4gICAgICAgICAgICB2YXIgcnggPSByYWRpdXMud2lkdGgsXG4gICAgICAgICAgICAgICAgcnkgPSByYWRpdXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGh4ID0gcnggKiBrYXBwYSxcbiAgICAgICAgICAgICAgICBoeSA9IHJ5ICoga2FwcGE7XG4gICAgICAgICAgICBzZWdtZW50cyA9IFtuZXcgU2VnbWVudChibC5hZGQocngsIDApLCBudWxsLCBbLWh4LCAwXSksIG5ldyBTZWdtZW50KGJsLnN1YnRyYWN0KDAsIHJ5KSwgWzAsIGh5XSksIG5ldyBTZWdtZW50KHRsLmFkZCgwLCByeSksIG51bGwsIFswLCAtaHldKSwgbmV3IFNlZ21lbnQodGwuYWRkKHJ4LCAwKSwgWy1oeCwgMF0sIG51bGwpLCBuZXcgU2VnbWVudCh0ci5zdWJ0cmFjdChyeCwgMCksIG51bGwsIFtoeCwgMF0pLCBuZXcgU2VnbWVudCh0ci5hZGQoMCwgcnkpLCBbMCwgLWh5XSwgbnVsbCksIG5ldyBTZWdtZW50KGJyLnN1YnRyYWN0KDAsIHJ5KSwgbnVsbCwgWzAsIGh5XSksIG5ldyBTZWdtZW50KGJyLnN1YnRyYWN0KHJ4LCAwKSwgW2h4LCAwXSldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgUm91bmRSZWN0YW5nbGU6ICcjUmVjdGFuZ2xlJyxcbiAgICAgICAgRWxsaXBzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3MpO1xuXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsbGlwc2UoZWxsaXBzZS5jZW50ZXIsIGVsbGlwc2UucmFkaXVzLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3ZhbDogJyNFbGxpcHNlJyxcbiAgICAgICAgQXJjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGZyb20gPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2Zyb20nKSxcbiAgICAgICAgICAgICAgdGhyb3VnaCA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAndGhyb3VnaCcpLFxuICAgICAgICAgICAgICB0byA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAndG8nKSxcbiAgICAgICAgICAgICAgcHJvcHMgPSBCYXNlLmdldE5hbWVkKGFyZ3MpLFxuICAgICAgICAgICAgICBwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09IGZhbHNlICYmIEl0ZW0uTk9fSU5TRVJUKTtcbiAgICAgICAgICBwYXRoLm1vdmVUbyhmcm9tKTtcbiAgICAgICAgICBwYXRoLmFyY1RvKHRocm91Z2gsIHRvKTtcbiAgICAgICAgICByZXR1cm4gcGF0aC5zZXQocHJvcHMpO1xuICAgICAgICB9LFxuICAgICAgICBSZWd1bGFyUG9seWdvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpLFxuICAgICAgICAgICAgICBzaWRlcyA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdzaWRlcycpLFxuICAgICAgICAgICAgICByYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyksXG4gICAgICAgICAgICAgIHN0ZXAgPSAzNjAgLyBzaWRlcyxcbiAgICAgICAgICAgICAgdGhyZWUgPSBzaWRlcyAlIDMgPT09IDAsXG4gICAgICAgICAgICAgIHZlY3RvciA9IG5ldyBQb2ludCgwLCB0aHJlZSA/IC1yYWRpdXMgOiByYWRpdXMpLFxuICAgICAgICAgICAgICBvZmZzZXQgPSB0aHJlZSA/IC0xIDogMC41LFxuICAgICAgICAgICAgICBzZWdtZW50cyA9IG5ldyBBcnJheShzaWRlcyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZCh2ZWN0b3Iucm90YXRlKChpICsgb2Zmc2V0KSAqIHN0ZXApKSk7XG5cbiAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFN0YXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdjZW50ZXInKSxcbiAgICAgICAgICAgICAgcG9pbnRzID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3BvaW50cycpICogMixcbiAgICAgICAgICAgICAgcmFkaXVzMSA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMxJyksXG4gICAgICAgICAgICAgIHJhZGl1czIgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncmFkaXVzMicpLFxuICAgICAgICAgICAgICBzdGVwID0gMzYwIC8gcG9pbnRzLFxuICAgICAgICAgICAgICB2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgLTEpLFxuICAgICAgICAgICAgICBzZWdtZW50cyA9IG5ldyBBcnJheShwb2ludHMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHM7IGkrKykgc2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChjZW50ZXIuYWRkKHZlY3Rvci5yb3RhdGUoc3RlcCAqIGkpLm11bHRpcGx5KGkgJSAyID8gcmFkaXVzMiA6IHJhZGl1czEpKSk7XG5cbiAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSgpXG4gIH0pO1xuICB2YXIgQ29tcG91bmRQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdDb21wb3VuZFBhdGgnLFxuICAgIF9zZXJpYWxpemVGaWVsZHM6IHtcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0sXG4gICAgYmVhbnM6IHRydWUsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29tcG91bmRQYXRoKGFyZykge1xuICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgIHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcblxuICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5zZXRQYXRoRGF0YShhcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWRkQ2hpbGRyZW4oQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uIGluc2VydENoaWxkcmVuKGluZGV4LCBpdGVtcykge1xuICAgICAgdmFyIGxpc3QgPSBpdGVtcyxcbiAgICAgICAgICBmaXJzdCA9IGxpc3RbMF07XG4gICAgICBpZiAoZmlyc3QgJiYgdHlwZW9mIGZpcnN0WzBdID09PSAnbnVtYmVyJykgbGlzdCA9IFtsaXN0XTtcblxuICAgICAgZm9yICh2YXIgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGl0ZW1zICYmICEoaXRlbSBpbnN0YW5jZW9mIFBhdGgpKSBsaXN0ID0gQmFzZS5zbGljZShsaXN0KTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgIGxpc3RbaV0gPSBuZXcgUGF0aCh7XG4gICAgICAgICAgICBzZWdtZW50czogaXRlbSxcbiAgICAgICAgICAgIGluc2VydDogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSB7XG4gICAgICAgICAgbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgW2ksIDFdLmNvbmNhdChpdGVtLnJlbW92ZUNoaWxkcmVuKCkpKTtcbiAgICAgICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnNlcnRDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgaW5kZXgsIGxpc3QpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2Uob3B0aW9ucykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgcGF0aCA9IGNoaWxkcmVuW2ldLnJlZHVjZShvcHRpb25zKTtcbiAgICAgICAgaWYgKHBhdGguaXNFbXB0eSgpKSBwYXRoLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcbiAgICAgICAgcGF0aC5jb3B5QXR0cmlidXRlcyh0aGlzKTtcbiAgICAgICAgcGF0aC5pbnNlcnRBYm92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWR1Y2UuYmFzZS5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgaXNDbG9zZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIWNoaWxkcmVuW2ldLl9jbG9zZWQpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBzZXRDbG9zZWQ6IGZ1bmN0aW9uIChjbG9zZWQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjaGlsZHJlbltpXS5zZXRDbG9zZWQoY2xvc2VkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICByZXR1cm4gZmlyc3QgJiYgZmlyc3QuZ2V0Rmlyc3RTZWdtZW50KCk7XG4gICAgfSxcbiAgICBnZXRMYXN0U2VnbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhc3QgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuICAgICAgcmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0U2VnbWVudCgpO1xuICAgIH0sXG4gICAgZ2V0Q3VydmVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICBjdXJ2ZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgQmFzZS5wdXNoKGN1cnZlcywgY2hpbGRyZW5baV0uZ2V0Q3VydmVzKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VydmVzO1xuICAgIH0sXG4gICAgZ2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICByZXR1cm4gZmlyc3QgJiYgZmlyc3QuZ2V0Rmlyc3RDdXJ2ZSgpO1xuICAgIH0sXG4gICAgZ2V0TGFzdEN1cnZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG4gICAgICByZXR1cm4gbGFzdCAmJiBsYXN0LmdldExhc3RDdXJ2ZSgpO1xuICAgIH0sXG4gICAgZ2V0QXJlYTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgYXJlYSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBhcmVhICs9IGNoaWxkcmVuW2ldLmdldEFyZWEoKTtcblxuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfSxcbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBsZW5ndGggKz0gY2hpbGRyZW5baV0uZ2V0TGVuZ3RoKCk7XG5cbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfSxcbiAgICBnZXRQYXRoRGF0YTogZnVuY3Rpb24gKF9tYXRyaXgsIF9wcmVjaXNpb24pIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgIHBhdGhzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgbXggPSBjaGlsZC5fbWF0cml4O1xuICAgICAgICBwYXRocy5wdXNoKGNoaWxkLmdldFBhdGhEYXRhKF9tYXRyaXggJiYgIW14LmlzSWRlbnRpdHkoKSA/IF9tYXRyaXguYXBwZW5kZWQobXgpIDogX21hdHJpeCwgX3ByZWNpc2lvbikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aHMuam9pbignJyk7XG4gICAgfSxcbiAgICBfaGl0VGVzdENoaWxkcmVuOiBmdW5jdGlvbiBfaGl0VGVzdENoaWxkcmVuKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4KSB7XG4gICAgICByZXR1cm4gX2hpdFRlc3RDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgcG9pbnQsIG9wdGlvbnMuY2xhc3MgPT09IFBhdGggfHwgb3B0aW9ucy50eXBlID09PSAncGF0aCcgPyBvcHRpb25zIDogQmFzZS5zZXQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgZmlsbDogZmFsc2VcbiAgICAgIH0pLCB2aWV3TWF0cml4KTtcbiAgICB9LFxuICAgIF9kcmF3OiBmdW5jdGlvbiAoY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSByZXR1cm47XG4gICAgICBwYXJhbSA9IHBhcmFtLmV4dGVuZCh7XG4gICAgICAgIGRvbnRTdGFydDogdHJ1ZSxcbiAgICAgICAgZG9udEZpbmlzaDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBjaGlsZHJlbltpXS5kcmF3KGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCk7XG5cbiAgICAgIGlmICghcGFyYW0uY2xpcCkge1xuICAgICAgICB0aGlzLl9zZXRTdHlsZXMoY3R4LCBwYXJhbSwgdmlld01hdHJpeCk7XG5cbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XG5cbiAgICAgICAgaWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgIGN0eC5maWxsKHN0eWxlLmdldEZpbGxSdWxlKCkpO1xuICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2RyYXdTZWxlY3RlZDogZnVuY3Rpb24gKGN0eCwgbWF0cml4LCBzZWxlY3Rpb25JdGVtcykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgbXggPSBjaGlsZC5fbWF0cml4O1xuXG4gICAgICAgIGlmICghc2VsZWN0aW9uSXRlbXNbY2hpbGQuX2lkXSkge1xuICAgICAgICAgIGNoaWxkLl9kcmF3U2VsZWN0ZWQoY3R4LCBteC5pc0lkZW50aXR5KCkgPyBtYXRyaXggOiBtYXRyaXguYXBwZW5kZWQobXgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50UGF0aCh0aGF0LCBjaGVjaykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhhdC5fY2hpbGRyZW47XG4gICAgICBpZiAoY2hlY2sgJiYgIWNoaWxkcmVuLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG4gICAgICByZXR1cm4gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIEJhc2UuZWFjaChbJ2xpbmVUbycsICdjdWJpY0N1cnZlVG8nLCAncXVhZHJhdGljQ3VydmVUbycsICdjdXJ2ZVRvJywgJ2FyY1RvJywgJ2xpbmVCeScsICdjdWJpY0N1cnZlQnknLCAncXVhZHJhdGljQ3VydmVCeScsICdjdXJ2ZUJ5JywgJ2FyY0J5J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHRoaXNba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcGF0aFtrZXldLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0sIHtcbiAgICAgIG1vdmVUbzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMpLFxuICAgICAgICAgICAgcGF0aCA9IGN1cnJlbnQgJiYgY3VycmVudC5pc0VtcHR5KCkgPyBjdXJyZW50IDogbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuICAgICAgICBpZiAocGF0aCAhPT0gY3VycmVudCkgdGhpcy5hZGRDaGlsZChwYXRoKTtcbiAgICAgICAgcGF0aC5tb3ZlVG8uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlQnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKSxcbiAgICAgICAgICAgIGxhc3QgPSBjdXJyZW50ICYmIGN1cnJlbnQuZ2V0TGFzdFNlZ21lbnQoKSxcbiAgICAgICAgICAgIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1vdmVUbyhsYXN0ID8gcG9pbnQuYWRkKGxhc3QuX3BvaW50KSA6IHBvaW50KTtcbiAgICAgIH0sXG4gICAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uICh0b2xlcmFuY2UpIHtcbiAgICAgICAgZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSkuY2xvc2VQYXRoKHRvbGVyYW5jZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0oKSwgQmFzZS5lYWNoKFsncmV2ZXJzZScsICdmbGF0dGVuJywgJ3NpbXBsaWZ5JywgJ3Ntb290aCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpc1trZXldID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICByZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJlcyA9IGNoaWxkcmVuW2ldW2tleV0ocGFyYW0pIHx8IHJlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICB9LCB7fSkpO1xuICBQYXRoSXRlbS5pbmplY3QobmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4sXG4gICAgICAgIG1heCA9IE1hdGgubWF4LFxuICAgICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgb3BlcmF0b3JzID0ge1xuICAgICAgdW5pdGU6IHtcbiAgICAgICAgJzEnOiB0cnVlLFxuICAgICAgICAnMic6IHRydWVcbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3Q6IHtcbiAgICAgICAgJzInOiB0cnVlXG4gICAgICB9LFxuICAgICAgc3VidHJhY3Q6IHtcbiAgICAgICAgJzEnOiB0cnVlXG4gICAgICB9LFxuICAgICAgZXhjbHVkZToge1xuICAgICAgICAnMSc6IHRydWUsXG4gICAgICAgICctMSc6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0UGF0aHMocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguX2NoaWxkcmVuIHx8IFtwYXRoXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlUGF0aChwYXRoLCByZXNvbHZlKSB7XG4gICAgICB2YXIgcmVzID0gcGF0aC5jbG9uZShmYWxzZSkucmVkdWNlKHtcbiAgICAgICAgc2ltcGxpZnk6IHRydWVcbiAgICAgIH0pLnRyYW5zZm9ybShudWxsLCB0cnVlLCB0cnVlKTtcblxuICAgICAgaWYgKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gZ2V0UGF0aHMocmVzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBwYXRoID0gcGF0aHNbaV07XG5cbiAgICAgICAgICBpZiAoIXBhdGguX2Nsb3NlZCAmJiAhcGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKDFlLTEyKTtcbiAgICAgICAgICAgIHBhdGguZ2V0Rmlyc3RTZWdtZW50KCkuc2V0SGFuZGxlSW4oMCwgMCk7XG4gICAgICAgICAgICBwYXRoLmdldExhc3RTZWdtZW50KCkuc2V0SGFuZGxlT3V0KDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyA9IHJlcy5yZXNvbHZlQ3Jvc3NpbmdzKCkucmVvcmllbnQocmVzLmdldEZpbGxSdWxlKCkgPT09ICdub256ZXJvJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzdWx0KHBhdGhzLCBzaW1wbGlmeSwgcGF0aDEsIHBhdGgyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IENvbXBvdW5kUGF0aChJdGVtLk5PX0lOU0VSVCk7XG4gICAgICByZXN1bHQuYWRkQ2hpbGRyZW4ocGF0aHMsIHRydWUpO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlZHVjZSh7XG4gICAgICAgIHNpbXBsaWZ5OiBzaW1wbGlmeVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5pbnNlcnQgPT0gZmFsc2UpKSB7XG4gICAgICAgIHJlc3VsdC5pbnNlcnRBYm92ZShwYXRoMiAmJiBwYXRoMS5pc1NpYmxpbmcocGF0aDIpICYmIHBhdGgxLmdldEluZGV4KCkgPCBwYXRoMi5nZXRJbmRleCgpID8gcGF0aDIgOiBwYXRoMSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5jb3B5QXR0cmlidXRlcyhwYXRoMSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlckludGVyc2VjdGlvbihpbnRlcikge1xuICAgICAgcmV0dXJuIGludGVyLmhhc092ZXJsYXAoKSB8fCBpbnRlci5pc0Nyb3NzaW5nKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2VCb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy50cmFjZSA9PSBmYWxzZSB8fCBvcHRpb25zLnN0cm9rZSkgJiYgL14oc3VidHJhY3R8aW50ZXJzZWN0KSQvLnRlc3Qob3BlcmF0aW9uKSkgcmV0dXJuIHNwbGl0Qm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdGlvbik7XG5cbiAgICAgIHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSwgdHJ1ZSksXG4gICAgICAgICAgX3BhdGgyID0gcGF0aDIgJiYgcGF0aDEgIT09IHBhdGgyICYmIHByZXBhcmVQYXRoKHBhdGgyLCB0cnVlKSxcbiAgICAgICAgICBvcGVyYXRvciA9IG9wZXJhdG9yc1tvcGVyYXRpb25dO1xuXG4gICAgICBvcGVyYXRvcltvcGVyYXRpb25dID0gdHJ1ZTtcbiAgICAgIGlmIChfcGF0aDIgJiYgKG9wZXJhdG9yLnN1YnRyYWN0IHx8IG9wZXJhdG9yLmV4Y2x1ZGUpIF4gKF9wYXRoMi5pc0Nsb2Nrd2lzZSgpIF4gX3BhdGgxLmlzQ2xvY2t3aXNlKCkpKSBfcGF0aDIucmV2ZXJzZSgpO1xuXG4gICAgICB2YXIgY3Jvc3NpbmdzID0gZGl2aWRlTG9jYXRpb25zKEN1cnZlTG9jYXRpb24uZXhwYW5kKF9wYXRoMS5nZXRJbnRlcnNlY3Rpb25zKF9wYXRoMiwgZmlsdGVySW50ZXJzZWN0aW9uKSkpLFxuICAgICAgICAgIHBhdGhzMSA9IGdldFBhdGhzKF9wYXRoMSksXG4gICAgICAgICAgcGF0aHMyID0gX3BhdGgyICYmIGdldFBhdGhzKF9wYXRoMiksXG4gICAgICAgICAgc2VnbWVudHMgPSBbXSxcbiAgICAgICAgICBjdXJ2ZXMgPSBbXSxcbiAgICAgICAgICBwYXRocztcblxuICAgICAgZnVuY3Rpb24gY29sbGVjdFBhdGhzKHBhdGhzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpXTtcbiAgICAgICAgICBCYXNlLnB1c2goc2VnbWVudHMsIHBhdGguX3NlZ21lbnRzKTtcbiAgICAgICAgICBCYXNlLnB1c2goY3VydmVzLCBwYXRoLmdldEN1cnZlcygpKTtcbiAgICAgICAgICBwYXRoLl9vdmVybGFwc09ubHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEN1cnZlcyhpbmRpY2VzKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbmRpY2VzICYmIGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKGN1cnZlc1tpbmRpY2VzW2ldXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNyb3NzaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgY29sbGVjdFBhdGhzKHBhdGhzMSk7XG4gICAgICAgIGlmIChwYXRoczIpIGNvbGxlY3RQYXRocyhwYXRoczIpO1xuICAgICAgICB2YXIgY3VydmVzVmFsdWVzID0gbmV3IEFycmF5KGN1cnZlcy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGN1cnZlc1ZhbHVlc1tpXSA9IGN1cnZlc1tpXS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJ2ZUNvbGxpc2lvbnMgPSBDb2xsaXNpb25EZXRlY3Rpb24uZmluZEN1cnZlQm91bmRzQ29sbGlzaW9ucyhjdXJ2ZXNWYWx1ZXMsIGN1cnZlc1ZhbHVlcywgMCwgdHJ1ZSk7XG4gICAgICAgIHZhciBjdXJ2ZUNvbGxpc2lvbnNNYXAgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjdXJ2ZSA9IGN1cnZlc1tpXSxcbiAgICAgICAgICAgICAgaWQgPSBjdXJ2ZS5fcGF0aC5faWQsXG4gICAgICAgICAgICAgIG1hcCA9IGN1cnZlQ29sbGlzaW9uc01hcFtpZF0gPSBjdXJ2ZUNvbGxpc2lvbnNNYXBbaWRdIHx8IHt9O1xuICAgICAgICAgIG1hcFtjdXJ2ZS5nZXRJbmRleCgpXSA9IHtcbiAgICAgICAgICAgIGhvcjogZ2V0Q3VydmVzKGN1cnZlQ29sbGlzaW9uc1tpXS5ob3IpLFxuICAgICAgICAgICAgdmVyOiBnZXRDdXJ2ZXMoY3VydmVDb2xsaXNpb25zW2ldLnZlcilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjcm9zc2luZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgcHJvcGFnYXRlV2luZGluZyhjcm9zc2luZ3NbaV0uX3NlZ21lbnQsIF9wYXRoMSwgX3BhdGgyLCBjdXJ2ZUNvbGxpc2lvbnNNYXAsIG9wZXJhdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXSxcbiAgICAgICAgICAgICAgaW50ZXIgPSBzZWdtZW50Ll9pbnRlcnNlY3Rpb247XG5cbiAgICAgICAgICBpZiAoIXNlZ21lbnQuX3dpbmRpbmcpIHtcbiAgICAgICAgICAgIHByb3BhZ2F0ZVdpbmRpbmcoc2VnbWVudCwgX3BhdGgxLCBfcGF0aDIsIGN1cnZlQ29sbGlzaW9uc01hcCwgb3BlcmF0b3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghKGludGVyICYmIGludGVyLl9vdmVybGFwKSkgc2VnbWVudC5fcGF0aC5fb3ZlcmxhcHNPbmx5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRocyA9IHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGhzID0gcmVvcmllbnRQYXRocyhwYXRoczIgPyBwYXRoczEuY29uY2F0KHBhdGhzMikgOiBwYXRoczEuc2xpY2UoKSwgZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICByZXR1cm4gISFvcGVyYXRvclt3XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVSZXN1bHQocGF0aHMsIHRydWUsIHBhdGgxLCBwYXRoMiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3BsaXRCb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0aW9uKSB7XG4gICAgICB2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEpLFxuICAgICAgICAgIF9wYXRoMiA9IHByZXBhcmVQYXRoKHBhdGgyKSxcbiAgICAgICAgICBjcm9zc2luZ3MgPSBfcGF0aDEuZ2V0SW50ZXJzZWN0aW9ucyhfcGF0aDIsIGZpbHRlckludGVyc2VjdGlvbiksXG4gICAgICAgICAgc3VidHJhY3QgPSBvcGVyYXRpb24gPT09ICdzdWJ0cmFjdCcsXG4gICAgICAgICAgZGl2aWRlID0gb3BlcmF0aW9uID09PSAnZGl2aWRlJyxcbiAgICAgICAgICBhZGRlZCA9IHt9LFxuICAgICAgICAgIHBhdGhzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFBhdGgocGF0aCkge1xuICAgICAgICBpZiAoIWFkZGVkW3BhdGguX2lkXSAmJiAoZGl2aWRlIHx8IF9wYXRoMi5jb250YWlucyhwYXRoLmdldFBvaW50QXQocGF0aC5nZXRMZW5ndGgoKSAvIDIpKSBeIHN1YnRyYWN0KSkge1xuICAgICAgICAgIHBhdGhzLnVuc2hpZnQocGF0aCk7XG4gICAgICAgICAgcmV0dXJuIGFkZGVkW3BhdGguX2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IGNyb3NzaW5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgcGF0aCA9IGNyb3NzaW5nc1tpXS5zcGxpdCgpO1xuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgaWYgKGFkZFBhdGgocGF0aCkpIHBhdGguZ2V0Rmlyc3RTZWdtZW50KCkuc2V0SGFuZGxlSW4oMCwgMCk7XG5cbiAgICAgICAgICBfcGF0aDEuZ2V0TGFzdFNlZ21lbnQoKS5zZXRIYW5kbGVPdXQoMCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWRkUGF0aChfcGF0aDEpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlc3VsdChwYXRocywgZmFsc2UsIHBhdGgxLCBwYXRoMik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlua0ludGVyc2VjdGlvbnMoZnJvbSwgdG8pIHtcbiAgICAgIHZhciBwcmV2ID0gZnJvbTtcblxuICAgICAgd2hpbGUgKHByZXYpIHtcbiAgICAgICAgaWYgKHByZXYgPT09IHRvKSByZXR1cm47XG4gICAgICAgIHByZXYgPSBwcmV2Ll9wcmV2aW91cztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGZyb20uX25leHQgJiYgZnJvbS5fbmV4dCAhPT0gdG8pIGZyb20gPSBmcm9tLl9uZXh0O1xuXG4gICAgICBpZiAoIWZyb20uX25leHQpIHtcbiAgICAgICAgd2hpbGUgKHRvLl9wcmV2aW91cykgdG8gPSB0by5fcHJldmlvdXM7XG5cbiAgICAgICAgZnJvbS5fbmV4dCA9IHRvO1xuICAgICAgICB0by5fcHJldmlvdXMgPSBmcm9tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyQ3VydmVIYW5kbGVzKGN1cnZlcykge1xuICAgICAgZm9yICh2YXIgaSA9IGN1cnZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgY3VydmVzW2ldLmNsZWFySGFuZGxlcygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlb3JpZW50UGF0aHMocGF0aHMsIGlzSW5zaWRlLCBjbG9ja3dpc2UpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYXRocyAmJiBwYXRocy5sZW5ndGg7XG5cbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEJhc2UuZWFjaChwYXRocywgZnVuY3Rpb24gKHBhdGgsIGkpIHtcbiAgICAgICAgICB0aGlzW3BhdGguX2lkXSA9IHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgICAgIHdpbmRpbmc6IHBhdGguaXNDbG9ja3dpc2UoKSA/IDEgOiAtMSxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgc29ydGVkID0gcGF0aHMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGFicyhiLmdldEFyZWEoKSkgLSBhYnMoYS5nZXRBcmVhKCkpO1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIGZpcnN0ID0gc29ydGVkWzBdO1xuICAgICAgICB2YXIgY29sbGlzaW9ucyA9IENvbGxpc2lvbkRldGVjdGlvbi5maW5kSXRlbUJvdW5kc0NvbGxpc2lvbnMoc29ydGVkLCBudWxsLCBOdW1lcmljYWwuR0VPTUVUUklDX0VQU0lMT04pO1xuICAgICAgICBpZiAoY2xvY2t3aXNlID09IG51bGwpIGNsb2Nrd2lzZSA9IGZpcnN0LmlzQ2xvY2t3aXNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXRoMSA9IHNvcnRlZFtpXSxcbiAgICAgICAgICAgICAgZW50cnkxID0gbG9va3VwW3BhdGgxLl9pZF0sXG4gICAgICAgICAgICAgIGNvbnRhaW5lcldpbmRpbmcgPSAwLFxuICAgICAgICAgICAgICBpbmRpY2VzID0gY29sbGlzaW9uc1tpXTtcblxuICAgICAgICAgIGlmIChpbmRpY2VzKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaW5kaWNlcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICBpZiAoaW5kaWNlc1tqXSA8IGkpIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50IHx8IHBhdGgxLmdldEludGVyaW9yUG9pbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aDIgPSBzb3J0ZWRbaW5kaWNlc1tqXV07XG5cbiAgICAgICAgICAgICAgICBpZiAocGF0aDIuY29udGFpbnMocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW50cnkyID0gbG9va3VwW3BhdGgyLl9pZF07XG4gICAgICAgICAgICAgICAgICBjb250YWluZXJXaW5kaW5nID0gZW50cnkyLndpbmRpbmc7XG4gICAgICAgICAgICAgICAgICBlbnRyeTEud2luZGluZyArPSBjb250YWluZXJXaW5kaW5nO1xuICAgICAgICAgICAgICAgICAgZW50cnkxLmNvbnRhaW5lciA9IGVudHJ5Mi5leGNsdWRlID8gZW50cnkyLmNvbnRhaW5lciA6IHBhdGgyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzSW5zaWRlKGVudHJ5MS53aW5kaW5nKSA9PT0gaXNJbnNpZGUoY29udGFpbmVyV2luZGluZykpIHtcbiAgICAgICAgICAgIGVudHJ5MS5leGNsdWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhdGhzW2VudHJ5MS5pbmRleF0gPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZW50cnkxLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIHBhdGgxLnNldENsb2Nrd2lzZShjb250YWluZXIgPyAhY29udGFpbmVyLmlzQ2xvY2t3aXNlKCkgOiBjbG9ja3dpc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGl2aWRlTG9jYXRpb25zKGxvY2F0aW9ucywgaW5jbHVkZSwgY2xlYXJMYXRlcikge1xuICAgICAgdmFyIHJlc3VsdHMgPSBpbmNsdWRlICYmIFtdLFxuICAgICAgICAgIHRNaW4gPSAxZS04LFxuICAgICAgICAgIHRNYXggPSAxIC0gdE1pbixcbiAgICAgICAgICBjbGVhckhhbmRsZXMgPSBmYWxzZSxcbiAgICAgICAgICBjbGVhckN1cnZlcyA9IGNsZWFyTGF0ZXIgfHwgW10sXG4gICAgICAgICAgY2xlYXJMb29rdXAgPSBjbGVhckxhdGVyICYmIHt9LFxuICAgICAgICAgIHJlbm9ybWFsaXplTG9jcyxcbiAgICAgICAgICBwcmV2Q3VydmUsXG4gICAgICAgICAgcHJldlRpbWU7XG5cbiAgICAgIGZ1bmN0aW9uIGdldElkKGN1cnZlKSB7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5fcGF0aC5faWQgKyAnLicgKyBjdXJ2ZS5fc2VnbWVudDEuX2luZGV4O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gKGNsZWFyTGF0ZXIgJiYgY2xlYXJMYXRlci5sZW5ndGgpIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGN1cnZlID0gY2xlYXJMYXRlcltpXTtcbiAgICAgICAgaWYgKGN1cnZlLl9wYXRoKSBjbGVhckxvb2t1cFtnZXRJZChjdXJ2ZSldID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IGxvY2F0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbG9jID0gbG9jYXRpb25zW2ldLFxuICAgICAgICAgICAgdGltZSA9IGxvYy5fdGltZSxcbiAgICAgICAgICAgIG9yaWdUaW1lID0gdGltZSxcbiAgICAgICAgICAgIGV4Y2x1ZGUgPSBpbmNsdWRlICYmICFpbmNsdWRlKGxvYyksXG4gICAgICAgICAgICBjdXJ2ZSA9IGxvYy5fY3VydmUsXG4gICAgICAgICAgICBzZWdtZW50O1xuXG4gICAgICAgIGlmIChjdXJ2ZSkge1xuICAgICAgICAgIGlmIChjdXJ2ZSAhPT0gcHJldkN1cnZlKSB7XG4gICAgICAgICAgICBjbGVhckhhbmRsZXMgPSAhY3VydmUuaGFzSGFuZGxlcygpIHx8IGNsZWFyTG9va3VwICYmIGNsZWFyTG9va3VwW2dldElkKGN1cnZlKV07XG4gICAgICAgICAgICByZW5vcm1hbGl6ZUxvY3MgPSBbXTtcbiAgICAgICAgICAgIHByZXZUaW1lID0gbnVsbDtcbiAgICAgICAgICAgIHByZXZDdXJ2ZSA9IGN1cnZlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldlRpbWUgPj0gdE1pbikge1xuICAgICAgICAgICAgdGltZSAvPSBwcmV2VGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhjbHVkZSkge1xuICAgICAgICAgIGlmIChyZW5vcm1hbGl6ZUxvY3MpIHJlbm9ybWFsaXplTG9jcy5wdXNoKGxvYyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgIHJlc3VsdHMudW5zaGlmdChsb2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldlRpbWUgPSBvcmlnVGltZTtcblxuICAgICAgICBpZiAodGltZSA8IHRNaW4pIHtcbiAgICAgICAgICBzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQxO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWUgPiB0TWF4KSB7XG4gICAgICAgICAgc2VnbWVudCA9IGN1cnZlLl9zZWdtZW50MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3Q3VydmUgPSBjdXJ2ZS5kaXZpZGVBdFRpbWUodGltZSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKGNsZWFySGFuZGxlcykgY2xlYXJDdXJ2ZXMucHVzaChjdXJ2ZSwgbmV3Q3VydmUpO1xuICAgICAgICAgIHNlZ21lbnQgPSBuZXdDdXJ2ZS5fc2VnbWVudDE7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gcmVub3JtYWxpemVMb2NzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICB2YXIgbCA9IHJlbm9ybWFsaXplTG9jc1tqXTtcbiAgICAgICAgICAgIGwuX3RpbWUgPSAobC5fdGltZSAtIHRpbWUpIC8gKDEgLSB0aW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb2MuX3NldFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICAgICAgdmFyIGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uLFxuICAgICAgICAgICAgZGVzdCA9IGxvYy5faW50ZXJzZWN0aW9uO1xuXG4gICAgICAgIGlmIChpbnRlcikge1xuICAgICAgICAgIGxpbmtJbnRlcnNlY3Rpb25zKGludGVyLCBkZXN0KTtcbiAgICAgICAgICB2YXIgb3RoZXIgPSBpbnRlcjtcblxuICAgICAgICAgIHdoaWxlIChvdGhlcikge1xuICAgICAgICAgICAgbGlua0ludGVyc2VjdGlvbnMob3RoZXIuX2ludGVyc2VjdGlvbiwgaW50ZXIpO1xuICAgICAgICAgICAgb3RoZXIgPSBvdGhlci5fbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VnbWVudC5faW50ZXJzZWN0aW9uID0gZGVzdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWNsZWFyTGF0ZXIpIGNsZWFyQ3VydmVIYW5kbGVzKGNsZWFyQ3VydmVzKTtcbiAgICAgIHJldHVybiByZXN1bHRzIHx8IGxvY2F0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaW5kaW5nKHBvaW50LCBjdXJ2ZXMsIGRpciwgY2xvc2VkLCBkb250RmxpcCkge1xuICAgICAgdmFyIGN1cnZlc0xpc3QgPSBBcnJheS5pc0FycmF5KGN1cnZlcykgPyBjdXJ2ZXMgOiBjdXJ2ZXNbZGlyID8gJ2hvcicgOiAndmVyJ107XG4gICAgICB2YXIgaWEgPSBkaXIgPyAxIDogMCxcbiAgICAgICAgICBpbyA9IGlhIF4gMSxcbiAgICAgICAgICBwdiA9IFtwb2ludC54LCBwb2ludC55XSxcbiAgICAgICAgICBwYSA9IHB2W2lhXSxcbiAgICAgICAgICBwbyA9IHB2W2lvXSxcbiAgICAgICAgICB3aW5kaW5nRXBzaWxvbiA9IDFlLTksXG4gICAgICAgICAgcXVhbGl0eUVwc2lsb24gPSAxZS02LFxuICAgICAgICAgIHBhTCA9IHBhIC0gd2luZGluZ0Vwc2lsb24sXG4gICAgICAgICAgcGFSID0gcGEgKyB3aW5kaW5nRXBzaWxvbixcbiAgICAgICAgICB3aW5kaW5nTCA9IDAsXG4gICAgICAgICAgd2luZGluZ1IgPSAwLFxuICAgICAgICAgIHBhdGhXaW5kaW5nTCA9IDAsXG4gICAgICAgICAgcGF0aFdpbmRpbmdSID0gMCxcbiAgICAgICAgICBvblBhdGggPSBmYWxzZSxcbiAgICAgICAgICBvbkFueVBhdGggPSBmYWxzZSxcbiAgICAgICAgICBxdWFsaXR5ID0gMSxcbiAgICAgICAgICByb290cyA9IFtdLFxuICAgICAgICAgIHZQcmV2LFxuICAgICAgICAgIHZDbG9zZTtcblxuICAgICAgZnVuY3Rpb24gYWRkV2luZGluZyh2KSB7XG4gICAgICAgIHZhciBvMCA9IHZbaW8gKyAwXSxcbiAgICAgICAgICAgIG8zID0gdltpbyArIDZdO1xuXG4gICAgICAgIGlmIChwbyA8IG1pbihvMCwgbzMpIHx8IHBvID4gbWF4KG8wLCBvMykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYTAgPSB2W2lhICsgMF0sXG4gICAgICAgICAgICBhMSA9IHZbaWEgKyAyXSxcbiAgICAgICAgICAgIGEyID0gdltpYSArIDRdLFxuICAgICAgICAgICAgYTMgPSB2W2lhICsgNl07XG5cbiAgICAgICAgaWYgKG8wID09PSBvMykge1xuICAgICAgICAgIGlmIChhMCA8IHBhUiAmJiBhMyA+IHBhTCB8fCBhMyA8IHBhUiAmJiBhMCA+IHBhTCkge1xuICAgICAgICAgICAgb25QYXRoID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IHBvID09PSBvMCA/IDAgOiBwbyA9PT0gbzMgPyAxIDogcGFMID4gbWF4KGEwLCBhMSwgYTIsIGEzKSB8fCBwYVIgPCBtaW4oYTAsIGExLCBhMiwgYTMpID8gMSA6IEN1cnZlLnNvbHZlQ3ViaWModiwgaW8sIHBvLCByb290cywgMCwgMSkgPiAwID8gcm9vdHNbMF0gOiAxLFxuICAgICAgICAgICAgYSA9IHQgPT09IDAgPyBhMCA6IHQgPT09IDEgPyBhMyA6IEN1cnZlLmdldFBvaW50KHYsIHQpW2RpciA/ICd5JyA6ICd4J10sXG4gICAgICAgICAgICB3aW5kaW5nID0gbzAgPiBvMyA/IDEgOiAtMSxcbiAgICAgICAgICAgIHdpbmRpbmdQcmV2ID0gdlByZXZbaW9dID4gdlByZXZbaW8gKyA2XSA/IDEgOiAtMSxcbiAgICAgICAgICAgIGEzUHJldiA9IHZQcmV2W2lhICsgNl07XG5cbiAgICAgICAgaWYgKHBvICE9PSBvMCkge1xuICAgICAgICAgIGlmIChhIDwgcGFMKSB7XG4gICAgICAgICAgICBwYXRoV2luZGluZ0wgKz0gd2luZGluZztcbiAgICAgICAgICB9IGVsc2UgaWYgKGEgPiBwYVIpIHtcbiAgICAgICAgICAgIHBhdGhXaW5kaW5nUiArPSB3aW5kaW5nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvblBhdGggPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhID4gcGEgLSBxdWFsaXR5RXBzaWxvbiAmJiBhIDwgcGEgKyBxdWFsaXR5RXBzaWxvbikgcXVhbGl0eSAvPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3aW5kaW5nICE9PSB3aW5kaW5nUHJldikge1xuICAgICAgICAgICAgaWYgKGEwIDwgcGFMKSB7XG4gICAgICAgICAgICAgIHBhdGhXaW5kaW5nTCArPSB3aW5kaW5nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhMCA+IHBhUikge1xuICAgICAgICAgICAgICBwYXRoV2luZGluZ1IgKz0gd2luZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGEwICE9IGEzUHJldikge1xuICAgICAgICAgICAgaWYgKGEzUHJldiA8IHBhUiAmJiBhID4gcGFSKSB7XG4gICAgICAgICAgICAgIHBhdGhXaW5kaW5nUiArPSB3aW5kaW5nO1xuICAgICAgICAgICAgICBvblBhdGggPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhM1ByZXYgPiBwYUwgJiYgYSA8IHBhTCkge1xuICAgICAgICAgICAgICBwYXRoV2luZGluZ0wgKz0gd2luZGluZztcbiAgICAgICAgICAgICAgb25QYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBxdWFsaXR5IC89IDQ7XG4gICAgICAgIH1cblxuICAgICAgICB2UHJldiA9IHY7XG4gICAgICAgIHJldHVybiAhZG9udEZsaXAgJiYgYSA+IHBhTCAmJiBhIDwgcGFSICYmIEN1cnZlLmdldFRhbmdlbnQodiwgdClbZGlyID8gJ3gnIDogJ3knXSA9PT0gMCAmJiBnZXRXaW5kaW5nKHBvaW50LCBjdXJ2ZXMsICFkaXIsIGNsb3NlZCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUN1cnZlKHYpIHtcbiAgICAgICAgdmFyIG8wID0gdltpbyArIDBdLFxuICAgICAgICAgICAgbzEgPSB2W2lvICsgMl0sXG4gICAgICAgICAgICBvMiA9IHZbaW8gKyA0XSxcbiAgICAgICAgICAgIG8zID0gdltpbyArIDZdO1xuXG4gICAgICAgIGlmIChwbyA8PSBtYXgobzAsIG8xLCBvMiwgbzMpICYmIHBvID49IG1pbihvMCwgbzEsIG8yLCBvMykpIHtcbiAgICAgICAgICB2YXIgYTAgPSB2W2lhICsgMF0sXG4gICAgICAgICAgICAgIGExID0gdltpYSArIDJdLFxuICAgICAgICAgICAgICBhMiA9IHZbaWEgKyA0XSxcbiAgICAgICAgICAgICAgYTMgPSB2W2lhICsgNl0sXG4gICAgICAgICAgICAgIG1vbm9DdXJ2ZXMgPSBwYUwgPiBtYXgoYTAsIGExLCBhMiwgYTMpIHx8IHBhUiA8IG1pbihhMCwgYTEsIGEyLCBhMykgPyBbdl0gOiBDdXJ2ZS5nZXRNb25vQ3VydmVzKHYsIGRpciksXG4gICAgICAgICAgICAgIHJlcztcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbW9ub0N1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZXMgPSBhZGRXaW5kaW5nKG1vbm9DdXJ2ZXNbaV0pKSByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlc0xpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IGN1cnZlc0xpc3RbaV0sXG4gICAgICAgICAgICBwYXRoID0gY3VydmUuX3BhdGgsXG4gICAgICAgICAgICB2ID0gY3VydmUuZ2V0VmFsdWVzKCksXG4gICAgICAgICAgICByZXM7XG5cbiAgICAgICAgaWYgKCFpIHx8IGN1cnZlc0xpc3RbaSAtIDFdLl9wYXRoICE9PSBwYXRoKSB7XG4gICAgICAgICAgdlByZXYgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKCFwYXRoLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHZDbG9zZSA9IEN1cnZlLmdldFZhbHVlcyhwYXRoLmdldExhc3RDdXJ2ZSgpLmdldFNlZ21lbnQyKCksIGN1cnZlLmdldFNlZ21lbnQxKCksIG51bGwsICFjbG9zZWQpO1xuXG4gICAgICAgICAgICBpZiAodkNsb3NlW2lvXSAhPT0gdkNsb3NlW2lvICsgNl0pIHtcbiAgICAgICAgICAgICAgdlByZXYgPSB2Q2xvc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF2UHJldikge1xuICAgICAgICAgICAgdlByZXYgPSB2O1xuICAgICAgICAgICAgdmFyIHByZXYgPSBwYXRoLmdldExhc3RDdXJ2ZSgpO1xuXG4gICAgICAgICAgICB3aGlsZSAocHJldiAmJiBwcmV2ICE9PSBjdXJ2ZSkge1xuICAgICAgICAgICAgICB2YXIgdjIgPSBwcmV2LmdldFZhbHVlcygpO1xuXG4gICAgICAgICAgICAgIGlmICh2Mltpb10gIT09IHYyW2lvICsgNl0pIHtcbiAgICAgICAgICAgICAgICB2UHJldiA9IHYyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcHJldiA9IHByZXYuZ2V0UHJldmlvdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzID0gaGFuZGxlQ3VydmUodikpIHJldHVybiByZXM7XG5cbiAgICAgICAgaWYgKGkgKyAxID09PSBsIHx8IGN1cnZlc0xpc3RbaSArIDFdLl9wYXRoICE9PSBwYXRoKSB7XG4gICAgICAgICAgaWYgKHZDbG9zZSAmJiAocmVzID0gaGFuZGxlQ3VydmUodkNsb3NlKSkpIHJldHVybiByZXM7XG5cbiAgICAgICAgICBpZiAob25QYXRoICYmICFwYXRoV2luZGluZ0wgJiYgIXBhdGhXaW5kaW5nUikge1xuICAgICAgICAgICAgcGF0aFdpbmRpbmdMID0gcGF0aFdpbmRpbmdSID0gcGF0aC5pc0Nsb2Nrd2lzZShjbG9zZWQpIF4gZGlyID8gMSA6IC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdpbmRpbmdMICs9IHBhdGhXaW5kaW5nTDtcbiAgICAgICAgICB3aW5kaW5nUiArPSBwYXRoV2luZGluZ1I7XG4gICAgICAgICAgcGF0aFdpbmRpbmdMID0gcGF0aFdpbmRpbmdSID0gMDtcblxuICAgICAgICAgIGlmIChvblBhdGgpIHtcbiAgICAgICAgICAgIG9uQW55UGF0aCA9IHRydWU7XG4gICAgICAgICAgICBvblBhdGggPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2Q2xvc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdpbmRpbmdMID0gYWJzKHdpbmRpbmdMKTtcbiAgICAgIHdpbmRpbmdSID0gYWJzKHdpbmRpbmdSKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpbmRpbmc6IG1heCh3aW5kaW5nTCwgd2luZGluZ1IpLFxuICAgICAgICB3aW5kaW5nTDogd2luZGluZ0wsXG4gICAgICAgIHdpbmRpbmdSOiB3aW5kaW5nUixcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eSxcbiAgICAgICAgb25QYXRoOiBvbkFueVBhdGhcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlV2luZGluZyhzZWdtZW50LCBwYXRoMSwgcGF0aDIsIGN1cnZlQ29sbGlzaW9uc01hcCwgb3BlcmF0b3IpIHtcbiAgICAgIHZhciBjaGFpbiA9IFtdLFxuICAgICAgICAgIHN0YXJ0ID0gc2VnbWVudCxcbiAgICAgICAgICB0b3RhbExlbmd0aCA9IDAsXG4gICAgICAgICAgd2luZGluZztcblxuICAgICAgZG8ge1xuICAgICAgICB2YXIgY3VydmUgPSBzZWdtZW50LmdldEN1cnZlKCk7XG5cbiAgICAgICAgaWYgKGN1cnZlKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xuICAgICAgICAgIGNoYWluLnB1c2goe1xuICAgICAgICAgICAgc2VnbWVudDogc2VnbWVudCxcbiAgICAgICAgICAgIGN1cnZlOiBjdXJ2ZSxcbiAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdG90YWxMZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuICAgICAgfSB3aGlsZSAoc2VnbWVudCAmJiAhc2VnbWVudC5faW50ZXJzZWN0aW9uICYmIHNlZ21lbnQgIT09IHN0YXJ0KTtcblxuICAgICAgdmFyIG9mZnNldHMgPSBbMC41LCAwLjI1LCAwLjc1XSxcbiAgICAgICAgICB3aW5kaW5nID0ge1xuICAgICAgICB3aW5kaW5nOiAwLFxuICAgICAgICBxdWFsaXR5OiAtMVxuICAgICAgfSxcbiAgICAgICAgICB0TWluID0gMWUtMyxcbiAgICAgICAgICB0TWF4ID0gMSAtIHRNaW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2Zmc2V0cy5sZW5ndGggJiYgd2luZGluZy5xdWFsaXR5IDwgMC41OyBpKyspIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRvdGFsTGVuZ3RoICogb2Zmc2V0c1tpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IGNoYWluLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgIHZhciBlbnRyeSA9IGNoYWluW2pdLFxuICAgICAgICAgICAgICBjdXJ2ZUxlbmd0aCA9IGVudHJ5Lmxlbmd0aDtcblxuICAgICAgICAgIGlmIChsZW5ndGggPD0gY3VydmVMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjdXJ2ZSA9IGVudHJ5LmN1cnZlLFxuICAgICAgICAgICAgICAgIHBhdGggPSBjdXJ2ZS5fcGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoLl9wYXJlbnQsXG4gICAgICAgICAgICAgICAgb3BlcmFuZCA9IHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCA/IHBhcmVudCA6IHBhdGgsXG4gICAgICAgICAgICAgICAgdCA9IE51bWVyaWNhbC5jbGFtcChjdXJ2ZS5nZXRUaW1lQXQobGVuZ3RoKSwgdE1pbiwgdE1heCksXG4gICAgICAgICAgICAgICAgcHQgPSBjdXJ2ZS5nZXRQb2ludEF0VGltZSh0KSxcbiAgICAgICAgICAgICAgICBkaXIgPSBhYnMoY3VydmUuZ2V0VGFuZ2VudEF0VGltZSh0KS55KSA8IE1hdGguU1FSVDFfMjtcbiAgICAgICAgICAgIHZhciB3aW5kID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKG9wZXJhdG9yLnN1YnRyYWN0ICYmIHBhdGgyKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlclBhdGggPSBvcGVyYW5kID09PSBwYXRoMSA/IHBhdGgyIDogcGF0aDEsXG4gICAgICAgICAgICAgICAgICBwYXRoV2luZGluZyA9IG90aGVyUGF0aC5fZ2V0V2luZGluZyhwdCwgZGlyLCB0cnVlKTtcblxuICAgICAgICAgICAgICBpZiAob3BlcmFuZCA9PT0gcGF0aDEgJiYgcGF0aFdpbmRpbmcud2luZGluZyB8fCBvcGVyYW5kID09PSBwYXRoMiAmJiAhcGF0aFdpbmRpbmcud2luZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoV2luZGluZy5xdWFsaXR5IDwgMSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHdpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIHF1YWxpdHk6IDFcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbmQgPSB3aW5kIHx8IGdldFdpbmRpbmcocHQsIGN1cnZlQ29sbGlzaW9uc01hcFtwYXRoLl9pZF1bY3VydmUuZ2V0SW5kZXgoKV0sIGRpciwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAod2luZC5xdWFsaXR5ID4gd2luZGluZy5xdWFsaXR5KSB3aW5kaW5nID0gd2luZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxlbmd0aCAtPSBjdXJ2ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gY2hhaW4ubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgY2hhaW5bal0uc2VnbWVudC5fd2luZGluZyA9IHdpbmRpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2VQYXRocyhzZWdtZW50cywgb3BlcmF0b3IpIHtcbiAgICAgIHZhciBwYXRocyA9IFtdLFxuICAgICAgICAgIHN0YXJ0cztcblxuICAgICAgZnVuY3Rpb24gaXNWYWxpZChzZWcpIHtcbiAgICAgICAgdmFyIHdpbmRpbmc7XG4gICAgICAgIHJldHVybiAhIShzZWcgJiYgIXNlZy5fdmlzaXRlZCAmJiAoIW9wZXJhdG9yIHx8IG9wZXJhdG9yWyh3aW5kaW5nID0gc2VnLl93aW5kaW5nIHx8IHt9KS53aW5kaW5nXSAmJiAhKG9wZXJhdG9yLnVuaXRlICYmIHdpbmRpbmcud2luZGluZyA9PT0gMiAmJiB3aW5kaW5nLndpbmRpbmdMICYmIHdpbmRpbmcud2luZGluZ1IpKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzU3RhcnQoc2VnKSB7XG4gICAgICAgIGlmIChzZWcpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzZWcgPT09IHN0YXJ0c1tpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB2aXNpdFBhdGgocGF0aCkge1xuICAgICAgICB2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHNlZ21lbnRzW2ldLl92aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRDcm9zc2luZ1NlZ21lbnRzKHNlZ21lbnQsIGNvbGxlY3RTdGFydHMpIHtcbiAgICAgICAgdmFyIGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uLFxuICAgICAgICAgICAgc3RhcnQgPSBpbnRlcixcbiAgICAgICAgICAgIGNyb3NzaW5ncyA9IFtdO1xuICAgICAgICBpZiAoY29sbGVjdFN0YXJ0cykgc3RhcnRzID0gW3NlZ21lbnRdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbGxlY3QoaW50ZXIsIGVuZCkge1xuICAgICAgICAgIHdoaWxlIChpbnRlciAmJiBpbnRlciAhPT0gZW5kKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBpbnRlci5fc2VnbWVudCxcbiAgICAgICAgICAgICAgICBwYXRoID0gb3RoZXIgJiYgb3RoZXIuX3BhdGg7XG5cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgIHZhciBuZXh0ID0gb3RoZXIuZ2V0TmV4dCgpIHx8IHBhdGguZ2V0Rmlyc3RTZWdtZW50KCksXG4gICAgICAgICAgICAgICAgICBuZXh0SW50ZXIgPSBuZXh0Ll9pbnRlcnNlY3Rpb247XG5cbiAgICAgICAgICAgICAgaWYgKG90aGVyICE9PSBzZWdtZW50ICYmIChpc1N0YXJ0KG90aGVyKSB8fCBpc1N0YXJ0KG5leHQpIHx8IG5leHQgJiYgaXNWYWxpZChvdGhlcikgJiYgKGlzVmFsaWQobmV4dCkgfHwgbmV4dEludGVyICYmIGlzVmFsaWQobmV4dEludGVyLl9zZWdtZW50KSkpKSB7XG4gICAgICAgICAgICAgICAgY3Jvc3NpbmdzLnB1c2gob3RoZXIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNvbGxlY3RTdGFydHMpIHN0YXJ0cy5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW50ZXIgPSBpbnRlci5fbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW50ZXIpIHtcbiAgICAgICAgICBjb2xsZWN0KGludGVyKTtcblxuICAgICAgICAgIHdoaWxlIChpbnRlciAmJiBpbnRlci5fcHJldmlvdXMpIGludGVyID0gaW50ZXIuX3ByZXZpb3VzO1xuXG4gICAgICAgICAgY29sbGVjdChpbnRlciwgc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyb3NzaW5ncztcbiAgICAgIH1cblxuICAgICAgc2VnbWVudHMuc29ydChmdW5jdGlvbiAoc2VnMSwgc2VnMikge1xuICAgICAgICB2YXIgaW50ZXIxID0gc2VnMS5faW50ZXJzZWN0aW9uLFxuICAgICAgICAgICAgaW50ZXIyID0gc2VnMi5faW50ZXJzZWN0aW9uLFxuICAgICAgICAgICAgb3ZlcjEgPSAhIShpbnRlcjEgJiYgaW50ZXIxLl9vdmVybGFwKSxcbiAgICAgICAgICAgIG92ZXIyID0gISEoaW50ZXIyICYmIGludGVyMi5fb3ZlcmxhcCksXG4gICAgICAgICAgICBwYXRoMSA9IHNlZzEuX3BhdGgsXG4gICAgICAgICAgICBwYXRoMiA9IHNlZzIuX3BhdGg7XG4gICAgICAgIHJldHVybiBvdmVyMSBeIG92ZXIyID8gb3ZlcjEgPyAxIDogLTEgOiAhaW50ZXIxIF4gIWludGVyMiA/IGludGVyMSA/IDEgOiAtMSA6IHBhdGgxICE9PSBwYXRoMiA/IHBhdGgxLl9pZCAtIHBhdGgyLl9pZCA6IHNlZzEuX2luZGV4IC0gc2VnMi5faW5kZXg7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2ldLFxuICAgICAgICAgICAgdmFsaWQgPSBpc1ZhbGlkKHNlZyksXG4gICAgICAgICAgICBwYXRoID0gbnVsbCxcbiAgICAgICAgICAgIGZpbmlzaGVkID0gZmFsc2UsXG4gICAgICAgICAgICBjbG9zZWQgPSB0cnVlLFxuICAgICAgICAgICAgYnJhbmNoZXMgPSBbXSxcbiAgICAgICAgICAgIGJyYW5jaCxcbiAgICAgICAgICAgIHZpc2l0ZWQsXG4gICAgICAgICAgICBoYW5kbGVJbjtcblxuICAgICAgICBpZiAodmFsaWQgJiYgc2VnLl9wYXRoLl9vdmVybGFwc09ubHkpIHtcbiAgICAgICAgICB2YXIgcGF0aDEgPSBzZWcuX3BhdGgsXG4gICAgICAgICAgICAgIHBhdGgyID0gc2VnLl9pbnRlcnNlY3Rpb24uX3NlZ21lbnQuX3BhdGg7XG5cbiAgICAgICAgICBpZiAocGF0aDEuY29tcGFyZShwYXRoMikpIHtcbiAgICAgICAgICAgIGlmIChwYXRoMS5nZXRBcmVhKCkpIHBhdGhzLnB1c2gocGF0aDEuY2xvbmUoZmFsc2UpKTtcbiAgICAgICAgICAgIHZpc2l0UGF0aChwYXRoMSk7XG4gICAgICAgICAgICB2aXNpdFBhdGgocGF0aDIpO1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAodmFsaWQpIHtcbiAgICAgICAgICB2YXIgZmlyc3QgPSAhcGF0aCxcbiAgICAgICAgICAgICAgY3Jvc3NpbmdzID0gZ2V0Q3Jvc3NpbmdTZWdtZW50cyhzZWcsIGZpcnN0KSxcbiAgICAgICAgICAgICAgb3RoZXIgPSBjcm9zc2luZ3Muc2hpZnQoKSxcbiAgICAgICAgICAgICAgZmluaXNoZWQgPSAhZmlyc3QgJiYgKGlzU3RhcnQoc2VnKSB8fCBpc1N0YXJ0KG90aGVyKSksXG4gICAgICAgICAgICAgIGNyb3NzID0gIWZpbmlzaGVkICYmIG90aGVyO1xuXG4gICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICBwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuICAgICAgICAgICAgYnJhbmNoID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgIGlmIChzZWcuaXNGaXJzdCgpIHx8IHNlZy5pc0xhc3QoKSkgY2xvc2VkID0gc2VnLl9wYXRoLl9jbG9zZWQ7XG4gICAgICAgICAgICBzZWcuX3Zpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNyb3NzICYmIGJyYW5jaCkge1xuICAgICAgICAgICAgYnJhbmNoZXMucHVzaChicmFuY2gpO1xuICAgICAgICAgICAgYnJhbmNoID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWJyYW5jaCkge1xuICAgICAgICAgICAgaWYgKGNyb3NzKSBjcm9zc2luZ3MucHVzaChzZWcpO1xuICAgICAgICAgICAgYnJhbmNoID0ge1xuICAgICAgICAgICAgICBzdGFydDogcGF0aC5fc2VnbWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICBjcm9zc2luZ3M6IGNyb3NzaW5ncyxcbiAgICAgICAgICAgICAgdmlzaXRlZDogdmlzaXRlZCA9IFtdLFxuICAgICAgICAgICAgICBoYW5kbGVJbjogaGFuZGxlSW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNyb3NzKSBzZWcgPSBvdGhlcjtcblxuICAgICAgICAgIGlmICghaXNWYWxpZChzZWcpKSB7XG4gICAgICAgICAgICBwYXRoLnJlbW92ZVNlZ21lbnRzKGJyYW5jaC5zdGFydCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gdmlzaXRlZC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgdmlzaXRlZFtqXS5fdmlzaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aXNpdGVkLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgc2VnID0gYnJhbmNoICYmIGJyYW5jaC5jcm9zc2luZ3Muc2hpZnQoKTtcblxuICAgICAgICAgICAgICBpZiAoIXNlZyB8fCAhc2VnLl9wYXRoKSB7XG4gICAgICAgICAgICAgICAgc2VnID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmFuY2ggPSBicmFuY2hlcy5wb3AoKTtcblxuICAgICAgICAgICAgICAgIGlmIChicmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgIHZpc2l0ZWQgPSBicmFuY2gudmlzaXRlZDtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZUluID0gYnJhbmNoLmhhbmRsZUluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoYnJhbmNoICYmICFpc1ZhbGlkKHNlZykpO1xuXG4gICAgICAgICAgICBpZiAoIXNlZykgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5leHQgPSBzZWcuZ2V0TmV4dCgpO1xuICAgICAgICAgIHBhdGguYWRkKG5ldyBTZWdtZW50KHNlZy5fcG9pbnQsIGhhbmRsZUluLCBuZXh0ICYmIHNlZy5faGFuZGxlT3V0KSk7XG4gICAgICAgICAgc2VnLl92aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICB2aXNpdGVkLnB1c2goc2VnKTtcbiAgICAgICAgICBzZWcgPSBuZXh0IHx8IHNlZy5fcGF0aC5nZXRGaXJzdFNlZ21lbnQoKTtcbiAgICAgICAgICBoYW5kbGVJbiA9IG5leHQgJiYgbmV4dC5faGFuZGxlSW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICBwYXRoLmdldEZpcnN0U2VnbWVudCgpLnNldEhhbmRsZUluKGhhbmRsZUluKTtcbiAgICAgICAgICAgIHBhdGguc2V0Q2xvc2VkKGNsb3NlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGguZ2V0QXJlYSgpICE9PSAwKSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIF9nZXRXaW5kaW5nOiBmdW5jdGlvbiAocG9pbnQsIGRpciwgY2xvc2VkKSB7XG4gICAgICAgIHJldHVybiBnZXRXaW5kaW5nKHBvaW50LCB0aGlzLmdldEN1cnZlcygpLCBkaXIsIGNsb3NlZCk7XG4gICAgICB9LFxuICAgICAgdW5pdGU6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0cmFjZUJvb2xlYW4odGhpcywgcGF0aCwgJ3VuaXRlJywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHJhY2VCb29sZWFuKHRoaXMsIHBhdGgsICdpbnRlcnNlY3QnLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlQm9vbGVhbih0aGlzLCBwYXRoLCAnc3VidHJhY3QnLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBleGNsdWRlOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHJhY2VCb29sZWFuKHRoaXMsIHBhdGgsICdleGNsdWRlJywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgZGl2aWRlOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucyAmJiAob3B0aW9ucy50cmFjZSA9PSBmYWxzZSB8fCBvcHRpb25zLnN0cm9rZSkgPyBzcGxpdEJvb2xlYW4odGhpcywgcGF0aCwgJ2RpdmlkZScpIDogY3JlYXRlUmVzdWx0KFt0aGlzLnN1YnRyYWN0KHBhdGgsIG9wdGlvbnMpLCB0aGlzLmludGVyc2VjdChwYXRoLCBvcHRpb25zKV0sIHRydWUsIHRoaXMsIHBhdGgsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIHJlc29sdmVDcm9zc2luZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgICBwYXRocyA9IGNoaWxkcmVuIHx8IFt0aGlzXTtcblxuICAgICAgICBmdW5jdGlvbiBoYXNPdmVybGFwKHNlZywgcGF0aCkge1xuICAgICAgICAgIHZhciBpbnRlciA9IHNlZyAmJiBzZWcuX2ludGVyc2VjdGlvbjtcbiAgICAgICAgICByZXR1cm4gaW50ZXIgJiYgaW50ZXIuX292ZXJsYXAgJiYgaW50ZXIuX3BhdGggPT09IHBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFzT3ZlcmxhcHMgPSBmYWxzZSxcbiAgICAgICAgICAgIGhhc0Nyb3NzaW5ncyA9IGZhbHNlLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9ucyA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9ucyhudWxsLCBmdW5jdGlvbiAoaW50ZXIpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXIuaGFzT3ZlcmxhcCgpICYmIChoYXNPdmVybGFwcyA9IHRydWUpIHx8IGludGVyLmlzQ3Jvc3NpbmcoKSAmJiAoaGFzQ3Jvc3NpbmdzID0gdHJ1ZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAgICAgY2xlYXJDdXJ2ZXMgPSBoYXNPdmVybGFwcyAmJiBoYXNDcm9zc2luZ3MgJiYgW107XG4gICAgICAgIGludGVyc2VjdGlvbnMgPSBDdXJ2ZUxvY2F0aW9uLmV4cGFuZChpbnRlcnNlY3Rpb25zKTtcblxuICAgICAgICBpZiAoaGFzT3ZlcmxhcHMpIHtcbiAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSBkaXZpZGVMb2NhdGlvbnMoaW50ZXJzZWN0aW9ucywgZnVuY3Rpb24gKGludGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXIuaGFzT3ZlcmxhcCgpO1xuICAgICAgICAgIH0sIGNsZWFyQ3VydmVzKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSBvdmVybGFwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSBvdmVybGFwc1tpXSxcbiAgICAgICAgICAgICAgICBwYXRoID0gb3ZlcmxhcC5fcGF0aCxcbiAgICAgICAgICAgICAgICBzZWcgPSBvdmVybGFwLl9zZWdtZW50LFxuICAgICAgICAgICAgICAgIHByZXYgPSBzZWcuZ2V0UHJldmlvdXMoKSxcbiAgICAgICAgICAgICAgICBuZXh0ID0gc2VnLmdldE5leHQoKTtcblxuICAgICAgICAgICAgaWYgKGhhc092ZXJsYXAocHJldiwgcGF0aCkgJiYgaGFzT3ZlcmxhcChuZXh0LCBwYXRoKSkge1xuICAgICAgICAgICAgICBzZWcucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgcHJldi5faGFuZGxlT3V0Ll9zZXQoMCwgMCk7XG5cbiAgICAgICAgICAgICAgbmV4dC5faGFuZGxlSW4uX3NldCgwLCAwKTtcblxuICAgICAgICAgICAgICBpZiAocHJldiAhPT0gc2VnICYmICFwcmV2LmdldEN1cnZlKCkuaGFzTGVuZ3RoKCkpIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9oYW5kbGVJbi5zZXQocHJldi5faGFuZGxlSW4pO1xuXG4gICAgICAgICAgICAgICAgcHJldi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDcm9zc2luZ3MpIHtcbiAgICAgICAgICBkaXZpZGVMb2NhdGlvbnMoaW50ZXJzZWN0aW9ucywgaGFzT3ZlcmxhcHMgJiYgZnVuY3Rpb24gKGludGVyKSB7XG4gICAgICAgICAgICB2YXIgY3VydmUxID0gaW50ZXIuZ2V0Q3VydmUoKSxcbiAgICAgICAgICAgICAgICBzZWcxID0gaW50ZXIuZ2V0U2VnbWVudCgpLFxuICAgICAgICAgICAgICAgIG90aGVyID0gaW50ZXIuX2ludGVyc2VjdGlvbixcbiAgICAgICAgICAgICAgICBjdXJ2ZTIgPSBvdGhlci5fY3VydmUsXG4gICAgICAgICAgICAgICAgc2VnMiA9IG90aGVyLl9zZWdtZW50O1xuICAgICAgICAgICAgaWYgKGN1cnZlMSAmJiBjdXJ2ZTIgJiYgY3VydmUxLl9wYXRoICYmIGN1cnZlMi5fcGF0aCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoc2VnMSkgc2VnMS5faW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzZWcyKSBzZWcyLl9pbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICAgIH0sIGNsZWFyQ3VydmVzKTtcbiAgICAgICAgICBpZiAoY2xlYXJDdXJ2ZXMpIGNsZWFyQ3VydmVIYW5kbGVzKGNsZWFyQ3VydmVzKTtcbiAgICAgICAgICBwYXRocyA9IHRyYWNlUGF0aHMoQmFzZS5lYWNoKHBhdGhzLCBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgQmFzZS5wdXNoKHRoaXMsIHBhdGguX3NlZ21lbnRzKTtcbiAgICAgICAgICB9LCBbXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAocGF0aHMgIT09IGNoaWxkcmVuKSB0aGlzLnNldENoaWxkcmVuKHBhdGhzKTtcbiAgICAgICAgICBpdGVtID0gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IDEgJiYgIWNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKHBhdGhzWzBdICE9PSB0aGlzKSB0aGlzLnNldFNlZ21lbnRzKHBhdGhzWzBdLnJlbW92ZVNlZ21lbnRzKCkpO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgaXRlbSA9IG5ldyBDb21wb3VuZFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuICAgICAgICAgIGl0ZW0uYWRkQ2hpbGRyZW4ocGF0aHMpO1xuICAgICAgICAgIGl0ZW0gPSBpdGVtLnJlZHVjZSgpO1xuICAgICAgICAgIGl0ZW0uY29weUF0dHJpYnV0ZXModGhpcyk7XG4gICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aChpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSxcbiAgICAgIHJlb3JpZW50OiBmdW5jdGlvbiAobm9uWmVybywgY2xvY2t3aXNlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnNldENoaWxkcmVuKHJlb3JpZW50UGF0aHModGhpcy5yZW1vdmVDaGlsZHJlbigpLCBmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgcmV0dXJuICEhKG5vblplcm8gPyB3IDogdyAmIDEpO1xuICAgICAgICAgIH0sIGNsb2Nrd2lzZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5zZXRDbG9ja3dpc2UoY2xvY2t3aXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGdldEludGVyaW9yUG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG4gICAgICAgICAgICBwb2ludCA9IGJvdW5kcy5nZXRDZW50ZXIodHJ1ZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5zKHBvaW50KSkge1xuICAgICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuICAgICAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICAgICAgaW50ZXJjZXB0cyA9IFtdLFxuICAgICAgICAgICAgICByb290cyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGN1cnZlc1tpXS5nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAgICAgICBvMCA9IHZbMV0sXG4gICAgICAgICAgICAgICAgbzEgPSB2WzNdLFxuICAgICAgICAgICAgICAgIG8yID0gdls1XSxcbiAgICAgICAgICAgICAgICBvMyA9IHZbN107XG5cbiAgICAgICAgICAgIGlmICh5ID49IG1pbihvMCwgbzEsIG8yLCBvMykgJiYgeSA8PSBtYXgobzAsIG8xLCBvMiwgbzMpKSB7XG4gICAgICAgICAgICAgIHZhciBtb25vQ3VydmVzID0gQ3VydmUuZ2V0TW9ub0N1cnZlcyh2KTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IG1vbm9DdXJ2ZXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG12ID0gbW9ub0N1cnZlc1tqXSxcbiAgICAgICAgICAgICAgICAgICAgbW8wID0gbXZbMV0sXG4gICAgICAgICAgICAgICAgICAgIG1vMyA9IG12WzddO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vMCAhPT0gbW8zICYmICh5ID49IG1vMCAmJiB5IDw9IG1vMyB8fCB5ID49IG1vMyAmJiB5IDw9IG1vMCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB4ID0geSA9PT0gbW8wID8gbXZbMF0gOiB5ID09PSBtbzMgPyBtdls2XSA6IEN1cnZlLnNvbHZlQ3ViaWMobXYsIDEsIHksIHJvb3RzLCAwLCAxKSA9PT0gMSA/IEN1cnZlLmdldFBvaW50KG12LCByb290c1swXSkueCA6IChtdlswXSArIG12WzZdKSAvIDI7XG4gICAgICAgICAgICAgICAgICBpbnRlcmNlcHRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGludGVyY2VwdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaW50ZXJjZXB0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9pbnQueCA9IChpbnRlcmNlcHRzWzBdICsgaW50ZXJjZXB0c1sxXSkgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgIH1cbiAgICB9O1xuICB9KCkpO1xuICB2YXIgUGF0aEZsYXR0ZW5lciA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdQYXRoRmxhdHRlbmVyJyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAocGF0aCwgZmxhdG5lc3MsIG1heFJlY3Vyc2lvbiwgaWdub3JlU3RyYWlnaHQsIG1hdHJpeCkge1xuICAgICAgdmFyIGN1cnZlcyA9IFtdLFxuICAgICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgICBtaW5TcGFuID0gMSAvIChtYXhSZWN1cnNpb24gfHwgMzIpLFxuICAgICAgICAgIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG4gICAgICAgICAgc2VnbWVudDEgPSBzZWdtZW50c1swXSxcbiAgICAgICAgICBzZWdtZW50MjtcblxuICAgICAgZnVuY3Rpb24gYWRkQ3VydmUoc2VnbWVudDEsIHNlZ21lbnQyKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IEN1cnZlLmdldFZhbHVlcyhzZWdtZW50MSwgc2VnbWVudDIsIG1hdHJpeCk7XG4gICAgICAgIGN1cnZlcy5wdXNoKGN1cnZlKTtcbiAgICAgICAgY29tcHV0ZVBhcnRzKGN1cnZlLCBzZWdtZW50MS5faW5kZXgsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb21wdXRlUGFydHMoY3VydmUsIGluZGV4LCB0MSwgdDIpIHtcbiAgICAgICAgaWYgKHQyIC0gdDEgPiBtaW5TcGFuICYmICEoaWdub3JlU3RyYWlnaHQgJiYgQ3VydmUuaXNTdHJhaWdodChjdXJ2ZSkpICYmICFDdXJ2ZS5pc0ZsYXRFbm91Z2goY3VydmUsIGZsYXRuZXNzIHx8IDAuMjUpKSB7XG4gICAgICAgICAgdmFyIGhhbHZlcyA9IEN1cnZlLnN1YmRpdmlkZShjdXJ2ZSwgMC41KSxcbiAgICAgICAgICAgICAgdE1pZCA9ICh0MSArIHQyKSAvIDI7XG4gICAgICAgICAgY29tcHV0ZVBhcnRzKGhhbHZlc1swXSwgaW5kZXgsIHQxLCB0TWlkKTtcbiAgICAgICAgICBjb21wdXRlUGFydHMoaGFsdmVzWzFdLCBpbmRleCwgdE1pZCwgdDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkeCA9IGN1cnZlWzZdIC0gY3VydmVbMF0sXG4gICAgICAgICAgICAgIGR5ID0gY3VydmVbN10gLSBjdXJ2ZVsxXSxcbiAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSBkaXN0O1xuICAgICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICAgIG9mZnNldDogbGVuZ3RoLFxuICAgICAgICAgICAgICBjdXJ2ZTogY3VydmUsXG4gICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgdGltZTogdDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzZWdtZW50MiA9IHNlZ21lbnRzW2ldO1xuICAgICAgICBhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpO1xuICAgICAgICBzZWdtZW50MSA9IHNlZ21lbnQyO1xuICAgICAgfVxuXG4gICAgICBpZiAocGF0aC5fY2xvc2VkKSBhZGRDdXJ2ZShzZWdtZW50MiB8fCBzZWdtZW50MSwgc2VnbWVudHNbMF0pO1xuICAgICAgdGhpcy5jdXJ2ZXMgPSBjdXJ2ZXM7XG4gICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH0sXG4gICAgX2dldDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgdmFyIHBhcnRzID0gdGhpcy5wYXJ0cyxcbiAgICAgICAgICBsZW5ndGggPSBwYXJ0cy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBqID0gdGhpcy5pbmRleDtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpID0gajtcbiAgICAgICAgaWYgKCFqIHx8IHBhcnRzWy0tal0ub2Zmc2V0IDwgb2Zmc2V0KSBicmVhaztcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICAgIGlmIChwYXJ0Lm9mZnNldCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgICB2YXIgcHJldiA9IHBhcnRzW2kgLSAxXSxcbiAgICAgICAgICAgICAgcHJldlRpbWUgPSBwcmV2ICYmIHByZXYuaW5kZXggPT09IHBhcnQuaW5kZXggPyBwcmV2LnRpbWUgOiAwLFxuICAgICAgICAgICAgICBwcmV2T2Zmc2V0ID0gcHJldiA/IHByZXYub2Zmc2V0IDogMDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IHBhcnQuaW5kZXgsXG4gICAgICAgICAgICB0aW1lOiBwcmV2VGltZSArIChwYXJ0LnRpbWUgLSBwcmV2VGltZSkgKiAob2Zmc2V0IC0gcHJldk9mZnNldCkgLyAocGFydC5vZmZzZXQgLSBwcmV2T2Zmc2V0KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXg6IHBhcnRzW2xlbmd0aCAtIDFdLmluZGV4LFxuICAgICAgICB0aW1lOiAxXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhd1BhcnQ6IGZ1bmN0aW9uIChjdHgsIGZyb20sIHRvKSB7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLl9nZXQoZnJvbSksXG4gICAgICAgICAgZW5kID0gdGhpcy5fZ2V0KHRvKTtcblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0LmluZGV4LCBsID0gZW5kLmluZGV4OyBpIDw9IGw7IGkrKykge1xuICAgICAgICB2YXIgY3VydmUgPSBDdXJ2ZS5nZXRQYXJ0KHRoaXMuY3VydmVzW2ldLCBpID09PSBzdGFydC5pbmRleCA/IHN0YXJ0LnRpbWUgOiAwLCBpID09PSBlbmQuaW5kZXggPyBlbmQudGltZSA6IDEpO1xuICAgICAgICBpZiAoaSA9PT0gc3RhcnQuaW5kZXgpIGN0eC5tb3ZlVG8oY3VydmVbMF0sIGN1cnZlWzFdKTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8uYXBwbHkoY3R4LCBjdXJ2ZS5zbGljZSgyKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBCYXNlLmVhY2goQ3VydmUuX2V2YWx1YXRlTWV0aG9kcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIHZhciBwYXJhbSA9IHRoaXMuX2dldChvZmZzZXQpO1xuXG4gICAgICByZXR1cm4gQ3VydmVbbmFtZV0odGhpcy5jdXJ2ZXNbcGFyYW0uaW5kZXhdLCBwYXJhbS50aW1lKTtcbiAgICB9O1xuICB9LCB7fSkpO1xuICB2YXIgUGF0aEZpdHRlciA9IEJhc2UuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzID0gW10sXG4gICAgICAgICAgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcbiAgICAgICAgICBjbG9zZWQgPSBwYXRoLl9jbG9zZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBwcmV2LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHNlZ21lbnRzW2ldLnBvaW50O1xuXG4gICAgICAgIGlmICghcHJldiB8fCAhcHJldi5lcXVhbHMocG9pbnQpKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2gocHJldiA9IHBvaW50LmNsb25lKCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgcG9pbnRzLnVuc2hpZnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHBvaW50cy5wdXNoKHBvaW50c1sxXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xvc2VkID0gY2xvc2VkO1xuICAgIH0sXG4gICAgZml0OiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICAgIHNlZ21lbnRzID0gbnVsbDtcblxuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VnbWVudHMgPSBbbmV3IFNlZ21lbnQocG9pbnRzWzBdKV07XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLmZpdEN1YmljKHNlZ21lbnRzLCBlcnJvciwgMCwgbGVuZ3RoIC0gMSwgcG9pbnRzWzFdLnN1YnRyYWN0KHBvaW50c1swXSksIHBvaW50c1tsZW5ndGggLSAyXS5zdWJ0cmFjdChwb2ludHNbbGVuZ3RoIC0gMV0pKTtcblxuICAgICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgc2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgfSxcbiAgICBmaXRDdWJpYzogZnVuY3Rpb24gKHNlZ21lbnRzLCBlcnJvciwgZmlyc3QsIGxhc3QsIHRhbjEsIHRhbjIpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuICAgICAgaWYgKGxhc3QgLSBmaXJzdCA9PT0gMSkge1xuICAgICAgICB2YXIgcHQxID0gcG9pbnRzW2ZpcnN0XSxcbiAgICAgICAgICAgIHB0MiA9IHBvaW50c1tsYXN0XSxcbiAgICAgICAgICAgIGRpc3QgPSBwdDEuZ2V0RGlzdGFuY2UocHQyKSAvIDM7XG4gICAgICAgIHRoaXMuYWRkQ3VydmUoc2VnbWVudHMsIFtwdDEsIHB0MS5hZGQodGFuMS5ub3JtYWxpemUoZGlzdCkpLCBwdDIuYWRkKHRhbjIubm9ybWFsaXplKGRpc3QpKSwgcHQyXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHVQcmltZSA9IHRoaXMuY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QpLFxuICAgICAgICAgIG1heEVycm9yID0gTWF0aC5tYXgoZXJyb3IsIGVycm9yICogZXJyb3IpLFxuICAgICAgICAgIHNwbGl0LFxuICAgICAgICAgIHBhcmFtZXRlcnNJbk9yZGVyID0gdHJ1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gNDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2VuZXJhdGVCZXppZXIoZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMik7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLmZpbmRNYXhFcnJvcihmaXJzdCwgbGFzdCwgY3VydmUsIHVQcmltZSk7XG5cbiAgICAgICAgaWYgKG1heC5lcnJvciA8IGVycm9yICYmIHBhcmFtZXRlcnNJbk9yZGVyKSB7XG4gICAgICAgICAgdGhpcy5hZGRDdXJ2ZShzZWdtZW50cywgY3VydmUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwbGl0ID0gbWF4LmluZGV4O1xuICAgICAgICBpZiAobWF4LmVycm9yID49IG1heEVycm9yKSBicmVhaztcbiAgICAgICAgcGFyYW1ldGVyc0luT3JkZXIgPSB0aGlzLnJlcGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0LCB1UHJpbWUsIGN1cnZlKTtcbiAgICAgICAgbWF4RXJyb3IgPSBtYXguZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHZhciB0YW5DZW50ZXIgPSBwb2ludHNbc3BsaXQgLSAxXS5zdWJ0cmFjdChwb2ludHNbc3BsaXQgKyAxXSk7XG4gICAgICB0aGlzLmZpdEN1YmljKHNlZ21lbnRzLCBlcnJvciwgZmlyc3QsIHNwbGl0LCB0YW4xLCB0YW5DZW50ZXIpO1xuICAgICAgdGhpcy5maXRDdWJpYyhzZWdtZW50cywgZXJyb3IsIHNwbGl0LCBsYXN0LCB0YW5DZW50ZXIubmVnYXRlKCksIHRhbjIpO1xuICAgIH0sXG4gICAgYWRkQ3VydmU6IGZ1bmN0aW9uIChzZWdtZW50cywgY3VydmUpIHtcbiAgICAgIHZhciBwcmV2ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICBwcmV2LnNldEhhbmRsZU91dChjdXJ2ZVsxXS5zdWJ0cmFjdChjdXJ2ZVswXSkpO1xuICAgICAgc2VnbWVudHMucHVzaChuZXcgU2VnbWVudChjdXJ2ZVszXSwgY3VydmVbMl0uc3VidHJhY3QoY3VydmVbM10pKSk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZUJlemllcjogZnVuY3Rpb24gKGZpcnN0LCBsYXN0LCB1UHJpbWUsIHRhbjEsIHRhbjIpIHtcbiAgICAgIHZhciBlcHNpbG9uID0gMWUtMTIsXG4gICAgICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgcG9pbnRzID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgcHQxID0gcG9pbnRzW2ZpcnN0XSxcbiAgICAgICAgICBwdDIgPSBwb2ludHNbbGFzdF0sXG4gICAgICAgICAgQyA9IFtbMCwgMF0sIFswLCAwXV0sXG4gICAgICAgICAgWCA9IFswLCAwXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsYXN0IC0gZmlyc3QgKyAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciB1ID0gdVByaW1lW2ldLFxuICAgICAgICAgICAgdCA9IDEgLSB1LFxuICAgICAgICAgICAgYiA9IDMgKiB1ICogdCxcbiAgICAgICAgICAgIGIwID0gdCAqIHQgKiB0LFxuICAgICAgICAgICAgYjEgPSBiICogdCxcbiAgICAgICAgICAgIGIyID0gYiAqIHUsXG4gICAgICAgICAgICBiMyA9IHUgKiB1ICogdSxcbiAgICAgICAgICAgIGExID0gdGFuMS5ub3JtYWxpemUoYjEpLFxuICAgICAgICAgICAgYTIgPSB0YW4yLm5vcm1hbGl6ZShiMiksXG4gICAgICAgICAgICB0bXAgPSBwb2ludHNbZmlyc3QgKyBpXS5zdWJ0cmFjdChwdDEubXVsdGlwbHkoYjAgKyBiMSkpLnN1YnRyYWN0KHB0Mi5tdWx0aXBseShiMiArIGIzKSk7XG4gICAgICAgIENbMF1bMF0gKz0gYTEuZG90KGExKTtcbiAgICAgICAgQ1swXVsxXSArPSBhMS5kb3QoYTIpO1xuICAgICAgICBDWzFdWzBdID0gQ1swXVsxXTtcbiAgICAgICAgQ1sxXVsxXSArPSBhMi5kb3QoYTIpO1xuICAgICAgICBYWzBdICs9IGExLmRvdCh0bXApO1xuICAgICAgICBYWzFdICs9IGEyLmRvdCh0bXApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGV0QzBDMSA9IENbMF1bMF0gKiBDWzFdWzFdIC0gQ1sxXVswXSAqIENbMF1bMV0sXG4gICAgICAgICAgYWxwaGExLFxuICAgICAgICAgIGFscGhhMjtcblxuICAgICAgaWYgKGFicyhkZXRDMEMxKSA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIGRldEMwWCA9IENbMF1bMF0gKiBYWzFdIC0gQ1sxXVswXSAqIFhbMF0sXG4gICAgICAgICAgICBkZXRYQzEgPSBYWzBdICogQ1sxXVsxXSAtIFhbMV0gKiBDWzBdWzFdO1xuICAgICAgICBhbHBoYTEgPSBkZXRYQzEgLyBkZXRDMEMxO1xuICAgICAgICBhbHBoYTIgPSBkZXRDMFggLyBkZXRDMEMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGMwID0gQ1swXVswXSArIENbMF1bMV0sXG4gICAgICAgICAgICBjMSA9IENbMV1bMF0gKyBDWzFdWzFdO1xuICAgICAgICBhbHBoYTEgPSBhbHBoYTIgPSBhYnMoYzApID4gZXBzaWxvbiA/IFhbMF0gLyBjMCA6IGFicyhjMSkgPiBlcHNpbG9uID8gWFsxXSAvIGMxIDogMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ0xlbmd0aCA9IHB0Mi5nZXREaXN0YW5jZShwdDEpLFxuICAgICAgICAgIGVwcyA9IGVwc2lsb24gKiBzZWdMZW5ndGgsXG4gICAgICAgICAgaGFuZGxlMSxcbiAgICAgICAgICBoYW5kbGUyO1xuXG4gICAgICBpZiAoYWxwaGExIDwgZXBzIHx8IGFscGhhMiA8IGVwcykge1xuICAgICAgICBhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxpbmUgPSBwdDIuc3VidHJhY3QocHQxKTtcbiAgICAgICAgaGFuZGxlMSA9IHRhbjEubm9ybWFsaXplKGFscGhhMSk7XG4gICAgICAgIGhhbmRsZTIgPSB0YW4yLm5vcm1hbGl6ZShhbHBoYTIpO1xuXG4gICAgICAgIGlmIChoYW5kbGUxLmRvdChsaW5lKSAtIGhhbmRsZTIuZG90KGxpbmUpID4gc2VnTGVuZ3RoICogc2VnTGVuZ3RoKSB7XG4gICAgICAgICAgYWxwaGExID0gYWxwaGEyID0gc2VnTGVuZ3RoIC8gMztcbiAgICAgICAgICBoYW5kbGUxID0gaGFuZGxlMiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtwdDEsIHB0MS5hZGQoaGFuZGxlMSB8fCB0YW4xLm5vcm1hbGl6ZShhbHBoYTEpKSwgcHQyLmFkZChoYW5kbGUyIHx8IHRhbjIubm9ybWFsaXplKGFscGhhMikpLCBwdDJdO1xuICAgIH0sXG4gICAgcmVwYXJhbWV0ZXJpemU6IGZ1bmN0aW9uIChmaXJzdCwgbGFzdCwgdSwgY3VydmUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBmaXJzdDsgaSA8PSBsYXN0OyBpKyspIHtcbiAgICAgICAgdVtpIC0gZmlyc3RdID0gdGhpcy5maW5kUm9vdChjdXJ2ZSwgdGhpcy5wb2ludHNbaV0sIHVbaSAtIGZpcnN0XSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gdS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHVbaV0gPD0gdVtpIC0gMV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBmaW5kUm9vdDogZnVuY3Rpb24gKGN1cnZlLCBwb2ludCwgdSkge1xuICAgICAgdmFyIGN1cnZlMSA9IFtdLFxuICAgICAgICAgIGN1cnZlMiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAyOyBpKyspIHtcbiAgICAgICAgY3VydmUxW2ldID0gY3VydmVbaSArIDFdLnN1YnRyYWN0KGN1cnZlW2ldKS5tdWx0aXBseSgzKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgIGN1cnZlMltpXSA9IGN1cnZlMVtpICsgMV0uc3VidHJhY3QoY3VydmUxW2ldKS5tdWx0aXBseSgyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHB0ID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdSksXG4gICAgICAgICAgcHQxID0gdGhpcy5ldmFsdWF0ZSgyLCBjdXJ2ZTEsIHUpLFxuICAgICAgICAgIHB0MiA9IHRoaXMuZXZhbHVhdGUoMSwgY3VydmUyLCB1KSxcbiAgICAgICAgICBkaWZmID0gcHQuc3VidHJhY3QocG9pbnQpLFxuICAgICAgICAgIGRmID0gcHQxLmRvdChwdDEpICsgZGlmZi5kb3QocHQyKTtcbiAgICAgIHJldHVybiBOdW1lcmljYWwuaXNNYWNoaW5lWmVybyhkZikgPyB1IDogdSAtIGRpZmYuZG90KHB0MSkgLyBkZjtcbiAgICB9LFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAoZGVncmVlLCBjdXJ2ZSwgdCkge1xuICAgICAgdmFyIHRtcCA9IGN1cnZlLnNsaWNlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGRlZ3JlZTsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGRlZ3JlZSAtIGk7IGorKykge1xuICAgICAgICAgIHRtcFtqXSA9IHRtcFtqXS5tdWx0aXBseSgxIC0gdCkuYWRkKHRtcFtqICsgMV0ubXVsdGlwbHkodCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0bXBbMF07XG4gICAgfSxcbiAgICBjaG9yZExlbmd0aFBhcmFtZXRlcml6ZTogZnVuY3Rpb24gKGZpcnN0LCBsYXN0KSB7XG4gICAgICB2YXIgdSA9IFswXTtcblxuICAgICAgZm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0OyBpKyspIHtcbiAgICAgICAgdVtpIC0gZmlyc3RdID0gdVtpIC0gZmlyc3QgLSAxXSArIHRoaXMucG9pbnRzW2ldLmdldERpc3RhbmNlKHRoaXMucG9pbnRzW2kgLSAxXSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBtID0gbGFzdCAtIGZpcnN0OyBpIDw9IG07IGkrKykge1xuICAgICAgICB1W2ldIC89IHVbbV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1O1xuICAgIH0sXG4gICAgZmluZE1heEVycm9yOiBmdW5jdGlvbiAoZmlyc3QsIGxhc3QsIGN1cnZlLCB1KSB7XG4gICAgICB2YXIgaW5kZXggPSBNYXRoLmZsb29yKChsYXN0IC0gZmlyc3QgKyAxKSAvIDIpLFxuICAgICAgICAgIG1heERpc3QgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIHZhciBQID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdVtpIC0gZmlyc3RdKTtcbiAgICAgICAgdmFyIHYgPSBQLnN1YnRyYWN0KHRoaXMucG9pbnRzW2ldKTtcbiAgICAgICAgdmFyIGRpc3QgPSB2LnggKiB2LnggKyB2LnkgKiB2Lnk7XG5cbiAgICAgICAgaWYgKGRpc3QgPj0gbWF4RGlzdCkge1xuICAgICAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogbWF4RGlzdCxcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHZhciBUZXh0SXRlbSA9IEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdUZXh0SXRlbScsXG4gICAgX2FwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuICAgIF9zZXJpYWxpemVGaWVsZHM6IHtcbiAgICAgIGNvbnRlbnQ6IG51bGxcbiAgICB9LFxuICAgIF9ib3VuZHNPcHRpb25zOiB7XG4gICAgICBzdHJva2U6IGZhbHNlLFxuICAgICAgaGFuZGxlOiBmYWxzZVxuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gVGV4dEl0ZW0oYXJnKSB7XG4gICAgICB0aGlzLl9jb250ZW50ID0gJyc7XG4gICAgICB0aGlzLl9saW5lcyA9IFtdO1xuICAgICAgdmFyIGhhc1Byb3BzID0gYXJnICYmIEJhc2UuaXNQbGFpbk9iamVjdChhcmcpICYmIGFyZy54ID09PSB1bmRlZmluZWQgJiYgYXJnLnkgPT09IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5faW5pdGlhbGl6ZShoYXNQcm9wcyAmJiBhcmcsICFoYXNQcm9wcyAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgX2VxdWFsczogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50ID09PSBpdGVtLl9jb250ZW50O1xuICAgIH0sXG4gICAgY29weUNvbnRlbnQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc2V0Q29udGVudChzb3VyY2UuX2NvbnRlbnQpO1xuICAgIH0sXG4gICAgZ2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfSxcbiAgICBzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgdGhpcy5fY29udGVudCA9ICcnICsgY29udGVudDtcbiAgICAgIHRoaXMuX2xpbmVzID0gdGhpcy5fY29udGVudC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvbWcpO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKDUyMSk7XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2NvbnRlbnQ7XG4gICAgfSxcbiAgICBnZXRDaGFyYWN0ZXJTdHlsZTogJyNnZXRTdHlsZScsXG4gICAgc2V0Q2hhcmFjdGVyU3R5bGU6ICcjc2V0U3R5bGUnLFxuICAgIGdldFBhcmFncmFwaFN0eWxlOiAnI2dldFN0eWxlJyxcbiAgICBzZXRQYXJhZ3JhcGhTdHlsZTogJyNzZXRTdHlsZSdcbiAgfSk7XG4gIHZhciBQb2ludFRleHQgPSBUZXh0SXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1BvaW50VGV4dCcsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnRUZXh0KCkge1xuICAgICAgVGV4dEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKTtcblxuICAgICAgcmV0dXJuIG5ldyBMaW5rZWRQb2ludChwb2ludC54LCBwb2ludC55LCB0aGlzLCAnc2V0UG9pbnQnKTtcbiAgICB9LFxuICAgIHNldFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnRyYW5zbGF0ZShwb2ludC5zdWJ0cmFjdCh0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKSkpO1xuICAgIH0sXG4gICAgX2RyYXc6IGZ1bmN0aW9uIChjdHgsIHBhcmFtLCB2aWV3TWF0cml4KSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbnRlbnQpIHJldHVybjtcblxuICAgICAgdGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXG4gICAgICB2YXIgbGluZXMgPSB0aGlzLl9saW5lcyxcbiAgICAgICAgICBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuICAgICAgICAgIGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG4gICAgICAgICAgaGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG4gICAgICAgICAgbGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcbiAgICAgICAgICBzaGFkb3dDb2xvciA9IGN0eC5zaGFkb3dDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gc3R5bGUuZ2V0Rm9udFN0eWxlKCk7XG4gICAgICBjdHgudGV4dEFsaWduID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvcjtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgICBpZiAoaGFzRmlsbCkge1xuICAgICAgICAgIGN0eC5maWxsVGV4dChsaW5lLCAwLCAwKTtcbiAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU3Ryb2tlKSBjdHguc3Ryb2tlVGV4dChsaW5lLCAwLCAwKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBsZWFkaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uIChtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuICAgICAgICAgIGxpbmVzID0gdGhpcy5fbGluZXMsXG4gICAgICAgICAgbnVtTGluZXMgPSBsaW5lcy5sZW5ndGgsXG4gICAgICAgICAganVzdGlmaWNhdGlvbiA9IHN0eWxlLmdldEp1c3RpZmljYXRpb24oKSxcbiAgICAgICAgICBsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRWaWV3KCkuZ2V0VGV4dFdpZHRoKHN0eWxlLmdldEZvbnRTdHlsZSgpLCBsaW5lcyksXG4gICAgICAgICAgeCA9IDA7XG4gICAgICBpZiAoanVzdGlmaWNhdGlvbiAhPT0gJ2xlZnQnKSB4IC09IHdpZHRoIC8gKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInID8gMiA6IDEpO1xuICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHgsIG51bUxpbmVzID8gLTAuNzUgKiBsZWFkaW5nIDogMCwgd2lkdGgsIG51bUxpbmVzICogbGVhZGluZyk7XG4gICAgICByZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCwgcmVjdCkgOiByZWN0O1xuICAgIH1cbiAgfSk7XG4gIHZhciBDb2xvciA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGVzID0ge1xuICAgICAgZ3JheTogWydncmF5J10sXG4gICAgICByZ2I6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcbiAgICAgIGhzYjogWydodWUnLCAnc2F0dXJhdGlvbicsICdicmlnaHRuZXNzJ10sXG4gICAgICBoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG4gICAgICBncmFkaWVudDogWydncmFkaWVudCcsICdvcmlnaW4nLCAnZGVzdGluYXRpb24nLCAnaGlnaGxpZ2h0J11cbiAgICB9O1xuICAgIHZhciBjb21wb25lbnRQYXJzZXJzID0ge30sXG4gICAgICAgIG5hbWVkQ29sb3JzID0ge1xuICAgICAgdHJhbnNwYXJlbnQ6IFswLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgICAgIGNvbG9yQ3R4O1xuXG4gICAgZnVuY3Rpb24gZnJvbUNTUyhzdHJpbmcpIHtcbiAgICAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiMoW1xcZGEtZl17Mn0pKFtcXGRhLWZdezJ9KShbXFxkYS1mXXsyfSkoW1xcZGEtZl17Mn0pPyQvaSkgfHwgc3RyaW5nLm1hdGNoKC9eIyhbXFxkYS1mXSkoW1xcZGEtZl0pKFtcXGRhLWZdKShbXFxkYS1mXSk/JC9pKSxcbiAgICAgICAgICB0eXBlID0gJ3JnYicsXG4gICAgICAgICAgY29tcG9uZW50cztcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBhbW91bnQgPSBtYXRjaFs0XSA/IDQgOiAzO1xuICAgICAgICBjb21wb25lbnRzID0gbmV3IEFycmF5KGFtb3VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGNoW2kgKyAxXTtcbiAgICAgICAgICBjb21wb25lbnRzW2ldID0gcGFyc2VJbnQodmFsdWUubGVuZ3RoID09IDEgPyB2YWx1ZSArIHZhbHVlIDogdmFsdWUsIDE2KSAvIDI1NTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXihyZ2J8aHNsKWE/XFwoKC4qKVxcKSQvKSkge1xuICAgICAgICB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgIGNvbXBvbmVudHMgPSBtYXRjaFsyXS50cmltKCkuc3BsaXQoL1ssXFxzXSsvZyk7XG4gICAgICAgIHZhciBpc0hTTCA9IHR5cGUgPT09ICdoc2wnO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gTWF0aC5taW4oY29tcG9uZW50cy5sZW5ndGgsIDQpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdChjb21wb25lbnQpO1xuXG4gICAgICAgICAgaWYgKGlzSFNMKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICB2YXIgdW5pdCA9IGNvbXBvbmVudC5tYXRjaCgvKFthLXpdKikkLylbMV07XG4gICAgICAgICAgICAgIHZhbHVlICo9IHtcbiAgICAgICAgICAgICAgICB0dXJuOiAzNjAsXG4gICAgICAgICAgICAgICAgcmFkOiAxODAgLyBNYXRoLlBJLFxuICAgICAgICAgICAgICAgIGdyYWQ6IDAuOVxuICAgICAgICAgICAgICB9W3VuaXRdIHx8IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCAzKSB7XG4gICAgICAgICAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPCAzKSB7XG4gICAgICAgICAgICB2YWx1ZSAvPSAvJSQvLnRlc3QoY29tcG9uZW50KSA/IDEwMCA6IDI1NTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21wb25lbnRzW2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb2xvciA9IG5hbWVkQ29sb3JzW3N0cmluZ107XG5cbiAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgICAgIGlmICghY29sb3JDdHgpIHtcbiAgICAgICAgICAgICAgY29sb3JDdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuICAgICAgICAgICAgICBjb2xvckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbG9yQ3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICAgIGNvbG9yQ3R4LmZpbGxTdHlsZSA9IHN0cmluZztcbiAgICAgICAgICAgIGNvbG9yQ3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBjb2xvckN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YTtcbiAgICAgICAgICAgIGNvbG9yID0gbmFtZWRDb2xvcnNbc3RyaW5nXSA9IFtkYXRhWzBdIC8gMjU1LCBkYXRhWzFdIC8gMjU1LCBkYXRhWzJdIC8gMjU1XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sb3IgPSBbMCwgMCwgMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50cyA9IGNvbG9yLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdHlwZSwgY29tcG9uZW50c107XG4gICAgfVxuXG4gICAgdmFyIGhzYkluZGljZXMgPSBbWzAsIDMsIDFdLCBbMiwgMCwgMV0sIFsxLCAwLCAzXSwgWzEsIDIsIDBdLCBbMywgMSwgMF0sIFswLCAxLCAyXV07XG4gICAgdmFyIGNvbnZlcnRlcnMgPSB7XG4gICAgICAncmdiLWhzYic6IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICAgICAgICBoID0gZGVsdGEgPT09IDAgPyAwIDogKG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApIDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyIDogKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MDtcbiAgICAgICAgcmV0dXJuIFtoLCBtYXggPT09IDAgPyAwIDogZGVsdGEgLyBtYXgsIG1heF07XG4gICAgICB9LFxuICAgICAgJ2hzYi1yZ2InOiBmdW5jdGlvbiAoaCwgcywgYikge1xuICAgICAgICBoID0gKGggLyA2MCAlIDYgKyA2KSAlIDY7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihoKSxcbiAgICAgICAgICAgIGYgPSBoIC0gaSxcbiAgICAgICAgICAgIGkgPSBoc2JJbmRpY2VzW2ldLFxuICAgICAgICAgICAgdiA9IFtiLCBiICogKDEgLSBzKSwgYiAqICgxIC0gcyAqIGYpLCBiICogKDEgLSBzICogKDEgLSBmKSldO1xuICAgICAgICByZXR1cm4gW3ZbaVswXV0sIHZbaVsxXV0sIHZbaVsyXV1dO1xuICAgICAgfSxcbiAgICAgICdyZ2ItaHNsJzogZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICAgICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgICAgICAgIGFjaHJvbWF0aWMgPSBkZWx0YSA9PT0gMCxcbiAgICAgICAgICAgIGggPSBhY2hyb21hdGljID8gMCA6IChtYXggPT0gciA/IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKSA6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMiA6IChyIC0gZykgLyBkZWx0YSArIDQpICogNjAsXG4gICAgICAgICAgICBsID0gKG1heCArIG1pbikgLyAyLFxuICAgICAgICAgICAgcyA9IGFjaHJvbWF0aWMgPyAwIDogbCA8IDAuNSA/IGRlbHRhIC8gKG1heCArIG1pbikgOiBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcbiAgICAgICAgcmV0dXJuIFtoLCBzLCBsXTtcbiAgICAgIH0sXG4gICAgICAnaHNsLXJnYic6IGZ1bmN0aW9uIChoLCBzLCBsKSB7XG4gICAgICAgIGggPSAoaCAvIDM2MCAlIDEgKyAxKSAlIDE7XG4gICAgICAgIGlmIChzID09PSAwKSByZXR1cm4gW2wsIGwsIGxdO1xuICAgICAgICB2YXIgdDNzID0gW2ggKyAxIC8gMywgaCwgaCAtIDEgLyAzXSxcbiAgICAgICAgICAgIHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcyxcbiAgICAgICAgICAgIHQxID0gMiAqIGwgLSB0MixcbiAgICAgICAgICAgIGMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHZhciB0MyA9IHQzc1tpXTtcbiAgICAgICAgICBpZiAodDMgPCAwKSB0MyArPSAxO1xuICAgICAgICAgIGlmICh0MyA+IDEpIHQzIC09IDE7XG4gICAgICAgICAgY1tpXSA9IDYgKiB0MyA8IDEgPyB0MSArICh0MiAtIHQxKSAqIDYgKiB0MyA6IDIgKiB0MyA8IDEgPyB0MiA6IDMgKiB0MyA8IDIgPyB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDYgOiB0MTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSxcbiAgICAgICdyZ2ItZ3JheSc6IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIHJldHVybiBbciAqIDAuMjk4OSArIGcgKiAwLjU4NyArIGIgKiAwLjExNF07XG4gICAgICB9LFxuICAgICAgJ2dyYXktcmdiJzogZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgcmV0dXJuIFtnLCBnLCBnXTtcbiAgICAgIH0sXG4gICAgICAnZ3JheS1oc2InOiBmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gWzAsIDAsIGddO1xuICAgICAgfSxcbiAgICAgICdncmF5LWhzbCc6IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgZ107XG4gICAgICB9LFxuICAgICAgJ2dyYWRpZW50LXJnYic6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSxcbiAgICAgICdyZ2ItZ3JhZGllbnQnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCYXNlLmVhY2godHlwZXMsIGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCB0eXBlKSB7XG4gICAgICBjb21wb25lbnRQYXJzZXJzW3R5cGVdID0gW107XG4gICAgICBCYXNlLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24gKG5hbWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuICAgICAgICAgICAgaGFzT3ZlcmxhcCA9IC9eKGh1ZXxzYXR1cmF0aW9uKSQvLnRlc3QobmFtZSksXG4gICAgICAgICAgICBwYXJzZXIgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdW2luZGV4XSA9IHR5cGUgPT09ICdncmFkaWVudCcgPyBuYW1lID09PSAnZ3JhZGllbnQnID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jb21wb25lbnRzWzBdO1xuICAgICAgICAgIHZhbHVlID0gR3JhZGllbnQucmVhZChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogYXJndW1lbnRzLCAwLCB7XG4gICAgICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCkgY3VycmVudC5fcmVtb3ZlT3duZXIodGhpcyk7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHZhbHVlLl9hZGRPd25lcih0aGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7XG4gICAgICAgICAgICByZWFkTnVsbDogbmFtZSA9PT0gJ2hpZ2hsaWdodCcsXG4gICAgICAgICAgICBjbG9uZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpID8gMCA6ICt2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGUgfHwgaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSkgPyB0aGlzLl9jb21wb25lbnRzW2luZGV4XSA6IHRoaXMuX2NvbnZlcnQodHlwZSlbaW5kZXhdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLl90eXBlICE9PSB0eXBlICYmICEoaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSkpKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdID0gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUpO1xuXG4gICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9O1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSwge1xuICAgICAgX2NsYXNzOiAnQ29sb3InLFxuICAgICAgX3JlYWRJbmRleDogdHJ1ZSxcbiAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbG9yKGFyZykge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIHJlYWRpbmcgPSB0aGlzLl9fcmVhZCxcbiAgICAgICAgICAgIHJlYWQgPSAwLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudHMsXG4gICAgICAgICAgICBhbHBoYSxcbiAgICAgICAgICAgIHZhbHVlcztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgYXJncyA9IGFyZztcbiAgICAgICAgICBhcmcgPSBhcmdzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ1R5cGUgPSBhcmcgIT0gbnVsbCAmJiB0eXBlb2YgYXJnO1xuXG4gICAgICAgIGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyAmJiBhcmcgaW4gdHlwZXMpIHtcbiAgICAgICAgICB0eXBlID0gYXJnO1xuICAgICAgICAgIGFyZyA9IGFyZ3NbMV07XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzID0gYXJnO1xuICAgICAgICAgICAgYWxwaGEgPSBhcmdzWzJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVhZGluZykgcmVhZCA9IDE7XG4gICAgICAgICAgICBhcmdzID0gQmFzZS5zbGljZShhcmdzLCAxKTtcbiAgICAgICAgICAgIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29tcG9uZW50cykge1xuICAgICAgICAgIHZhbHVlcyA9IGFyZ1R5cGUgPT09ICdudW1iZXInID8gYXJncyA6IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbCA/IGFyZyA6IG51bGw7XG5cbiAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHR5cGUgPSB2YWx1ZXMubGVuZ3RoID49IDMgPyAncmdiJyA6ICdncmF5JztcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0eXBlc1t0eXBlXS5sZW5ndGg7XG4gICAgICAgICAgICBhbHBoYSA9IHZhbHVlc1tsZW5ndGhdO1xuXG4gICAgICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgICByZWFkICs9IHZhbHVlcyA9PT0gYXJndW1lbnRzID8gbGVuZ3RoICsgKGFscGhhICE9IG51bGwgPyAxIDogMCkgOiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IGxlbmd0aCkgdmFsdWVzID0gQmFzZS5zbGljZSh2YWx1ZXMsIDAsIGxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhcmdUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRlZCA9IGZyb21DU1MoYXJnKTtcbiAgICAgICAgICAgIHR5cGUgPSBjb252ZXJ0ZWRbMF07XG4gICAgICAgICAgICBjb21wb25lbnRzID0gY29udmVydGVkWzFdO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgYWxwaGEgPSBjb21wb25lbnRzWzNdO1xuICAgICAgICAgICAgICBjb21wb25lbnRzLmxlbmd0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBhcmcuX3R5cGU7XG4gICAgICAgICAgICAgIGNvbXBvbmVudHMgPSBhcmcuX2NvbXBvbmVudHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgYWxwaGEgPSBhcmcuX2FscGhhO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZ3JhZGllbnQnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgIGlmIChwb2ludCkgY29tcG9uZW50c1tpXSA9IHBvaW50LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgdHlwZSA9ICdncmFkaWVudCc7XG4gICAgICAgICAgICAgIHZhbHVlcyA9IGFyZ3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0eXBlID0gJ2h1ZScgaW4gYXJnID8gJ2xpZ2h0bmVzcycgaW4gYXJnID8gJ2hzbCcgOiAnaHNiJyA6ICdncmFkaWVudCcgaW4gYXJnIHx8ICdzdG9wcycgaW4gYXJnIHx8ICdyYWRpYWwnIGluIGFyZyA/ICdncmFkaWVudCcgOiAnZ3JheScgaW4gYXJnID8gJ2dyYXknIDogJ3JnYic7XG4gICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV0sXG4gICAgICAgICAgICAgICAgICBwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJnW3Byb3BlcnRpZXNbaV1dO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgIWkgJiYgdHlwZSA9PT0gJ2dyYWRpZW50JyAmJiAnc3RvcHMnIGluIGFyZykge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BzOiBhcmcuc3RvcHMsXG4gICAgICAgICAgICAgICAgICAgIHJhZGlhbDogYXJnLnJhZGlhbFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFscGhhID0gYXJnLmFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZWFkaW5nICYmIHR5cGUpIHJlYWQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGUgfHwgJ3JnYic7XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICB2YXIgcGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdGhpcy5fdHlwZV07XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWVzICYmIHZhbHVlc1tpXSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkgY29tcG9uZW50c1tpXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdGhpcy5fdHlwZV07XG4gICAgICAgIHRoaXMuX2FscGhhID0gYWxwaGE7XG4gICAgICAgIGlmIChyZWFkaW5nKSB0aGlzLl9fcmVhZCA9IHJlYWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHNldDogJyNpbml0aWFsaXplJyxcbiAgICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5nZXRDb21wb25lbnRzKCk7XG4gICAgICAgIHJldHVybiBCYXNlLnNlcmlhbGl6ZSgvXihncmF5fHJnYikkLy50ZXN0KHRoaXMuX3R5cGUpID8gY29tcG9uZW50cyA6IFt0aGlzLl90eXBlXS5jb25jYXQoY29tcG9uZW50cyksIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuICAgICAgfSxcbiAgICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhc1N0eWxlID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5fb3duZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fc2V0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vd25lci5fY2hhbmdlZCgxMjkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jb252ZXJ0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgY29udmVydGVyO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZSA/IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoKSA6IChjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzW3RoaXMuX3R5cGUgKyAnLScgKyB0eXBlXSkgPyBjb252ZXJ0ZXIuYXBwbHkodGhpcywgdGhpcy5fY29tcG9uZW50cykgOiBjb252ZXJ0ZXJzWydyZ2ItJyArIHR5cGVdLmFwcGx5KHRoaXMsIGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctcmdiJ10uYXBwbHkodGhpcywgdGhpcy5fY29tcG9uZW50cykpO1xuICAgICAgfSxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IodHlwZSwgdGhpcy5fY29udmVydCh0eXBlKSwgdGhpcy5fYWxwaGEpO1xuICAgICAgfSxcbiAgICAgIGdldFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgICB9LFxuICAgICAgc2V0VHlwZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICB9LFxuICAgICAgZ2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoKTtcblxuICAgICAgICBpZiAodGhpcy5fYWxwaGEgIT0gbnVsbCkgY29tcG9uZW50cy5wdXNoKHRoaXMuX2FscGhhKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgICB9LFxuICAgICAgZ2V0QWxwaGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGwgPyB0aGlzLl9hbHBoYSA6IDE7XG4gICAgICB9LFxuICAgICAgc2V0QWxwaGE6IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICB0aGlzLl9hbHBoYSA9IGFscGhhID09IG51bGwgPyBudWxsIDogTWF0aC5taW4oTWF0aC5tYXgoYWxwaGEsIDApLCAxKTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICB9LFxuICAgICAgaGFzQWxwaGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGw7XG4gICAgICB9LFxuICAgICAgZXF1YWxzOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIGNvbCA9IEJhc2UuaXNQbGFpblZhbHVlKGNvbG9yLCB0cnVlKSA/IENvbG9yLnJlYWQoYXJndW1lbnRzKSA6IGNvbG9yO1xuICAgICAgICByZXR1cm4gY29sID09PSB0aGlzIHx8IGNvbCAmJiB0aGlzLl9jbGFzcyA9PT0gY29sLl9jbGFzcyAmJiB0aGlzLl90eXBlID09PSBjb2wuX3R5cGUgJiYgdGhpcy5nZXRBbHBoYSgpID09PSBjb2wuZ2V0QWxwaGEoKSAmJiBCYXNlLmVxdWFscyh0aGlzLl9jb21wb25lbnRzLCBjb2wuX2NvbXBvbmVudHMpIHx8IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcHJvcGVydGllcyxcbiAgICAgICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgICAgICBpc0dyYWRpZW50ID0gdGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50JyxcbiAgICAgICAgICAgIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2NvbXBvbmVudHNbaV07XG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHBhcnRzLnB1c2gocHJvcGVydGllc1tpXSArICc6ICcgKyAoaXNHcmFkaWVudCA/IHZhbHVlIDogZi5udW1iZXIodmFsdWUpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYWxwaGEgIT0gbnVsbCkgcGFydHMucHVzaCgnYWxwaGE6ICcgKyBmLm51bWJlcih0aGlzLl9hbHBoYSkpO1xuICAgICAgICByZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgICAgfSxcbiAgICAgIHRvQ1NTOiBmdW5jdGlvbiAoaGV4KSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29udmVydCgncmdiJyksXG4gICAgICAgICAgICBhbHBoYSA9IGhleCB8fCB0aGlzLl9hbHBoYSA9PSBudWxsID8gMSA6IHRoaXMuX2FscGhhO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbnZlcnQodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHZhbCA8IDAgPyAwIDogdmFsID4gMSA/IDEgOiB2YWwpICogMjU1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudHMgPSBbY29udmVydChjb21wb25lbnRzWzBdKSwgY29udmVydChjb21wb25lbnRzWzFdKSwgY29udmVydChjb21wb25lbnRzWzJdKV07XG4gICAgICAgIGlmIChhbHBoYSA8IDEpIGNvbXBvbmVudHMucHVzaChhbHBoYSA8IDAgPyAwIDogYWxwaGEpO1xuICAgICAgICByZXR1cm4gaGV4ID8gJyMnICsgKCgxIDw8IDI0KSArIChjb21wb25lbnRzWzBdIDw8IDE2KSArIChjb21wb25lbnRzWzFdIDw8IDgpICsgY29tcG9uZW50c1syXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpIDogKGNvbXBvbmVudHMubGVuZ3RoID09IDQgPyAncmdiYSgnIDogJ3JnYignKSArIGNvbXBvbmVudHMuam9pbignLCcpICsgJyknO1xuICAgICAgfSxcbiAgICAgIHRvQ2FudmFzU3R5bGU6IGZ1bmN0aW9uIChjdHgsIG1hdHJpeCkge1xuICAgICAgICBpZiAodGhpcy5fY2FudmFzU3R5bGUpIHJldHVybiB0aGlzLl9jYW52YXNTdHlsZTtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgIT09ICdncmFkaWVudCcpIHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IHRoaXMudG9DU1MoKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLFxuICAgICAgICAgICAgZ3JhZGllbnQgPSBjb21wb25lbnRzWzBdLFxuICAgICAgICAgICAgc3RvcHMgPSBncmFkaWVudC5fc3RvcHMsXG4gICAgICAgICAgICBvcmlnaW4gPSBjb21wb25lbnRzWzFdLFxuICAgICAgICAgICAgZGVzdGluYXRpb24gPSBjb21wb25lbnRzWzJdLFxuICAgICAgICAgICAgaGlnaGxpZ2h0ID0gY29tcG9uZW50c1szXSxcbiAgICAgICAgICAgIGludmVyc2UgPSBtYXRyaXggJiYgbWF0cml4LmludmVydGVkKCksXG4gICAgICAgICAgICBjYW52YXNHcmFkaWVudDtcblxuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIG9yaWdpbiA9IGludmVyc2UuX3RyYW5zZm9ybVBvaW50KG9yaWdpbik7XG4gICAgICAgICAgZGVzdGluYXRpb24gPSBpbnZlcnNlLl90cmFuc2Zvcm1Qb2ludChkZXN0aW5hdGlvbik7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodCkgaGlnaGxpZ2h0ID0gaW52ZXJzZS5fdHJhbnNmb3JtUG9pbnQoaGlnaGxpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmFkaWVudC5fcmFkaWFsKSB7XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IGRlc3RpbmF0aW9uLmdldERpc3RhbmNlKG9yaWdpbik7XG5cbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgdmVjdG9yID0gaGlnaGxpZ2h0LnN1YnRyYWN0KG9yaWdpbik7XG4gICAgICAgICAgICBpZiAodmVjdG9yLmdldExlbmd0aCgpID4gcmFkaXVzKSBoaWdobGlnaHQgPSBvcmlnaW4uYWRkKHZlY3Rvci5ub3JtYWxpemUocmFkaXVzIC0gMC4xKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gaGlnaGxpZ2h0IHx8IG9yaWdpbjtcbiAgICAgICAgICBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChzdGFydC54LCBzdGFydC55LCAwLCBvcmlnaW4ueCwgb3JpZ2luLnksIHJhZGl1cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQob3JpZ2luLngsIG9yaWdpbi55LCBkZXN0aW5hdGlvbi54LCBkZXN0aW5hdGlvbi55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXSxcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gc3RvcC5fb2Zmc2V0O1xuICAgICAgICAgIGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChvZmZzZXQgPT0gbnVsbCA/IGkgLyAobCAtIDEpIDogb2Zmc2V0LCBzdG9wLl9jb2xvci50b0NhbnZhc1N0eWxlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gY2FudmFzR3JhZGllbnQ7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgICAgICAgbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb2ludCwgcG9pbnQsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgX3R5cGVzOiB0eXBlcyxcbiAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IocmFuZG9tKCksIHJhbmRvbSgpLCByYW5kb20oKSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRPd25lcjogZnVuY3Rpb24gKGNvbG9yLCBvd25lciwgc2V0dGVyKSB7XG4gICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IuX293bmVyICYmIG93bmVyICYmIGNvbG9yLl9vd25lciAhPT0gb3duZXIpIHtcbiAgICAgICAgICAgICAgY29sb3IgPSBjb2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNvbG9yLl9vd25lciBeICFvd25lcikge1xuICAgICAgICAgICAgICBjb2xvci5fb3duZXIgPSBvd25lciB8fCBudWxsO1xuICAgICAgICAgICAgICBjb2xvci5fc2V0dGVyID0gc2V0dGVyIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0oKSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3BlcmF0b3JzID0ge1xuICAgICAgYWRkOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICB9LFxuICAgICAgc3VidHJhY3Q6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0sXG4gICAgICBtdWx0aXBseTogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgKiBiO1xuICAgICAgfSxcbiAgICAgIGRpdmlkZTogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLyBiO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJhc2UuZWFjaChvcGVyYXRvcnMsIGZ1bmN0aW9uIChvcGVyYXRvciwgbmFtZSkge1xuICAgICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICBjb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKTtcblxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG4gICAgICAgICAgICBjb21wb25lbnRzMSA9IHRoaXMuX2NvbXBvbmVudHMsXG4gICAgICAgICAgICBjb21wb25lbnRzMiA9IGNvbG9yLl9jb252ZXJ0KHR5cGUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29tcG9uZW50czEubGVuZ3RoOyBpIDwgbDsgaSsrKSBjb21wb25lbnRzMltpXSA9IG9wZXJhdG9yKGNvbXBvbmVudHMxW2ldLCBjb21wb25lbnRzMltpXSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0eXBlLCBjb21wb25lbnRzMiwgdGhpcy5fYWxwaGEgIT0gbnVsbCA/IG9wZXJhdG9yKHRoaXMuX2FscGhhLCBjb2xvci5nZXRBbHBoYSgpKSA6IG51bGwpO1xuICAgICAgfTtcbiAgICB9LCB7fSk7XG4gIH0oKSk7XG4gIHZhciBHcmFkaWVudCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdHcmFkaWVudCcsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnQoc3RvcHMsIHJhZGlhbCkge1xuICAgICAgdGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cbiAgICAgIGlmIChzdG9wcyAmJiBCYXNlLmlzUGxhaW5PYmplY3Qoc3RvcHMpKSB7XG4gICAgICAgIHRoaXMuc2V0KHN0b3BzKTtcbiAgICAgICAgc3RvcHMgPSByYWRpYWwgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RvcHMgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNldFN0b3BzKHN0b3BzIHx8IFsnd2hpdGUnLCAnYmxhY2snXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yYWRpYWwgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNldFJhZGlhbCh0eXBlb2YgcmFkaWFsID09PSAnc3RyaW5nJyAmJiByYWRpYWwgPT09ICdyYWRpYWwnIHx8IHJhZGlhbCB8fCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgcmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9zdG9wcywgdGhpcy5fcmFkaWFsXSwgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX293bmVycyAmJiB0aGlzLl9vd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX293bmVyc1tpXS5fY2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FkZE93bmVyOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgIGlmICghdGhpcy5fb3duZXJzKSB0aGlzLl9vd25lcnMgPSBbXTtcblxuICAgICAgdGhpcy5fb3duZXJzLnB1c2goY29sb3IpO1xuICAgIH0sXG4gICAgX3JlbW92ZU93bmVyOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX293bmVycyA/IHRoaXMuX293bmVycy5pbmRleE9mKGNvbG9yKSA6IC0xO1xuXG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgdGhpcy5fb3duZXJzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9vd25lcnMubGVuZ3RoKSB0aGlzLl9vd25lcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0b3BzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHN0b3BzW2ldID0gdGhpcy5fc3RvcHNbaV0uY2xvbmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBHcmFkaWVudChzdG9wcywgdGhpcy5fcmFkaWFsKTtcbiAgICB9LFxuICAgIGdldFN0b3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcHM7XG4gICAgfSxcbiAgICBzZXRTdG9wczogZnVuY3Rpb24gKHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dyYWRpZW50IHN0b3AgbGlzdCBuZWVkcyB0byBjb250YWluIGF0IGxlYXN0IHR3byBzdG9wcy4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9zdG9wcyA9IHRoaXMuX3N0b3BzO1xuXG4gICAgICBpZiAoX3N0b3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykgX3N0b3BzW2ldLl9vd25lciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgX3N0b3BzID0gdGhpcy5fc3RvcHMgPSBHcmFkaWVudFN0b3AucmVhZExpc3Qoc3RvcHMsIDAsIHtcbiAgICAgICAgY2xvbmU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIF9zdG9wc1tpXS5fb3duZXIgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfSxcbiAgICBnZXRSYWRpYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yYWRpYWw7XG4gICAgfSxcbiAgICBzZXRSYWRpYWw6IGZ1bmN0aW9uIChyYWRpYWwpIHtcbiAgICAgIHRoaXMuX3JhZGlhbCA9IHJhZGlhbDtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoZ3JhZGllbnQpIHtcbiAgICAgIGlmIChncmFkaWVudCA9PT0gdGhpcykgcmV0dXJuIHRydWU7XG5cbiAgICAgIGlmIChncmFkaWVudCAmJiB0aGlzLl9jbGFzcyA9PT0gZ3JhZGllbnQuX2NsYXNzKSB7XG4gICAgICAgIHZhciBzdG9wczEgPSB0aGlzLl9zdG9wcyxcbiAgICAgICAgICAgIHN0b3BzMiA9IGdyYWRpZW50Ll9zdG9wcyxcbiAgICAgICAgICAgIGxlbmd0aCA9IHN0b3BzMS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gc3RvcHMyLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghc3RvcHMxW2ldLmVxdWFscyhzdG9wczJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBHcmFkaWVudFN0b3AgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnR3JhZGllbnRTdG9wJyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudFN0b3AoYXJnMCwgYXJnMSkge1xuICAgICAgdmFyIGNvbG9yID0gYXJnMCxcbiAgICAgICAgICBvZmZzZXQgPSBhcmcxO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdvYmplY3QnICYmIGFyZzEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSAmJiB0eXBlb2YgYXJnMFswXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjb2xvciA9IGFyZzBbMF07XG4gICAgICAgICAgb2Zmc2V0ID0gYXJnMFsxXTtcbiAgICAgICAgfSBlbHNlIGlmICgnY29sb3InIGluIGFyZzAgfHwgJ29mZnNldCcgaW4gYXJnMCB8fCAncmFtcFBvaW50JyBpbiBhcmcwKSB7XG4gICAgICAgICAgY29sb3IgPSBhcmcwLmNvbG9yO1xuICAgICAgICAgIG9mZnNldCA9IGFyZzAub2Zmc2V0IHx8IGFyZzAucmFtcFBvaW50IHx8IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRDb2xvcihjb2xvcik7XG4gICAgICB0aGlzLnNldE9mZnNldChvZmZzZXQpO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgR3JhZGllbnRTdG9wKHRoaXMuX2NvbG9yLmNsb25lKCksIHRoaXMuX29mZnNldCk7XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5fY29sb3IsXG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKG9mZnNldCA9PSBudWxsID8gW2NvbG9yXSA6IFtjb2xvciwgb2Zmc2V0XSwgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX293bmVyKSB0aGlzLl9vd25lci5fY2hhbmdlZCgxMjkpO1xuICAgIH0sXG4gICAgZ2V0T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICAgIH0sXG4gICAgc2V0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9LFxuICAgIGdldFJhbXBQb2ludDogJyNnZXRPZmZzZXQnLFxuICAgIHNldFJhbXBQb2ludDogJyNzZXRPZmZzZXQnLFxuICAgIGdldENvbG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICAgfSxcbiAgICBzZXRDb2xvcjogZnVuY3Rpb24gKCkge1xuICAgICAgQ29sb3IuX3NldE93bmVyKHRoaXMuX2NvbG9yLCBudWxsKTtcblxuICAgICAgdGhpcy5fY29sb3IgPSBDb2xvci5fc2V0T3duZXIoQ29sb3IucmVhZChhcmd1bWVudHMsIDApLCB0aGlzLCAnc2V0Q29sb3InKTtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgcmV0dXJuIHN0b3AgPT09IHRoaXMgfHwgc3RvcCAmJiB0aGlzLl9jbGFzcyA9PT0gc3RvcC5fY2xhc3MgJiYgdGhpcy5fY29sb3IuZXF1YWxzKHN0b3AuX2NvbG9yKSAmJiB0aGlzLl9vZmZzZXQgPT0gc3RvcC5fb2Zmc2V0IHx8IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBTdHlsZSA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGl0ZW1EZWZhdWx0cyA9IHtcbiAgICAgIGZpbGxDb2xvcjogbnVsbCxcbiAgICAgIGZpbGxSdWxlOiAnbm9uemVybycsXG4gICAgICBzdHJva2VDb2xvcjogbnVsbCxcbiAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgc3Ryb2tlQ2FwOiAnYnV0dCcsXG4gICAgICBzdHJva2VKb2luOiAnbWl0ZXInLFxuICAgICAgc3Ryb2tlU2NhbGluZzogdHJ1ZSxcbiAgICAgIG1pdGVyTGltaXQ6IDEwLFxuICAgICAgZGFzaE9mZnNldDogMCxcbiAgICAgIGRhc2hBcnJheTogW10sXG4gICAgICBzaGFkb3dDb2xvcjogbnVsbCxcbiAgICAgIHNoYWRvd0JsdXI6IDAsXG4gICAgICBzaGFkb3dPZmZzZXQ6IG5ldyBQb2ludCgpLFxuICAgICAgc2VsZWN0ZWRDb2xvcjogbnVsbFxuICAgIH0sXG4gICAgICAgIGdyb3VwRGVmYXVsdHMgPSBCYXNlLnNldCh7fSwgaXRlbURlZmF1bHRzLCB7XG4gICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG4gICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgIGxlYWRpbmc6IG51bGwsXG4gICAgICBqdXN0aWZpY2F0aW9uOiAnbGVmdCdcbiAgICB9KSxcbiAgICAgICAgdGV4dERlZmF1bHRzID0gQmFzZS5zZXQoe30sIGdyb3VwRGVmYXVsdHMsIHtcbiAgICAgIGZpbGxDb2xvcjogbmV3IENvbG9yKClcbiAgICB9KSxcbiAgICAgICAgZmxhZ3MgPSB7XG4gICAgICBzdHJva2VXaWR0aDogMTkzLFxuICAgICAgc3Ryb2tlQ2FwOiAxOTMsXG4gICAgICBzdHJva2VKb2luOiAxOTMsXG4gICAgICBzdHJva2VTY2FsaW5nOiAyMDEsXG4gICAgICBtaXRlckxpbWl0OiAxOTMsXG4gICAgICBmb250RmFtaWx5OiA5LFxuICAgICAgZm9udFdlaWdodDogOSxcbiAgICAgIGZvbnRTaXplOiA5LFxuICAgICAgZm9udDogOSxcbiAgICAgIGxlYWRpbmc6IDksXG4gICAgICBqdXN0aWZpY2F0aW9uOiA5XG4gICAgfSxcbiAgICAgICAgaXRlbSA9IHtcbiAgICAgIGJlYW5zOiB0cnVlXG4gICAgfSxcbiAgICAgICAgZmllbGRzID0ge1xuICAgICAgX2NsYXNzOiAnU3R5bGUnLFxuICAgICAgYmVhbnM6IHRydWUsXG4gICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBTdHlsZShzdHlsZSwgX293bmVyLCBfcHJvamVjdCkge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fb3duZXIgPSBfb3duZXI7XG4gICAgICAgIHRoaXMuX3Byb2plY3QgPSBfb3duZXIgJiYgX293bmVyLl9wcm9qZWN0IHx8IF9wcm9qZWN0IHx8IHBhcGVyLnByb2plY3Q7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRzID0gIV9vd25lciB8fCBfb3duZXIgaW5zdGFuY2VvZiBHcm91cCA/IGdyb3VwRGVmYXVsdHMgOiBfb3duZXIgaW5zdGFuY2VvZiBUZXh0SXRlbSA/IHRleHREZWZhdWx0cyA6IGl0ZW1EZWZhdWx0cztcbiAgICAgICAgaWYgKHN0eWxlKSB0aGlzLnNldChzdHlsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBCYXNlLmVhY2goZ3JvdXBEZWZhdWx0cywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHZhciBpc0NvbG9yID0gL0NvbG9yJC8udGVzdChrZXkpLFxuICAgICAgICAgIGlzUG9pbnQgPSBrZXkgPT09ICdzaGFkb3dPZmZzZXQnLFxuICAgICAgICAgIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcbiAgICAgICAgICBmbGFnID0gZmxhZ3Nba2V5XSxcbiAgICAgICAgICBzZXQgPSAnc2V0JyArIHBhcnQsXG4gICAgICAgICAgZ2V0ID0gJ2dldCcgKyBwYXJ0O1xuXG4gICAgICBmaWVsZHNbc2V0XSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcbiAgICAgICAgICAgIGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuLFxuICAgICAgICAgICAgYXBwbHlUb0NoaWxkcmVuID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKTtcblxuICAgICAgICBpZiAoYXBwbHlUb0NoaWxkcmVuKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGNoaWxkcmVuW2ldLl9zdHlsZVtzZXRdKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoa2V5ID09PSAnc2VsZWN0ZWRDb2xvcicgfHwgIWFwcGx5VG9DaGlsZHJlbikgJiYga2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG4gICAgICAgICAgdmFyIG9sZCA9IHRoaXMuX3ZhbHVlc1trZXldO1xuXG4gICAgICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgICAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgICAgICAgICBDb2xvci5fc2V0T3duZXIob2xkLCBudWxsKTtcblxuICAgICAgICAgICAgICAgIG9sZC5fY2FudmFzU3R5bGUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQ29sb3IuX3NldE93bmVyKHZhbHVlLCBvd25lciwgYXBwbHlUb0NoaWxkcmVuICYmIHNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChvd25lcikgb3duZXIuX2NoYW5nZWQoZmxhZyB8fCAxMjkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmllbGRzW2dldF0gPSBmdW5jdGlvbiAoX2RvbnRNZXJnZSkge1xuICAgICAgICB2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcbiAgICAgICAgICAgIGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuLFxuICAgICAgICAgICAgYXBwbHlUb0NoaWxkcmVuID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSxcbiAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgIGlmIChhcHBseVRvQ2hpbGRyZW4gJiYgIV9kb250TWVyZ2UpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkVmFsdWUgPSBjaGlsZHJlbltpXS5fc3R5bGVbZ2V0XSgpO1xuXG4gICAgICAgICAgICBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBjaGlsZFZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsdWUsIGNoaWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1trZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZGVmYXVsdHNba2V5XTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmNsb25lKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN0b3IgPSBpc0NvbG9yID8gQ29sb3IgOiBpc1BvaW50ID8gUG9pbnQgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAoY3RvciAmJiAhKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBjdG9yKSkge1xuICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlID0gY3Rvci5yZWFkKFt2YWx1ZV0sIDAsIHtcbiAgICAgICAgICAgICAgICByZWFkTnVsbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjbG9uZTogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgJiYgaXNDb2xvcikge1xuICAgICAgICAgIHZhbHVlID0gQ29sb3IuX3NldE93bmVyKHZhbHVlLCBvd25lciwgYXBwbHlUb0NoaWxkcmVuICYmIHNldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuXG4gICAgICBpdGVtW2dldF0gPSBmdW5jdGlvbiAoX2RvbnRNZXJnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVbZ2V0XShfZG9udE1lcmdlKTtcbiAgICAgIH07XG5cbiAgICAgIGl0ZW1bc2V0XSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdHlsZVtzZXRdKHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgQmFzZS5lYWNoKHtcbiAgICAgIEZvbnQ6ICdGb250RmFtaWx5JyxcbiAgICAgIFdpbmRpbmdSdWxlOiAnRmlsbFJ1bGUnXG4gICAgfSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHZhciBnZXQgPSAnZ2V0JyArIGtleSxcbiAgICAgICAgICBzZXQgPSAnc2V0JyArIGtleTtcbiAgICAgIGZpZWxkc1tnZXRdID0gaXRlbVtnZXRdID0gJyNnZXQnICsgdmFsdWU7XG4gICAgICBmaWVsZHNbc2V0XSA9IGl0ZW1bc2V0XSA9ICcjc2V0JyArIHZhbHVlO1xuICAgIH0pO1xuICAgIEl0ZW0uaW5qZWN0KGl0ZW0pO1xuICAgIHJldHVybiBmaWVsZHM7XG4gIH0oKSwge1xuICAgIHNldDogZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICB2YXIgaXNTdHlsZSA9IHN0eWxlIGluc3RhbmNlb2YgU3R5bGUsXG4gICAgICAgICAgdmFsdWVzID0gaXNTdHlsZSA/IHN0eWxlLl92YWx1ZXMgOiBzdHlsZTtcblxuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZSAmJiBpc1N0eWxlICYmIHZhbHVlLmNsb25lID8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoc3R5bGUxLCBzdHlsZTIsIHNlY29uZGFyeSkge1xuICAgICAgICB2YXIgdmFsdWVzMSA9IHN0eWxlMS5fdmFsdWVzLFxuICAgICAgICAgICAgdmFsdWVzMiA9IHN0eWxlMi5fdmFsdWVzLFxuICAgICAgICAgICAgZGVmYXVsdHMyID0gc3R5bGUyLl9kZWZhdWx0cztcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWVzMSkge1xuICAgICAgICAgIHZhciB2YWx1ZTEgPSB2YWx1ZXMxW2tleV0sXG4gICAgICAgICAgICAgIHZhbHVlMiA9IHZhbHVlczJba2V5XTtcbiAgICAgICAgICBpZiAoIShzZWNvbmRhcnkgJiYga2V5IGluIHZhbHVlczIpICYmICFCYXNlLmVxdWFscyh2YWx1ZTEsIHZhbHVlMiA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdHMyW2tleV0gOiB2YWx1ZTIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0eWxlID09PSB0aGlzIHx8IHN0eWxlICYmIHRoaXMuX2NsYXNzID09PSBzdHlsZS5fY2xhc3MgJiYgY29tcGFyZSh0aGlzLCBzdHlsZSkgJiYgY29tcGFyZShzdHlsZSwgdGhpcywgdHJ1ZSkgfHwgZmFsc2U7XG4gICAgfSxcbiAgICBfZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbG9yO1xuICAgICAgY29sb3IgPSB0aGlzLmdldEZpbGxDb2xvcigpO1xuICAgICAgaWYgKGNvbG9yKSBjb2xvci5fY2FudmFzU3R5bGUgPSBudWxsO1xuICAgICAgY29sb3IgPSB0aGlzLmdldFN0cm9rZUNvbG9yKCk7XG4gICAgICBpZiAoY29sb3IpIGNvbG9yLl9jYW52YXNTdHlsZSA9IG51bGw7XG4gICAgICBjb2xvciA9IHRoaXMuZ2V0U2hhZG93Q29sb3IoKTtcbiAgICAgIGlmIChjb2xvcikgY29sb3IuX2NhbnZhc1N0eWxlID0gbnVsbDtcbiAgICB9LFxuICAgIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0RmlsbENvbG9yKCk7XG4gICAgICByZXR1cm4gISFjb2xvciAmJiBjb2xvci5hbHBoYSA+IDA7XG4gICAgfSxcbiAgICBoYXNTdHJva2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0U3Ryb2tlQ29sb3IoKTtcbiAgICAgIHJldHVybiAhIWNvbG9yICYmIGNvbG9yLmFscGhhID4gMCAmJiB0aGlzLmdldFN0cm9rZVdpZHRoKCkgPiAwO1xuICAgIH0sXG4gICAgaGFzU2hhZG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmdldFNoYWRvd0NvbG9yKCk7XG4gICAgICByZXR1cm4gISFjb2xvciAmJiBjb2xvci5hbHBoYSA+IDAgJiYgKHRoaXMuZ2V0U2hhZG93Qmx1cigpID4gMCB8fCAhdGhpcy5nZXRTaGFkb3dPZmZzZXQoKS5pc1plcm8oKSk7XG4gICAgfSxcbiAgICBnZXRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvamVjdC5fdmlldztcbiAgICB9LFxuICAgIGdldEZvbnRTdHlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9udFdlaWdodCgpICsgJyAnICsgZm9udFNpemUgKyAoL1thLXpdL2kudGVzdChmb250U2l6ZSArICcnKSA/ICcgJyA6ICdweCAnKSArIHRoaXMuZ2V0Rm9udEZhbWlseSgpO1xuICAgIH0sXG4gICAgZ2V0Rm9udDogJyNnZXRGb250RmFtaWx5JyxcbiAgICBzZXRGb250OiAnI3NldEZvbnRGYW1pbHknLFxuICAgIGdldExlYWRpbmc6IGZ1bmN0aW9uIGdldExlYWRpbmcoKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IGdldExlYWRpbmcuYmFzZS5jYWxsKHRoaXMpLFxuICAgICAgICAgIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgaWYgKC9wdHxlbXwlfHB4Ly50ZXN0KGZvbnRTaXplKSkgZm9udFNpemUgPSB0aGlzLmdldFZpZXcoKS5nZXRQaXhlbFNpemUoZm9udFNpemUpO1xuICAgICAgcmV0dXJuIGxlYWRpbmcgIT0gbnVsbCA/IGxlYWRpbmcgOiBmb250U2l6ZSAqIDEuMjtcbiAgICB9XG4gIH0pO1xuICB2YXIgRG9tRWxlbWVudCA9IG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlUHJlZml4KGVsLCBuYW1lLCBzZXQsIHZhbHVlKSB7XG4gICAgICB2YXIgcHJlZml4ZXMgPSBbJycsICd3ZWJraXQnLCAnbW96JywgJ01veicsICdtcycsICdvJ10sXG4gICAgICAgICAgc3VmZml4ID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXSxcbiAgICAgICAgICAgIGtleSA9IHByZWZpeCA/IHByZWZpeCArIHN1ZmZpeCA6IG5hbWU7XG5cbiAgICAgICAgaWYgKGtleSBpbiBlbCkge1xuICAgICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICAgIGVsW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsW2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U3R5bGVzOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGRvYyA9IGVsICYmIGVsLm5vZGVUeXBlICE9PSA5ID8gZWwub3duZXJEb2N1bWVudCA6IGVsLFxuICAgICAgICAgICAgdmlldyA9IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXc7XG4gICAgICAgIHJldHVybiB2aWV3ICYmIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuICAgICAgfSxcbiAgICAgIGdldEJvdW5kczogZnVuY3Rpb24gKGVsLCB2aWV3cG9ydCkge1xuICAgICAgICB2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIGJvZHkgPSBkb2MuYm9keSxcbiAgICAgICAgICAgIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgcmVjdDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSByZWN0LmxlZnQgLSAoaHRtbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwKSxcbiAgICAgICAgICAgIHkgPSByZWN0LnRvcCAtIChodG1sLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwKTtcblxuICAgICAgICBpZiAoIXZpZXdwb3J0KSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSBkb2MuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgeCArPSB2aWV3LnBhZ2VYT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQ7XG4gICAgICAgICAgeSArPSB2aWV3LnBhZ2VZT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgeSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgfSxcbiAgICAgIGdldFZpZXdwb3J0Qm91bmRzOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICB2aWV3ID0gZG9jLmRlZmF1bHRWaWV3LFxuICAgICAgICAgICAgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKDAsIDAsIHZpZXcuaW5uZXJXaWR0aCB8fCBodG1sLmNsaWVudFdpZHRoLCB2aWV3LmlubmVySGVpZ2h0IHx8IGh0bWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICBnZXRPZmZzZXQ6IGZ1bmN0aW9uIChlbCwgdmlld3BvcnQpIHtcbiAgICAgICAgcmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB2aWV3cG9ydCkuZ2V0UG9pbnQoKTtcbiAgICAgIH0sXG4gICAgICBnZXRTaXplOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKS5nZXRTaXplKCk7XG4gICAgICB9LFxuICAgICAgaXNJbnZpc2libGU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gRG9tRWxlbWVudC5nZXRTaXplKGVsKS5lcXVhbHMobmV3IFNpemUoMCwgMCkpO1xuICAgICAgfSxcbiAgICAgIGlzSW5WaWV3OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuICFEb21FbGVtZW50LmlzSW52aXNpYmxlKGVsKSAmJiBEb21FbGVtZW50LmdldFZpZXdwb3J0Qm91bmRzKGVsKS5pbnRlcnNlY3RzKERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKSk7XG4gICAgICB9LFxuICAgICAgaXNJbnNlcnRlZDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKTtcbiAgICAgIH0sXG4gICAgICBnZXRQcmVmaXhlZDogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBlbCAmJiBoYW5kbGVQcmVmaXgoZWwsIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIHNldFByZWZpeGVkOiBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkgaGFuZGxlUHJlZml4KGVsLCBrZXksIHRydWUsIG5hbWVba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlUHJlZml4KGVsLCBuYW1lLCB0cnVlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG4gIHZhciBEb21FdmVudCA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChlbCwgZXZlbnRzKSB7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcbiAgICAgICAgICAgICAgcGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGFydHNbaV07XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGVsID09PSBkb2N1bWVudCAmJiAobmFtZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IG5hbWUgPT09ICd0b3VjaG1vdmUnKSA/IHtcbiAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICAgIH0gOiBmYWxzZTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuYywgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChlbCwgZXZlbnRzKSB7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcbiAgICAgICAgICAgICAgcGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHBvcyA9IGV2ZW50LnRhcmdldFRvdWNoZXMgPyBldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA/IGV2ZW50LnRhcmdldFRvdWNoZXNbMF0gOiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChwb3MucGFnZVggfHwgcG9zLmNsaWVudFggKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCwgcG9zLnBhZ2VZIHx8IHBvcy5jbGllbnRZICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgfSxcbiAgICBnZXRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuICAgIH0sXG4gICAgZ2V0UmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC50b0VsZW1lbnQ7XG4gICAgfSxcbiAgICBnZXRPZmZzZXQ6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gRG9tRXZlbnQuZ2V0UG9pbnQoZXZlbnQpLnN1YnRyYWN0KERvbUVsZW1lbnQuZ2V0T2Zmc2V0KHRhcmdldCB8fCBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpKSk7XG4gICAgfVxuICB9O1xuICBEb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBuYXRpdmVSZXF1ZXN0ID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZCh3aW5kb3csICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSxcbiAgICAgICAgcmVxdWVzdGVkID0gZmFsc2UsXG4gICAgICAgIGNhbGxiYWNrcyA9IFtdLFxuICAgICAgICB0aW1lcjtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrcygpIHtcbiAgICAgIHZhciBmdW5jdGlvbnMgPSBjYWxsYmFja3M7XG4gICAgICBjYWxsYmFja3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmdW5jdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSBmdW5jdGlvbnNbaV0oKTtcblxuICAgICAgcmVxdWVzdGVkID0gbmF0aXZlUmVxdWVzdCAmJiBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgaWYgKHJlcXVlc3RlZCkgbmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblxuICAgICAgaWYgKG5hdGl2ZVJlcXVlc3QpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0ZWQpIHtcbiAgICAgICAgICBuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG4gICAgICAgICAgcmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGltZXIpIHtcbiAgICAgICAgdGltZXIgPSBzZXRJbnRlcnZhbChoYW5kbGVDYWxsYmFja3MsIDEwMDAgLyA2MCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuICB2YXIgVmlldyA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcbiAgICBfY2xhc3M6ICdWaWV3JyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBWaWV3KHByb2plY3QsIGVsZW1lbnQpIHtcbiAgICAgIGZ1bmN0aW9uIGdldFNpemUobmFtZSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudFtuYW1lXSB8fCBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKSwgMTApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRDYW52YXNTaXplKCkge1xuICAgICAgICB2YXIgc2l6ZSA9IERvbUVsZW1lbnQuZ2V0U2l6ZShlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHNpemUuaXNOYU4oKSB8fCBzaXplLmlzWmVybygpID8gbmV3IFNpemUoZ2V0U2l6ZSgnd2lkdGgnKSwgZ2V0U2l6ZSgnaGVpZ2h0JykpIDogc2l6ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpemU7XG5cbiAgICAgIGlmICh3aW5kb3cgJiYgZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICBpZiAodGhpcy5faWQgPT0gbnVsbCkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5faWQgPSAncGFwZXItdmlldy0nICsgVmlldy5faWQrKyk7XG4gICAgICAgIERvbUV2ZW50LmFkZChlbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcbiAgICAgICAgdmFyIG5vbmUgPSAnbm9uZSc7XG4gICAgICAgIERvbUVsZW1lbnQuc2V0UHJlZml4ZWQoZWxlbWVudC5zdHlsZSwge1xuICAgICAgICAgIHVzZXJEcmFnOiBub25lLFxuICAgICAgICAgIHVzZXJTZWxlY3Q6IG5vbmUsXG4gICAgICAgICAgdG91Y2hDYWxsb3V0OiBub25lLFxuICAgICAgICAgIGNvbnRlbnRab29taW5nOiBub25lLFxuICAgICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdyZXNpemUnKSkge1xuICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICBEb21FdmVudC5hZGQod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMgPSB7XG4gICAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhhdC5zZXRWaWV3U2l6ZShnZXRDYW52YXNTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2l6ZSA9IGdldENhbnZhc1NpemUoKTtcblxuICAgICAgICBpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3N0YXRzJykgJiYgdHlwZW9mIFN0YXRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuX3N0YXRzID0gbmV3IFN0YXRzKCk7XG4gICAgICAgICAgdmFyIHN0YXRzID0gdGhpcy5fc3RhdHMuZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgc3R5bGUgPSBzdGF0cy5zdHlsZSxcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gRG9tRWxlbWVudC5nZXRPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBvZmZzZXQueCArICdweCc7XG4gICAgICAgICAgc3R5bGUudG9wID0gb2Zmc2V0LnkgKyAncHgnO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmV3IFNpemUoZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgIHRoaXMuX3Njb3BlID0gcHJvamVjdC5fc2NvcGU7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIGlmICghdGhpcy5fcGl4ZWxSYXRpbykgdGhpcy5fcGl4ZWxSYXRpbyA9IHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICB0aGlzLl9zZXRFbGVtZW50U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cbiAgICAgIHRoaXMuX3ZpZXdTaXplID0gc2l6ZTtcblxuICAgICAgVmlldy5fdmlld3MucHVzaCh0aGlzKTtcblxuICAgICAgVmlldy5fdmlld3NCeUlkW3RoaXMuX2lkXSA9IHRoaXM7XG4gICAgICAodGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpKS5fb3duZXIgPSB0aGlzO1xuICAgICAgaWYgKCFWaWV3Ll9mb2N1c2VkKSBWaWV3Ll9mb2N1c2VkID0gdGhpcztcbiAgICAgIHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcbiAgICAgIHRoaXMuX2ZyYW1lSXRlbUNvdW50ID0gMDtcbiAgICAgIHRoaXMuX2l0ZW1FdmVudHMgPSB7XG4gICAgICAgIG5hdGl2ZToge30sXG4gICAgICAgIHZpcnR1YWw6IHt9XG4gICAgICB9O1xuICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9ICFwYXBlci5hZ2VudC5ub2RlO1xuICAgICAgdGhpcy5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9wcm9qZWN0KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoVmlldy5fZm9jdXNlZCA9PT0gdGhpcykgVmlldy5fZm9jdXNlZCA9IG51bGw7XG5cbiAgICAgIFZpZXcuX3ZpZXdzLnNwbGljZShWaWV3Ll92aWV3cy5pbmRleE9mKHRoaXMpLCAxKTtcblxuICAgICAgZGVsZXRlIFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF07XG4gICAgICB2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG4gICAgICBpZiAocHJvamVjdC5fdmlldyA9PT0gdGhpcykgcHJvamVjdC5fdmlldyA9IG51bGw7XG4gICAgICBEb21FdmVudC5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG4gICAgICBEb21FdmVudC5yZW1vdmUod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IHRoaXMuX3Byb2plY3QgPSBudWxsO1xuICAgICAgdGhpcy5vZmYoJ2ZyYW1lJyk7XG4gICAgICB0aGlzLl9hbmltYXRlID0gZmFsc2U7XG4gICAgICB0aGlzLl9mcmFtZUl0ZW1zID0ge307XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIF9ldmVudHM6IEJhc2UuZWFjaChJdGVtLl9pdGVtSGFuZGxlcnMuY29uY2F0KFsnb25SZXNpemUnLCAnb25LZXlEb3duJywgJ29uS2V5VXAnXSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB0aGlzW25hbWVdID0ge307XG4gICAgfSwge1xuICAgICAgb25GcmFtZToge1xuICAgICAgICBpbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIF9hbmltYXRlOiBmYWxzZSxcbiAgICBfdGltZTogMCxcbiAgICBfY291bnQ6IDAsXG4gICAgZ2V0QXV0b1VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F1dG9VcGRhdGU7XG4gICAgfSxcbiAgICBzZXRBdXRvVXBkYXRlOiBmdW5jdGlvbiAoYXV0b1VwZGF0ZSkge1xuICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IGF1dG9VcGRhdGU7XG4gICAgICBpZiAoYXV0b1VwZGF0ZSkgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcbiAgICByZXF1ZXN0VXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX3JlcXVlc3RlZCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIERvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5fcmVxdWVzdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAodGhhdC5fYW5pbWF0ZSkge1xuICAgICAgICAgICAgdGhhdC5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoYXQuX2VsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICgoIURvbUVsZW1lbnQuZ2V0UHJlZml4ZWQoZG9jdW1lbnQsICdoaWRkZW4nKSB8fCBQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShlbGVtZW50LCAna2VlcGFsaXZlJykgPT09ICd0cnVlJykgJiYgRG9tRWxlbWVudC5pc0luVmlldyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICB0aGF0Ll9oYW5kbGVGcmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGF0Ll9hdXRvVXBkYXRlKSB0aGF0LnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBsYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGUgPSB0cnVlO1xuICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfSxcbiAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgX2hhbmRsZUZyYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICBwYXBlciA9IHRoaXMuX3Njb3BlO1xuICAgICAgdmFyIG5vdyA9IERhdGUubm93KCkgLyAxMDAwLFxuICAgICAgICAgIGRlbHRhID0gdGhpcy5fbGFzdCA/IG5vdyAtIHRoaXMuX2xhc3QgOiAwO1xuICAgICAgdGhpcy5fbGFzdCA9IG5vdztcbiAgICAgIHRoaXMuZW1pdCgnZnJhbWUnLCBuZXcgQmFzZSh7XG4gICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgICAgdGltZTogdGhpcy5fdGltZSArPSBkZWx0YSxcbiAgICAgICAgY291bnQ6IHRoaXMuX2NvdW50KytcbiAgICAgIH0pKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0cykgdGhpcy5fc3RhdHMudXBkYXRlKCk7XG4gICAgfSxcbiAgICBfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uIChpdGVtLCBhbmltYXRlKSB7XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLl9mcmFtZUl0ZW1zO1xuXG4gICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICBpdGVtc1tpdGVtLl9pZF0gPSB7XG4gICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgIGNvdW50OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICgrK3RoaXMuX2ZyYW1lSXRlbUNvdW50ID09PSAxKSB0aGlzLm9uKCdmcmFtZScsIHRoaXMuX2hhbmRsZUZyYW1lSXRlbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGl0ZW1zW2l0ZW0uX2lkXTtcblxuICAgICAgICBpZiAoLS10aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMub2ZmKCdmcmFtZScsIHRoaXMuX2hhbmRsZUZyYW1lSXRlbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfaGFuZGxlRnJhbWVJdGVtczogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2ZyYW1lSXRlbXMpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fZnJhbWVJdGVtc1tpXTtcbiAgICAgICAgZW50cnkuaXRlbS5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKGV2ZW50LCB7XG4gICAgICAgICAgdGltZTogZW50cnkudGltZSArPSBldmVudC5kZWx0YSxcbiAgICAgICAgICBjb3VudDogZW50cnkuY291bnQrK1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcHJvamVjdC5fY2hhbmdlZCg0MDk3KTtcblxuICAgICAgdGhpcy5fYm91bmRzID0gdGhpcy5fZGVjb21wb3NlZCA9IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgIH0sXG4gICAgZ2V0UGl4ZWxSYXRpbzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XG4gICAgfSxcbiAgICBnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbyAqIDcyO1xuICAgIH0sXG4gICAgZ2V0Vmlld1NpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5fdmlld1NpemU7XG4gICAgICByZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRWaWV3U2l6ZScpO1xuICAgIH0sXG4gICAgc2V0Vmlld1NpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgZGVsdGEgPSBzaXplLnN1YnRyYWN0KHRoaXMuX3ZpZXdTaXplKTtcbiAgICAgIGlmIChkZWx0YS5pc1plcm8oKSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9zZXRFbGVtZW50U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cbiAgICAgIHRoaXMuX3ZpZXdTaXplLnNldChzaXplKTtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuXG4gICAgICB0aGlzLmVtaXQoJ3Jlc2l6ZScsIHtcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgZGVsdGE6IGRlbHRhXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuX2F1dG9VcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9zZXRFbGVtZW50U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQud2lkdGggIT09IHdpZHRoKSBlbGVtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICAgIGlmIChlbGVtZW50LmhlaWdodCAhPT0gaGVpZ2h0KSBlbGVtZW50LmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9ib3VuZHMpIHRoaXMuX2JvdW5kcyA9IHRoaXMuX21hdHJpeC5pbnZlcnRlZCgpLl90cmFuc2Zvcm1Cb3VuZHMobmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSwgdGhpcy5fdmlld1NpemUpKTtcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gICAgfSxcbiAgICBnZXRTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRTaXplKCk7XG4gICAgfSxcbiAgICBpc1Zpc2libGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBEb21FbGVtZW50LmlzSW5WaWV3KHRoaXMuX2VsZW1lbnQpO1xuICAgIH0sXG4gICAgaXNJbnNlcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIERvbUVsZW1lbnQuaXNJbnNlcnRlZCh0aGlzLl9lbGVtZW50KTtcbiAgICB9LFxuICAgIGdldFBpeGVsU2l6ZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICBwaXhlbHM7XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgICAgICB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRlbXAuc3R5bGUuZm9udFNpemUgPSBzaXplO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGVtcCk7XG4gICAgICAgIHBpeGVscyA9IHBhcnNlRmxvYXQoRG9tRWxlbWVudC5nZXRTdHlsZXModGVtcCkuZm9udFNpemUpO1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGVtcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXhlbHMgPSBwYXJzZUZsb2F0KHBpeGVscyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwaXhlbHM7XG4gICAgfSxcbiAgICBnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uIChmb250LCBsaW5lcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCBCYXNlLmVhY2goWydyb3RhdGUnLCAnc2NhbGUnLCAnc2hlYXInLCAnc2tldyddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJvdGF0ZSA9IGtleSA9PT0gJ3JvdGF0ZSc7XG5cbiAgICB0aGlzW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICB2YWx1ZSA9IChyb3RhdGUgPyBCYXNlIDogUG9pbnQpLnJlYWQoYXJncyksXG4gICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZChhcmdzLCAwLCB7XG4gICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KClba2V5XSh2YWx1ZSwgY2VudGVyIHx8IHRoaXMuZ2V0Q2VudGVyKHRydWUpKSk7XG4gICAgfTtcbiAgfSwge1xuICAgIF9kZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvbXBvc2VkIHx8ICh0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpKTtcbiAgICB9LFxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG14ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG14LnRyYW5zbGF0ZS5hcHBseShteCwgYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xuICAgIH0sXG4gICAgc2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgdGhpcy50cmFuc2xhdGUodGhpcy5nZXRDZW50ZXIoKS5zdWJ0cmFjdChjZW50ZXIpKTtcbiAgICB9LFxuICAgIGdldFpvb206IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzY2FsaW5nID0gdGhpcy5fZGVjb21wb3NlKCkuc2NhbGluZztcblxuICAgICAgcmV0dXJuIChzY2FsaW5nLnggKyBzY2FsaW5nLnkpIC8gMjtcbiAgICB9LFxuICAgIHNldFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KCkuc2NhbGUoem9vbSAvIHRoaXMuZ2V0Wm9vbSgpLCB0aGlzLmdldENlbnRlcigpKSk7XG4gICAgfSxcbiAgICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlY29tcG9zZSgpLnJvdGF0aW9uO1xuICAgIH0sXG4gICAgc2V0Um90YXRpb246IGZ1bmN0aW9uIChyb3RhdGlvbikge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFJvdGF0aW9uKCk7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgcm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJvdGF0ZShyb3RhdGlvbiAtIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0U2NhbGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNjYWxpbmcgPSB0aGlzLl9kZWNvbXBvc2UoKS5zY2FsaW5nO1xuXG4gICAgICByZXR1cm4gbmV3IExpbmtlZFBvaW50KHNjYWxpbmcueCwgc2NhbGluZy55LCB0aGlzLCAnc2V0U2NhbGluZycpO1xuICAgIH0sXG4gICAgc2V0U2NhbGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFNjYWxpbmcoKSxcbiAgICAgICAgICBzY2FsaW5nID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHtcbiAgICAgICAgY2xvbmU6IHRydWUsXG4gICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGN1cnJlbnQgJiYgc2NhbGluZykge1xuICAgICAgICB0aGlzLnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldE1hdHJpeDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeDtcbiAgICB9LFxuICAgIHNldE1hdHJpeDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcbiAgICAgIG1hdHJpeC5zZXQuYXBwbHkobWF0cml4LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICB0aGlzLl9tYXRyaXguYXBwZW5kKG1hdHJpeCk7XG4gICAgfSxcbiAgICBzY3JvbGxCeTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFuc2xhdGUoUG9pbnQucmVhZChhcmd1bWVudHMpLm5lZ2F0ZSgpKTtcbiAgICB9XG4gIH0pLCB7XG4gICAgcHJvamVjdFRvVmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIHZpZXdUb1Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGdldEV2ZW50UG9pbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld1RvUHJvamVjdChEb21FdmVudC5nZXRPZmZzZXQoZXZlbnQsIHRoaXMuX2VsZW1lbnQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzdGF0aWNzOiB7XG4gICAgICBfdmlld3M6IFtdLFxuICAgICAgX3ZpZXdzQnlJZDoge30sXG4gICAgICBfaWQ6IDAsXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIChwcm9qZWN0LCBlbGVtZW50KSB7XG4gICAgICAgIGlmIChkb2N1bWVudCAmJiB0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcbiAgICAgICAgdmFyIGN0b3IgPSB3aW5kb3cgPyBDYW52YXNWaWV3IDogVmlldztcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHByb2plY3QsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXdpbmRvdykgcmV0dXJuO1xuICAgIHZhciBwcmV2Rm9jdXMsXG4gICAgICAgIHRlbXBGb2N1cyxcbiAgICAgICAgZHJhZ2dpbmcgPSBmYWxzZSxcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBnZXRWaWV3KGV2ZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gRG9tRXZlbnQuZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgIHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIFZpZXcuX3ZpZXdzQnlJZFt0YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVGb2N1cygpIHtcbiAgICAgIHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblxuICAgICAgaWYgKCF2aWV3IHx8ICF2aWV3LmlzVmlzaWJsZSgpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gVmlldy5fdmlld3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCh2aWV3ID0gVmlldy5fdmlld3NbaV0pLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICBWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdmlldztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCwgcG9pbnQpIHtcbiAgICAgIHZpZXcuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdXNlbW92ZScsIGV2ZW50LCBwb2ludCk7XG4gICAgfVxuXG4gICAgdmFyIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IsXG4gICAgICAgIG1vdXNlZG93bixcbiAgICAgICAgbW91c2Vtb3ZlLFxuICAgICAgICBtb3VzZXVwO1xuXG4gICAgaWYgKG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgbW91c2Vkb3duID0gJ3BvaW50ZXJkb3duIE1TUG9pbnRlckRvd24nO1xuICAgICAgbW91c2Vtb3ZlID0gJ3BvaW50ZXJtb3ZlIE1TUG9pbnRlck1vdmUnO1xuICAgICAgbW91c2V1cCA9ICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3VzZWRvd24gPSAndG91Y2hzdGFydCc7XG4gICAgICBtb3VzZW1vdmUgPSAndG91Y2htb3ZlJztcbiAgICAgIG1vdXNldXAgPSAndG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4gICAgICBpZiAoISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaSkpKSB7XG4gICAgICAgIG1vdXNlZG93biArPSAnIG1vdXNlZG93bic7XG4gICAgICAgIG1vdXNlbW92ZSArPSAnIG1vdXNlbW92ZSc7XG4gICAgICAgIG1vdXNldXAgKz0gJyBtb3VzZXVwJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmlld0V2ZW50cyA9IHt9LFxuICAgICAgICBkb2NFdmVudHMgPSB7XG4gICAgICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZCxcbiAgICAgICAgICAgIHRhcmdldCA9IERvbUV2ZW50LmdldFJlbGF0ZWRUYXJnZXQoZXZlbnQpO1xuXG4gICAgICAgIGlmICh2aWV3ICYmICghdGFyZ2V0IHx8IHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSBEb21FdmVudC5nZXRPZmZzZXQoZXZlbnQsIHZpZXcuX2VsZW1lbnQpLFxuICAgICAgICAgICAgICB4ID0gb2Zmc2V0LngsXG4gICAgICAgICAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgICBheCA9IGFicyh4KSxcbiAgICAgICAgICAgICAgbWF4ID0gMSA8PCAyNSxcbiAgICAgICAgICAgICAgZGlmZiA9IGF4IC0gbWF4O1xuICAgICAgICAgIG9mZnNldC54ID0gYWJzKGRpZmYpIDwgYXggPyBkaWZmICogKHggPCAwID8gLTEgOiAxKSA6IHg7XG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50LCB2aWV3LnZpZXdUb1Byb2plY3Qob2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzY3JvbGw6IHVwZGF0ZUZvY3VzXG4gICAgfTtcblxuICAgIHZpZXdFdmVudHNbbW91c2Vkb3duXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gZ2V0VmlldyhldmVudCk7XG5cbiAgICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgICAgZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIHZpZXcuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdXNlZG93bicsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jRXZlbnRzW21vdXNlbW92ZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblxuICAgICAgaWYgKCFtb3VzZURvd24pIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGdldFZpZXcoZXZlbnQpO1xuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICBpZiAodmlldyAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodmlldykgaGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghcHJldkZvY3VzKSBwcmV2Rm9jdXMgPSB2aWV3O1xuICAgICAgICAgICAgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSB0ZW1wRm9jdXMgPSB0YXJnZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRlbXBGb2N1cyAmJiB0ZW1wRm9jdXMgPT09IHZpZXcpIHtcbiAgICAgICAgICBpZiAocHJldkZvY3VzICYmICFwcmV2Rm9jdXMuaXNJbnNlcnRlZCgpKSBwcmV2Rm9jdXMgPSBudWxsO1xuICAgICAgICAgIHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gcHJldkZvY3VzO1xuICAgICAgICAgIHByZXZGb2N1cyA9IG51bGw7XG4gICAgICAgICAgdXBkYXRlRm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmlldykgaGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgZG9jRXZlbnRzW21vdXNlZG93bl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgIH07XG5cbiAgICBkb2NFdmVudHNbbW91c2V1cF0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcbiAgICAgIGlmICh2aWV3ICYmIGRyYWdnaW5nKSB2aWV3Ll9oYW5kbGVNb3VzZUV2ZW50KCdtb3VzZXVwJywgZXZlbnQpO1xuICAgICAgbW91c2VEb3duID0gZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgRG9tRXZlbnQuYWRkKGRvY3VtZW50LCBkb2NFdmVudHMpO1xuICAgIERvbUV2ZW50LmFkZCh3aW5kb3csIHtcbiAgICAgIGxvYWQ6IHVwZGF0ZUZvY3VzXG4gICAgfSk7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlLFxuICAgICAgICBwcmV2ZW50ZWQgPSBmYWxzZSxcbiAgICAgICAgZmFsbGJhY2tzID0ge1xuICAgICAgZG91YmxlY2xpY2s6ICdjbGljaycsXG4gICAgICBtb3VzZWRyYWc6ICdtb3VzZW1vdmUnXG4gICAgfSxcbiAgICAgICAgd2FzSW5WaWV3ID0gZmFsc2UsXG4gICAgICAgIG92ZXJWaWV3LFxuICAgICAgICBkb3duUG9pbnQsXG4gICAgICAgIGxhc3RQb2ludCxcbiAgICAgICAgZG93bkl0ZW0sXG4gICAgICAgIG92ZXJJdGVtLFxuICAgICAgICBkcmFnSXRlbSxcbiAgICAgICAgY2xpY2tJdGVtLFxuICAgICAgICBjbGlja1RpbWUsXG4gICAgICAgIGRibENsaWNrO1xuXG4gICAgZnVuY3Rpb24gZW1pdE1vdXNlRXZlbnQob2JqLCB0YXJnZXQsIHR5cGUsIGV2ZW50LCBwb2ludCwgcHJldlBvaW50LCBzdG9wSXRlbSkge1xuICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZSxcbiAgICAgICAgICBtb3VzZUV2ZW50O1xuXG4gICAgICBmdW5jdGlvbiBlbWl0KG9iaiwgdHlwZSkge1xuICAgICAgICBpZiAob2JqLnJlc3BvbmRzKHR5cGUpKSB7XG4gICAgICAgICAgaWYgKCFtb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICBtb3VzZUV2ZW50ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQgfHwgb2JqLCBwcmV2UG9pbnQgPyBwb2ludC5zdWJ0cmFjdChwcmV2UG9pbnQpIDogbnVsbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9iai5lbWl0KHR5cGUsIG1vdXNlRXZlbnQpKSB7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG1vdXNlRXZlbnQucHJldmVudGVkKSBwcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG1vdXNlRXZlbnQuc3RvcHBlZCkgcmV0dXJuIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmFsbGJhY2sgPSBmYWxsYmFja3NbdHlwZV07XG4gICAgICAgICAgaWYgKGZhbGxiYWNrKSByZXR1cm4gZW1pdChvYmosIGZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAob2JqICYmIG9iaiAhPT0gc3RvcEl0ZW0pIHtcbiAgICAgICAgaWYgKGVtaXQob2JqLCB0eXBlKSkgYnJlYWs7XG4gICAgICAgIG9iaiA9IG9iai5fcGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcHBlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0TW91c2VFdmVudHModmlldywgaGl0SXRlbSwgdHlwZSwgZXZlbnQsIHBvaW50LCBwcmV2UG9pbnQpIHtcbiAgICAgIHZpZXcuX3Byb2plY3QucmVtb3ZlT24odHlwZSk7XG5cbiAgICAgIHByZXZlbnRlZCA9IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGRyYWdJdGVtICYmIGVtaXRNb3VzZUV2ZW50KGRyYWdJdGVtLCBudWxsLCB0eXBlLCBldmVudCwgcG9pbnQsIHByZXZQb2ludCkgfHwgaGl0SXRlbSAmJiBoaXRJdGVtICE9PSBkcmFnSXRlbSAmJiAhaGl0SXRlbS5pc0Rlc2NlbmRhbnQoZHJhZ0l0ZW0pICYmIGVtaXRNb3VzZUV2ZW50KGhpdEl0ZW0sIG51bGwsIHR5cGUgPT09ICdtb3VzZWRyYWcnID8gJ21vdXNlbW92ZScgOiB0eXBlLCBldmVudCwgcG9pbnQsIHByZXZQb2ludCwgZHJhZ0l0ZW0pIHx8IGVtaXRNb3VzZUV2ZW50KHZpZXcsIGRyYWdJdGVtIHx8IGhpdEl0ZW0gfHwgdmlldywgdHlwZSwgZXZlbnQsIHBvaW50LCBwcmV2UG9pbnQpO1xuICAgIH1cblxuICAgIHZhciBpdGVtRXZlbnRzTWFwID0ge1xuICAgICAgbW91c2Vkb3duOiB7XG4gICAgICAgIG1vdXNlZG93bjogMSxcbiAgICAgICAgbW91c2VkcmFnOiAxLFxuICAgICAgICBjbGljazogMSxcbiAgICAgICAgZG91YmxlY2xpY2s6IDFcbiAgICAgIH0sXG4gICAgICBtb3VzZXVwOiB7XG4gICAgICAgIG1vdXNldXA6IDEsXG4gICAgICAgIG1vdXNlZHJhZzogMSxcbiAgICAgICAgY2xpY2s6IDEsXG4gICAgICAgIGRvdWJsZWNsaWNrOiAxXG4gICAgICB9LFxuICAgICAgbW91c2Vtb3ZlOiB7XG4gICAgICAgIG1vdXNlZHJhZzogMSxcbiAgICAgICAgbW91c2Vtb3ZlOiAxLFxuICAgICAgICBtb3VzZWVudGVyOiAxLFxuICAgICAgICBtb3VzZWxlYXZlOiAxXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgX3ZpZXdFdmVudHM6IHZpZXdFdmVudHMsXG4gICAgICBfaGFuZGxlTW91c2VFdmVudDogZnVuY3Rpb24gKHR5cGUsIGV2ZW50LCBwb2ludCkge1xuICAgICAgICB2YXIgaXRlbUV2ZW50cyA9IHRoaXMuX2l0ZW1FdmVudHMsXG4gICAgICAgICAgICBoaXRJdGVtcyA9IGl0ZW1FdmVudHMubmF0aXZlW3R5cGVdLFxuICAgICAgICAgICAgbmF0aXZlTW92ZSA9IHR5cGUgPT09ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgdG9vbCA9IHRoaXMuX3Njb3BlLnRvb2wsXG4gICAgICAgICAgICB2aWV3ID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiByZXNwb25kcyh0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1FdmVudHMudmlydHVhbFt0eXBlXSB8fCB2aWV3LnJlc3BvbmRzKHR5cGUpIHx8IHRvb2wgJiYgdG9vbC5yZXNwb25kcyh0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYXRpdmVNb3ZlICYmIGRyYWdnaW5nICYmIHJlc3BvbmRzKCdtb3VzZWRyYWcnKSkgdHlwZSA9ICdtb3VzZWRyYWcnO1xuICAgICAgICBpZiAoIXBvaW50KSBwb2ludCA9IHRoaXMuZ2V0RXZlbnRQb2ludChldmVudCk7XG5cbiAgICAgICAgdmFyIGluVmlldyA9IHRoaXMuZ2V0Qm91bmRzKCkuY29udGFpbnMocG9pbnQpLFxuICAgICAgICAgICAgaGl0ID0gaGl0SXRlbXMgJiYgaW5WaWV3ICYmIHZpZXcuX3Byb2plY3QuaGl0VGVzdChwb2ludCwge1xuICAgICAgICAgIHRvbGVyYW5jZTogMCxcbiAgICAgICAgICBmaWxsOiB0cnVlLFxuICAgICAgICAgIHN0cm9rZTogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgICAgIGhpdEl0ZW0gPSBoaXQgJiYgaGl0Lml0ZW0gfHwgbnVsbCxcbiAgICAgICAgICAgIGhhbmRsZSA9IGZhbHNlLFxuICAgICAgICAgICAgbW91c2UgPSB7fTtcblxuICAgICAgICBtb3VzZVt0eXBlLnN1YnN0cig1KV0gPSB0cnVlO1xuXG4gICAgICAgIGlmIChoaXRJdGVtcyAmJiBoaXRJdGVtICE9PSBvdmVySXRlbSkge1xuICAgICAgICAgIGlmIChvdmVySXRlbSkge1xuICAgICAgICAgICAgZW1pdE1vdXNlRXZlbnQob3Zlckl0ZW0sIG51bGwsICdtb3VzZWxlYXZlJywgZXZlbnQsIHBvaW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGl0SXRlbSkge1xuICAgICAgICAgICAgZW1pdE1vdXNlRXZlbnQoaGl0SXRlbSwgbnVsbCwgJ21vdXNlZW50ZXInLCBldmVudCwgcG9pbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG92ZXJJdGVtID0gaGl0SXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3YXNJblZpZXcgXiBpblZpZXcpIHtcbiAgICAgICAgICBlbWl0TW91c2VFdmVudCh0aGlzLCBudWxsLCBpblZpZXcgPyAnbW91c2VlbnRlcicgOiAnbW91c2VsZWF2ZScsIGV2ZW50LCBwb2ludCk7XG4gICAgICAgICAgb3ZlclZpZXcgPSBpblZpZXcgPyB0aGlzIDogbnVsbDtcbiAgICAgICAgICBoYW5kbGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChpblZpZXcgfHwgbW91c2UuZHJhZykgJiYgIXBvaW50LmVxdWFscyhsYXN0UG9pbnQpKSB7XG4gICAgICAgICAgZW1pdE1vdXNlRXZlbnRzKHRoaXMsIGhpdEl0ZW0sIG5hdGl2ZU1vdmUgPyB0eXBlIDogJ21vdXNlbW92ZScsIGV2ZW50LCBwb2ludCwgbGFzdFBvaW50KTtcbiAgICAgICAgICBoYW5kbGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FzSW5WaWV3ID0gaW5WaWV3O1xuXG4gICAgICAgIGlmIChtb3VzZS5kb3duICYmIGluVmlldyB8fCBtb3VzZS51cCAmJiBkb3duUG9pbnQpIHtcbiAgICAgICAgICBlbWl0TW91c2VFdmVudHModGhpcywgaGl0SXRlbSwgdHlwZSwgZXZlbnQsIHBvaW50LCBkb3duUG9pbnQpO1xuXG4gICAgICAgICAgaWYgKG1vdXNlLmRvd24pIHtcbiAgICAgICAgICAgIGRibENsaWNrID0gaGl0SXRlbSA9PT0gY2xpY2tJdGVtICYmIERhdGUubm93KCkgLSBjbGlja1RpbWUgPCAzMDA7XG4gICAgICAgICAgICBkb3duSXRlbSA9IGNsaWNrSXRlbSA9IGhpdEl0ZW07XG5cbiAgICAgICAgICAgIGlmICghcHJldmVudGVkICYmIGhpdEl0ZW0pIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBoaXRJdGVtO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChpdGVtICYmICFpdGVtLnJlc3BvbmRzKCdtb3VzZWRyYWcnKSkgaXRlbSA9IGl0ZW0uX3BhcmVudDtcblxuICAgICAgICAgICAgICBpZiAoaXRlbSkgZHJhZ0l0ZW0gPSBoaXRJdGVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb3duUG9pbnQgPSBwb2ludDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1vdXNlLnVwKSB7XG4gICAgICAgICAgICBpZiAoIXByZXZlbnRlZCAmJiBoaXRJdGVtID09PSBkb3duSXRlbSkge1xuICAgICAgICAgICAgICBjbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICBlbWl0TW91c2VFdmVudHModGhpcywgaGl0SXRlbSwgZGJsQ2xpY2sgPyAnZG91YmxlY2xpY2snIDogJ2NsaWNrJywgZXZlbnQsIHBvaW50LCBkb3duUG9pbnQpO1xuICAgICAgICAgICAgICBkYmxDbGljayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb3duSXRlbSA9IGRyYWdJdGVtID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3YXNJblZpZXcgPSBmYWxzZTtcbiAgICAgICAgICBoYW5kbGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XG5cbiAgICAgICAgaWYgKGhhbmRsZSAmJiB0b29sKSB7XG4gICAgICAgICAgY2FsbGVkID0gdG9vbC5faGFuZGxlTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIG1vdXNlKSB8fCBjYWxsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSAhPT0gZmFsc2UgJiYgKGNhbGxlZCAmJiAhbW91c2UubW92ZSB8fCBtb3VzZS5kb3duICYmIHJlc3BvbmRzKCdtb3VzZXVwJykpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9oYW5kbGVLZXlFdmVudDogZnVuY3Rpb24gKHR5cGUsIGV2ZW50LCBrZXksIGNoYXJhY3Rlcikge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSxcbiAgICAgICAgICAgIHRvb2wgPSBzY29wZS50b29sLFxuICAgICAgICAgICAga2V5RXZlbnQ7XG5cbiAgICAgICAgZnVuY3Rpb24gZW1pdChvYmopIHtcbiAgICAgICAgICBpZiAob2JqLnJlc3BvbmRzKHR5cGUpKSB7XG4gICAgICAgICAgICBwYXBlciA9IHNjb3BlO1xuICAgICAgICAgICAgb2JqLmVtaXQodHlwZSwga2V5RXZlbnQgPSBrZXlFdmVudCB8fCBuZXcgS2V5RXZlbnQodHlwZSwgZXZlbnQsIGtleSwgY2hhcmFjdGVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICBlbWl0KHRoaXMpO1xuICAgICAgICAgIGlmICh0b29sICYmIHRvb2wucmVzcG9uZHModHlwZSkpIGVtaXQodG9vbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY291bnRJdGVtRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBzaWduKSB7XG4gICAgICAgIHZhciBpdGVtRXZlbnRzID0gdGhpcy5faXRlbUV2ZW50cyxcbiAgICAgICAgICAgIG5hdGl2ZSA9IGl0ZW1FdmVudHMubmF0aXZlLFxuICAgICAgICAgICAgdmlydHVhbCA9IGl0ZW1FdmVudHMudmlydHVhbDtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaXRlbUV2ZW50c01hcCkge1xuICAgICAgICAgIG5hdGl2ZVtrZXldID0gKG5hdGl2ZVtrZXldIHx8IDApICsgKGl0ZW1FdmVudHNNYXBba2V5XVt0eXBlXSB8fCAwKSAqIHNpZ247XG4gICAgICAgIH1cblxuICAgICAgICB2aXJ0dWFsW3R5cGVdID0gKHZpcnR1YWxbdHlwZV0gfHwgMCkgKyBzaWduO1xuICAgICAgfSxcbiAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgdXBkYXRlRm9jdXM6IHVwZGF0ZUZvY3VzLFxuICAgICAgICBfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRyYWdnaW5nID0gbW91c2VEb3duID0gY2FsbGVkID0gd2FzSW5WaWV3ID0gZmFsc2U7XG4gICAgICAgICAgcHJldkZvY3VzID0gdGVtcEZvY3VzID0gb3ZlclZpZXcgPSBkb3duUG9pbnQgPSBsYXN0UG9pbnQgPSBkb3duSXRlbSA9IG92ZXJJdGVtID0gZHJhZ0l0ZW0gPSBjbGlja0l0ZW0gPSBjbGlja1RpbWUgPSBkYmxDbGljayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KCkpO1xuICB2YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdDYW52YXNWaWV3JyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBDYW52YXNWaWV3KHByb2plY3QsIGNhbnZhcykge1xuICAgICAgaWYgKCEoY2FudmFzIGluc3RhbmNlb2Ygd2luZG93LkhUTUxDYW52YXNFbGVtZW50KSkge1xuICAgICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMsIDEpO1xuICAgICAgICBpZiAoc2l6ZS5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIENhbnZhc1ZpZXcgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQ6ICcgKyBCYXNlLnNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICBjYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fcGl4ZWxSYXRpbyA9IDE7XG5cbiAgICAgIGlmICghL15vZmZ8ZmFsc2UkLy50ZXN0KFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGNhbnZhcywgJ2hpZHBpJykpKSB7XG4gICAgICAgIHZhciBkZXZpY2VSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG4gICAgICAgICAgICBiYWNraW5nU3RvcmVSYXRpbyA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQoY3R4LCAnYmFja2luZ1N0b3JlUGl4ZWxSYXRpbycpIHx8IDE7XG4gICAgICAgIHRoaXMuX3BpeGVsUmF0aW8gPSBkZXZpY2VSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgfVxuXG4gICAgICBWaWV3LmNhbGwodGhpcywgcHJvamVjdCwgY2FudmFzKTtcbiAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdGhpcy5fY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiByZW1vdmUuYmFzZS5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgX3NldEVsZW1lbnRTaXplOiBmdW5jdGlvbiBfc2V0RWxlbWVudFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLl9waXhlbFJhdGlvO1xuXG4gICAgICBfc2V0RWxlbWVudFNpemUuYmFzZS5jYWxsKHRoaXMsIHdpZHRoICogcGl4ZWxSYXRpbywgaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG5cbiAgICAgIGlmIChwaXhlbFJhdGlvICE9PSAxKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICAgICAgaWYgKCFQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAncmVzaXplJykpIHtcbiAgICAgICAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgICB9LFxuICAgIGdldFBpeGVsU2l6ZTogZnVuY3Rpb24gZ2V0UGl4ZWxTaXplKHNpemUpIHtcbiAgICAgIHZhciBhZ2VudCA9IHBhcGVyLmFnZW50LFxuICAgICAgICAgIHBpeGVscztcblxuICAgICAgaWYgKGFnZW50ICYmIGFnZW50LmZpcmVmb3gpIHtcbiAgICAgICAgcGl4ZWxzID0gZ2V0UGl4ZWxTaXplLmJhc2UuY2FsbCh0aGlzLCBzaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuICAgICAgICAgICAgcHJldkZvbnQgPSBjdHguZm9udDtcbiAgICAgICAgY3R4LmZvbnQgPSBzaXplICsgJyBzZXJpZic7XG4gICAgICAgIHBpeGVscyA9IHBhcnNlRmxvYXQoY3R4LmZvbnQpO1xuICAgICAgICBjdHguZm9udCA9IHByZXZGb250O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGl4ZWxzO1xuICAgIH0sXG4gICAgZ2V0VGV4dFdpZHRoOiBmdW5jdGlvbiAoZm9udCwgbGluZXMpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuICAgICAgICAgIHByZXZGb250ID0gY3R4LmZvbnQsXG4gICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgY3R4LmZvbnQgPSBmb250O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aCk7XG5cbiAgICAgIGN0eC5mb250ID0gcHJldkZvbnQ7XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fbmVlZHNVcGRhdGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcbiAgICAgICAgICBjdHggPSB0aGlzLl9jb250ZXh0LFxuICAgICAgICAgIHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCArIDEsIHNpemUuaGVpZ2h0ICsgMSk7XG4gICAgICBpZiAocHJvamVjdCkgcHJvamVjdC5kcmF3KGN0eCwgdGhpcy5fbWF0cml4LCB0aGlzLl9waXhlbFJhdGlvKTtcbiAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgRXZlbnQgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnRXZlbnQnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEV2ZW50KGV2ZW50KSB7XG4gICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICB0aGlzLnR5cGUgPSBldmVudCAmJiBldmVudC50eXBlO1xuICAgIH0sXG4gICAgcHJldmVudGVkOiBmYWxzZSxcbiAgICBzdG9wcGVkOiBmYWxzZSxcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgdGhpcy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcbiAgICBnZXRUaW1lU3RhbXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50LnRpbWVTdGFtcDtcbiAgICB9LFxuICAgIGdldE1vZGlmaWVyczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEtleS5tb2RpZmllcnM7XG4gICAgfVxuICB9KTtcbiAgdmFyIEtleUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdLZXlFdmVudCcsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gS2V5RXZlbnQodHlwZSwgZXZlbnQsIGtleSwgY2hhcmFjdGVyKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IGNoYXJhY3RlcjtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJ7IHR5cGU6ICdcIiArIHRoaXMudHlwZSArIFwiJywga2V5OiAnXCIgKyB0aGlzLmtleSArIFwiJywgY2hhcmFjdGVyOiAnXCIgKyB0aGlzLmNoYXJhY3RlciArIFwiJywgbW9kaWZpZXJzOiBcIiArIHRoaXMuZ2V0TW9kaWZpZXJzKCkgKyBcIiB9XCI7XG4gICAgfVxuICB9KTtcbiAgdmFyIEtleSA9IG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleUxvb2t1cCA9IHtcbiAgICAgICdcXHQnOiAndGFiJyxcbiAgICAgICcgJzogJ3NwYWNlJyxcbiAgICAgICdcXGInOiAnYmFja3NwYWNlJyxcbiAgICAgICdcXHg3Zic6ICdkZWxldGUnLFxuICAgICAgJ1NwYWNlYmFyJzogJ3NwYWNlJyxcbiAgICAgICdEZWwnOiAnZGVsZXRlJyxcbiAgICAgICdXaW4nOiAnbWV0YScsXG4gICAgICAnRXNjJzogJ2VzY2FwZSdcbiAgICB9LFxuICAgICAgICBjaGFyTG9va3VwID0ge1xuICAgICAgJ3RhYic6ICdcXHQnLFxuICAgICAgJ3NwYWNlJzogJyAnLFxuICAgICAgJ2VudGVyJzogJ1xccidcbiAgICB9LFxuICAgICAgICBrZXlNYXAgPSB7fSxcbiAgICAgICAgY2hhck1hcCA9IHt9LFxuICAgICAgICBtZXRhRml4TWFwLFxuICAgICAgICBkb3duS2V5LFxuICAgICAgICBtb2RpZmllcnMgPSBuZXcgQmFzZSh7XG4gICAgICBzaGlmdDogZmFsc2UsXG4gICAgICBjb250cm9sOiBmYWxzZSxcbiAgICAgIGFsdDogZmFsc2UsXG4gICAgICBtZXRhOiBmYWxzZSxcbiAgICAgIGNhcHNMb2NrOiBmYWxzZSxcbiAgICAgIHNwYWNlOiBmYWxzZVxuICAgIH0pLmluamVjdCh7XG4gICAgICBvcHRpb246IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWx0O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29tbWFuZDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYWdlbnQgPSBwYXBlciAmJiBwYXBlci5hZ2VudDtcbiAgICAgICAgICByZXR1cm4gYWdlbnQgJiYgYWdlbnQubWFjID8gdGhpcy5tZXRhIDogdGhpcy5jb250cm9sO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnZXRLZXkoZXZlbnQpIHtcbiAgICAgIHZhciBrZXkgPSBldmVudC5rZXkgfHwgZXZlbnQua2V5SWRlbnRpZmllcjtcbiAgICAgIGtleSA9IC9eVVxcKy8udGVzdChrZXkpID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChrZXkuc3Vic3RyKDIpLCAxNikpIDogL15BcnJvd1tBLVpdLy50ZXN0KGtleSkgPyBrZXkuc3Vic3RyKDUpIDoga2V5ID09PSAnVW5pZGVudGlmaWVkJyB8fCBrZXkgPT09IHVuZGVmaW5lZCA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQua2V5Q29kZSkgOiBrZXk7XG4gICAgICByZXR1cm4ga2V5TG9va3VwW2tleV0gfHwgKGtleS5sZW5ndGggPiAxID8gQmFzZS5oeXBoZW5hdGUoa2V5KSA6IGtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVLZXkoZG93biwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnLFxuICAgICAgICAgIHZpZXcgPSBWaWV3Ll9mb2N1c2VkLFxuICAgICAgICAgIG5hbWU7XG4gICAgICBrZXlNYXBba2V5XSA9IGRvd247XG5cbiAgICAgIGlmIChkb3duKSB7XG4gICAgICAgIGNoYXJNYXBba2V5XSA9IGNoYXJhY3RlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBjaGFyTWFwW2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkubGVuZ3RoID4gMSAmJiAobmFtZSA9IEJhc2UuY2FtZWxpemUoa2V5KSkgaW4gbW9kaWZpZXJzKSB7XG4gICAgICAgIG1vZGlmaWVyc1tuYW1lXSA9IGRvd247XG4gICAgICAgIHZhciBhZ2VudCA9IHBhcGVyICYmIHBhcGVyLmFnZW50O1xuXG4gICAgICAgIGlmIChuYW1lID09PSAnbWV0YScgJiYgYWdlbnQgJiYgYWdlbnQubWFjKSB7XG4gICAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICAgIG1ldGFGaXhNYXAgPSB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBtZXRhRml4TWFwKSB7XG4gICAgICAgICAgICAgIGlmIChrIGluIGNoYXJNYXApIGhhbmRsZUtleShmYWxzZSwgaywgbWV0YUZpeE1hcFtrXSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZXRhRml4TWFwID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZG93biAmJiBtZXRhRml4TWFwKSB7XG4gICAgICAgIG1ldGFGaXhNYXBba2V5XSA9IGNoYXJhY3RlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgdmlldy5faGFuZGxlS2V5RXZlbnQoZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCcsIGV2ZW50LCBrZXksIGNoYXJhY3Rlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRG9tRXZlbnQuYWRkKGRvY3VtZW50LCB7XG4gICAgICBrZXlkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IGdldEtleShldmVudCksXG4gICAgICAgICAgICBhZ2VudCA9IHBhcGVyICYmIHBhcGVyLmFnZW50O1xuXG4gICAgICAgIGlmIChrZXkubGVuZ3RoID4gMSB8fCBhZ2VudCAmJiBhZ2VudC5jaHJvbWUgJiYgKGV2ZW50LmFsdEtleSB8fCBhZ2VudC5tYWMgJiYgZXZlbnQubWV0YUtleSB8fCAhYWdlbnQubWFjICYmIGV2ZW50LmN0cmxLZXkpKSB7XG4gICAgICAgICAgaGFuZGxlS2V5KHRydWUsIGtleSwgY2hhckxvb2t1cFtrZXldIHx8IChrZXkubGVuZ3RoID4gMSA/ICcnIDoga2V5KSwgZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvd25LZXkgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBrZXlwcmVzczogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChkb3duS2V5KSB7XG4gICAgICAgICAgdmFyIGtleSA9IGdldEtleShldmVudCksXG4gICAgICAgICAgICAgIGNvZGUgPSBldmVudC5jaGFyQ29kZSxcbiAgICAgICAgICAgICAgY2hhcmFjdGVyID0gY29kZSA+PSAzMiA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgOiBrZXkubGVuZ3RoID4gMSA/ICcnIDoga2V5O1xuXG4gICAgICAgICAgaWYgKGtleSAhPT0gZG93bktleSkge1xuICAgICAgICAgICAga2V5ID0gY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlS2V5KHRydWUsIGtleSwgY2hhcmFjdGVyLCBldmVudCk7XG4gICAgICAgICAgZG93bktleSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBrZXl1cDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBnZXRLZXkoZXZlbnQpO1xuICAgICAgICBpZiAoa2V5IGluIGNoYXJNYXApIGhhbmRsZUtleShmYWxzZSwga2V5LCBjaGFyTWFwW2tleV0sIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBEb21FdmVudC5hZGQod2luZG93LCB7XG4gICAgICBibHVyOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNoYXJNYXApIGhhbmRsZUtleShmYWxzZSwga2V5LCBjaGFyTWFwW2tleV0sIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICBpc0Rvd246IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEha2V5TWFwW2tleV07XG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuICB2YXIgTW91c2VFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnTW91c2VFdmVudCcsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCwgZGVsdGEpIHtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRoaXMuZGVsdGEgPSBkZWx0YTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJ7IHR5cGU6ICdcIiArIHRoaXMudHlwZSArIFwiJywgcG9pbnQ6IFwiICsgdGhpcy5wb2ludCArICcsIHRhcmdldDogJyArIHRoaXMudGFyZ2V0ICsgKHRoaXMuZGVsdGEgPyAnLCBkZWx0YTogJyArIHRoaXMuZGVsdGEgOiAnJykgKyAnLCBtb2RpZmllcnM6ICcgKyB0aGlzLmdldE1vZGlmaWVycygpICsgJyB9JztcbiAgICB9XG4gIH0pO1xuICB2YXIgVG9vbEV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdUb29sRXZlbnQnLFxuICAgIF9pdGVtOiBudWxsLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2xFdmVudCh0b29sLCB0eXBlLCBldmVudCkge1xuICAgICAgdGhpcy50b29sID0gdG9vbDtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgfSxcbiAgICBfY2hvb3NlUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCwgdG9vbFBvaW50KSB7XG4gICAgICByZXR1cm4gcG9pbnQgPyBwb2ludCA6IHRvb2xQb2ludCA/IHRvb2xQb2ludC5jbG9uZSgpIDogbnVsbDtcbiAgICB9LFxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fcG9pbnQsIHRoaXMudG9vbC5fcG9pbnQpO1xuICAgIH0sXG4gICAgc2V0UG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdGhpcy5fcG9pbnQgPSBwb2ludDtcbiAgICB9LFxuICAgIGdldExhc3RQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2xhc3RQb2ludCwgdGhpcy50b29sLl9sYXN0UG9pbnQpO1xuICAgIH0sXG4gICAgc2V0TGFzdFBvaW50OiBmdW5jdGlvbiAobGFzdFBvaW50KSB7XG4gICAgICB0aGlzLl9sYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG4gICAgfSxcbiAgICBnZXREb3duUG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9kb3duUG9pbnQsIHRoaXMudG9vbC5fZG93blBvaW50KTtcbiAgICB9LFxuICAgIHNldERvd25Qb2ludDogZnVuY3Rpb24gKGRvd25Qb2ludCkge1xuICAgICAgdGhpcy5fZG93blBvaW50ID0gZG93blBvaW50O1xuICAgIH0sXG4gICAgZ2V0TWlkZGxlUG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fbWlkZGxlUG9pbnQgJiYgdGhpcy50b29sLl9sYXN0UG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbC5fcG9pbnQuYWRkKHRoaXMudG9vbC5fbGFzdFBvaW50KS5kaXZpZGUoMik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9taWRkbGVQb2ludDtcbiAgICB9LFxuICAgIHNldE1pZGRsZVBvaW50OiBmdW5jdGlvbiAobWlkZGxlUG9pbnQpIHtcbiAgICAgIHRoaXMuX21pZGRsZVBvaW50ID0gbWlkZGxlUG9pbnQ7XG4gICAgfSxcbiAgICBnZXREZWx0YTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9kZWx0YSAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludCA/IHRoaXMudG9vbC5fcG9pbnQuc3VidHJhY3QodGhpcy50b29sLl9sYXN0UG9pbnQpIDogdGhpcy5fZGVsdGE7XG4gICAgfSxcbiAgICBzZXREZWx0YTogZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICB0aGlzLl9kZWx0YSA9IGRlbHRhO1xuICAgIH0sXG4gICAgZ2V0Q291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvb2xbL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKSA/ICdfZG93bkNvdW50JyA6ICdfbW92ZUNvdW50J107XG4gICAgfSxcbiAgICBzZXRDb3VudDogZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICB0aGlzLnRvb2xbL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKSA/ICdkb3duQ291bnQnIDogJ2NvdW50J10gPSBjb3VudDtcbiAgICB9LFxuICAgIGdldEl0ZW06IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5faXRlbSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy50b29sLl9zY29wZS5wcm9qZWN0LmhpdFRlc3QodGhpcy5nZXRQb2ludCgpKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSByZXN1bHQuaXRlbSxcbiAgICAgICAgICAgICAgcGFyZW50ID0gaXRlbS5fcGFyZW50O1xuXG4gICAgICAgICAgd2hpbGUgKC9eKEdyb3VwfENvbXBvdW5kUGF0aCkkLy50ZXN0KHBhcmVudC5fY2xhc3MpKSB7XG4gICAgICAgICAgICBpdGVtID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5faXRlbSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2l0ZW07XG4gICAgfSxcbiAgICBzZXRJdGVtOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdGhpcy5faXRlbSA9IGl0ZW07XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICd7IHR5cGU6ICcgKyB0aGlzLnR5cGUgKyAnLCBwb2ludDogJyArIHRoaXMuZ2V0UG9pbnQoKSArICcsIGNvdW50OiAnICsgdGhpcy5nZXRDb3VudCgpICsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKSArICcgfSc7XG4gICAgfVxuICB9KTtcbiAgdmFyIFRvb2wgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1Rvb2wnLFxuICAgIF9saXN0OiAndG9vbHMnLFxuICAgIF9yZWZlcmVuY2U6ICd0b29sJyxcbiAgICBfZXZlbnRzOiBbJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbk1vdXNlTW92ZScsICdvbkFjdGl2YXRlJywgJ29uRGVhY3RpdmF0ZScsICdvbkVkaXRPcHRpb25zJywgJ29uS2V5RG93bicsICdvbktleVVwJ10sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gVG9vbChwcm9wcykge1xuICAgICAgUGFwZXJTY29wZUl0ZW0uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuX21vdmVDb3VudCA9IC0xO1xuICAgICAgdGhpcy5fZG93bkNvdW50ID0gLTE7XG4gICAgICB0aGlzLnNldChwcm9wcyk7XG4gICAgfSxcbiAgICBnZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlO1xuICAgIH0sXG4gICAgc2V0TWluRGlzdGFuY2U6IGZ1bmN0aW9uIChtaW5EaXN0YW5jZSkge1xuICAgICAgdGhpcy5fbWluRGlzdGFuY2UgPSBtaW5EaXN0YW5jZTtcblxuICAgICAgaWYgKG1pbkRpc3RhbmNlICE9IG51bGwgJiYgdGhpcy5fbWF4RGlzdGFuY2UgIT0gbnVsbCAmJiBtaW5EaXN0YW5jZSA+IHRoaXMuX21heERpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX21heERpc3RhbmNlID0gbWluRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21heERpc3RhbmNlO1xuICAgIH0sXG4gICAgc2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uIChtYXhEaXN0YW5jZSkge1xuICAgICAgdGhpcy5fbWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcblxuICAgICAgaWYgKHRoaXMuX21pbkRpc3RhbmNlICE9IG51bGwgJiYgbWF4RGlzdGFuY2UgIT0gbnVsbCAmJiBtYXhEaXN0YW5jZSA8IHRoaXMuX21pbkRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX21pbkRpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWluRGlzdGFuY2UgPT0gdGhpcy5fbWF4RGlzdGFuY2UgPyB0aGlzLl9taW5EaXN0YW5jZSA6IG51bGw7XG4gICAgfSxcbiAgICBzZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbiAoZGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX21pbkRpc3RhbmNlID0gdGhpcy5fbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9LFxuICAgIF9oYW5kbGVNb3VzZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZXZlbnQsIHBvaW50LCBtb3VzZSkge1xuICAgICAgcGFwZXIgPSB0aGlzLl9zY29wZTtcbiAgICAgIGlmIChtb3VzZS5kcmFnICYmICF0aGlzLnJlc3BvbmRzKHR5cGUpKSB0eXBlID0gJ21vdXNlbW92ZSc7XG4gICAgICB2YXIgbW92ZSA9IG1vdXNlLm1vdmUgfHwgbW91c2UuZHJhZyxcbiAgICAgICAgICByZXNwb25kcyA9IHRoaXMucmVzcG9uZHModHlwZSksXG4gICAgICAgICAgbWluRGlzdGFuY2UgPSB0aGlzLm1pbkRpc3RhbmNlLFxuICAgICAgICAgIG1heERpc3RhbmNlID0gdGhpcy5tYXhEaXN0YW5jZSxcbiAgICAgICAgICBjYWxsZWQgPSBmYWxzZSxcbiAgICAgICAgICB0b29sID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSkge1xuICAgICAgICB2YXIgcHQgPSBwb2ludCxcbiAgICAgICAgICAgIHRvb2xQb2ludCA9IG1vdmUgPyB0b29sLl9wb2ludCA6IHRvb2wuX2Rvd25Qb2ludCB8fCBwdDtcblxuICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgIGlmICh0b29sLl9tb3ZlQ291bnQgPj0gMCAmJiBwdC5lcXVhbHModG9vbFBvaW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b29sUG9pbnQgJiYgKG1pbkRpc3RhbmNlICE9IG51bGwgfHwgbWF4RGlzdGFuY2UgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBwdC5zdWJ0cmFjdCh0b29sUG9pbnQpLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gdmVjdG9yLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgKG1pbkRpc3RhbmNlIHx8IDApKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChtYXhEaXN0YW5jZSkge1xuICAgICAgICAgICAgICBwdCA9IHRvb2xQb2ludC5hZGQodmVjdG9yLm5vcm1hbGl6ZShNYXRoLm1pbihkaXN0YW5jZSwgbWF4RGlzdGFuY2UpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9vbC5fbW92ZUNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICB0b29sLl9wb2ludCA9IHB0O1xuICAgICAgICB0b29sLl9sYXN0UG9pbnQgPSB0b29sUG9pbnQgfHwgcHQ7XG5cbiAgICAgICAgaWYgKG1vdXNlLmRvd24pIHtcbiAgICAgICAgICB0b29sLl9tb3ZlQ291bnQgPSAtMTtcbiAgICAgICAgICB0b29sLl9kb3duUG9pbnQgPSBwdDtcbiAgICAgICAgICB0b29sLl9kb3duQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbWl0KCkge1xuICAgICAgICBpZiAocmVzcG9uZHMpIHtcbiAgICAgICAgICBjYWxsZWQgPSB0b29sLmVtaXQodHlwZSwgbmV3IFRvb2xFdmVudCh0b29sLCB0eXBlLCBldmVudCkpIHx8IGNhbGxlZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobW91c2UuZG93bikge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgZW1pdCgpO1xuICAgICAgfSBlbHNlIGlmIChtb3VzZS51cCkge1xuICAgICAgICB1cGRhdGUobnVsbCwgbWF4RGlzdGFuY2UpO1xuICAgICAgICBlbWl0KCk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbmRzKSB7XG4gICAgICAgIHdoaWxlICh1cGRhdGUobWluRGlzdGFuY2UsIG1heERpc3RhbmNlKSkgZW1pdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbGVkO1xuICAgIH1cbiAgfSk7XG4gIHZhciBUd2VlbiA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcbiAgICBfY2xhc3M6ICdUd2VlbicsXG4gICAgc3RhdGljczoge1xuICAgICAgZWFzaW5nczoge1xuICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgKiB0O1xuICAgICAgICB9LFxuICAgICAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCAqICgyIC0gdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgPCAwLjUgPyAyICogdCAqIHQgOiAtMSArIDIgKiAoMiAtIHQpICogdDtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAtLXQgKiB0ICogdCArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0IDwgMC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIC0tdCAqIHQgKiB0ICogdDtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgPCAwLjUgPyA4ICogdCAqIHQgKiB0ICogdCA6IDEgLSA4ICogLS10ICogdCAqIHQgKiB0O1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5RdWludDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VPdXRRdWludDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gMSArIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0IDwgMC41ID8gMTYgKiB0ICogdCAqIHQgKiB0ICogdCA6IDEgKyAxNiAqIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFR3ZWVuKG9iamVjdCwgZnJvbSwgdG8sIGR1cmF0aW9uLCBlYXNpbmcsIHN0YXJ0KSB7XG4gICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGVhc2luZztcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHRoaXMudHlwZSA9IGlzRnVuY3Rpb24gPyB0eXBlIDogdHlwZSA9PT0gJ3N0cmluZycgPyBlYXNpbmcgOiAnbGluZWFyJztcbiAgICAgIHRoaXMuZWFzaW5nID0gaXNGdW5jdGlvbiA/IGVhc2luZyA6IFR3ZWVuLmVhc2luZ3NbdGhpcy50eXBlXTtcbiAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fdGhlbiA9IG51bGw7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuICAgICAgdmFyIHN0YXRlID0gZnJvbSB8fCB0bztcbiAgICAgIHRoaXMuX2tleXMgPSBzdGF0ZSA/IE9iamVjdC5rZXlzKHN0YXRlKSA6IFtdO1xuICAgICAgdGhpcy5fcGFyc2VkS2V5cyA9IHRoaXMuX3BhcnNlS2V5cyh0aGlzLl9rZXlzKTtcbiAgICAgIHRoaXMuX2Zyb20gPSBzdGF0ZSAmJiB0aGlzLl9nZXRTdGF0ZShmcm9tKTtcbiAgICAgIHRoaXMuX3RvID0gc3RhdGUgJiYgdGhpcy5fZ2V0U3RhdGUodG8pO1xuXG4gICAgICBpZiAoc3RhcnQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRoZW46IGZ1bmN0aW9uICh0aGVuKSB7XG4gICAgICB0aGlzLl90aGVuID0gdGhlbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgICAgICBwcm9ncmVzcyA9IDE7XG4gICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFjdG9yID0gdGhpcy5lYXNpbmcocHJvZ3Jlc3MpLFxuICAgICAgICAgICAga2V5cyA9IHRoaXMuX2tleXMsXG4gICAgICAgICAgICBnZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShmYWN0b3IsIHByb2dyZXNzKSA6IHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cyAmJiBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLFxuICAgICAgICAgICAgICBmcm9tID0gZ2V0VmFsdWUodGhpcy5fZnJvbVtrZXldKSxcbiAgICAgICAgICAgICAgdG8gPSBnZXRWYWx1ZSh0aGlzLl90b1trZXldKSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBmcm9tICYmIHRvICYmIGZyb20uX19hZGQgJiYgdG8uX19hZGQgPyB0by5fX3N1YnRyYWN0KGZyb20pLl9fbXVsdGlwbHkoZmFjdG9yKS5fX2FkZChmcm9tKSA6ICh0byAtIGZyb20pICogZmFjdG9yICsgZnJvbTtcblxuICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHRoaXMuX3BhcnNlZEtleXNba2V5XSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucmVzcG9uZHMoJ3VwZGF0ZScpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBuZXcgQmFzZSh7XG4gICAgICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3MsXG4gICAgICAgICAgICBmYWN0b3I6IGZhY3RvclxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5ydW5uaW5nICYmIHRoaXMuX3RoZW4pIHtcbiAgICAgICAgICB0aGlzLl90aGVuKHRoaXMub2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIF9ldmVudHM6IHtcbiAgICAgIG9uVXBkYXRlOiB7fVxuICAgIH0sXG4gICAgX2hhbmRsZUZyYW1lOiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZSxcbiAgICAgICAgICBwcm9ncmVzcyA9IHN0YXJ0VGltZSA/ICh0aW1lIC0gc3RhcnRUaW1lKSAvIHRoaXMuZHVyYXRpb24gOiAwO1xuXG4gICAgICBpZiAoIXN0YXJ0VGltZSkge1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZShwcm9ncmVzcyk7XG4gICAgfSxcbiAgICBfZ2V0U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLFxuICAgICAgICAgICAgcGF0aCA9IHRoaXMuX3BhcnNlZEtleXNba2V5XSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRQcm9wZXJ0eShwYXRoKSxcbiAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIHZhciByZXNvbHZlZCA9IHRoaXMuX3Jlc29sdmVWYWx1ZShjdXJyZW50LCBzdGF0ZVtrZXldKTtcblxuICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHBhdGgsIHJlc29sdmVkKTtcblxuICAgICAgICAgIHZhbHVlID0gdGhpcy5fZ2V0UHJvcGVydHkocGF0aCk7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZS5jbG9uZSA/IHZhbHVlLmNsb25lKCkgOiB2YWx1ZTtcblxuICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHBhdGgsIGN1cnJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY3VycmVudCAmJiBjdXJyZW50LmNsb25lID8gY3VycmVudC5jbG9uZSgpIDogY3VycmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBfcmVzb2x2ZVZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgdmFyIG9wZXJhdG9yID0gdmFsdWVbMF07XG4gICAgICAgICAgcmV0dXJuIG9wZXJhdG9yICYmIG9wZXJhdG9yLm1hdGNoICYmIG9wZXJhdG9yLm1hdGNoKC9eWytcXC1cXCpcXC9dPS8pID8gdGhpcy5fY2FsY3VsYXRlKGN1cnJlbnQsIG9wZXJhdG9yWzBdLCB2YWx1ZVsxXSkgOiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2goL15bK1xcLSovXT0oLiopLyk7XG5cbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBKU09OLnBhcnNlKG1hdGNoWzFdLnJlcGxhY2UoLyhbJ1wiXSk/KFthLXpBLVowLTlfXSspKFsnXCJdKT86L2csICdcIiQyXCI6ICcpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGUoY3VycmVudCwgdmFsdWVbMF0sIHBhcnNlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIF9jYWxjdWxhdGU6IGZ1bmN0aW9uIChsZWZ0LCBvcGVyYXRvciwgcmlnaHQpIHtcbiAgICAgIHJldHVybiBwYXBlci5QYXBlclNjcmlwdC5jYWxjdWxhdGVCaW5hcnkobGVmdCwgb3BlcmF0b3IsIHJpZ2h0KTtcbiAgICB9LFxuICAgIF9wYXJzZUtleXM6IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICB2YXIgcGFyc2VkID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICBwYXRoID0ga2V5LnJlcGxhY2UoL1xcLihbXi5dKikvZywgJy8kMScpLnJlcGxhY2UoL1xcW1snXCJdPyhbXidcIlxcXV0qKVsnXCJdP1xcXS9nLCAnLyQxJyk7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH0sXG4gICAgX2dldFByb3BlcnR5OiBmdW5jdGlvbiAocGF0aCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5vYmplY3Q7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aC5sZW5ndGggLSAob2Zmc2V0IHx8IDApOyBpIDwgbCAmJiBvYmo7IGkrKykge1xuICAgICAgICBvYmogPSBvYmpbcGF0aFtpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBfc2V0UHJvcGVydHk6IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkge1xuICAgICAgdmFyIGRlc3QgPSB0aGlzLl9nZXRQcm9wZXJ0eShwYXRoLCAxKTtcblxuICAgICAgaWYgKGRlc3QpIHtcbiAgICAgICAgZGVzdFtwYXRoW3BhdGgubGVuZ3RoIC0gMV1dID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIEh0dHAgPSB7XG4gICAgcmVxdWVzdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciB4aHIgPSBuZXcgc2VsZi5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oKG9wdGlvbnMubWV0aG9kIHx8ICdnZXQnKS50b1VwcGVyQ2FzZSgpLCBvcHRpb25zLnVybCwgQmFzZS5waWNrKG9wdGlvbnMuYXN5bmMsIHRydWUpKTtcbiAgICAgIGlmIChvcHRpb25zLm1pbWVUeXBlKSB4aHIub3ZlcnJpZGVNaW1lVHlwZShvcHRpb25zLm1pbWVUeXBlKTtcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMCB8fCBzdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm9uTG9hZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5vbkxvYWQuY2FsbCh4aHIsIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIub25lcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXMsXG4gICAgICAgICAgICBtZXNzYWdlID0gJ0NvdWxkIG5vdCBsb2FkIFwiJyArIG9wdGlvbnMudXJsICsgJ1wiIChTdGF0dXM6ICcgKyBzdGF0dXMgKyAnKSc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub25FcnJvcikge1xuICAgICAgICAgIG9wdGlvbnMub25FcnJvcihtZXNzYWdlLCBzdGF0dXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHhoci5zZW5kKG51bGwpO1xuICAgIH1cbiAgfTtcbiAgdmFyIENhbnZhc1Byb3ZpZGVyID0gQmFzZS5leHBvcnRzLkNhbnZhc1Byb3ZpZGVyID0ge1xuICAgIGNhbnZhc2VzOiBbXSxcbiAgICBnZXRDYW52YXM6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoIXdpbmRvdykgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgY2FudmFzLFxuICAgICAgICAgIGNsZWFyID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiB3aWR0aCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaGVpZ2h0ID0gd2lkdGguaGVpZ2h0O1xuICAgICAgICB3aWR0aCA9IHdpZHRoLndpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYW52YXNlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FudmFzID0gdGhpcy5jYW52YXNlcy5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjbGVhciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzICcgKyBjYW52YXMgKyAnIGlzIHVuYWJsZSB0byBwcm92aWRlIGEgMkQgY29udGV4dC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbnZhcy53aWR0aCA9PT0gd2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICAgIGlmIChjbGVhcikgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCArIDEsIGhlaWdodCArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH0sXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiBjYW52YXMgPyBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSA6IG51bGw7XG4gICAgfSxcbiAgICByZWxlYXNlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIgY2FudmFzID0gb2JqICYmIG9iai5jYW52YXMgPyBvYmouY2FudmFzIDogb2JqO1xuXG4gICAgICBpZiAoY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnJlc3RvcmUoKTtcbiAgICAgICAgdGhpcy5jYW52YXNlcy5wdXNoKGNhbnZhcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgQmxlbmRNb2RlID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4sXG4gICAgICAgIG1heCA9IE1hdGgubWF4LFxuICAgICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgc3IsXG4gICAgICAgIHNnLFxuICAgICAgICBzYixcbiAgICAgICAgc2EsXG4gICAgICAgIGJyLFxuICAgICAgICBiZyxcbiAgICAgICAgYmIsXG4gICAgICAgIGJhLFxuICAgICAgICBkcixcbiAgICAgICAgZGcsXG4gICAgICAgIGRiO1xuXG4gICAgZnVuY3Rpb24gZ2V0THVtKHIsIGcsIGIpIHtcbiAgICAgIHJldHVybiAwLjI5ODkgKiByICsgMC41ODcgKiBnICsgMC4xMTQgKiBiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEx1bShyLCBnLCBiLCBsKSB7XG4gICAgICB2YXIgZCA9IGwgLSBnZXRMdW0ociwgZywgYik7XG4gICAgICBkciA9IHIgKyBkO1xuICAgICAgZGcgPSBnICsgZDtcbiAgICAgIGRiID0gYiArIGQ7XG4gICAgICB2YXIgbCA9IGdldEx1bShkciwgZGcsIGRiKSxcbiAgICAgICAgICBtbiA9IG1pbihkciwgZGcsIGRiKSxcbiAgICAgICAgICBteCA9IG1heChkciwgZGcsIGRiKTtcblxuICAgICAgaWYgKG1uIDwgMCkge1xuICAgICAgICB2YXIgbG1uID0gbCAtIG1uO1xuICAgICAgICBkciA9IGwgKyAoZHIgLSBsKSAqIGwgLyBsbW47XG4gICAgICAgIGRnID0gbCArIChkZyAtIGwpICogbCAvIGxtbjtcbiAgICAgICAgZGIgPSBsICsgKGRiIC0gbCkgKiBsIC8gbG1uO1xuICAgICAgfVxuXG4gICAgICBpZiAobXggPiAyNTUpIHtcbiAgICAgICAgdmFyIGxuID0gMjU1IC0gbCxcbiAgICAgICAgICAgIG14bCA9IG14IC0gbDtcbiAgICAgICAgZHIgPSBsICsgKGRyIC0gbCkgKiBsbiAvIG14bDtcbiAgICAgICAgZGcgPSBsICsgKGRnIC0gbCkgKiBsbiAvIG14bDtcbiAgICAgICAgZGIgPSBsICsgKGRiIC0gbCkgKiBsbiAvIG14bDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTYXQociwgZywgYikge1xuICAgICAgcmV0dXJuIG1heChyLCBnLCBiKSAtIG1pbihyLCBnLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRTYXQociwgZywgYiwgcykge1xuICAgICAgdmFyIGNvbCA9IFtyLCBnLCBiXSxcbiAgICAgICAgICBteCA9IG1heChyLCBnLCBiKSxcbiAgICAgICAgICBtbiA9IG1pbihyLCBnLCBiKSxcbiAgICAgICAgICBtZDtcbiAgICAgIG1uID0gbW4gPT09IHIgPyAwIDogbW4gPT09IGcgPyAxIDogMjtcbiAgICAgIG14ID0gbXggPT09IHIgPyAwIDogbXggPT09IGcgPyAxIDogMjtcbiAgICAgIG1kID0gbWluKG1uLCBteCkgPT09IDAgPyBtYXgobW4sIG14KSA9PT0gMSA/IDIgOiAxIDogMDtcblxuICAgICAgaWYgKGNvbFtteF0gPiBjb2xbbW5dKSB7XG4gICAgICAgIGNvbFttZF0gPSAoY29sW21kXSAtIGNvbFttbl0pICogcyAvIChjb2xbbXhdIC0gY29sW21uXSk7XG4gICAgICAgIGNvbFtteF0gPSBzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sW21kXSA9IGNvbFtteF0gPSAwO1xuICAgICAgfVxuXG4gICAgICBjb2xbbW5dID0gMDtcbiAgICAgIGRyID0gY29sWzBdO1xuICAgICAgZGcgPSBjb2xbMV07XG4gICAgICBkYiA9IGNvbFsyXTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZXMgPSB7XG4gICAgICBtdWx0aXBseTogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IGJyICogc3IgLyAyNTU7XG4gICAgICAgIGRnID0gYmcgKiBzZyAvIDI1NTtcbiAgICAgICAgZGIgPSBiYiAqIHNiIC8gMjU1O1xuICAgICAgfSxcbiAgICAgIHNjcmVlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IGJyICsgc3IgLSBiciAqIHNyIC8gMjU1O1xuICAgICAgICBkZyA9IGJnICsgc2cgLSBiZyAqIHNnIC8gMjU1O1xuICAgICAgICBkYiA9IGJiICsgc2IgLSBiYiAqIHNiIC8gMjU1O1xuICAgICAgfSxcbiAgICAgIG92ZXJsYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBiciA8IDEyOCA/IDIgKiBiciAqIHNyIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1O1xuICAgICAgICBkZyA9IGJnIDwgMTI4ID8gMiAqIGJnICogc2cgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJnKSAqICgyNTUgLSBzZykgLyAyNTU7XG4gICAgICAgIGRiID0gYmIgPCAxMjggPyAyICogYmIgKiBzYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NTtcbiAgICAgIH0sXG4gICAgICAnc29mdC1saWdodCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBzciAqIGJyIC8gMjU1O1xuICAgICAgICBkciA9IHQgKyBiciAqICgyNTUgLSAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NSAtIHQpIC8gMjU1O1xuICAgICAgICB0ID0gc2cgKiBiZyAvIDI1NTtcbiAgICAgICAgZGcgPSB0ICsgYmcgKiAoMjU1IC0gKDI1NSAtIGJnKSAqICgyNTUgLSBzZykgLyAyNTUgLSB0KSAvIDI1NTtcbiAgICAgICAgdCA9IHNiICogYmIgLyAyNTU7XG4gICAgICAgIGRiID0gdCArIGJiICogKDI1NSAtICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1IC0gdCkgLyAyNTU7XG4gICAgICB9LFxuICAgICAgJ2hhcmQtbGlnaHQnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gc3IgPCAxMjggPyAyICogc3IgKiBiciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc3IpICogKDI1NSAtIGJyKSAvIDI1NTtcbiAgICAgICAgZGcgPSBzZyA8IDEyOCA/IDIgKiBzZyAqIGJnIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzZykgKiAoMjU1IC0gYmcpIC8gMjU1O1xuICAgICAgICBkYiA9IHNiIDwgMTI4ID8gMiAqIHNiICogYmIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNiKSAqICgyNTUgLSBiYikgLyAyNTU7XG4gICAgICB9LFxuICAgICAgJ2NvbG9yLWRvZGdlJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IGJyID09PSAwID8gMCA6IHNyID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiciAvICgyNTUgLSBzcikpO1xuICAgICAgICBkZyA9IGJnID09PSAwID8gMCA6IHNnID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiZyAvICgyNTUgLSBzZykpO1xuICAgICAgICBkYiA9IGJiID09PSAwID8gMCA6IHNiID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiYiAvICgyNTUgLSBzYikpO1xuICAgICAgfSxcbiAgICAgICdjb2xvci1idXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IGJyID09PSAyNTUgPyAyNTUgOiBzciA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJyKSAqIDI1NSAvIHNyKTtcbiAgICAgICAgZGcgPSBiZyA9PT0gMjU1ID8gMjU1IDogc2cgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBiZykgKiAyNTUgLyBzZyk7XG4gICAgICAgIGRiID0gYmIgPT09IDI1NSA/IDI1NSA6IHNiID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmIpICogMjU1IC8gc2IpO1xuICAgICAgfSxcbiAgICAgIGRhcmtlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IGJyIDwgc3IgPyBiciA6IHNyO1xuICAgICAgICBkZyA9IGJnIDwgc2cgPyBiZyA6IHNnO1xuICAgICAgICBkYiA9IGJiIDwgc2IgPyBiYiA6IHNiO1xuICAgICAgfSxcbiAgICAgIGxpZ2h0ZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBiciA+IHNyID8gYnIgOiBzcjtcbiAgICAgICAgZGcgPSBiZyA+IHNnID8gYmcgOiBzZztcbiAgICAgICAgZGIgPSBiYiA+IHNiID8gYmIgOiBzYjtcbiAgICAgIH0sXG4gICAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gYnIgLSBzcjtcbiAgICAgICAgaWYgKGRyIDwgMCkgZHIgPSAtZHI7XG4gICAgICAgIGRnID0gYmcgLSBzZztcbiAgICAgICAgaWYgKGRnIDwgMCkgZGcgPSAtZGc7XG4gICAgICAgIGRiID0gYmIgLSBzYjtcbiAgICAgICAgaWYgKGRiIDwgMCkgZGIgPSAtZGI7XG4gICAgICB9LFxuICAgICAgZXhjbHVzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gYnIgKyBzciAqICgyNTUgLSBiciAtIGJyKSAvIDI1NTtcbiAgICAgICAgZGcgPSBiZyArIHNnICogKDI1NSAtIGJnIC0gYmcpIC8gMjU1O1xuICAgICAgICBkYiA9IGJiICsgc2IgKiAoMjU1IC0gYmIgLSBiYikgLyAyNTU7XG4gICAgICB9LFxuICAgICAgaHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNhdChzciwgc2csIHNiLCBnZXRTYXQoYnIsIGJnLCBiYikpO1xuICAgICAgICBzZXRMdW0oZHIsIGRnLCBkYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcbiAgICAgIH0sXG4gICAgICBzYXR1cmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNhdChiciwgYmcsIGJiLCBnZXRTYXQoc3IsIHNnLCBzYikpO1xuICAgICAgICBzZXRMdW0oZHIsIGRnLCBkYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcbiAgICAgIH0sXG4gICAgICBsdW1pbm9zaXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldEx1bShiciwgYmcsIGJiLCBnZXRMdW0oc3IsIHNnLCBzYikpO1xuICAgICAgfSxcbiAgICAgIGNvbG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldEx1bShzciwgc2csIHNiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuICAgICAgfSxcbiAgICAgIGFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IG1pbihiciArIHNyLCAyNTUpO1xuICAgICAgICBkZyA9IG1pbihiZyArIHNnLCAyNTUpO1xuICAgICAgICBkYiA9IG1pbihiYiArIHNiLCAyNTUpO1xuICAgICAgfSxcbiAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gbWF4KGJyIC0gc3IsIDApO1xuICAgICAgICBkZyA9IG1heChiZyAtIHNnLCAwKTtcbiAgICAgICAgZGIgPSBtYXgoYmIgLSBzYiwgMCk7XG4gICAgICB9LFxuICAgICAgYXZlcmFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IChiciArIHNyKSAvIDI7XG4gICAgICAgIGRnID0gKGJnICsgc2cpIC8gMjtcbiAgICAgICAgZGIgPSAoYmIgKyBzYikgLyAyO1xuICAgICAgfSxcbiAgICAgIG5lZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gMjU1IC0gYWJzKDI1NSAtIHNyIC0gYnIpO1xuICAgICAgICBkZyA9IDI1NSAtIGFicygyNTUgLSBzZyAtIGJnKTtcbiAgICAgICAgZGIgPSAyNTUgLSBhYnMoMjU1IC0gc2IgLSBiYik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbmF0aXZlTW9kZXMgPSB0aGlzLm5hdGl2ZU1vZGVzID0gQmFzZS5lYWNoKFsnc291cmNlLW92ZXInLCAnc291cmNlLWluJywgJ3NvdXJjZS1vdXQnLCAnc291cmNlLWF0b3AnLCAnZGVzdGluYXRpb24tb3ZlcicsICdkZXN0aW5hdGlvbi1pbicsICdkZXN0aW5hdGlvbi1vdXQnLCAnZGVzdGluYXRpb24tYXRvcCcsICdsaWdodGVyJywgJ2RhcmtlcicsICdjb3B5JywgJ3hvciddLCBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgdGhpc1ttb2RlXSA9IHRydWU7XG4gICAgfSwge30pO1xuICAgIHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgQmFzZS5lYWNoKG1vZGVzLCBmdW5jdGlvbiAoZnVuYywgbW9kZSkge1xuICAgICAgICB2YXIgZGFya2VuID0gbW9kZSA9PT0gJ2RhcmtlbicsXG4gICAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRhcmtlbiA/ICcjMzAwJyA6ICcjYTAwJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG1vZGU7XG5cbiAgICAgICAgICBpZiAoY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9PT0gbW9kZSkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRhcmtlbiA/ICcjYTAwJyA6ICcjMzAwJztcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICAgICAgICAgIG9rID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzBdICE9PSBkYXJrZW4gPyAxNzAgOiA1MTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgbmF0aXZlTW9kZXNbbW9kZV0gPSBvaztcbiAgICAgIH0pO1xuICAgICAgQ2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuICAgIH1cblxuICAgIHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uIChtb2RlLCBzcmNDb250ZXh0LCBkc3RDb250ZXh0LCBhbHBoYSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgc3JjQ2FudmFzID0gc3JjQ29udGV4dC5jYW52YXMsXG4gICAgICAgICAgbm9ybWFsID0gbW9kZSA9PT0gJ25vcm1hbCc7XG5cbiAgICAgIGlmIChub3JtYWwgfHwgbmF0aXZlTW9kZXNbbW9kZV0pIHtcbiAgICAgICAgZHN0Q29udGV4dC5zYXZlKCk7XG4gICAgICAgIGRzdENvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBkc3RDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgICAgIGlmICghbm9ybWFsKSBkc3RDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG1vZGU7XG4gICAgICAgIGRzdENvbnRleHQuZHJhd0ltYWdlKHNyY0NhbnZhcywgb2Zmc2V0LngsIG9mZnNldC55KTtcbiAgICAgICAgZHN0Q29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvY2VzcyA9IG1vZGVzW21vZGVdO1xuICAgICAgICBpZiAoIXByb2Nlc3MpIHJldHVybjtcbiAgICAgICAgdmFyIGRzdERhdGEgPSBkc3RDb250ZXh0LmdldEltYWdlRGF0YShvZmZzZXQueCwgb2Zmc2V0LnksIHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCksXG4gICAgICAgICAgICBkc3QgPSBkc3REYXRhLmRhdGEsXG4gICAgICAgICAgICBzcmMgPSBzcmNDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLmRhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkc3QubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICAgICAgc3IgPSBzcmNbaV07XG4gICAgICAgICAgYnIgPSBkc3RbaV07XG4gICAgICAgICAgc2cgPSBzcmNbaSArIDFdO1xuICAgICAgICAgIGJnID0gZHN0W2kgKyAxXTtcbiAgICAgICAgICBzYiA9IHNyY1tpICsgMl07XG4gICAgICAgICAgYmIgPSBkc3RbaSArIDJdO1xuICAgICAgICAgIHNhID0gc3JjW2kgKyAzXTtcbiAgICAgICAgICBiYSA9IGRzdFtpICsgM107XG4gICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgIHZhciBhMSA9IHNhICogYWxwaGEgLyAyNTUsXG4gICAgICAgICAgICAgIGEyID0gMSAtIGExO1xuICAgICAgICAgIGRzdFtpXSA9IGExICogZHIgKyBhMiAqIGJyO1xuICAgICAgICAgIGRzdFtpICsgMV0gPSBhMSAqIGRnICsgYTIgKiBiZztcbiAgICAgICAgICBkc3RbaSArIDJdID0gYTEgKiBkYiArIGEyICogYmI7XG4gICAgICAgICAgZHN0W2kgKyAzXSA9IHNhICogYWxwaGEgKyBhMiAqIGJhO1xuICAgICAgICB9XG5cbiAgICAgICAgZHN0Q29udGV4dC5wdXRJbWFnZURhdGEoZHN0RGF0YSwgb2Zmc2V0LngsIG9mZnNldC55KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG4gIHZhciBTdmdFbGVtZW50ID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3ZnID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgeG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucycsXG4gICAgICAgIHhsaW5rID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2UgPSB7XG4gICAgICBocmVmOiB4bGluayxcbiAgICAgIHhsaW5rOiB4bWxucyxcbiAgICAgIHhtbG5zOiB4bWxucyArICcvJyxcbiAgICAgICd4bWxuczp4bGluayc6IHhtbG5zICsgJy8nXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YWcsIGF0dHJpYnV0ZXMsIGZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIHNldChkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnLCB0YWcpLCBhdHRyaWJ1dGVzLCBmb3JtYXR0ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldChub2RlLCBuYW1lKSB7XG4gICAgICB2YXIgbmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlW25hbWVdLFxuICAgICAgICAgIHZhbHVlID0gbmFtZXNwYWNlID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpIDogbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICByZXR1cm4gdmFsdWUgPT09ICdudWxsJyA/IG51bGwgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQobm9kZSwgYXR0cmlidXRlcywgZm9ybWF0dGVyKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZVtuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgZm9ybWF0dGVyKSB2YWx1ZSA9IGZvcm1hdHRlci5udW1iZXIodmFsdWUpO1xuXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3ZnOiBzdmcsXG4gICAgICB4bWxuczogeG1sbnMsXG4gICAgICB4bGluazogeGxpbmssXG4gICAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICAgIGdldDogZ2V0LFxuICAgICAgc2V0OiBzZXRcbiAgICB9O1xuICB9KCk7XG4gIHZhciBTdmdTdHlsZXMgPSBCYXNlLmVhY2goe1xuICAgIGZpbGxDb2xvcjogWydmaWxsJywgJ2NvbG9yJ10sXG4gICAgZmlsbFJ1bGU6IFsnZmlsbC1ydWxlJywgJ3N0cmluZyddLFxuICAgIHN0cm9rZUNvbG9yOiBbJ3N0cm9rZScsICdjb2xvciddLFxuICAgIHN0cm9rZVdpZHRoOiBbJ3N0cm9rZS13aWR0aCcsICdudW1iZXInXSxcbiAgICBzdHJva2VDYXA6IFsnc3Ryb2tlLWxpbmVjYXAnLCAnc3RyaW5nJ10sXG4gICAgc3Ryb2tlSm9pbjogWydzdHJva2UtbGluZWpvaW4nLCAnc3RyaW5nJ10sXG4gICAgc3Ryb2tlU2NhbGluZzogWyd2ZWN0b3ItZWZmZWN0JywgJ2xvb2t1cCcsIHtcbiAgICAgIHRydWU6ICdub25lJyxcbiAgICAgIGZhbHNlOiAnbm9uLXNjYWxpbmctc3Ryb2tlJ1xuICAgIH0sIGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuICF2YWx1ZSAmJiAoaXRlbSBpbnN0YW5jZW9mIFBhdGhJdGVtIHx8IGl0ZW0gaW5zdGFuY2VvZiBTaGFwZSB8fCBpdGVtIGluc3RhbmNlb2YgVGV4dEl0ZW0pO1xuICAgIH1dLFxuICAgIG1pdGVyTGltaXQ6IFsnc3Ryb2tlLW1pdGVybGltaXQnLCAnbnVtYmVyJ10sXG4gICAgZGFzaEFycmF5OiBbJ3N0cm9rZS1kYXNoYXJyYXknLCAnYXJyYXknXSxcbiAgICBkYXNoT2Zmc2V0OiBbJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ251bWJlciddLFxuICAgIGZvbnRGYW1pbHk6IFsnZm9udC1mYW1pbHknLCAnc3RyaW5nJ10sXG4gICAgZm9udFdlaWdodDogWydmb250LXdlaWdodCcsICdzdHJpbmcnXSxcbiAgICBmb250U2l6ZTogWydmb250LXNpemUnLCAnbnVtYmVyJ10sXG4gICAganVzdGlmaWNhdGlvbjogWyd0ZXh0LWFuY2hvcicsICdsb29rdXAnLCB7XG4gICAgICBsZWZ0OiAnc3RhcnQnLFxuICAgICAgY2VudGVyOiAnbWlkZGxlJyxcbiAgICAgIHJpZ2h0OiAnZW5kJ1xuICAgIH1dLFxuICAgIG9wYWNpdHk6IFsnb3BhY2l0eScsICdudW1iZXInXSxcbiAgICBibGVuZE1vZGU6IFsnbWl4LWJsZW5kLW1vZGUnLCAnc3R5bGUnXVxuICB9LCBmdW5jdGlvbiAoZW50cnksIGtleSkge1xuICAgIHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG4gICAgICAgIGxvb2t1cCA9IGVudHJ5WzJdO1xuICAgIHRoaXNba2V5XSA9IHtcbiAgICAgIHR5cGU6IGVudHJ5WzFdLFxuICAgICAgcHJvcGVydHk6IGtleSxcbiAgICAgIGF0dHJpYnV0ZTogZW50cnlbMF0sXG4gICAgICB0b1NWRzogbG9va3VwLFxuICAgICAgZnJvbVNWRzogbG9va3VwICYmIEJhc2UuZWFjaChsb29rdXAsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzW3ZhbHVlXSA9IG5hbWU7XG4gICAgICB9LCB7fSksXG4gICAgICBleHBvcnRGaWx0ZXI6IGVudHJ5WzNdLFxuICAgICAgZ2V0OiAnZ2V0JyArIHBhcnQsXG4gICAgICBzZXQ6ICdzZXQnICsgcGFydFxuICAgIH07XG4gIH0sIHt9KTtcbiAgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9ybWF0dGVyO1xuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKG1hdHJpeCwgY29vcmRpbmF0ZXMsIGNlbnRlcikge1xuICAgICAgdmFyIGF0dHJzID0gbmV3IEJhc2UoKSxcbiAgICAgICAgICB0cmFucyA9IG1hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuXG4gICAgICBpZiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdmFyIHBvaW50O1xuXG4gICAgICAgIGlmIChtYXRyaXguaXNJbnZlcnRpYmxlKCkpIHtcbiAgICAgICAgICBtYXRyaXggPSBtYXRyaXguX3NoaWZ0bGVzcygpO1xuICAgICAgICAgIHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRyYW5zKTtcbiAgICAgICAgICB0cmFucyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJzW2NlbnRlciA/ICdjeCcgOiAneCddID0gcG9pbnQueDtcbiAgICAgICAgYXR0cnNbY2VudGVyID8gJ2N5JyA6ICd5J10gPSBwb2ludC55O1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1hdHJpeC5pc0lkZW50aXR5KCkpIHtcbiAgICAgICAgdmFyIGRlY29tcG9zZWQgPSBtYXRyaXguZGVjb21wb3NlKCk7XG5cbiAgICAgICAgaWYgKGRlY29tcG9zZWQpIHtcbiAgICAgICAgICB2YXIgcGFydHMgPSBbXSxcbiAgICAgICAgICAgICAgYW5nbGUgPSBkZWNvbXBvc2VkLnJvdGF0aW9uLFxuICAgICAgICAgICAgICBzY2FsZSA9IGRlY29tcG9zZWQuc2NhbGluZyxcbiAgICAgICAgICAgICAgc2tldyA9IGRlY29tcG9zZWQuc2tld2luZztcbiAgICAgICAgICBpZiAodHJhbnMgJiYgIXRyYW5zLmlzWmVybygpKSBwYXJ0cy5wdXNoKCd0cmFuc2xhdGUoJyArIGZvcm1hdHRlci5wb2ludCh0cmFucykgKyAnKScpO1xuICAgICAgICAgIGlmIChhbmdsZSkgcGFydHMucHVzaCgncm90YXRlKCcgKyBmb3JtYXR0ZXIubnVtYmVyKGFuZ2xlKSArICcpJyk7XG4gICAgICAgICAgaWYgKCFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnggLSAxKSB8fCAhTnVtZXJpY2FsLmlzWmVybyhzY2FsZS55IC0gMSkpIHBhcnRzLnB1c2goJ3NjYWxlKCcgKyBmb3JtYXR0ZXIucG9pbnQoc2NhbGUpICsgJyknKTtcbiAgICAgICAgICBpZiAoc2tldy54KSBwYXJ0cy5wdXNoKCdza2V3WCgnICsgZm9ybWF0dGVyLm51bWJlcihza2V3LngpICsgJyknKTtcbiAgICAgICAgICBpZiAoc2tldy55KSBwYXJ0cy5wdXNoKCdza2V3WSgnICsgZm9ybWF0dGVyLm51bWJlcihza2V3LnkpICsgJyknKTtcbiAgICAgICAgICBhdHRycy50cmFuc2Zvcm0gPSBwYXJ0cy5qb2luKCcgJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0cnMudHJhbnNmb3JtID0gJ21hdHJpeCgnICsgbWF0cml4LmdldFZhbHVlcygpLmpvaW4oJywnKSArICcpJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0R3JvdXAoaXRlbSwgb3B0aW9ucykge1xuICAgICAgdmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCksXG4gICAgICAgICAgY2hpbGRyZW4gPSBpdGVtLl9jaGlsZHJlbjtcbiAgICAgIHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ2cnLCBhdHRycywgZm9ybWF0dGVyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBleHBvcnRTVkcoY2hpbGQsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICBpZiAoY2hpbGQuaXNDbGlwTWFzaygpKSB7XG4gICAgICAgICAgICB2YXIgY2xpcCA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdjbGlwUGF0aCcpO1xuICAgICAgICAgICAgY2xpcC5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgc2V0RGVmaW5pdGlvbihjaGlsZCwgY2xpcCwgJ2NsaXAnKTtcbiAgICAgICAgICAgIFN2Z0VsZW1lbnQuc2V0KG5vZGUsIHtcbiAgICAgICAgICAgICAgJ2NsaXAtcGF0aCc6ICd1cmwoIycgKyBjbGlwLmlkICsgJyknXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRSYXN0ZXIoaXRlbSwgb3B0aW9ucykge1xuICAgICAgdmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG4gICAgICAgICAgc2l6ZSA9IGl0ZW0uZ2V0U2l6ZSgpLFxuICAgICAgICAgIGltYWdlID0gaXRlbS5nZXRJbWFnZSgpO1xuICAgICAgYXR0cnMueCAtPSBzaXplLndpZHRoIC8gMjtcbiAgICAgIGF0dHJzLnkgLT0gc2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgYXR0cnMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgYXR0cnMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICBhdHRycy5ocmVmID0gb3B0aW9ucy5lbWJlZEltYWdlcyA9PSBmYWxzZSAmJiBpbWFnZSAmJiBpbWFnZS5zcmMgfHwgaXRlbS50b0RhdGFVUkwoKTtcbiAgICAgIHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSgnaW1hZ2UnLCBhdHRycywgZm9ybWF0dGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBtYXRjaFNoYXBlcyA9IG9wdGlvbnMubWF0Y2hTaGFwZXM7XG5cbiAgICAgIGlmIChtYXRjaFNoYXBlcykge1xuICAgICAgICB2YXIgc2hhcGUgPSBpdGVtLnRvU2hhcGUoZmFsc2UpO1xuICAgICAgICBpZiAoc2hhcGUpIHJldHVybiBleHBvcnRTaGFwZShzaGFwZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50cyA9IGl0ZW0uX3NlZ21lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCk7XG5cbiAgICAgIGlmIChtYXRjaFNoYXBlcyAmJiBsZW5ndGggPj0gMiAmJiAhaXRlbS5oYXNIYW5kbGVzKCkpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB0eXBlID0gaXRlbS5fY2xvc2VkID8gJ3BvbHlnb24nIDogJ3BvbHlsaW5lJztcbiAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goZm9ybWF0dGVyLnBvaW50KHNlZ21lbnRzW2ldLl9wb2ludCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0dHJzLnBvaW50cyA9IHBhcnRzLmpvaW4oJyAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gJ2xpbmUnO1xuICAgICAgICAgIHZhciBzdGFydCA9IHNlZ21lbnRzWzBdLl9wb2ludCxcbiAgICAgICAgICAgICAgZW5kID0gc2VnbWVudHNbMV0uX3BvaW50O1xuICAgICAgICAgIGF0dHJzLnNldCh7XG4gICAgICAgICAgICB4MTogc3RhcnQueCxcbiAgICAgICAgICAgIHkxOiBzdGFydC55LFxuICAgICAgICAgICAgeDI6IGVuZC54LFxuICAgICAgICAgICAgeTI6IGVuZC55XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSAncGF0aCc7XG4gICAgICAgIGF0dHJzLmQgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKHR5cGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydFNoYXBlKGl0ZW0pIHtcbiAgICAgIHZhciB0eXBlID0gaXRlbS5fdHlwZSxcbiAgICAgICAgICByYWRpdXMgPSBpdGVtLl9yYWRpdXMsXG4gICAgICAgICAgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlLCB0eXBlICE9PSAncmVjdGFuZ2xlJyk7XG5cbiAgICAgIGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuICAgICAgICB0eXBlID0gJ3JlY3QnO1xuICAgICAgICB2YXIgc2l6ZSA9IGl0ZW0uX3NpemUsXG4gICAgICAgICAgICB3aWR0aCA9IHNpemUud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgYXR0cnMueCAtPSB3aWR0aCAvIDI7XG4gICAgICAgIGF0dHJzLnkgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgYXR0cnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgYXR0cnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBpZiAocmFkaXVzLmlzWmVybygpKSByYWRpdXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFkaXVzKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuICAgICAgICAgIGF0dHJzLnIgPSByYWRpdXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0cnMucnggPSByYWRpdXMud2lkdGg7XG4gICAgICAgICAgYXR0cnMucnkgPSByYWRpdXMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSh0eXBlLCBhdHRycywgZm9ybWF0dGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRDb21wb3VuZFBhdGgoaXRlbSwgb3B0aW9ucykge1xuICAgICAgdmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCk7XG4gICAgICB2YXIgZGF0YSA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgaWYgKGRhdGEpIGF0dHJzLmQgPSBkYXRhO1xuICAgICAgcmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKCdwYXRoJywgYXR0cnMsIGZvcm1hdHRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0U3ltYm9sSXRlbShpdGVtLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcbiAgICAgICAgICBkZWZpbml0aW9uID0gaXRlbS5fZGVmaW5pdGlvbixcbiAgICAgICAgICBub2RlID0gZ2V0RGVmaW5pdGlvbihkZWZpbml0aW9uLCAnc3ltYm9sJyksXG4gICAgICAgICAgZGVmaW5pdGlvbkl0ZW0gPSBkZWZpbml0aW9uLl9pdGVtLFxuICAgICAgICAgIGJvdW5kcyA9IGRlZmluaXRpb25JdGVtLmdldFN0cm9rZUJvdW5kcygpO1xuXG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgbm9kZSA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdzeW1ib2wnLCB7XG4gICAgICAgICAgdmlld0JveDogZm9ybWF0dGVyLnJlY3RhbmdsZShib3VuZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGV4cG9ydFNWRyhkZWZpbml0aW9uSXRlbSwgb3B0aW9ucykpO1xuICAgICAgICBzZXREZWZpbml0aW9uKGRlZmluaXRpb24sIG5vZGUsICdzeW1ib2wnKTtcbiAgICAgIH1cblxuICAgICAgYXR0cnMuaHJlZiA9ICcjJyArIG5vZGUuaWQ7XG4gICAgICBhdHRycy54ICs9IGJvdW5kcy54O1xuICAgICAgYXR0cnMueSArPSBib3VuZHMueTtcbiAgICAgIGF0dHJzLndpZHRoID0gYm91bmRzLndpZHRoO1xuICAgICAgYXR0cnMuaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgICAgIGF0dHJzLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xuICAgICAgcmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKCd1c2UnLCBhdHRycywgZm9ybWF0dGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRHcmFkaWVudChjb2xvcikge1xuICAgICAgdmFyIGdyYWRpZW50Tm9kZSA9IGdldERlZmluaXRpb24oY29sb3IsICdjb2xvcicpO1xuXG4gICAgICBpZiAoIWdyYWRpZW50Tm9kZSkge1xuICAgICAgICB2YXIgZ3JhZGllbnQgPSBjb2xvci5nZXRHcmFkaWVudCgpLFxuICAgICAgICAgICAgcmFkaWFsID0gZ3JhZGllbnQuX3JhZGlhbCxcbiAgICAgICAgICAgIG9yaWdpbiA9IGNvbG9yLmdldE9yaWdpbigpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24gPSBjb2xvci5nZXREZXN0aW5hdGlvbigpLFxuICAgICAgICAgICAgYXR0cnM7XG5cbiAgICAgICAgaWYgKHJhZGlhbCkge1xuICAgICAgICAgIGF0dHJzID0ge1xuICAgICAgICAgICAgY3g6IG9yaWdpbi54LFxuICAgICAgICAgICAgY3k6IG9yaWdpbi55LFxuICAgICAgICAgICAgcjogb3JpZ2luLmdldERpc3RhbmNlKGRlc3RpbmF0aW9uKVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IGNvbG9yLmdldEhpZ2hsaWdodCgpO1xuXG4gICAgICAgICAgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgICAgICAgYXR0cnMuZnggPSBoaWdobGlnaHQueDtcbiAgICAgICAgICAgIGF0dHJzLmZ5ID0gaGlnaGxpZ2h0Lnk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJzID0ge1xuICAgICAgICAgICAgeDE6IG9yaWdpbi54LFxuICAgICAgICAgICAgeTE6IG9yaWdpbi55LFxuICAgICAgICAgICAgeDI6IGRlc3RpbmF0aW9uLngsXG4gICAgICAgICAgICB5MjogZGVzdGluYXRpb24ueVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBhdHRycy5ncmFkaWVudFVuaXRzID0gJ3VzZXJTcGFjZU9uVXNlJztcbiAgICAgICAgZ3JhZGllbnROb2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoKHJhZGlhbCA/ICdyYWRpYWwnIDogJ2xpbmVhcicpICsgJ0dyYWRpZW50JywgYXR0cnMsIGZvcm1hdHRlcik7XG4gICAgICAgIHZhciBzdG9wcyA9IGdyYWRpZW50Ll9zdG9wcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV0sXG4gICAgICAgICAgICAgIHN0b3BDb2xvciA9IHN0b3AuX2NvbG9yLFxuICAgICAgICAgICAgICBhbHBoYSA9IHN0b3BDb2xvci5nZXRBbHBoYSgpLFxuICAgICAgICAgICAgICBvZmZzZXQgPSBzdG9wLl9vZmZzZXQ7XG4gICAgICAgICAgYXR0cnMgPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCA9PSBudWxsID8gaSAvIChsIC0gMSkgOiBvZmZzZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChzdG9wQ29sb3IpIGF0dHJzWydzdG9wLWNvbG9yJ10gPSBzdG9wQ29sb3IudG9DU1ModHJ1ZSk7XG4gICAgICAgICAgaWYgKGFscGhhIDwgMSkgYXR0cnNbJ3N0b3Atb3BhY2l0eSddID0gYWxwaGE7XG4gICAgICAgICAgZ3JhZGllbnROb2RlLmFwcGVuZENoaWxkKFN2Z0VsZW1lbnQuY3JlYXRlKCdzdG9wJywgYXR0cnMsIGZvcm1hdHRlcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RGVmaW5pdGlvbihjb2xvciwgZ3JhZGllbnROb2RlLCAnY29sb3InKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICd1cmwoIycgKyBncmFkaWVudE5vZGUuaWQgKyAnKSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0VGV4dChpdGVtKSB7XG4gICAgICB2YXIgbm9kZSA9IFN2Z0VsZW1lbnQuY3JlYXRlKCd0ZXh0JywgZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksIGZvcm1hdHRlcik7XG4gICAgICBub2RlLnRleHRDb250ZW50ID0gaXRlbS5fY29udGVudDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHZhciBleHBvcnRlcnMgPSB7XG4gICAgICBHcm91cDogZXhwb3J0R3JvdXAsXG4gICAgICBMYXllcjogZXhwb3J0R3JvdXAsXG4gICAgICBSYXN0ZXI6IGV4cG9ydFJhc3RlcixcbiAgICAgIFBhdGg6IGV4cG9ydFBhdGgsXG4gICAgICBTaGFwZTogZXhwb3J0U2hhcGUsXG4gICAgICBDb21wb3VuZFBhdGg6IGV4cG9ydENvbXBvdW5kUGF0aCxcbiAgICAgIFN5bWJvbEl0ZW06IGV4cG9ydFN5bWJvbEl0ZW0sXG4gICAgICBQb2ludFRleHQ6IGV4cG9ydFRleHRcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZShpdGVtLCBub2RlLCBpc1Jvb3QpIHtcbiAgICAgIHZhciBhdHRycyA9IHt9LFxuICAgICAgICAgIHBhcmVudCA9ICFpc1Jvb3QgJiYgaXRlbS5nZXRQYXJlbnQoKSxcbiAgICAgICAgICBzdHlsZSA9IFtdO1xuICAgICAgaWYgKGl0ZW0uX25hbWUgIT0gbnVsbCkgYXR0cnMuaWQgPSBpdGVtLl9uYW1lO1xuICAgICAgQmFzZS5lYWNoKFN2Z1N0eWxlcywgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHZhciBnZXQgPSBlbnRyeS5nZXQsXG4gICAgICAgICAgICB0eXBlID0gZW50cnkudHlwZSxcbiAgICAgICAgICAgIHZhbHVlID0gaXRlbVtnZXRdKCk7XG5cbiAgICAgICAgaWYgKGVudHJ5LmV4cG9ydEZpbHRlciA/IGVudHJ5LmV4cG9ydEZpbHRlcihpdGVtLCB2YWx1ZSkgOiAhcGFyZW50IHx8ICFCYXNlLmVxdWFscyhwYXJlbnRbZ2V0XSgpLCB2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbG9yJyAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSB2YWx1ZS5nZXRBbHBoYSgpO1xuICAgICAgICAgICAgaWYgKGFscGhhIDwgMSkgYXR0cnNbZW50cnkuYXR0cmlidXRlICsgJy1vcGFjaXR5J10gPSBhbHBoYTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgc3R5bGUucHVzaChlbnRyeS5hdHRyaWJ1dGUgKyAnOiAnICsgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyc1tlbnRyeS5hdHRyaWJ1dGVdID0gdmFsdWUgPT0gbnVsbCA/ICdub25lJyA6IHR5cGUgPT09ICdjb2xvcicgPyB2YWx1ZS5ncmFkaWVudCA/IGV4cG9ydEdyYWRpZW50KHZhbHVlLCBpdGVtKSA6IHZhbHVlLnRvQ1NTKHRydWUpIDogdHlwZSA9PT0gJ2FycmF5JyA/IHZhbHVlLmpvaW4oJywnKSA6IHR5cGUgPT09ICdsb29rdXAnID8gZW50cnkudG9TVkdbdmFsdWVdIDogdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzdHlsZS5sZW5ndGgpIGF0dHJzLnN0eWxlID0gc3R5bGUuam9pbignOycpO1xuICAgICAgaWYgKGF0dHJzLm9wYWNpdHkgPT09IDEpIGRlbGV0ZSBhdHRycy5vcGFjaXR5O1xuICAgICAgaWYgKCFpdGVtLl92aXNpYmxlKSBhdHRycy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICByZXR1cm4gU3ZnRWxlbWVudC5zZXQobm9kZSwgYXR0cnMsIGZvcm1hdHRlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmluaXRpb25zO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbihpdGVtLCB0eXBlKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb25zKSBkZWZpbml0aW9ucyA9IHtcbiAgICAgICAgaWRzOiB7fSxcbiAgICAgICAgc3Znczoge31cbiAgICAgIH07XG4gICAgICByZXR1cm4gaXRlbSAmJiBkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyAoaXRlbS5faWQgfHwgaXRlbS5fX2lkIHx8IChpdGVtLl9faWQgPSBVSUQuZ2V0KCdzdmcnKSkpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXREZWZpbml0aW9uKGl0ZW0sIG5vZGUsIHR5cGUpIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbnMpIGdldERlZmluaXRpb24oKTtcbiAgICAgIHZhciB0eXBlSWQgPSBkZWZpbml0aW9ucy5pZHNbdHlwZV0gPSAoZGVmaW5pdGlvbnMuaWRzW3R5cGVdIHx8IDApICsgMTtcbiAgICAgIG5vZGUuaWQgPSB0eXBlICsgJy0nICsgdHlwZUlkO1xuICAgICAgZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nICsgKGl0ZW0uX2lkIHx8IGl0ZW0uX19pZCldID0gbm9kZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc3ZnID0gbm9kZSxcbiAgICAgICAgICBkZWZzID0gbnVsbDtcblxuICAgICAgaWYgKGRlZmluaXRpb25zKSB7XG4gICAgICAgIHN2ZyA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycgJiYgbm9kZTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIGRlZmluaXRpb25zLnN2Z3MpIHtcbiAgICAgICAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgICAgIGlmICghc3ZnKSB7XG4gICAgICAgICAgICAgIHN2ZyA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdzdmcnKTtcbiAgICAgICAgICAgICAgc3ZnLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZzID0gc3ZnLmluc2VydEJlZm9yZShTdmdFbGVtZW50LmNyZWF0ZSgnZGVmcycpLCBzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChkZWZpbml0aW9ucy5zdmdzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmluaXRpb25zID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnMuYXNTdHJpbmcgPyBuZXcgc2VsZi5YTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKSA6IHN2ZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRTVkcoaXRlbSwgb3B0aW9ucywgaXNSb290KSB7XG4gICAgICB2YXIgZXhwb3J0ZXIgPSBleHBvcnRlcnNbaXRlbS5fY2xhc3NdLFxuICAgICAgICAgIG5vZGUgPSBleHBvcnRlciAmJiBleHBvcnRlcihpdGVtLCBvcHRpb25zKTtcblxuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgdmFyIG9uRXhwb3J0ID0gb3B0aW9ucy5vbkV4cG9ydDtcbiAgICAgICAgaWYgKG9uRXhwb3J0KSBub2RlID0gb25FeHBvcnQoaXRlbSwgbm9kZSwgb3B0aW9ucykgfHwgbm9kZTtcbiAgICAgICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeShpdGVtLl9kYXRhKTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YSAhPT0gJ3t9JyAmJiBkYXRhICE9PSAnbnVsbCcpIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnLCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUgJiYgYXBwbHlTdHlsZShpdGVtLCBub2RlLCBpc1Jvb3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIEl0ZW0uaW5qZWN0KHtcbiAgICAgIGV4cG9ydFNWRzogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBleHBvcnREZWZpbml0aW9ucyhleHBvcnRTVkcodGhpcywgb3B0aW9ucywgdHJ1ZSksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFByb2plY3QuaW5qZWN0KHtcbiAgICAgIGV4cG9ydFNWRzogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgICAgdmlldyA9IHRoaXMuZ2V0VmlldygpLFxuICAgICAgICAgICAgYm91bmRzID0gQmFzZS5waWNrKG9wdGlvbnMuYm91bmRzLCAndmlldycpLFxuICAgICAgICAgICAgbXggPSBvcHRpb25zLm1hdHJpeCB8fCBib3VuZHMgPT09ICd2aWV3JyAmJiB2aWV3Ll9tYXRyaXgsXG4gICAgICAgICAgICBtYXRyaXggPSBteCAmJiBNYXRyaXgucmVhZChbbXhdKSxcbiAgICAgICAgICAgIHJlY3QgPSBib3VuZHMgPT09ICd2aWV3JyA/IG5ldyBSZWN0YW5nbGUoWzAsIDBdLCB2aWV3LmdldFZpZXdTaXplKCkpIDogYm91bmRzID09PSAnY29udGVudCcgPyBJdGVtLl9nZXRCb3VuZHMoY2hpbGRyZW4sIG1hdHJpeCwge1xuICAgICAgICAgIHN0cm9rZTogdHJ1ZVxuICAgICAgICB9KS5yZWN0IDogUmVjdGFuZ2xlLnJlYWQoW2JvdW5kc10sIDAsIHtcbiAgICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgICAgIGF0dHJzID0ge1xuICAgICAgICAgIHZlcnNpb246ICcxLjEnLFxuICAgICAgICAgIHhtbG5zOiBTdmdFbGVtZW50LnN2ZyxcbiAgICAgICAgICAneG1sbnM6eGxpbmsnOiBTdmdFbGVtZW50LnhsaW5rXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICBhdHRycy53aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgYXR0cnMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgaWYgKHJlY3QueCB8fCByZWN0LnggPT09IDAgfHwgcmVjdC55IHx8IHJlY3QueSA9PT0gMCkgYXR0cnMudmlld0JveCA9IGZvcm1hdHRlci5yZWN0YW5nbGUocmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZSA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdzdmcnLCBhdHRycywgZm9ybWF0dGVyKSxcbiAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG5cbiAgICAgICAgaWYgKG1hdHJpeCAmJiAhbWF0cml4LmlzSWRlbnRpdHkoKSkge1xuICAgICAgICAgIHBhcmVudCA9IG5vZGUuYXBwZW5kQ2hpbGQoU3ZnRWxlbWVudC5jcmVhdGUoJ2cnLCBnZXRUcmFuc2Zvcm0obWF0cml4KSwgZm9ybWF0dGVyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChleHBvcnRTVkcoY2hpbGRyZW5baV0sIG9wdGlvbnMsIHRydWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSgpO1xuICBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWZpbml0aW9ucyA9IHt9LFxuICAgICAgICByb290U2l6ZTtcblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlKG5vZGUsIG5hbWUsIGlzU3RyaW5nLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBTdmdFbGVtZW50LmdldChub2RlLCBuYW1lKSB8fCBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgcmVzID0gdmFsdWUgPT0gbnVsbCA/IGFsbG93TnVsbCA/IG51bGwgOiBpc1N0cmluZyA/ICcnIDogMCA6IGlzU3RyaW5nID8gdmFsdWUgOiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIHJldHVybiAvJVxccyokLy50ZXN0KHZhbHVlKSA/IHJlcyAvIDEwMCAqIChhbGxvd1BlcmNlbnQgPyAxIDogcm9vdFNpemVbL3h8XndpZHRoLy50ZXN0KG5hbWUpID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSkgOiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UG9pbnQobm9kZSwgeCwgeSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQsIGRlZmF1bHRYLCBkZWZhdWx0WSkge1xuICAgICAgeCA9IGdldFZhbHVlKG5vZGUsIHggfHwgJ3gnLCBmYWxzZSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQsIGRlZmF1bHRYKTtcbiAgICAgIHkgPSBnZXRWYWx1ZShub2RlLCB5IHx8ICd5JywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50LCBkZWZhdWx0WSk7XG4gICAgICByZXR1cm4gYWxsb3dOdWxsICYmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSA/IG51bGwgOiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2l6ZShub2RlLCB3LCBoLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCkge1xuICAgICAgdyA9IGdldFZhbHVlKG5vZGUsIHcgfHwgJ3dpZHRoJywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50KTtcbiAgICAgIGggPSBnZXRWYWx1ZShub2RlLCBoIHx8ICdoZWlnaHQnLCBmYWxzZSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQpO1xuICAgICAgcmV0dXJuIGFsbG93TnVsbCAmJiAodyA9PSBudWxsIHx8IGggPT0gbnVsbCkgPyBudWxsIDogbmV3IFNpemUodywgaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlLCB0eXBlLCBsb29rdXApIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gJ25vbmUnID8gbnVsbCA6IHR5cGUgPT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB0eXBlID09PSAnYXJyYXknID8gdmFsdWUgPyB2YWx1ZS5zcGxpdCgvW1xccyxdKy9nKS5tYXAocGFyc2VGbG9hdCkgOiBbXSA6IHR5cGUgPT09ICdjb2xvcicgPyBnZXREZWZpbml0aW9uKHZhbHVlKSB8fCB2YWx1ZSA6IHR5cGUgPT09ICdsb29rdXAnID8gbG9va3VwW3ZhbHVlXSA6IHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuICAgICAgdmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICAgIGlzQ2xpcCA9IHR5cGUgPT09ICdjbGlwcGF0aCcsXG4gICAgICAgICAgaXNEZWZzID0gdHlwZSA9PT0gJ2RlZnMnLFxuICAgICAgICAgIGl0ZW0gPSBuZXcgR3JvdXAoKSxcbiAgICAgICAgICBwcm9qZWN0ID0gaXRlbS5fcHJvamVjdCxcbiAgICAgICAgICBjdXJyZW50U3R5bGUgPSBwcm9qZWN0Ll9jdXJyZW50U3R5bGUsXG4gICAgICAgICAgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgaWYgKCFpc0NsaXAgJiYgIWlzRGVmcykge1xuICAgICAgICBpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG4gICAgICAgIHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGl0ZW0uX3N0eWxlLmNsb25lKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgdmFyIGRlZnMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2RlZnMnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGRlZnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaW1wb3J0Tm9kZShkZWZzW2ldLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IG5vZGVzW2ldLFxuICAgICAgICAgICAgY2hpbGQ7XG4gICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEgJiYgIS9eZGVmcyQvaS50ZXN0KGNoaWxkTm9kZS5ub2RlTmFtZSkgJiYgKGNoaWxkID0gaW1wb3J0Tm9kZShjaGlsZE5vZGUsIG9wdGlvbnMsIGZhbHNlKSkgJiYgIShjaGlsZCBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb24pKSBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaXRlbS5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICBpZiAoaXNDbGlwKSBpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0ucmVkdWNlKCksIG5vZGUsIGlzUm9vdCk7XG4gICAgICBwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBjdXJyZW50U3R5bGU7XG5cbiAgICAgIGlmIChpc0NsaXAgfHwgaXNEZWZzKSB7XG4gICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgIGl0ZW0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbXBvcnRQb2x5KG5vZGUsIHR5cGUpIHtcbiAgICAgIHZhciBjb29yZHMgPSBub2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJykubWF0Y2goL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpLFxuICAgICAgICAgIHBvaW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHBvaW50cy5wdXNoKG5ldyBQb2ludChwYXJzZUZsb2F0KGNvb3Jkc1tpXSksIHBhcnNlRmxvYXQoY29vcmRzW2kgKyAxXSkpKTtcblxuICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aChwb2ludHMpO1xuICAgICAgaWYgKHR5cGUgPT09ICdwb2x5Z29uJykgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydFBhdGgobm9kZSkge1xuICAgICAgcmV0dXJuIFBhdGhJdGVtLmNyZWF0ZShub2RlLmdldEF0dHJpYnV0ZSgnZCcpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbXBvcnRHcmFkaWVudChub2RlLCB0eXBlKSB7XG4gICAgICB2YXIgaWQgPSAoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSB8fCAnJykuc3Vic3RyaW5nKDEpLFxuICAgICAgICAgIHJhZGlhbCA9IHR5cGUgPT09ICdyYWRpYWxncmFkaWVudCcsXG4gICAgICAgICAgZ3JhZGllbnQ7XG5cbiAgICAgIGlmIChpZCkge1xuICAgICAgICBncmFkaWVudCA9IGRlZmluaXRpb25zW2lkXS5nZXRHcmFkaWVudCgpO1xuXG4gICAgICAgIGlmIChncmFkaWVudC5fcmFkaWFsIF4gcmFkaWFsKSB7XG4gICAgICAgICAgZ3JhZGllbnQgPSBncmFkaWVudC5jbG9uZSgpO1xuICAgICAgICAgIGdyYWRpZW50Ll9yYWRpYWwgPSByYWRpYWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2RlcyxcbiAgICAgICAgICAgIHN0b3BzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBub2Rlc1tpXTtcbiAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHN0b3BzLnB1c2goYXBwbHlBdHRyaWJ1dGVzKG5ldyBHcmFkaWVudFN0b3AoKSwgY2hpbGQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYWRpZW50ID0gbmV3IEdyYWRpZW50KHN0b3BzLCByYWRpYWwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ2luLFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgIGhpZ2hsaWdodCxcbiAgICAgICAgICBzY2FsZVRvQm91bmRzID0gZ2V0VmFsdWUobm9kZSwgJ2dyYWRpZW50VW5pdHMnLCB0cnVlKSAhPT0gJ3VzZXJTcGFjZU9uVXNlJztcblxuICAgICAgaWYgKHJhZGlhbCkge1xuICAgICAgICBvcmlnaW4gPSBnZXRQb2ludChub2RlLCAnY3gnLCAnY3knLCBmYWxzZSwgc2NhbGVUb0JvdW5kcywgJzUwJScsICc1MCUnKTtcbiAgICAgICAgZGVzdGluYXRpb24gPSBvcmlnaW4uYWRkKGdldFZhbHVlKG5vZGUsICdyJywgZmFsc2UsIGZhbHNlLCBzY2FsZVRvQm91bmRzLCAnNTAlJyksIDApO1xuICAgICAgICBoaWdobGlnaHQgPSBnZXRQb2ludChub2RlLCAnZngnLCAnZnknLCB0cnVlLCBzY2FsZVRvQm91bmRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICd4MScsICd5MScsIGZhbHNlLCBzY2FsZVRvQm91bmRzLCAnMCUnLCAnMCUnKTtcbiAgICAgICAgZGVzdGluYXRpb24gPSBnZXRQb2ludChub2RlLCAneDInLCAneTInLCBmYWxzZSwgc2NhbGVUb0JvdW5kcywgJzEwMCUnLCAnMCUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yID0gYXBwbHlBdHRyaWJ1dGVzKG5ldyBDb2xvcihncmFkaWVudCwgb3JpZ2luLCBkZXN0aW5hdGlvbiwgaGlnaGxpZ2h0KSwgbm9kZSk7XG4gICAgICBjb2xvci5fc2NhbGVUb0JvdW5kcyA9IHNjYWxlVG9Cb3VuZHM7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaW1wb3J0ZXJzID0ge1xuICAgICAgJyNkb2N1bWVudCc6IGZ1bmN0aW9uIChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSByZXR1cm4gaW1wb3J0Tm9kZShjaGlsZCwgb3B0aW9ucywgaXNSb290KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGc6IGltcG9ydEdyb3VwLFxuICAgICAgc3ZnOiBpbXBvcnRHcm91cCxcbiAgICAgIGNsaXBwYXRoOiBpbXBvcnRHcm91cCxcbiAgICAgIHBvbHlnb246IGltcG9ydFBvbHksXG4gICAgICBwb2x5bGluZTogaW1wb3J0UG9seSxcbiAgICAgIHBhdGg6IGltcG9ydFBhdGgsXG4gICAgICBsaW5lYXJncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG4gICAgICByYWRpYWxncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG4gICAgICBpbWFnZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSk7XG4gICAgICAgIHJhc3Rlci5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGdldFNpemUobm9kZSk7XG4gICAgICAgICAgdGhpcy5zZXRTaXplKHNpemUpO1xuICAgICAgICAgIHZhciBjZW50ZXIgPSBnZXRQb2ludChub2RlKS5hZGQoc2l6ZS5kaXZpZGUoMikpO1xuXG4gICAgICAgICAgdGhpcy5fbWF0cml4LmFwcGVuZChuZXcgTWF0cml4KCkudHJhbnNsYXRlKGNlbnRlcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJhc3RlcjtcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6IGZ1bmN0aW9uIChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2xEZWZpbml0aW9uKGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCksIHRydWUpO1xuICAgICAgfSxcbiAgICAgIGRlZnM6IGltcG9ydEdyb3VwLFxuICAgICAgdXNlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaWQgPSAoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSB8fCAnJykuc3Vic3RyaW5nKDEpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb25zW2lkXSxcbiAgICAgICAgICAgIHBvaW50ID0gZ2V0UG9pbnQobm9kZSk7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uID8gZGVmaW5pdGlvbiBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb24gPyBkZWZpbml0aW9uLnBsYWNlKHBvaW50KSA6IGRlZmluaXRpb24uY2xvbmUoKS50cmFuc2xhdGUocG9pbnQpIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBjaXJjbGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhcGUuQ2lyY2xlKGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpLCBnZXRWYWx1ZShub2RlLCAncicpKTtcbiAgICAgIH0sXG4gICAgICBlbGxpcHNlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNoYXBlLkVsbGlwc2Uoe1xuICAgICAgICAgIGNlbnRlcjogZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG4gICAgICAgICAgcmFkaXVzOiBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJlY3Q6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhcGUuUmVjdGFuZ2xlKG5ldyBSZWN0YW5nbGUoZ2V0UG9pbnQobm9kZSksIGdldFNpemUobm9kZSkpLCBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpKTtcbiAgICAgIH0sXG4gICAgICBsaW5lOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGguTGluZShnZXRQb2ludChub2RlLCAneDEnLCAneTEnKSwgZ2V0UG9pbnQobm9kZSwgJ3gyJywgJ3kyJykpO1xuICAgICAgfSxcbiAgICAgIHRleHQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IFBvaW50VGV4dChnZXRQb2ludChub2RlKS5hZGQoZ2V0UG9pbnQobm9kZSwgJ2R4JywgJ2R5JykpKTtcbiAgICAgICAgdGV4dC5zZXRDb250ZW50KG5vZGUudGV4dENvbnRlbnQudHJpbSgpIHx8ICcnKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9LFxuICAgICAgc3dpdGNoOiBpbXBvcnRHcm91cFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSkge1xuICAgICAgaWYgKGl0ZW0udHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1zID0gKG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8ICcnKS5zcGxpdCgvXFwpXFxzKi9nKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRyYW5zZm9ybXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbaV07XG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIGJyZWFrO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IHRyYW5zZm9ybS5zcGxpdCgvXFwoXFxzKi8pLFxuICAgICAgICAgICAgICBjb21tYW5kID0gcGFydHNbMF0sXG4gICAgICAgICAgICAgIHYgPSBwYXJ0c1sxXS5zcGxpdCgvW1xccyxdKy9nKTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBtID0gdi5sZW5ndGg7IGogPCBtOyBqKyspIHZbal0gPSBwYXJzZUZsb2F0KHZbal0pO1xuXG4gICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgICAgICAgICBtYXRyaXguYXBwZW5kKG5ldyBNYXRyaXgodlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgICAgbWF0cml4LnJvdGF0ZSh2WzBdLCB2WzFdIHx8IDAsIHZbMl0gfHwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHZbMF0sIHZbMV0gfHwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgICAgIG1hdHJpeC5zY2FsZSh2KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NrZXdYJzpcbiAgICAgICAgICAgICAgbWF0cml4LnNrZXcodlswXSwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdza2V3WSc6XG4gICAgICAgICAgICAgIG1hdHJpeC5za2V3KDAsIHZbMF0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLnRyYW5zZm9ybShtYXRyaXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5T3BhY2l0eShpdGVtLCB2YWx1ZSwgbmFtZSkge1xuICAgICAgdmFyIGtleSA9IG5hbWUgPT09ICdmaWxsLW9wYWNpdHknID8gJ2dldEZpbGxDb2xvcicgOiAnZ2V0U3Ryb2tlQ29sb3InLFxuICAgICAgICAgIGNvbG9yID0gaXRlbVtrZXldICYmIGl0ZW1ba2V5XSgpO1xuICAgICAgaWYgKGNvbG9yKSBjb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBCYXNlLnNldChCYXNlLmVhY2goU3ZnU3R5bGVzLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHRoaXNbZW50cnkuYXR0cmlidXRlXSA9IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXRlbVtlbnRyeS5zZXRdKSB7XG4gICAgICAgICAgaXRlbVtlbnRyeS5zZXRdKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgZW50cnkudHlwZSwgZW50cnkuZnJvbVNWRykpO1xuXG4gICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGl0ZW1bZW50cnkuZ2V0XSgpO1xuXG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbG9yLl9zY2FsZVRvQm91bmRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGl0ZW0uZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICAgICAgY29sb3IudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoYm91bmRzLmdldFBvaW50KCkpLnNjYWxlKGJvdW5kcy5nZXRTaXplKCkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCB7fSksIHtcbiAgICAgIGlkOiBmdW5jdGlvbiAoaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgZGVmaW5pdGlvbnNbdmFsdWVdID0gaXRlbTtcbiAgICAgICAgaWYgKGl0ZW0uc2V0TmFtZSkgaXRlbS5zZXROYW1lKHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICAnY2xpcC1wYXRoJzogZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgIHZhciBjbGlwID0gZ2V0RGVmaW5pdGlvbih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgICBjbGlwID0gY2xpcC5jbG9uZSgpO1xuICAgICAgICAgIGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICBpdGVtLmluc2VydENoaWxkKDAsIGNsaXApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdyb3VwKGNsaXAsIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcbiAgICAgIHRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG4gICAgICAnZmlsbC1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuICAgICAgdmlzaWJpbGl0eTogZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgIGlmIChpdGVtLnNldFZpc2libGUpIGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSA9PT0gJ3Zpc2libGUnKTtcbiAgICAgIH0sXG4gICAgICBkaXNwbGF5OiBmdW5jdGlvbiAoaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGl0ZW0uc2V0VmlzaWJsZSkgaXRlbS5zZXRWaXNpYmxlKHZhbHVlICE9PSBudWxsKTtcbiAgICAgIH0sXG4gICAgICAnc3RvcC1jb2xvcic6IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXRlbS5zZXRDb2xvcikgaXRlbS5zZXRDb2xvcih2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgJ3N0b3Atb3BhY2l0eSc6IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXRlbS5fY29sb3IpIGl0ZW0uX2NvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgIH0sXG4gICAgICBvZmZzZXQ6IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXRlbS5zZXRPZmZzZXQpIHtcbiAgICAgICAgICB2YXIgcGVyY2VudCA9IHZhbHVlLm1hdGNoKC8oLiopJSQvKTtcbiAgICAgICAgICBpdGVtLnNldE9mZnNldChwZXJjZW50ID8gcGVyY2VudFsxXSAvIDEwMCA6IHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpZXdCb3g6IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSB7XG4gICAgICAgIHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZShjb252ZXJ0VmFsdWUodmFsdWUsICdhcnJheScpKSxcbiAgICAgICAgICAgIHNpemUgPSBnZXRTaXplKG5vZGUsIG51bGwsIG51bGwsIHRydWUpLFxuICAgICAgICAgICAgZ3JvdXAsXG4gICAgICAgICAgICBtYXRyaXg7XG5cbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgIHZhciBzY2FsZSA9IHNpemUgPyBzaXplLmRpdmlkZShyZWN0LmdldFNpemUoKSkgOiAxLFxuICAgICAgICAgICAgICBtYXRyaXggPSBuZXcgTWF0cml4KCkuc2NhbGUoc2NhbGUpLnRyYW5zbGF0ZShyZWN0LmdldFBvaW50KCkubmVnYXRlKCkpO1xuICAgICAgICAgIGdyb3VwID0gaXRlbTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvbikge1xuICAgICAgICAgIGlmIChzaXplKSByZWN0LnNldFNpemUoc2l6ZSk7XG4gICAgICAgICAgZ3JvdXAgPSBpdGVtLl9pdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgaWYgKGdldEF0dHJpYnV0ZShub2RlLCAnb3ZlcmZsb3cnLCBzdHlsZXMpICE9PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgIHZhciBjbGlwID0gbmV3IFNoYXBlLlJlY3RhbmdsZShyZWN0KTtcbiAgICAgICAgICAgIGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG4gICAgICAgICAgICBncm91cC5hZGRDaGlsZChjbGlwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0cml4KSBncm91cC50cmFuc2Zvcm0obWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcykge1xuICAgICAgdmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbbmFtZV0sXG4gICAgICAgICAgdmFsdWUgPSBhdHRyICYmIGF0dHIudmFsdWU7XG5cbiAgICAgIGlmICghdmFsdWUgJiYgbm9kZS5zdHlsZSkge1xuICAgICAgICB2YXIgc3R5bGUgPSBCYXNlLmNhbWVsaXplKG5hbWUpO1xuICAgICAgICB2YWx1ZSA9IG5vZGUuc3R5bGVbc3R5bGVdO1xuICAgICAgICBpZiAoIXZhbHVlICYmIHN0eWxlcy5ub2RlW3N0eWxlXSAhPT0gc3R5bGVzLnBhcmVudFtzdHlsZV0pIHZhbHVlID0gc3R5bGVzLm5vZGVbc3R5bGVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIXZhbHVlID8gdW5kZWZpbmVkIDogdmFsdWUgPT09ICdub25lJyA/IG51bGwgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgIHN0eWxlcyA9IHtcbiAgICAgICAgbm9kZTogRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZSkgfHwge30sXG4gICAgICAgIHBhcmVudDogIWlzUm9vdCAmJiAhL15kZWZzJC9pLnRlc3QocGFyZW50LnRhZ05hbWUpICYmIERvbUVsZW1lbnQuZ2V0U3R5bGVzKHBhcmVudCkgfHwge31cbiAgICAgIH07XG4gICAgICBCYXNlLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24gKGFwcGx5LCBuYW1lKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpO1xuICAgICAgICBpdGVtID0gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiBhcHBseShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSB8fCBpdGVtO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREZWZpbml0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXFwoKD86W1wiJyNdKikoW15cIicpXSspLyksXG4gICAgICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdLFxuICAgICAgICAgIHJlcyA9IG5hbWUgJiYgZGVmaW5pdGlvbnNbd2luZG93ID8gbmFtZS5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcjJylbMF0gKyAnIycsICcnKSA6IG5hbWVdO1xuXG4gICAgICBpZiAocmVzICYmIHJlcy5fc2NhbGVUb0JvdW5kcykge1xuICAgICAgICByZXMgPSByZXMuY2xvbmUoKTtcbiAgICAgICAgcmVzLl9zY2FsZVRvQm91bmRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbXBvcnROb2RlKG5vZGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuICAgICAgdmFyIHR5cGUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgaXNFbGVtZW50ID0gdHlwZSAhPT0gJyNkb2N1bWVudCcsXG4gICAgICAgICAgYm9keSA9IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBuZXh0O1xuXG4gICAgICBpZiAoaXNSb290ICYmIGlzRWxlbWVudCkge1xuICAgICAgICByb290U2l6ZSA9IHBhcGVyLmdldFZpZXcoKS5nZXRTaXplKCk7XG4gICAgICAgIHJvb3RTaXplID0gZ2V0U2l6ZShub2RlLCBudWxsLCBudWxsLCB0cnVlKSB8fCByb290U2l6ZTtcbiAgICAgICAgY29udGFpbmVyID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3N2ZycsIHtcbiAgICAgICAgICBzdHlsZTogJ3N0cm9rZS13aWR0aDogMXB4OyBzdHJva2UtbWl0ZXJsaW1pdDogMTAnXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNldHRpbmdzID0gcGFwZXIuc2V0dGluZ3MsXG4gICAgICAgICAgYXBwbHlNYXRyaXggPSBzZXR0aW5ncy5hcHBseU1hdHJpeCxcbiAgICAgICAgICBpbnNlcnRJdGVtcyA9IHNldHRpbmdzLmluc2VydEl0ZW1zO1xuICAgICAgc2V0dGluZ3MuYXBwbHlNYXRyaXggPSBmYWxzZTtcbiAgICAgIHNldHRpbmdzLmluc2VydEl0ZW1zID0gZmFsc2U7XG4gICAgICB2YXIgaW1wb3J0ZXIgPSBpbXBvcnRlcnNbdHlwZV0sXG4gICAgICAgICAgaXRlbSA9IGltcG9ydGVyICYmIGltcG9ydGVyKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkgfHwgbnVsbDtcbiAgICAgIHNldHRpbmdzLmluc2VydEl0ZW1zID0gaW5zZXJ0SXRlbXM7XG4gICAgICBzZXR0aW5ncy5hcHBseU1hdHJpeCA9IGFwcGx5TWF0cml4O1xuXG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBpZiAoaXNFbGVtZW50ICYmICEoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSkgaXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuICAgICAgICB2YXIgb25JbXBvcnQgPSBvcHRpb25zLm9uSW1wb3J0LFxuICAgICAgICAgICAgZGF0YSA9IGlzRWxlbWVudCAmJiBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJyk7XG4gICAgICAgIGlmIChvbkltcG9ydCkgaXRlbSA9IG9uSW1wb3J0KG5vZGUsIGl0ZW0sIG9wdGlvbnMpIHx8IGl0ZW07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwYW5kU2hhcGVzICYmIGl0ZW0gaW5zdGFuY2VvZiBTaGFwZSkge1xuICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgaXRlbSA9IGl0ZW0udG9QYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSkgaXRlbS5fZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgYm9keS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIGRlZmluaXRpb25zID0ge307XG4gICAgICAgIGlmIChpdGVtICYmIEJhc2UucGljayhvcHRpb25zLmFwcGx5TWF0cml4LCBhcHBseU1hdHJpeCkpIGl0ZW0ubWF0cml4LmFwcGx5KHRydWUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbXBvcnRTVkcoc291cmNlLCBvcHRpb25zLCBvd25lcikge1xuICAgICAgaWYgKCFzb3VyY2UpIHJldHVybiBudWxsO1xuICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8ge1xuICAgICAgICBvbkxvYWQ6IG9wdGlvbnNcbiAgICAgIH0gOiBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHNjb3BlID0gcGFwZXIsXG4gICAgICAgICAgaXRlbSA9IG51bGw7XG5cbiAgICAgIGZ1bmN0aW9uIG9uTG9hZChzdmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBzdmcgPT09ICdvYmplY3QnID8gc3ZnIDogbmV3IHNlbGYuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHN2Zy50cmltKCksICdpbWFnZS9zdmcreG1sJyk7XG5cbiAgICAgICAgICBpZiAoIW5vZGUubm9kZU5hbWUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBTVkcgc291cmNlOiAnICsgc291cmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXBlciA9IHNjb3BlO1xuICAgICAgICAgIGl0ZW0gPSBpbXBvcnROb2RlKG5vZGUsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuaW5zZXJ0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3duZXIuX2luc2VydEl0ZW0odW5kZWZpbmVkLCBpdGVtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb25Mb2FkID0gb3B0aW9ucy5vbkxvYWQ7XG4gICAgICAgICAgaWYgKG9uTG9hZCkgb25Mb2FkKGl0ZW0sIHN2Zyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgICAgIHZhciBvbkVycm9yID0gb3B0aW9ucy5vbkVycm9yO1xuXG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihtZXNzYWdlLCBzdGF0dXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgIS9eW1xcc1xcU10qPC8udGVzdChzb3VyY2UpKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc291cmNlKTtcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIG9uTG9hZChub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBIdHRwLnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsOiBzb3VyY2UsXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIG9uTG9hZDogb25Mb2FkLFxuICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb25Mb2FkKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9uRXJyb3IocmVhZGVyLmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRBc1RleHQoc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uTG9hZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBJdGVtLmluamVjdCh7XG4gICAgICBpbXBvcnRTVkc6IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgUHJvamVjdC5pbmplY3Qoe1xuICAgICAgaW1wb3J0U1ZHOiBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgIHJldHVybiBpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0oKTtcblxuICBCYXNlLmV4cG9ydHMuUGFwZXJTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdsb2JhbCA9IHRoaXMsXG4gICAgICAgIGFjb3JuID0gZ2xvYmFsLmFjb3JuO1xuXG4gICAgaWYgKCFhY29ybiAmJiB0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjb3JuID0gcmVxdWlyZSgnYWNvcm4nKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgaWYgKCFhY29ybikge1xuICAgICAgdmFyIGV4cG9ydHMsIG1vZHVsZTtcbiAgICAgIGFjb3JuID0gZXhwb3J0cyA9IG1vZHVsZSA9IHt9O1xuXG4gICAgICAoZnVuY3Rpb24gKHJvb3QsIG1vZCkge1xuICAgICAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIHJldHVybiBtb2QoZXhwb3J0cyk7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSByZXR1cm4gZGVmaW5lKFtcImV4cG9ydHNcIl0sIG1vZCk7XG4gICAgICAgIG1vZChyb290LmFjb3JuIHx8IChyb290LmFjb3JuID0ge30pKTtcbiAgICAgIH0pKHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgIGV4cG9ydHMudmVyc2lvbiA9IFwiMC41LjBcIjtcbiAgICAgICAgdmFyIG9wdGlvbnMsIGlucHV0LCBpbnB1dExlbiwgc291cmNlRmlsZTtcblxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKGlucHQsIG9wdHMpIHtcbiAgICAgICAgICBpbnB1dCA9IFN0cmluZyhpbnB0KTtcbiAgICAgICAgICBpbnB1dExlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICBzZXRPcHRpb25zKG9wdHMpO1xuICAgICAgICAgIGluaXRUb2tlblN0YXRlKCk7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVG9wTGV2ZWwob3B0aW9ucy5wcm9ncmFtKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgIGVjbWFWZXJzaW9uOiA1LFxuICAgICAgICAgIHN0cmljdFNlbWljb2xvbnM6IGZhbHNlLFxuICAgICAgICAgIGFsbG93VHJhaWxpbmdDb21tYXM6IHRydWUsXG4gICAgICAgICAgZm9yYmlkUmVzZXJ2ZWQ6IGZhbHNlLFxuICAgICAgICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICAgICAgICBsb2NhdGlvbnM6IGZhbHNlLFxuICAgICAgICAgIG9uQ29tbWVudDogbnVsbCxcbiAgICAgICAgICByYW5nZXM6IGZhbHNlLFxuICAgICAgICAgIHByb2dyYW06IG51bGwsXG4gICAgICAgICAgc291cmNlRmlsZTogbnVsbCxcbiAgICAgICAgICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG9wdCkpIG9wdGlvbnNbb3B0XSA9IGRlZmF1bHRPcHRpb25zW29wdF07XG5cbiAgICAgICAgICBzb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlIHx8IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0TGluZUluZm8gPSBleHBvcnRzLmdldExpbmVJbmZvID0gZnVuY3Rpb24gKGlucHV0LCBvZmZzZXQpIHtcbiAgICAgICAgICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgICAgICAgICBsaW5lQnJlYWsubGFzdEluZGV4ID0gY3VyO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZUJyZWFrLmV4ZWMoaW5wdXQpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICBjdXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb2Zmc2V0IC0gY3VyXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBleHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gKGlucHQsIG9wdHMpIHtcbiAgICAgICAgICBpbnB1dCA9IFN0cmluZyhpbnB0KTtcbiAgICAgICAgICBpbnB1dExlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICBzZXRPcHRpb25zKG9wdHMpO1xuICAgICAgICAgIGluaXRUb2tlblN0YXRlKCk7XG4gICAgICAgICAgdmFyIHQgPSB7fTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFRva2VuKGZvcmNlUmVnZXhwKSB7XG4gICAgICAgICAgICBsYXN0RW5kID0gdG9rRW5kO1xuICAgICAgICAgICAgcmVhZFRva2VuKGZvcmNlUmVnZXhwKTtcbiAgICAgICAgICAgIHQuc3RhcnQgPSB0b2tTdGFydDtcbiAgICAgICAgICAgIHQuZW5kID0gdG9rRW5kO1xuICAgICAgICAgICAgdC5zdGFydExvYyA9IHRva1N0YXJ0TG9jO1xuICAgICAgICAgICAgdC5lbmRMb2MgPSB0b2tFbmRMb2M7XG4gICAgICAgICAgICB0LnR5cGUgPSB0b2tUeXBlO1xuICAgICAgICAgICAgdC52YWx1ZSA9IHRva1ZhbDtcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldFRva2VuLmp1bXBUbyA9IGZ1bmN0aW9uIChwb3MsIHJlQWxsb3dlZCkge1xuICAgICAgICAgICAgdG9rUG9zID0gcG9zO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgdG9rQ3VyTGluZSA9IDE7XG4gICAgICAgICAgICAgIHRva0xpbmVTdGFydCA9IGxpbmVCcmVhay5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICB2YXIgbWF0Y2g7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVhay5leGVjKGlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCBwb3MpIHtcbiAgICAgICAgICAgICAgICArK3Rva0N1ckxpbmU7XG4gICAgICAgICAgICAgICAgdG9rTGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9rUmVnZXhwQWxsb3dlZCA9IHJlQWxsb3dlZDtcbiAgICAgICAgICAgIHNraXBTcGFjZSgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gZ2V0VG9rZW47XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRva1BvcztcbiAgICAgICAgdmFyIHRva1N0YXJ0LCB0b2tFbmQ7XG4gICAgICAgIHZhciB0b2tTdGFydExvYywgdG9rRW5kTG9jO1xuICAgICAgICB2YXIgdG9rVHlwZSwgdG9rVmFsO1xuICAgICAgICB2YXIgdG9rUmVnZXhwQWxsb3dlZDtcbiAgICAgICAgdmFyIHRva0N1ckxpbmUsIHRva0xpbmVTdGFydDtcbiAgICAgICAgdmFyIGxhc3RTdGFydCwgbGFzdEVuZCwgbGFzdEVuZExvYztcbiAgICAgICAgdmFyIGluRnVuY3Rpb24sIGxhYmVscywgc3RyaWN0O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJhaXNlKHBvcywgbWVzc2FnZSkge1xuICAgICAgICAgIHZhciBsb2MgPSBnZXRMaW5lSW5mbyhpbnB1dCwgcG9zKTtcbiAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBlcnIucG9zID0gcG9zO1xuICAgICAgICAgIGVyci5sb2MgPSBsb2M7XG4gICAgICAgICAgZXJyLnJhaXNlZEF0ID0gdG9rUG9zO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbXB0eSA9IFtdO1xuICAgICAgICB2YXIgX251bSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm51bVwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfcmVnZXhwID0ge1xuICAgICAgICAgIHR5cGU6IFwicmVnZXhwXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9zdHJpbmcgPSB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgX25hbWUgPSB7XG4gICAgICAgICAgdHlwZTogXCJuYW1lXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9lb2YgPSB7XG4gICAgICAgICAgdHlwZTogXCJlb2ZcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2JyZWFrID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiYnJlYWtcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX2Nhc2UgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJjYXNlXCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX2NhdGNoID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiY2F0Y2hcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2NvbnRpbnVlID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiY29udGludWVcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX2RlYnVnZ2VyID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiZGVidWdnZXJcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX2RlZmF1bHQgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJkZWZhdWx0XCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9kbyA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImRvXCIsXG4gICAgICAgICAgaXNMb29wOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfZWxzZSA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImVsc2VcIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfZmluYWxseSA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImZpbmFsbHlcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX2ZvciA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImZvclwiLFxuICAgICAgICAgIGlzTG9vcDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX2Z1bmN0aW9uID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiZnVuY3Rpb25cIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2lmID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiaWZcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX3JldHVybiA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcInJldHVyblwiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9zd2l0Y2ggPSB7XG4gICAgICAgICAga2V5d29yZDogXCJzd2l0Y2hcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3Rocm93ID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwidGhyb3dcIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfdHJ5ID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwidHJ5XCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF92YXIgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJ2YXJcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3doaWxlID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwid2hpbGVcIixcbiAgICAgICAgICBpc0xvb3A6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF93aXRoID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwid2l0aFwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfbmV3ID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwibmV3XCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3RoaXMgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJ0aGlzXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9udWxsID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwibnVsbFwiLFxuICAgICAgICAgIGF0b21WYWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAgICAgX3RydWUgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJ0cnVlXCIsXG4gICAgICAgICAgYXRvbVZhbHVlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfZmFsc2UgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJmYWxzZVwiLFxuICAgICAgICAgIGF0b21WYWx1ZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9pbiA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImluXCIsXG4gICAgICAgICAgYmlub3A6IDcsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIga2V5d29yZFR5cGVzID0ge1xuICAgICAgICAgIFwiYnJlYWtcIjogX2JyZWFrLFxuICAgICAgICAgIFwiY2FzZVwiOiBfY2FzZSxcbiAgICAgICAgICBcImNhdGNoXCI6IF9jYXRjaCxcbiAgICAgICAgICBcImNvbnRpbnVlXCI6IF9jb250aW51ZSxcbiAgICAgICAgICBcImRlYnVnZ2VyXCI6IF9kZWJ1Z2dlcixcbiAgICAgICAgICBcImRlZmF1bHRcIjogX2RlZmF1bHQsXG4gICAgICAgICAgXCJkb1wiOiBfZG8sXG4gICAgICAgICAgXCJlbHNlXCI6IF9lbHNlLFxuICAgICAgICAgIFwiZmluYWxseVwiOiBfZmluYWxseSxcbiAgICAgICAgICBcImZvclwiOiBfZm9yLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIjogX2Z1bmN0aW9uLFxuICAgICAgICAgIFwiaWZcIjogX2lmLFxuICAgICAgICAgIFwicmV0dXJuXCI6IF9yZXR1cm4sXG4gICAgICAgICAgXCJzd2l0Y2hcIjogX3N3aXRjaCxcbiAgICAgICAgICBcInRocm93XCI6IF90aHJvdyxcbiAgICAgICAgICBcInRyeVwiOiBfdHJ5LFxuICAgICAgICAgIFwidmFyXCI6IF92YXIsXG4gICAgICAgICAgXCJ3aGlsZVwiOiBfd2hpbGUsXG4gICAgICAgICAgXCJ3aXRoXCI6IF93aXRoLFxuICAgICAgICAgIFwibnVsbFwiOiBfbnVsbCxcbiAgICAgICAgICBcInRydWVcIjogX3RydWUsXG4gICAgICAgICAgXCJmYWxzZVwiOiBfZmFsc2UsXG4gICAgICAgICAgXCJuZXdcIjogX25ldyxcbiAgICAgICAgICBcImluXCI6IF9pbixcbiAgICAgICAgICBcImluc3RhbmNlb2ZcIjoge1xuICAgICAgICAgICAga2V5d29yZDogXCJpbnN0YW5jZW9mXCIsXG4gICAgICAgICAgICBiaW5vcDogNyxcbiAgICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGhpc1wiOiBfdGhpcyxcbiAgICAgICAgICBcInR5cGVvZlwiOiB7XG4gICAgICAgICAgICBrZXl3b3JkOiBcInR5cGVvZlwiLFxuICAgICAgICAgICAgcHJlZml4OiB0cnVlLFxuICAgICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ2b2lkXCI6IHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwidm9pZFwiLFxuICAgICAgICAgICAgcHJlZml4OiB0cnVlLFxuICAgICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVcIjoge1xuICAgICAgICAgICAga2V5d29yZDogXCJkZWxldGVcIixcbiAgICAgICAgICAgIHByZWZpeDogdHJ1ZSxcbiAgICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBfYnJhY2tldEwgPSB7XG4gICAgICAgICAgdHlwZTogXCJbXCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX2JyYWNrZXRSID0ge1xuICAgICAgICAgIHR5cGU6IFwiXVwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfYnJhY2VMID0ge1xuICAgICAgICAgIHR5cGU6IFwie1wiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9icmFjZVIgPSB7XG4gICAgICAgICAgdHlwZTogXCJ9XCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9wYXJlbkwgPSB7XG4gICAgICAgICAgdHlwZTogXCIoXCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX3BhcmVuUiA9IHtcbiAgICAgICAgICB0eXBlOiBcIilcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2NvbW1hID0ge1xuICAgICAgICAgIHR5cGU6IFwiLFwiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZW1pID0ge1xuICAgICAgICAgIHR5cGU6IFwiO1wiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9jb2xvbiA9IHtcbiAgICAgICAgICB0eXBlOiBcIjpcIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfZG90ID0ge1xuICAgICAgICAgIHR5cGU6IFwiLlwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfcXVlc3Rpb24gPSB7XG4gICAgICAgICAgdHlwZTogXCI/XCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3NsYXNoID0ge1xuICAgICAgICAgIGJpbm9wOiAxMCxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfZXEgPSB7XG4gICAgICAgICAgaXNBc3NpZ246IHRydWUsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2Fzc2lnbiA9IHtcbiAgICAgICAgICBpc0Fzc2lnbjogdHJ1ZSxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfaW5jRGVjID0ge1xuICAgICAgICAgIHBvc3RmaXg6IHRydWUsXG4gICAgICAgICAgcHJlZml4OiB0cnVlLFxuICAgICAgICAgIGlzVXBkYXRlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfcHJlZml4ID0ge1xuICAgICAgICAgIHByZWZpeDogdHJ1ZSxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfbG9naWNhbE9SID0ge1xuICAgICAgICAgIGJpbm9wOiAxLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9sb2dpY2FsQU5EID0ge1xuICAgICAgICAgIGJpbm9wOiAyLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9iaXR3aXNlT1IgPSB7XG4gICAgICAgICAgYmlub3A6IDMsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2JpdHdpc2VYT1IgPSB7XG4gICAgICAgICAgYmlub3A6IDQsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2JpdHdpc2VBTkQgPSB7XG4gICAgICAgICAgYmlub3A6IDUsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2VxdWFsaXR5ID0ge1xuICAgICAgICAgIGJpbm9wOiA2LFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9yZWxhdGlvbmFsID0ge1xuICAgICAgICAgIGJpbm9wOiA3LFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9iaXRTaGlmdCA9IHtcbiAgICAgICAgICBiaW5vcDogOCxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfcGx1c01pbiA9IHtcbiAgICAgICAgICBiaW5vcDogOSxcbiAgICAgICAgICBwcmVmaXg6IHRydWUsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX211bHRpcGx5TW9kdWxvID0ge1xuICAgICAgICAgIGJpbm9wOiAxMCxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGV4cG9ydHMudG9rVHlwZXMgPSB7XG4gICAgICAgICAgYnJhY2tldEw6IF9icmFja2V0TCxcbiAgICAgICAgICBicmFja2V0UjogX2JyYWNrZXRSLFxuICAgICAgICAgIGJyYWNlTDogX2JyYWNlTCxcbiAgICAgICAgICBicmFjZVI6IF9icmFjZVIsXG4gICAgICAgICAgcGFyZW5MOiBfcGFyZW5MLFxuICAgICAgICAgIHBhcmVuUjogX3BhcmVuUixcbiAgICAgICAgICBjb21tYTogX2NvbW1hLFxuICAgICAgICAgIHNlbWk6IF9zZW1pLFxuICAgICAgICAgIGNvbG9uOiBfY29sb24sXG4gICAgICAgICAgZG90OiBfZG90LFxuICAgICAgICAgIHF1ZXN0aW9uOiBfcXVlc3Rpb24sXG4gICAgICAgICAgc2xhc2g6IF9zbGFzaCxcbiAgICAgICAgICBlcTogX2VxLFxuICAgICAgICAgIG5hbWU6IF9uYW1lLFxuICAgICAgICAgIGVvZjogX2VvZixcbiAgICAgICAgICBudW06IF9udW0sXG4gICAgICAgICAgcmVnZXhwOiBfcmVnZXhwLFxuICAgICAgICAgIHN0cmluZzogX3N0cmluZ1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGt3IGluIGtleXdvcmRUeXBlcykgZXhwb3J0cy50b2tUeXBlc1tcIl9cIiArIGt3XSA9IGtleXdvcmRUeXBlc1trd107XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZVByZWRpY2F0ZSh3b3Jkcykge1xuICAgICAgICAgIHdvcmRzID0gd29yZHMuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgIHZhciBmID0gXCJcIixcbiAgICAgICAgICAgICAgY2F0cyA9IFtdO1xuXG4gICAgICAgICAgb3V0OiBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhdHMubGVuZ3RoOyArK2opIGlmIChjYXRzW2pdWzBdLmxlbmd0aCA9PSB3b3Jkc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2F0c1tqXS5wdXNoKHdvcmRzW2ldKTtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXRzLnB1c2goW3dvcmRzW2ldXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY29tcGFyZVRvKGFycikge1xuICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPT0gMSkgcmV0dXJuIGYgKz0gXCJyZXR1cm4gc3RyID09PSBcIiArIEpTT04uc3RyaW5naWZ5KGFyclswXSkgKyBcIjtcIjtcbiAgICAgICAgICAgIGYgKz0gXCJzd2l0Y2goc3RyKXtcIjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIGYgKz0gXCJjYXNlIFwiICsgSlNPTi5zdHJpbmdpZnkoYXJyW2ldKSArIFwiOlwiO1xuXG4gICAgICAgICAgICBmICs9IFwicmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjYXRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIGNhdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZiArPSBcInN3aXRjaChzdHIubGVuZ3RoKXtcIjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBjYXQgPSBjYXRzW2ldO1xuICAgICAgICAgICAgICBmICs9IFwiY2FzZSBcIiArIGNhdFswXS5sZW5ndGggKyBcIjpcIjtcbiAgICAgICAgICAgICAgY29tcGFyZVRvKGNhdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGYgKz0gXCJ9XCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBhcmVUbyh3b3Jkcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInN0clwiLCBmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc1Jlc2VydmVkV29yZDMgPSBtYWtlUHJlZGljYXRlKFwiYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZVwiKTtcbiAgICAgICAgdmFyIGlzUmVzZXJ2ZWRXb3JkNSA9IG1ha2VQcmVkaWNhdGUoXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiKTtcbiAgICAgICAgdmFyIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkID0gbWFrZVByZWRpY2F0ZShcImltcGxlbWVudHMgaW50ZXJmYWNlIGxldCBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgeWllbGRcIik7XG4gICAgICAgIHZhciBpc1N0cmljdEJhZElkV29yZCA9IG1ha2VQcmVkaWNhdGUoXCJldmFsIGFyZ3VtZW50c1wiKTtcbiAgICAgICAgdmFyIGlzS2V5d29yZCA9IG1ha2VQcmVkaWNhdGUoXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIik7XG4gICAgICAgIHZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuICAgICAgICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbiAgICAgICAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NDlcXHUwNjcyLVxcdTA2ZDNcXHUwNmU3LVxcdTA2ZThcXHUwNmZiLVxcdTA2ZmNcXHUwNzMwLVxcdTA3NGFcXHUwODAwLVxcdTA4MTRcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODQwLVxcdTA4NTdcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWQ3XFx1MDlkZi1cXHUwOWUwXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVmLVxcdTBiNjBcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2Mi1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAyXFx1MGQwM1xcdTBkNDYtXFx1MGQ0OFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTM0LVxcdTBlM2FcXHUwZTQwLVxcdTBlNDVcXHUwZTUwLVxcdTBlNTlcXHUwZWI0LVxcdTBlYjlcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNDEtXFx1MGY0N1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzBlLVxcdTE3MTBcXHUxNzIwLVxcdTE3MzBcXHUxNzQwLVxcdTE3NTBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdiMlxcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTUxLVxcdTE5NmRcXHUxOWIwLVxcdTE5YzBcXHUxOWM4LVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTVcXHUxYTIwLVxcdTFhNTNcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYjQ2LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzAwLVxcdTFjMjJcXHUxYzQwLVxcdTFjNDlcXHUxYzViLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxZDAwLVxcdTFkYmVcXHUxZTAxLVxcdTFmMTVcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyZDgxLVxcdTJkOTZcXHUyZGUwLVxcdTJkZmZcXHUzMDIxLVxcdTMwMjhcXHUzMDk5XFx1MzA5YVxcdWE2NDAtXFx1YTY2ZFxcdWE2NzQtXFx1YTY3ZFxcdWE2OWZcXHVhNmYwLVxcdWE2ZjFcXHVhN2Y4LVxcdWE4MDBcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODAtXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZjMtXFx1YThmN1xcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5MzAtXFx1YTk0NVxcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWFhMDAtXFx1YWEyN1xcdWFhNDAtXFx1YWE0MVxcdWFhNGMtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWUwLVxcdWFhZTlcXHVhYWYyLVxcdWFhZjNcXHVhYmMwLVxcdWFiZTFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMjAtXFx1ZmIyOFxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuICAgICAgICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbiAgICAgICAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG4gICAgICAgIHZhciBuZXdsaW5lID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuICAgICAgICB2YXIgbGluZUJyZWFrID0gL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldL2c7XG5cbiAgICAgICAgdmFyIGlzSWRlbnRpZmllclN0YXJ0ID0gZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICAgICAgICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICAgICAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpc0lkZW50aWZpZXJDaGFyID0gZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gICAgICAgICAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICAgICAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBsaW5lX2xvY190KCkge1xuICAgICAgICAgIHRoaXMubGluZSA9IHRva0N1ckxpbmU7XG4gICAgICAgICAgdGhpcy5jb2x1bW4gPSB0b2tQb3MgLSB0b2tMaW5lU3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0VG9rZW5TdGF0ZSgpIHtcbiAgICAgICAgICB0b2tDdXJMaW5lID0gMTtcbiAgICAgICAgICB0b2tQb3MgPSB0b2tMaW5lU3RhcnQgPSAwO1xuICAgICAgICAgIHRva1JlZ2V4cEFsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgIHNraXBTcGFjZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluaXNoVG9rZW4odHlwZSwgdmFsKSB7XG4gICAgICAgICAgdG9rRW5kID0gdG9rUG9zO1xuICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgdG9rRW5kTG9jID0gbmV3IGxpbmVfbG9jX3QoKTtcbiAgICAgICAgICB0b2tUeXBlID0gdHlwZTtcbiAgICAgICAgICBza2lwU3BhY2UoKTtcbiAgICAgICAgICB0b2tWYWwgPSB2YWw7XG4gICAgICAgICAgdG9rUmVnZXhwQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNraXBCbG9ja0NvbW1lbnQoKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0TG9jID0gb3B0aW9ucy5vbkNvbW1lbnQgJiYgb3B0aW9ucy5sb2NhdGlvbnMgJiYgbmV3IGxpbmVfbG9jX3QoKTtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0b2tQb3MsXG4gICAgICAgICAgICAgIGVuZCA9IGlucHV0LmluZGV4T2YoXCIqL1wiLCB0b2tQb3MgKz0gMik7XG4gICAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHJhaXNlKHRva1BvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7XG4gICAgICAgICAgdG9rUG9zID0gZW5kICsgMjtcblxuICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgbGluZUJyZWFrLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgICAgICAgdmFyIG1hdGNoO1xuXG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrLmV4ZWMoaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRva1Bvcykge1xuICAgICAgICAgICAgICArK3Rva0N1ckxpbmU7XG4gICAgICAgICAgICAgIHRva0xpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLm9uQ29tbWVudCkgb3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdG9rUG9zLCBzdGFydExvYywgb3B0aW9ucy5sb2NhdGlvbnMgJiYgbmV3IGxpbmVfbG9jX3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBza2lwTGluZUNvbW1lbnQoKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdG9rUG9zO1xuICAgICAgICAgIHZhciBzdGFydExvYyA9IG9wdGlvbnMub25Db21tZW50ICYmIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190KCk7XG4gICAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKz0gMik7XG5cbiAgICAgICAgICB3aGlsZSAodG9rUG9zIDwgaW5wdXRMZW4gJiYgY2ggIT09IDEwICYmIGNoICE9PSAxMyAmJiBjaCAhPT0gODIzMiAmJiBjaCAhPT0gODIzMykge1xuICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5vbkNvbW1lbnQpIG9wdGlvbnMub25Db21tZW50KGZhbHNlLCBpbnB1dC5zbGljZShzdGFydCArIDIsIHRva1BvcyksIHN0YXJ0LCB0b2tQb3MsIHN0YXJ0TG9jLCBvcHRpb25zLmxvY2F0aW9ucyAmJiBuZXcgbGluZV9sb2NfdCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNraXBTcGFjZSgpIHtcbiAgICAgICAgICB3aGlsZSAodG9rUG9zIDwgaW5wdXRMZW4pIHtcbiAgICAgICAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAzMikge1xuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDEzKSB7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblxuICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgICAgICsrdG9rQ3VyTGluZTtcbiAgICAgICAgICAgICAgICB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDEwIHx8IGNoID09PSA4MjMyIHx8IGNoID09PSA4MjMzKSB7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgICAgICsrdG9rQ3VyTGluZTtcbiAgICAgICAgICAgICAgICB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPiA4ICYmIGNoIDwgMTQpIHtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSA0Nykge1xuICAgICAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cbiAgICAgICAgICAgICAgaWYgKG5leHQgPT09IDQyKSB7XG4gICAgICAgICAgICAgICAgc2tpcEJsb2NrQ29tbWVudCgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHQgPT09IDQ3KSB7XG4gICAgICAgICAgICAgICAgc2tpcExpbmVDb21tZW50KCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDE2MCkge1xuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVG9rZW5fZG90KCkge1xuICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSByZXR1cm4gcmVhZE51bWJlcih0cnVlKTtcbiAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2RvdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVG9rZW5fc2xhc2goKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXG4gICAgICAgICAgaWYgKHRva1JlZ2V4cEFsbG93ZWQpIHtcbiAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRSZWdleHAoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoT3AoX3NsYXNoLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUb2tlbl9tdWx0X21vZHVsbygpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE9wKF9tdWx0aXBseU1vZHVsbywgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gY29kZSkgcmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IF9sb2dpY2FsT1IgOiBfbG9naWNhbEFORCwgMik7XG4gICAgICAgICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IF9iaXR3aXNlT1IgOiBfYml0d2lzZUFORCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVG9rZW5fY2FyZXQoKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hPcChfYml0d2lzZVhPUiwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVG9rZW5fcGx1c19taW4oY29kZSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblxuICAgICAgICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSA0NSAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09IDYyICYmIG5ld2xpbmUudGVzdChpbnB1dC5zbGljZShsYXN0RW5kLCB0b2tQb3MpKSkge1xuICAgICAgICAgICAgICB0b2tQb3MgKz0gMztcbiAgICAgICAgICAgICAgc2tpcExpbmVDb21tZW50KCk7XG4gICAgICAgICAgICAgIHNraXBTcGFjZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hPcChfaW5jRGVjLCAyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoT3AoX3BsdXNNaW4sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFRva2VuX2x0X2d0KGNvZGUpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgICAgICAgdmFyIHNpemUgPSAxO1xuXG4gICAgICAgICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgICAgICAgIHNpemUgPSBjb2RlID09PSA2MiAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgc2l6ZSkgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgc2l6ZSArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE9wKF9iaXRTaGlmdCwgc2l6ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHQgPT0gMzMgJiYgY29kZSA9PSA2MCAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09IDQ1ICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMykgPT0gNDUpIHtcbiAgICAgICAgICAgIHRva1BvcyArPSA0O1xuICAgICAgICAgICAgc2tpcExpbmVDb21tZW50KCk7XG4gICAgICAgICAgICBza2lwU3BhY2UoKTtcbiAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW4oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHNpemUgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09PSA2MSA/IDMgOiAyO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hPcChfcmVsYXRpb25hbCwgc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVG9rZW5fZXFfZXhjbChjb2RlKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9lcXVhbGl0eSwgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PT0gNjEgPyAzIDogMik7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDYxID8gX2VxIDogX3ByZWZpeCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5fZG90KCk7XG5cbiAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX3BhcmVuTCk7XG5cbiAgICAgICAgICAgIGNhc2UgNDE6XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX3BhcmVuUik7XG5cbiAgICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX3NlbWkpO1xuXG4gICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9jb21tYSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTE6XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNrZXRMKTtcblxuICAgICAgICAgICAgY2FzZSA5MzpcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2tldFIpO1xuXG4gICAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2VMKTtcblxuICAgICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNlUik7XG5cbiAgICAgICAgICAgIGNhc2UgNTg6XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2NvbG9uKTtcblxuICAgICAgICAgICAgY2FzZSA2MzpcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfcXVlc3Rpb24pO1xuXG4gICAgICAgICAgICBjYXNlIDQ4OlxuICAgICAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgICAgICAgICAgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHJldHVybiByZWFkSGV4TnVtYmVyKCk7XG5cbiAgICAgICAgICAgIGNhc2UgNDk6XG4gICAgICAgICAgICBjYXNlIDUwOlxuICAgICAgICAgICAgY2FzZSA1MTpcbiAgICAgICAgICAgIGNhc2UgNTI6XG4gICAgICAgICAgICBjYXNlIDUzOlxuICAgICAgICAgICAgY2FzZSA1NDpcbiAgICAgICAgICAgIGNhc2UgNTU6XG4gICAgICAgICAgICBjYXNlIDU2OlxuICAgICAgICAgICAgY2FzZSA1NzpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWROdW1iZXIoZmFsc2UpO1xuXG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJpbmcoY29kZSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5fc2xhc2goY29kZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuX211bHRfbW9kdWxvKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTI0OlxuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbl9waXBlX2FtcChjb2RlKTtcblxuICAgICAgICAgICAgY2FzZSA5NDpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbl9jYXJldCgpO1xuXG4gICAgICAgICAgICBjYXNlIDQzOlxuICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbl9wbHVzX21pbihjb2RlKTtcblxuICAgICAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5fbHRfZ3QoY29kZSk7XG5cbiAgICAgICAgICAgIGNhc2UgNjE6XG4gICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuX2VxX2V4Y2woY29kZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTI2OlxuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoT3AoX3ByZWZpeCwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFRva2VuKGZvcmNlUmVnZXhwKSB7XG4gICAgICAgICAgaWYgKCFmb3JjZVJlZ2V4cCkgdG9rU3RhcnQgPSB0b2tQb3M7ZWxzZSB0b2tQb3MgPSB0b2tTdGFydCArIDE7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB0b2tTdGFydExvYyA9IG5ldyBsaW5lX2xvY190KCk7XG4gICAgICAgICAgaWYgKGZvcmNlUmVnZXhwKSByZXR1cm4gcmVhZFJlZ2V4cCgpO1xuICAgICAgICAgIGlmICh0b2tQb3MgPj0gaW5wdXRMZW4pIHJldHVybiBmaW5pc2hUb2tlbihfZW9mKTtcbiAgICAgICAgICB2YXIgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkgfHwgY29kZSA9PT0gOTIpIHJldHVybiByZWFkV29yZCgpO1xuICAgICAgICAgIHZhciB0b2sgPSBnZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuXG4gICAgICAgICAgaWYgKHRvayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwiXFxcXFwiIHx8IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoY2gpKSByZXR1cm4gcmVhZFdvcmQoKTtcbiAgICAgICAgICAgIHJhaXNlKHRva1BvcywgXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluaXNoT3AodHlwZSwgc2l6ZSkge1xuICAgICAgICAgIHZhciBzdHIgPSBpbnB1dC5zbGljZSh0b2tQb3MsIHRva1BvcyArIHNpemUpO1xuICAgICAgICAgIHRva1BvcyArPSBzaXplO1xuICAgICAgICAgIGZpbmlzaFRva2VuKHR5cGUsIHN0cik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkUmVnZXhwKCkge1xuICAgICAgICAgIHZhciBjb250ZW50ID0gXCJcIixcbiAgICAgICAgICAgICAgZXNjYXBlZCxcbiAgICAgICAgICAgICAgaW5DbGFzcyxcbiAgICAgICAgICAgICAgc3RhcnQgPSB0b2tQb3M7XG5cbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodG9rUG9zID49IGlucHV0TGVuKSByYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO1xuICAgICAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckF0KHRva1Bvcyk7XG4gICAgICAgICAgICBpZiAobmV3bGluZS50ZXN0KGNoKSkgcmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTtcblxuICAgICAgICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gXCJbXCIpIGluQ2xhc3MgPSB0cnVlO2Vsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbkNsYXNzKSBpbkNsYXNzID0gZmFsc2U7ZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSBicmVhaztcbiAgICAgICAgICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICAgICAgICAgIH0gZWxzZSBlc2NhcGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb250ZW50ID0gaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1Bvcyk7XG4gICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgdmFyIG1vZHMgPSByZWFkV29yZDEoKTtcbiAgICAgICAgICBpZiAobW9kcyAmJiAhL15bZ21zaXldKiQvLnRlc3QobW9kcykpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgcmVnZXhwIGZsYWdcIik7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IFJlZ0V4cChjb250ZW50LCBtb2RzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSByYWlzZShzdGFydCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJhaXNlKGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfcmVnZXhwLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkSW50KHJhZGl4LCBsZW4pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0b2tQb3MsXG4gICAgICAgICAgICAgIHRvdGFsID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyksXG4gICAgICAgICAgICAgICAgdmFsO1xuICAgICAgICAgICAgaWYgKGNvZGUgPj0gOTcpIHZhbCA9IGNvZGUgLSA5NyArIDEwO2Vsc2UgaWYgKGNvZGUgPj0gNjUpIHZhbCA9IGNvZGUgLSA2NSArIDEwO2Vsc2UgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgdmFsID0gY29kZSAtIDQ4O2Vsc2UgdmFsID0gSW5maW5pdHk7XG4gICAgICAgICAgICBpZiAodmFsID49IHJhZGl4KSBicmVhaztcbiAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b2tQb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRva1BvcyAtIHN0YXJ0ICE9PSBsZW4pIHJldHVybiBudWxsO1xuICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRIZXhOdW1iZXIoKSB7XG4gICAgICAgICAgdG9rUG9zICs9IDI7XG4gICAgICAgICAgdmFyIHZhbCA9IHJlYWRJbnQoMTYpO1xuICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkgcmFpc2UodG9rU3RhcnQgKyAyLCBcIkV4cGVjdGVkIGhleGFkZWNpbWFsIG51bWJlclwiKTtcbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpKSkgcmFpc2UodG9rUG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfbnVtLCB2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZE51bWJlcihzdGFydHNXaXRoRG90KSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdG9rUG9zLFxuICAgICAgICAgICAgICBpc0Zsb2F0ID0gZmFsc2UsXG4gICAgICAgICAgICAgIG9jdGFsID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSA0ODtcbiAgICAgICAgICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgcmVhZEludCgxMCkgPT09IG51bGwpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO1xuXG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSA9PT0gNDYpIHtcbiAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgcmVhZEludCgxMCk7XG4gICAgICAgICAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblxuICAgICAgICAgIGlmIChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpIHtcbiAgICAgICAgICAgIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgKyt0b2tQb3M7XG4gICAgICAgICAgICBpZiAocmVhZEludCgxMCkgPT09IG51bGwpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO1xuICAgICAgICAgICAgaXNGbG9hdCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSkpIHJhaXNlKHRva1BvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTtcbiAgICAgICAgICB2YXIgc3RyID0gaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1BvcyksXG4gICAgICAgICAgICAgIHZhbDtcbiAgICAgICAgICBpZiAoaXNGbG9hdCkgdmFsID0gcGFyc2VGbG9hdChzdHIpO2Vsc2UgaWYgKCFvY3RhbCB8fCBzdHIubGVuZ3RoID09PSAxKSB2YWwgPSBwYXJzZUludChzdHIsIDEwKTtlbHNlIGlmICgvWzg5XS8udGVzdChzdHIpIHx8IHN0cmljdCkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7ZWxzZSB2YWwgPSBwYXJzZUludChzdHIsIDgpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfbnVtLCB2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFN0cmluZyhxdW90ZSkge1xuICAgICAgICAgIHRva1BvcysrO1xuICAgICAgICAgIHZhciBvdXQgPSBcIlwiO1xuXG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRva1BvcyA+PSBpbnB1dExlbikgcmFpc2UodG9rU3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTtcbiAgICAgICAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9zdHJpbmcsIG91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgICAgICAgICAgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKTtcbiAgICAgICAgICAgICAgdmFyIG9jdGFsID0gL15bMC03XSsvLmV4ZWMoaW5wdXQuc2xpY2UodG9rUG9zLCB0b2tQb3MgKyAzKSk7XG4gICAgICAgICAgICAgIGlmIChvY3RhbCkgb2N0YWwgPSBvY3RhbFswXTtcblxuICAgICAgICAgICAgICB3aGlsZSAob2N0YWwgJiYgcGFyc2VJbnQob2N0YWwsIDgpID4gMjU1KSBvY3RhbCA9IG9jdGFsLnNsaWNlKDAsIC0xKTtcblxuICAgICAgICAgICAgICBpZiAob2N0YWwgPT09IFwiMFwiKSBvY3RhbCA9IG51bGw7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuXG4gICAgICAgICAgICAgIGlmIChvY3RhbCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QpIHJhaXNlKHRva1BvcyAtIDIsIFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChvY3RhbCwgOCkpO1xuICAgICAgICAgICAgICAgIHRva1BvcyArPSBvY3RhbC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTEwOlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCJcXHJcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTIwOlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyZWFkSGV4Q2hhcigyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocmVhZEhleENoYXIoNCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSA4NTpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocmVhZEhleENoYXIoOCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMTY6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSA5ODpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiXFxiXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDExODpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiXFx1MDAwYlwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDI6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIlxcZlwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSA0ODpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiXFwwXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSAxMCkgKyt0b2tQb3M7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgIHRva0xpbmVTdGFydCA9IHRva1BvcztcbiAgICAgICAgICAgICAgICAgICAgICArK3Rva0N1ckxpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgfHwgY2ggPT09IDEwIHx8IGNoID09PSA4MjMyIHx8IGNoID09PSA4MjMzKSByYWlzZSh0b2tTdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRIZXhDaGFyKGxlbikge1xuICAgICAgICAgIHZhciBuID0gcmVhZEludCgxNiwgbGVuKTtcbiAgICAgICAgICBpZiAobiA9PT0gbnVsbCkgcmFpc2UodG9rU3RhcnQsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGFpbnNFc2M7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFdvcmQxKCkge1xuICAgICAgICAgIGNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHdvcmQsXG4gICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgc3RhcnQgPSB0b2tQb3M7XG5cbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJDaGFyKGNoKSkge1xuICAgICAgICAgICAgICBpZiAoY29udGFpbnNFc2MpIHdvcmQgKz0gaW5wdXQuY2hhckF0KHRva1Bvcyk7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgICAgICAgICAgaWYgKCFjb250YWluc0VzYykgd29yZCA9IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpO1xuICAgICAgICAgICAgICBjb250YWluc0VzYyA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKSAhPSAxMTcpIHJhaXNlKHRva1BvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpO1xuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgdmFyIGVzYyA9IHJlYWRIZXhDaGFyKDQpO1xuICAgICAgICAgICAgICB2YXIgZXNjU3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlc2MpO1xuICAgICAgICAgICAgICBpZiAoIWVzY1N0cikgcmFpc2UodG9rUG9zIC0gMSwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgICAgICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0KGVzYykgOiBpc0lkZW50aWZpZXJDaGFyKGVzYykpKSByYWlzZSh0b2tQb3MgLSA0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7XG4gICAgICAgICAgICAgIHdvcmQgKz0gZXNjU3RyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zRXNjID8gd29yZCA6IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFdvcmQoKSB7XG4gICAgICAgICAgdmFyIHdvcmQgPSByZWFkV29yZDEoKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IF9uYW1lO1xuICAgICAgICAgIGlmICghY29udGFpbnNFc2MgJiYgaXNLZXl3b3JkKHdvcmQpKSB0eXBlID0ga2V5d29yZFR5cGVzW3dvcmRdO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbih0eXBlLCB3b3JkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgbGFzdFN0YXJ0ID0gdG9rU3RhcnQ7XG4gICAgICAgICAgbGFzdEVuZCA9IHRva0VuZDtcbiAgICAgICAgICBsYXN0RW5kTG9jID0gdG9rRW5kTG9jO1xuICAgICAgICAgIHJlYWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0U3RyaWN0KHN0cmN0KSB7XG4gICAgICAgICAgc3RyaWN0ID0gc3RyY3Q7XG4gICAgICAgICAgdG9rUG9zID0gdG9rU3RhcnQ7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgIHdoaWxlICh0b2tQb3MgPCB0b2tMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgICAgdG9rTGluZVN0YXJ0ID0gaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgdG9rTGluZVN0YXJ0IC0gMikgKyAxO1xuICAgICAgICAgICAgICAtLXRva0N1ckxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2tpcFNwYWNlKCk7XG4gICAgICAgICAgcmVhZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBub2RlX3QoKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gdG9rU3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9sb2NfdCgpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gdG9rU3RhcnRMb2M7XG4gICAgICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICAgICAgICAgIGlmIChzb3VyY2VGaWxlICE9PSBudWxsKSB0aGlzLnNvdXJjZSA9IHNvdXJjZUZpbGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzdGFydE5vZGUoKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBuZXcgbm9kZV90KCk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSBub2RlLmxvYyA9IG5ldyBub2RlX2xvY190KCk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSkgbm9kZS5zb3VyY2VGaWxlID0gb3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlO1xuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmdlcykgbm9kZS5yYW5nZSA9IFt0b2tTdGFydCwgMF07XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzdGFydE5vZGVGcm9tKG90aGVyKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBuZXcgbm9kZV90KCk7XG4gICAgICAgICAgbm9kZS5zdGFydCA9IG90aGVyLnN0YXJ0O1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICBub2RlLmxvYyA9IG5ldyBub2RlX2xvY190KCk7XG4gICAgICAgICAgICBub2RlLmxvYy5zdGFydCA9IG90aGVyLmxvYy5zdGFydDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5yYW5nZXMpIG5vZGUucmFuZ2UgPSBbb3RoZXIucmFuZ2VbMF0sIDBdO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluaXNoTm9kZShub2RlLCB0eXBlKSB7XG4gICAgICAgICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICAgICAgICBub2RlLmVuZCA9IGxhc3RFbmQ7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSBub2RlLmxvYy5lbmQgPSBsYXN0RW5kTG9jO1xuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmdlcykgbm9kZS5yYW5nZVsxXSA9IGxhc3RFbmQ7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1VzZVN0cmljdChzdG10KSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiBzdG10LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBzdG10LmV4cHJlc3Npb24udmFsdWUgPT09IFwidXNlIHN0cmljdFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZWF0KHR5cGUpIHtcbiAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FuSW5zZXJ0U2VtaWNvbG9uKCkge1xuICAgICAgICAgIHJldHVybiAhb3B0aW9ucy5zdHJpY3RTZW1pY29sb25zICYmICh0b2tUeXBlID09PSBfZW9mIHx8IHRva1R5cGUgPT09IF9icmFjZVIgfHwgbmV3bGluZS50ZXN0KGlucHV0LnNsaWNlKGxhc3RFbmQsIHRva1N0YXJ0KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2VtaWNvbG9uKCkge1xuICAgICAgICAgIGlmICghZWF0KF9zZW1pKSAmJiAhY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4cGVjdCh0eXBlKSB7XG4gICAgICAgICAgaWYgKHRva1R5cGUgPT09IHR5cGUpIG5leHQoKTtlbHNlIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVuZXhwZWN0ZWQoKSB7XG4gICAgICAgICAgcmFpc2UodG9rU3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTFZhbChleHByKSB7XG4gICAgICAgICAgaWYgKGV4cHIudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgZXhwci50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikgcmFpc2UoZXhwci5zdGFydCwgXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpO1xuICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBpc1N0cmljdEJhZElkV29yZChleHByLm5hbWUpKSByYWlzZShleHByLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBcIiArIGV4cHIubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VUb3BMZXZlbChwcm9ncmFtKSB7XG4gICAgICAgICAgbGFzdFN0YXJ0ID0gbGFzdEVuZCA9IHRva1BvcztcbiAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIGxhc3RFbmRMb2MgPSBuZXcgbGluZV9sb2NfdCgpO1xuICAgICAgICAgIGluRnVuY3Rpb24gPSBzdHJpY3QgPSBudWxsO1xuICAgICAgICAgIGxhYmVscyA9IFtdO1xuICAgICAgICAgIHJlYWRUb2tlbigpO1xuICAgICAgICAgIHZhciBub2RlID0gcHJvZ3JhbSB8fCBzdGFydE5vZGUoKSxcbiAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgIGlmICghcHJvZ3JhbSkgbm9kZS5ib2R5ID0gW107XG5cbiAgICAgICAgICB3aGlsZSAodG9rVHlwZSAhPT0gX2VvZikge1xuICAgICAgICAgICAgdmFyIHN0bXQgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gICAgICAgICAgICBpZiAoZmlyc3QgJiYgaXNVc2VTdHJpY3Qoc3RtdCkpIHNldFN0cmljdCh0cnVlKTtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvb3BMYWJlbCA9IHtcbiAgICAgICAgICBraW5kOiBcImxvb3BcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgc3dpdGNoTGFiZWwgPSB7XG4gICAgICAgICAga2luZDogXCJzd2l0Y2hcIlxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KCkge1xuICAgICAgICAgIGlmICh0b2tUeXBlID09PSBfc2xhc2ggfHwgdG9rVHlwZSA9PT0gX2Fzc2lnbiAmJiB0b2tWYWwgPT0gXCIvPVwiKSByZWFkVG9rZW4odHJ1ZSk7XG4gICAgICAgICAgdmFyIHN0YXJ0dHlwZSA9IHRva1R5cGUsXG4gICAgICAgICAgICAgIG5vZGUgPSBzdGFydE5vZGUoKTtcblxuICAgICAgICAgIHN3aXRjaCAoc3RhcnR0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIF9icmVhazpcbiAgICAgICAgICAgIGNhc2UgX2NvbnRpbnVlOlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIHZhciBpc0JyZWFrID0gc3RhcnR0eXBlID09PSBfYnJlYWs7XG4gICAgICAgICAgICAgIGlmIChlYXQoX3NlbWkpIHx8IGNhbkluc2VydFNlbWljb2xvbigpKSBub2RlLmxhYmVsID0gbnVsbDtlbHNlIGlmICh0b2tUeXBlICE9PSBfbmFtZSkgdW5leHBlY3RlZCgpO2Vsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUubGFiZWwgPSBwYXJzZUlkZW50KCk7XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsYWIgPSBsYWJlbHNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGkgPT09IGxhYmVscy5sZW5ndGgpIHJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBzdGFydHR5cGUua2V5d29yZCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBjYXNlIF9kZWJ1Z2dlcjpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfZG86XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICAgICAgICAgICAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgbGFiZWxzLnBvcCgpO1xuICAgICAgICAgICAgICBleHBlY3QoX3doaWxlKTtcbiAgICAgICAgICAgICAgbm9kZS50ZXN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfZm9yOlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIGxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgICAgICAgICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICAgICAgICAgICAgaWYgKHRva1R5cGUgPT09IF9zZW1pKSByZXR1cm4gcGFyc2VGb3Iobm9kZSwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgaWYgKHRva1R5cGUgPT09IF92YXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdCA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBwYXJzZVZhcihpbml0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBmaW5pc2hOb2RlKGluaXQsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGVhdChfaW4pKSByZXR1cm4gcGFyc2VGb3JJbihub2RlLCBpbml0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGb3Iobm9kZSwgaW5pdCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaW5pdCA9IHBhcnNlRXhwcmVzc2lvbihmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGVhdChfaW4pKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tMVmFsKGluaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZvckluKG5vZGUsIGluaXQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRm9yKG5vZGUsIGluaXQpO1xuXG4gICAgICAgICAgICBjYXNlIF9mdW5jdGlvbjpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbihub2RlLCB0cnVlKTtcblxuICAgICAgICAgICAgY2FzZSBfaWY6XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbm9kZS50ZXN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgbm9kZS5jb25zZXF1ZW50ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgbm9kZS5hbHRlcm5hdGUgPSBlYXQoX2Vsc2UpID8gcGFyc2VTdGF0ZW1lbnQoKSA6IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX3JldHVybjpcbiAgICAgICAgICAgICAgaWYgKCFpbkZ1bmN0aW9uICYmICFvcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKSByYWlzZSh0b2tTdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIGlmIChlYXQoX3NlbWkpIHx8IGNhbkluc2VydFNlbWljb2xvbigpKSBub2RlLmFyZ3VtZW50ID0gbnVsbDtlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX3N3aXRjaDpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBub2RlLmRpc2NyaW1pbmFudCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgIG5vZGUuY2FzZXMgPSBbXTtcbiAgICAgICAgICAgICAgZXhwZWN0KF9icmFjZUwpO1xuICAgICAgICAgICAgICBsYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgY3VyLCBzYXdEZWZhdWx0OyB0b2tUeXBlICE9IF9icmFjZVI7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva1R5cGUgPT09IF9jYXNlIHx8IHRva1R5cGUgPT09IF9kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaXNDYXNlID0gdG9rVHlwZSA9PT0gX2Nhc2U7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VyKSBmaW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuICAgICAgICAgICAgICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgICAgICAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNDYXNlKSBjdXIudGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkgcmFpc2UobGFzdFN0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGV4cGVjdChfY29sb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWN1cikgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaChwYXJzZVN0YXRlbWVudCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY3VyKSBmaW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIGxhYmVscy5wb3AoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX3Rocm93OlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIGlmIChuZXdsaW5lLnRlc3QoaW5wdXQuc2xpY2UobGFzdEVuZCwgdG9rU3RhcnQpKSkgcmFpc2UobGFzdEVuZCwgXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIik7XG4gICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX3RyeTpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBub2RlLmJsb2NrID0gcGFyc2VCbG9jaygpO1xuICAgICAgICAgICAgICBub2RlLmhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgICAgICAgIGlmICh0b2tUeXBlID09PSBfY2F0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhdXNlID0gc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICAgICAgICAgICAgICBjbGF1c2UucGFyYW0gPSBwYXJzZUlkZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBpc1N0cmljdEJhZElkV29yZChjbGF1c2UucGFyYW0ubmFtZSkpIHJhaXNlKGNsYXVzZS5wYXJhbS5zdGFydCwgXCJCaW5kaW5nIFwiICsgY2xhdXNlLnBhcmFtLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoX3BhcmVuUik7XG4gICAgICAgICAgICAgICAgY2xhdXNlLmd1YXJkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjbGF1c2UuYm9keSA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgICAgICAgICBub2RlLmhhbmRsZXIgPSBmaW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5vZGUuZ3VhcmRlZEhhbmRsZXJzID0gZW1wdHk7XG4gICAgICAgICAgICAgIG5vZGUuZmluYWxpemVyID0gZWF0KF9maW5hbGx5KSA/IHBhcnNlQmxvY2soKSA6IG51bGw7XG4gICAgICAgICAgICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikgcmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfdmFyOlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIHBhcnNlVmFyKG5vZGUpO1xuICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuXG4gICAgICAgICAgICBjYXNlIF93aGlsZTpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBub2RlLnRlc3QgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICBsYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgICAgICAgICAgICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICBsYWJlbHMucG9wKCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX3dpdGg6XG4gICAgICAgICAgICAgIGlmIChzdHJpY3QpIHJhaXNlKHRva1N0YXJ0LCBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBub2RlLm9iamVjdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfYnJhY2VMOlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VCbG9jaygpO1xuXG4gICAgICAgICAgICBjYXNlIF9zZW1pOlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHZhciBtYXliZU5hbWUgPSB0b2tWYWwsXG4gICAgICAgICAgICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gX25hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBlYXQoX2NvbG9uKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgKytpKSBpZiAobGFiZWxzW2ldLm5hbWUgPT09IG1heWJlTmFtZSkgcmFpc2UoZXhwci5zdGFydCwgXCJMYWJlbCAnXCIgKyBtYXliZU5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTtcblxuICAgICAgICAgICAgICAgIHZhciBraW5kID0gdG9rVHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRva1R5cGUgPT09IF9zd2l0Y2ggPyBcInN3aXRjaFwiIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsYWJlbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBtYXliZU5hbWUsXG4gICAgICAgICAgICAgICAgICBraW5kOiBraW5kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBsYWJlbHMucG9wKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVBhcmVuRXhwcmVzc2lvbigpIHtcbiAgICAgICAgICBleHBlY3QoX3BhcmVuTCk7XG4gICAgICAgICAgdmFyIHZhbCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VCbG9jayhhbGxvd1N0cmljdCkge1xuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCksXG4gICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgc3RyaWN0ID0gZmFsc2UsXG4gICAgICAgICAgICAgIG9sZFN0cmljdDtcbiAgICAgICAgICBub2RlLmJvZHkgPSBbXTtcbiAgICAgICAgICBleHBlY3QoX2JyYWNlTCk7XG5cbiAgICAgICAgICB3aGlsZSAoIWVhdChfYnJhY2VSKSkge1xuICAgICAgICAgICAgdmFyIHN0bXQgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG5cbiAgICAgICAgICAgIGlmIChmaXJzdCAmJiBhbGxvd1N0cmljdCAmJiBpc1VzZVN0cmljdChzdG10KSkge1xuICAgICAgICAgICAgICBvbGRTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgICAgICAgIHNldFN0cmljdChzdHJpY3QgPSB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RyaWN0ICYmICFvbGRTdHJpY3QpIHNldFN0cmljdChmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRm9yKG5vZGUsIGluaXQpIHtcbiAgICAgICAgICBub2RlLmluaXQgPSBpbml0O1xuICAgICAgICAgIGV4cGVjdChfc2VtaSk7XG4gICAgICAgICAgbm9kZS50ZXN0ID0gdG9rVHlwZSA9PT0gX3NlbWkgPyBudWxsIDogcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZXhwZWN0KF9zZW1pKTtcbiAgICAgICAgICBub2RlLnVwZGF0ZSA9IHRva1R5cGUgPT09IF9wYXJlblIgPyBudWxsIDogcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZXhwZWN0KF9wYXJlblIpO1xuICAgICAgICAgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgbGFiZWxzLnBvcCgpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VGb3JJbihub2RlLCBpbml0KSB7XG4gICAgICAgICAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgICAgICAgICBub2RlLnJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZXhwZWN0KF9wYXJlblIpO1xuICAgICAgICAgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgbGFiZWxzLnBvcCgpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRm9ySW5TdGF0ZW1lbnRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVZhcihub2RlLCBub0luKSB7XG4gICAgICAgICAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICBub2RlLmtpbmQgPSBcInZhclwiO1xuXG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgdmFyIGRlY2wgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgICAgIGRlY2wuaWQgPSBwYXJzZUlkZW50KCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0QmFkSWRXb3JkKGRlY2wuaWQubmFtZSkpIHJhaXNlKGRlY2wuaWQuc3RhcnQsIFwiQmluZGluZyBcIiArIGRlY2wuaWQubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgZGVjbC5pbml0ID0gZWF0KF9lcSkgPyBwYXJzZUV4cHJlc3Npb24odHJ1ZSwgbm9JbikgOiBudWxsO1xuICAgICAgICAgICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaChmaW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICAgICAgICAgIGlmICghZWF0KF9jb21tYSkpIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKG5vQ29tbWEsIG5vSW4pIHtcbiAgICAgICAgICB2YXIgZXhwciA9IHBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG5cbiAgICAgICAgICBpZiAoIW5vQ29tbWEgJiYgdG9rVHlwZSA9PT0gX2NvbW1hKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oZXhwcik7XG4gICAgICAgICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuXG4gICAgICAgICAgICB3aGlsZSAoZWF0KF9jb21tYSkpIG5vZGUuZXhwcmVzc2lvbnMucHVzaChwYXJzZU1heWJlQXNzaWduKG5vSW4pKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZU1heWJlQXNzaWduKG5vSW4pIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IHBhcnNlTWF5YmVDb25kaXRpb25hbChub0luKTtcblxuICAgICAgICAgIGlmICh0b2tUeXBlLmlzQXNzaWduKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20obGVmdCk7XG4gICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gdG9rVmFsO1xuICAgICAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIG5vZGUucmlnaHQgPSBwYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgICAgICAgICAgY2hlY2tMVmFsKGxlZnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTWF5YmVDb25kaXRpb25hbChub0luKSB7XG4gICAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJPcHMobm9Jbik7XG5cbiAgICAgICAgICBpZiAoZWF0KF9xdWVzdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShleHByKTtcbiAgICAgICAgICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgICAgICAgICBub2RlLmNvbnNlcXVlbnQgPSBwYXJzZUV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QoX2NvbG9uKTtcbiAgICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlID0gcGFyc2VFeHByZXNzaW9uKHRydWUsIG5vSW4pO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUV4cHJPcHMobm9Jbikge1xuICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJPcChwYXJzZU1heWJlVW5hcnkoKSwgLTEsIG5vSW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VFeHByT3AobGVmdCwgbWluUHJlYywgbm9Jbikge1xuICAgICAgICAgIHZhciBwcmVjID0gdG9rVHlwZS5iaW5vcDtcblxuICAgICAgICAgIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRva1R5cGUgIT09IF9pbikpIHtcbiAgICAgICAgICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20obGVmdCk7XG4gICAgICAgICAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG4gICAgICAgICAgICAgIHZhciBvcCA9IHRva1R5cGU7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbm9kZS5yaWdodCA9IHBhcnNlRXhwck9wKHBhcnNlTWF5YmVVbmFyeSgpLCBwcmVjLCBub0luKTtcbiAgICAgICAgICAgICAgdmFyIGV4cHJOb2RlID0gZmluaXNoTm9kZShub2RlLCBvcCA9PT0gX2xvZ2ljYWxPUiB8fCBvcCA9PT0gX2xvZ2ljYWxBTkQgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIik7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJPcChleHByTm9kZSwgbWluUHJlYywgbm9Jbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZU1heWJlVW5hcnkoKSB7XG4gICAgICAgICAgaWYgKHRva1R5cGUucHJlZml4KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRva1R5cGUuaXNVcGRhdGU7XG4gICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gdG9rVmFsO1xuICAgICAgICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgICAgICAgdG9rUmVnZXhwQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBub2RlLmFyZ3VtZW50ID0gcGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgICAgICAgICBpZiAodXBkYXRlKSBjaGVja0xWYWwobm9kZS5hcmd1bWVudCk7ZWxzZSBpZiAoc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiYgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIikgcmFpc2Uobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJTdWJzY3JpcHRzKCk7XG5cbiAgICAgICAgICB3aGlsZSAodG9rVHlwZS5wb3N0Zml4ICYmICFjYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGV4cHIpO1xuICAgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcbiAgICAgICAgICAgIG5vZGUucHJlZml4ID0gZmFsc2U7XG4gICAgICAgICAgICBub2RlLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgICAgICAgIGNoZWNrTFZhbChleHByKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGV4cHIgPSBmaW5pc2hOb2RlKG5vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRXhwclN1YnNjcmlwdHMoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhwYXJzZUV4cHJBdG9tKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VTdWJzY3JpcHRzKGJhc2UsIG5vQ2FsbHMpIHtcbiAgICAgICAgICBpZiAoZWF0KF9kb3QpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oYmFzZSk7XG4gICAgICAgICAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICAgICAgICBub2RlLnByb3BlcnR5ID0gcGFyc2VJZGVudCh0cnVlKTtcbiAgICAgICAgICAgIG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVN1YnNjcmlwdHMoZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIiksIG5vQ2FsbHMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWF0KF9icmFja2V0TCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShiYXNlKTtcbiAgICAgICAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgICAgICAgIG5vZGUucHJvcGVydHkgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIG5vZGUuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZXhwZWN0KF9icmFja2V0Uik7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpLCBub0NhbGxzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIGVhdChfcGFyZW5MKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGJhc2UpO1xuICAgICAgICAgICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgICAgICAgICAgbm9kZS5hcmd1bWVudHMgPSBwYXJzZUV4cHJMaXN0KF9wYXJlblIsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVN1YnNjcmlwdHMoZmluaXNoTm9kZShub2RlLCBcIkNhbGxFeHByZXNzaW9uXCIpLCBub0NhbGxzKTtcbiAgICAgICAgICB9IGVsc2UgcmV0dXJuIGJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUV4cHJBdG9tKCkge1xuICAgICAgICAgIHN3aXRjaCAodG9rVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBfdGhpczpcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuXG4gICAgICAgICAgICBjYXNlIF9uYW1lOlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJZGVudCgpO1xuXG4gICAgICAgICAgICBjYXNlIF9udW06XG4gICAgICAgICAgICBjYXNlIF9zdHJpbmc6XG4gICAgICAgICAgICBjYXNlIF9yZWdleHA6XG4gICAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIG5vZGUudmFsdWUgPSB0b2tWYWw7XG4gICAgICAgICAgICAgIG5vZGUucmF3ID0gaW5wdXQuc2xpY2UodG9rU3RhcnQsIHRva0VuZCk7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpO1xuXG4gICAgICAgICAgICBjYXNlIF9udWxsOlxuICAgICAgICAgICAgY2FzZSBfdHJ1ZTpcbiAgICAgICAgICAgIGNhc2UgX2ZhbHNlOlxuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICBub2RlLnZhbHVlID0gdG9rVHlwZS5hdG9tVmFsdWU7XG4gICAgICAgICAgICAgIG5vZGUucmF3ID0gdG9rVHlwZS5rZXl3b3JkO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfcGFyZW5MOlxuICAgICAgICAgICAgICB2YXIgdG9rU3RhcnRMb2MxID0gdG9rU3RhcnRMb2MsXG4gICAgICAgICAgICAgICAgICB0b2tTdGFydDEgPSB0b2tTdGFydDtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICB2YXIgdmFsID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgIHZhbC5zdGFydCA9IHRva1N0YXJ0MTtcbiAgICAgICAgICAgICAgdmFsLmVuZCA9IHRva0VuZDtcblxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YWwubG9jLnN0YXJ0ID0gdG9rU3RhcnRMb2MxO1xuICAgICAgICAgICAgICAgIHZhbC5sb2MuZW5kID0gdG9rRW5kTG9jO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKSB2YWwucmFuZ2UgPSBbdG9rU3RhcnQxLCB0b2tFbmRdO1xuICAgICAgICAgICAgICBleHBlY3QoX3BhcmVuUik7XG4gICAgICAgICAgICAgIHJldHVybiB2YWw7XG5cbiAgICAgICAgICAgIGNhc2UgX2JyYWNrZXRMOlxuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIG5vZGUuZWxlbWVudHMgPSBwYXJzZUV4cHJMaXN0KF9icmFja2V0UiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpO1xuXG4gICAgICAgICAgICBjYXNlIF9icmFjZUw6XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZU9iaigpO1xuXG4gICAgICAgICAgICBjYXNlIF9mdW5jdGlvbjpcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbihub2RlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGNhc2UgX25ldzpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTmV3KCk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZU5ldygpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBub2RlLmNhbGxlZSA9IHBhcnNlU3Vic2NyaXB0cyhwYXJzZUV4cHJBdG9tKCksIHRydWUpO1xuICAgICAgICAgIGlmIChlYXQoX3BhcmVuTCkpIG5vZGUuYXJndW1lbnRzID0gcGFyc2VFeHByTGlzdChfcGFyZW5SLCBmYWxzZSk7ZWxzZSBub2RlLmFyZ3VtZW50cyA9IGVtcHR5O1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlT2JqKCkge1xuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCksXG4gICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgc2F3R2V0U2V0ID0gZmFsc2U7XG4gICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gICAgICAgICAgbmV4dCgpO1xuXG4gICAgICAgICAgd2hpbGUgKCFlYXQoX2JyYWNlUikpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgZXhwZWN0KF9jb21tYSk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93VHJhaWxpbmdDb21tYXMgJiYgZWF0KF9icmFjZVIpKSBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHtcbiAgICAgICAgICAgICAga2V5OiBwYXJzZVByb3BlcnR5TmFtZSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzR2V0U2V0ID0gZmFsc2UsXG4gICAgICAgICAgICAgICAga2luZDtcblxuICAgICAgICAgICAgaWYgKGVhdChfY29sb24pKSB7XG4gICAgICAgICAgICAgIHByb3AudmFsdWUgPSBwYXJzZUV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICAgIGtpbmQgPSBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpKSB7XG4gICAgICAgICAgICAgIGlzR2V0U2V0ID0gc2F3R2V0U2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAga2luZCA9IHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgICAgICAgICAgIHByb3Aua2V5ID0gcGFyc2VQcm9wZXJ0eU5hbWUoKTtcbiAgICAgICAgICAgICAgaWYgKHRva1R5cGUgIT09IF9wYXJlbkwpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgcHJvcC52YWx1ZSA9IHBhcnNlRnVuY3Rpb24oc3RhcnROb2RlKCksIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB1bmV4cGVjdGVkKCk7XG5cbiAgICAgICAgICAgIGlmIChwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAoc3RyaWN0IHx8IHNhd0dldFNldCkpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnByb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBub2RlLnByb3BlcnRpZXNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAob3RoZXIua2V5Lm5hbWUgPT09IHByb3Aua2V5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb25mbGljdCA9IGtpbmQgPT0gb3RoZXIua2luZCB8fCBpc0dldFNldCAmJiBvdGhlci5raW5kID09PSBcImluaXRcIiB8fCBraW5kID09PSBcImluaXRcIiAmJiAob3RoZXIua2luZCA9PT0gXCJnZXRcIiB8fCBvdGhlci5raW5kID09PSBcInNldFwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb25mbGljdCAmJiAhc3RyaWN0ICYmIGtpbmQgPT09IFwiaW5pdFwiICYmIG90aGVyLmtpbmQgPT09IFwiaW5pdFwiKSBjb25mbGljdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0KSByYWlzZShwcm9wLmtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0RXhwcmVzc2lvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHlOYW1lKCkge1xuICAgICAgICAgIGlmICh0b2tUeXBlID09PSBfbnVtIHx8IHRva1R5cGUgPT09IF9zdHJpbmcpIHJldHVybiBwYXJzZUV4cHJBdG9tKCk7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gICAgICAgICAgaWYgKHRva1R5cGUgPT09IF9uYW1lKSBub2RlLmlkID0gcGFyc2VJZGVudCgpO2Vsc2UgaWYgKGlzU3RhdGVtZW50KSB1bmV4cGVjdGVkKCk7ZWxzZSBub2RlLmlkID0gbnVsbDtcbiAgICAgICAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgICAgICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgZXhwZWN0KF9wYXJlbkwpO1xuXG4gICAgICAgICAgd2hpbGUgKCFlYXQoX3BhcmVuUikpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3QpIGV4cGVjdChfY29tbWEpO2Vsc2UgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIG5vZGUucGFyYW1zLnB1c2gocGFyc2VJZGVudCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb2xkSW5GdW5jID0gaW5GdW5jdGlvbixcbiAgICAgICAgICAgICAgb2xkTGFiZWxzID0gbGFiZWxzO1xuICAgICAgICAgIGluRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGxhYmVscyA9IFtdO1xuICAgICAgICAgIG5vZGUuYm9keSA9IHBhcnNlQmxvY2sodHJ1ZSk7XG4gICAgICAgICAgaW5GdW5jdGlvbiA9IG9sZEluRnVuYztcbiAgICAgICAgICBsYWJlbHMgPSBvbGRMYWJlbHM7XG5cbiAgICAgICAgICBpZiAoc3RyaWN0IHx8IG5vZGUuYm9keS5ib2R5Lmxlbmd0aCAmJiBpc1VzZVN0cmljdChub2RlLmJvZHkuYm9keVswXSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBub2RlLmlkID8gLTEgOiAwOyBpIDwgbm9kZS5wYXJhbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gaSA8IDAgPyBub2RlLmlkIDogbm9kZS5wYXJhbXNbaV07XG4gICAgICAgICAgICAgIGlmIChpc1N0cmljdFJlc2VydmVkV29yZChpZC5uYW1lKSB8fCBpc1N0cmljdEJhZElkV29yZChpZC5uYW1lKSkgcmFpc2UoaWQuc3RhcnQsIFwiRGVmaW5pbmcgJ1wiICsgaWQubmFtZSArIFwiJyBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgICAgaWYgKGkgPj0gMCkgZm9yICh2YXIgaiA9IDA7IGogPCBpOyArK2opIGlmIChpZC5uYW1lID09PSBub2RlLnBhcmFtc1tqXS5uYW1lKSByYWlzZShpZC5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRXhwckxpc3QoY2xvc2UsIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dFbXB0eSkge1xuICAgICAgICAgIHZhciBlbHRzID0gW10sXG4gICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcblxuICAgICAgICAgIHdoaWxlICghZWF0KGNsb3NlKSkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICBleHBlY3QoX2NvbW1hKTtcbiAgICAgICAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiBvcHRpb25zLmFsbG93VHJhaWxpbmdDb21tYXMgJiYgZWF0KGNsb3NlKSkgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgZmlyc3QgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdG9rVHlwZSA9PT0gX2NvbW1hKSBlbHRzLnB1c2gobnVsbCk7ZWxzZSBlbHRzLnB1c2gocGFyc2VFeHByZXNzaW9uKHRydWUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlSWRlbnQobGliZXJhbCkge1xuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgICAgICAgaWYgKGxpYmVyYWwgJiYgb3B0aW9ucy5mb3JiaWRSZXNlcnZlZCA9PSBcImV2ZXJ5d2hlcmVcIikgbGliZXJhbCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHRva1R5cGUgPT09IF9uYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWxpYmVyYWwgJiYgKG9wdGlvbnMuZm9yYmlkUmVzZXJ2ZWQgJiYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDMgPyBpc1Jlc2VydmVkV29yZDMgOiBpc1Jlc2VydmVkV29yZDUpKHRva1ZhbCkgfHwgc3RyaWN0ICYmIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHRva1ZhbCkpICYmIGlucHV0LnNsaWNlKHRva1N0YXJ0LCB0b2tFbmQpLmluZGV4T2YoXCJcXFxcXCIpID09IC0xKSByYWlzZSh0b2tTdGFydCwgXCJUaGUga2V5d29yZCAnXCIgKyB0b2tWYWwgKyBcIicgaXMgcmVzZXJ2ZWRcIik7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSB0b2tWYWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaWJlcmFsICYmIHRva1R5cGUua2V5d29yZCkge1xuICAgICAgICAgICAgbm9kZS5uYW1lID0gdG9rVHlwZS5rZXl3b3JkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rUmVnZXhwQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWFjb3JuLnZlcnNpb24pIGFjb3JuID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gKGdsb2JhbC5hY29ybiB8fCBhY29ybikucGFyc2UoY29kZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIGJpbmFyeU9wZXJhdG9ycyA9IHtcbiAgICAgICcrJzogJ19fYWRkJyxcbiAgICAgICctJzogJ19fc3VidHJhY3QnLFxuICAgICAgJyonOiAnX19tdWx0aXBseScsXG4gICAgICAnLyc6ICdfX2RpdmlkZScsXG4gICAgICAnJSc6ICdfX21vZHVsbycsXG4gICAgICAnPT0nOiAnX19lcXVhbHMnLFxuICAgICAgJyE9JzogJ19fZXF1YWxzJ1xuICAgIH07XG4gICAgdmFyIHVuYXJ5T3BlcmF0b3JzID0ge1xuICAgICAgJy0nOiAnX19uZWdhdGUnLFxuICAgICAgJysnOiAnX19zZWxmJ1xuICAgIH07XG4gICAgdmFyIGZpZWxkcyA9IEJhc2UuZWFjaChbJ2FkZCcsICdzdWJ0cmFjdCcsICdtdWx0aXBseScsICdkaXZpZGUnLCAnbW9kdWxvJywgJ2VxdWFscycsICduZWdhdGUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRoaXNbJ19fJyArIG5hbWVdID0gJyMnICsgbmFtZTtcbiAgICB9LCB7XG4gICAgICBfX3NlbGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgUG9pbnQuaW5qZWN0KGZpZWxkcyk7XG4gICAgU2l6ZS5pbmplY3QoZmllbGRzKTtcbiAgICBDb2xvci5pbmplY3QoZmllbGRzKTtcblxuICAgIGZ1bmN0aW9uIF9fJF9fKGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuICAgICAgdmFyIGhhbmRsZXIgPSBiaW5hcnlPcGVyYXRvcnNbb3BlcmF0b3JdO1xuXG4gICAgICBpZiAobGVmdCAmJiBsZWZ0W2hhbmRsZXJdKSB7XG4gICAgICAgIHZhciByZXMgPSBsZWZ0W2hhbmRsZXJdKHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yID09PSAnIT0nID8gIXJlcyA6IHJlcztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xuXG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBsZWZ0IC0gcmlnaHQ7XG5cbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgcmV0dXJuIGxlZnQgKiByaWdodDtcblxuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICByZXR1cm4gbGVmdCAvIHJpZ2h0O1xuXG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIHJldHVybiBsZWZ0ICUgcmlnaHQ7XG5cbiAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgIHJldHVybiBsZWZ0ID09IHJpZ2h0O1xuXG4gICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICByZXR1cm4gbGVmdCAhPSByaWdodDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkX18ob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHVuYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVtoYW5kbGVyXSkgcmV0dXJuIHZhbHVlW2hhbmRsZXJdKCk7XG5cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgcmV0dXJuICt2YWx1ZTtcblxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gLXZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBpbGUoY29kZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFjb2RlKSByZXR1cm4gJyc7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBpbnNlcnRpb25zID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGdldE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbnNlcnRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBpbnNlcnRpb24gPSBpbnNlcnRpb25zW2ldO1xuICAgICAgICAgIGlmIChpbnNlcnRpb25bMF0gPj0gb2Zmc2V0KSBicmVhaztcbiAgICAgICAgICBvZmZzZXQgKz0gaW5zZXJ0aW9uWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Q29kZShub2RlKSB7XG4gICAgICAgIHJldHVybiBjb2RlLnN1YnN0cmluZyhnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksIGdldE9mZnNldChub2RlLnJhbmdlWzFdKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEJldHdlZW4obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGNvZGUuc3Vic3RyaW5nKGdldE9mZnNldChsZWZ0LnJhbmdlWzFdKSwgZ2V0T2Zmc2V0KHJpZ2h0LnJhbmdlWzBdKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2VDb2RlKG5vZGUsIHN0cikge1xuICAgICAgICB2YXIgc3RhcnQgPSBnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksXG4gICAgICAgICAgICBlbmQgPSBnZXRPZmZzZXQobm9kZS5yYW5nZVsxXSksXG4gICAgICAgICAgICBpbnNlcnQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBpbnNlcnRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gaW5zZXJ0aW9uc1tpXVswXSkge1xuICAgICAgICAgICAgaW5zZXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbnNlcnRpb25zLnNwbGljZShpbnNlcnQsIDAsIFtzdGFydCwgc3RyLmxlbmd0aCAtIGVuZCArIHN0YXJ0XSk7XG4gICAgICAgIGNvZGUgPSBjb2RlLnN1YnN0cmluZygwLCBzdGFydCkgKyBzdHIgKyBjb2RlLnN1YnN0cmluZyhlbmQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVPdmVybG9hZGluZyhub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgaW4gdW5hcnlPcGVyYXRvcnMgJiYgbm9kZS5hcmd1bWVudC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZyA9IGdldENvZGUobm9kZS5hcmd1bWVudCk7XG4gICAgICAgICAgICAgIHJlcGxhY2VDb2RlKG5vZGUsICckX18oXCInICsgbm9kZS5vcGVyYXRvciArICdcIiwgJyArIGFyZyArICcpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBpZiAobm9kZS5vcGVyYXRvciBpbiBiaW5hcnlPcGVyYXRvcnMgJiYgbm9kZS5sZWZ0LnR5cGUgIT09ICdMaXRlcmFsJykge1xuICAgICAgICAgICAgICB2YXIgbGVmdCA9IGdldENvZGUobm9kZS5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gZ2V0Q29kZShub2RlLnJpZ2h0KSxcbiAgICAgICAgICAgICAgICAgIGJldHdlZW4gPSBnZXRCZXR3ZWVuKG5vZGUubGVmdCwgbm9kZS5yaWdodCksXG4gICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IG5vZGUub3BlcmF0b3I7XG4gICAgICAgICAgICAgIHJlcGxhY2VDb2RlKG5vZGUsICdfXyRfXygnICsgbGVmdCArICcsJyArIGJldHdlZW4ucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcJyArIG9wZXJhdG9yKSwgJ1wiJyArIG9wZXJhdG9yICsgJ1wiJykgKyAnLCAnICsgcmlnaHQgKyAnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcGFyZW50ICYmIHBhcmVudC50eXBlO1xuXG4gICAgICAgICAgICBpZiAoIShwYXJlbnRUeXBlID09PSAnRm9yU3RhdGVtZW50JyB8fCBwYXJlbnRUeXBlID09PSAnQmluYXJ5RXhwcmVzc2lvbicgJiYgL15bPSE8Pl0vLnRlc3QocGFyZW50Lm9wZXJhdG9yKSB8fCBwYXJlbnRUeXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiYgcGFyZW50LmNvbXB1dGVkKSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnVXBkYXRlRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gZ2V0Q29kZShub2RlLmFyZ3VtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgZXhwID0gJ19fJF9fKCcgKyBhcmcgKyAnLCBcIicgKyBub2RlLm9wZXJhdG9yWzBdICsgJ1wiLCAxKScsXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZyArICcgPSAnICsgZXhwO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnKCcgKyBzdHIgKyAnKSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnRUeXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nIHx8IHBhcmVudFR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InIHx8IHBhcmVudFR5cGUgPT09ICdCaW5hcnlFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgICAgaWYgKGdldENvZGUocGFyZW50LmxlZnQgfHwgcGFyZW50LmlkKSA9PT0gYXJnKSBzdHIgPSBleHA7XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcgKyAnOyAnICsgc3RyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcGxhY2VDb2RlKG5vZGUsIHN0cik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eLj0kLy50ZXN0KG5vZGUub3BlcmF0b3IpICYmIG5vZGUubGVmdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gZ2V0Q29kZShub2RlLmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gZ2V0Q29kZShub2RlLnJpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICBleHAgPSBsZWZ0ICsgJyA9IF9fJF9fKCcgKyBsZWZ0ICsgJywgXCInICsgbm9kZS5vcGVyYXRvclswXSArICdcIiwgJyArIHJpZ2h0ICsgJyknO1xuICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvZGUobm9kZSwgL15cXCguKlxcKSQvLnRlc3QoZ2V0Q29kZShub2RlKSkgPyAnKCcgKyBleHAgKyAnKScgOiBleHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFeHBvcnRzKG5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24nOlxuICAgICAgICAgICAgcmVwbGFjZUNvZGUoe1xuICAgICAgICAgICAgICByYW5nZTogW25vZGUuc3RhcnQsIG5vZGUuZGVjbGFyYXRpb24uc3RhcnRdXG4gICAgICAgICAgICB9LCAnbW9kdWxlLmV4cG9ydHMgPSAnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbic6XG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSBub2RlLmRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnM7XG5cbiAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zO1xuXG4gICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjKSB7XG4gICAgICAgICAgICAgICAgICByZXBsYWNlQ29kZShkZWMsICdtb2R1bGUuZXhwb3J0cy4nICsgZ2V0Q29kZShkZWMpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29kZSh7XG4gICAgICAgICAgICAgICAgICByYW5nZTogW25vZGUuc3RhcnQsIGRlY2xhcmF0aW9uLnN0YXJ0ICsgZGVjbGFyYXRpb24ua2luZC5sZW5ndGhdXG4gICAgICAgICAgICAgICAgfSwgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpZmllcnMpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cG9ydHMgPSBzcGVjaWZpZXJzLm1hcChmdW5jdGlvbiAoc3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb2RlKHNwZWNpZmllcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtb2R1bGUuZXhwb3J0cy4nICsgbmFtZSArICcgPSAnICsgbmFtZSArICc7ICc7XG4gICAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuXG4gICAgICAgICAgICAgIGlmIChleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvZGUobm9kZSwgZXhwb3J0cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd2Fsa0FTVChub2RlLCBwYXJlbnQsIHBhcGVyRmVhdHVyZXMpIHtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3JhbmdlJyAmJiBrZXkgIT09ICdsb2MnKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGVba2V5XTtcblxuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgd2Fsa0FTVCh2YWx1ZVtpXSwgbm9kZSwgcGFwZXJGZWF0dXJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB3YWxrQVNUKHZhbHVlLCBub2RlLCBwYXBlckZlYXR1cmVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXBlckZlYXR1cmVzLm9wZXJhdG9yT3ZlcmxvYWRpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoYW5kbGVPdmVybG9hZGluZyhub2RlLCBwYXJlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXBlckZlYXR1cmVzLm1vZHVsZUV4cG9ydHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoYW5kbGVFeHBvcnRzKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbmNvZGVWTFEodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcyA9ICcnLFxuICAgICAgICAgICAgYmFzZTY0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgICAgICB2YWx1ZSA9IChNYXRoLmFicyh2YWx1ZSkgPDwgMSkgKyAodmFsdWUgPCAwID8gMSA6IDApO1xuXG4gICAgICAgIHdoaWxlICh2YWx1ZSB8fCAhcmVzKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSB2YWx1ZSAmIDMyIC0gMTtcbiAgICAgICAgICB2YWx1ZSA+Pj0gNTtcbiAgICAgICAgICBpZiAodmFsdWUpIG5leHQgfD0gMzI7XG4gICAgICAgICAgcmVzICs9IGJhc2U2NFtuZXh0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIHZhciB1cmwgPSBvcHRpb25zLnVybCB8fCAnJyxcbiAgICAgICAgICBzb3VyY2VNYXBzID0gb3B0aW9ucy5zb3VyY2VNYXBzLFxuICAgICAgICAgIHBhcGVyRmVhdHVyZXMgPSBvcHRpb25zLnBhcGVyRmVhdHVyZXMgfHwge30sXG4gICAgICAgICAgc291cmNlID0gb3B0aW9ucy5zb3VyY2UgfHwgY29kZSxcbiAgICAgICAgICBvZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwLFxuICAgICAgICAgIGFnZW50ID0gcGFwZXIuYWdlbnQsXG4gICAgICAgICAgdmVyc2lvbiA9IGFnZW50LnZlcnNpb25OdW1iZXIsXG4gICAgICAgICAgb2Zmc2V0Q29kZSA9IGZhbHNlLFxuICAgICAgICAgIGxpbmVCcmVha3MgPSAvXFxyXFxufFxcbnxcXHIvbWcsXG4gICAgICAgICAgbWFwO1xuXG4gICAgICBpZiAoc291cmNlTWFwcyAmJiAoYWdlbnQuY2hyb21lICYmIHZlcnNpb24gPj0gMzAgfHwgYWdlbnQud2Via2l0ICYmIHZlcnNpb24gPj0gNTM3Ljc2IHx8IGFnZW50LmZpcmVmb3ggJiYgdmVyc2lvbiA+PSAyMyB8fCBhZ2VudC5ub2RlKSkge1xuICAgICAgICBpZiAoYWdlbnQubm9kZSkge1xuICAgICAgICAgIG9mZnNldCAtPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdyAmJiB1cmwgJiYgIXdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YodXJsKSkge1xuICAgICAgICAgIHZhciBodG1sID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2h0bWwnKVswXS5pbm5lckhUTUw7XG4gICAgICAgICAgb2Zmc2V0ID0gaHRtbC5zdWJzdHIoMCwgaHRtbC5pbmRleE9mKGNvZGUpICsgMSkubWF0Y2gobGluZUJyZWFrcykubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldENvZGUgPSBvZmZzZXQgPiAwICYmICEoYWdlbnQuY2hyb21lICYmIHZlcnNpb24gPj0gMzYgfHwgYWdlbnQuc2FmYXJpICYmIHZlcnNpb24gPj0gNjAwIHx8IGFnZW50LmZpcmVmb3ggJiYgdmVyc2lvbiA+PSA0MCB8fCBhZ2VudC5ub2RlKTtcbiAgICAgICAgdmFyIG1hcHBpbmdzID0gWydBQScgKyBlbmNvZGVWTFEob2Zmc2V0Q29kZSA/IDAgOiBvZmZzZXQpICsgJ0EnXTtcbiAgICAgICAgbWFwcGluZ3MubGVuZ3RoID0gKGNvZGUubWF0Y2gobGluZUJyZWFrcykgfHwgW10pLmxlbmd0aCArIDEgKyAob2Zmc2V0Q29kZSA/IG9mZnNldCA6IDApO1xuICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgdmVyc2lvbjogMyxcbiAgICAgICAgICBmaWxlOiB1cmwsXG4gICAgICAgICAgbmFtZXM6IFtdLFxuICAgICAgICAgIG1hcHBpbmdzOiBtYXBwaW5ncy5qb2luKCc7QUFDQScpLFxuICAgICAgICAgIHNvdXJjZVJvb3Q6ICcnLFxuICAgICAgICAgIHNvdXJjZXM6IFt1cmxdLFxuICAgICAgICAgIHNvdXJjZXNDb250ZW50OiBbc291cmNlXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAocGFwZXJGZWF0dXJlcy5vcGVyYXRvck92ZXJsb2FkaW5nICE9PSBmYWxzZSB8fCBwYXBlckZlYXR1cmVzLm1vZHVsZUV4cG9ydHMgIT09IGZhbHNlKSB7XG4gICAgICAgIHdhbGtBU1QocGFyc2UoY29kZSwge1xuICAgICAgICAgIHJhbmdlczogdHJ1ZSxcbiAgICAgICAgICBwcmVzZXJ2ZVBhcmVuczogdHJ1ZSxcbiAgICAgICAgICBzb3VyY2VUeXBlOiAnbW9kdWxlJ1xuICAgICAgICB9KSwgbnVsbCwgcGFwZXJGZWF0dXJlcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXApIHtcbiAgICAgICAgaWYgKG9mZnNldENvZGUpIHtcbiAgICAgICAgICBjb2RlID0gbmV3IEFycmF5KG9mZnNldCArIDEpLmpvaW4oJ1xcbicpICsgY29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgvXihpbmxpbmV8Ym90aCkkLy50ZXN0KHNvdXJjZU1hcHMpKSB7XG4gICAgICAgICAgY29kZSArPSBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBzZWxmLmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KG1hcCkpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlICs9IFwiXFxuLy8jIHNvdXJjZVVSTD1cIiArICh1cmwgfHwgJ3BhcGVyc2NyaXB0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgbWFwOiBtYXBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY3V0ZShjb2RlLCBzY29wZSwgb3B0aW9ucykge1xuICAgICAgcGFwZXIgPSBzY29wZTtcbiAgICAgIHZhciB2aWV3ID0gc2NvcGUuZ2V0VmlldygpLFxuICAgICAgICAgIHRvb2wgPSAvXFxidG9vbFxcLlxcdyt8XFxzK29uKD86S2V5fE1vdXNlKSg/OlVwfERvd258TW92ZXxEcmFnKVxcYi8udGVzdChjb2RlKSAmJiAhL1xcYm5ld1xccytUb29sXFxiLy50ZXN0KGNvZGUpID8gbmV3IFRvb2woKSA6IG51bGwsXG4gICAgICAgICAgdG9vbEhhbmRsZXJzID0gdG9vbCA/IHRvb2wuX2V2ZW50cyA6IFtdLFxuICAgICAgICAgIGhhbmRsZXJzID0gWydvbkZyYW1lJywgJ29uUmVzaXplJ10uY29uY2F0KHRvb2xIYW5kbGVycyksXG4gICAgICAgICAgcGFyYW1zID0gW10sXG4gICAgICAgICAgYXJncyA9IFtdLFxuICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgY29tcGlsZWQgPSB0eXBlb2YgY29kZSA9PT0gJ29iamVjdCcgPyBjb2RlIDogY29tcGlsZShjb2RlLCBvcHRpb25zKTtcbiAgICAgIGNvZGUgPSBjb21waWxlZC5jb2RlO1xuXG4gICAgICBmdW5jdGlvbiBleHBvc2Uoc2NvcGUsIGhpZGRlbikge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2NvcGUpIHtcbiAgICAgICAgICBpZiAoKGhpZGRlbiB8fCAhL15fLy50ZXN0KGtleSkpICYmIG5ldyBSZWdFeHAoJyhbXFxcXGJcXFxcc1xcXFxXXXxeKScgKyBrZXkucmVwbGFjZSgvXFwkL2csICdcXFxcJCcpICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGFyZ3MucHVzaChzY29wZVtrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXhwb3NlKHtcbiAgICAgICAgX18kX186IF9fJF9fLFxuICAgICAgICAkX186ICRfXyxcbiAgICAgICAgcGFwZXI6IHNjb3BlLFxuICAgICAgICB0b29sOiB0b29sXG4gICAgICB9LCB0cnVlKTtcbiAgICAgIGV4cG9zZShzY29wZSk7XG4gICAgICBjb2RlID0gJ3ZhciBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH07ICcgKyBjb2RlO1xuICAgICAgdmFyIGV4cG9ydHMgPSBCYXNlLmVhY2goaGFuZGxlcnMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxzKycgKyBrZXkgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgcGFyYW1zLnB1c2goa2V5KTtcbiAgICAgICAgICB0aGlzLnB1c2goJ21vZHVsZS5leHBvcnRzLicgKyBrZXkgKyAnID0gJyArIGtleSArICc7Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtdKS5qb2luKCdcXG4nKTtcblxuICAgICAgaWYgKGV4cG9ydHMpIHtcbiAgICAgICAgY29kZSArPSAnXFxuJyArIGV4cG9ydHM7XG4gICAgICB9XG5cbiAgICAgIGNvZGUgKz0gJ1xcbnJldHVybiBtb2R1bGUuZXhwb3J0czsnO1xuICAgICAgdmFyIGFnZW50ID0gcGFwZXIuYWdlbnQ7XG5cbiAgICAgIGlmIChkb2N1bWVudCAmJiAoYWdlbnQuY2hyb21lIHx8IGFnZW50LmZpcmVmb3ggJiYgYWdlbnQudmVyc2lvbk51bWJlciA8IDQwKSkge1xuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXG4gICAgICAgICAgICBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICBpZiAoYWdlbnQuZmlyZWZveCkgY29kZSA9ICdcXG4nICsgY29kZTtcbiAgICAgICAgc2NyaXB0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdkb2N1bWVudC5fX3BhcGVyc2NyaXB0X18gPSBmdW5jdGlvbignICsgcGFyYW1zICsgJykgeycgKyBjb2RlICsgJ1xcbn0nKSk7XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgZnVuYyA9IGRvY3VtZW50Ll9fcGFwZXJzY3JpcHRfXztcbiAgICAgICAgZGVsZXRlIGRvY3VtZW50Ll9fcGFwZXJzY3JpcHRfXztcbiAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVuYyA9IEZ1bmN0aW9uKHBhcmFtcywgY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBleHBvcnRzID0gZnVuYyAmJiBmdW5jLmFwcGx5KHNjb3BlLCBhcmdzKTtcbiAgICAgIHZhciBvYmogPSBleHBvcnRzIHx8IHt9O1xuICAgICAgQmFzZS5lYWNoKHRvb2xIYW5kbGVycywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlKSB0b29sW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodmlldykge1xuICAgICAgICBpZiAob2JqLm9uUmVzaXplKSB2aWV3LnNldE9uUmVzaXplKG9iai5vblJlc2l6ZSk7XG4gICAgICAgIHZpZXcuZW1pdCgncmVzaXplJywge1xuICAgICAgICAgIHNpemU6IHZpZXcuc2l6ZSxcbiAgICAgICAgICBkZWx0YTogbmV3IFBvaW50KClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvYmoub25GcmFtZSkgdmlldy5zZXRPbkZyYW1lKG9iai5vbkZyYW1lKTtcbiAgICAgICAgdmlldy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHBvcnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRTY3JpcHQoc2NyaXB0KSB7XG4gICAgICBpZiAoL150ZXh0XFwvKD86eC18KXBhcGVyc2NyaXB0JC8udGVzdChzY3JpcHQudHlwZSkgJiYgUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnaWdub3JlJykgIT09ICd0cnVlJykge1xuICAgICAgICB2YXIgY2FudmFzSWQgPSBQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShzY3JpcHQsICdjYW52YXMnKSxcbiAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKSxcbiAgICAgICAgICAgIHNyYyA9IHNjcmlwdC5zcmMgfHwgc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKSxcbiAgICAgICAgICAgIGFzeW5jID0gUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoc2NyaXB0LCAnYXN5bmMnKSxcbiAgICAgICAgICAgIHNjb3BlQXR0cmlidXRlID0gJ2RhdGEtcGFwZXItc2NvcGUnO1xuICAgICAgICBpZiAoIWNhbnZhcykgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBjYW52YXMgd2l0aCBpZCBcIicgKyBjYW52YXNJZCArICdcIicpO1xuICAgICAgICB2YXIgc2NvcGUgPSBQYXBlclNjb3BlLmdldChjYW52YXMuZ2V0QXR0cmlidXRlKHNjb3BlQXR0cmlidXRlKSkgfHwgbmV3IFBhcGVyU2NvcGUoKS5zZXR1cChjYW52YXMpO1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHNjb3BlQXR0cmlidXRlLCBzY29wZS5faWQpO1xuXG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICBIdHRwLnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsOiBzcmMsXG4gICAgICAgICAgICBhc3luYzogYXN5bmMsXG4gICAgICAgICAgICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgb25Mb2FkOiBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgICAgICBleGVjdXRlKGNvZGUsIHNjb3BlLCBzcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4ZWN1dGUoc2NyaXB0LmlubmVySFRNTCwgc2NvcGUsIHNjcmlwdC5iYXNlVVJJKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItaWdub3JlJywgJ3RydWUnKTtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRBbGwoKSB7XG4gICAgICBCYXNlLmVhY2goZG9jdW1lbnQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpLCBsb2FkU2NyaXB0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkKHNjcmlwdCkge1xuICAgICAgcmV0dXJuIHNjcmlwdCA/IGxvYWRTY3JpcHQoc2NyaXB0KSA6IGxvYWRBbGwoKTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93KSB7XG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBzZXRUaW1lb3V0KGxvYWRBbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRG9tRXZlbnQuYWRkKHdpbmRvdywge1xuICAgICAgICAgIGxvYWQ6IGxvYWRBbGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBleGVjdXRlOiBleGVjdXRlLFxuICAgICAgbG9hZDogbG9hZCxcbiAgICAgIHBhcnNlOiBwYXJzZSxcbiAgICAgIGNhbGN1bGF0ZUJpbmFyeTogX18kX18sXG4gICAgICBjYWxjdWxhdGVVbmFyeTogJF9fXG4gICAgfTtcbiAgfS5jYWxsKHRoaXMpO1xuXG4gIHZhciBwYXBlciA9IG5ldyAoUGFwZXJTY29wZS5pbmplY3QoQmFzZS5leHBvcnRzLCB7XG4gICAgQmFzZTogQmFzZSxcbiAgICBOdW1lcmljYWw6IE51bWVyaWNhbCxcbiAgICBLZXk6IEtleSxcbiAgICBEb21FdmVudDogRG9tRXZlbnQsXG4gICAgRG9tRWxlbWVudDogRG9tRWxlbWVudCxcbiAgICBkb2N1bWVudDogZG9jdW1lbnQsXG4gICAgd2luZG93OiB3aW5kb3csXG4gICAgU3ltYm9sOiBTeW1ib2xEZWZpbml0aW9uLFxuICAgIFBsYWNlZFN5bWJvbDogU3ltYm9sSXRlbVxuICB9KSkoKTtcblxuICBpZiAocGFwZXIuYWdlbnQubm9kZSkge1xuICAgIHJlcXVpcmUoJy4vbm9kZS9leHRlbmQuanMnKShwYXBlcik7XG4gIH1cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCdwYXBlcicsIHBhcGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcGVyO1xuICB9XG5cbiAgcmV0dXJuIHBhcGVyO1xufS5jYWxsKHRoaXMsIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyA/IHNlbGYgOiBudWxsKTsiLCJpbXBvcnQgXCIuL3N0eWxlcy9pbmRleC5zY3NzXCI7XHJcbmltcG9ydCBwYXBlciwgeyBSZWN0YW5nbGUsIFBhdGgsIFBvaW50LCBUb29sLCBQb2ludFRleHQgfSBmcm9tICdwYXBlcic7XHJcbmltcG9ydCBTaWRlYmFyIGZyb20gJy4vc2NyaXB0cy9zaWRlYmFyL3NpZGViYXInO1xyXG5pbXBvcnQgc2lkZWJhckRhdGEgZnJvbSAnLi9zY3JpcHRzL3V0aWwvc2lkZWJhcl9kYXRhJ1xyXG5pbXBvcnQgTXlDYW52YXMgZnJvbSBcIi4vc2NyaXB0cy9jYW52YXMvY2FudmFzXCI7XHJcbmltcG9ydCBJbmZvIGZyb20gXCIuL3NjcmlwdHMvaW50cm8vaW5mb1wiO1xyXG5pbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIi4vc2NyaXB0cy9pbnRyby9tZXNzc2FnXCI7XHJcblxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgbWFpbiA9PntcclxuICAgIC8vIGNhbnZhc1xyXG4gICAgY29uc3QgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteUNhbnZhcycpO1xyXG4gICAgY29uc3QgbXlDYW52YXMgPSBuZXcgTXlDYW52YXMoY2FudmFzRWxlbWVudCk7XHJcblxyXG4gICBcclxuXHJcbiAgICAvL3NpZGViYXJcclxuICAgIGNvbnN0IHNpZGViYXJFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlY3Rpb24tY29udGVudC1zaWRlYmFyJyk7XHJcbiAgICBjb25zdCBzaWRlYmFyID0gbmV3IFNpZGViYXIoXHJcbiAgICAgICAgc2lkZWJhckRhdGFbMF0sIFxyXG4gICAgICAgIHNpZGViYXJFbGVtZW50LFxyXG4gICAgICAgIG15Q2FudmFzLmRyYXdTaGFwZXMpO1xyXG5cclxuXHJcbiAgICAvL2luZm8gc2lkZSBiYXJcclxuICAgIGNvbnN0IGluZm9TaWRlYmFyID0gbmV3IEluZm8oXCJUaXBzXCIsIG1lc3NhZ2UpO1xyXG5cclxuICAgICBcclxufSk7XHJcblxyXG5cclxuIiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSBcIi4uL3V0aWwvY29uc3RhbnRzXCI7XHJcbmltcG9ydCBwYXBlciwgeyBQcm9qZWN0LCBQYXRoLCBHcm91cCwgUG9pbnRUZXh0LCB0b29sLCBUb29sLCBSZWN0YW5nbGUsIFBvaW50LCBTaXplIH0gZnJvbSAncGFwZXInO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uL21vZGFsL21vZGFsXCI7XHJcblxyXG5pbXBvcnQge2dldEFuZ2xlRGVnfSBmcm9tICcuLi91dGlsL3V0aWwnO1xyXG5cclxuY29uc3QgYm91bmRzSWRlbnRpZmllck9iaiA9IHtcclxuICAxOiAndG9wTGVmdCcsIDI6ICd0b3BSaWdodCcsIDM6ICdib3R0b21SaWdodCcsIDA6ICdib3R0b21MZWZ0J1xyXG59XHJcbmNvbnN0IExJTkUgPSAnbGluZSc7IFxyXG5cclxuY2xhc3MgTXlDYW52YXMge1xyXG4gIGNvbnN0cnVjdG9yKGNhbnZhc0VsZW1lbnQpIHtcclxuICAgIHRoaXMuY2FudmFzRWxlbWVudCA9ICBjYW52YXNFbGVtZW50O1xyXG4gICAgdGhpcy5jZW50ZXJQb3NpdGlvbiA9IHRoaXMuZ2V0Q2VudGVyUG9zaXRpb24oKTtcclxuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSAnYmxhY2snO1xyXG4gICAgdGhpcy5maWxsQ29sb3IgPSBcIndoaXRlXCI7XHJcbiAgICB0aGlzLmRlZmF1bHRTaXplID0gWzEwMCwxMDBdO1xyXG4gICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbSA9IG51bGw7XHJcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMjtcclxuXHJcbiAgICAvLyBzZXRzIHVwIHBhcGVyIGpzIG9uIGNhbnZhc1xyXG4gICAgcGFwZXIuc2V0dXAoY2FudmFzRWxlbWVudCk7XHJcblxyXG4gICAgLy9jcmVhdGVzIG5ldyBwcm9qZWN0IGluIHBhcGVyXHJcbiAgICB0aGlzLnByb2plY3QgPSBuZXcgUHJvamVjdChjYW52YXNFbGVtZW50KVxyXG5cclxuICAgIC8vY2FudmFzIHNjYWxlIHZhbHVlXHJcbiAgICB0aGlzLmNhbnZhc1NjYWxlVmFsdWUgPSAxO1xyXG5cclxuICAgIC8vY3JlYXRpbmcgdG9vbFxyXG4gICAgdGhpcy50b29sID0gbmV3IFRvb2woKTtcclxuICAgIC8vIGhhcyBtb3ZlZCBhdCBsZWFzdCAxMCBwb2ludHM6XHJcbiAgICB0b29sLm1pbkRpc3RhbmNlID0gMjtcclxuXHJcbiAgICAvL2JpbmRzIG1ldGhvZHNcclxuICAgIC8vc2hhcGVzIG1ldGhvZCBiaW5kaW5nXHJcbiAgICB0aGlzLmRyYXdTaGFwZXMgPSB0aGlzLmRyYXdTaGFwZXMuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZHJhd0NsYXNzU2hhcGUgPSB0aGlzLmRyYXdDbGFzc1NoYXBlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmRyYXdMaW5lU2hhcGUgPSB0aGlzLmRyYXdMaW5lU2hhcGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZHJhd09iamVjdFNoYXBlID0gdGhpcy5kcmF3T2JqZWN0U2hhcGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZHJhd1RleHRTaGFwZSA9IHRoaXMuZHJhd1RleHRTaGFwZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5kcmF3VXNlckNhc2VTaGFwZSA9IHRoaXMuZHJhd1VzZUNhc2VTaGFwZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5kcmF3Q29tcG9uZW50U2hhcGUgPSB0aGlzLmRyYXdDb21wb25lbnRTaGFwZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5kcmF3TW9kdWxlU2hhcGUgPSB0aGlzLmRyYXdNb2R1bGVTaGFwZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5kcmF3QWN0aXZpdHlTaGFwZSA9IHRoaXMuZHJhd0FjdGl2aXR5U2hhcGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZHJhd0RlY2lzaW9uU2hhcGUgPSB0aGlzLmRyYXdEZWNpc2lvblNoYXBlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmRyYXdBY3RvclNoYXBlID0gdGhpcy5kcmF3QWN0b3JTaGFwZS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vZ2VuZXJhbCBtZXRob2QgYmluZGluZ1xyXG4gICAgdGhpcy5nZXRDZW50ZXJQb3NpdGlvbiA9IHRoaXMuZ2V0Q2VudGVyUG9zaXRpb24uYmluZCh0aGlzKTtcclxuXHJcbiAgICAvL3VzZXIgaW50ZXJhY3Rpb24gbWV0aG9kIGJpbmRpbmdcclxuICAgIHRoaXMub25Ub29sRG91YmxlQ2xpY2sgPSB0aGlzLm9uVG9vbERvdWJsZUNsaWNrLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uVG9vbE1vdXNlRG93biA9IHRoaXMub25Ub29sTW91c2VEb3duLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnNldE9uZUl0ZW1TZWxlY3RlZCA9IHRoaXMuc2V0T25lSXRlbVNlbGVjdGVkLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uVG9vbERyYWcgPSB0aGlzLm9uVG9vbERyYWcuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25Ub29sS2V5RG93biA9IHRoaXMub25Ub29sS2V5RG93bi5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vdG9vbCBsZXZlbCBjbGlja2xpc3RlbmVyXHJcbiAgICB0aGlzLnRvb2wub25Nb3VzZURvd24gPSB0aGlzLm9uVG9vbE1vdXNlRG93bjtcclxuICAgIHRoaXMudG9vbC5vbk1vdXNlVXAgPSB0aGlzLm9uVG9vbE1vdXNlVXA7XHJcbiAgICB0aGlzLnRvb2wub25Nb3VzZURyYWcgPSB0aGlzLm9uVG9vbERyYWc7XHJcbiAgICB0aGlzLnRvb2wub25LZXlEb3duID0gdGhpcy5vblRvb2xLZXlEb3duO1xyXG5cclxuICAgICAvL2FkZCBkb3VibGUgY2xpY2sgbGlzdGVuZXIgb24gY2FudmFzIGJlY2F1c2UgdG9vbCBoYXZlIG5vIGRvdWJsZSBjbGljayBsaXN0ZW5lclxyXG4gICAgdGhpcy5jYW52YXNFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCB0aGlzLm9uVG9vbERvdWJsZUNsaWNrKTtcclxuXHJcbiAgICAvL3NldCByaWdodCBtZW51IGxpdGVuZXJzXHJcbiAgICB0aGlzLnNldE1lbnVDbGlja0xpc3RlbmVyID0gdGhpcy5zZXRNZW51Q2xpY2tMaXN0ZW5lci5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuc2V0TWVudUNsaWNrTGlzdGVuZXIoKTtcclxuICB9XHJcblxyXG5cclxuICAvL3NldCByaWdodCBtZW51IGNsaWNrIGxpc3RlbmVyXHJcbiAgc2V0TWVudUNsaWNrTGlzdGVuZXIoKXtcclxuICAgIGNvbnN0IG9wZW5GaWxlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvcGVuLWZpbGUnKTtcclxuICAgIGNvbnN0IGRvd25sb2FkRmlsZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93bmxvYWQtZmlsZScpO1xyXG4gICAgY29uc3QgYnJpbmdUb0Zyb250RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdicmluZy10by1mcm9udCcpO1xyXG4gICAgY29uc3QgbW92ZVRvQmFja0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW92ZS10by1iYWNrJyk7XHJcblxyXG4gICAgb3BlbkZpbGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyx0aGlzLm9wZW5GaWxlLmJpbmQodGhpcykpO1xyXG4gICAgZG93bmxvYWRGaWxlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZG93bmxvYWRBc1NWRy5iaW5kKHRoaXMpKTtcclxuICAgIGJyaW5nVG9Gcm9udEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmJyaW5nVG9Gcm9udC5iaW5kKHRoaXMpKTtcclxuICAgIG1vdmVUb0JhY2tFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5tb3ZlVG9CYWNrLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbiAgLy9zZXQgaW5wdXQgdG8gb3BlbiBmaWxlIHBpY2tlciBkaWFsb2dcclxuICBvcGVuRmlsZSgpe1xyXG4gICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgIGlucHV0LnR5cGUgPSAnZmlsZSc7XHJcbiAgICBpbnB1dC5tdWx0aXBsZSA9IGZhbHNlO1xyXG4gICAgaW5wdXQuYWNjZXB0ID0gJ2ltYWdlL3N2Zyt4bWwnO1xyXG4gICAgaW5wdXQub25jaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvamVjdC5pbXBvcnRTVkcoVVJMLmNyZWF0ZU9iamVjdFVSTChpbnB1dC5maWxlc1swXSksKGdyb3VwLCBzdmcpPT57XHJcbiAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0LmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgd2hpbGUoZ3JvdXAuY2hpbGRyZW5bMV0uY2hpbGRyZW4ubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnByb2plY3QuYWN0aXZlTGF5ZXIuYWRkQ2hpbGQoZ3JvdXAuY2hpbGRyZW5bMV0uY2hpbGRyZW5bMF0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH07XHJcbiAgICBpbnB1dC5jbGljaygpO1xyXG4gICAgXHJcbiAgfVxyXG5cclxuICAvLyBzZXQgZG93bmxvYWQgcHJvamVjdCBhcyBzdmdcclxuICBkb3dubG9hZEFzU1ZHKCkge1xyXG4gICBcclxuICAgIGlmKHRoaXMucHJvamVjdC5hY3RpdmVMYXllci5jaGlsZHJlbi5sZW5ndGggPT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGZpbGVOYW1lID0gYHVtbGNoYXJ0XyR7RGF0ZS5ub3coKX0uc3ZnYDtcclxuIFxyXG4gICAgdmFyIHVybCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsXCIgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5wcm9qZWN0LmV4cG9ydFNWRyh7YXNTdHJpbmc6dHJ1ZX0pKTtcclxuICAgIFxyXG4gICAgdmFyIGRvd25sb2FkTGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgIGRvd25sb2FkTGlua0VsZW1lbnQuZG93bmxvYWQgPSBmaWxlTmFtZTtcclxuICAgIGRvd25sb2FkTGlua0VsZW1lbnQuaHJlZiA9IHVybDtcclxuICAgIGRvd25sb2FkTGlua0VsZW1lbnQuY2xpY2soKTtcclxuIH1cclxuXHJcblxyXG4gLy9zZXQgYnJpbmcgdG8gZnJvbnQgbGlzdGVuZXIgZm9yIGl0ZW1zXHJcbiBicmluZ1RvRnJvbnQoKXtcclxuICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmJyaW5nVG9Gcm9udCgpO1xyXG4gfVxyXG5cclxuIC8vc2V0IG1vdmUgdG8gYmFjayBsaXN0ZW5lciBmb3IgaXRlbXNcclxuIG1vdmVUb0JhY2soKXtcclxuICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLnNlbmRUb0JhY2soKTtcclxuIH1cclxuXHJcbiAgLy9zaGFwZSBkcmF3IGRpc3RyaWJ1dG9yXHJcbiAgZHJhd1NoYXBlcyhzaGFwZU5hbWUpe1xyXG5cclxuICAgIHN3aXRjaCAoc2hhcGVOYW1lKSB7XHJcbiAgICAgIGNhc2UgU0hBUEVTLkNMQVNTOlxyXG4gICAgICAgIHRoaXMuZHJhd0NsYXNzU2hhcGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuQUdHUkVHQVRJT046XHJcbiAgICAgIGNhc2UgU0hBUEVTLkNPTVBPU0lUSU9OOlxyXG4gICAgICBjYXNlIFNIQVBFUy5ESVZJREVSOiAgXHJcbiAgICAgIGNhc2UgU0hBUEVTLkFTU09DSUFUSU9OOiAgXHJcbiAgICAgICAgbGV0IHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LTUwLCB0aGlzLmNlbnRlclBvc2l0aW9uLnkpO1xyXG4gICAgICAgIGxldCBlbmRQb2ludCA9IG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngrNTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueSk7XHJcbiAgICAgICAgdGhpcy5kcmF3TGluZVNoYXBlKHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBzaGFwZU5hbWUpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFNIQVBFUy5TUVVBUkU6XHJcbiAgICAgIGNhc2UgU0hBUEVTLk9CSkVDVDpcclxuICAgICAgY2FzZSBTSEFQRVMuSU5URVJGQUNFOlxyXG4gICAgICAgICAgdGhpcy5kcmF3T2JqZWN0U2hhcGUoc2hhcGVOYW1lKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuVElUTEU6XHJcbiAgICAgICAgc3RhcnRQb2ludCA9IG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMjUsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yNSk7XHJcbiAgICAgICAgdGhpcy5kcmF3VGV4dFNoYXBlKHN0YXJ0UG9pbnQsIFwiQWRkIFRleHRcIik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU0hBUEVTLkNJUkNMRTpcclxuICAgICAgY2FzZSBTSEFQRVMuVVNFQ0FTRTpcclxuICAgICAgICB0aGlzLmRyYXdVc2VDYXNlU2hhcGUoc2hhcGVOYW1lKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuQ09NUE9ORU5UOlxyXG4gICAgICAgIHRoaXMuZHJhd0NvbXBvbmVudFNoYXBlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU0hBUEVTLk1PRFVMRTpcclxuICAgICAgICB0aGlzLmRyYXdNb2R1bGVTaGFwZSgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFNIQVBFUy5BQ1RJVklUWTpcclxuICAgICAgICB0aGlzLmRyYXdBY3Rpdml0eVNoYXBlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU0hBUEVTLkRFQ0lTSU9OOlxyXG4gICAgICAgIHRoaXMuZHJhd0RlY2lzaW9uU2hhcGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuQUNUT1I6XHJcbiAgICAgICAgdGhpcy5kcmF3QWN0b3JTaGFwZSgpO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlcyB0aHJlZSByZWN0YW5nbGUgdG8gbWFrZSBhIGNsYXNzIFVNTFxyXG4gIGRyYXdDbGFzc1NoYXBlKCl7XHJcbiAgICAvL2NyZWF0ZXMgZ3JvdXAgYW5kIGFkZCBzaGFwZXNcclxuXHJcbiAgICAvL2NyZWF0ZSBjbGFzcyByZWN0YW5nbGVcclxuICAgIGNvbnN0IGdyb3VwQ2xhc3MgPSBuZXcgR3JvdXAoKTtcclxuICAgIGNvbnN0IGZpcnN0UmVjdFggPSB0aGlzLmNlbnRlclBvc2l0aW9uLngtNTA7XHJcbiAgICBjb25zdCBmaXJzdFJlY3RZID0gdGhpcy5jZW50ZXJQb3NpdGlvbi55LTUwO1xyXG4gICAgY29uc3QgZmlyc3RSZWN0SGVpZ2h0ID0gMjA7XHJcbiAgICBjb25zdCBmcmlzdFJlY3RXaWR0aCA9IHRoaXMuZGVmYXVsdFNpemVbMV07XHJcbiAgICBjb25zdCBjbGFzc05hbWVSZWN0YW5nbGUgPSBuZXcgUGF0aC5SZWN0YW5nbGUoZmlyc3RSZWN0WCwgZmlyc3RSZWN0WSwgZnJpc3RSZWN0V2lkdGgsIGZpcnN0UmVjdEhlaWdodCk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoY2xhc3NOYW1lUmVjdGFuZ2xlKTtcclxuICAgIGdyb3VwQ2xhc3MuYWRkQ2hpbGQoY2xhc3NOYW1lUmVjdGFuZ2xlKTtcclxuXHJcbiAgICAvL2NyZWF0ZSB2YXJhaWJsZSByZWN0YW5nbGVcclxuICAgIGNvbnN0IHNlY1JlY3RYID0gZmlyc3RSZWN0WDtcclxuICAgIGNvbnN0IHNlY1JlY3RZID0gZmlyc3RSZWN0WSArIGZpcnN0UmVjdEhlaWdodDtcclxuICAgIGNvbnN0IHNlY1JlY3RIZWlnaHQgPSA1MDtcclxuICAgIGNvbnN0IHNlY1JlY3RXaWR0aCA9IHRoaXMuZGVmYXVsdFNpemVbMV07XHJcbiAgICBjb25zdCB2YXJpYWJsZU5hbWVSZWN0YW5nbGUgPSBuZXcgUGF0aC5SZWN0YW5nbGUoc2VjUmVjdFgsIHNlY1JlY3RZLCBzZWNSZWN0V2lkdGgsIHNlY1JlY3RIZWlnaHQpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHZhcmlhYmxlTmFtZVJlY3RhbmdsZSk7XHJcbiAgICBncm91cENsYXNzLmFkZENoaWxkKHZhcmlhYmxlTmFtZVJlY3RhbmdsZSk7XHJcblxyXG5cclxuICAgIC8vY3JlYXRlIG1ldGhvZCByZWN0YW5nbGVcclxuICAgIGNvbnN0IHRoaXJkUmVjdFggPSBmaXJzdFJlY3RYO1xyXG4gICAgY29uc3QgdGhpcmRSZWN0WSA9IHNlY1JlY3RZICsgc2VjUmVjdEhlaWdodDtcclxuICAgIGNvbnN0IHRoaXJkUmVjdEhlaWdodCA9IDMwO1xyXG4gICAgY29uc3QgdGhpcmRSZWN0V2lkdGggPSB0aGlzLmRlZmF1bHRTaXplWzFdO1xyXG4gICAgY29uc3QgbWV0aG9kTmFtZVJlY3RhbmdsZSA9IG5ldyBQYXRoLlJlY3RhbmdsZSh0aGlyZFJlY3RYLCB0aGlyZFJlY3RZLCB0aGlyZFJlY3RXaWR0aCwgdGhpcmRSZWN0SGVpZ2h0KTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChtZXRob2ROYW1lUmVjdGFuZ2xlKTtcclxuICAgIGdyb3VwQ2xhc3MuYWRkQ2hpbGQobWV0aG9kTmFtZVJlY3RhbmdsZSk7XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gYWRkcyB0ZXh0IHRvIHRoZSBjbGlja2VkIGFyZWFcclxuICBkcmF3VGV4dFNoYXBlKHBvc2l0aW9uLCB0ZXh0KXtcclxuICAgIC8vY3JlYXRlIHRleHQgc2hhcGVcclxuICAgIGxldCB0ZXh0U2hhcGUgPSBuZXcgUG9pbnRUZXh0KHBvc2l0aW9uKTtcclxuICAgIHRleHRTaGFwZS5maWxsQ29sb3IgPSB0aGlzLnN0cm9rZUNvbG9yO1xyXG4gICAgdGV4dFNoYXBlLmNvbnRlbnQgPSB0ZXh0O1xyXG5cclxuICAgIC8vYWRkcyBkb3VibGVjbGljayBsaXN0bmVyIHRvIHRleHRcclxuICAgIHRleHRTaGFwZS5vbkRvdWJsZUNsaWNrID0gKGUpPT57XHJcbiAgICAgIC8vc2hvdyBtb2RhbCB0byB1cGRhdGUgdGV4dFxyXG4gICAgICBpZih0ZXh0U2hhcGUuYm91bmRzLnNlbGVjdGVkKXtcclxuICAgICAgICBuZXcgTW9kYWwoKHVwZGF0ZWRUZXh0KT0+e1xyXG4gICAgICAgICAgdGV4dFNoYXBlLmNvbnRlbnQgPSB1cGRhdGVkVGV4dDtcclxuICAgICAgICB9KS5zaG93KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dFNoYXBlXHJcbiAgfVxyXG5cclxuICAvL2FkZCBEaXZpZGVyL0Fzc29jaWF0aW9uL0NvbXBvc2l0aW9pbi9BZ2dyZWdhdGlvbiB3aXRoIGhlYWQgc2hhcGUgYW5kIHRocmVlIGNpcmNsZXMgKHRvIGFpZCBtb3ZlbWVudCBhbmQgZHJhZylcclxuICBkcmF3TGluZVNoYXBlKHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBsaW5lVHlwZSl7XHJcbiAgICBcclxuXHJcbiAgICBsZXQgbWFpbkdyb3VwID0gbmV3IEdyb3VwKCk7XHJcbiAgICBsZXQgZ3JvdXAgPSAgbmV3IEdyb3VwKCk7XHJcbiAgICBcclxuICAgIC8vZHJhdyBsaW5lXHJcbiAgICBjb25zdCBsaW5lID0gbmV3IFBhdGguTGluZShzdGFydFBvaW50LCBlbmRQb2ludCk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwobGluZSk7XHJcblxyXG4gICAgLy8gZHJhdyBoZWFkIGNpcmNsZVxyXG4gICAgY29uc3QgaGVhZENpcmNsZSA9IG5ldyBQYXRoLkNpcmNsZShlbmRQb2ludCwgNSk7XHJcbiAgICBoZWFkQ2lyY2xlLmZpbGxDb2xvciA9ICdibGFjayc7XHJcbiAgICBoZWFkQ2lyY2xlLnN0cm9rZVdpZHRoID0gMTtcclxuXHJcbiAgICAvL2RyYXcgbWlkZGxlIGNpcmNsZVxyXG4gICAgY29uc3QgbWlkUG9pbnQgPSBuZXcgUG9pbnQoKHN0YXJ0UG9pbnQueCtlbmRQb2ludC54KS8yLCAoc3RhcnRQb2ludC55K2VuZFBvaW50LnkpLzIpXHJcbiAgICBjb25zdCBtaWRDaXJjbGUgPSBuZXcgUGF0aC5DaXJjbGUobWlkUG9pbnQsIDQpO1xyXG4gICAgbWlkQ2lyY2xlLmZpbGxDb2xvciA9ICdibGFjayc7XHJcbiAgICBtaWRDaXJjbGUuc3Ryb2tlV2lkdGggPSAxO1xyXG5cclxuXHJcbiAgICAvL2RyYXcgdGFpbCBjaXJjbGVcclxuICAgIGNvbnN0IHRhaWxDaXJjbGUgPSBuZXcgUGF0aC5DaXJjbGUoc3RhcnRQb2ludCwgNSk7XHJcbiAgICB0YWlsQ2lyY2xlLmZpbGxDb2xvciA9ICdibGFjayc7XHJcbiAgICB0YWlsQ2lyY2xlLnN0cm9rZVdpZHRoID0gMTtcclxuXHJcblxyXG4gICAgLy9hZGQgY2lyY2xlcyBhbmQgbGluZSB0byBncm91cFxyXG4gICAgZ3JvdXAuYWRkQ2hpbGQobGluZSk7XHJcbiAgICBncm91cC5hZGRDaGlsZCh0YWlsQ2lyY2xlKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKG1pZENpcmNsZSk7XHJcbiAgICBncm91cC5hZGRDaGlsZChoZWFkQ2lyY2xlKTtcclxuXHJcbiAgICAvL2RyYXcgYXJyb3cgc2hhcGVcclxuICAgIGNvbnN0IGhlYWRTaGFwZSA9IG5ldyBQYXRoKCk7XHJcbiAgICBoZWFkU2hhcGUuc3Ryb2tlQ29sb3I9IHRoaXMuc3Ryb2tlQ29sb3I7XHJcbiAgICBoZWFkU2hhcGUuc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xyXG5cclxuICAgIGxldCBhcnJvd0NlbnRlciA9IGVuZFBvaW50O1xyXG5cclxuICAgIC8vYmFzZWQgb24gbGluZSB0eXBlIGRyYXcgc2hhcGVcclxuICAgIGlmKGxpbmVUeXBlICE9PSBTSEFQRVMuRElWSURFUil7XHJcbiAgICAgIGNvbnN0IGxlZnRFZGdlID0gbmV3IFBvaW50KGFycm93Q2VudGVyLngtMTAsIGFycm93Q2VudGVyLnktMTApO1xyXG4gICAgICBjb25zdCByaWdodEVkZ2UgPSBuZXcgUG9pbnQoYXJyb3dDZW50ZXIueC0xMCwgYXJyb3dDZW50ZXIueSsxMCk7XHJcbiAgICAgIGhlYWRTaGFwZS5hZGQobGVmdEVkZ2UpO1xyXG4gICAgICBoZWFkU2hhcGUuYWRkKGFycm93Q2VudGVyKTtcclxuICAgICAgaGVhZFNoYXBlLmFkZChyaWdodEVkZ2UpO1xyXG5cclxuICAgICAgaWYobGluZVR5cGUgPT09IFNIQVBFUy5BR0dSRUdBVElPTiB8fCBsaW5lVHlwZSA9PT0gIFNIQVBFUy5DT01QT1NJVElPTil7XHJcbiAgICAgICAgY29uc3QgYm90dG9tUmlnaHRFZGdlID0gbmV3IFBvaW50KGFycm93Q2VudGVyLngtMjAsIGFycm93Q2VudGVyLnkpO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUxlZnRFZGdlID0gbGVmdEVkZ2U7XHJcbiAgICAgICAgaGVhZFNoYXBlLmFkZChib3R0b21SaWdodEVkZ2UpO1xyXG4gICAgICAgIGhlYWRTaGFwZS5hZGQoYm90dG9tTGVmdEVkZ2UpO1xyXG5cclxuICAgICAgICBpZihsaW5lVHlwZSA9PT0gU0hBUEVTLkFHR1JFR0FUSU9OKXtcclxuICAgICAgICAgIGhlYWRTaGFwZS5zdHJva2VDb2xvciA9ICd3aGl0ZSc7XHJcbiAgICAgICAgICBoZWFkU2hhcGUuZmlsbENvbG9yID0gJ3doaXRlJztcclxuICAgICAgICAgIGhlYWRTaGFwZS5zaGFkb3dDb2xvciA9ICdncmF5JztcclxuICAgICAgICAgIGhlYWRTaGFwZS5zaGFkb3dPZmZzZXQ9MTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGxpbmVUeXBlID09PSBTSEFQRVMuQ09NUE9TSVRJT04pe1xyXG4gICAgICAgICAgaGVhZFNoYXBlLmZpbGxDb2xvciA9ICdibGFjayc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgXHJcblxyXG4gICAgLy9yb3RhdGUgdGhlIGhlYWQgc2hhcGVcclxuICAgIGlmKGxpbmVUeXBlICE9PSBTSEFQRVMuRElWSURFUilcclxuICAgICAgaGVhZFNoYXBlLnJvdGF0ZShcclxuICAgICAgICBnZXRBbmdsZURlZyhlbmRQb2ludC54LCBlbmRQb2ludC55LHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55KSwgXHJcbiAgICAgICAgYXJyb3dDZW50ZXIpO1xyXG5cclxuICAgIFxyXG4gICAgLy9hZGQgZ3JvdXAgdG8gbWFpbiBncm91cFxyXG4gICAgbWFpbkdyb3VwLmFkZENoaWxkKGdyb3VwKTtcclxuICAgIGlmKGxpbmVUeXBlICE9PSBTSEFQRVMuRElWSURFUilcclxuICAgICAgbWFpbkdyb3VwLmFkZENoaWxkKGhlYWRTaGFwZSk7XHJcbiAgICBtYWluR3JvdXAuZGF0YS50eXBlID0gTElORTtcclxuICAgIG1haW5Hcm91cC5kYXRhLmxpbmVUeXBlID0gbGluZVR5cGU7XHJcblxyXG4gICAgcmV0dXJuIG1haW5Hcm91cDtcclxuICB9XHJcblxyXG4gIC8vYWRkIE9iamVjdC9JbnRlcmZhY2Ugc2hhcGVcclxuICBkcmF3T2JqZWN0U2hhcGUodHlwZSl7XHJcbiAgICAvL2NyZWF0ZXMgb2JqZWN0IHJlY3RhbmdsZVxyXG4gICAgY29uc3Qgc3RhcnRQb2ludCA9IG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtNTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yNSlcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IG5ldyBQYXRoLlJlY3RhbmdsZShzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSwgdGhpcy5kZWZhdWx0U2l6ZVswXSwgdGhpcy5kZWZhdWx0U2l6ZVswXS8yKTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChyZWN0YW5nbGUpO1xyXG5cclxuXHJcblxyXG4gICAgLy9jcmVhdGUgdGV4dHNoYXBlXHJcbiAgICBpZih0eXBlICE9PSBTSEFQRVMuU1FVQVJFKXtcclxuICAgICAgY29uc3QgdGV4dFNoYXBlU3RhcnRQb2ludCA9IG5ldyBQb2ludChzdGFydFBvaW50LngrMzAsIHN0YXJ0UG9pbnQueSszMCk7XHJcbiAgICAgIGNvbnN0IHRleHRTaGFwZSA9IHRoaXMuZHJhd1RleHRTaGFwZSh0ZXh0U2hhcGVTdGFydFBvaW50LCB0eXBlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vYWRkIFVzZWNhc2UvQWN0aXZpdHkgc2hhcGVcclxuICBkcmF3VXNlQ2FzZVNoYXBlKHR5cGUpe1xyXG4gICAgLy9kcmF3IGNpcmNsZVxyXG4gICAgbGV0IGNpcmNsZVBhdGggPSBuZXcgUGF0aC5DaXJjbGUodGhpcy5jZW50ZXJQb3NpdGlvbiwgMjUpO1xyXG4gICAgY2lyY2xlUGF0aC5zY2FsZSgyLDEuMik7XHJcbiAgICBcclxuICAgIC8vc2NhbGUgdG8gbWFrZSBpdCBhbiBvdmFsXHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoY2lyY2xlUGF0aClcclxuXHJcbiAgICBpZih0eXBlID09PSBTSEFQRVMuVVNFQ0FTRSl7XHJcbiAgICAgIC8vYWRkIFRleHRcclxuICAgICAgY29uc3QgdGV4dFNoYXBlID0gdGhpcy5kcmF3VGV4dFNoYXBlKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMjUsIHRoaXMuY2VudGVyUG9zaXRpb24ueSs1KSwgdHlwZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvL2FkZCBDb21wb25lbnQgc2hhcGVcclxuICBkcmF3Q29tcG9uZW50U2hhcGUoKXtcclxuICAgIC8vZHJhdyBtYWluIHJlY3RhbmdsZVxyXG4gICAgY29uc3Qgc3RhcnRQb2ludCA9IG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtNTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yNSlcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IG5ldyBQYXRoLlJlY3RhbmdsZShzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSwgdGhpcy5kZWZhdWx0U2l6ZVswXSsyMCwgdGhpcy5kZWZhdWx0U2l6ZVswXS00NSk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwocmVjdGFuZ2xlKTtcclxuXHJcbiAgICAvLyBkcmF3IHN1YiBwYXJ0IG9mIHRoZSBzaGFwZVxyXG4gICAgY29uc3Qgc3ViUmVjdCA9IG5ldyBQYXRoLlJlY3RhbmdsZShyZWN0YW5nbGUuYm91bmRzLnRvcFJpZ2h0LngtMjUsIHN0YXJ0UG9pbnQueSs2LCAyMCwgMjUpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHN1YlJlY3QpO1xyXG4gICAgc3ViUmVjdC5zdHJva2VXaWR0aCA9IDIvdGhpcy5zdHJva2VXaWR0aDtcclxuXHJcbiAgICAvL2RyYXcgdHdvIHN1YiByZWNcclxuICAgIGNvbnN0IHN1YlJlY3QxID0gbmV3IFBhdGguUmVjdGFuZ2xlKHJlY3RhbmdsZS5ib3VuZHMudG9wUmlnaHQueC0yOCwgc3RhcnRQb2ludC55KzksIDcsIDcpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHN1YlJlY3QxKTtcclxuICAgIHN1YlJlY3QxLnN0cm9rZVdpZHRoID0gMi90aGlzLnN0cm9rZVdpZHRoO1xyXG5cclxuICAgIGNvbnN0IHN1YlJlY3QyID0gbmV3IFBhdGguUmVjdGFuZ2xlKHJlY3RhbmdsZS5ib3VuZHMudG9wUmlnaHQueC0yOCwgc3RhcnRQb2ludC55KzIwLCA3LCA3KTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChzdWJSZWN0Mik7XHJcbiAgICBzdWJSZWN0Mi5zdHJva2VXaWR0aCA9IDIvdGhpcy5zdHJva2VXaWR0aDtcclxuXHJcbiAgICAvL2NyZWF0ZSBncm91cCBhbmQgYWRkIHNoYXBlc1xyXG4gICAgbGV0IGdyb3VwID0gIG5ldyBHcm91cCgpO1xyXG5cclxuICAgIGdyb3VwLmFkZENoaWxkKHJlY3RhbmdsZSk7XHJcbiAgICBncm91cC5hZGRDaGlsZChzdWJSZWN0KTtcclxuICAgIGdyb3VwLmFkZENoaWxkKHN1YlJlY3QxKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKHN1YlJlY3QyKTtcclxuXHJcbiAgICAvL2FkZCB0ZXh0IHRvIHNoYXBlXHJcbiAgICBjb25zdCB0ZXh0U2hhcGUgPSB0aGlzLmRyYXdUZXh0U2hhcGUobmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueC0yNSwgdGhpcy5jZW50ZXJQb3NpdGlvbi55KzgpLCBTSEFQRVMuQ09NUE9ORU5UKTtcclxuICB9XHJcblxyXG4gIC8vYWRkIG1vZHVsZSBzaGFwZVxyXG4gIGRyYXdNb2R1bGVTaGFwZSgpe1xyXG4gICAgXHJcbiAgICAvLyBkcmF3IG1haW4gcmVjdFxyXG4gICAgY29uc3QgcmVjdGFuZ2xlID0gbmV3IFBhdGguUmVjdGFuZ2xlKHRoaXMuY2VudGVyUG9zaXRpb24ueC01MCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTUwLCB0aGlzLmRlZmF1bHRTaXplWzBdKzIwLCB0aGlzLmRlZmF1bHRTaXplWzBdLTQwKTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChyZWN0YW5nbGUpO1xyXG5cclxuICAgIC8vZHJhdyB0d28gc3ViIHJlY1xyXG4gICAgY29uc3Qgc3ViUmVjdDEgPSBuZXcgUGF0aC5SZWN0YW5nbGUocmVjdGFuZ2xlLmJvdW5kcy50b3BMZWZ0LngtNywgcmVjdGFuZ2xlLmJvdW5kcy50b3BMZWZ0LnkrMTIsIDE1LCAxMik7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoc3ViUmVjdDEpO1xyXG5cclxuICAgIGNvbnN0IHN1YlJlY3QyID0gbmV3IFBhdGguUmVjdGFuZ2xlKHJlY3RhbmdsZS5ib3VuZHMudG9wTGVmdC54LTcsIHJlY3RhbmdsZS5ib3VuZHMudG9wTGVmdC55KzM1LCAxNSwgMTIpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHN1YlJlY3QyKTtcclxuXHJcbiAgICAvL2NyZWF0ZSBncm91cCBhbmQgYWRkIHNoYXBlc1xyXG4gICAgbGV0IGdyb3VwID0gIG5ldyBHcm91cCgpO1xyXG5cclxuICAgIGdyb3VwLmFkZENoaWxkKHJlY3RhbmdsZSk7XHJcbiAgICBncm91cC5hZGRDaGlsZChzdWJSZWN0MSk7XHJcbiAgICBncm91cC5hZGRDaGlsZChzdWJSZWN0Mik7XHJcblxyXG4gICAgLy9hZGQgdGV4dCB0byBzaGFwZVxyXG4gICAgY29uc3QgdGV4dFNoYXBlID0gdGhpcy5kcmF3VGV4dFNoYXBlKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0xNSksIFNIQVBFUy5NT0RVTEUpO1xyXG4gIH1cclxuICBcclxuXHJcbiAgLy9hZGQgYWN0aXZpdHkgc2hhcGVcclxuICBkcmF3QWN0aXZpdHlTaGFwZSgpe1xyXG4gICAgLy9jcmVhdGUgcm91bmRlZCBzaGFwZSByZWN0YW5nbGVcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUodGhpcy5jZW50ZXJQb3NpdGlvbi5zdWJ0cmFjdCg1MCksIG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngrNzAsIHRoaXMuY2VudGVyUG9zaXRpb24ueSkpO1xyXG4gICAgY29uc3QgcmFkaXVzID0gbmV3IFNpemUoMzAsIDMwKTtcclxuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aC5SZWN0YW5nbGUocmVjdGFuZ2xlLCByYWRpdXMpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHBhdGgpO1xyXG5cclxuICAgIFxyXG4gICAgLy9hZGQgdGV4dCB0byBzaGFwZVxyXG4gICAgY29uc3QgdGV4dFNoYXBlID0gdGhpcy5kcmF3VGV4dFNoYXBlKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yMCksIFNIQVBFUy5BQ1RJVklUWSk7XHJcbiAgfVxyXG5cclxuICAvL2FkZCBkZWNpc2lvbiBzaGFwZVxyXG4gIGRyYXdEZWNpc2lvblNoYXBlKCl7XHJcbiAgICAvL2NyZWF0ZSByZWN0YW5nbGVcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IG5ldyBQYXRoLlJlY3RhbmdsZSh0aGlzLmNlbnRlclBvc2l0aW9uLngtMjAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yMCwgdGhpcy5kZWZhdWx0U2l6ZVswXS8yLjUsIHRoaXMuZGVmYXVsdFNpemVbMF0vMi41KTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChyZWN0YW5nbGUpO1xyXG5cclxuICAgIC8vcm90YXRlXHJcbiAgICByZWN0YW5nbGUucm90YXRlKDQ1KTtcclxuICB9XHJcblxyXG4gIC8vb24gdG9vbCBjbGlja1xyXG4gIG9uVG9vbE1vdXNlRG93bihlKXtcclxuICAgIC8vdG9nZ2xlIGl0ZW0gc2VsZWN0ZWRcclxuICAgIHRoaXMuc2V0T25lSXRlbVNlbGVjdGVkKGUpO1xyXG5cclxuICAgIC8vcmV0dXJuIGlmIG5vIGN1cnJlbnRBY3RpdmVJdGVtXHJcbiAgICBpZighdGhpcy5jdXJyZW50QWN0aXZlSXRlbSkgcmV0dXJuO1xyXG5cclxuICAgIC8vY2xlYXJpbmcgY3VycmVudEFjdGl2ZUl0ZW0gZGF0YSB0byBmaXggdGhlIGlzc3VlIG9mIHVuaW50ZW5kZWQgbW92ZXNcclxuICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5zdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgaWYodGhpcy5jdXJyZW50QWN0aXZlSXRlbS5jb250YWlucyhlLnBvaW50KSl7XHJcbiAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5zdGF0ZSA9ICdtb3ZlJ1xyXG4gICAgfVxyXG4gICAgLy9zZXQgaXRlbXMgZGF0YSBiYXNlZCBvbiBpdGVtIG1vdXNlRG93biBwb2ludFxyXG4gICAgaWYodGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnR5cGUgIT09IExJTkUpe1xyXG4gICAgICBpZih0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmhpdFRlc3QoZS5wb2ludCwge2JvdW5kczogdHJ1ZSwgdG9sZXJhbmNlOiA1fSkpe1xyXG4gICAgICAgIC8vZ2V0IGJvdW5kcyBvZiB0aGUgc2hhcGVcclxuICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmJvdW5kcztcclxuXHJcblxyXG4gICAgICAgIC8vaXRyYXRpbmcgdG8gZmluZCB0aGUgZXhhY3QgYm91bmQgcG9pbnRcclxuICAgICAgICBmb3IobGV0W2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGJvdW5kc0lkZW50aWZpZXJPYmopKXtcclxuICAgICAgICAgIGlmKGJvdW5kc1t2YWx1ZV0uaXNDbG9zZShlLnBvaW50LCA1KSl7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wcG9zaXRlQm91bmQgPSBib3VuZHNbYm91bmRzSWRlbnRpZmllck9ialsocGFyc2VJbnQoa2V5KSArIDIpICUgNF1dO1xyXG4gICAgICAgICAgICAvL2dldCBvcHBvc2l0ZSBib3VuZCBwb2ludFxyXG4gICAgICAgICAgICBjb25zdCBvcHBvc2l0ZVBvaW50ID0gbmV3IFBvaW50KG9wcG9zaXRlQm91bmQueCxvcHBvc2l0ZUJvdW5kLnkpO1xyXG4gICAgICAgICAgICAvL2dldCBjdXJyZW50IGJvdW5kIHBvaW50XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludCA9IG5ldyBQb2ludChib3VuZHNbdmFsdWVdLngsIGJvdW5kc1t2YWx1ZV0ueSk7XHJcblxyXG4gICAgICAgICAgICAvL3NldCBzaGFwZSBkYXRhIHRvIGJlIHVzZWQgZm9yIHJlc2l6aW5nIGxhdGVyXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5zdGF0ZSA9ICdyZXNpemUnXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5mcm9tID0gb3Bwb3NpdGVQb2ludDtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnRvID0gY3VycmVudFBvaW50O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vb25seSBmb3Igc2hhcGVzIHdpdGggdHlwZSBMSU5FXHJcbiAgICAgIGNvbnN0IGhlYWRDaXJjbGVJdGVtID0gdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5maXJzdENoaWxkLmNoaWxkcmVuWzNdO1xyXG4gICAgICBpZihoZWFkQ2lyY2xlSXRlbS5jb250YWlucyhlLnBvaW50KSl7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnN0YXRlID0gJ3Jlc2l6ZSdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy9kcmF3IGFjdG9yIHNoYXBlXHJcbiAgZHJhd0FjdG9yU2hhcGUoKXtcclxuICAgIC8vZHJhdyBhY3RvciBoZWFkXHJcbiAgICBjb25zdCBoZWFkID0gbmV3IFBhdGguQ2lyY2xlKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngsIHRoaXMuY2VudGVyUG9zaXRpb24ueS01MCksIDcpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKGhlYWQpXHJcblxyXG4gICAgLy9kcmF3IGFjdG9yIGJvZHlcclxuICAgIGNvbnN0IGJvZHkgPSBuZXcgUGF0aC5MaW5lKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngsIHRoaXMuY2VudGVyUG9zaXRpb24ueS00MyksIG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0xMCkpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKGJvZHkpXHJcblxyXG4gICAgLy9kcmF3IGFjdG9yIGFybXNcclxuICAgIGNvbnN0IGFybXMgPSBuZXcgUGF0aC5MaW5lKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMjAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0zOCksIG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngrMjAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0zOCkpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKGFybXMpIFxyXG5cclxuICAgIC8vZHJhdyBmZWV0XHJcbiAgICBjb25zdCBsZWZ0RmVldCA9IG5ldyBQYXRoLkxpbmUobmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueC0yMCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55KzUpLCBuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LCB0aGlzLmNlbnRlclBvc2l0aW9uLnktMTApKTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChsZWZ0RmVldCkgXHJcblxyXG4gICAgY29uc3QgcmlnaHRGZWV0ID0gbmV3IFBhdGguTGluZShuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LCB0aGlzLmNlbnRlclBvc2l0aW9uLnktMTApLCBuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54KzIwLCB0aGlzLmNlbnRlclBvc2l0aW9uLnkrNSkpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHJpZ2h0RmVldCkgXHJcblxyXG4gICAgLy9hZGQgc2hhcGVzIHRvIGdyb3VwIHRvIG1ha2UgZnVsbCBhY3RvclxyXG4gICAgbGV0IGdyb3VwID0gIG5ldyBHcm91cCgpO1xyXG4gICAgZ3JvdXAuYWRkQ2hpbGQoaGVhZCk7XHJcbiAgICBncm91cC5hZGRDaGlsZChib2R5KTtcclxuICAgIGdyb3VwLmFkZENoaWxkKGFybXMpO1xyXG4gICAgZ3JvdXAuYWRkQ2hpbGQobGVmdEZlZXQpO1xyXG4gICAgZ3JvdXAuYWRkQ2hpbGQocmlnaHRGZWV0KTtcclxuICB9XHJcblxyXG5cclxuICAvL2l0ZW0gZHJhZyBsaXN0ZW5lclxyXG4gIG9uVG9vbERyYWcoZSl7XHJcbiAgICAvLyBkZWJ1Z2dlclxyXG4gICAgaWYodGhpcy5jdXJyZW50QWN0aXZlSXRlbSA9PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgaWYodGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnN0YXRlID09PSAnbW92ZScpe1xyXG4gICAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLnBvc2l0aW9uID0gZS5wb2ludDsgIFxyXG4gICAgfSBlbHNlXHJcbiAgICBpZih0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEuc3RhdGUgPT09ICdyZXNpemUnKXtcclxuICAgICAgaWYodGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnR5cGUgPT09IExJTkUpe1xyXG4gICAgICAgIC8vc2hhcGVzIHdpdGggdHlwZSBsaW5lLCByZS1yZW5kZXJpbmcgbGluZSBvbiBlYWNoIHVzZXIgbW92ZVxyXG4gICAgICAgIGNvbnN0IGxpbmVTdGFydFBvaW50ID0gdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5maXJzdENoaWxkLmZpcnN0Q2hpbGQuc2VnbWVudHNbMF0ucG9pbnQ7XHJcbiAgICAgICAgY29uc3QgbGluZVR5cGUgPSB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEubGluZVR5cGU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtID0gIHRoaXMuZHJhd0xpbmVTaGFwZShsaW5lU3RhcnRQb2ludCwgZS5wb2ludCwgbGluZVR5cGUpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5zdGF0ZSA9ICdyZXNpemUnXHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgIC8vc2hhcGVzIG90aGVyIHRoYW4gbGluZSwgdXBkYXRpbmcgdGhlIGJvdW5kc1xyXG4gICAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uYm91bmRzID0gbmV3IFJlY3RhbmdsZShcclxuICAgICAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5mcm9tLGUucG9pbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uYm91bmRzLnNlbGVjdGVkID0gdHJ1ZVxyXG4gICAgfSBcclxuICB9XHJcblxyXG4gIC8vb24gdG9vbCBkb3VibGUgY2xpY2tcclxuICBvblRvb2xEb3VibGVDbGljayhlKXtcclxuICAgIGlmKGUuY3RybEtleSkge1xyXG4gICAgICB0aGlzLmRyYXdUZXh0U2hhcGUoe3g6IGUubGF5ZXJYLCB5OiBlLmxheWVyWX0sIFwiQWRkIFRleHRcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBcclxuXHJcbiAgLy90b2dnbGUgaXRlbSBzZWxlY3RlaW9uIGFuZCBzYXZpbmcgY3VycmVudEFjdGl2ZUl0ZW1cclxuICBzZXRPbmVJdGVtU2VsZWN0ZWQoZSl7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGUucG9pbnQ7XHJcbiAgICBsZXQgY2xpY2tlZEl0ZW1zID0gW11cclxuICAgIHRoaXMucHJvamVjdC5hY3RpdmVMYXllci5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkPT57XHJcbiAgICAgIGlmKGNoaWxkLmNvbnRhaW5zKHBvc2l0aW9uKSl7XHJcbiAgICAgICAgY2xpY2tlZEl0ZW1zLnB1c2goY2hpbGQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoaWxkLmJvdW5kcy5zZWxlY3RlZCA9ICBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIC8vcmV0dXJuIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWRcclxuICAgIGlmKGNsaWNrZWRJdGVtcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAvL3NlbGVjdCB0aGUgY2xpY2tlZCBpdGVtXHJcbiAgICBsZXQgbGF0ZXN0SXRlbSA9IGNsaWNrZWRJdGVtc1swXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xpY2tlZEl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmKGxhdGVzdEl0ZW0uaWQgPCBjbGlja2VkSXRlbXNbaV0uaWQpe1xyXG4gICAgICAgIGxhdGVzdEl0ZW0gPSBjbGlja2VkSXRlbXNbaV07XHJcbiAgICAgIH1lbHNlXHJcbiAgICAgIHtcclxuICAgICAgICBjbGlja2VkSXRlbXNbaV0uYm91bmRzLnNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0gPSBsYXRlc3RJdGVtO1xyXG4gICAgbGF0ZXN0SXRlbS5ib3VuZHMuc2VsZWN0ZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIGtleWJvYXJkIGludHJhY3Rpb24gdG8gbW92ZSBzaGFwZXNcclxuICBvblRvb2xLZXlEb3duKGUpe1xyXG4gICAgaWYoIXRoaXMuY3VycmVudEFjdGl2ZUl0ZW0pIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0ucG9zaXRpb247XHJcbiAgICBjb25zdCBzdGVwID0gNTtcclxuICAgIHN3aXRjaChlLmtleSl7XHJcbiAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgIHBvc2l0aW9uLnggLT0gc3RlcDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgIHBvc2l0aW9uLnggKz0gc3RlcDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndXAnOlxyXG4gICAgICAgIHBvc2l0aW9uLnkgLT0gc3RlcDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnZG93bic6XHJcbiAgICAgICAgcG9zaXRpb24ueSArPSBzdGVwO1xyXG4gICAgICAgIGJyZWFrOyBcclxuICAgICAgY2FzZSAnZGVsZXRlJzpcclxuICAgICAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLnJlbW92ZSgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZ2VuZXJhbCBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gcmV0dXJuIGNlbnRlciBwb3NpdGlvbiBvZiBjYW52YXNcclxuICBnZXRDZW50ZXJQb3NpdGlvbigpe1xyXG4gICAgcmV0dXJuIG5ldyBQb2ludCh7eDogdGhpcy5jYW52YXNFbGVtZW50LmNsaWVudFdpZHRoLzIsIHk6dGhpcy5jYW52YXNFbGVtZW50LmNsaWVudEhlaWdodC8yfSk7XHJcbiAgfVxyXG5cclxuICAvLyBoZWxwZXIgdG8gc2V0IHN0cm9rZSBhbmQgZmlsbFxyXG4gIHNldFN0cm9rZUFuZEZpbGwoaXRlbSl7XHJcbiAgICBpdGVtLnN0cm9rZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aDtcclxuICAgIGl0ZW0uc3Ryb2tlQ29sb3IgPSB0aGlzLnN0cm9rZUNvbG9yO1xyXG4gICAgaXRlbS5maWxsQ29sb3IgPSB0aGlzLmZpbGxDb2xvcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE15Q2FudmFzO1xyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbmZve1xyXG4gICAgY29uc3RydWN0b3IodGl0bGUsIHRleHQpe1xyXG4gICAgICAgIHRoaXMudGl0bGUgPSAgdGl0bGU7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuXHJcbiAgICAgICAgdGhpcy5zaG93ID0gdGhpcy5zaG93LmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzaG93KCl7XHJcbiAgICAgICAgLy9zZXQgdXAgaW5mbyB2aWV3XHJcbiAgICAgICAgY29uc3QgaW5mb1NlY3Rpb25Db250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luZm8tc2lkZWJhcicpO1xyXG4gICAgICAgIGNvbnN0IHRvcEJhckNvbmF0aW5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB0b3BCYXJDb25hdGluZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAndG9wLWJhci1jb250YWluZXInKTtcclxuICAgICAgICBjb25zdCB0aXRsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpO1xyXG4gICAgICAgIHRpdGxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2luZm8tdGl0bGUnKVxyXG4gICAgICAgIHRpdGxlRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLnRpdGxlO1xyXG4gICAgICAgIGNvbnN0IGNsb3NlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICBjbG9zZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdpbmZvLWNsb3NlJyk7XHJcbiAgICAgICAgY2xvc2VFbGVtZW50LmlubmVySFRNTCA9ICdYJztcclxuICAgICAgICB0b3BCYXJDb25hdGluZXJFbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlRWxlbWVudCk7XHJcbiAgICAgICAgdG9wQmFyQ29uYXRpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChjbG9zZUVsZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IGJvZHlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgYm9keUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdpbmZvLWJvZHknKTtcclxuICAgICAgICBib2R5RWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLnRleHQ7XHJcbiAgICAgICAgaW5mb1NlY3Rpb25Db250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHRvcEJhckNvbmF0aW5lckVsZW1lbnQpO1xyXG4gICAgICAgIGluZm9TZWN0aW9uQ29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChib2R5RWxlbWVudCk7XHJcblxyXG5cclxuICAgICAgICAvL3NldCB1cCBsaXN0ZW5lclxyXG4gICAgICAgIGNsb3NlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgaW5mb1NlY3Rpb25Db250YWluZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgY29uc3QgbWVzc2FnZSA9IFwiPHA+IC0gQ2xpY2sgYW55IHNoYXBlIGZyb20gdGhlIFVNTCBzZWN0aW9uIHRvIGFkZCBpdCB0byB0aGUgY2FudmFzLjxici8+IDwvcD5cIitcclxuXCI8cD4gLSBUaGVuIHNlbGVjdCBhIHNoYXBlIGFuZCBkcmFnIGl0IGZvcm0gYW55IGNvcm5lciB0byByZXNpemUuPGJyLz4gPC9wPlwiK1xyXG5cIjxwPiAtIFlvdSBjYW4gYWxzbyBtb3ZlIGEgc2hhcGUgd2l0aCBhcnJvdyBrZXlzIGZvcm0gdGhlIGtleWJvYXJkLjxici8+IDwvcD5cIitcclxuXCI8cD4gLSBTZWxlY3QgYW55IGxpbmUgc2hhcGUgYW5kIHVzZSBtaWRkbGUgY2lyY2xlIHRvIG1vdmUgdGhlIGxpbmUgYXJvdW5kIGFuZCB0aGUgaGVhZCBjaXJjbGUgdG8gcm90YXRlIGl0IGF0IGRpZmZlcmVudCBhbmdsZXMuPGJyLz4gPC9wPlwiK1xyXG5cIjxwPiAtIFNlbGVjdCBhIHNoYXBlIGFuZCBwcmVzcyAnZGVsZXRlJyBrZXkgdG8gZGVsZXRlIHRoZSBzaGFwZS48YnIvPiA8L3A+XCIrXHJcblwiPHA+IC0gUHJlc3MgJ0N0cmwgKyBNb3VzZSBEb3VibGUgQ2xpY2snIHRvIGFkZCB0ZXh0Ljxici8+IDwvcD5cIitcclxuXCI8cD4gLSBVc2UgJ01vdmUtVG8tRnJvbnQnIGFuZCAnU2VuZC1Uby1CYWNrJyBpY29uIHRvIG1vdmUgdGhlIHNoYXBlcy48YnIvPiA8L3A+XCIrXHJcblwiPHA+IC0gRm9yIHNhdmluZyBhbmQgb3BlbmluZyBleGlzaXRpbmcgcHJvamVjdCB1dGlsaXplIHRoZSBtZW51IGJhci48YnIvPiA8L3A+XCI7IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWwge1xyXG4gICAgY29uc3RydWN0b3IodGV4dENhbGxiYWNrKXtcclxuICAgICAgICB0aGlzLnRleHRDYWxsYmFjayA9IHRleHRDYWxsYmFjaztcclxuICAgICAgICB0aGlzLnNob3cgPSB0aGlzLnNob3cuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93KCl7XHJcbiAgICAgICAgY29uc3QgYm9keUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm9keScpO1xyXG4gICAgICAgIGNvbnN0IG1vZGFsTWFpbkNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBtb2RhbE1haW5Db250YWluZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdtb2RhbC1tYWluLWNvbnRhaW5lcicpXHJcbiAgICAgICAgY29uc3QgbW9kYWxDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgbW9kYWxDb250YWluZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdtb2RhbC1jb250YWluZXInKVxyXG4gICAgICAgIGNvbnN0IG1vZGFsVGl0bGVDb25haW5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBtb2RhbFRpdGxlQ29uYWluZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdtb2RhbC10aXRsZS1jb250YWluZXInKTtcclxuICAgICAgICBjb25zdCBtb2RhbFRpdGxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gxJyk7XHJcbiAgICAgICAgbW9kYWxUaXRsZUVsZW1lbnQuaW5uZXJIVE1MID0gXCJBZGQgVGV4dFwiXHJcbiAgICAgICAgbW9kYWxUaXRsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsJ21vZGFsLXRpdGxlJyk7XHJcbiAgICAgICAgY29uc3QgbW9kYWxDbG9zZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgbW9kYWxDbG9zZUVsZW1lbnQuaW5uZXJIVE1MID0gXCJYXCJcclxuICAgICAgICBtb2RhbENsb3NlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywnbW9kYWwtY2xvc2UnKTtcclxuICAgICAgICBjb25zdCBtb2RhbElucHV0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICAgICAgbW9kYWxJbnB1dEVsZW1lbnQucGxhY2Vob2xkZXIgPSBcIkFkZCB0ZXh0IGhlcmVcIlxyXG4gICAgICAgIG1vZGFsSW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdtb2RhbC1pbnB1dCcpO1xyXG4gICAgICAgIGNvbnN0IG1vZGFsU3VibWl0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gICAgICAgIG1vZGFsU3VibWl0RWxlbWVudC5pbm5lckhUTUwgPSBcIlN1Ym1pdFwiXHJcbiAgICAgICAgbW9kYWxTdWJtaXRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdtb2RhbC1zdWJtaXQnKTtcclxuXHJcbiAgICAgICAgbW9kYWxUaXRsZUNvbmFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChtb2RhbFRpdGxlRWxlbWVudCk7XHJcbiAgICAgICAgbW9kYWxUaXRsZUNvbmFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChtb2RhbENsb3NlRWxlbWVudCk7XHJcbiAgICAgICAgbW9kYWxDb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKG1vZGFsVGl0bGVDb25haW5lckVsZW1lbnQpO1xyXG4gICAgICAgIG1vZGFsQ29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChtb2RhbElucHV0RWxlbWVudCk7XHJcbiAgICAgICAgbW9kYWxDb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKG1vZGFsU3VibWl0RWxlbWVudCk7XHJcbiAgICAgICAgbW9kYWxNYWluQ29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChtb2RhbENvbnRhaW5lckVsZW1lbnQpO1xyXG4gICAgICAgIGJvZHlFbGVtZW50LmFwcGVuZENoaWxkKG1vZGFsTWFpbkNvbnRhaW5lckVsZW1lbnQpO1xyXG5cclxuICAgICAgICAvL2FkZHMgbGlzdGVuZXJzXHJcblxyXG4gICAgICAgIC8vY2xvc2UgbW9kYWwgb24gb3V0c2lkZSBjbGlja1xyXG4gICAgICAgIG1vZGFsTWFpbkNvbnRhaW5lckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSk9PntcclxuICAgICAgICAgICAgbW9kYWxNYWluQ29udGFpbmVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywnaGlkZGRlbicpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL3N0b3BzIG1vZGFsIGZyb20gY2xvc2luZyBpZiBjbGlja2VkIGluc2lkZSBtb2RhbFxyXG4gICAgICAgIG1vZGFsQ29udGFpbmVyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsKGUpPT57XHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvL2Nsb3NlcyBtb2RhbCBvbiBjbGlja1xyXG4gICAgICAgIG1vZGFsQ2xvc2VFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpPT57XHJcbiAgICAgICAgICAgIG1vZGFsTWFpbkNvbnRhaW5lckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsJ2hpZGRkZW4nKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy9nZXRzIHRleHQgZm9ybSBpbnB1dCBvbiBzdWJtaXQgYW5kIHNlbmRpbmcgdG8gY2FsbGJhY2tcclxuICAgICAgICBtb2RhbFN1Ym1pdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLChlKT0+e1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dFRleHQgPSBtb2RhbElucHV0RWxlbWVudC52YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0Q2FsbGJhY2soaW5wdXRUZXh0KTtcclxuICAgICAgICAgICAgbW9kYWxNYWluQ29udGFpbmVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywnaGlkZGRlbicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lkZWJhcntcclxuICAgIGNvbnN0cnVjdG9yKGNhdGVnb3J5T2JqLCBzaWRlYmFyRWxlbWVudCwgb25TaGFwZUNsaWNrQ2FsbGJhY2spe1xyXG4gICAgICAgIHRoaXMuY2F0ZWdvcnlUaXRsZSA9IGNhdGVnb3J5T2JqLmNhdGVnb3J5TmFtZTtcclxuICAgICAgICB0aGlzLnNoYXBlcyA9IGNhdGVnb3J5T2JqLnNoYXBlcztcclxuICAgICAgICB0aGlzLnNpZGViYXJFbGVtZW50ID0gc2lkZWJhckVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5vblNoYXBlQ2xpY2tDYWxsYmFjayA9IG9uU2hhcGVDbGlja0NhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuZHJhdygpO1xyXG4gICAgICAgIHRoaXMuc2hhcGVDbGlja0xpc3RlbmVyID0gdGhpcy5zaGFwZUNsaWNrTGlzdGVuZXIuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBzaGFwZUNsaWNrTGlzdGVuZXIoc2hhcGVOYW1lKXtcclxuICAgICAgICByZXR1cm4gZT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9uU2hhcGVDbGlja0NhbGxiYWNrKHNoYXBlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXcoKXtcclxuICAgICAgICAvL2FkZHMgY2F0ZWdvcnkgdGl0bGUgaW4gc2lkZWJhclxyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5VGl0bGVFbGVtZW50ICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gxJyk7XHJcbiAgICAgICAgY2F0ZWdvcnlUaXRsZUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5jYXRlZ29yeVRpdGxlO1xyXG4gICAgICAgIGNhdGVnb3J5VGl0bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2lkZWJhci1jYXRlZ29yeS10aXRsZScpO1xyXG4gICAgICAgIHRoaXMuc2lkZWJhckVsZW1lbnQuYXBwZW5kQ2hpbGQoY2F0ZWdvcnlUaXRsZUVsZW1lbnQpO1xyXG5cclxuICAgICAgICAvL2FkZHMgY2F0ZWdvcnkgc2hhcGVzIGluIHNpZGViYXJcclxuICAgICAgICBjb25zdCBzaGFwZXNVbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xyXG4gICAgICAgIHNoYXBlc1VsRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgXCJzaWRlYmFyLWNhdGVnb3J5LXNoYXBlcy11bFwiKVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLnNoYXBlc1tpXTtcclxuICAgICAgICAgICAgY29uc3Qgc2hhcGVMaUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xyXG4gICAgICAgICAgICBzaGFwZUxpRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgXCJzaWRlYmFyLWNhdGVnb3J5LXNoYXBlcy1saVwiKVxyXG4gICAgICAgICAgICBzaGFwZUxpRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5zaGFwZUNsaWNrTGlzdGVuZXIoc2hhcGUubmFtZSkpXHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlSW1hZ2VFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgICAgICAgICAgIHNoYXBlSW1hZ2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLFwic2lkZWJhci1jYXRlZ29yeS1pbWFnZXNcIilcclxuICAgICAgICAgICAgc2hhcGVJbWFnZUVsZW1lbnQuc3JjID0gc2hhcGUudXJpO1xyXG4gICAgICAgICAgICBzaGFwZUxpRWxlbWVudC5hcHBlbmRDaGlsZChzaGFwZUltYWdlRWxlbWVudCk7XHJcbiAgICAgICAgICAgIHNoYXBlc1VsRWxlbWVudC5hcHBlbmRDaGlsZChzaGFwZUxpRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2lkZWJhckVsZW1lbnQuYXBwZW5kQ2hpbGQoc2hhcGVzVWxFbGVtZW50KTtcclxuXHJcbiAgICB9XHJcbn0iLCJleHBvcnQgY29uc3QgU0hBUEVTID0ge1xyXG4gICAgQ0xBU1M6ICdDbGFzcycsXHJcbiAgICBTUVVBUkU6ICdTcXVhcmUnLFxyXG4gICAgRElWSURFUjogJ0RpdmlkZXInLFxyXG4gICAgQ0lSQ0xFOiAnQ2lyY2xlJyxcclxuICAgIE9CSkVDVDogJ09iamVjdCcsXHJcbiAgICBJTlRFUkZBQ0U6ICdJbnRlcmZhY2UnLFxyXG4gICAgQUNUT1I6ICdBY3RvcicsXHJcbiAgICBBR0dSRUdBVElPTjogJ0FnZ3JlZ2F0aW9uJyxcclxuICAgIENPTVBPU0lUSU9OOiAnQ29tcG9zaXRpb24nLFxyXG4gICAgQVNTT0NJQVRJT046ICdBc3NvY2lhdGlvbicsXHJcbiAgICBDT01QT05FTlQ6ICdDb21wb25lbnQnLFxyXG4gICAgTU9EVUxFOiAnTW9kdWxlJyxcclxuICAgIFRJVExFOiAnVGl0bGUnLFxyXG4gICAgQUNUSVZJVFk6ICdBY3Rpdml0eScsXHJcbiAgICBVU0VDQVNFOiAnVXNlIENhc2UnLFxyXG4gICAgREVDSVNJT046ICdEZWNpc2lvbidcclxufSIsImltcG9ydCB7IFNIQVBFUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xyXG5cclxuY29uc3Qgc2lkZWJhckRhdGEgPSAgW1xyXG4ge1xyXG4gICAgIGNhdGVnb3J5TmFtZTogXCJVTUxcIixcclxuICAgICBzaGFwZXM6W1xyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgICBuYW1lOiBTSEFQRVMuT0JKRUNULFxyXG4gICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL29iamVjdC5zdmcnXHJcbiAgICAgICAgIH0sXHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLklOVEVSRkFDRSxcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2ludGVyZmFjZS5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5DTEFTUyxcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2NsYXNzLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLkRJVklERVIsXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9kaXZpZGVyLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLlRJVExFLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvdGl0bGUuc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuQ09NUE9ORU5ULFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvY29tcG9uZW50LnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLk1PRFVMRSxcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL21vZHVsZS5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5BQ1RPUixcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2FjdG9yLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLlVTRUNBU0UsXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy91c2VyY2FzZS5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5BQ1RJVklUWSxcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2FjdGl2aXR5LnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLkRFQ0lTSU9OLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvZGVjaXNpb24uc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuQUdHUkVHQVRJT04sXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9hZ2dyZWdhdGlvbi5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5DT01QT1NJVElPTixcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2NvbXBvc2l0aW9uLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLkFTU09DSUFUSU9OLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvYXNzb2NpYXRpb24uc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuQ0lSQ0xFLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvY2lyY2xlLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLlNRVUFSRSxcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL3NxdWFyZS5zdmcnXHJcbiAgICAgICAgfVxyXG4gICAgIF1cclxuIH0gICBcclxuXVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2lkZWJhckRhdGE7IiwiZXhwb3J0IGZ1bmN0aW9uIGdldEFuZ2xlRGVnKGV4LGV5LGN4LGN5KSB7XHJcbiAgdmFyIGR5ID0gZXkgLSBjeTtcclxuICB2YXIgZHggPSBleCAtIGN4O1xyXG4gIHZhciB0aGV0YSA9IE1hdGguYXRhbjIoZHksIGR4KTtcclxuICB0aGV0YSAqPSAxODAgLyBNYXRoLlBJOyBcclxuICByZXR1cm4gdGhldGE7XHJcbn0iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9