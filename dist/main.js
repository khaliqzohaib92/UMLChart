/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/acorn/dist/acorn.mjs":
/*!*******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.mjs ***!
  \*******************************************/
/*! exports provided: Node, Parser, Position, SourceLocation, TokContext, Token, TokenType, defaultOptions, getLineInfo, isIdentifierChar, isIdentifierStart, isNewLine, keywordTypes, lineBreak, lineBreakG, nonASCIIwhitespace, parse, parseExpressionAt, tokContexts, tokTypes, tokenizer, version */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SourceLocation", function() { return SourceLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokContext", function() { return TokContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOptions", function() { return defaultOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineInfo", function() { return getLineInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierChar", function() { return isIdentifierChar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierStart", function() { return isIdentifierStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNewLine", function() { return isNewLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keywordTypes", function() { return keywords$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreak", function() { return lineBreak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreakG", function() { return lineBreakG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonASCIIwhitespace", function() { return nonASCIIwhitespace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseExpressionAt", function() { return parseExpressionAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokContexts", function() { return types$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokTypes", function() { return types; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenizer", function() { return tokenizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 9.
  ecmaVersion: 9,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
pp.strictDirective = function(start) {
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") { return true }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // '['
  if (context) { return false }

  if (nextCh === 123) { return true } // '{'
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (this.options.ecmaVersion > 10 && starttype === types._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40) // '('
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope, node) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (!this.eat(types.braceR)) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  } else if (init.type === "AssignmentPattern") {
    this.raise(init.start, "Invalid left-hand side in for-loop");
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      }
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  this.strict = oldStrict;
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassElement = function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
      key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    method.kind = "constructor";
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, "getter should have no params"); }
  if (method.kind === "set" && method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && method.value.params[0].type === "RestElement")
    { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, "MethodDefinition")
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
    this.expectContextual("from");
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseIdent(true);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    this.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types.comma); }
    if (allowEmpty && this.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (bindingType === BIND_LEXICAL && expr.name === "let")
      { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, "Argument name clash"); }
      checkClashes[expr.name] = true;
    }
    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    break

  case "MemberExpression":
    if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1)
      {
    var prop = list[i];

    this.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(noIn) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldShorthandAssign = refDestructuringErrors.shorthandAssign;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
    if (element === base || element.type === "ArrowFunctionExpression") { return element }
    base = element;
  }
};

pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
  if (computed || this.eat(types.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
    node.computed = !!computed;
    if (computed) { this.expect(types.bracketR); }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== "Import", false, refDestructuringErrors);
    if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (node$1.callee.type === "Import") {
      if (node$1.arguments.length !== 1) {
        this.raise(node$1.start, "import() requires exactly one argument");
      }

      var importArg = node$1.arguments[0];
      if (importArg && importArg.type === "SpreadElement") {
        this.raise(importArg.start, "... is not allowed in import()");
      }
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  case types._import:
    if (this.options.ecmaVersion > 10) {
      return this.parseDynamicImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
};

pp$3.parseDynamicImport = function() {
  var node = this.startNode();
  this.next();
  if (this.type !== types.parenL) {
    this.unexpected();
  }
  return this.finishNode(node, "Import")
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types.parenR) {
      first ? first = false : this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target" || containsEsc)
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
    if (!this.inNonArrowFunction())
      { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.options.ecmaVersion > 10 && node.callee.type === "Import") {
    this.raise(node.callee.start, "Cannot use new with import(...)");
  }
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== "Import", false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types.comma && this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();

  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types.comma)
      { elt = null; }
    else if (this.type === types.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$5.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$5.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$5.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$5.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$5.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$5.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$5.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues
};

var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
buildUnicodeData(9);
buildUnicodeData(10);
buildUnicodeData(11);

var pp$8 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i), next;
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current () {
  return this.at(this.pos)
};

RegExpValidationState.prototype.lookahead = function lookahead () {
  return this.at(this.nextIndex(this.pos))
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.current() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString(ch) {
  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$8.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$8.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$8.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$8.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$8.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$8.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$8.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$8.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
pp$8.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>
pp$8.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$8.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$8.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$8.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$8.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$8.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &&
      this.regexp_eatUnicodePropertyValueExpression(state) &&
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise("Invalid property value"); }
};
pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
    { state.raise("Invalid property name"); }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$8.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw "unterminated regular expression" error before.
    state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$8.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$8.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$8.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$8.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$8.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$8.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$9 = Parser.prototype;

// Move to the next token

pp$9.next = function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$9.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$9[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$9.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$9.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$9.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$9.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$9.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // '/'
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // '*'
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$9.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$9.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$9.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$9.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$9.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$9.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$9.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$9.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
};

pp$9.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$9.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$9.readInt = function(radix, len) {
  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);
    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

pp$9.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$9.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var str$1 = this.input.slice(start, this.pos);
    var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val$1)
  }
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$9.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString$1(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$9.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$9.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$9.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types.template, out)
    }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$9.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case "\\":
      ++this.pos;
      break

    case "$":
      if (this.input[this.pos + 1] !== "{") {
        break
      }
    // falls through

    case "`":
      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$9.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString$1(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$9.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$9.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString$1(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$9.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.

var version = "6.4.0";

Parser.acorn = {
  Parser: Parser,
  version: version,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types,
  keywordTypes: keywords$1,
  TokContext: TokContext,
  tokContexts: types$1,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  Token: Token,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
};

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return Parser.parse(input, options)
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}




/***/ }),

/***/ "./node_modules/paper/dist/paper-full.js":
/*!***********************************************!*\
  !*** ./node_modules/paper/dist/paper-full.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Paper.js v0.12.11 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jürg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Fri Jun 19 19:14:33 2020 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jürg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */
var paper = function (self, undefined) {
  self = self || __webpack_require__(/*! ./node/self.js */ 0);
  var window = self.window,
      document = self.document;
  var Base = new function () {
    var hidden = /^(statics|enumerable|beans|preserve)$/,
        array = [],
        slice = array.slice,
        create = Object.create,
        describe = Object.getOwnPropertyDescriptor,
        define = Object.defineProperty,
        forEach = array.forEach || function (iter, bind) {
      for (var i = 0, l = this.length; i < l; i++) {
        iter.call(bind, this[i], i, this);
      }
    },
        forIn = function (iter, bind) {
      for (var i in this) {
        if (this.hasOwnProperty(i)) iter.call(bind, this[i], i, this);
      }
    },
        set = Object.assign || function (dst) {
      for (var i = 1, l = arguments.length; i < l; i++) {
        var src = arguments[i];

        for (var key in src) {
          if (src.hasOwnProperty(key)) dst[key] = src[key];
        }
      }

      return dst;
    },
        each = function (obj, iter, bind) {
      if (obj) {
        var desc = describe(obj, 'length');
        (desc && typeof desc.value === 'number' ? forEach : forIn).call(obj, iter, bind = bind || obj);
      }

      return bind;
    };

    function inject(dest, src, enumerable, beans, preserve) {
      var beansNames = {};

      function field(name, val) {
        val = val || (val = describe(src, name)) && (val.get ? val : val.value);
        if (typeof val === 'string' && val[0] === '#') val = dest[val.substring(1)] || val;
        var isFunc = typeof val === 'function',
            res = val,
            prev = preserve || isFunc && !val.base ? val && val.get ? name in dest : dest[name] : null,
            bean;

        if (!preserve || !prev) {
          if (isFunc && prev) val.base = prev;
          if (isFunc && beans !== false && (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/))) beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];

          if (!res || isFunc || !res.get || typeof res.get !== 'function' || !Base.isPlainObject(res)) {
            res = {
              value: res,
              writable: true
            };
          }

          if ((describe(dest, name) || {
            configurable: true
          }).configurable) {
            res.configurable = true;
            res.enumerable = enumerable != null ? enumerable : !bean;
          }

          define(dest, name, res);
        }
      }

      if (src) {
        for (var name in src) {
          if (src.hasOwnProperty(name) && !hidden.test(name)) field(name);
        }

        for (var name in beansNames) {
          var part = beansNames[name],
              set = dest['set' + part],
              get = dest['get' + part] || set && dest['is' + part];
          if (get && (beans === true || get.length === 0)) field(name, {
            get: get,
            set: set
          });
        }
      }

      return dest;
    }

    function Base() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        var src = arguments[i];
        if (src) set(this, src);
      }

      return this;
    }

    return inject(Base, {
      inject: function (src) {
        if (src) {
          var statics = src.statics === true ? src : src.statics,
              beans = src.beans,
              preserve = src.preserve;
          if (statics !== src) inject(this.prototype, src, src.enumerable, beans, preserve);
          inject(this, statics, null, beans, preserve);
        }

        for (var i = 1, l = arguments.length; i < l; i++) this.inject(arguments[i]);

        return this;
      },
      extend: function () {
        var base = this,
            ctor,
            proto;

        for (var i = 0, obj, l = arguments.length; i < l && !(ctor && proto); i++) {
          obj = arguments[i];
          ctor = ctor || obj.initialize;
          proto = proto || obj.prototype;
        }

        ctor = ctor || function () {
          base.apply(this, arguments);
        };

        proto = ctor.prototype = proto || create(this.prototype);
        define(proto, 'constructor', {
          value: ctor,
          writable: true,
          configurable: true
        });
        inject(ctor, this);
        if (arguments.length) this.inject.apply(ctor, arguments);
        ctor.base = base;
        return ctor;
      }
    }).inject({
      enumerable: false,
      initialize: Base,
      set: Base,
      inject: function () {
        for (var i = 0, l = arguments.length; i < l; i++) {
          var src = arguments[i];

          if (src) {
            inject(this, src, src.enumerable, src.beans, src.preserve);
          }
        }

        return this;
      },
      extend: function () {
        var res = create(this);
        return res.inject.apply(res, arguments);
      },
      each: function (iter, bind) {
        return each(this, iter, bind);
      },
      clone: function () {
        return new this.constructor(this);
      },
      statics: {
        set: set,
        each: each,
        create: create,
        define: define,
        describe: describe,
        clone: function (obj) {
          return set(new obj.constructor(), obj);
        },
        isPlainObject: function (obj) {
          var ctor = obj != null && obj.constructor;
          return ctor && (ctor === Object || ctor === Base || ctor.name === 'Object');
        },
        pick: function (a, b) {
          return a !== undefined ? a : b;
        },
        slice: function (list, begin, end) {
          return slice.call(list, begin, end);
        }
      }
    });
  }();
  if (true) module.exports = Base;
  Base.inject({
    enumerable: false,
    toString: function () {
      return this._id != null ? (this._class || 'Object') + (this._name ? " '" + this._name + "'" : ' @' + this._id) : '{ ' + Base.each(this, function (value, key) {
        if (!/^_/.test(key)) {
          var type = typeof value;
          this.push(key + ': ' + (type === 'number' ? Formatter.instance.number(value) : type === 'string' ? "'" + value + "'" : value));
        }
      }, []).join(', ') + ' }';
    },
    getClassName: function () {
      return this._class || '';
    },
    importJSON: function (json) {
      return Base.importJSON(json, this);
    },
    exportJSON: function (options) {
      return Base.exportJSON(this, options);
    },
    toJSON: function () {
      return Base.serialize(this);
    },
    set: function (props, exclude) {
      if (props) Base.filter(this, props, exclude, this._prioritize);
      return this;
    }
  }, {
    beans: false,
    statics: {
      exports: {},
      extend: function extend() {
        var res = extend.base.apply(this, arguments),
            name = res.prototype._class;
        if (name && !Base.exports[name]) Base.exports[name] = res;
        return res;
      },
      equals: function (obj1, obj2) {
        if (obj1 === obj2) return true;
        if (obj1 && obj1.equals) return obj1.equals(obj2);
        if (obj2 && obj2.equals) return obj2.equals(obj1);

        if (obj1 && obj2 && typeof obj1 === 'object' && typeof obj2 === 'object') {
          if (Array.isArray(obj1) && Array.isArray(obj2)) {
            var length = obj1.length;
            if (length !== obj2.length) return false;

            while (length--) {
              if (!Base.equals(obj1[length], obj2[length])) return false;
            }
          } else {
            var keys = Object.keys(obj1),
                length = keys.length;
            if (length !== Object.keys(obj2).length) return false;

            while (length--) {
              var key = keys[length];
              if (!(obj2.hasOwnProperty(key) && Base.equals(obj1[key], obj2[key]))) return false;
            }
          }

          return true;
        }

        return false;
      },
      read: function (list, start, options, amount) {
        if (this === Base) {
          var value = this.peek(list, start);
          list.__index++;
          return value;
        }

        var proto = this.prototype,
            readIndex = proto._readIndex,
            begin = start || readIndex && list.__index || 0,
            length = list.length,
            obj = list[begin];
        amount = amount || length - begin;

        if (obj instanceof this || options && options.readNull && obj == null && amount <= 1) {
          if (readIndex) list.__index = begin + 1;
          return obj && options && options.clone ? obj.clone() : obj;
        }

        obj = Base.create(proto);
        if (readIndex) obj.__read = true;
        obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length ? Base.slice(list, begin, begin + amount) : list) || obj;

        if (readIndex) {
          list.__index = begin + obj.__read;
          var filtered = obj.__filtered;

          if (filtered) {
            list.__filtered = filtered;
            obj.__filtered = undefined;
          }

          obj.__read = undefined;
        }

        return obj;
      },
      peek: function (list, start) {
        return list[list.__index = start || list.__index || 0];
      },
      remain: function (list) {
        return list.length - (list.__index || 0);
      },
      readList: function (list, start, options, amount) {
        var res = [],
            entry,
            begin = start || 0,
            end = amount ? begin + amount : list.length;

        for (var i = begin; i < end; i++) {
          res.push(Array.isArray(entry = list[i]) ? this.read(entry, 0, options) : this.read(list, i, options, 1));
        }

        return res;
      },
      readNamed: function (list, name, start, options, amount) {
        var value = this.getNamed(list, name),
            hasValue = value !== undefined;

        if (hasValue) {
          var filtered = list.__filtered;

          if (!filtered) {
            var source = this.getSource(list);
            filtered = list.__filtered = Base.create(source);
            filtered.__unfiltered = source;
          }

          filtered[name] = undefined;
        }

        return this.read(hasValue ? [value] : list, start, options, amount);
      },
      readSupported: function (list, dest) {
        var source = this.getSource(list),
            that = this,
            read = false;

        if (source) {
          Object.keys(source).forEach(function (key) {
            if (key in dest) {
              var value = that.readNamed(list, key);

              if (value !== undefined) {
                dest[key] = value;
              }

              read = true;
            }
          });
        }

        return read;
      },
      getSource: function (list) {
        var source = list.__source;

        if (source === undefined) {
          var arg = list.length === 1 && list[0];
          source = list.__source = arg && Base.isPlainObject(arg) ? arg : null;
        }

        return source;
      },
      getNamed: function (list, name) {
        var source = this.getSource(list);

        if (source) {
          return name ? source[name] : list.__filtered || source;
        }
      },
      hasNamed: function (list, name) {
        return !!this.getNamed(list, name);
      },
      filter: function (dest, source, exclude, prioritize) {
        var processed;

        function handleKey(key) {
          if (!(exclude && key in exclude) && !(processed && key in processed)) {
            var value = source[key];
            if (value !== undefined) dest[key] = value;
          }
        }

        if (prioritize) {
          var keys = {};

          for (var i = 0, key, l = prioritize.length; i < l; i++) {
            if ((key = prioritize[i]) in source) {
              handleKey(key);
              keys[key] = true;
            }
          }

          processed = keys;
        }

        Object.keys(source.__unfiltered || source).forEach(handleKey);
        return dest;
      },
      isPlainValue: function (obj, asString) {
        return Base.isPlainObject(obj) || Array.isArray(obj) || asString && typeof obj === 'string';
      },
      serialize: function (obj, options, compact, dictionary) {
        options = options || {};
        var isRoot = !dictionary,
            res;

        if (isRoot) {
          options.formatter = new Formatter(options.precision);
          dictionary = {
            length: 0,
            definitions: {},
            references: {},
            add: function (item, create) {
              var id = '#' + item._id,
                  ref = this.references[id];

              if (!ref) {
                this.length++;
                var res = create.call(item),
                    name = item._class;
                if (name && res[0] !== name) res.unshift(name);
                this.definitions[id] = res;
                ref = this.references[id] = [id];
              }

              return ref;
            }
          };
        }

        if (obj && obj._serialize) {
          res = obj._serialize(options, dictionary);
          var name = obj._class;

          if (name && !obj._compactSerialize && (isRoot || !compact) && res[0] !== name) {
            res.unshift(name);
          }
        } else if (Array.isArray(obj)) {
          res = [];

          for (var i = 0, l = obj.length; i < l; i++) res[i] = Base.serialize(obj[i], options, compact, dictionary);
        } else if (Base.isPlainObject(obj)) {
          res = {};
          var keys = Object.keys(obj);

          for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            res[key] = Base.serialize(obj[key], options, compact, dictionary);
          }
        } else if (typeof obj === 'number') {
          res = options.formatter.number(obj, options.precision);
        } else {
          res = obj;
        }

        return isRoot && dictionary.length > 0 ? [['dictionary', dictionary.definitions], res] : res;
      },
      deserialize: function (json, create, _data, _setDictionary, _isRoot) {
        var res = json,
            isFirst = !_data,
            hasDictionary = isFirst && json && json.length && json[0][0] === 'dictionary';
        _data = _data || {};

        if (Array.isArray(json)) {
          var type = json[0],
              isDictionary = type === 'dictionary';

          if (json.length == 1 && /^#/.test(type)) {
            return _data.dictionary[type];
          }

          type = Base.exports[type];
          res = [];

          for (var i = type ? 1 : 0, l = json.length; i < l; i++) {
            res.push(Base.deserialize(json[i], create, _data, isDictionary, hasDictionary));
          }

          if (type) {
            var args = res;

            if (create) {
              res = create(type, args, isFirst || _isRoot);
            } else {
              res = new type(args);
            }
          }
        } else if (Base.isPlainObject(json)) {
          res = {};
          if (_setDictionary) _data.dictionary = res;

          for (var key in json) res[key] = Base.deserialize(json[key], create, _data);
        }

        return hasDictionary ? res[1] : res;
      },
      exportJSON: function (obj, options) {
        var json = Base.serialize(obj, options);
        return options && options.asString == false ? json : JSON.stringify(json);
      },
      importJSON: function (json, target) {
        return Base.deserialize(typeof json === 'string' ? JSON.parse(json) : json, function (ctor, args, isRoot) {
          var useTarget = isRoot && target && target.constructor === ctor,
              obj = useTarget ? target : Base.create(ctor.prototype);

          if (args.length === 1 && obj instanceof Item && (useTarget || !(obj instanceof Layer))) {
            var arg = args[0];

            if (Base.isPlainObject(arg)) {
              arg.insert = false;

              if (useTarget) {
                args = args.concat([{
                  insert: true
                }]);
              }
            }
          }

          (useTarget ? obj.set : ctor).apply(obj, args);
          if (useTarget) target = null;
          return obj;
        });
      },
      push: function (list, items) {
        var itemsLength = items.length;

        if (itemsLength < 4096) {
          list.push.apply(list, items);
        } else {
          var startLength = list.length;
          list.length += itemsLength;

          for (var i = 0; i < itemsLength; i++) {
            list[startLength + i] = items[i];
          }
        }

        return list;
      },
      splice: function (list, items, index, remove) {
        var amount = items && items.length,
            append = index === undefined;
        index = append ? list.length : index;
        if (index > list.length) index = list.length;

        for (var i = 0; i < amount; i++) items[i]._index = index + i;

        if (append) {
          Base.push(list, items);
          return [];
        } else {
          var args = [index, remove];
          if (items) Base.push(args, items);
          var removed = list.splice.apply(list, args);

          for (var i = 0, l = removed.length; i < l; i++) removed[i]._index = undefined;

          for (var i = index + amount, l = list.length; i < l; i++) list[i]._index = i;

          return removed;
        }
      },
      capitalize: function (str) {
        return str.replace(/\b[a-z]/g, function (match) {
          return match.toUpperCase();
        });
      },
      camelize: function (str) {
        return str.replace(/-(.)/g, function (match, chr) {
          return chr.toUpperCase();
        });
      },
      hyphenate: function (str) {
        return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
      }
    }
  });
  var Emitter = {
    on: function (type, func) {
      if (typeof type !== 'string') {
        Base.each(type, function (value, key) {
          this.on(key, value);
        }, this);
      } else {
        var types = this._eventTypes,
            entry = types && types[type],
            handlers = this._callbacks = this._callbacks || {};
        handlers = handlers[type] = handlers[type] || [];

        if (handlers.indexOf(func) === -1) {
          handlers.push(func);
          if (entry && entry.install && handlers.length === 1) entry.install.call(this, type);
        }
      }

      return this;
    },
    off: function (type, func) {
      if (typeof type !== 'string') {
        Base.each(type, function (value, key) {
          this.off(key, value);
        }, this);
        return;
      }

      var types = this._eventTypes,
          entry = types && types[type],
          handlers = this._callbacks && this._callbacks[type],
          index;

      if (handlers) {
        if (!func || (index = handlers.indexOf(func)) !== -1 && handlers.length === 1) {
          if (entry && entry.uninstall) entry.uninstall.call(this, type);
          delete this._callbacks[type];
        } else if (index !== -1) {
          handlers.splice(index, 1);
        }
      }

      return this;
    },
    once: function (type, func) {
      return this.on(type, function handler() {
        func.apply(this, arguments);
        this.off(type, handler);
      });
    },
    emit: function (type, event) {
      var handlers = this._callbacks && this._callbacks[type];
      if (!handlers) return false;
      var args = Base.slice(arguments, 1),
          setTarget = event && event.target && !event.currentTarget;
      handlers = handlers.slice();
      if (setTarget) event.currentTarget = this;

      for (var i = 0, l = handlers.length; i < l; i++) {
        if (handlers[i].apply(this, args) == false) {
          if (event && event.stop) event.stop();
          break;
        }
      }

      if (setTarget) delete event.currentTarget;
      return true;
    },
    responds: function (type) {
      return !!(this._callbacks && this._callbacks[type]);
    },
    attach: '#on',
    detach: '#off',
    fire: '#emit',
    _installEvents: function (install) {
      var types = this._eventTypes,
          handlers = this._callbacks,
          key = install ? 'install' : 'uninstall';

      if (types) {
        for (var type in handlers) {
          if (handlers[type].length > 0) {
            var entry = types[type],
                func = entry && entry[key];
            if (func) func.call(this, type);
          }
        }
      }
    },
    statics: {
      inject: function inject(src) {
        var events = src._events;

        if (events) {
          var types = {};
          Base.each(events, function (entry, key) {
            var isString = typeof entry === 'string',
                name = isString ? entry : key,
                part = Base.capitalize(name),
                type = name.substring(2).toLowerCase();
            types[type] = isString ? {} : entry;
            name = '_' + name;

            src['get' + part] = function () {
              return this[name];
            };

            src['set' + part] = function (func) {
              var prev = this[name];
              if (prev) this.off(type, prev);
              if (func) this.on(type, func);
              this[name] = func;
            };
          });
          src._eventTypes = types;
        }

        return inject.base.apply(this, arguments);
      }
    }
  };
  var PaperScope = Base.extend({
    _class: 'PaperScope',
    initialize: function PaperScope() {
      paper = this;
      this.settings = new Base({
        applyMatrix: true,
        insertItems: true,
        handleSize: 4,
        hitTolerance: 0
      });
      this.project = null;
      this.projects = [];
      this.tools = [];
      this._id = PaperScope._id++;
      PaperScope._scopes[this._id] = this;
      var proto = PaperScope.prototype;

      if (!this.support) {
        var ctx = CanvasProvider.getContext(1, 1) || {};
        proto.support = {
          nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
          nativeBlendModes: BlendMode.nativeModes
        };
        CanvasProvider.release(ctx);
      }

      if (!this.agent) {
        var user = self.navigator.userAgent.toLowerCase(),
            os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user) || [])[0],
            platform = os === 'darwin' ? 'mac' : os,
            agent = proto.agent = proto.browser = {
          platform: platform
        };
        if (platform) agent[platform] = true;
        user.replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g, function (match, n, v1, v2, rv) {
          if (!agent.chrome) {
            var v = n === 'opera' ? v2 : /^(node|trident)$/.test(n) ? rv : v1;
            agent.version = v;
            agent.versionNumber = parseFloat(v);
            n = {
              trident: 'msie',
              jsdom: 'node'
            }[n] || n;
            agent.name = n;
            agent[n] = true;
          }
        });
        if (agent.chrome) delete agent.webkit;
        if (agent.atom) delete agent.chrome;
      }
    },
    version: "0.12.11",
    getView: function () {
      var project = this.project;
      return project && project._view;
    },
    getPaper: function () {
      return this;
    },
    execute: function (code, options) {
      var exports = paper.PaperScript.execute(code, this, options);
      View.updateFocus();
      return exports;
    },
    install: function (scope) {
      var that = this;
      Base.each(['project', 'view', 'tool'], function (key) {
        Base.define(scope, key, {
          configurable: true,
          get: function () {
            return that[key];
          }
        });
      });

      for (var key in this) if (!/^_/.test(key) && this[key]) scope[key] = this[key];
    },
    setup: function (element) {
      paper = this;
      this.project = new Project(element);
      return this;
    },
    createCanvas: function (width, height) {
      return CanvasProvider.getCanvas(width, height);
    },
    activate: function () {
      paper = this;
    },
    clear: function () {
      var projects = this.projects,
          tools = this.tools;

      for (var i = projects.length - 1; i >= 0; i--) projects[i].remove();

      for (var i = tools.length - 1; i >= 0; i--) tools[i].remove();
    },
    remove: function () {
      this.clear();
      delete PaperScope._scopes[this._id];
    },
    statics: new function () {
      function handleAttribute(name) {
        name += 'Attribute';
        return function (el, attr) {
          return el[name](attr) || el[name]('data-paper-' + attr);
        };
      }

      return {
        _scopes: {},
        _id: 0,
        get: function (id) {
          return this._scopes[id] || null;
        },
        getAttribute: handleAttribute('get'),
        hasAttribute: handleAttribute('has')
      };
    }()
  });
  var PaperScopeItem = Base.extend(Emitter, {
    initialize: function (activate) {
      this._scope = paper;
      this._index = this._scope[this._list].push(this) - 1;
      if (activate || !this._scope[this._reference]) this.activate();
    },
    activate: function () {
      if (!this._scope) return false;
      var prev = this._scope[this._reference];
      if (prev && prev !== this) prev.emit('deactivate');
      this._scope[this._reference] = this;
      this.emit('activate', prev);
      return true;
    },
    isActive: function () {
      return this._scope[this._reference] === this;
    },
    remove: function () {
      if (this._index == null) return false;
      Base.splice(this._scope[this._list], null, this._index, 1);
      if (this._scope[this._reference] == this) this._scope[this._reference] = null;
      this._scope = null;
      return true;
    },
    getView: function () {
      return this._scope.getView();
    }
  });
  var CollisionDetection = {
    findItemBoundsCollisions: function (items1, items2, tolerance) {
      function getBounds(items) {
        var bounds = new Array(items.length);

        for (var i = 0; i < items.length; i++) {
          var rect = items[i].getBounds();
          bounds[i] = [rect.left, rect.top, rect.right, rect.bottom];
        }

        return bounds;
      }

      var bounds1 = getBounds(items1),
          bounds2 = !items2 || items2 === items1 ? bounds1 : getBounds(items2);
      return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
    },
    findCurveBoundsCollisions: function (curves1, curves2, tolerance, bothAxis) {
      function getBounds(curves) {
        var min = Math.min,
            max = Math.max,
            bounds = new Array(curves.length);

        for (var i = 0; i < curves.length; i++) {
          var v = curves[i];
          bounds[i] = [min(v[0], v[2], v[4], v[6]), min(v[1], v[3], v[5], v[7]), max(v[0], v[2], v[4], v[6]), max(v[1], v[3], v[5], v[7])];
        }

        return bounds;
      }

      var bounds1 = getBounds(curves1),
          bounds2 = !curves2 || curves2 === curves1 ? bounds1 : getBounds(curves2);

      if (bothAxis) {
        var hor = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, false, true),
            ver = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, true, true),
            list = [];

        for (var i = 0, l = hor.length; i < l; i++) {
          list[i] = {
            hor: hor[i],
            ver: ver[i]
          };
        }

        return list;
      }

      return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
    },
    findBoundsCollisions: function (boundsA, boundsB, tolerance, sweepVertical, onlySweepAxisCollisions) {
      var self = !boundsB || boundsA === boundsB,
          allBounds = self ? boundsA : boundsA.concat(boundsB),
          lengthA = boundsA.length,
          lengthAll = allBounds.length;

      function binarySearch(indices, coord, value) {
        var lo = 0,
            hi = indices.length;

        while (lo < hi) {
          var mid = hi + lo >>> 1;

          if (allBounds[indices[mid]][coord] < value) {
            lo = mid + 1;
          } else {
            hi = mid;
          }
        }

        return lo - 1;
      }

      var pri0 = sweepVertical ? 1 : 0,
          pri1 = pri0 + 2,
          sec0 = sweepVertical ? 0 : 1,
          sec1 = sec0 + 2;
      var allIndicesByPri0 = new Array(lengthAll);

      for (var i = 0; i < lengthAll; i++) {
        allIndicesByPri0[i] = i;
      }

      allIndicesByPri0.sort(function (i1, i2) {
        return allBounds[i1][pri0] - allBounds[i2][pri0];
      });
      var activeIndicesByPri1 = [],
          allCollisions = new Array(lengthA);

      for (var i = 0; i < lengthAll; i++) {
        var curIndex = allIndicesByPri0[i],
            curBounds = allBounds[curIndex],
            origIndex = self ? curIndex : curIndex - lengthA,
            isCurrentA = curIndex < lengthA,
            isCurrentB = self || !isCurrentA,
            curCollisions = isCurrentA ? [] : null;

        if (activeIndicesByPri1.length) {
          var pruneCount = binarySearch(activeIndicesByPri1, pri1, curBounds[pri0] - tolerance) + 1;
          activeIndicesByPri1.splice(0, pruneCount);

          if (self && onlySweepAxisCollisions) {
            curCollisions = curCollisions.concat(activeIndicesByPri1);

            for (var j = 0; j < activeIndicesByPri1.length; j++) {
              var activeIndex = activeIndicesByPri1[j];
              allCollisions[activeIndex].push(origIndex);
            }
          } else {
            var curSec1 = curBounds[sec1],
                curSec0 = curBounds[sec0];

            for (var j = 0; j < activeIndicesByPri1.length; j++) {
              var activeIndex = activeIndicesByPri1[j],
                  activeBounds = allBounds[activeIndex],
                  isActiveA = activeIndex < lengthA,
                  isActiveB = self || activeIndex >= lengthA;

              if (onlySweepAxisCollisions || (isCurrentA && isActiveB || isCurrentB && isActiveA) && curSec1 >= activeBounds[sec0] - tolerance && curSec0 <= activeBounds[sec1] + tolerance) {
                if (isCurrentA && isActiveB) {
                  curCollisions.push(self ? activeIndex : activeIndex - lengthA);
                }

                if (isCurrentB && isActiveA) {
                  allCollisions[activeIndex].push(origIndex);
                }
              }
            }
          }
        }

        if (isCurrentA) {
          if (boundsA === boundsB) {
            curCollisions.push(curIndex);
          }

          allCollisions[curIndex] = curCollisions;
        }

        if (activeIndicesByPri1.length) {
          var curPri1 = curBounds[pri1],
              index = binarySearch(activeIndicesByPri1, pri1, curPri1);
          activeIndicesByPri1.splice(index + 1, 0, curIndex);
        } else {
          activeIndicesByPri1.push(curIndex);
        }
      }

      for (var i = 0; i < allCollisions.length; i++) {
        var collisions = allCollisions[i];

        if (collisions) {
          collisions.sort(function (i1, i2) {
            return i1 - i2;
          });
        }
      }

      return allCollisions;
    }
  };
  var Formatter = Base.extend({
    initialize: function (precision) {
      this.precision = Base.pick(precision, 5);
      this.multiplier = Math.pow(10, this.precision);
    },
    number: function (val) {
      return this.precision < 16 ? Math.round(val * this.multiplier) / this.multiplier : val;
    },
    pair: function (val1, val2, separator) {
      return this.number(val1) + (separator || ',') + this.number(val2);
    },
    point: function (val, separator) {
      return this.number(val.x) + (separator || ',') + this.number(val.y);
    },
    size: function (val, separator) {
      return this.number(val.width) + (separator || ',') + this.number(val.height);
    },
    rectangle: function (val, separator) {
      return this.point(val, separator) + (separator || ',') + this.size(val, separator);
    }
  });
  Formatter.instance = new Formatter();
  var Numerical = new function () {
    var abscissas = [[0.5773502691896257645091488], [0, 0.7745966692414833770358531], [0.3399810435848562648026658, 0.8611363115940525752239465], [0, 0.5384693101056830910363144, 0.9061798459386639927976269], [0.2386191860831969086305017, 0.6612093864662645136613996, 0.9324695142031520278123016], [0, 0.4058451513773971669066064, 0.7415311855993944398638648, 0.9491079123427585245261897], [0.1834346424956498049394761, 0.5255324099163289858177390, 0.7966664774136267395915539, 0.9602898564975362316835609], [0, 0.3242534234038089290385380, 0.6133714327005903973087020, 0.8360311073266357942994298, 0.9681602395076260898355762], [0.1488743389816312108848260, 0.4333953941292471907992659, 0.6794095682990244062343274, 0.8650633666889845107320967, 0.9739065285171717200779640], [0, 0.2695431559523449723315320, 0.5190961292068118159257257, 0.7301520055740493240934163, 0.8870625997680952990751578, 0.9782286581460569928039380], [0.1252334085114689154724414, 0.3678314989981801937526915, 0.5873179542866174472967024, 0.7699026741943046870368938, 0.9041172563704748566784659, 0.9815606342467192506905491], [0, 0.2304583159551347940655281, 0.4484927510364468528779129, 0.6423493394403402206439846, 0.8015780907333099127942065, 0.9175983992229779652065478, 0.9841830547185881494728294], [0.1080549487073436620662447, 0.3191123689278897604356718, 0.5152486363581540919652907, 0.6872929048116854701480198, 0.8272013150697649931897947, 0.9284348836635735173363911, 0.9862838086968123388415973], [0, 0.2011940939974345223006283, 0.3941513470775633698972074, 0.5709721726085388475372267, 0.7244177313601700474161861, 0.8482065834104272162006483, 0.9372733924007059043077589, 0.9879925180204854284895657], [0.0950125098376374401853193, 0.2816035507792589132304605, 0.4580167776572273863424194, 0.6178762444026437484466718, 0.7554044083550030338951012, 0.8656312023878317438804679, 0.9445750230732325760779884, 0.9894009349916499325961542]];
    var weights = [[1], [0.8888888888888888888888889, 0.5555555555555555555555556], [0.6521451548625461426269361, 0.3478548451374538573730639], [0.5688888888888888888888889, 0.4786286704993664680412915, 0.2369268850561890875142640], [0.4679139345726910473898703, 0.3607615730481386075698335, 0.1713244923791703450402961], [0.4179591836734693877551020, 0.3818300505051189449503698, 0.2797053914892766679014678, 0.1294849661688696932706114], [0.3626837833783619829651504, 0.3137066458778872873379622, 0.2223810344533744705443560, 0.1012285362903762591525314], [0.3302393550012597631645251, 0.3123470770400028400686304, 0.2606106964029354623187429, 0.1806481606948574040584720, 0.0812743883615744119718922], [0.2955242247147528701738930, 0.2692667193099963550912269, 0.2190863625159820439955349, 0.1494513491505805931457763, 0.0666713443086881375935688], [0.2729250867779006307144835, 0.2628045445102466621806889, 0.2331937645919904799185237, 0.1862902109277342514260976, 0.1255803694649046246346943, 0.0556685671161736664827537], [0.2491470458134027850005624, 0.2334925365383548087608499, 0.2031674267230659217490645, 0.1600783285433462263346525, 0.1069393259953184309602547, 0.0471753363865118271946160], [0.2325515532308739101945895, 0.2262831802628972384120902, 0.2078160475368885023125232, 0.1781459807619457382800467, 0.1388735102197872384636018, 0.0921214998377284479144218, 0.0404840047653158795200216], [0.2152638534631577901958764, 0.2051984637212956039659241, 0.1855383974779378137417166, 0.1572031671581935345696019, 0.1215185706879031846894148, 0.0801580871597602098056333, 0.0351194603317518630318329], [0.2025782419255612728806202, 0.1984314853271115764561183, 0.1861610000155622110268006, 0.1662692058169939335532009, 0.1395706779261543144478048, 0.1071592204671719350118695, 0.0703660474881081247092674, 0.0307532419961172683546284], [0.1894506104550684962853967, 0.1826034150449235888667637, 0.1691565193950025381893121, 0.1495959888165767320815017, 0.1246289712555338720524763, 0.0951585116824927848099251, 0.0622535239386478928628438, 0.0271524594117540948517806]];

    var abs = Math.abs,
        sqrt = Math.sqrt,
        pow = Math.pow,
        log2 = Math.log2 || function (x) {
      return Math.log(x) * Math.LOG2E;
    },
        EPSILON = 1e-12,
        MACHINE_EPSILON = 1.12e-16;

    function clamp(value, min, max) {
      return value < min ? min : value > max ? max : value;
    }

    function getDiscriminant(a, b, c) {
      function split(v) {
        var x = v * 134217729,
            y = v - x,
            hi = y + x,
            lo = v - hi;
        return [hi, lo];
      }

      var D = b * b - a * c,
          E = b * b + a * c;

      if (abs(D) * 3 < E) {
        var ad = split(a),
            bd = split(b),
            cd = split(c),
            p = b * b,
            dp = bd[0] * bd[0] - p + 2 * bd[0] * bd[1] + bd[1] * bd[1],
            q = a * c,
            dq = ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0] + ad[1] * cd[1];
        D = p - q + (dp - dq);
      }

      return D;
    }

    function getNormalizationFactor() {
      var norm = Math.max.apply(Math, arguments);
      return norm && (norm < 1e-8 || norm > 1e8) ? pow(2, -Math.round(log2(norm))) : 0;
    }

    return {
      EPSILON: EPSILON,
      MACHINE_EPSILON: MACHINE_EPSILON,
      CURVETIME_EPSILON: 1e-8,
      GEOMETRIC_EPSILON: 1e-7,
      TRIGONOMETRIC_EPSILON: 1e-8,
      KAPPA: 4 * (sqrt(2) - 1) / 3,
      isZero: function (val) {
        return val >= -EPSILON && val <= EPSILON;
      },
      isMachineZero: function (val) {
        return val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;
      },
      clamp: clamp,
      integrate: function (f, a, b, n) {
        var x = abscissas[n - 2],
            w = weights[n - 2],
            A = (b - a) * 0.5,
            B = A + a,
            i = 0,
            m = n + 1 >> 1,
            sum = n & 1 ? w[i++] * f(B) : 0;

        while (i < m) {
          var Ax = A * x[i];
          sum += w[i++] * (f(B + Ax) + f(B - Ax));
        }

        return A * sum;
      },
      findRoot: function (f, df, x, a, b, n, tolerance) {
        for (var i = 0; i < n; i++) {
          var fx = f(x),
              dx = fx / df(x),
              nx = x - dx;

          if (abs(dx) < tolerance) {
            x = nx;
            break;
          }

          if (fx > 0) {
            b = x;
            x = nx <= a ? (a + b) * 0.5 : nx;
          } else {
            a = x;
            x = nx >= b ? (a + b) * 0.5 : nx;
          }
        }

        return clamp(x, a, b);
      },
      solveQuadratic: function (a, b, c, roots, min, max) {
        var x1,
            x2 = Infinity;

        if (abs(a) < EPSILON) {
          if (abs(b) < EPSILON) return abs(c) < EPSILON ? -1 : 0;
          x1 = -c / b;
        } else {
          b *= -0.5;
          var D = getDiscriminant(a, b, c);

          if (D && abs(D) < MACHINE_EPSILON) {
            var f = getNormalizationFactor(abs(a), abs(b), abs(c));

            if (f) {
              a *= f;
              b *= f;
              c *= f;
              D = getDiscriminant(a, b, c);
            }
          }

          if (D >= -MACHINE_EPSILON) {
            var Q = D < 0 ? 0 : sqrt(D),
                R = b + (b < 0 ? -Q : Q);

            if (R === 0) {
              x1 = c / a;
              x2 = -x1;
            } else {
              x1 = R / a;
              x2 = c / R;
            }
          }
        }

        var count = 0,
            boundless = min == null,
            minB = min - EPSILON,
            maxB = max + EPSILON;
        if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB)) roots[count++] = boundless ? x1 : clamp(x1, min, max);
        if (x2 !== x1 && isFinite(x2) && (boundless || x2 > minB && x2 < maxB)) roots[count++] = boundless ? x2 : clamp(x2, min, max);
        return count;
      },
      solveCubic: function (a, b, c, d, roots, min, max) {
        var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),
            x,
            b1,
            c2,
            qd,
            q;

        if (f) {
          a *= f;
          b *= f;
          c *= f;
          d *= f;
        }

        function evaluate(x0) {
          x = x0;
          var tmp = a * x;
          b1 = tmp + b;
          c2 = b1 * x + c;
          qd = (tmp + b1) * x + c2;
          q = c2 * x + d;
        }

        if (abs(a) < EPSILON) {
          a = b;
          b1 = c;
          c2 = d;
          x = Infinity;
        } else if (abs(d) < EPSILON) {
          b1 = b;
          c2 = c;
          x = 0;
        } else {
          evaluate(-(b / a) / 3);
          var t = q / a,
              r = pow(abs(t), 1 / 3),
              s = t < 0 ? -1 : 1,
              td = -qd / a,
              rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,
              x0 = x - s * rd;

          if (x0 !== x) {
            do {
              evaluate(x0);
              x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);
            } while (s * x0 > s * x);

            if (abs(a) * x * x > abs(d / x)) {
              c2 = -d / x;
              b1 = (c2 - c) / x;
            }
          }
        }

        var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),
            boundless = min == null;
        if (isFinite(x) && (count === 0 || count > 0 && x !== roots[0] && x !== roots[1]) && (boundless || x > min - EPSILON && x < max + EPSILON)) roots[count++] = boundless ? x : clamp(x, min, max);
        return count;
      }
    };
  }();
  var UID = {
    _id: 1,
    _pools: {},
    get: function (name) {
      if (name) {
        var pool = this._pools[name];
        if (!pool) pool = this._pools[name] = {
          _id: 1
        };
        return pool._id++;
      } else {
        return this._id++;
      }
    }
  };
  var Point = Base.extend({
    _class: 'Point',
    _readIndex: true,
    initialize: function Point(arg0, arg1) {
      var type = typeof arg0,
          reading = this.__read,
          read = 0;

      if (type === 'number') {
        var hasY = typeof arg1 === 'number';

        this._set(arg0, hasY ? arg1 : arg0);

        if (reading) read = hasY ? 2 : 1;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0);

        if (reading) read = arg0 === null ? 1 : 0;
      } else {
        var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
        read = 1;

        if (Array.isArray(obj)) {
          this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
        } else if ('x' in obj) {
          this._set(obj.x || 0, obj.y || 0);
        } else if ('width' in obj) {
          this._set(obj.width || 0, obj.height || 0);
        } else if ('angle' in obj) {
          this._set(obj.length || 0, 0);

          this.setAngle(obj.angle || 0);
        } else {
          this._set(0, 0);

          read = 0;
        }
      }

      if (reading) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function (x, y) {
      this.x = x;
      this.y = y;
      return this;
    },
    equals: function (point) {
      return this === point || point && (this.x === point.x && this.y === point.y || Array.isArray(point) && this.x === point[0] && this.y === point[1]) || false;
    },
    clone: function () {
      return new Point(this.x, this.y);
    },
    toString: function () {
      var f = Formatter.instance;
      return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
    },
    _serialize: function (options) {
      var f = options.formatter;
      return [f.number(this.x), f.number(this.y)];
    },
    getLength: function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    setLength: function (length) {
      if (this.isZero()) {
        var angle = this._angle || 0;

        this._set(Math.cos(angle) * length, Math.sin(angle) * length);
      } else {
        var scale = length / this.getLength();
        if (Numerical.isZero(scale)) this.getAngle();

        this._set(this.x * scale, this.y * scale);
      }
    },
    getAngle: function () {
      return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
    },
    setAngle: function (angle) {
      this.setAngleInRadians.call(this, angle * Math.PI / 180);
    },
    getAngleInDegrees: '#getAngle',
    setAngleInDegrees: '#setAngle',
    getAngleInRadians: function () {
      if (!arguments.length) {
        return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
      } else {
        var point = Point.read(arguments),
            div = this.getLength() * point.getLength();

        if (Numerical.isZero(div)) {
          return NaN;
        } else {
          var a = this.dot(point) / div;
          return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
        }
      }
    },
    setAngleInRadians: function (angle) {
      this._angle = angle;

      if (!this.isZero()) {
        var length = this.getLength();

        this._set(Math.cos(angle) * length, Math.sin(angle) * length);
      }
    },
    getQuadrant: function () {
      return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
    }
  }, {
    beans: false,
    getDirectedAngle: function () {
      var point = Point.read(arguments);
      return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
    },
    getDistance: function () {
      var args = arguments,
          point = Point.read(args),
          x = point.x - this.x,
          y = point.y - this.y,
          d = x * x + y * y,
          squared = Base.read(args);
      return squared ? d : Math.sqrt(d);
    },
    normalize: function (length) {
      if (length === undefined) length = 1;
      var current = this.getLength(),
          scale = current !== 0 ? length / current : 0,
          point = new Point(this.x * scale, this.y * scale);
      if (scale >= 0) point._angle = this._angle;
      return point;
    },
    rotate: function (angle, center) {
      if (angle === 0) return this.clone();
      angle = angle * Math.PI / 180;
      var point = center ? this.subtract(center) : this,
          sin = Math.sin(angle),
          cos = Math.cos(angle);
      point = new Point(point.x * cos - point.y * sin, point.x * sin + point.y * cos);
      return center ? point.add(center) : point;
    },
    transform: function (matrix) {
      return matrix ? matrix._transformPoint(this) : this;
    },
    add: function () {
      var point = Point.read(arguments);
      return new Point(this.x + point.x, this.y + point.y);
    },
    subtract: function () {
      var point = Point.read(arguments);
      return new Point(this.x - point.x, this.y - point.y);
    },
    multiply: function () {
      var point = Point.read(arguments);
      return new Point(this.x * point.x, this.y * point.y);
    },
    divide: function () {
      var point = Point.read(arguments);
      return new Point(this.x / point.x, this.y / point.y);
    },
    modulo: function () {
      var point = Point.read(arguments);
      return new Point(this.x % point.x, this.y % point.y);
    },
    negate: function () {
      return new Point(-this.x, -this.y);
    },
    isInside: function () {
      return Rectangle.read(arguments).contains(this);
    },
    isClose: function () {
      var args = arguments,
          point = Point.read(args),
          tolerance = Base.read(args);
      return this.getDistance(point) <= tolerance;
    },
    isCollinear: function () {
      var point = Point.read(arguments);
      return Point.isCollinear(this.x, this.y, point.x, point.y);
    },
    isColinear: '#isCollinear',
    isOrthogonal: function () {
      var point = Point.read(arguments);
      return Point.isOrthogonal(this.x, this.y, point.x, point.y);
    },
    isZero: function () {
      var isZero = Numerical.isZero;
      return isZero(this.x) && isZero(this.y);
    },
    isNaN: function () {
      return isNaN(this.x) || isNaN(this.y);
    },
    isInQuadrant: function (q) {
      return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0 && this.y * (q > 2 ? -1 : 1) >= 0;
    },
    dot: function () {
      var point = Point.read(arguments);
      return this.x * point.x + this.y * point.y;
    },
    cross: function () {
      var point = Point.read(arguments);
      return this.x * point.y - this.y * point.x;
    },
    project: function () {
      var point = Point.read(arguments),
          scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
      return new Point(point.x * scale, point.y * scale);
    },
    statics: {
      min: function () {
        var args = arguments,
            point1 = Point.read(args),
            point2 = Point.read(args);
        return new Point(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y));
      },
      max: function () {
        var args = arguments,
            point1 = Point.read(args),
            point2 = Point.read(args);
        return new Point(Math.max(point1.x, point2.x), Math.max(point1.y, point2.y));
      },
      random: function () {
        return new Point(Math.random(), Math.random());
      },
      isCollinear: function (x1, y1, x2, y2) {
        return Math.abs(x1 * y2 - y1 * x2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;
      },
      isOrthogonal: function (x1, y1, x2, y2) {
        return Math.abs(x1 * x2 + y1 * y2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;
      }
    }
  }, Base.each(['round', 'ceil', 'floor', 'abs'], function (key) {
    var op = Math[key];

    this[key] = function () {
      return new Point(op(this.x), op(this.y));
    };
  }, {}));
  var LinkedPoint = Point.extend({
    initialize: function Point(x, y, owner, setter) {
      this._x = x;
      this._y = y;
      this._owner = owner;
      this._setter = setter;
    },
    _set: function (x, y, _dontNotify) {
      this._x = x;
      this._y = y;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    },
    getX: function () {
      return this._x;
    },
    setX: function (x) {
      this._x = x;

      this._owner[this._setter](this);
    },
    getY: function () {
      return this._y;
    },
    setY: function (y) {
      this._y = y;

      this._owner[this._setter](this);
    },
    isSelected: function () {
      return !!(this._owner._selection & this._getSelection());
    },
    setSelected: function (selected) {
      this._owner._changeSelection(this._getSelection(), selected);
    },
    _getSelection: function () {
      return this._setter === 'setPosition' ? 4 : 0;
    }
  });
  var Size = Base.extend({
    _class: 'Size',
    _readIndex: true,
    initialize: function Size(arg0, arg1) {
      var type = typeof arg0,
          reading = this.__read,
          read = 0;

      if (type === 'number') {
        var hasHeight = typeof arg1 === 'number';

        this._set(arg0, hasHeight ? arg1 : arg0);

        if (reading) read = hasHeight ? 2 : 1;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0);

        if (reading) read = arg0 === null ? 1 : 0;
      } else {
        var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
        read = 1;

        if (Array.isArray(obj)) {
          this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
        } else if ('width' in obj) {
          this._set(obj.width || 0, obj.height || 0);
        } else if ('x' in obj) {
          this._set(obj.x || 0, obj.y || 0);
        } else {
          this._set(0, 0);

          read = 0;
        }
      }

      if (reading) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function (width, height) {
      this.width = width;
      this.height = height;
      return this;
    },
    equals: function (size) {
      return size === this || size && (this.width === size.width && this.height === size.height || Array.isArray(size) && this.width === size[0] && this.height === size[1]) || false;
    },
    clone: function () {
      return new Size(this.width, this.height);
    },
    toString: function () {
      var f = Formatter.instance;
      return '{ width: ' + f.number(this.width) + ', height: ' + f.number(this.height) + ' }';
    },
    _serialize: function (options) {
      var f = options.formatter;
      return [f.number(this.width), f.number(this.height)];
    },
    add: function () {
      var size = Size.read(arguments);
      return new Size(this.width + size.width, this.height + size.height);
    },
    subtract: function () {
      var size = Size.read(arguments);
      return new Size(this.width - size.width, this.height - size.height);
    },
    multiply: function () {
      var size = Size.read(arguments);
      return new Size(this.width * size.width, this.height * size.height);
    },
    divide: function () {
      var size = Size.read(arguments);
      return new Size(this.width / size.width, this.height / size.height);
    },
    modulo: function () {
      var size = Size.read(arguments);
      return new Size(this.width % size.width, this.height % size.height);
    },
    negate: function () {
      return new Size(-this.width, -this.height);
    },
    isZero: function () {
      var isZero = Numerical.isZero;
      return isZero(this.width) && isZero(this.height);
    },
    isNaN: function () {
      return isNaN(this.width) || isNaN(this.height);
    },
    statics: {
      min: function (size1, size2) {
        return new Size(Math.min(size1.width, size2.width), Math.min(size1.height, size2.height));
      },
      max: function (size1, size2) {
        return new Size(Math.max(size1.width, size2.width), Math.max(size1.height, size2.height));
      },
      random: function () {
        return new Size(Math.random(), Math.random());
      }
    }
  }, Base.each(['round', 'ceil', 'floor', 'abs'], function (key) {
    var op = Math[key];

    this[key] = function () {
      return new Size(op(this.width), op(this.height));
    };
  }, {}));
  var LinkedSize = Size.extend({
    initialize: function Size(width, height, owner, setter) {
      this._width = width;
      this._height = height;
      this._owner = owner;
      this._setter = setter;
    },
    _set: function (width, height, _dontNotify) {
      this._width = width;
      this._height = height;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    },
    getWidth: function () {
      return this._width;
    },
    setWidth: function (width) {
      this._width = width;

      this._owner[this._setter](this);
    },
    getHeight: function () {
      return this._height;
    },
    setHeight: function (height) {
      this._height = height;

      this._owner[this._setter](this);
    }
  });
  var Rectangle = Base.extend({
    _class: 'Rectangle',
    _readIndex: true,
    beans: true,
    initialize: function Rectangle(arg0, arg1, arg2, arg3) {
      var args = arguments,
          type = typeof arg0,
          read;

      if (type === 'number') {
        this._set(arg0, arg1, arg2, arg3);

        read = 4;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0, 0, 0);

        read = arg0 === null ? 1 : 0;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          this._set.apply(this, arg0);

          read = 1;
        } else if (arg0.x !== undefined || arg0.width !== undefined) {
          this._set(arg0.x || 0, arg0.y || 0, arg0.width || 0, arg0.height || 0);

          read = 1;
        } else if (arg0.from === undefined && arg0.to === undefined) {
          this._set(0, 0, 0, 0);

          if (Base.readSupported(args, this)) {
            read = 1;
          }
        }
      }

      if (read === undefined) {
        var frm = Point.readNamed(args, 'from'),
            next = Base.peek(args),
            x = frm.x,
            y = frm.y,
            width,
            height;

        if (next && next.x !== undefined || Base.hasNamed(args, 'to')) {
          var to = Point.readNamed(args, 'to');
          width = to.x - x;
          height = to.y - y;

          if (width < 0) {
            x = to.x;
            width = -width;
          }

          if (height < 0) {
            y = to.y;
            height = -height;
          }
        } else {
          var size = Size.read(args);
          width = size.width;
          height = size.height;
        }

        this._set(x, y, width, height);

        read = args.__index;
      }

      var filtered = args.__filtered;
      if (filtered) this.__filtered = filtered;
      if (this.__read) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function (x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      return this;
    },
    clone: function () {
      return new Rectangle(this.x, this.y, this.width, this.height);
    },
    equals: function (rect) {
      var rt = Base.isPlainValue(rect) ? Rectangle.read(arguments) : rect;
      return rt === this || rt && this.x === rt.x && this.y === rt.y && this.width === rt.width && this.height === rt.height || false;
    },
    toString: function () {
      var f = Formatter.instance;
      return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ', width: ' + f.number(this.width) + ', height: ' + f.number(this.height) + ' }';
    },
    _serialize: function (options) {
      var f = options.formatter;
      return [f.number(this.x), f.number(this.y), f.number(this.width), f.number(this.height)];
    },
    getPoint: function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this.x, this.y, this, 'setPoint');
    },
    setPoint: function () {
      var point = Point.read(arguments);
      this.x = point.x;
      this.y = point.y;
    },
    getSize: function (_dontLink) {
      var ctor = _dontLink ? Size : LinkedSize;
      return new ctor(this.width, this.height, this, 'setSize');
    },
    _fw: 1,
    _fh: 1,
    setSize: function () {
      var size = Size.read(arguments),
          sx = this._sx,
          sy = this._sy,
          w = size.width,
          h = size.height;

      if (sx) {
        this.x += (this.width - w) * sx;
      }

      if (sy) {
        this.y += (this.height - h) * sy;
      }

      this.width = w;
      this.height = h;
      this._fw = this._fh = 1;
    },
    getLeft: function () {
      return this.x;
    },
    setLeft: function (left) {
      if (!this._fw) {
        var amount = left - this.x;
        this.width -= this._sx === 0.5 ? amount * 2 : amount;
      }

      this.x = left;
      this._sx = this._fw = 0;
    },
    getTop: function () {
      return this.y;
    },
    setTop: function (top) {
      if (!this._fh) {
        var amount = top - this.y;
        this.height -= this._sy === 0.5 ? amount * 2 : amount;
      }

      this.y = top;
      this._sy = this._fh = 0;
    },
    getRight: function () {
      return this.x + this.width;
    },
    setRight: function (right) {
      if (!this._fw) {
        var amount = right - this.x;
        this.width = this._sx === 0.5 ? amount * 2 : amount;
      }

      this.x = right - this.width;
      this._sx = 1;
      this._fw = 0;
    },
    getBottom: function () {
      return this.y + this.height;
    },
    setBottom: function (bottom) {
      if (!this._fh) {
        var amount = bottom - this.y;
        this.height = this._sy === 0.5 ? amount * 2 : amount;
      }

      this.y = bottom - this.height;
      this._sy = 1;
      this._fh = 0;
    },
    getCenterX: function () {
      return this.x + this.width / 2;
    },
    setCenterX: function (x) {
      if (this._fw || this._sx === 0.5) {
        this.x = x - this.width / 2;
      } else {
        if (this._sx) {
          this.x += (x - this.x) * 2 * this._sx;
        }

        this.width = (x - this.x) * 2;
      }

      this._sx = 0.5;
      this._fw = 0;
    },
    getCenterY: function () {
      return this.y + this.height / 2;
    },
    setCenterY: function (y) {
      if (this._fh || this._sy === 0.5) {
        this.y = y - this.height / 2;
      } else {
        if (this._sy) {
          this.y += (y - this.y) * 2 * this._sy;
        }

        this.height = (y - this.y) * 2;
      }

      this._sy = 0.5;
      this._fh = 0;
    },
    getCenter: function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
    },
    setCenter: function () {
      var point = Point.read(arguments);
      this.setCenterX(point.x);
      this.setCenterY(point.y);
      return this;
    },
    getArea: function () {
      return this.width * this.height;
    },
    isEmpty: function () {
      return this.width === 0 || this.height === 0;
    },
    contains: function (arg) {
      return arg && arg.width !== undefined || (Array.isArray(arg) ? arg : arguments).length === 4 ? this._containsRectangle(Rectangle.read(arguments)) : this._containsPoint(Point.read(arguments));
    },
    _containsPoint: function (point) {
      var x = point.x,
          y = point.y;
      return x >= this.x && y >= this.y && x <= this.x + this.width && y <= this.y + this.height;
    },
    _containsRectangle: function (rect) {
      var x = rect.x,
          y = rect.y;
      return x >= this.x && y >= this.y && x + rect.width <= this.x + this.width && y + rect.height <= this.y + this.height;
    },
    intersects: function () {
      var rect = Rectangle.read(arguments),
          epsilon = Base.read(arguments) || 0;
      return rect.x + rect.width > this.x - epsilon && rect.y + rect.height > this.y - epsilon && rect.x < this.x + this.width + epsilon && rect.y < this.y + this.height + epsilon;
    },
    intersect: function () {
      var rect = Rectangle.read(arguments),
          x1 = Math.max(this.x, rect.x),
          y1 = Math.max(this.y, rect.y),
          x2 = Math.min(this.x + this.width, rect.x + rect.width),
          y2 = Math.min(this.y + this.height, rect.y + rect.height);
      return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    unite: function () {
      var rect = Rectangle.read(arguments),
          x1 = Math.min(this.x, rect.x),
          y1 = Math.min(this.y, rect.y),
          x2 = Math.max(this.x + this.width, rect.x + rect.width),
          y2 = Math.max(this.y + this.height, rect.y + rect.height);
      return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    include: function () {
      var point = Point.read(arguments);
      var x1 = Math.min(this.x, point.x),
          y1 = Math.min(this.y, point.y),
          x2 = Math.max(this.x + this.width, point.x),
          y2 = Math.max(this.y + this.height, point.y);
      return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    expand: function () {
      var amount = Size.read(arguments),
          hor = amount.width,
          ver = amount.height;
      return new Rectangle(this.x - hor / 2, this.y - ver / 2, this.width + hor, this.height + ver);
    },
    scale: function (hor, ver) {
      return this.expand(this.width * hor - this.width, this.height * (ver === undefined ? hor : ver) - this.height);
    }
  }, Base.each([['Top', 'Left'], ['Top', 'Right'], ['Bottom', 'Left'], ['Bottom', 'Right'], ['Left', 'Center'], ['Top', 'Center'], ['Right', 'Center'], ['Bottom', 'Center']], function (parts, index) {
    var part = parts.join(''),
        xFirst = /^[RL]/.test(part);
    if (index >= 4) parts[1] += xFirst ? 'Y' : 'X';
    var x = parts[xFirst ? 0 : 1],
        y = parts[xFirst ? 1 : 0],
        getX = 'get' + x,
        getY = 'get' + y,
        setX = 'set' + x,
        setY = 'set' + y,
        get = 'get' + part,
        set = 'set' + part;

    this[get] = function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this[getX](), this[getY](), this, set);
    };

    this[set] = function () {
      var point = Point.read(arguments);
      this[setX](point.x);
      this[setY](point.y);
    };
  }, {
    beans: true
  }));
  var LinkedRectangle = Rectangle.extend({
    initialize: function Rectangle(x, y, width, height, owner, setter) {
      this._set(x, y, width, height, true);

      this._owner = owner;
      this._setter = setter;
    },
    _set: function (x, y, width, height, _dontNotify) {
      this._x = x;
      this._y = y;
      this._width = width;
      this._height = height;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    }
  }, new function () {
    var proto = Rectangle.prototype;
    return Base.each(['x', 'y', 'width', 'height'], function (key) {
      var part = Base.capitalize(key),
          internal = '_' + key;

      this['get' + part] = function () {
        return this[internal];
      };

      this['set' + part] = function (value) {
        this[internal] = value;
        if (!this._dontNotify) this._owner[this._setter](this);
      };
    }, Base.each(['Point', 'Size', 'Center', 'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY', 'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'], function (key) {
      var name = 'set' + key;

      this[name] = function () {
        this._dontNotify = true;
        proto[name].apply(this, arguments);
        this._dontNotify = false;

        this._owner[this._setter](this);
      };
    }, {
      isSelected: function () {
        return !!(this._owner._selection & 2);
      },
      setSelected: function (selected) {
        var owner = this._owner;

        if (owner._changeSelection) {
          owner._changeSelection(2, selected);
        }
      }
    }));
  }());
  var Matrix = Base.extend({
    _class: 'Matrix',
    initialize: function Matrix(arg, _dontNotify) {
      var args = arguments,
          count = args.length,
          ok = true;

      if (count >= 6) {
        this._set.apply(this, args);
      } else if (count === 1 || count === 2) {
        if (arg instanceof Matrix) {
          this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty, _dontNotify);
        } else if (Array.isArray(arg)) {
          this._set.apply(this, _dontNotify ? arg.concat([_dontNotify]) : arg);
        } else {
          ok = false;
        }
      } else if (!count) {
        this.reset();
      } else {
        ok = false;
      }

      if (!ok) {
        throw new Error('Unsupported matrix parameters');
      }

      return this;
    },
    set: '#initialize',
    _set: function (a, b, c, d, tx, ty, _dontNotify) {
      this._a = a;
      this._b = b;
      this._c = c;
      this._d = d;
      this._tx = tx;
      this._ty = ty;
      if (!_dontNotify) this._changed();
      return this;
    },
    _serialize: function (options, dictionary) {
      return Base.serialize(this.getValues(), options, true, dictionary);
    },
    _changed: function () {
      var owner = this._owner;

      if (owner) {
        if (owner._applyMatrix) {
          owner.transform(null, true);
        } else {
          owner._changed(25);
        }
      }
    },
    clone: function () {
      return new Matrix(this._a, this._b, this._c, this._d, this._tx, this._ty);
    },
    equals: function (mx) {
      return mx === this || mx && this._a === mx._a && this._b === mx._b && this._c === mx._c && this._d === mx._d && this._tx === mx._tx && this._ty === mx._ty;
    },
    toString: function () {
      var f = Formatter.instance;
      return '[[' + [f.number(this._a), f.number(this._c), f.number(this._tx)].join(', ') + '], [' + [f.number(this._b), f.number(this._d), f.number(this._ty)].join(', ') + ']]';
    },
    reset: function (_dontNotify) {
      this._a = this._d = 1;
      this._b = this._c = this._tx = this._ty = 0;
      if (!_dontNotify) this._changed();
      return this;
    },
    apply: function (recursively, _setApplyMatrix) {
      var owner = this._owner;

      if (owner) {
        owner.transform(null, Base.pick(recursively, true), _setApplyMatrix);
        return this.isIdentity();
      }

      return false;
    },
    translate: function () {
      var point = Point.read(arguments),
          x = point.x,
          y = point.y;
      this._tx += x * this._a + y * this._c;
      this._ty += x * this._b + y * this._d;

      this._changed();

      return this;
    },
    scale: function () {
      var args = arguments,
          scale = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      if (center) this.translate(center);
      this._a *= scale.x;
      this._b *= scale.x;
      this._c *= scale.y;
      this._d *= scale.y;
      if (center) this.translate(center.negate());

      this._changed();

      return this;
    },
    rotate: function (angle) {
      angle *= Math.PI / 180;
      var center = Point.read(arguments, 1),
          x = center.x,
          y = center.y,
          cos = Math.cos(angle),
          sin = Math.sin(angle),
          tx = x - x * cos + y * sin,
          ty = y - x * sin - y * cos,
          a = this._a,
          b = this._b,
          c = this._c,
          d = this._d;
      this._a = cos * a + sin * c;
      this._b = cos * b + sin * d;
      this._c = -sin * a + cos * c;
      this._d = -sin * b + cos * d;
      this._tx += tx * a + ty * c;
      this._ty += tx * b + ty * d;

      this._changed();

      return this;
    },
    shear: function () {
      var args = arguments,
          shear = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      if (center) this.translate(center);
      var a = this._a,
          b = this._b;
      this._a += shear.y * this._c;
      this._b += shear.y * this._d;
      this._c += shear.x * a;
      this._d += shear.x * b;
      if (center) this.translate(center.negate());

      this._changed();

      return this;
    },
    skew: function () {
      var args = arguments,
          skew = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      }),
          toRadians = Math.PI / 180,
          shear = new Point(Math.tan(skew.x * toRadians), Math.tan(skew.y * toRadians));
      return this.shear(shear, center);
    },
    append: function (mx, _dontNotify) {
      if (mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            a2 = mx._a,
            b2 = mx._c,
            c2 = mx._b,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        this._a = a2 * a1 + c2 * c1;
        this._c = b2 * a1 + d2 * c1;
        this._b = a2 * b1 + c2 * d1;
        this._d = b2 * b1 + d2 * d1;
        this._tx += tx2 * a1 + ty2 * c1;
        this._ty += tx2 * b1 + ty2 * d1;
        if (!_dontNotify) this._changed();
      }

      return this;
    },
    prepend: function (mx, _dontNotify) {
      if (mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            tx1 = this._tx,
            ty1 = this._ty,
            a2 = mx._a,
            b2 = mx._c,
            c2 = mx._b,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        this._a = a2 * a1 + b2 * b1;
        this._c = a2 * c1 + b2 * d1;
        this._b = c2 * a1 + d2 * b1;
        this._d = c2 * c1 + d2 * d1;
        this._tx = a2 * tx1 + b2 * ty1 + tx2;
        this._ty = c2 * tx1 + d2 * ty1 + ty2;
        if (!_dontNotify) this._changed();
      }

      return this;
    },
    appended: function (mx) {
      return this.clone().append(mx);
    },
    prepended: function (mx) {
      return this.clone().prepend(mx);
    },
    invert: function () {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          tx = this._tx,
          ty = this._ty,
          det = a * d - b * c,
          res = null;

      if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
        this._a = d / det;
        this._b = -b / det;
        this._c = -c / det;
        this._d = a / det;
        this._tx = (c * ty - d * tx) / det;
        this._ty = (b * tx - a * ty) / det;
        res = this;
      }

      return res;
    },
    inverted: function () {
      return this.clone().invert();
    },
    concatenate: '#append',
    preConcatenate: '#prepend',
    chain: '#appended',
    _shiftless: function () {
      return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
    },
    _orNullIfIdentity: function () {
      return this.isIdentity() ? null : this;
    },
    isIdentity: function () {
      return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1 && this._tx === 0 && this._ty === 0;
    },
    isInvertible: function () {
      var det = this._a * this._d - this._c * this._b;
      return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
    },
    isSingular: function () {
      return !this.isInvertible();
    },
    transform: function (src, dst, count) {
      return arguments.length < 3 ? this._transformPoint(Point.read(arguments)) : this._transformCoordinates(src, dst, count);
    },
    _transformPoint: function (point, dest, _dontNotify) {
      var x = point.x,
          y = point.y;
      if (!dest) dest = new Point();
      return dest._set(x * this._a + y * this._c + this._tx, x * this._b + y * this._d + this._ty, _dontNotify);
    },
    _transformCoordinates: function (src, dst, count) {
      for (var i = 0, max = 2 * count; i < max; i += 2) {
        var x = src[i],
            y = src[i + 1];
        dst[i] = x * this._a + y * this._c + this._tx;
        dst[i + 1] = x * this._b + y * this._d + this._ty;
      }

      return dst;
    },
    _transformCorners: function (rect) {
      var x1 = rect.x,
          y1 = rect.y,
          x2 = x1 + rect.width,
          y2 = y1 + rect.height,
          coords = [x1, y1, x2, y1, x2, y2, x1, y2];
      return this._transformCoordinates(coords, coords, 4);
    },
    _transformBounds: function (bounds, dest, _dontNotify) {
      var coords = this._transformCorners(bounds),
          min = coords.slice(0, 2),
          max = min.slice();

      for (var i = 2; i < 8; i++) {
        var val = coords[i],
            j = i & 1;

        if (val < min[j]) {
          min[j] = val;
        } else if (val > max[j]) {
          max[j] = val;
        }
      }

      if (!dest) dest = new Rectangle();
      return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1], _dontNotify);
    },
    inverseTransform: function () {
      return this._inverseTransform(Point.read(arguments));
    },
    _inverseTransform: function (point, dest, _dontNotify) {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          tx = this._tx,
          ty = this._ty,
          det = a * d - b * c,
          res = null;

      if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
        var x = point.x - this._tx,
            y = point.y - this._ty;
        if (!dest) dest = new Point();
        res = dest._set((x * d - y * c) / det, (y * a - x * b) / det, _dontNotify);
      }

      return res;
    },
    decompose: function () {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          det = a * d - b * c,
          sqrt = Math.sqrt,
          atan2 = Math.atan2,
          degrees = 180 / Math.PI,
          rotate,
          scale,
          skew;

      if (a !== 0 || b !== 0) {
        var r = sqrt(a * a + b * b);
        rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);
        scale = [r, det / r];
        skew = [atan2(a * c + b * d, r * r), 0];
      } else if (c !== 0 || d !== 0) {
        var s = sqrt(c * c + d * d);
        rotate = Math.asin(c / s) * (d > 0 ? 1 : -1);
        scale = [det / s, s];
        skew = [0, atan2(a * c + b * d, s * s)];
      } else {
        rotate = 0;
        skew = scale = [0, 0];
      }

      return {
        translation: this.getTranslation(),
        rotation: rotate * degrees,
        scaling: new Point(scale),
        skewing: new Point(skew[0] * degrees, skew[1] * degrees)
      };
    },
    getValues: function () {
      return [this._a, this._b, this._c, this._d, this._tx, this._ty];
    },
    getTranslation: function () {
      return new Point(this._tx, this._ty);
    },
    getScaling: function () {
      return this.decompose().scaling;
    },
    getRotation: function () {
      return this.decompose().rotation;
    },
    applyToContext: function (ctx) {
      if (!this.isIdentity()) {
        ctx.transform(this._a, this._b, this._c, this._d, this._tx, this._ty);
      }
    }
  }, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function (key) {
    var part = Base.capitalize(key),
        prop = '_' + key;

    this['get' + part] = function () {
      return this[prop];
    };

    this['set' + part] = function (value) {
      this[prop] = value;

      this._changed();
    };
  }, {}));
  var Line = Base.extend({
    _class: 'Line',
    initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
      var asVector = false;

      if (arguments.length >= 4) {
        this._px = arg0;
        this._py = arg1;
        this._vx = arg2;
        this._vy = arg3;
        asVector = arg4;
      } else {
        this._px = arg0.x;
        this._py = arg0.y;
        this._vx = arg1.x;
        this._vy = arg1.y;
        asVector = arg2;
      }

      if (!asVector) {
        this._vx -= this._px;
        this._vy -= this._py;
      }
    },
    getPoint: function () {
      return new Point(this._px, this._py);
    },
    getVector: function () {
      return new Point(this._vx, this._vy);
    },
    getLength: function () {
      return this.getVector().getLength();
    },
    intersect: function (line, isInfinite) {
      return Line.intersect(this._px, this._py, this._vx, this._vy, line._px, line._py, line._vx, line._vy, true, isInfinite);
    },
    getSide: function (point, isInfinite) {
      return Line.getSide(this._px, this._py, this._vx, this._vy, point.x, point.y, true, isInfinite);
    },
    getDistance: function (point) {
      return Math.abs(this.getSignedDistance(point));
    },
    getSignedDistance: function (point) {
      return Line.getSignedDistance(this._px, this._py, this._vx, this._vy, point.x, point.y, true);
    },
    isCollinear: function (line) {
      return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
    },
    isOrthogonal: function (line) {
      return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
    },
    statics: {
      intersect: function (p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector, isInfinite) {
        if (!asVector) {
          v1x -= p1x;
          v1y -= p1y;
          v2x -= p2x;
          v2y -= p2y;
        }

        var cross = v1x * v2y - v1y * v2x;

        if (!Numerical.isMachineZero(cross)) {
          var dx = p1x - p2x,
              dy = p1y - p2y,
              u1 = (v2x * dy - v2y * dx) / cross,
              u2 = (v1x * dy - v1y * dx) / cross,
              epsilon = 1e-12,
              uMin = -epsilon,
              uMax = 1 + epsilon;

          if (isInfinite || uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
            if (!isInfinite) {
              u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
            }

            return new Point(p1x + u1 * v1x, p1y + u1 * v1y);
          }
        }
      },
      getSide: function (px, py, vx, vy, x, y, asVector, isInfinite) {
        if (!asVector) {
          vx -= px;
          vy -= py;
        }

        var v2x = x - px,
            v2y = y - py,
            ccw = v2x * vy - v2y * vx;

        if (!isInfinite && Numerical.isMachineZero(ccw)) {
          ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
          if (ccw >= 0 && ccw <= 1) ccw = 0;
        }

        return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
      },
      getSignedDistance: function (px, py, vx, vy, x, y, asVector) {
        if (!asVector) {
          vx -= px;
          vy -= py;
        }

        return vx === 0 ? vy > 0 ? x - px : px - x : vy === 0 ? vx < 0 ? y - py : py - y : ((x - px) * vy - (y - py) * vx) / (vy > vx ? vy * Math.sqrt(1 + vx * vx / (vy * vy)) : vx * Math.sqrt(1 + vy * vy / (vx * vx)));
      },
      getDistance: function (px, py, vx, vy, x, y, asVector) {
        return Math.abs(Line.getSignedDistance(px, py, vx, vy, x, y, asVector));
      }
    }
  });
  var Project = PaperScopeItem.extend({
    _class: 'Project',
    _list: 'projects',
    _reference: 'project',
    _compactSerialize: true,
    initialize: function Project(element) {
      PaperScopeItem.call(this, true);
      this._children = [];
      this._namedChildren = {};
      this._activeLayer = null;
      this._currentStyle = new Style(null, null, this);
      this._view = View.create(this, element || CanvasProvider.getCanvas(1, 1));
      this._selectionItems = {};
      this._selectionCount = 0;
      this._updateVersion = 0;
    },
    _serialize: function (options, dictionary) {
      return Base.serialize(this._children, options, true, dictionary);
    },
    _changed: function (flags, item) {
      if (flags & 1) {
        var view = this._view;

        if (view) {
          view._needsUpdate = true;
          if (!view._requested && view._autoUpdate) view.requestUpdate();
        }
      }

      var changes = this._changes;

      if (changes && item) {
        var changesById = this._changesById,
            id = item._id,
            entry = changesById[id];

        if (entry) {
          entry.flags |= flags;
        } else {
          changes.push(changesById[id] = {
            item: item,
            flags: flags
          });
        }
      }
    },
    clear: function () {
      var children = this._children;

      for (var i = children.length - 1; i >= 0; i--) children[i].remove();
    },
    isEmpty: function () {
      return !this._children.length;
    },
    remove: function remove() {
      if (!remove.base.call(this)) return false;
      if (this._view) this._view.remove();
      return true;
    },
    getView: function () {
      return this._view;
    },
    getCurrentStyle: function () {
      return this._currentStyle;
    },
    setCurrentStyle: function (style) {
      this._currentStyle.set(style);
    },
    getIndex: function () {
      return this._index;
    },
    getOptions: function () {
      return this._scope.settings;
    },
    getLayers: function () {
      return this._children;
    },
    getActiveLayer: function () {
      return this._activeLayer || new Layer({
        project: this,
        insert: true
      });
    },
    getSymbolDefinitions: function () {
      var definitions = [],
          ids = {};
      this.getItems({
        class: SymbolItem,
        match: function (item) {
          var definition = item._definition,
              id = definition._id;

          if (!ids[id]) {
            ids[id] = true;
            definitions.push(definition);
          }

          return false;
        }
      });
      return definitions;
    },
    getSymbols: 'getSymbolDefinitions',
    getSelectedItems: function () {
      var selectionItems = this._selectionItems,
          items = [];

      for (var id in selectionItems) {
        var item = selectionItems[id],
            selection = item._selection;

        if (selection & 1 && item.isInserted()) {
          items.push(item);
        } else if (!selection) {
          this._updateSelection(item);
        }
      }

      return items;
    },
    _updateSelection: function (item) {
      var id = item._id,
          selectionItems = this._selectionItems;

      if (item._selection) {
        if (selectionItems[id] !== item) {
          this._selectionCount++;
          selectionItems[id] = item;
        }
      } else if (selectionItems[id] === item) {
        this._selectionCount--;
        delete selectionItems[id];
      }
    },
    selectAll: function () {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) children[i].setFullySelected(true);
    },
    deselectAll: function () {
      var selectionItems = this._selectionItems;

      for (var i in selectionItems) selectionItems[i].setFullySelected(false);
    },
    addLayer: function (layer) {
      return this.insertLayer(undefined, layer);
    },
    insertLayer: function (index, layer) {
      if (layer instanceof Layer) {
        layer._remove(false, true);

        Base.splice(this._children, [layer], index, 0);

        layer._setProject(this, true);

        var name = layer._name;
        if (name) layer.setName(name);
        if (this._changes) layer._changed(5);
        if (!this._activeLayer) this._activeLayer = layer;
      } else {
        layer = null;
      }

      return layer;
    },
    _insertItem: function (index, item, _created) {
      item = this.insertLayer(index, item) || (this._activeLayer || this._insertItem(undefined, new Layer(Item.NO_INSERT), true)).insertChild(index, item);
      if (_created && item.activate) item.activate();
      return item;
    },
    getItems: function (options) {
      return Item._getItems(this, options);
    },
    getItem: function (options) {
      return Item._getItems(this, options, null, null, true)[0] || null;
    },
    importJSON: function (json) {
      this.activate();
      var layer = this._activeLayer;
      return Base.importJSON(json, layer && layer.isEmpty() && layer);
    },
    removeOn: function (type) {
      var sets = this._removeSets;

      if (sets) {
        if (type === 'mouseup') sets.mousedrag = null;
        var set = sets[type];

        if (set) {
          for (var id in set) {
            var item = set[id];

            for (var key in sets) {
              var other = sets[key];
              if (other && other != set) delete other[item._id];
            }

            item.remove();
          }

          sets[type] = null;
        }
      }
    },
    draw: function (ctx, matrix, pixelRatio) {
      this._updateVersion++;
      ctx.save();
      matrix.applyToContext(ctx);
      var children = this._children,
          param = new Base({
        offset: new Point(0, 0),
        pixelRatio: pixelRatio,
        viewMatrix: matrix.isIdentity() ? null : matrix,
        matrices: [new Matrix()],
        updateMatrix: true
      });

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].draw(ctx, param);
      }

      ctx.restore();

      if (this._selectionCount > 0) {
        ctx.save();
        ctx.strokeWidth = 1;
        var items = this._selectionItems,
            size = this._scope.settings.handleSize,
            version = this._updateVersion;

        for (var id in items) {
          items[id]._drawSelection(ctx, matrix, size, items, version);
        }

        ctx.restore();
      }
    }
  });
  var Item = Base.extend(Emitter, {
    statics: {
      extend: function extend(src) {
        if (src._serializeFields) src._serializeFields = Base.set({}, this.prototype._serializeFields, src._serializeFields);
        return extend.base.apply(this, arguments);
      },
      NO_INSERT: {
        insert: false
      }
    },
    _class: 'Item',
    _name: null,
    _applyMatrix: true,
    _canApplyMatrix: true,
    _canScaleStroke: false,
    _pivot: null,
    _visible: true,
    _blendMode: 'normal',
    _opacity: 1,
    _locked: false,
    _guide: false,
    _clipMask: false,
    _selection: 0,
    _selectBounds: true,
    _selectChildren: false,
    _serializeFields: {
      name: null,
      applyMatrix: null,
      matrix: new Matrix(),
      pivot: null,
      visible: true,
      blendMode: 'normal',
      opacity: 1,
      locked: false,
      guide: false,
      clipMask: false,
      selected: false,
      data: {}
    },
    _prioritize: ['applyMatrix']
  }, new function () {
    var handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick', 'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];
    return Base.each(handlers, function (name) {
      this._events[name] = {
        install: function (type) {
          this.getView()._countItemEvent(type, 1);
        },
        uninstall: function (type) {
          this.getView()._countItemEvent(type, -1);
        }
      };
    }, {
      _events: {
        onFrame: {
          install: function () {
            this.getView()._animateItem(this, true);
          },
          uninstall: function () {
            this.getView()._animateItem(this, false);
          }
        },
        onLoad: {},
        onError: {}
      },
      statics: {
        _itemHandlers: handlers
      }
    });
  }(), {
    initialize: function Item() {},
    _initialize: function (props, point) {
      var hasProps = props && Base.isPlainObject(props),
          internal = hasProps && props.internal === true,
          matrix = this._matrix = new Matrix(),
          project = hasProps && props.project || paper.project,
          settings = paper.settings;
      this._id = internal ? null : UID.get();
      this._parent = this._index = null;
      this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
      if (point) matrix.translate(point);
      matrix._owner = this;
      this._style = new Style(project._currentStyle, this, project);

      if (internal || hasProps && props.insert == false || !settings.insertItems && !(hasProps && props.insert === true)) {
        this._setProject(project);
      } else {
        (hasProps && props.parent || project)._insertItem(undefined, this, true);
      }

      if (hasProps && props !== Item.NO_INSERT) {
        this.set(props, {
          internal: true,
          insert: true,
          project: true,
          parent: true
        });
      }

      return hasProps;
    },
    _serialize: function (options, dictionary) {
      var props = {},
          that = this;

      function serialize(fields) {
        for (var key in fields) {
          var value = that[key];

          if (!Base.equals(value, key === 'leading' ? fields.fontSize * 1.2 : fields[key])) {
            props[key] = Base.serialize(value, options, key !== 'data', dictionary);
          }
        }
      }

      serialize(this._serializeFields);
      if (!(this instanceof Group)) serialize(this._style._defaults);
      return [this._class, props];
    },
    _changed: function (flags) {
      var symbol = this._symbol,
          cacheParent = this._parent || symbol,
          project = this._project;

      if (flags & 8) {
        this._bounds = this._position = this._decomposed = undefined;
      }

      if (flags & 16) {
        this._globalMatrix = undefined;
      }

      if (cacheParent && flags & 72) {
        Item._clearBoundsCache(cacheParent);
      }

      if (flags & 2) {
        Item._clearBoundsCache(this);
      }

      if (project) project._changed(flags, this);
      if (symbol) symbol._changed(flags);
    },
    getId: function () {
      return this._id;
    },
    getName: function () {
      return this._name;
    },
    setName: function (name) {
      if (this._name) this._removeNamed();
      if (name === +name + '') throw new Error('Names consisting only of numbers are not supported.');

      var owner = this._getOwner();

      if (name && owner) {
        var children = owner._children,
            namedChildren = owner._namedChildren;
        (namedChildren[name] = namedChildren[name] || []).push(this);
        if (!(name in children)) children[name] = this;
      }

      this._name = name || undefined;

      this._changed(256);
    },
    getStyle: function () {
      return this._style;
    },
    setStyle: function (style) {
      this.getStyle().set(style);
    }
  }, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'], function (name) {
    var part = Base.capitalize(name),
        key = '_' + name,
        flags = {
      locked: 256,
      visible: 265
    };

    this['get' + part] = function () {
      return this[key];
    };

    this['set' + part] = function (value) {
      if (value != this[key]) {
        this[key] = value;

        this._changed(flags[name] || 257);
      }
    };
  }, {}), {
    beans: true,
    getSelection: function () {
      return this._selection;
    },
    setSelection: function (selection) {
      if (selection !== this._selection) {
        this._selection = selection;
        var project = this._project;

        if (project) {
          project._updateSelection(this);

          this._changed(257);
        }
      }
    },
    _changeSelection: function (flag, selected) {
      var selection = this._selection;
      this.setSelection(selected ? selection | flag : selection & ~flag);
    },
    isSelected: function () {
      if (this._selectChildren) {
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) if (children[i].isSelected()) return true;
      }

      return !!(this._selection & 1);
    },
    setSelected: function (selected) {
      if (this._selectChildren) {
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) children[i].setSelected(selected);
      }

      this._changeSelection(1, selected);
    },
    isFullySelected: function () {
      var children = this._children,
          selected = !!(this._selection & 1);

      if (children && selected) {
        for (var i = 0, l = children.length; i < l; i++) if (!children[i].isFullySelected()) return false;

        return true;
      }

      return selected;
    },
    setFullySelected: function (selected) {
      var children = this._children;

      if (children) {
        for (var i = 0, l = children.length; i < l; i++) children[i].setFullySelected(selected);
      }

      this._changeSelection(1, selected);
    },
    isClipMask: function () {
      return this._clipMask;
    },
    setClipMask: function (clipMask) {
      if (this._clipMask != (clipMask = !!clipMask)) {
        this._clipMask = clipMask;

        if (clipMask) {
          this.setFillColor(null);
          this.setStrokeColor(null);
        }

        this._changed(257);

        if (this._parent) this._parent._changed(2048);
      }
    },
    getData: function () {
      if (!this._data) this._data = {};
      return this._data;
    },
    setData: function (data) {
      this._data = data;
    },
    getPosition: function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;

      var position = this._position || (this._position = this._getPositionFromBounds());

      return new ctor(position.x, position.y, this, 'setPosition');
    },
    setPosition: function () {
      this.translate(Point.read(arguments).subtract(this.getPosition(true)));
    },
    _getPositionFromBounds: function (bounds) {
      return this._pivot ? this._matrix._transformPoint(this._pivot) : (bounds || this.getBounds()).getCenter(true);
    },
    getPivot: function () {
      var pivot = this._pivot;
      return pivot ? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot') : null;
    },
    setPivot: function () {
      this._pivot = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });
      this._position = undefined;
    }
  }, Base.each({
    getStrokeBounds: {
      stroke: true
    },
    getHandleBounds: {
      handle: true
    },
    getInternalBounds: {
      internal: true
    }
  }, function (options, key) {
    this[key] = function (matrix) {
      return this.getBounds(matrix, options);
    };
  }, {
    beans: true,
    getBounds: function (matrix, options) {
      var hasMatrix = options || matrix instanceof Matrix,
          opts = Base.set({}, hasMatrix ? options : matrix, this._boundsOptions);
      if (!opts.stroke || this.getStrokeScaling()) opts.cacheItem = this;

      var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;

      return !arguments.length ? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height, this, 'setBounds') : rect;
    },
    setBounds: function () {
      var rect = Rectangle.read(arguments),
          bounds = this.getBounds(),
          _matrix = this._matrix,
          matrix = new Matrix(),
          center = rect.getCenter();
      matrix.translate(center);

      if (rect.width != bounds.width || rect.height != bounds.height) {
        if (!_matrix.isInvertible()) {
          _matrix.set(_matrix._backup || new Matrix().translate(_matrix.getTranslation()));

          bounds = this.getBounds();
        }

        matrix.scale(bounds.width !== 0 ? rect.width / bounds.width : 0, bounds.height !== 0 ? rect.height / bounds.height : 0);
      }

      center = bounds.getCenter();
      matrix.translate(-center.x, -center.y);
      this.transform(matrix);
    },
    _getBounds: function (matrix, options) {
      var children = this._children;
      if (!children || !children.length) return new Rectangle();

      Item._updateBoundsCache(this, options.cacheItem);

      return Item._getBounds(children, matrix, options);
    },
    _getBoundsCacheKey: function (options, internal) {
      return [options.stroke ? 1 : 0, options.handle ? 1 : 0, internal ? 1 : 0].join('');
    },
    _getCachedBounds: function (matrix, options, noInternal) {
      matrix = matrix && matrix._orNullIfIdentity();

      var internal = options.internal && !noInternal,
          cacheItem = options.cacheItem,
          _matrix = internal ? null : this._matrix._orNullIfIdentity(),
          cacheKey = cacheItem && (!matrix || matrix.equals(_matrix)) && this._getBoundsCacheKey(options, internal),
          bounds = this._bounds;

      Item._updateBoundsCache(this._parent || this._symbol, cacheItem);

      if (cacheKey && bounds && cacheKey in bounds) {
        var cached = bounds[cacheKey];
        return {
          rect: cached.rect.clone(),
          nonscaling: cached.nonscaling
        };
      }

      var res = this._getBounds(matrix || _matrix, options),
          rect = res.rect || res,
          style = this._style,
          nonscaling = res.nonscaling || style.hasStroke() && !style.getStrokeScaling();

      if (cacheKey) {
        if (!bounds) {
          this._bounds = bounds = {};
        }

        var cached = bounds[cacheKey] = {
          rect: rect.clone(),
          nonscaling: nonscaling,
          internal: internal
        };
      }

      return {
        rect: rect,
        nonscaling: nonscaling
      };
    },
    _getStrokeMatrix: function (matrix, options) {
      var parent = this.getStrokeScaling() ? null : options && options.internal ? this : this._parent || this._symbol && this._symbol._item,
          mx = parent ? parent.getViewMatrix().invert() : matrix;
      return mx && mx._shiftless();
    },
    statics: {
      _updateBoundsCache: function (parent, item) {
        if (parent && item) {
          var id = item._id,
              ref = parent._boundsCache = parent._boundsCache || {
            ids: {},
            list: []
          };

          if (!ref.ids[id]) {
            ref.list.push(item);
            ref.ids[id] = item;
          }
        }
      },
      _clearBoundsCache: function (item) {
        var cache = item._boundsCache;

        if (cache) {
          item._bounds = item._position = item._boundsCache = undefined;

          for (var i = 0, list = cache.list, l = list.length; i < l; i++) {
            var other = list[i];

            if (other !== item) {
              other._bounds = other._position = undefined;
              if (other._boundsCache) Item._clearBoundsCache(other);
            }
          }
        }
      },
      _getBounds: function (items, matrix, options) {
        var x1 = Infinity,
            x2 = -x1,
            y1 = x1,
            y2 = x2,
            nonscaling = false;
        options = options || {};

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i];

          if (item._visible && !item.isEmpty(true)) {
            var bounds = item._getCachedBounds(matrix && matrix.appended(item._matrix), options, true),
                rect = bounds.rect;

            x1 = Math.min(rect.x, x1);
            y1 = Math.min(rect.y, y1);
            x2 = Math.max(rect.x + rect.width, x2);
            y2 = Math.max(rect.y + rect.height, y2);
            if (bounds.nonscaling) nonscaling = true;
          }
        }

        return {
          rect: isFinite(x1) ? new Rectangle(x1, y1, x2 - x1, y2 - y1) : new Rectangle(),
          nonscaling: nonscaling
        };
      }
    }
  }), {
    beans: true,
    _decompose: function () {
      return this._applyMatrix ? null : this._decomposed || (this._decomposed = this._matrix.decompose());
    },
    getRotation: function () {
      var decomposed = this._decompose();

      return decomposed ? decomposed.rotation : 0;
    },
    setRotation: function (rotation) {
      var current = this.getRotation();

      if (current != null && rotation != null) {
        var decomposed = this._decomposed;
        this.rotate(rotation - current);

        if (decomposed) {
          decomposed.rotation = rotation;
          this._decomposed = decomposed;
        }
      }
    },
    getScaling: function () {
      var decomposed = this._decompose(),
          s = decomposed && decomposed.scaling;

      return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');
    },
    setScaling: function () {
      var current = this.getScaling(),
          scaling = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });

      if (current && scaling && !current.equals(scaling)) {
        var rotation = this.getRotation(),
            decomposed = this._decomposed,
            matrix = new Matrix(),
            isZero = Numerical.isZero;

        if (isZero(current.x) || isZero(current.y)) {
          matrix.translate(decomposed.translation);

          if (rotation) {
            matrix.rotate(rotation);
          }

          matrix.scale(scaling.x, scaling.y);

          this._matrix.set(matrix);
        } else {
          var center = this.getPosition(true);
          matrix.translate(center);
          if (rotation) matrix.rotate(rotation);
          matrix.scale(scaling.x / current.x, scaling.y / current.y);
          if (rotation) matrix.rotate(-rotation);
          matrix.translate(center.negate());
          this.transform(matrix);
        }

        if (decomposed) {
          decomposed.scaling = scaling;
          this._decomposed = decomposed;
        }
      }
    },
    getMatrix: function () {
      return this._matrix;
    },
    setMatrix: function () {
      var matrix = this._matrix;
      matrix.set.apply(matrix, arguments);
    },
    getGlobalMatrix: function (_dontClone) {
      var matrix = this._globalMatrix;

      if (matrix) {
        var parent = this._parent;
        var parents = [];

        while (parent) {
          if (!parent._globalMatrix) {
            matrix = null;

            for (var i = 0, l = parents.length; i < l; i++) {
              parents[i]._globalMatrix = null;
            }

            break;
          }

          parents.push(parent);
          parent = parent._parent;
        }
      }

      if (!matrix) {
        matrix = this._globalMatrix = this._matrix.clone();
        var parent = this._parent;
        if (parent) matrix.prepend(parent.getGlobalMatrix(true));
      }

      return _dontClone ? matrix : matrix.clone();
    },
    getViewMatrix: function () {
      return this.getGlobalMatrix().prepend(this.getView()._matrix);
    },
    getApplyMatrix: function () {
      return this._applyMatrix;
    },
    setApplyMatrix: function (apply) {
      if (this._applyMatrix = this._canApplyMatrix && !!apply) this.transform(null, true);
    },
    getTransformContent: '#getApplyMatrix',
    setTransformContent: '#setApplyMatrix'
  }, {
    getProject: function () {
      return this._project;
    },
    _setProject: function (project, installEvents) {
      if (this._project !== project) {
        if (this._project) this._installEvents(false);
        this._project = project;
        var children = this._children;

        for (var i = 0, l = children && children.length; i < l; i++) children[i]._setProject(project);

        installEvents = true;
      }

      if (installEvents) this._installEvents(true);
    },
    getView: function () {
      return this._project._view;
    },
    _installEvents: function _installEvents(install) {
      _installEvents.base.call(this, install);

      var children = this._children;

      for (var i = 0, l = children && children.length; i < l; i++) children[i]._installEvents(install);
    },
    getLayer: function () {
      var parent = this;

      while (parent = parent._parent) {
        if (parent instanceof Layer) return parent;
      }

      return null;
    },
    getParent: function () {
      return this._parent;
    },
    setParent: function (item) {
      return item.addChild(this);
    },
    _getOwner: '#getParent',
    getChildren: function () {
      return this._children;
    },
    setChildren: function (items) {
      this.removeChildren();
      this.addChildren(items);
    },
    getFirstChild: function () {
      return this._children && this._children[0] || null;
    },
    getLastChild: function () {
      return this._children && this._children[this._children.length - 1] || null;
    },
    getNextSibling: function () {
      var owner = this._getOwner();

      return owner && owner._children[this._index + 1] || null;
    },
    getPreviousSibling: function () {
      var owner = this._getOwner();

      return owner && owner._children[this._index - 1] || null;
    },
    getIndex: function () {
      return this._index;
    },
    equals: function (item) {
      return item === this || item && this._class === item._class && this._style.equals(item._style) && this._matrix.equals(item._matrix) && this._locked === item._locked && this._visible === item._visible && this._blendMode === item._blendMode && this._opacity === item._opacity && this._clipMask === item._clipMask && this._guide === item._guide && this._equals(item) || false;
    },
    _equals: function (item) {
      return Base.equals(this._children, item._children);
    },
    clone: function (options) {
      var copy = new this.constructor(Item.NO_INSERT),
          children = this._children,
          insert = Base.pick(options ? options.insert : undefined, options === undefined || options === true),
          deep = Base.pick(options ? options.deep : undefined, true);
      if (children) copy.copyAttributes(this);
      if (!children || deep) copy.copyContent(this);
      if (!children) copy.copyAttributes(this);
      if (insert) copy.insertAbove(this);
      var name = this._name,
          parent = this._parent;

      if (name && parent) {
        var children = parent._children,
            orig = name,
            i = 1;

        while (children[name]) name = orig + ' ' + i++;

        if (name !== orig) copy.setName(name);
      }

      return copy;
    },
    copyContent: function (source) {
      var children = source._children;

      for (var i = 0, l = children && children.length; i < l; i++) {
        this.addChild(children[i].clone(false), true);
      }
    },
    copyAttributes: function (source, excludeMatrix) {
      this.setStyle(source._style);
      var keys = ['_locked', '_visible', '_blendMode', '_opacity', '_clipMask', '_guide'];

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        if (source.hasOwnProperty(key)) this[key] = source[key];
      }

      if (!excludeMatrix) this._matrix.set(source._matrix, true);
      this.setApplyMatrix(source._applyMatrix);
      this.setPivot(source._pivot);
      this.setSelection(source._selection);
      var data = source._data,
          name = source._name;
      this._data = data ? Base.clone(data) : null;
      if (name) this.setName(name);
    },
    rasterize: function (resolution, insert) {
      var bounds = this.getStrokeBounds(),
          scale = (resolution || this.getView().getResolution()) / 72,
          topLeft = bounds.getTopLeft().floor(),
          bottomRight = bounds.getBottomRight().ceil(),
          size = new Size(bottomRight.subtract(topLeft)),
          raster = new Raster(Item.NO_INSERT);

      if (!size.isZero()) {
        var canvas = CanvasProvider.getCanvas(size.multiply(scale)),
            ctx = canvas.getContext('2d'),
            matrix = new Matrix().scale(scale).translate(topLeft.negate());
        ctx.save();
        matrix.applyToContext(ctx);
        this.draw(ctx, new Base({
          matrices: [matrix]
        }));
        ctx.restore();
        raster.setCanvas(canvas);
      }

      raster.transform(new Matrix().translate(topLeft.add(size.divide(2))).scale(1 / scale));
      if (insert === undefined || insert) raster.insertAbove(this);
      return raster;
    },
    contains: function () {
      var matrix = this._matrix;
      return matrix.isInvertible() && !!this._contains(matrix._inverseTransform(Point.read(arguments)));
    },
    _contains: function (point) {
      var children = this._children;

      if (children) {
        for (var i = children.length - 1; i >= 0; i--) {
          if (children[i].contains(point)) return true;
        }

        return false;
      }

      return point.isInside(this.getInternalBounds());
    },
    isInside: function () {
      return Rectangle.read(arguments).contains(this.getBounds());
    },
    _asPathItem: function () {
      return new Path.Rectangle({
        rectangle: this.getInternalBounds(),
        matrix: this._matrix,
        insert: false
      });
    },
    intersects: function (item, _matrix) {
      if (!(item instanceof Item)) return false;
      return this._asPathItem().getIntersections(item._asPathItem(), null, _matrix, true).length > 0;
    }
  }, new function () {
    function hitTest() {
      var args = arguments;
      return this._hitTest(Point.read(args), HitResult.getOptions(args));
    }

    function hitTestAll() {
      var args = arguments,
          point = Point.read(args),
          options = HitResult.getOptions(args),
          all = [];

      this._hitTest(point, new Base({
        all: all
      }, options));

      return all;
    }

    function hitTestChildren(point, options, viewMatrix, _exclude) {
      var children = this._children;

      if (children) {
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];

          var res = child !== _exclude && child._hitTest(point, options, viewMatrix);

          if (res && !options.all) return res;
        }
      }

      return null;
    }

    Project.inject({
      hitTest: hitTest,
      hitTestAll: hitTestAll,
      _hitTest: hitTestChildren
    });
    return {
      hitTest: hitTest,
      hitTestAll: hitTestAll,
      _hitTestChildren: hitTestChildren
    };
  }(), {
    _hitTest: function (point, options, parentViewMatrix) {
      if (this._locked || !this._visible || this._guide && !options.guides || this.isEmpty()) {
        return null;
      }

      var matrix = this._matrix,
          viewMatrix = parentViewMatrix ? parentViewMatrix.appended(matrix) : this.getGlobalMatrix().prepend(this.getView()._matrix),
          tolerance = Math.max(options.tolerance, 1e-12),
          tolerancePadding = options._tolerancePadding = new Size(Path._getStrokePadding(tolerance, matrix._shiftless().invert()));
      point = matrix._inverseTransform(point);

      if (!point || !this._children && !this.getBounds({
        internal: true,
        stroke: true,
        handle: true
      }).expand(tolerancePadding.multiply(2))._containsPoint(point)) {
        return null;
      }

      var checkSelf = !(options.guides && !this._guide || options.selected && !this.isSelected() || options.type && options.type !== Base.hyphenate(this._class) || options.class && !(this instanceof options.class)),
          match = options.match,
          that = this,
          bounds,
          res;

      function filter(hit) {
        if (hit && match && !match(hit)) hit = null;
        if (hit && options.all) options.all.push(hit);
        return hit;
      }

      function checkPoint(type, part) {
        var pt = part ? bounds['get' + part]() : that.getPosition();

        if (point.subtract(pt).divide(tolerancePadding).length <= 1) {
          return new HitResult(type, that, {
            name: part ? Base.hyphenate(part) : type,
            point: pt
          });
        }
      }

      var checkPosition = options.position,
          checkCenter = options.center,
          checkBounds = options.bounds;

      if (checkSelf && this._parent && (checkPosition || checkCenter || checkBounds)) {
        if (checkCenter || checkBounds) {
          bounds = this.getInternalBounds();
        }

        res = checkPosition && checkPoint('position') || checkCenter && checkPoint('center', 'Center');

        if (!res && checkBounds) {
          var points = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'];

          for (var i = 0; i < 8 && !res; i++) {
            res = checkPoint('bounds', points[i]);
          }
        }

        res = filter(res);
      }

      if (!res) {
        res = this._hitTestChildren(point, options, viewMatrix) || checkSelf && filter(this._hitTestSelf(point, options, viewMatrix, this.getStrokeScaling() ? null : viewMatrix._shiftless().invert())) || null;
      }

      if (res && res.point) {
        res.point = matrix.transform(res.point);
      }

      return res;
    },
    _hitTestSelf: function (point, options) {
      if (options.fill && this.hasFill() && this._contains(point)) return new HitResult('fill', this);
    },
    matches: function (name, compare) {
      function matchObject(obj1, obj2) {
        for (var i in obj1) {
          if (obj1.hasOwnProperty(i)) {
            var val1 = obj1[i],
                val2 = obj2[i];

            if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
              if (!matchObject(val1, val2)) return false;
            } else if (!Base.equals(val1, val2)) {
              return false;
            }
          }
        }

        return true;
      }

      var type = typeof name;

      if (type === 'object') {
        for (var key in name) {
          if (name.hasOwnProperty(key) && !this.matches(key, name[key])) return false;
        }

        return true;
      } else if (type === 'function') {
        return name(this);
      } else if (name === 'match') {
        return compare(this);
      } else {
        var value = /^(empty|editable)$/.test(name) ? this['is' + Base.capitalize(name)]() : name === 'type' ? Base.hyphenate(this._class) : this[name];

        if (name === 'class') {
          if (typeof compare === 'function') return this instanceof compare;
          value = this._class;
        }

        if (typeof compare === 'function') {
          return !!compare(value);
        } else if (compare) {
          if (compare.test) {
            return compare.test(value);
          } else if (Base.isPlainObject(compare)) {
            return matchObject(compare, value);
          }
        }

        return Base.equals(value, compare);
      }
    },
    getItems: function (options) {
      return Item._getItems(this, options, this._matrix);
    },
    getItem: function (options) {
      return Item._getItems(this, options, this._matrix, null, true)[0] || null;
    },
    statics: {
      _getItems: function _getItems(item, options, matrix, param, firstOnly) {
        if (!param) {
          var obj = typeof options === 'object' && options,
              overlapping = obj && obj.overlapping,
              inside = obj && obj.inside,
              bounds = overlapping || inside,
              rect = bounds && Rectangle.read([bounds]);
          param = {
            items: [],
            recursive: obj && obj.recursive !== false,
            inside: !!inside,
            overlapping: !!overlapping,
            rect: rect,
            path: overlapping && new Path.Rectangle({
              rectangle: rect,
              insert: false
            })
          };

          if (obj) {
            options = Base.filter({}, options, {
              recursive: true,
              inside: true,
              overlapping: true
            });
          }
        }

        var children = item._children,
            items = param.items,
            rect = param.rect;
        matrix = rect && (matrix || new Matrix());

        for (var i = 0, l = children && children.length; i < l; i++) {
          var child = children[i],
              childMatrix = matrix && matrix.appended(child._matrix),
              add = true;

          if (rect) {
            var bounds = child.getBounds(childMatrix);
            if (!rect.intersects(bounds)) continue;
            if (!(rect.contains(bounds) || param.overlapping && (bounds.contains(rect) || param.path.intersects(child, childMatrix)))) add = false;
          }

          if (add && child.matches(options)) {
            items.push(child);
            if (firstOnly) break;
          }

          if (param.recursive !== false) {
            _getItems(child, options, childMatrix, param, firstOnly);
          }

          if (firstOnly && items.length > 0) break;
        }

        return items;
      }
    }
  }, {
    importJSON: function (json) {
      var res = Base.importJSON(json, this);
      return res !== this ? this.addChild(res) : res;
    },
    addChild: function (item) {
      return this.insertChild(undefined, item);
    },
    insertChild: function (index, item) {
      var res = item ? this.insertChildren(index, [item]) : null;
      return res && res[0];
    },
    addChildren: function (items) {
      return this.insertChildren(this._children.length, items);
    },
    insertChildren: function (index, items) {
      var children = this._children;

      if (children && items && items.length > 0) {
        items = Base.slice(items);
        var inserted = {};

        for (var i = items.length - 1; i >= 0; i--) {
          var item = items[i],
              id = item && item._id;

          if (!item || inserted[id]) {
            items.splice(i, 1);
          } else {
            item._remove(false, true);

            inserted[id] = true;
          }
        }

        Base.splice(children, items, index, 0);
        var project = this._project,
            notifySelf = project._changes;

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i],
              name = item._name;
          item._parent = this;

          item._setProject(project, true);

          if (name) item.setName(name);
          if (notifySelf) item._changed(5);
        }

        this._changed(11);
      } else {
        items = null;
      }

      return items;
    },
    _insertItem: '#insertChild',
    _insertAt: function (item, offset) {
      var owner = item && item._getOwner(),
          res = item !== this && owner ? this : null;

      if (res) {
        res._remove(false, true);

        owner._insertItem(item._index + offset, res);
      }

      return res;
    },
    insertAbove: function (item) {
      return this._insertAt(item, 1);
    },
    insertBelow: function (item) {
      return this._insertAt(item, 0);
    },
    sendToBack: function () {
      var owner = this._getOwner();

      return owner ? owner._insertItem(0, this) : null;
    },
    bringToFront: function () {
      var owner = this._getOwner();

      return owner ? owner._insertItem(undefined, this) : null;
    },
    appendTop: '#addChild',
    appendBottom: function (item) {
      return this.insertChild(0, item);
    },
    moveAbove: '#insertAbove',
    moveBelow: '#insertBelow',
    addTo: function (owner) {
      return owner._insertItem(undefined, this);
    },
    copyTo: function (owner) {
      return this.clone(false).addTo(owner);
    },
    reduce: function (options) {
      var children = this._children;

      if (children && children.length === 1) {
        var child = children[0].reduce(options);

        if (this._parent) {
          child.insertAbove(this);
          this.remove();
        } else {
          child.remove();
        }

        return child;
      }

      return this;
    },
    _removeNamed: function () {
      var owner = this._getOwner();

      if (owner) {
        var children = owner._children,
            namedChildren = owner._namedChildren,
            name = this._name,
            namedArray = namedChildren[name],
            index = namedArray ? namedArray.indexOf(this) : -1;

        if (index !== -1) {
          if (children[name] == this) delete children[name];
          namedArray.splice(index, 1);

          if (namedArray.length) {
            children[name] = namedArray[0];
          } else {
            delete namedChildren[name];
          }
        }
      }
    },
    _remove: function (notifySelf, notifyParent) {
      var owner = this._getOwner(),
          project = this._project,
          index = this._index;

      if (this._style) this._style._dispose();

      if (owner) {
        if (this._name) this._removeNamed();

        if (index != null) {
          if (project._activeLayer === this) project._activeLayer = this.getNextSibling() || this.getPreviousSibling();
          Base.splice(owner._children, null, index, 1);
        }

        this._installEvents(false);

        if (notifySelf && project._changes) this._changed(5);
        if (notifyParent) owner._changed(11, this);
        this._parent = null;
        return true;
      }

      return false;
    },
    remove: function () {
      return this._remove(true, true);
    },
    replaceWith: function (item) {
      var ok = item && item.insertBelow(this);
      if (ok) this.remove();
      return ok;
    },
    removeChildren: function (start, end) {
      if (!this._children) return null;
      start = start || 0;
      end = Base.pick(end, this._children.length);
      var removed = Base.splice(this._children, null, start, end - start);

      for (var i = removed.length - 1; i >= 0; i--) {
        removed[i]._remove(true, false);
      }

      if (removed.length > 0) this._changed(11);
      return removed;
    },
    clear: '#removeChildren',
    reverseChildren: function () {
      if (this._children) {
        this._children.reverse();

        for (var i = 0, l = this._children.length; i < l; i++) this._children[i]._index = i;

        this._changed(11);
      }
    },
    isEmpty: function (recursively) {
      var children = this._children;
      var numChildren = children ? children.length : 0;

      if (recursively) {
        for (var i = 0; i < numChildren; i++) {
          if (!children[i].isEmpty(recursively)) {
            return false;
          }
        }

        return true;
      }

      return !numChildren;
    },
    isEditable: function () {
      var item = this;

      while (item) {
        if (!item._visible || item._locked) return false;
        item = item._parent;
      }

      return true;
    },
    hasFill: function () {
      return this.getStyle().hasFill();
    },
    hasStroke: function () {
      return this.getStyle().hasStroke();
    },
    hasShadow: function () {
      return this.getStyle().hasShadow();
    },
    _getOrder: function (item) {
      function getList(item) {
        var list = [];

        do {
          list.unshift(item);
        } while (item = item._parent);

        return list;
      }

      var list1 = getList(this),
          list2 = getList(item);

      for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
        if (list1[i] != list2[i]) {
          return list1[i]._index < list2[i]._index ? 1 : -1;
        }
      }

      return 0;
    },
    hasChildren: function () {
      return this._children && this._children.length > 0;
    },
    isInserted: function () {
      return this._parent ? this._parent.isInserted() : false;
    },
    isAbove: function (item) {
      return this._getOrder(item) === -1;
    },
    isBelow: function (item) {
      return this._getOrder(item) === 1;
    },
    isParent: function (item) {
      return this._parent === item;
    },
    isChild: function (item) {
      return item && item._parent === this;
    },
    isDescendant: function (item) {
      var parent = this;

      while (parent = parent._parent) {
        if (parent === item) return true;
      }

      return false;
    },
    isAncestor: function (item) {
      return item ? item.isDescendant(this) : false;
    },
    isSibling: function (item) {
      return this._parent === item._parent;
    },
    isGroupedWith: function (item) {
      var parent = this._parent;

      while (parent) {
        if (parent._parent && /^(Group|Layer|CompoundPath)$/.test(parent._class) && item.isDescendant(parent)) return true;
        parent = parent._parent;
      }

      return false;
    }
  }, Base.each(['rotate', 'scale', 'shear', 'skew'], function (key) {
    var rotate = key === 'rotate';

    this[key] = function () {
      var args = arguments,
          value = (rotate ? Base : Point).read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      return this.transform(new Matrix()[key](value, center || this.getPosition(true)));
    };
  }, {
    translate: function () {
      var mx = new Matrix();
      return this.transform(mx.translate.apply(mx, arguments));
    },
    transform: function (matrix, _applyRecursively, _setApplyMatrix) {
      var _matrix = this._matrix,
          transformMatrix = matrix && !matrix.isIdentity(),
          applyMatrix = _setApplyMatrix && this._canApplyMatrix || this._applyMatrix && (transformMatrix || !_matrix.isIdentity() || _applyRecursively && this._children);
      if (!transformMatrix && !applyMatrix) return this;

      if (transformMatrix) {
        if (!matrix.isInvertible() && _matrix.isInvertible()) _matrix._backup = _matrix.getValues();

        _matrix.prepend(matrix, true);

        var style = this._style,
            fillColor = style.getFillColor(true),
            strokeColor = style.getStrokeColor(true);
        if (fillColor) fillColor.transform(matrix);
        if (strokeColor) strokeColor.transform(matrix);
      }

      if (applyMatrix && (applyMatrix = this._transformContent(_matrix, _applyRecursively, _setApplyMatrix))) {
        var pivot = this._pivot;
        if (pivot) _matrix._transformPoint(pivot, pivot, true);

        _matrix.reset(true);

        if (_setApplyMatrix && this._canApplyMatrix) this._applyMatrix = true;
      }

      var bounds = this._bounds,
          position = this._position;

      if (transformMatrix || applyMatrix) {
        this._changed(25);
      }

      var decomp = transformMatrix && bounds && matrix.decompose();

      if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
        for (var key in bounds) {
          var cache = bounds[key];

          if (cache.nonscaling) {
            delete bounds[key];
          } else if (applyMatrix || !cache.internal) {
            var rect = cache.rect;

            matrix._transformBounds(rect, rect);
          }
        }

        this._bounds = bounds;

        var cached = bounds[this._getBoundsCacheKey(this._boundsOptions || {})];

        if (cached) {
          this._position = this._getPositionFromBounds(cached.rect);
        }
      } else if (transformMatrix && position && this._pivot) {
        this._position = matrix._transformPoint(position, position);
      }

      return this;
    },
    _transformContent: function (matrix, applyRecursively, setApplyMatrix) {
      var children = this._children;

      if (children) {
        for (var i = 0, l = children.length; i < l; i++) {
          children[i].transform(matrix, applyRecursively, setApplyMatrix);
        }

        return true;
      }
    },
    globalToLocal: function () {
      return this.getGlobalMatrix(true)._inverseTransform(Point.read(arguments));
    },
    localToGlobal: function () {
      return this.getGlobalMatrix(true)._transformPoint(Point.read(arguments));
    },
    parentToLocal: function () {
      return this._matrix._inverseTransform(Point.read(arguments));
    },
    localToParent: function () {
      return this._matrix._transformPoint(Point.read(arguments));
    },
    fitBounds: function (rectangle, fill) {
      rectangle = Rectangle.read(arguments);
      var bounds = this.getBounds(),
          itemRatio = bounds.height / bounds.width,
          rectRatio = rectangle.height / rectangle.width,
          scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio) ? rectangle.width / bounds.width : rectangle.height / bounds.height,
          newBounds = new Rectangle(new Point(), new Size(bounds.width * scale, bounds.height * scale));
      newBounds.setCenter(rectangle.getCenter());
      this.setBounds(newBounds);
    }
  }), {
    _setStyles: function (ctx, param, viewMatrix) {
      var style = this._style,
          matrix = this._matrix;

      if (style.hasFill()) {
        ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);
      }

      if (style.hasStroke()) {
        ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);
        ctx.lineWidth = style.getStrokeWidth();
        var strokeJoin = style.getStrokeJoin(),
            strokeCap = style.getStrokeCap(),
            miterLimit = style.getMiterLimit();
        if (strokeJoin) ctx.lineJoin = strokeJoin;
        if (strokeCap) ctx.lineCap = strokeCap;
        if (miterLimit) ctx.miterLimit = miterLimit;

        if (paper.support.nativeDash) {
          var dashArray = style.getDashArray(),
              dashOffset = style.getDashOffset();

          if (dashArray && dashArray.length) {
            if ('setLineDash' in ctx) {
              ctx.setLineDash(dashArray);
              ctx.lineDashOffset = dashOffset;
            } else {
              ctx.mozDash = dashArray;
              ctx.mozDashOffset = dashOffset;
            }
          }
        }
      }

      if (style.hasShadow()) {
        var pixelRatio = param.pixelRatio || 1,
            mx = viewMatrix._shiftless().prepend(new Matrix().scale(pixelRatio, pixelRatio)),
            blur = mx.transform(new Point(style.getShadowBlur(), 0)),
            offset = mx.transform(this.getShadowOffset());

        ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
        ctx.shadowBlur = blur.getLength();
        ctx.shadowOffsetX = offset.x;
        ctx.shadowOffsetY = offset.y;
      }
    },
    draw: function (ctx, param, parentStrokeMatrix) {
      var updateVersion = this._updateVersion = this._project._updateVersion;
      if (!this._visible || this._opacity === 0) return;
      var matrices = param.matrices,
          viewMatrix = param.viewMatrix,
          matrix = this._matrix,
          globalMatrix = matrices[matrices.length - 1].appended(matrix);
      if (!globalMatrix.isInvertible()) return;
      viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix) : globalMatrix;
      matrices.push(globalMatrix);

      if (param.updateMatrix) {
        this._globalMatrix = globalMatrix;
      }

      var blendMode = this._blendMode,
          opacity = Numerical.clamp(this._opacity, 0, 1),
          normalBlend = blendMode === 'normal',
          nativeBlend = BlendMode.nativeModes[blendMode],
          direct = normalBlend && opacity === 1 || param.dontStart || param.clip || (nativeBlend || normalBlend && opacity < 1) && this._canComposite(),
          pixelRatio = param.pixelRatio || 1,
          mainCtx,
          itemOffset,
          prevOffset;

      if (!direct) {
        var bounds = this.getStrokeBounds(viewMatrix);

        if (!bounds.width || !bounds.height) {
          matrices.pop();
          return;
        }

        prevOffset = param.offset;
        itemOffset = param.offset = bounds.getTopLeft().floor();
        mainCtx = ctx;
        ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1).multiply(pixelRatio));
        if (pixelRatio !== 1) ctx.scale(pixelRatio, pixelRatio);
      }

      ctx.save();
      var strokeMatrix = parentStrokeMatrix ? parentStrokeMatrix.appended(matrix) : this._canScaleStroke && !this.getStrokeScaling(true) && viewMatrix,
          clip = !direct && param.clipItem,
          transform = !strokeMatrix || clip;

      if (direct) {
        ctx.globalAlpha = opacity;
        if (nativeBlend) ctx.globalCompositeOperation = blendMode;
      } else if (transform) {
        ctx.translate(-itemOffset.x, -itemOffset.y);
      }

      if (transform) {
        (direct ? matrix : viewMatrix).applyToContext(ctx);
      }

      if (clip) {
        param.clipItem.draw(ctx, param.extend({
          clip: true
        }));
      }

      if (strokeMatrix) {
        ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        var offset = param.offset;
        if (offset) ctx.translate(-offset.x, -offset.y);
      }

      this._draw(ctx, param, viewMatrix, strokeMatrix);

      ctx.restore();
      matrices.pop();

      if (param.clip && !param.dontFinish) {
        ctx.clip(this.getFillRule());
      }

      if (!direct) {
        BlendMode.process(blendMode, ctx, mainCtx, opacity, itemOffset.subtract(prevOffset).multiply(pixelRatio));
        CanvasProvider.release(ctx);
        param.offset = prevOffset;
      }
    },
    _isUpdated: function (updateVersion) {
      var parent = this._parent;
      if (parent instanceof CompoundPath) return parent._isUpdated(updateVersion);
      var updated = this._updateVersion === updateVersion;

      if (!updated && parent && parent._visible && parent._isUpdated(updateVersion)) {
        this._updateVersion = updateVersion;
        updated = true;
      }

      return updated;
    },
    _drawSelection: function (ctx, matrix, size, selectionItems, updateVersion) {
      var selection = this._selection,
          itemSelected = selection & 1,
          boundsSelected = selection & 2 || itemSelected && this._selectBounds,
          positionSelected = selection & 4;
      if (!this._drawSelected) itemSelected = false;

      if ((itemSelected || boundsSelected || positionSelected) && this._isUpdated(updateVersion)) {
        var layer,
            color = this.getSelectedColor(true) || (layer = this.getLayer()) && layer.getSelectedColor(true),
            mx = matrix.appended(this.getGlobalMatrix(true)),
            half = size / 2;
        ctx.strokeStyle = ctx.fillStyle = color ? color.toCanvasStyle(ctx) : '#009dec';
        if (itemSelected) this._drawSelected(ctx, mx, selectionItems);

        if (positionSelected) {
          var pos = this.getPosition(true),
              parent = this._parent,
              point = parent ? parent.localToGlobal(pos) : pos,
              x = point.x,
              y = point.y;
          ctx.beginPath();
          ctx.arc(x, y, half, 0, Math.PI * 2, true);
          ctx.stroke();
          var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],
              start = half,
              end = size + 1;

          for (var i = 0; i < 4; i++) {
            var delta = deltas[i],
                dx = delta[0],
                dy = delta[1];
            ctx.moveTo(x + dx * start, y + dy * start);
            ctx.lineTo(x + dx * end, y + dy * end);
            ctx.stroke();
          }
        }

        if (boundsSelected) {
          var coords = mx._transformCorners(this.getInternalBounds());

          ctx.beginPath();

          for (var i = 0; i < 8; i++) {
            ctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
          }

          ctx.closePath();
          ctx.stroke();

          for (var i = 0; i < 8; i++) {
            ctx.fillRect(coords[i] - half, coords[++i] - half, size, size);
          }
        }
      }
    },
    _canComposite: function () {
      return false;
    }
  }, Base.each(['down', 'drag', 'up', 'move'], function (key) {
    this['removeOn' + Base.capitalize(key)] = function () {
      var hash = {};
      hash[key] = true;
      return this.removeOn(hash);
    };
  }, {
    removeOn: function (obj) {
      for (var name in obj) {
        if (obj[name]) {
          var key = 'mouse' + name,
              project = this._project,
              sets = project._removeSets = project._removeSets || {};
          sets[key] = sets[key] || {};
          sets[key][this._id] = this;
        }
      }

      return this;
    }
  }), {
    tween: function (from, to, options) {
      if (!options) {
        options = to;
        to = from;
        from = null;

        if (!options) {
          options = to;
          to = null;
        }
      }

      var easing = options && options.easing,
          start = options && options.start,
          duration = options != null && (typeof options === 'number' ? options : options.duration),
          tween = new Tween(this, from, to, duration, easing, start);

      function onFrame(event) {
        tween._handleFrame(event.time * 1000);

        if (!tween.running) {
          this.off('frame', onFrame);
        }
      }

      if (duration) {
        this.on('frame', onFrame);
      }

      return tween;
    },
    tweenTo: function (to, options) {
      return this.tween(null, to, options);
    },
    tweenFrom: function (from, options) {
      return this.tween(from, null, options);
    }
  });
  var Group = Item.extend({
    _class: 'Group',
    _selectBounds: false,
    _selectChildren: true,
    _serializeFields: {
      children: []
    },
    initialize: function Group(arg) {
      this._children = [];
      this._namedChildren = {};
      if (!this._initialize(arg)) this.addChildren(Array.isArray(arg) ? arg : arguments);
    },
    _changed: function _changed(flags) {
      _changed.base.call(this, flags);

      if (flags & 2050) {
        this._clipItem = undefined;
      }
    },
    _getClipItem: function () {
      var clipItem = this._clipItem;

      if (clipItem === undefined) {
        clipItem = null;
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) {
          if (children[i]._clipMask) {
            clipItem = children[i];
            break;
          }
        }

        this._clipItem = clipItem;
      }

      return clipItem;
    },
    isClipped: function () {
      return !!this._getClipItem();
    },
    setClipped: function (clipped) {
      var child = this.getFirstChild();
      if (child) child.setClipMask(clipped);
    },
    _getBounds: function _getBounds(matrix, options) {
      var clipItem = this._getClipItem();

      return clipItem ? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix), Base.set({}, options, {
        stroke: false
      })) : _getBounds.base.call(this, matrix, options);
    },
    _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
      var clipItem = this._getClipItem();

      return (!clipItem || clipItem.contains(point)) && _hitTestChildren.base.call(this, point, options, viewMatrix, clipItem);
    },
    _draw: function (ctx, param) {
      var clip = param.clip,
          clipItem = !clip && this._getClipItem();

      param = param.extend({
        clipItem: clipItem,
        clip: false
      });

      if (clip) {
        ctx.beginPath();
        param.dontStart = param.dontFinish = true;
      } else if (clipItem) {
        clipItem.draw(ctx, param.extend({
          clip: true
        }));
      }

      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        var item = children[i];
        if (item !== clipItem) item.draw(ctx, param);
      }
    }
  });
  var Layer = Group.extend({
    _class: 'Layer',
    initialize: function Layer() {
      Group.apply(this, arguments);
    },
    _getOwner: function () {
      return this._parent || this._index != null && this._project;
    },
    isInserted: function isInserted() {
      return this._parent ? isInserted.base.call(this) : this._index != null;
    },
    activate: function () {
      this._project._activeLayer = this;
    },
    _hitTestSelf: function () {}
  });
  var Shape = Item.extend({
    _class: 'Shape',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _canScaleStroke: true,
    _serializeFields: {
      type: null,
      size: null,
      radius: null
    },
    initialize: function Shape(props, point) {
      this._initialize(props, point);
    },
    _equals: function (item) {
      return this._type === item._type && this._size.equals(item._size) && Base.equals(this._radius, item._radius);
    },
    copyContent: function (source) {
      this.setType(source._type);
      this.setSize(source._size);
      this.setRadius(source._radius);
    },
    getType: function () {
      return this._type;
    },
    setType: function (type) {
      this._type = type;
    },
    getShape: '#getType',
    setShape: '#setType',
    getSize: function () {
      var size = this._size;
      return new LinkedSize(size.width, size.height, this, 'setSize');
    },
    setSize: function () {
      var size = Size.read(arguments);

      if (!this._size) {
        this._size = size.clone();
      } else if (!this._size.equals(size)) {
        var type = this._type,
            width = size.width,
            height = size.height;

        if (type === 'rectangle') {
          this._radius.set(Size.min(this._radius, size.divide(2).abs()));
        } else if (type === 'circle') {
          width = height = (width + height) / 2;
          this._radius = width / 2;
        } else if (type === 'ellipse') {
          this._radius._set(width / 2, height / 2);
        }

        this._size._set(width, height);

        this._changed(9);
      }
    },
    getRadius: function () {
      var rad = this._radius;
      return this._type === 'circle' ? rad : new LinkedSize(rad.width, rad.height, this, 'setRadius');
    },
    setRadius: function (radius) {
      var type = this._type;

      if (type === 'circle') {
        if (radius === this._radius) return;
        var size = radius * 2;
        this._radius = radius;

        this._size._set(size, size);
      } else {
        radius = Size.read(arguments);

        if (!this._radius) {
          this._radius = radius.clone();
        } else {
          if (this._radius.equals(radius)) return;

          this._radius.set(radius);

          if (type === 'rectangle') {
            var size = Size.max(this._size, radius.multiply(2));

            this._size.set(size);
          } else if (type === 'ellipse') {
            this._size._set(radius.width * 2, radius.height * 2);
          }
        }
      }

      this._changed(9);
    },
    isEmpty: function () {
      return false;
    },
    toPath: function (insert) {
      var path = new Path[Base.capitalize(this._type)]({
        center: new Point(),
        size: this._size,
        radius: this._radius,
        insert: false
      });
      path.copyAttributes(this);
      if (paper.settings.applyMatrix) path.setApplyMatrix(true);
      if (insert === undefined || insert) path.insertAbove(this);
      return path;
    },
    toShape: '#clone',
    _asPathItem: function () {
      return this.toPath(false);
    },
    _draw: function (ctx, param, viewMatrix, strokeMatrix) {
      var style = this._style,
          hasFill = style.hasFill(),
          hasStroke = style.hasStroke(),
          dontPaint = param.dontFinish || param.clip,
          untransformed = !strokeMatrix;

      if (hasFill || hasStroke || dontPaint) {
        var type = this._type,
            radius = this._radius,
            isCircle = type === 'circle';
        if (!param.dontStart) ctx.beginPath();

        if (untransformed && isCircle) {
          ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
        } else {
          var rx = isCircle ? radius : radius.width,
              ry = isCircle ? radius : radius.height,
              size = this._size,
              width = size.width,
              height = size.height;

          if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
            ctx.rect(-width / 2, -height / 2, width, height);
          } else {
            var x = width / 2,
                y = height / 2,
                kappa = 1 - 0.5522847498307936,
                cx = rx * kappa,
                cy = ry * kappa,
                c = [-x, -y + ry, -x, -y + cy, -x + cx, -y, -x + rx, -y, x - rx, -y, x - cx, -y, x, -y + cy, x, -y + ry, x, y - ry, x, y - cy, x - cx, y, x - rx, y, -x + rx, y, -x + cx, y, -x, y - cy, -x, y - ry];
            if (strokeMatrix) strokeMatrix.transform(c, c, 32);
            ctx.moveTo(c[0], c[1]);
            ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
            if (x !== rx) ctx.lineTo(c[8], c[9]);
            ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
            if (y !== ry) ctx.lineTo(c[16], c[17]);
            ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
            if (x !== rx) ctx.lineTo(c[24], c[25]);
            ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
          }
        }

        ctx.closePath();
      }

      if (!dontPaint && (hasFill || hasStroke)) {
        this._setStyles(ctx, param, viewMatrix);

        if (hasFill) {
          ctx.fill(style.getFillRule());
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (hasStroke) ctx.stroke();
      }
    },
    _canComposite: function () {
      return !(this.hasFill() && this.hasStroke());
    },
    _getBounds: function (matrix, options) {
      var rect = new Rectangle(this._size).setCenter(0, 0),
          style = this._style,
          strokeWidth = options.stroke && style.hasStroke() && style.getStrokeWidth();
      if (matrix) rect = matrix._transformBounds(rect);
      return strokeWidth ? rect.expand(Path._getStrokePadding(strokeWidth, this._getStrokeMatrix(matrix, options))) : rect;
    }
  }, new function () {
    function getCornerCenter(that, point, expand) {
      var radius = that._radius;

      if (!radius.isZero()) {
        var halfSize = that._size.divide(2);

        for (var q = 1; q <= 4; q++) {
          var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),
              corner = dir.multiply(halfSize),
              center = corner.subtract(dir.multiply(radius)),
              rect = new Rectangle(expand ? corner.add(dir.multiply(expand)) : corner, center);
          if (rect.contains(point)) return {
            point: center,
            quadrant: q
          };
        }
      }
    }

    function isOnEllipseStroke(point, radius, padding, quadrant) {
      var vector = point.divide(radius);
      return (!quadrant || vector.isInQuadrant(quadrant)) && vector.subtract(vector.normalize()).multiply(radius).divide(padding).length <= 1;
    }

    return {
      _contains: function _contains(point) {
        if (this._type === 'rectangle') {
          var center = getCornerCenter(this, point);
          return center ? point.subtract(center.point).divide(this._radius).getLength() <= 1 : _contains.base.call(this, point);
        } else {
          return point.divide(this.size).getLength() <= 0.5;
        }
      },
      _hitTestSelf: function _hitTestSelf(point, options, viewMatrix, strokeMatrix) {
        var hit = false,
            style = this._style,
            hitStroke = options.stroke && style.hasStroke(),
            hitFill = options.fill && style.hasFill();

        if (hitStroke || hitFill) {
          var type = this._type,
              radius = this._radius,
              strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,
              strokePadding = options._tolerancePadding.add(Path._getStrokePadding(strokeRadius, !style.getStrokeScaling() && strokeMatrix));

          if (type === 'rectangle') {
            var padding = strokePadding.multiply(2),
                center = getCornerCenter(this, point, padding);

            if (center) {
              hit = isOnEllipseStroke(point.subtract(center.point), radius, strokePadding, center.quadrant);
            } else {
              var rect = new Rectangle(this._size).setCenter(0, 0),
                  outer = rect.expand(padding),
                  inner = rect.expand(padding.negate());
              hit = outer._containsPoint(point) && !inner._containsPoint(point);
            }
          } else {
            hit = isOnEllipseStroke(point, radius, strokePadding);
          }
        }

        return hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this) : _hitTestSelf.base.apply(this, arguments);
      }
    };
  }(), {
    statics: new function () {
      function createShape(type, point, size, radius, args) {
        var item = Base.create(Shape.prototype);
        item._type = type;
        item._size = size;
        item._radius = radius;

        item._initialize(Base.getNamed(args), point);

        return item;
      }

      return {
        Circle: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              radius = Base.readNamed(args, 'radius');
          return createShape('circle', center, new Size(radius * 2), radius, args);
        },
        Rectangle: function () {
          var args = arguments,
              rect = Rectangle.readNamed(args, 'rectangle'),
              radius = Size.min(Size.readNamed(args, 'radius'), rect.getSize(true).divide(2));
          return createShape('rectangle', rect.getCenter(true), rect.getSize(true), radius, args);
        },
        Ellipse: function () {
          var args = arguments,
              ellipse = Shape._readEllipse(args),
              radius = ellipse.radius;

          return createShape('ellipse', ellipse.center, radius.multiply(2), radius, args);
        },
        _readEllipse: function (args) {
          var center, radius;

          if (Base.hasNamed(args, 'radius')) {
            center = Point.readNamed(args, 'center');
            radius = Size.readNamed(args, 'radius');
          } else {
            var rect = Rectangle.readNamed(args, 'rectangle');
            center = rect.getCenter(true);
            radius = rect.getSize(true).divide(2);
          }

          return {
            center: center,
            radius: radius
          };
        }
      };
    }()
  });
  var Raster = Item.extend({
    _class: 'Raster',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsOptions: {
      stroke: false,
      handle: false
    },
    _serializeFields: {
      crossOrigin: null,
      source: null
    },
    _prioritize: ['crossOrigin'],
    _smoothing: true,
    beans: true,
    initialize: function Raster(source, position) {
      if (!this._initialize(source, position !== undefined && Point.read(arguments))) {
        var image,
            type = typeof source,
            object = type === 'string' ? document.getElementById(source) : type === 'object' ? source : null;

        if (object && object !== Item.NO_INSERT) {
          if (object.getContext || object.naturalHeight != null) {
            image = object;
          } else if (object) {
            var size = Size.read(arguments);

            if (!size.isZero()) {
              image = CanvasProvider.getCanvas(size);
            }
          }
        }

        if (image) {
          this.setImage(image);
        } else {
          this.setSource(source);
        }
      }

      if (!this._size) {
        this._size = new Size();
        this._loaded = false;
      }
    },
    _equals: function (item) {
      return this.getSource() === item.getSource();
    },
    copyContent: function (source) {
      var image = source._image,
          canvas = source._canvas;

      if (image) {
        this._setImage(image);
      } else if (canvas) {
        var copyCanvas = CanvasProvider.getCanvas(source._size);
        copyCanvas.getContext('2d').drawImage(canvas, 0, 0);

        this._setImage(copyCanvas);
      }

      this._crossOrigin = source._crossOrigin;
    },
    getSize: function () {
      var size = this._size;
      return new LinkedSize(size ? size.width : 0, size ? size.height : 0, this, 'setSize');
    },
    setSize: function () {
      var size = Size.read(arguments);

      if (!size.equals(this._size)) {
        if (size.width > 0 && size.height > 0) {
          var element = this.getElement();

          this._setImage(CanvasProvider.getCanvas(size));

          if (element) this.getContext(true).drawImage(element, 0, 0, size.width, size.height);
        } else {
          if (this._canvas) CanvasProvider.release(this._canvas);
          this._size = size.clone();
        }
      }
    },
    getWidth: function () {
      return this._size ? this._size.width : 0;
    },
    setWidth: function (width) {
      this.setSize(width, this.getHeight());
    },
    getHeight: function () {
      return this._size ? this._size.height : 0;
    },
    setHeight: function (height) {
      this.setSize(this.getWidth(), height);
    },
    getLoaded: function () {
      return this._loaded;
    },
    isEmpty: function () {
      var size = this._size;
      return !size || size.width === 0 && size.height === 0;
    },
    getResolution: function () {
      var matrix = this._matrix,
          orig = new Point(0, 0).transform(matrix),
          u = new Point(1, 0).transform(matrix).subtract(orig),
          v = new Point(0, 1).transform(matrix).subtract(orig);
      return new Size(72 / u.getLength(), 72 / v.getLength());
    },
    getPpi: '#getResolution',
    getImage: function () {
      return this._image;
    },
    setImage: function (image) {
      var that = this;

      function emit(event) {
        var view = that.getView(),
            type = event && event.type || 'load';

        if (view && that.responds(type)) {
          paper = view._scope;
          that.emit(type, new Event(event));
        }
      }

      this._setImage(image);

      if (this._loaded) {
        setTimeout(emit, 0);
      } else if (image) {
        DomEvent.add(image, {
          load: function (event) {
            that._setImage(image);

            emit(event);
          },
          error: emit
        });
      }
    },
    _setImage: function (image) {
      if (this._canvas) CanvasProvider.release(this._canvas);

      if (image && image.getContext) {
        this._image = null;
        this._canvas = image;
        this._loaded = true;
      } else {
        this._image = image;
        this._canvas = null;
        this._loaded = !!(image && image.src && image.complete);
      }

      this._size = new Size(image ? image.naturalWidth || image.width : 0, image ? image.naturalHeight || image.height : 0);
      this._context = null;

      this._changed(1033);
    },
    getCanvas: function () {
      if (!this._canvas) {
        var ctx = CanvasProvider.getContext(this._size);

        try {
          if (this._image) ctx.drawImage(this._image, 0, 0);
          this._canvas = ctx.canvas;
        } catch (e) {
          CanvasProvider.release(ctx);
        }
      }

      return this._canvas;
    },
    setCanvas: '#setImage',
    getContext: function (_change) {
      if (!this._context) this._context = this.getCanvas().getContext('2d');

      if (_change) {
        this._image = null;

        this._changed(1025);
      }

      return this._context;
    },
    setContext: function (context) {
      this._context = context;
    },
    getSource: function () {
      var image = this._image;
      return image && image.src || this.toDataURL();
    },
    setSource: function (src) {
      var image = new self.Image(),
          crossOrigin = this._crossOrigin;
      if (crossOrigin) image.crossOrigin = crossOrigin;
      if (src) image.src = src;
      this.setImage(image);
    },
    getCrossOrigin: function () {
      var image = this._image;
      return image && image.crossOrigin || this._crossOrigin || '';
    },
    setCrossOrigin: function (crossOrigin) {
      this._crossOrigin = crossOrigin;
      var image = this._image;
      if (image) image.crossOrigin = crossOrigin;
    },
    getSmoothing: function () {
      return this._smoothing;
    },
    setSmoothing: function (smoothing) {
      this._smoothing = smoothing;

      this._changed(257);
    },
    getElement: function () {
      return this._canvas || this._loaded && this._image;
    }
  }, {
    beans: false,
    getSubCanvas: function () {
      var rect = Rectangle.read(arguments),
          ctx = CanvasProvider.getContext(rect.getSize());
      ctx.drawImage(this.getCanvas(), rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
      return ctx.canvas;
    },
    getSubRaster: function () {
      var rect = Rectangle.read(arguments),
          raster = new Raster(Item.NO_INSERT);

      raster._setImage(this.getSubCanvas(rect));

      raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));

      raster._matrix.prepend(this._matrix);

      raster.insertAbove(this);
      return raster;
    },
    toDataURL: function () {
      var image = this._image,
          src = image && image.src;
      if (/^data:/.test(src)) return src;
      var canvas = this.getCanvas();
      return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
    },
    drawImage: function (image) {
      var point = Point.read(arguments, 1);
      this.getContext(true).drawImage(image, point.x, point.y);
    },
    getAverageColor: function (object) {
      var bounds, path;

      if (!object) {
        bounds = this.getBounds();
      } else if (object instanceof PathItem) {
        path = object;
        bounds = object.getBounds();
      } else if (typeof object === 'object') {
        if ('width' in object) {
          bounds = new Rectangle(object);
        } else if ('x' in object) {
          bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
        }
      }

      if (!bounds) return null;
      var sampleSize = 32,
          width = Math.min(bounds.width, sampleSize),
          height = Math.min(bounds.height, sampleSize);
      var ctx = Raster._sampleContext;

      if (!ctx) {
        ctx = Raster._sampleContext = CanvasProvider.getContext(new Size(sampleSize));
      } else {
        ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
      }

      ctx.save();
      var matrix = new Matrix().scale(width / bounds.width, height / bounds.height).translate(-bounds.x, -bounds.y);
      matrix.applyToContext(ctx);
      if (path) path.draw(ctx, new Base({
        clip: true,
        matrices: [matrix]
      }));

      this._matrix.applyToContext(ctx);

      var element = this.getElement(),
          size = this._size;
      if (element) ctx.drawImage(element, -size.width / 2, -size.height / 2);
      ctx.restore();
      var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width), Math.ceil(height)).data,
          channels = [0, 0, 0],
          total = 0;

      for (var i = 0, l = pixels.length; i < l; i += 4) {
        var alpha = pixels[i + 3];
        total += alpha;
        alpha /= 255;
        channels[0] += pixels[i] * alpha;
        channels[1] += pixels[i + 1] * alpha;
        channels[2] += pixels[i + 2] * alpha;
      }

      for (var i = 0; i < 3; i++) channels[i] /= total;

      return total ? Color.read(channels) : null;
    },
    getPixel: function () {
      var point = Point.read(arguments);
      var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
      return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255], data[3] / 255);
    },
    setPixel: function () {
      var args = arguments,
          point = Point.read(args),
          color = Color.read(args),
          components = color._convert('rgb'),
          alpha = color._alpha,
          ctx = this.getContext(true),
          imageData = ctx.createImageData(1, 1),
          data = imageData.data;

      data[0] = components[0] * 255;
      data[1] = components[1] * 255;
      data[2] = components[2] * 255;
      data[3] = alpha != null ? alpha * 255 : 255;
      ctx.putImageData(imageData, point.x, point.y);
    },
    clear: function () {
      var size = this._size;
      this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);
    },
    createImageData: function () {
      var size = Size.read(arguments);
      return this.getContext().createImageData(size.width, size.height);
    },
    getImageData: function () {
      var rect = Rectangle.read(arguments);
      if (rect.isEmpty()) rect = new Rectangle(this._size);
      return this.getContext().getImageData(rect.x, rect.y, rect.width, rect.height);
    },
    setImageData: function (data) {
      var point = Point.read(arguments, 1);
      this.getContext(true).putImageData(data, point.x, point.y);
    },
    _getBounds: function (matrix, options) {
      var rect = new Rectangle(this._size).setCenter(0, 0);
      return matrix ? matrix._transformBounds(rect) : rect;
    },
    _hitTestSelf: function (point) {
      if (this._contains(point)) {
        var that = this;
        return new HitResult('pixel', that, {
          offset: point.add(that._size.divide(2)).round(),
          color: {
            get: function () {
              return that.getPixel(this.offset);
            }
          }
        });
      }
    },
    _draw: function (ctx, param, viewMatrix) {
      var element = this.getElement();

      if (element && element.width > 0 && element.height > 0) {
        ctx.globalAlpha = Numerical.clamp(this._opacity, 0, 1);

        this._setStyles(ctx, param, viewMatrix);

        DomElement.setPrefixed(ctx, 'imageSmoothingEnabled', this._smoothing);
        ctx.drawImage(element, -this._size.width / 2, -this._size.height / 2);
      }
    },
    _canComposite: function () {
      return true;
    }
  });
  var SymbolItem = Item.extend({
    _class: 'SymbolItem',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsOptions: {
      stroke: true
    },
    _serializeFields: {
      symbol: null
    },
    initialize: function SymbolItem(arg0, arg1) {
      if (!this._initialize(arg0, arg1 !== undefined && Point.read(arguments, 1))) this.setDefinition(arg0 instanceof SymbolDefinition ? arg0 : new SymbolDefinition(arg0));
    },
    _equals: function (item) {
      return this._definition === item._definition;
    },
    copyContent: function (source) {
      this.setDefinition(source._definition);
    },
    getDefinition: function () {
      return this._definition;
    },
    setDefinition: function (definition) {
      this._definition = definition;

      this._changed(9);
    },
    getSymbol: '#getDefinition',
    setSymbol: '#setDefinition',
    isEmpty: function () {
      return this._definition._item.isEmpty();
    },
    _getBounds: function (matrix, options) {
      var item = this._definition._item;
      return item._getCachedBounds(item._matrix.prepended(matrix), options);
    },
    _hitTestSelf: function (point, options, viewMatrix) {
      var opts = options.extend({
        all: false
      });

      var res = this._definition._item._hitTest(point, opts, viewMatrix);

      if (res) res.item = this;
      return res;
    },
    _draw: function (ctx, param) {
      this._definition._item.draw(ctx, param);
    }
  });
  var SymbolDefinition = Base.extend({
    _class: 'SymbolDefinition',
    initialize: function SymbolDefinition(item, dontCenter) {
      this._id = UID.get();
      this.project = paper.project;
      if (item) this.setItem(item, dontCenter);
    },
    _serialize: function (options, dictionary) {
      return dictionary.add(this, function () {
        return Base.serialize([this._class, this._item], options, false, dictionary);
      });
    },
    _changed: function (flags) {
      if (flags & 8) Item._clearBoundsCache(this);
      if (flags & 1) this.project._changed(flags);
    },
    getItem: function () {
      return this._item;
    },
    setItem: function (item, _dontCenter) {
      if (item._symbol) item = item.clone();
      if (this._item) this._item._symbol = null;
      this._item = item;
      item.remove();
      item.setSelected(false);
      if (!_dontCenter) item.setPosition(new Point());
      item._symbol = this;

      this._changed(9);
    },
    getDefinition: '#getItem',
    setDefinition: '#setItem',
    place: function (position) {
      return new SymbolItem(this, position);
    },
    clone: function () {
      return new SymbolDefinition(this._item.clone(false));
    },
    equals: function (symbol) {
      return symbol === this || symbol && this._item.equals(symbol._item) || false;
    }
  });
  var HitResult = Base.extend({
    _class: 'HitResult',
    initialize: function HitResult(type, item, values) {
      this.type = type;
      this.item = item;
      if (values) this.inject(values);
    },
    statics: {
      getOptions: function (args) {
        var options = args && Base.read(args);
        return new Base({
          type: null,
          tolerance: paper.settings.hitTolerance,
          fill: !options,
          stroke: !options,
          segments: !options,
          handles: false,
          ends: false,
          position: false,
          center: false,
          bounds: false,
          guides: false,
          selected: false
        }, options);
      }
    }
  });
  var Segment = Base.extend({
    _class: 'Segment',
    beans: true,
    _selection: 0,
    initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
      var count = arguments.length,
          point,
          handleIn,
          handleOut,
          selection;

      if (count > 0) {
        if (arg0 == null || typeof arg0 === 'object') {
          if (count === 1 && arg0 && 'point' in arg0) {
            point = arg0.point;
            handleIn = arg0.handleIn;
            handleOut = arg0.handleOut;
            selection = arg0.selection;
          } else {
            point = arg0;
            handleIn = arg1;
            handleOut = arg2;
            selection = arg3;
          }
        } else {
          point = [arg0, arg1];
          handleIn = arg2 !== undefined ? [arg2, arg3] : null;
          handleOut = arg4 !== undefined ? [arg4, arg5] : null;
        }
      }

      new SegmentPoint(point, this, '_point');
      new SegmentPoint(handleIn, this, '_handleIn');
      new SegmentPoint(handleOut, this, '_handleOut');
      if (selection) this.setSelection(selection);
    },
    _serialize: function (options, dictionary) {
      var point = this._point,
          selection = this._selection,
          obj = selection || this.hasHandles() ? [point, this._handleIn, this._handleOut] : point;
      if (selection) obj.push(selection);
      return Base.serialize(obj, options, true, dictionary);
    },
    _changed: function (point) {
      var path = this._path;
      if (!path) return;
      var curves = path._curves,
          index = this._index,
          curve;

      if (curves) {
        if ((!point || point === this._point || point === this._handleIn) && (curve = index > 0 ? curves[index - 1] : path._closed ? curves[curves.length - 1] : null)) curve._changed();
        if ((!point || point === this._point || point === this._handleOut) && (curve = curves[index])) curve._changed();
      }

      path._changed(41);
    },
    getPoint: function () {
      return this._point;
    },
    setPoint: function () {
      this._point.set(Point.read(arguments));
    },
    getHandleIn: function () {
      return this._handleIn;
    },
    setHandleIn: function () {
      this._handleIn.set(Point.read(arguments));
    },
    getHandleOut: function () {
      return this._handleOut;
    },
    setHandleOut: function () {
      this._handleOut.set(Point.read(arguments));
    },
    hasHandles: function () {
      return !this._handleIn.isZero() || !this._handleOut.isZero();
    },
    isSmooth: function () {
      var handleIn = this._handleIn,
          handleOut = this._handleOut;
      return !handleIn.isZero() && !handleOut.isZero() && handleIn.isCollinear(handleOut);
    },
    clearHandles: function () {
      this._handleIn._set(0, 0);

      this._handleOut._set(0, 0);
    },
    getSelection: function () {
      return this._selection;
    },
    setSelection: function (selection) {
      var oldSelection = this._selection,
          path = this._path;
      this._selection = selection = selection || 0;

      if (path && selection !== oldSelection) {
        path._updateSelection(this, oldSelection, selection);

        path._changed(257);
      }
    },
    _changeSelection: function (flag, selected) {
      var selection = this._selection;
      this.setSelection(selected ? selection | flag : selection & ~flag);
    },
    isSelected: function () {
      return !!(this._selection & 7);
    },
    setSelected: function (selected) {
      this._changeSelection(7, selected);
    },
    getIndex: function () {
      return this._index !== undefined ? this._index : null;
    },
    getPath: function () {
      return this._path || null;
    },
    getCurve: function () {
      var path = this._path,
          index = this._index;

      if (path) {
        if (index > 0 && !path._closed && index === path._segments.length - 1) index--;
        return path.getCurves()[index] || null;
      }

      return null;
    },
    getLocation: function () {
      var curve = this.getCurve();
      return curve ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1) : null;
    },
    getNext: function () {
      var segments = this._path && this._path._segments;
      return segments && (segments[this._index + 1] || this._path._closed && segments[0]) || null;
    },
    smooth: function (options, _first, _last) {
      var opts = options || {},
          type = opts.type,
          factor = opts.factor,
          prev = this.getPrevious(),
          next = this.getNext(),
          p0 = (prev || this)._point,
          p1 = this._point,
          p2 = (next || this)._point,
          d1 = p0.getDistance(p1),
          d2 = p1.getDistance(p2);

      if (!type || type === 'catmull-rom') {
        var a = factor === undefined ? 0.5 : factor,
            d1_a = Math.pow(d1, a),
            d1_2a = d1_a * d1_a,
            d2_a = Math.pow(d2, a),
            d2_2a = d2_a * d2_a;

        if (!_first && prev) {
          var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,
              N = 3 * d2_a * (d2_a + d1_a);
          this.setHandleIn(N !== 0 ? new Point((d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x, (d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y) : new Point());
        }

        if (!_last && next) {
          var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,
              N = 3 * d1_a * (d1_a + d2_a);
          this.setHandleOut(N !== 0 ? new Point((d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x, (d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y) : new Point());
        }
      } else if (type === 'geometric') {
        if (prev && next) {
          var vector = p0.subtract(p2),
              t = factor === undefined ? 0.4 : factor,
              k = t * d1 / (d1 + d2);
          if (!_first) this.setHandleIn(vector.multiply(k));
          if (!_last) this.setHandleOut(vector.multiply(k - t));
        }
      } else {
        throw new Error('Smoothing method \'' + type + '\' not supported.');
      }
    },
    getPrevious: function () {
      var segments = this._path && this._path._segments;
      return segments && (segments[this._index - 1] || this._path._closed && segments[segments.length - 1]) || null;
    },
    isFirst: function () {
      return !this._index;
    },
    isLast: function () {
      var path = this._path;
      return path && this._index === path._segments.length - 1 || false;
    },
    reverse: function () {
      var handleIn = this._handleIn,
          handleOut = this._handleOut,
          tmp = handleIn.clone();
      handleIn.set(handleOut);
      handleOut.set(tmp);
    },
    reversed: function () {
      return new Segment(this._point, this._handleOut, this._handleIn);
    },
    remove: function () {
      return this._path ? !!this._path.removeSegment(this._index) : false;
    },
    clone: function () {
      return new Segment(this._point, this._handleIn, this._handleOut);
    },
    equals: function (segment) {
      return segment === this || segment && this._class === segment._class && this._point.equals(segment._point) && this._handleIn.equals(segment._handleIn) && this._handleOut.equals(segment._handleOut) || false;
    },
    toString: function () {
      var parts = ['point: ' + this._point];
      if (!this._handleIn.isZero()) parts.push('handleIn: ' + this._handleIn);
      if (!this._handleOut.isZero()) parts.push('handleOut: ' + this._handleOut);
      return '{ ' + parts.join(', ') + ' }';
    },
    transform: function (matrix) {
      this._transformCoordinates(matrix, new Array(6), true);

      this._changed();
    },
    interpolate: function (from, to, factor) {
      var u = 1 - factor,
          v = factor,
          point1 = from._point,
          point2 = to._point,
          handleIn1 = from._handleIn,
          handleIn2 = to._handleIn,
          handleOut2 = to._handleOut,
          handleOut1 = from._handleOut;

      this._point._set(u * point1._x + v * point2._x, u * point1._y + v * point2._y, true);

      this._handleIn._set(u * handleIn1._x + v * handleIn2._x, u * handleIn1._y + v * handleIn2._y, true);

      this._handleOut._set(u * handleOut1._x + v * handleOut2._x, u * handleOut1._y + v * handleOut2._y, true);

      this._changed();
    },
    _transformCoordinates: function (matrix, coords, change) {
      var point = this._point,
          handleIn = !change || !this._handleIn.isZero() ? this._handleIn : null,
          handleOut = !change || !this._handleOut.isZero() ? this._handleOut : null,
          x = point._x,
          y = point._y,
          i = 2;
      coords[0] = x;
      coords[1] = y;

      if (handleIn) {
        coords[i++] = handleIn._x + x;
        coords[i++] = handleIn._y + y;
      }

      if (handleOut) {
        coords[i++] = handleOut._x + x;
        coords[i++] = handleOut._y + y;
      }

      if (matrix) {
        matrix._transformCoordinates(coords, coords, i / 2);

        x = coords[0];
        y = coords[1];

        if (change) {
          point._x = x;
          point._y = y;
          i = 2;

          if (handleIn) {
            handleIn._x = coords[i++] - x;
            handleIn._y = coords[i++] - y;
          }

          if (handleOut) {
            handleOut._x = coords[i++] - x;
            handleOut._y = coords[i++] - y;
          }
        } else {
          if (!handleIn) {
            coords[i++] = x;
            coords[i++] = y;
          }

          if (!handleOut) {
            coords[i++] = x;
            coords[i++] = y;
          }
        }
      }

      return coords;
    }
  });
  var SegmentPoint = Point.extend({
    initialize: function SegmentPoint(point, owner, key) {
      var x, y, selected;

      if (!point) {
        x = y = 0;
      } else if ((x = point[0]) !== undefined) {
        y = point[1];
      } else {
        var pt = point;

        if ((x = pt.x) === undefined) {
          pt = Point.read(arguments);
          x = pt.x;
        }

        y = pt.y;
        selected = pt.selected;
      }

      this._x = x;
      this._y = y;
      this._owner = owner;
      owner[key] = this;
      if (selected) this.setSelected(true);
    },
    _set: function (x, y) {
      this._x = x;
      this._y = y;

      this._owner._changed(this);

      return this;
    },
    getX: function () {
      return this._x;
    },
    setX: function (x) {
      this._x = x;

      this._owner._changed(this);
    },
    getY: function () {
      return this._y;
    },
    setY: function (y) {
      this._y = y;

      this._owner._changed(this);
    },
    isZero: function () {
      var isZero = Numerical.isZero;
      return isZero(this._x) && isZero(this._y);
    },
    isSelected: function () {
      return !!(this._owner._selection & this._getSelection());
    },
    setSelected: function (selected) {
      this._owner._changeSelection(this._getSelection(), selected);
    },
    _getSelection: function () {
      var owner = this._owner;
      return this === owner._point ? 1 : this === owner._handleIn ? 2 : this === owner._handleOut ? 4 : 0;
    }
  });
  var Curve = Base.extend({
    _class: 'Curve',
    beans: true,
    initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      var count = arguments.length,
          seg1,
          seg2,
          point1,
          point2,
          handle1,
          handle2;

      if (count === 3) {
        this._path = arg0;
        seg1 = arg1;
        seg2 = arg2;
      } else if (!count) {
        seg1 = new Segment();
        seg2 = new Segment();
      } else if (count === 1) {
        if ('segment1' in arg0) {
          seg1 = new Segment(arg0.segment1);
          seg2 = new Segment(arg0.segment2);
        } else if ('point1' in arg0) {
          point1 = arg0.point1;
          handle1 = arg0.handle1;
          handle2 = arg0.handle2;
          point2 = arg0.point2;
        } else if (Array.isArray(arg0)) {
          point1 = [arg0[0], arg0[1]];
          point2 = [arg0[6], arg0[7]];
          handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
          handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
        }
      } else if (count === 2) {
        seg1 = new Segment(arg0);
        seg2 = new Segment(arg1);
      } else if (count === 4) {
        point1 = arg0;
        handle1 = arg1;
        handle2 = arg2;
        point2 = arg3;
      } else if (count === 8) {
        point1 = [arg0, arg1];
        point2 = [arg6, arg7];
        handle1 = [arg2 - arg0, arg3 - arg1];
        handle2 = [arg4 - arg6, arg5 - arg7];
      }

      this._segment1 = seg1 || new Segment(point1, null, handle1);
      this._segment2 = seg2 || new Segment(point2, handle2, null);
    },
    _serialize: function (options, dictionary) {
      return Base.serialize(this.hasHandles() ? [this.getPoint1(), this.getHandle1(), this.getHandle2(), this.getPoint2()] : [this.getPoint1(), this.getPoint2()], options, true, dictionary);
    },
    _changed: function () {
      this._length = this._bounds = undefined;
    },
    clone: function () {
      return new Curve(this._segment1, this._segment2);
    },
    toString: function () {
      var parts = ['point1: ' + this._segment1._point];
      if (!this._segment1._handleOut.isZero()) parts.push('handle1: ' + this._segment1._handleOut);
      if (!this._segment2._handleIn.isZero()) parts.push('handle2: ' + this._segment2._handleIn);
      parts.push('point2: ' + this._segment2._point);
      return '{ ' + parts.join(', ') + ' }';
    },
    classify: function () {
      return Curve.classify(this.getValues());
    },
    remove: function () {
      var removed = false;

      if (this._path) {
        var segment2 = this._segment2,
            handleOut = segment2._handleOut;
        removed = segment2.remove();
        if (removed) this._segment1._handleOut.set(handleOut);
      }

      return removed;
    },
    getPoint1: function () {
      return this._segment1._point;
    },
    setPoint1: function () {
      this._segment1._point.set(Point.read(arguments));
    },
    getPoint2: function () {
      return this._segment2._point;
    },
    setPoint2: function () {
      this._segment2._point.set(Point.read(arguments));
    },
    getHandle1: function () {
      return this._segment1._handleOut;
    },
    setHandle1: function () {
      this._segment1._handleOut.set(Point.read(arguments));
    },
    getHandle2: function () {
      return this._segment2._handleIn;
    },
    setHandle2: function () {
      this._segment2._handleIn.set(Point.read(arguments));
    },
    getSegment1: function () {
      return this._segment1;
    },
    getSegment2: function () {
      return this._segment2;
    },
    getPath: function () {
      return this._path;
    },
    getIndex: function () {
      return this._segment1._index;
    },
    getNext: function () {
      var curves = this._path && this._path._curves;
      return curves && (curves[this._segment1._index + 1] || this._path._closed && curves[0]) || null;
    },
    getPrevious: function () {
      var curves = this._path && this._path._curves;
      return curves && (curves[this._segment1._index - 1] || this._path._closed && curves[curves.length - 1]) || null;
    },
    isFirst: function () {
      return !this._segment1._index;
    },
    isLast: function () {
      var path = this._path;
      return path && this._segment1._index === path._curves.length - 1 || false;
    },
    isSelected: function () {
      return this.getPoint1().isSelected() && this.getHandle1().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
    },
    setSelected: function (selected) {
      this.getPoint1().setSelected(selected);
      this.getHandle1().setSelected(selected);
      this.getHandle2().setSelected(selected);
      this.getPoint2().setSelected(selected);
    },
    getValues: function (matrix) {
      return Curve.getValues(this._segment1, this._segment2, matrix);
    },
    getPoints: function () {
      var coords = this.getValues(),
          points = [];

      for (var i = 0; i < 8; i += 2) points.push(new Point(coords[i], coords[i + 1]));

      return points;
    }
  }, {
    getLength: function () {
      if (this._length == null) this._length = Curve.getLength(this.getValues(), 0, 1);
      return this._length;
    },
    getArea: function () {
      return Curve.getArea(this.getValues());
    },
    getLine: function () {
      return new Line(this._segment1._point, this._segment2._point);
    },
    getPart: function (from, to) {
      return new Curve(Curve.getPart(this.getValues(), from, to));
    },
    getPartLength: function (from, to) {
      return Curve.getLength(this.getValues(), from, to);
    },
    divideAt: function (location) {
      return this.divideAtTime(location && location.curve === this ? location.time : this.getTimeAt(location));
    },
    divideAtTime: function (time, _setHandles) {
      var tMin = 1e-8,
          tMax = 1 - tMin,
          res = null;

      if (time >= tMin && time <= tMax) {
        var parts = Curve.subdivide(this.getValues(), time),
            left = parts[0],
            right = parts[1],
            setHandles = _setHandles || this.hasHandles(),
            seg1 = this._segment1,
            seg2 = this._segment2,
            path = this._path;

        if (setHandles) {
          seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);

          seg2._handleIn._set(right[4] - right[6], right[5] - right[7]);
        }

        var x = left[6],
            y = left[7],
            segment = new Segment(new Point(x, y), setHandles && new Point(left[4] - x, left[5] - y), setHandles && new Point(right[2] - x, right[3] - y));

        if (path) {
          path.insert(seg1._index + 1, segment);
          res = this.getNext();
        } else {
          this._segment2 = segment;

          this._changed();

          res = new Curve(segment, seg2);
        }
      }

      return res;
    },
    splitAt: function (location) {
      var path = this._path;
      return path ? path.splitAt(location) : null;
    },
    splitAtTime: function (time) {
      return this.splitAt(this.getLocationAtTime(time));
    },
    divide: function (offset, isTime) {
      return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset : this.getTimeAt(offset));
    },
    split: function (offset, isTime) {
      return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset : this.getTimeAt(offset));
    },
    reversed: function () {
      return new Curve(this._segment2.reversed(), this._segment1.reversed());
    },
    clearHandles: function () {
      this._segment1._handleOut._set(0, 0);

      this._segment2._handleIn._set(0, 0);
    },
    statics: {
      getValues: function (segment1, segment2, matrix, straight) {
        var p1 = segment1._point,
            h1 = segment1._handleOut,
            h2 = segment2._handleIn,
            p2 = segment2._point,
            x1 = p1.x,
            y1 = p1.y,
            x2 = p2.x,
            y2 = p2.y,
            values = straight ? [x1, y1, x1, y1, x2, y2, x2, y2] : [x1, y1, x1 + h1._x, y1 + h1._y, x2 + h2._x, y2 + h2._y, x2, y2];
        if (matrix) matrix._transformCoordinates(values, values, 4);
        return values;
      },
      subdivide: function (v, t) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7];
        if (t === undefined) t = 0.5;
        var u = 1 - t,
            x4 = u * x0 + t * x1,
            y4 = u * y0 + t * y1,
            x5 = u * x1 + t * x2,
            y5 = u * y1 + t * y2,
            x6 = u * x2 + t * x3,
            y6 = u * y2 + t * y3,
            x7 = u * x4 + t * x5,
            y7 = u * y4 + t * y5,
            x8 = u * x5 + t * x6,
            y8 = u * y5 + t * y6,
            x9 = u * x7 + t * x8,
            y9 = u * y7 + t * y8;
        return [[x0, y0, x4, y4, x7, y7, x9, y9], [x9, y9, x8, y8, x6, y6, x3, y3]];
      },
      getMonoCurves: function (v, dir) {
        var curves = [],
            io = dir ? 0 : 1,
            o0 = v[io + 0],
            o1 = v[io + 2],
            o2 = v[io + 4],
            o3 = v[io + 6];

        if (o0 >= o1 === o1 >= o2 && o1 >= o2 === o2 >= o3 || Curve.isStraight(v)) {
          curves.push(v);
        } else {
          var a = 3 * (o1 - o2) - o0 + o3,
              b = 2 * (o0 + o2) - 4 * o1,
              c = o1 - o0,
              tMin = 1e-8,
              tMax = 1 - tMin,
              roots = [],
              n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);

          if (!n) {
            curves.push(v);
          } else {
            roots.sort();
            var t = roots[0],
                parts = Curve.subdivide(v, t);
            curves.push(parts[0]);

            if (n > 1) {
              t = (roots[1] - t) / (1 - t);
              parts = Curve.subdivide(parts[1], t);
              curves.push(parts[0]);
            }

            curves.push(parts[1]);
          }
        }

        return curves;
      },
      solveCubic: function (v, coord, val, roots, min, max) {
        var v0 = v[coord],
            v1 = v[coord + 2],
            v2 = v[coord + 4],
            v3 = v[coord + 6],
            res = 0;

        if (!(v0 < val && v3 < val && v1 < val && v2 < val || v0 > val && v3 > val && v1 > val && v2 > val)) {
          var c = 3 * (v1 - v0),
              b = 3 * (v2 - v1) - c,
              a = v3 - v0 - c - b;
          res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);
        }

        return res;
      },
      getTimeOf: function (v, point) {
        var p0 = new Point(v[0], v[1]),
            p3 = new Point(v[6], v[7]),
            epsilon = 1e-12,
            geomEpsilon = 1e-7,
            t = point.isClose(p0, epsilon) ? 0 : point.isClose(p3, epsilon) ? 1 : null;

        if (t === null) {
          var coords = [point.x, point.y],
              roots = [];

          for (var c = 0; c < 2; c++) {
            var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);

            for (var i = 0; i < count; i++) {
              var u = roots[i];
              if (point.isClose(Curve.getPoint(v, u), geomEpsilon)) return u;
            }
          }
        }

        return point.isClose(p0, geomEpsilon) ? 0 : point.isClose(p3, geomEpsilon) ? 1 : null;
      },
      getNearestTime: function (v, point) {
        if (Curve.isStraight(v)) {
          var x0 = v[0],
              y0 = v[1],
              x3 = v[6],
              y3 = v[7],
              vx = x3 - x0,
              vy = y3 - y0,
              det = vx * vx + vy * vy;
          if (det === 0) return 0;
          var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
          return u < 1e-12 ? 0 : u > 0.999999999999 ? 1 : Curve.getTimeOf(v, new Point(x0 + u * vx, y0 + u * vy));
        }

        var count = 100,
            minDist = Infinity,
            minT = 0;

        function refine(t) {
          if (t >= 0 && t <= 1) {
            var dist = point.getDistance(Curve.getPoint(v, t), true);

            if (dist < minDist) {
              minDist = dist;
              minT = t;
              return true;
            }
          }
        }

        for (var i = 0; i <= count; i++) refine(i / count);

        var step = 1 / (count * 2);

        while (step > 1e-8) {
          if (!refine(minT - step) && !refine(minT + step)) step /= 2;
        }

        return minT;
      },
      getPart: function (v, from, to) {
        var flip = from > to;

        if (flip) {
          var tmp = from;
          from = to;
          to = tmp;
        }

        if (from > 0) v = Curve.subdivide(v, from)[1];
        if (to < 1) v = Curve.subdivide(v, (to - from) / (1 - from))[0];
        return flip ? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]] : v;
      },
      isFlatEnough: function (v, flatness) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7],
            ux = 3 * x1 - 2 * x0 - x3,
            uy = 3 * y1 - 2 * y0 - y3,
            vx = 3 * x2 - 2 * x3 - x0,
            vy = 3 * y2 - 2 * y3 - y0;
        return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy) <= 16 * flatness * flatness;
      },
      getArea: function (v) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7];
        return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2) + y1 * (x0 - x2) - x1 * (y0 - y2) + y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
      },
      getBounds: function (v) {
        var min = v.slice(0, 2),
            max = min.slice(),
            roots = [0, 0];

        for (var i = 0; i < 2; i++) Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6], i, 0, min, max, roots);

        return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      _addBounds: function (v0, v1, v2, v3, coord, padding, min, max, roots) {
        function add(value, padding) {
          var left = value - padding,
              right = value + padding;
          if (left < min[coord]) min[coord] = left;
          if (right > max[coord]) max[coord] = right;
        }

        padding /= 2;
        var minPad = min[coord] + padding,
            maxPad = max[coord] - padding;

        if (v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad || v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
          if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
            add(v0, 0);
            add(v3, 0);
          } else {
            var a = 3 * (v1 - v2) - v0 + v3,
                b = 2 * (v0 + v2) - 4 * v1,
                c = v1 - v0,
                count = Numerical.solveQuadratic(a, b, c, roots),
                tMin = 1e-8,
                tMax = 1 - tMin;
            add(v3, 0);

            for (var i = 0; i < count; i++) {
              var t = roots[i],
                  u = 1 - t;
              if (tMin <= t && t <= tMax) add(u * u * u * v0 + 3 * u * u * t * v1 + 3 * u * t * t * v2 + t * t * t * v3, padding);
            }
          }
        }
      }
    }
  }, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds'], function (name) {
    this[name] = function () {
      if (!this._bounds) this._bounds = {};
      var bounds = this._bounds[name];

      if (!bounds) {
        bounds = this._bounds[name] = Path[name]([this._segment1, this._segment2], false, this._path);
      }

      return bounds.clone();
    };
  }, {}), Base.each({
    isStraight: function (p1, h1, h2, p2) {
      if (h1.isZero() && h2.isZero()) {
        return true;
      } else {
        var v = p2.subtract(p1);

        if (v.isZero()) {
          return false;
        } else if (v.isCollinear(h1) && v.isCollinear(h2)) {
          var l = new Line(p1, p2),
              epsilon = 1e-7;

          if (l.getDistance(p1.add(h1)) < epsilon && l.getDistance(p2.add(h2)) < epsilon) {
            var div = v.dot(v),
                s1 = v.dot(h1) / div,
                s2 = v.dot(h2) / div;
            return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
          }
        }
      }

      return false;
    },
    isLinear: function (p1, h1, h2, p2) {
      var third = p2.subtract(p1).divide(3);
      return h1.equals(third) && h2.negate().equals(third);
    }
  }, function (test, name) {
    this[name] = function (epsilon) {
      var seg1 = this._segment1,
          seg2 = this._segment2;
      return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point, epsilon);
    };

    this.statics[name] = function (v, epsilon) {
      var x0 = v[0],
          y0 = v[1],
          x3 = v[6],
          y3 = v[7];
      return test(new Point(x0, y0), new Point(v[2] - x0, v[3] - y0), new Point(v[4] - x3, v[5] - y3), new Point(x3, y3), epsilon);
    };
  }, {
    statics: {},
    hasHandles: function () {
      return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero();
    },
    hasLength: function (epsilon) {
      return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (epsilon || 0);
    },
    isCollinear: function (curve) {
      return curve && this.isStraight() && curve.isStraight() && this.getLine().isCollinear(curve.getLine());
    },
    isHorizontal: function () {
      return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y) < 1e-8;
    },
    isVertical: function () {
      return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x) < 1e-8;
    }
  }), {
    beans: false,
    getLocationAt: function (offset, _isTime) {
      return this.getLocationAtTime(_isTime ? offset : this.getTimeAt(offset));
    },
    getLocationAtTime: function (t) {
      return t != null && t >= 0 && t <= 1 ? new CurveLocation(this, t) : null;
    },
    getTimeAt: function (offset, start) {
      return Curve.getTimeAt(this.getValues(), offset, start);
    },
    getParameterAt: '#getTimeAt',
    getTimesWithTangent: function () {
      var tangent = Point.read(arguments);
      return tangent.isZero() ? [] : Curve.getTimesWithTangent(this.getValues(), tangent);
    },
    getOffsetAtTime: function (t) {
      return this.getPartLength(0, t);
    },
    getLocationOf: function () {
      return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
    },
    getOffsetOf: function () {
      var loc = this.getLocationOf.apply(this, arguments);
      return loc ? loc.getOffset() : null;
    },
    getTimeOf: function () {
      return Curve.getTimeOf(this.getValues(), Point.read(arguments));
    },
    getParameterOf: '#getTimeOf',
    getNearestLocation: function () {
      var point = Point.read(arguments),
          values = this.getValues(),
          t = Curve.getNearestTime(values, point),
          pt = Curve.getPoint(values, t);
      return new CurveLocation(this, t, pt, null, point.getDistance(pt));
    },
    getNearestPoint: function () {
      var loc = this.getNearestLocation.apply(this, arguments);
      return loc ? loc.getPoint() : loc;
    }
  }, new function () {
    var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent', 'getWeightedNormal', 'getCurvature'];
    return Base.each(methods, function (name) {
      this[name + 'At'] = function (location, _isTime) {
        var values = this.getValues();
        return Curve[name](values, _isTime ? location : Curve.getTimeAt(values, location));
      };

      this[name + 'AtTime'] = function (time) {
        return Curve[name](this.getValues(), time);
      };
    }, {
      statics: {
        _evaluateMethods: methods
      }
    });
  }(), new function () {
    function getLengthIntegrand(v) {
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          ax = 9 * (x1 - x2) + 3 * (x3 - x0),
          bx = 6 * (x0 + x2) - 12 * x1,
          cx = 3 * (x1 - x0),
          ay = 9 * (y1 - y2) + 3 * (y3 - y0),
          by = 6 * (y0 + y2) - 12 * y1,
          cy = 3 * (y1 - y0);
      return function (t) {
        var dx = (ax * t + bx) * t + cx,
            dy = (ay * t + by) * t + cy;
        return Math.sqrt(dx * dx + dy * dy);
      };
    }

    function getIterations(a, b) {
      return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
    }

    function evaluate(v, t, type, normalized) {
      if (t == null || t < 0 || t > 1) return null;
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          isZero = Numerical.isZero;

      if (isZero(x1 - x0) && isZero(y1 - y0)) {
        x1 = x0;
        y1 = y0;
      }

      if (isZero(x2 - x3) && isZero(y2 - y3)) {
        x2 = x3;
        y2 = y3;
      }

      var cx = 3 * (x1 - x0),
          bx = 3 * (x2 - x1) - cx,
          ax = x3 - x0 - cx - bx,
          cy = 3 * (y1 - y0),
          by = 3 * (y2 - y1) - cy,
          ay = y3 - y0 - cy - by,
          x,
          y;

      if (type === 0) {
        x = t === 0 ? x0 : t === 1 ? x3 : ((ax * t + bx) * t + cx) * t + x0;
        y = t === 0 ? y0 : t === 1 ? y3 : ((ay * t + by) * t + cy) * t + y0;
      } else {
        var tMin = 1e-8,
            tMax = 1 - tMin;

        if (t < tMin) {
          x = cx;
          y = cy;
        } else if (t > tMax) {
          x = 3 * (x3 - x2);
          y = 3 * (y3 - y2);
        } else {
          x = (3 * ax * t + 2 * bx) * t + cx;
          y = (3 * ay * t + 2 * by) * t + cy;
        }

        if (normalized) {
          if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
            x = x2 - x1;
            y = y2 - y1;
          }

          var len = Math.sqrt(x * x + y * y);

          if (len) {
            x /= len;
            y /= len;
          }
        }

        if (type === 3) {
          var x2 = 6 * ax * t + 2 * bx,
              y2 = 6 * ay * t + 2 * by,
              d = Math.pow(x * x + y * y, 3 / 2);
          x = d !== 0 ? (x * y2 - y * x2) / d : 0;
          y = 0;
        }
      }

      return type === 2 ? new Point(y, -x) : new Point(x, y);
    }

    return {
      statics: {
        classify: function (v) {
          var x0 = v[0],
              y0 = v[1],
              x1 = v[2],
              y1 = v[3],
              x2 = v[4],
              y2 = v[5],
              x3 = v[6],
              y3 = v[7],
              a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,
              a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,
              a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,
              d3 = 3 * a3,
              d2 = d3 - a2,
              d1 = d2 - a2 + a1,
              l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),
              s = l !== 0 ? 1 / l : 0,
              isZero = Numerical.isZero,
              serpentine = 'serpentine';
          d1 *= s;
          d2 *= s;
          d3 *= s;

          function type(type, t1, t2) {
            var hasRoots = t1 !== undefined,
                t1Ok = hasRoots && t1 > 0 && t1 < 1,
                t2Ok = hasRoots && t2 > 0 && t2 < 1;

            if (hasRoots && (!(t1Ok || t2Ok) || type === 'loop' && !(t1Ok && t2Ok))) {
              type = 'arch';
              t1Ok = t2Ok = false;
            }

            return {
              type: type,
              roots: t1Ok || t2Ok ? t1Ok && t2Ok ? t1 < t2 ? [t1, t2] : [t2, t1] : [t1Ok ? t1 : t2] : null
            };
          }

          if (isZero(d1)) {
            return isZero(d2) ? type(isZero(d3) ? 'line' : 'quadratic') : type(serpentine, d3 / (3 * d2));
          }

          var d = 3 * d2 * d2 - 4 * d1 * d3;

          if (isZero(d)) {
            return type('cusp', d2 / (2 * d1));
          }

          var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),
              f2 = 2 * d1;
          return type(d > 0 ? serpentine : 'loop', (d2 + f1) / f2, (d2 - f1) / f2);
        },
        getLength: function (v, a, b, ds) {
          if (a === undefined) a = 0;
          if (b === undefined) b = 1;

          if (Curve.isStraight(v)) {
            var c = v;

            if (b < 1) {
              c = Curve.subdivide(c, b)[0];
              a /= b;
            }

            if (a > 0) {
              c = Curve.subdivide(c, a)[1];
            }

            var dx = c[6] - c[0],
                dy = c[7] - c[1];
            return Math.sqrt(dx * dx + dy * dy);
          }

          return Numerical.integrate(ds || getLengthIntegrand(v), a, b, getIterations(a, b));
        },
        getTimeAt: function (v, offset, start) {
          if (start === undefined) start = offset < 0 ? 1 : 0;
          if (offset === 0) return start;
          var abs = Math.abs,
              epsilon = 1e-12,
              forward = offset > 0,
              a = forward ? start : 0,
              b = forward ? 1 : start,
              ds = getLengthIntegrand(v),
              rangeLength = Curve.getLength(v, a, b, ds),
              diff = abs(offset) - rangeLength;

          if (abs(diff) < epsilon) {
            return forward ? b : a;
          } else if (diff > epsilon) {
            return null;
          }

          var guess = offset / rangeLength,
              length = 0;

          function f(t) {
            length += Numerical.integrate(ds, start, t, getIterations(start, t));
            start = t;
            return length - offset;
          }

          return Numerical.findRoot(f, ds, start + guess, a, b, 32, 1e-12);
        },
        getPoint: function (v, t) {
          return evaluate(v, t, 0, false);
        },
        getTangent: function (v, t) {
          return evaluate(v, t, 1, true);
        },
        getWeightedTangent: function (v, t) {
          return evaluate(v, t, 1, false);
        },
        getNormal: function (v, t) {
          return evaluate(v, t, 2, true);
        },
        getWeightedNormal: function (v, t) {
          return evaluate(v, t, 2, false);
        },
        getCurvature: function (v, t) {
          return evaluate(v, t, 3, false).x;
        },
        getPeaks: function (v) {
          var x0 = v[0],
              y0 = v[1],
              x1 = v[2],
              y1 = v[3],
              x2 = v[4],
              y2 = v[5],
              x3 = v[6],
              y3 = v[7],
              ax = -x0 + 3 * x1 - 3 * x2 + x3,
              bx = 3 * x0 - 6 * x1 + 3 * x2,
              cx = -3 * x0 + 3 * x1,
              ay = -y0 + 3 * y1 - 3 * y2 + y3,
              by = 3 * y0 - 6 * y1 + 3 * y2,
              cy = -3 * y0 + 3 * y1,
              tMin = 1e-8,
              tMax = 1 - tMin,
              roots = [];
          Numerical.solveCubic(9 * (ax * ax + ay * ay), 9 * (ax * bx + by * ay), 2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay), cx * bx + by * cy, roots, tMin, tMax);
          return roots.sort();
        }
      }
    };
  }(), new function () {
    function addLocation(locations, include, c1, t1, c2, t2, overlap) {
      var excludeStart = !overlap && c1.getPrevious() === c2,
          excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,
          tMin = 1e-8,
          tMax = 1 - tMin;

      if (t1 !== null && t1 >= (excludeStart ? tMin : 0) && t1 <= (excludeEnd ? tMax : 1)) {
        if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) && t2 <= (excludeStart ? tMax : 1)) {
          var loc1 = new CurveLocation(c1, t1, null, overlap),
              loc2 = new CurveLocation(c2, t2, null, overlap);
          loc1._intersection = loc2;
          loc2._intersection = loc1;

          if (!include || include(loc1)) {
            CurveLocation.insert(locations, loc1, true);
          }
        }
      }
    }

    function addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMin, tMax, uMin, uMax) {
      if (++calls >= 4096 || ++recursion >= 40) return calls;
      var fatLineEpsilon = 1e-9,
          q0x = v2[0],
          q0y = v2[1],
          q3x = v2[6],
          q3y = v2[7],
          getSignedDistance = Line.getSignedDistance,
          d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
          d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
          factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
          dMin = factor * Math.min(0, d1, d2),
          dMax = factor * Math.max(0, d1, d2),
          dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
          dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
          dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
          dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
          hull = getConvexHull(dp0, dp1, dp2, dp3),
          top = hull[0],
          bottom = hull[1],
          tMinClip,
          tMaxClip;
      if (d1 === 0 && d2 === 0 && dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0 || (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null || (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(), dMin, dMax)) == null) return calls;
      var tMinNew = tMin + (tMax - tMin) * tMinClip,
          tMaxNew = tMin + (tMax - tMin) * tMaxClip;

      if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
        var t = (tMinNew + tMaxNew) / 2,
            u = (uMin + uMax) / 2;
        addLocation(locations, include, flip ? c2 : c1, flip ? u : t, flip ? c1 : c2, flip ? t : u);
      } else {
        v1 = Curve.getPart(v1, tMinClip, tMaxClip);
        var uDiff = uMax - uMin;

        if (tMaxClip - tMinClip > 0.8) {
          if (tMaxNew - tMinNew > uDiff) {
            var parts = Curve.subdivide(v1, 0.5),
                t = (tMinNew + tMaxNew) / 2;
            calls = addCurveIntersections(v2, parts[0], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, t);
            calls = addCurveIntersections(v2, parts[1], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, t, tMaxNew);
          } else {
            var parts = Curve.subdivide(v2, 0.5),
                u = (uMin + uMax) / 2;
            calls = addCurveIntersections(parts[0], v1, c2, c1, locations, include, !flip, recursion, calls, uMin, u, tMinNew, tMaxNew);
            calls = addCurveIntersections(parts[1], v1, c2, c1, locations, include, !flip, recursion, calls, u, uMax, tMinNew, tMaxNew);
          }
        } else {
          if (uDiff === 0 || uDiff >= fatLineEpsilon) {
            calls = addCurveIntersections(v2, v1, c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, tMaxNew);
          } else {
            calls = addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMinNew, tMaxNew, uMin, uMax);
          }
        }
      }

      return calls;
    }

    function getConvexHull(dq0, dq1, dq2, dq3) {
      var p0 = [0, dq0],
          p1 = [1 / 3, dq1],
          p2 = [2 / 3, dq2],
          p3 = [1, dq3],
          dist1 = dq1 - (2 * dq0 + dq3) / 3,
          dist2 = dq2 - (dq0 + 2 * dq3) / 3,
          hull;

      if (dist1 * dist2 < 0) {
        hull = [[p0, p1, p3], [p0, p2, p3]];
      } else {
        var distRatio = dist1 / dist2;
        hull = [distRatio >= 2 ? [p0, p1, p3] : distRatio <= 0.5 ? [p0, p2, p3] : [p0, p1, p2, p3], [p0, p3]];
      }

      return (dist1 || dist2) < 0 ? hull.reverse() : hull;
    }

    function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
      if (hullTop[0][1] < dMin) {
        return clipConvexHullPart(hullTop, true, dMin);
      } else if (hullBottom[0][1] > dMax) {
        return clipConvexHullPart(hullBottom, false, dMax);
      } else {
        return hullTop[0][0];
      }
    }

    function clipConvexHullPart(part, top, threshold) {
      var px = part[0][0],
          py = part[0][1];

      for (var i = 1, l = part.length; i < l; i++) {
        var qx = part[i][0],
            qy = part[i][1];

        if (top ? qy >= threshold : qy <= threshold) {
          return qy === threshold ? qx : px + (threshold - py) * (qx - px) / (qy - py);
        }

        px = qx;
        py = qy;
      }

      return null;
    }

    function getCurveLineIntersections(v, px, py, vx, vy) {
      var isZero = Numerical.isZero;

      if (isZero(vx) && isZero(vy)) {
        var t = Curve.getTimeOf(v, new Point(px, py));
        return t === null ? [] : [t];
      }

      var angle = Math.atan2(-vy, vx),
          sin = Math.sin(angle),
          cos = Math.cos(angle),
          rv = [],
          roots = [];

      for (var i = 0; i < 8; i += 2) {
        var x = v[i] - px,
            y = v[i + 1] - py;
        rv.push(x * cos - y * sin, x * sin + y * cos);
      }

      Curve.solveCubic(rv, 1, 0, roots, 0, 1);
      return roots;
    }

    function addCurveLineIntersections(v1, v2, c1, c2, locations, include, flip) {
      var x1 = v2[0],
          y1 = v2[1],
          x2 = v2[6],
          y2 = v2[7],
          roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);

      for (var i = 0, l = roots.length; i < l; i++) {
        var t1 = roots[i],
            p1 = Curve.getPoint(v1, t1),
            t2 = Curve.getTimeOf(v2, p1);

        if (t2 !== null) {
          addLocation(locations, include, flip ? c2 : c1, flip ? t2 : t1, flip ? c1 : c2, flip ? t1 : t2);
        }
      }
    }

    function addLineIntersection(v1, v2, c1, c2, locations, include) {
      var pt = Line.intersect(v1[0], v1[1], v1[6], v1[7], v2[0], v2[1], v2[6], v2[7]);

      if (pt) {
        addLocation(locations, include, c1, Curve.getTimeOf(v1, pt), c2, Curve.getTimeOf(v2, pt));
      }
    }

    function getCurveIntersections(v1, v2, c1, c2, locations, include) {
      var epsilon = 1e-12,
          min = Math.min,
          max = Math.max;

      if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon > min(v2[0], v2[2], v2[4], v2[6]) && min(v1[0], v1[2], v1[4], v1[6]) - epsilon < max(v2[0], v2[2], v2[4], v2[6]) && max(v1[1], v1[3], v1[5], v1[7]) + epsilon > min(v2[1], v2[3], v2[5], v2[7]) && min(v1[1], v1[3], v1[5], v1[7]) - epsilon < max(v2[1], v2[3], v2[5], v2[7])) {
        var overlaps = getOverlaps(v1, v2);

        if (overlaps) {
          for (var i = 0; i < 2; i++) {
            var overlap = overlaps[i];
            addLocation(locations, include, c1, overlap[0], c2, overlap[1], true);
          }
        } else {
          var straight1 = Curve.isStraight(v1),
              straight2 = Curve.isStraight(v2),
              straight = straight1 && straight2,
              flip = straight1 && !straight2,
              before = locations.length;
          (straight ? addLineIntersection : straight1 || straight2 ? addCurveLineIntersections : addCurveIntersections)(flip ? v2 : v1, flip ? v1 : v2, flip ? c2 : c1, flip ? c1 : c2, locations, include, flip, 0, 0, 0, 1, 0, 1);

          if (!straight || locations.length === before) {
            for (var i = 0; i < 4; i++) {
              var t1 = i >> 1,
                  t2 = i & 1,
                  i1 = t1 * 6,
                  i2 = t2 * 6,
                  p1 = new Point(v1[i1], v1[i1 + 1]),
                  p2 = new Point(v2[i2], v2[i2 + 1]);

              if (p1.isClose(p2, epsilon)) {
                addLocation(locations, include, c1, t1, c2, t2);
              }
            }
          }
        }
      }

      return locations;
    }

    function getSelfIntersection(v1, c1, locations, include) {
      var info = Curve.classify(v1);

      if (info.type === 'loop') {
        var roots = info.roots;
        addLocation(locations, include, c1, roots[0], c1, roots[1]);
      }

      return locations;
    }

    function getIntersections(curves1, curves2, include, matrix1, matrix2, _returnFirst) {
      var epsilon = 1e-7,
          self = !curves2;
      if (self) curves2 = curves1;
      var length1 = curves1.length,
          length2 = curves2.length,
          values1 = new Array(length1),
          values2 = self ? values1 : new Array(length2),
          locations = [];

      for (var i = 0; i < length1; i++) {
        values1[i] = curves1[i].getValues(matrix1);
      }

      if (!self) {
        for (var i = 0; i < length2; i++) {
          values2[i] = curves2[i].getValues(matrix2);
        }
      }

      var boundsCollisions = CollisionDetection.findCurveBoundsCollisions(values1, values2, epsilon);

      for (var index1 = 0; index1 < length1; index1++) {
        var curve1 = curves1[index1],
            v1 = values1[index1];

        if (self) {
          getSelfIntersection(v1, curve1, locations, include);
        }

        var collisions1 = boundsCollisions[index1];

        if (collisions1) {
          for (var j = 0; j < collisions1.length; j++) {
            if (_returnFirst && locations.length) return locations;
            var index2 = collisions1[j];

            if (!self || index2 > index1) {
              var curve2 = curves2[index2],
                  v2 = values2[index2];
              getCurveIntersections(v1, v2, curve1, curve2, locations, include);
            }
          }
        }
      }

      return locations;
    }

    function getOverlaps(v1, v2) {
      function getSquaredLineLength(v) {
        var x = v[6] - v[0],
            y = v[7] - v[1];
        return x * x + y * y;
      }

      var abs = Math.abs,
          getDistance = Line.getDistance,
          timeEpsilon = 1e-8,
          geomEpsilon = 1e-7,
          straight1 = Curve.isStraight(v1),
          straight2 = Curve.isStraight(v2),
          straightBoth = straight1 && straight2,
          flip = getSquaredLineLength(v1) < getSquaredLineLength(v2),
          l1 = flip ? v2 : v1,
          l2 = flip ? v1 : v2,
          px = l1[0],
          py = l1[1],
          vx = l1[6] - px,
          vy = l1[7] - py;

      if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
        if (!straightBoth && getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
          straight1 = straight2 = straightBoth = true;
        }
      } else if (straightBoth) {
        return null;
      }

      if (straight1 ^ straight2) {
        return null;
      }

      var v = [v1, v2],
          pairs = [];

      for (var i = 0; i < 4 && pairs.length < 2; i++) {
        var i1 = i & 1,
            i2 = i1 ^ 1,
            t1 = i >> 1,
            t2 = Curve.getTimeOf(v[i1], new Point(v[i2][t1 ? 6 : 0], v[i2][t1 ? 7 : 1]));

        if (t2 != null) {
          var pair = i1 ? [t1, t2] : [t2, t1];

          if (!pairs.length || abs(pair[0] - pairs[0][0]) > timeEpsilon && abs(pair[1] - pairs[0][1]) > timeEpsilon) {
            pairs.push(pair);
          }
        }

        if (i > 2 && !pairs.length) break;
      }

      if (pairs.length !== 2) {
        pairs = null;
      } else if (!straightBoth) {
        var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
            o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
        if (abs(o2[2] - o1[2]) > geomEpsilon || abs(o2[3] - o1[3]) > geomEpsilon || abs(o2[4] - o1[4]) > geomEpsilon || abs(o2[5] - o1[5]) > geomEpsilon) pairs = null;
      }

      return pairs;
    }

    function getTimesWithTangent(v, tangent) {
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          normalized = tangent.normalize(),
          tx = normalized.x,
          ty = normalized.y,
          ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,
          ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,
          bx = 6 * x2 - 12 * x1 + 6 * x0,
          by = 6 * y2 - 12 * y1 + 6 * y0,
          cx = 3 * x1 - 3 * x0,
          cy = 3 * y1 - 3 * y0,
          den = 2 * ax * ty - 2 * ay * tx,
          times = [];

      if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {
        var num = ax * cy - ay * cx,
            den = ax * by - ay * bx;

        if (den != 0) {
          var t = -num / den;
          if (t >= 0 && t <= 1) times.push(t);
        }
      } else {
        var delta = (bx * bx - 4 * ax * cx) * ty * ty + (-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty + (by * by - 4 * ay * cy) * tx * tx,
            k = bx * ty - by * tx;

        if (delta >= 0 && den != 0) {
          var d = Math.sqrt(delta),
              t0 = -(k + d) / den,
              t1 = (-k + d) / den;
          if (t0 >= 0 && t0 <= 1) times.push(t0);
          if (t1 >= 0 && t1 <= 1) times.push(t1);
        }
      }

      return times;
    }

    return {
      getIntersections: function (curve) {
        var v1 = this.getValues(),
            v2 = curve && curve !== this && curve.getValues();
        return v2 ? getCurveIntersections(v1, v2, this, curve, []) : getSelfIntersection(v1, this, []);
      },
      statics: {
        getOverlaps: getOverlaps,
        getIntersections: getIntersections,
        getCurveLineIntersections: getCurveLineIntersections,
        getTimesWithTangent: getTimesWithTangent
      }
    };
  }());
  var CurveLocation = Base.extend({
    _class: 'CurveLocation',
    initialize: function CurveLocation(curve, time, point, _overlap, _distance) {
      if (time >= 0.99999999) {
        var next = curve.getNext();

        if (next) {
          time = 0;
          curve = next;
        }
      }

      this._setCurve(curve);

      this._time = time;
      this._point = point || curve.getPointAtTime(time);
      this._overlap = _overlap;
      this._distance = _distance;
      this._intersection = this._next = this._previous = null;
    },
    _setPath: function (path) {
      this._path = path;
      this._version = path ? path._version : 0;
    },
    _setCurve: function (curve) {
      this._setPath(curve._path);

      this._curve = curve;
      this._segment = null;
      this._segment1 = curve._segment1;
      this._segment2 = curve._segment2;
    },
    _setSegment: function (segment) {
      var curve = segment.getCurve();

      if (curve) {
        this._setCurve(curve);
      } else {
        this._setPath(segment._path);

        this._segment1 = segment;
        this._segment2 = null;
      }

      this._segment = segment;
      this._time = segment === this._segment1 ? 0 : 1;
      this._point = segment._point.clone();
    },
    getSegment: function () {
      var segment = this._segment;

      if (!segment) {
        var curve = this.getCurve(),
            time = this.getTime();

        if (time === 0) {
          segment = curve._segment1;
        } else if (time === 1) {
          segment = curve._segment2;
        } else if (time != null) {
          segment = curve.getPartLength(0, time) < curve.getPartLength(time, 1) ? curve._segment1 : curve._segment2;
        }

        this._segment = segment;
      }

      return segment;
    },
    getCurve: function () {
      var path = this._path,
          that = this;

      if (path && path._version !== this._version) {
        this._time = this._offset = this._curveOffset = this._curve = null;
      }

      function trySegment(segment) {
        var curve = segment && segment.getCurve();

        if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
          that._setCurve(curve);

          return curve;
        }
      }

      return this._curve || trySegment(this._segment) || trySegment(this._segment1) || trySegment(this._segment2.getPrevious());
    },
    getPath: function () {
      var curve = this.getCurve();
      return curve && curve._path;
    },
    getIndex: function () {
      var curve = this.getCurve();
      return curve && curve.getIndex();
    },
    getTime: function () {
      var curve = this.getCurve(),
          time = this._time;
      return curve && time == null ? this._time = curve.getTimeOf(this._point) : time;
    },
    getParameter: '#getTime',
    getPoint: function () {
      return this._point;
    },
    getOffset: function () {
      var offset = this._offset;

      if (offset == null) {
        offset = 0;
        var path = this.getPath(),
            index = this.getIndex();

        if (path && index != null) {
          var curves = path.getCurves();

          for (var i = 0; i < index; i++) offset += curves[i].getLength();
        }

        this._offset = offset += this.getCurveOffset();
      }

      return offset;
    },
    getCurveOffset: function () {
      var offset = this._curveOffset;

      if (offset == null) {
        var curve = this.getCurve(),
            time = this.getTime();
        this._curveOffset = offset = time != null && curve && curve.getPartLength(0, time);
      }

      return offset;
    },
    getIntersection: function () {
      return this._intersection;
    },
    getDistance: function () {
      return this._distance;
    },
    divide: function () {
      var curve = this.getCurve(),
          res = curve && curve.divideAtTime(this.getTime());

      if (res) {
        this._setSegment(res._segment1);
      }

      return res;
    },
    split: function () {
      var curve = this.getCurve(),
          path = curve._path,
          res = curve && curve.splitAtTime(this.getTime());

      if (res) {
        this._setSegment(path.getLastSegment());
      }

      return res;
    },
    equals: function (loc, _ignoreOther) {
      var res = this === loc;

      if (!res && loc instanceof CurveLocation) {
        var c1 = this.getCurve(),
            c2 = loc.getCurve(),
            p1 = c1._path,
            p2 = c2._path;

        if (p1 === p2) {
          var abs = Math.abs,
              epsilon = 1e-7,
              diff = abs(this.getOffset() - loc.getOffset()),
              i1 = !_ignoreOther && this._intersection,
              i2 = !_ignoreOther && loc._intersection;
          res = (diff < epsilon || p1 && abs(p1.getLength() - diff) < epsilon) && (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
        }
      }

      return res;
    },
    toString: function () {
      var parts = [],
          point = this.getPoint(),
          f = Formatter.instance;
      if (point) parts.push('point: ' + point);
      var index = this.getIndex();
      if (index != null) parts.push('index: ' + index);
      var time = this.getTime();
      if (time != null) parts.push('time: ' + f.number(time));
      if (this._distance != null) parts.push('distance: ' + f.number(this._distance));
      return '{ ' + parts.join(', ') + ' }';
    },
    isTouching: function () {
      var inter = this._intersection;

      if (inter && this.getTangent().isCollinear(inter.getTangent())) {
        var curve1 = this.getCurve(),
            curve2 = inter.getCurve();
        return !(curve1.isStraight() && curve2.isStraight() && curve1.getLine().intersect(curve2.getLine()));
      }

      return false;
    },
    isCrossing: function () {
      var inter = this._intersection;
      if (!inter) return false;
      var t1 = this.getTime(),
          t2 = inter.getTime(),
          tMin = 1e-8,
          tMax = 1 - tMin,
          t1Inside = t1 >= tMin && t1 <= tMax,
          t2Inside = t2 >= tMin && t2 <= tMax;
      if (t1Inside && t2Inside) return !this.isTouching();
      var c2 = this.getCurve(),
          c1 = c2 && t1 < tMin ? c2.getPrevious() : c2,
          c4 = inter.getCurve(),
          c3 = c4 && t2 < tMin ? c4.getPrevious() : c4;
      if (t1 > tMax) c2 = c2.getNext();
      if (t2 > tMax) c4 = c4.getNext();
      if (!c1 || !c2 || !c3 || !c4) return false;
      var offsets = [];

      function addOffsets(curve, end) {
        var v = curve.getValues(),
            roots = Curve.classify(v).roots || Curve.getPeaks(v),
            count = roots.length,
            offset = Curve.getLength(v, end && count ? roots[count - 1] : 0, !end && count ? roots[0] : 1);
        offsets.push(count ? offset : offset / 32);
      }

      function isInRange(angle, min, max) {
        return min < max ? angle > min && angle < max : angle > min || angle < max;
      }

      if (!t1Inside) {
        addOffsets(c1, true);
        addOffsets(c2, false);
      }

      if (!t2Inside) {
        addOffsets(c3, true);
        addOffsets(c4, false);
      }

      var pt = this.getPoint(),
          offset = Math.min.apply(Math, offsets),
          v2 = t1Inside ? c2.getTangentAtTime(t1) : c2.getPointAt(offset).subtract(pt),
          v1 = t1Inside ? v2.negate() : c1.getPointAt(-offset).subtract(pt),
          v4 = t2Inside ? c4.getTangentAtTime(t2) : c4.getPointAt(offset).subtract(pt),
          v3 = t2Inside ? v4.negate() : c3.getPointAt(-offset).subtract(pt),
          a1 = v1.getAngle(),
          a2 = v2.getAngle(),
          a3 = v3.getAngle(),
          a4 = v4.getAngle();
      return !!(t1Inside ? isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4) && isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3) : isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2) && isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));
    },
    hasOverlap: function () {
      return !!this._overlap;
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    var get = name + 'At';

    this[name] = function () {
      var curve = this.getCurve(),
          time = this.getTime();
      return time != null && curve && curve[get](time, true);
    };
  }, {
    preserve: true
  }), new function () {
    function insert(locations, loc, merge) {
      var length = locations.length,
          l = 0,
          r = length - 1;

      function search(index, dir) {
        for (var i = index + dir; i >= -1 && i <= length; i += dir) {
          var loc2 = locations[(i % length + length) % length];
          if (!loc.getPoint().isClose(loc2.getPoint(), 1e-7)) break;
          if (loc.equals(loc2)) return loc2;
        }

        return null;
      }

      while (l <= r) {
        var m = l + r >>> 1,
            loc2 = locations[m],
            found;

        if (merge && (found = loc.equals(loc2) ? loc2 : search(m, -1) || search(m, 1))) {
          if (loc._overlap) {
            found._overlap = found._intersection._overlap = true;
          }

          return found;
        }

        var path1 = loc.getPath(),
            path2 = loc2.getPath(),
            diff = path1 !== path2 ? path1._id - path2._id : loc.getIndex() + loc.getTime() - (loc2.getIndex() + loc2.getTime());

        if (diff < 0) {
          r = m - 1;
        } else {
          l = m + 1;
        }
      }

      locations.splice(l, 0, loc);
      return loc;
    }

    return {
      statics: {
        insert: insert,
        expand: function (locations) {
          var expanded = locations.slice();

          for (var i = locations.length - 1; i >= 0; i--) {
            insert(expanded, locations[i]._intersection, false);
          }

          return expanded;
        }
      }
    };
  }());
  var PathItem = Item.extend({
    _class: 'PathItem',
    _selectBounds: false,
    _canScaleStroke: true,
    beans: true,
    initialize: function PathItem() {},
    statics: {
      create: function (arg) {
        var data, segments, compound;

        if (Base.isPlainObject(arg)) {
          segments = arg.segments;
          data = arg.pathData;
        } else if (Array.isArray(arg)) {
          segments = arg;
        } else if (typeof arg === 'string') {
          data = arg;
        }

        if (segments) {
          var first = segments[0];
          compound = first && Array.isArray(first[0]);
        } else if (data) {
          compound = (data.match(/m/gi) || []).length > 1 || /z\s*\S+/i.test(data);
        }

        var ctor = compound ? CompoundPath : Path;
        return new ctor(arg);
      }
    },
    _asPathItem: function () {
      return this;
    },
    isClockwise: function () {
      return this.getArea() >= 0;
    },
    setClockwise: function (clockwise) {
      if (this.isClockwise() != (clockwise = !!clockwise)) this.reverse();
    },
    setPathData: function (data) {
      var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
          coords,
          relative = false,
          previous,
          control,
          current = new Point(),
          start = new Point();

      function getCoord(index, coord) {
        var val = +coords[index];
        if (relative) val += current[coord];
        return val;
      }

      function getPoint(index) {
        return new Point(getCoord(index, 'x'), getCoord(index + 1, 'y'));
      }

      this.clear();

      for (var i = 0, l = parts && parts.length; i < l; i++) {
        var part = parts[i],
            command = part[0],
            lower = command.toLowerCase();
        coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
        var length = coords && coords.length;
        relative = command === lower;
        if (previous === 'z' && !/[mz]/.test(lower)) this.moveTo(current);

        switch (lower) {
          case 'm':
          case 'l':
            var move = lower === 'm';

            for (var j = 0; j < length; j += 2) {
              this[move ? 'moveTo' : 'lineTo'](current = getPoint(j));

              if (move) {
                start = current;
                move = false;
              }
            }

            control = current;
            break;

          case 'h':
          case 'v':
            var coord = lower === 'h' ? 'x' : 'y';
            current = current.clone();

            for (var j = 0; j < length; j++) {
              current[coord] = getCoord(j, coord);
              this.lineTo(current);
            }

            control = current;
            break;

          case 'c':
            for (var j = 0; j < length; j += 6) {
              this.cubicCurveTo(getPoint(j), control = getPoint(j + 2), current = getPoint(j + 4));
            }

            break;

          case 's':
            for (var j = 0; j < length; j += 4) {
              this.cubicCurveTo(/[cs]/.test(previous) ? current.multiply(2).subtract(control) : current, control = getPoint(j), current = getPoint(j + 2));
              previous = lower;
            }

            break;

          case 'q':
            for (var j = 0; j < length; j += 4) {
              this.quadraticCurveTo(control = getPoint(j), current = getPoint(j + 2));
            }

            break;

          case 't':
            for (var j = 0; j < length; j += 2) {
              this.quadraticCurveTo(control = /[qt]/.test(previous) ? current.multiply(2).subtract(control) : current, current = getPoint(j));
              previous = lower;
            }

            break;

          case 'a':
            for (var j = 0; j < length; j += 7) {
              this.arcTo(current = getPoint(j + 5), new Size(+coords[j], +coords[j + 1]), +coords[j + 2], +coords[j + 4], +coords[j + 3]);
            }

            break;

          case 'z':
            this.closePath(1e-12);
            current = start;
            break;
        }

        previous = lower;
      }
    },
    _canComposite: function () {
      return !(this.hasFill() && this.hasStroke());
    },
    _contains: function (point) {
      var winding = point.isInside(this.getBounds({
        internal: true,
        handle: true
      })) ? this._getWinding(point) : {};
      return winding.onPath || !!(this.getFillRule() === 'evenodd' ? winding.windingL & 1 || winding.windingR & 1 : winding.winding);
    },
    getIntersections: function (path, include, _matrix, _returnFirst) {
      var self = this === path || !path,
          matrix1 = this._matrix._orNullIfIdentity(),
          matrix2 = self ? matrix1 : (_matrix || path._matrix)._orNullIfIdentity();

      return self || this.getBounds(matrix1).intersects(path.getBounds(matrix2), 1e-12) ? Curve.getIntersections(this.getCurves(), !self && path.getCurves(), include, matrix1, matrix2, _returnFirst) : [];
    },
    getCrossings: function (path) {
      return this.getIntersections(path, function (inter) {
        return inter.isCrossing();
      });
    },
    getNearestLocation: function () {
      var point = Point.read(arguments),
          curves = this.getCurves(),
          minDist = Infinity,
          minLoc = null;

      for (var i = 0, l = curves.length; i < l; i++) {
        var loc = curves[i].getNearestLocation(point);

        if (loc._distance < minDist) {
          minDist = loc._distance;
          minLoc = loc;
        }
      }

      return minLoc;
    },
    getNearestPoint: function () {
      var loc = this.getNearestLocation.apply(this, arguments);
      return loc ? loc.getPoint() : loc;
    },
    interpolate: function (from, to, factor) {
      var isPath = !this._children,
          name = isPath ? '_segments' : '_children',
          itemsFrom = from[name],
          itemsTo = to[name],
          items = this[name];

      if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
        throw new Error('Invalid operands in interpolate() call: ' + from + ', ' + to);
      }

      var current = items.length,
          length = itemsTo.length;

      if (current < length) {
        var ctor = isPath ? Segment : Path;

        for (var i = current; i < length; i++) {
          this.add(new ctor());
        }
      } else if (current > length) {
        this[isPath ? 'removeSegments' : 'removeChildren'](length, current);
      }

      for (var i = 0; i < length; i++) {
        items[i].interpolate(itemsFrom[i], itemsTo[i], factor);
      }

      if (isPath) {
        this.setClosed(from._closed);

        this._changed(9);
      }
    },
    compare: function (path) {
      var ok = false;

      if (path) {
        var paths1 = this._children || [this],
            paths2 = path._children ? path._children.slice() : [path],
            length1 = paths1.length,
            length2 = paths2.length,
            matched = [],
            count = 0;
        ok = true;
        var boundsOverlaps = CollisionDetection.findItemBoundsCollisions(paths1, paths2, Numerical.GEOMETRIC_EPSILON);

        for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
          var path1 = paths1[i1];
          ok = false;
          var pathBoundsOverlaps = boundsOverlaps[i1];

          if (pathBoundsOverlaps) {
            for (var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--) {
              if (path1.compare(paths2[pathBoundsOverlaps[i2]])) {
                if (!matched[pathBoundsOverlaps[i2]]) {
                  matched[pathBoundsOverlaps[i2]] = true;
                  count++;
                }

                ok = true;
              }
            }
          }
        }

        ok = ok && count === length2;
      }

      return ok;
    }
  });
  var Path = PathItem.extend({
    _class: 'Path',
    _serializeFields: {
      segments: [],
      closed: false
    },
    initialize: function Path(arg) {
      this._closed = false;
      this._segments = [];
      this._version = 0;
      var args = arguments,
          segments = Array.isArray(arg) ? typeof arg[0] === 'object' ? arg : args : arg && arg.size === undefined && (arg.x !== undefined || arg.point !== undefined) ? args : null;

      if (segments && segments.length > 0) {
        this.setSegments(segments);
      } else {
        this._curves = undefined;
        this._segmentSelection = 0;

        if (!segments && typeof arg === 'string') {
          this.setPathData(arg);
          arg = null;
        }
      }

      this._initialize(!segments && arg);
    },
    _equals: function (item) {
      return this._closed === item._closed && Base.equals(this._segments, item._segments);
    },
    copyContent: function (source) {
      this.setSegments(source._segments);
      this._closed = source._closed;
    },
    _changed: function _changed(flags) {
      _changed.base.call(this, flags);

      if (flags & 8) {
        this._length = this._area = undefined;

        if (flags & 32) {
          this._version++;
        } else if (this._curves) {
          for (var i = 0, l = this._curves.length; i < l; i++) this._curves[i]._changed();
        }
      } else if (flags & 64) {
        this._bounds = undefined;
      }
    },
    getStyle: function () {
      var parent = this._parent;
      return (parent instanceof CompoundPath ? parent : this)._style;
    },
    getSegments: function () {
      return this._segments;
    },
    setSegments: function (segments) {
      var fullySelected = this.isFullySelected(),
          length = segments && segments.length;
      this._segments.length = 0;
      this._segmentSelection = 0;
      this._curves = undefined;

      if (length) {
        var last = segments[length - 1];

        if (typeof last === 'boolean') {
          this.setClosed(last);
          length--;
        }

        this._add(Segment.readList(segments, 0, {}, length));
      }

      if (fullySelected) this.setFullySelected(true);
    },
    getFirstSegment: function () {
      return this._segments[0];
    },
    getLastSegment: function () {
      return this._segments[this._segments.length - 1];
    },
    getCurves: function () {
      var curves = this._curves,
          segments = this._segments;

      if (!curves) {
        var length = this._countCurves();

        curves = this._curves = new Array(length);

        for (var i = 0; i < length; i++) curves[i] = new Curve(this, segments[i], segments[i + 1] || segments[0]);
      }

      return curves;
    },
    getFirstCurve: function () {
      return this.getCurves()[0];
    },
    getLastCurve: function () {
      var curves = this.getCurves();
      return curves[curves.length - 1];
    },
    isClosed: function () {
      return this._closed;
    },
    setClosed: function (closed) {
      if (this._closed != (closed = !!closed)) {
        this._closed = closed;

        if (this._curves) {
          var length = this._curves.length = this._countCurves();

          if (closed) this._curves[length - 1] = new Curve(this, this._segments[length - 1], this._segments[0]);
        }

        this._changed(41);
      }
    }
  }, {
    beans: true,
    getPathData: function (_matrix, _precision) {
      var segments = this._segments,
          length = segments.length,
          f = new Formatter(_precision),
          coords = new Array(6),
          first = true,
          curX,
          curY,
          prevX,
          prevY,
          inX,
          inY,
          outX,
          outY,
          parts = [];

      function addSegment(segment, skipLine) {
        segment._transformCoordinates(_matrix, coords);

        curX = coords[0];
        curY = coords[1];

        if (first) {
          parts.push('M' + f.pair(curX, curY));
          first = false;
        } else {
          inX = coords[2];
          inY = coords[3];

          if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
            if (!skipLine) {
              var dx = curX - prevX,
                  dy = curY - prevY;
              parts.push(dx === 0 ? 'v' + f.number(dy) : dy === 0 ? 'h' + f.number(dx) : 'l' + f.pair(dx, dy));
            }
          } else {
            parts.push('c' + f.pair(outX - prevX, outY - prevY) + ' ' + f.pair(inX - prevX, inY - prevY) + ' ' + f.pair(curX - prevX, curY - prevY));
          }
        }

        prevX = curX;
        prevY = curY;
        outX = coords[4];
        outY = coords[5];
      }

      if (!length) return '';

      for (var i = 0; i < length; i++) addSegment(segments[i]);

      if (this._closed && length > 0) {
        addSegment(segments[0], true);
        parts.push('z');
      }

      return parts.join('');
    },
    isEmpty: function () {
      return !this._segments.length;
    },
    _transformContent: function (matrix) {
      var segments = this._segments,
          coords = new Array(6);

      for (var i = 0, l = segments.length; i < l; i++) segments[i]._transformCoordinates(matrix, coords, true);

      return true;
    },
    _add: function (segs, index) {
      var segments = this._segments,
          curves = this._curves,
          amount = segs.length,
          append = index == null,
          index = append ? segments.length : index;

      for (var i = 0; i < amount; i++) {
        var segment = segs[i];
        if (segment._path) segment = segs[i] = segment.clone();
        segment._path = this;
        segment._index = index + i;
        if (segment._selection) this._updateSelection(segment, 0, segment._selection);
      }

      if (append) {
        Base.push(segments, segs);
      } else {
        segments.splice.apply(segments, [index, 0].concat(segs));

        for (var i = index + amount, l = segments.length; i < l; i++) segments[i]._index = i;
      }

      if (curves) {
        var total = this._countCurves(),
            start = index > 0 && index + amount - 1 === total ? index - 1 : index,
            insert = start,
            end = Math.min(start + amount, total);

        if (segs._curves) {
          curves.splice.apply(curves, [start, 0].concat(segs._curves));
          insert += segs._curves.length;
        }

        for (var i = insert; i < end; i++) curves.splice(i, 0, new Curve(this, null, null));

        this._adjustCurves(start, end);
      }

      this._changed(41);

      return segs;
    },
    _adjustCurves: function (start, end) {
      var segments = this._segments,
          curves = this._curves,
          curve;

      for (var i = start; i < end; i++) {
        curve = curves[i];
        curve._path = this;
        curve._segment1 = segments[i];
        curve._segment2 = segments[i + 1] || segments[0];

        curve._changed();
      }

      if (curve = curves[this._closed && !start ? segments.length - 1 : start - 1]) {
        curve._segment2 = segments[start] || segments[0];

        curve._changed();
      }

      if (curve = curves[end]) {
        curve._segment1 = segments[end];

        curve._changed();
      }
    },
    _countCurves: function () {
      var length = this._segments.length;
      return !this._closed && length > 0 ? length - 1 : length;
    },
    add: function (segment1) {
      var args = arguments;
      return args.length > 1 && typeof segment1 !== 'number' ? this._add(Segment.readList(args)) : this._add([Segment.read(args)])[0];
    },
    insert: function (index, segment1) {
      var args = arguments;
      return args.length > 2 && typeof segment1 !== 'number' ? this._add(Segment.readList(args, 1), index) : this._add([Segment.read(args, 1)], index)[0];
    },
    addSegment: function () {
      return this._add([Segment.read(arguments)])[0];
    },
    insertSegment: function (index) {
      return this._add([Segment.read(arguments, 1)], index)[0];
    },
    addSegments: function (segments) {
      return this._add(Segment.readList(segments));
    },
    insertSegments: function (index, segments) {
      return this._add(Segment.readList(segments), index);
    },
    removeSegment: function (index) {
      return this.removeSegments(index, index + 1)[0] || null;
    },
    removeSegments: function (start, end, _includeCurves) {
      start = start || 0;
      end = Base.pick(end, this._segments.length);
      var segments = this._segments,
          curves = this._curves,
          count = segments.length,
          removed = segments.splice(start, end - start),
          amount = removed.length;
      if (!amount) return removed;

      for (var i = 0; i < amount; i++) {
        var segment = removed[i];
        if (segment._selection) this._updateSelection(segment, segment._selection, 0);
        segment._index = segment._path = null;
      }

      for (var i = start, l = segments.length; i < l; i++) segments[i]._index = i;

      if (curves) {
        var index = start > 0 && end === count + (this._closed ? 1 : 0) ? start - 1 : start,
            curves = curves.splice(index, amount);

        for (var i = curves.length - 1; i >= 0; i--) curves[i]._path = null;

        if (_includeCurves) removed._curves = curves.slice(1);

        this._adjustCurves(index, index);
      }

      this._changed(41);

      return removed;
    },
    clear: '#removeSegments',
    hasHandles: function () {
      var segments = this._segments;

      for (var i = 0, l = segments.length; i < l; i++) {
        if (segments[i].hasHandles()) return true;
      }

      return false;
    },
    clearHandles: function () {
      var segments = this._segments;

      for (var i = 0, l = segments.length; i < l; i++) segments[i].clearHandles();
    },
    getLength: function () {
      if (this._length == null) {
        var curves = this.getCurves(),
            length = 0;

        for (var i = 0, l = curves.length; i < l; i++) length += curves[i].getLength();

        this._length = length;
      }

      return this._length;
    },
    getArea: function () {
      var area = this._area;

      if (area == null) {
        var segments = this._segments,
            closed = this._closed;
        area = 0;

        for (var i = 0, l = segments.length; i < l; i++) {
          var last = i + 1 === l;
          area += Curve.getArea(Curve.getValues(segments[i], segments[last ? 0 : i + 1], null, last && !closed));
        }

        this._area = area;
      }

      return area;
    },
    isFullySelected: function () {
      var length = this._segments.length;
      return this.isSelected() && length > 0 && this._segmentSelection === length * 7;
    },
    setFullySelected: function (selected) {
      if (selected) this._selectSegments(true);
      this.setSelected(selected);
    },
    setSelection: function setSelection(selection) {
      if (!(selection & 1)) this._selectSegments(false);
      setSelection.base.call(this, selection);
    },
    _selectSegments: function (selected) {
      var segments = this._segments,
          length = segments.length,
          selection = selected ? 7 : 0;
      this._segmentSelection = selection * length;

      for (var i = 0; i < length; i++) segments[i]._selection = selection;
    },
    _updateSelection: function (segment, oldSelection, newSelection) {
      segment._selection = newSelection;
      var selection = this._segmentSelection += newSelection - oldSelection;
      if (selection > 0) this.setSelected(true);
    },
    divideAt: function (location) {
      var loc = this.getLocationAt(location),
          curve;
      return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset())) ? curve._segment1 : null;
    },
    splitAt: function (location) {
      var loc = this.getLocationAt(location),
          index = loc && loc.index,
          time = loc && loc.time,
          tMin = 1e-8,
          tMax = 1 - tMin;

      if (time > tMax) {
        index++;
        time = 0;
      }

      var curves = this.getCurves();

      if (index >= 0 && index < curves.length) {
        if (time >= tMin) {
          curves[index++].divideAtTime(time);
        }

        var segs = this.removeSegments(index, this._segments.length, true),
            path;

        if (this._closed) {
          this.setClosed(false);
          path = this;
        } else {
          path = new Path(Item.NO_INSERT);
          path.insertAbove(this);
          path.copyAttributes(this);
        }

        path._add(segs, 0);

        this.addSegment(segs[0]);
        return path;
      }

      return null;
    },
    split: function (index, time) {
      var curve,
          location = time === undefined ? index : (curve = this.getCurves()[index]) && curve.getLocationAtTime(time);
      return location != null ? this.splitAt(location) : null;
    },
    join: function (path, tolerance) {
      var epsilon = tolerance || 0;

      if (path && path !== this) {
        var segments = path._segments,
            last1 = this.getLastSegment(),
            last2 = path.getLastSegment();
        if (!last2) return this;
        if (last1 && last1._point.isClose(last2._point, epsilon)) path.reverse();
        var first2 = path.getFirstSegment();

        if (last1 && last1._point.isClose(first2._point, epsilon)) {
          last1.setHandleOut(first2._handleOut);

          this._add(segments.slice(1));
        } else {
          var first1 = this.getFirstSegment();
          if (first1 && first1._point.isClose(first2._point, epsilon)) path.reverse();
          last2 = path.getLastSegment();

          if (first1 && first1._point.isClose(last2._point, epsilon)) {
            first1.setHandleIn(last2._handleIn);

            this._add(segments.slice(0, segments.length - 1), 0);
          } else {
            this._add(segments.slice());
          }
        }

        if (path._closed) this._add([segments[0]]);
        path.remove();
      }

      var first = this.getFirstSegment(),
          last = this.getLastSegment();

      if (first !== last && first._point.isClose(last._point, epsilon)) {
        first.setHandleIn(last._handleIn);
        last.remove();
        this.setClosed(true);
      }

      return this;
    },
    reduce: function (options) {
      var curves = this.getCurves(),
          simplify = options && options.simplify,
          tolerance = simplify ? 1e-7 : 0;

      for (var i = curves.length - 1; i >= 0; i--) {
        var curve = curves[i];
        if (!curve.hasHandles() && (!curve.hasLength(tolerance) || simplify && curve.isCollinear(curve.getNext()))) curve.remove();
      }

      return this;
    },
    reverse: function () {
      this._segments.reverse();

      for (var i = 0, l = this._segments.length; i < l; i++) {
        var segment = this._segments[i];
        var handleIn = segment._handleIn;
        segment._handleIn = segment._handleOut;
        segment._handleOut = handleIn;
        segment._index = i;
      }

      this._curves = null;

      this._changed(9);
    },
    flatten: function (flatness) {
      var flattener = new PathFlattener(this, flatness || 0.25, 256, true),
          parts = flattener.parts,
          length = parts.length,
          segments = [];

      for (var i = 0; i < length; i++) {
        segments.push(new Segment(parts[i].curve.slice(0, 2)));
      }

      if (!this._closed && length > 0) {
        segments.push(new Segment(parts[length - 1].curve.slice(6)));
      }

      this.setSegments(segments);
    },
    simplify: function (tolerance) {
      var segments = new PathFitter(this).fit(tolerance || 2.5);
      if (segments) this.setSegments(segments);
      return !!segments;
    },
    smooth: function (options) {
      var that = this,
          opts = options || {},
          type = opts.type || 'asymmetric',
          segments = this._segments,
          length = segments.length,
          closed = this._closed;

      function getIndex(value, _default) {
        var index = value && value.index;

        if (index != null) {
          var path = value.path;
          if (path && path !== that) throw new Error(value._class + ' ' + index + ' of ' + path + ' is not part of ' + that);
          if (_default && value instanceof Curve) index++;
        } else {
          index = typeof value === 'number' ? value : _default;
        }

        return Math.min(index < 0 && closed ? index % length : index < 0 ? index + length : index, length - 1);
      }

      var loop = closed && opts.from === undefined && opts.to === undefined,
          from = getIndex(opts.from, 0),
          to = getIndex(opts.to, length - 1);

      if (from > to) {
        if (closed) {
          from -= length;
        } else {
          var tmp = from;
          from = to;
          to = tmp;
        }
      }

      if (/^(?:asymmetric|continuous)$/.test(type)) {
        var asymmetric = type === 'asymmetric',
            min = Math.min,
            amount = to - from + 1,
            n = amount - 1,
            padding = loop ? min(amount, 4) : 1,
            paddingLeft = padding,
            paddingRight = padding,
            knots = [];

        if (!closed) {
          paddingLeft = min(1, from);
          paddingRight = min(1, length - to - 1);
        }

        n += paddingLeft + paddingRight;
        if (n <= 1) return;

        for (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {
          knots[i] = segments[(j < 0 ? j + length : j) % length]._point;
        }

        var x = knots[0]._x + 2 * knots[1]._x,
            y = knots[0]._y + 2 * knots[1]._y,
            f = 2,
            n_1 = n - 1,
            rx = [x],
            ry = [y],
            rf = [f],
            px = [],
            py = [];

        for (var i = 1; i < n; i++) {
          var internal = i < n_1,
              a = internal ? 1 : asymmetric ? 1 : 2,
              b = internal ? 4 : asymmetric ? 2 : 7,
              u = internal ? 4 : asymmetric ? 3 : 8,
              v = internal ? 2 : asymmetric ? 0 : 1,
              m = a / f;
          f = rf[i] = b - m;
          x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;
          y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;
        }

        px[n_1] = rx[n_1] / rf[n_1];
        py[n_1] = ry[n_1] / rf[n_1];

        for (var i = n - 2; i >= 0; i--) {
          px[i] = (rx[i] - px[i + 1]) / rf[i];
          py[i] = (ry[i] - py[i + 1]) / rf[i];
        }

        px[n] = (3 * knots[n]._x - px[n_1]) / 2;
        py[n] = (3 * knots[n]._y - py[n_1]) / 2;

        for (var i = paddingLeft, max = n - paddingRight, j = from; i <= max; i++, j++) {
          var segment = segments[j < 0 ? j + length : j],
              pt = segment._point,
              hx = px[i] - pt._x,
              hy = py[i] - pt._y;
          if (loop || i < max) segment.setHandleOut(hx, hy);
          if (loop || i > paddingLeft) segment.setHandleIn(-hx, -hy);
        }
      } else {
        for (var i = from; i <= to; i++) {
          segments[i < 0 ? i + length : i].smooth(opts, !loop && i === from, !loop && i === to);
        }
      }
    },
    toShape: function (insert) {
      if (!this._closed) return null;
      var segments = this._segments,
          type,
          size,
          radius,
          topCenter;

      function isCollinear(i, j) {
        var seg1 = segments[i],
            seg2 = seg1.getNext(),
            seg3 = segments[j],
            seg4 = seg3.getNext();
        return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg3._handleOut.isZero() && seg4._handleIn.isZero() && seg2._point.subtract(seg1._point).isCollinear(seg4._point.subtract(seg3._point));
      }

      function isOrthogonal(i) {
        var seg2 = segments[i],
            seg1 = seg2.getPrevious(),
            seg3 = seg2.getNext();
        return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg2._handleOut.isZero() && seg3._handleIn.isZero() && seg2._point.subtract(seg1._point).isOrthogonal(seg3._point.subtract(seg2._point));
      }

      function isArc(i) {
        var seg1 = segments[i],
            seg2 = seg1.getNext(),
            handle1 = seg1._handleOut,
            handle2 = seg2._handleIn,
            kappa = 0.5522847498307936;

        if (handle1.isOrthogonal(handle2)) {
          var pt1 = seg1._point,
              pt2 = seg2._point,
              corner = new Line(pt1, handle1, true).intersect(new Line(pt2, handle2, true), true);
          return corner && Numerical.isZero(handle1.getLength() / corner.subtract(pt1).getLength() - kappa) && Numerical.isZero(handle2.getLength() / corner.subtract(pt2).getLength() - kappa);
        }

        return false;
      }

      function getDistance(i, j) {
        return segments[i]._point.getDistance(segments[j]._point);
      }

      if (!this.hasHandles() && segments.length === 4 && isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
        type = Shape.Rectangle;
        size = new Size(getDistance(0, 3), getDistance(0, 1));
        topCenter = segments[1]._point.add(segments[2]._point).divide(2);
      } else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4) && isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
        type = Shape.Rectangle;
        size = new Size(getDistance(1, 6), getDistance(0, 3));
        radius = size.subtract(new Size(getDistance(0, 7), getDistance(1, 2))).divide(2);
        topCenter = segments[3]._point.add(segments[4]._point).divide(2);
      } else if (segments.length === 4 && isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
        if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
          type = Shape.Circle;
          radius = getDistance(0, 2) / 2;
        } else {
          type = Shape.Ellipse;
          radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
        }

        topCenter = segments[1]._point;
      }

      if (type) {
        var center = this.getPosition(true),
            shape = new type({
          center: center,
          size: size,
          radius: radius,
          insert: false
        });
        shape.copyAttributes(this, true);

        shape._matrix.prepend(this._matrix);

        shape.rotate(topCenter.subtract(center).getAngle() + 90);
        if (insert === undefined || insert) shape.insertAbove(this);
        return shape;
      }

      return null;
    },
    toPath: '#clone',
    compare: function compare(path) {
      if (!path || path instanceof CompoundPath) return compare.base.call(this, path);
      var curves1 = this.getCurves(),
          curves2 = path.getCurves(),
          length1 = curves1.length,
          length2 = curves2.length;

      if (!length1 || !length2) {
        return length1 == length2;
      }

      var v1 = curves1[0].getValues(),
          values2 = [],
          pos1 = 0,
          pos2,
          end1 = 0,
          end2;

      for (var i = 0; i < length2; i++) {
        var v2 = curves2[i].getValues();
        values2.push(v2);
        var overlaps = Curve.getOverlaps(v1, v2);

        if (overlaps) {
          pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;
          end2 = overlaps[0][1];
          break;
        }
      }

      var abs = Math.abs,
          epsilon = 1e-8,
          v2 = values2[pos2],
          start2;

      while (v1 && v2) {
        var overlaps = Curve.getOverlaps(v1, v2);

        if (overlaps) {
          var t1 = overlaps[0][0];

          if (abs(t1 - end1) < epsilon) {
            end1 = overlaps[1][0];

            if (end1 === 1) {
              v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
              end1 = 0;
            }

            var t2 = overlaps[0][1];

            if (abs(t2 - end2) < epsilon) {
              if (!start2) start2 = [pos2, t2];
              end2 = overlaps[1][1];

              if (end2 === 1) {
                if (++pos2 >= length2) pos2 = 0;
                v2 = values2[pos2] || curves2[pos2].getValues();
                end2 = 0;
              }

              if (!v1) {
                return start2[0] === pos2 && start2[1] === end2;
              }

              continue;
            }
          }
        }

        break;
      }

      return false;
    },
    _hitTestSelf: function (point, options, viewMatrix, strokeMatrix) {
      var that = this,
          style = this.getStyle(),
          segments = this._segments,
          numSegments = segments.length,
          closed = this._closed,
          tolerancePadding = options._tolerancePadding,
          strokePadding = tolerancePadding,
          join,
          cap,
          miterLimit,
          area,
          loc,
          res,
          hitStroke = options.stroke && style.hasStroke(),
          hitFill = options.fill && style.hasFill(),
          hitCurves = options.curves,
          strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : hitFill && options.tolerance > 0 || hitCurves ? 0 : null;

      if (strokeRadius !== null) {
        if (strokeRadius > 0) {
          join = style.getStrokeJoin();
          cap = style.getStrokeCap();
          miterLimit = style.getMiterLimit();
          strokePadding = strokePadding.add(Path._getStrokePadding(strokeRadius, strokeMatrix));
        } else {
          join = cap = 'round';
        }
      }

      function isCloseEnough(pt, padding) {
        return point.subtract(pt).divide(padding).length <= 1;
      }

      function checkSegmentPoint(seg, pt, name) {
        if (!options.selected || pt.isSelected()) {
          var anchor = seg._point;
          if (pt !== anchor) pt = pt.add(anchor);

          if (isCloseEnough(pt, strokePadding)) {
            return new HitResult(name, that, {
              segment: seg,
              point: pt
            });
          }
        }
      }

      function checkSegmentPoints(seg, ends) {
        return (ends || options.segments) && checkSegmentPoint(seg, seg._point, 'segment') || !ends && options.handles && (checkSegmentPoint(seg, seg._handleIn, 'handle-in') || checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
      }

      function addToArea(point) {
        area.add(point);
      }

      function checkSegmentStroke(segment) {
        var isJoin = closed || segment._index > 0 && segment._index < numSegments - 1;

        if ((isJoin ? join : cap) === 'round') {
          return isCloseEnough(segment._point, strokePadding);
        } else {
          area = new Path({
            internal: true,
            closed: true
          });

          if (isJoin) {
            if (!segment.isSmooth()) {
              Path._addBevelJoin(segment, join, strokeRadius, miterLimit, null, strokeMatrix, addToArea, true);
            }
          } else if (cap === 'square') {
            Path._addSquareCap(segment, cap, strokeRadius, null, strokeMatrix, addToArea, true);
          }

          if (!area.isEmpty()) {
            var loc;
            return area.contains(point) || (loc = area.getNearestLocation(point)) && isCloseEnough(loc.getPoint(), tolerancePadding);
          }
        }
      }

      if (options.ends && !options.segments && !closed) {
        if (res = checkSegmentPoints(segments[0], true) || checkSegmentPoints(segments[numSegments - 1], true)) return res;
      } else if (options.segments || options.handles) {
        for (var i = 0; i < numSegments; i++) if (res = checkSegmentPoints(segments[i])) return res;
      }

      if (strokeRadius !== null) {
        loc = this.getNearestLocation(point);

        if (loc) {
          var time = loc.getTime();

          if (time === 0 || time === 1 && numSegments > 1) {
            if (!checkSegmentStroke(loc.getSegment())) loc = null;
          } else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
            loc = null;
          }
        }

        if (!loc && join === 'miter' && numSegments > 1) {
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];

            if (point.getDistance(segment._point) <= miterLimit * strokeRadius && checkSegmentStroke(segment)) {
              loc = segment.getLocation();
              break;
            }
          }
        }
      }

      return !loc && hitFill && this._contains(point) || loc && !hitStroke && !hitCurves ? new HitResult('fill', this) : loc ? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
        location: loc,
        point: loc.getPoint()
      }) : null;
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    this[name + 'At'] = function (offset) {
      var loc = this.getLocationAt(offset);
      return loc && loc[name]();
    };
  }, {
    beans: false,
    getLocationOf: function () {
      var point = Point.read(arguments),
          curves = this.getCurves();

      for (var i = 0, l = curves.length; i < l; i++) {
        var loc = curves[i].getLocationOf(point);
        if (loc) return loc;
      }

      return null;
    },
    getOffsetOf: function () {
      var loc = this.getLocationOf.apply(this, arguments);
      return loc ? loc.getOffset() : null;
    },
    getLocationAt: function (offset) {
      if (typeof offset === 'number') {
        var curves = this.getCurves(),
            length = 0;

        for (var i = 0, l = curves.length; i < l; i++) {
          var start = length,
              curve = curves[i];
          length += curve.getLength();

          if (length > offset) {
            return curve.getLocationAt(offset - start);
          }
        }

        if (curves.length > 0 && offset <= this.getLength()) {
          return new CurveLocation(curves[curves.length - 1], 1);
        }
      } else if (offset && offset.getPath && offset.getPath() === this) {
        return offset;
      }

      return null;
    },
    getOffsetsWithTangent: function () {
      var tangent = Point.read(arguments);

      if (tangent.isZero()) {
        return [];
      }

      var offsets = [];
      var curveStart = 0;
      var curves = this.getCurves();

      for (var i = 0, l = curves.length; i < l; i++) {
        var curve = curves[i];
        var curveTimes = curve.getTimesWithTangent(tangent);

        for (var j = 0, m = curveTimes.length; j < m; j++) {
          var offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);

          if (offsets.indexOf(offset) < 0) {
            offsets.push(offset);
          }
        }

        curveStart += curve.length;
      }

      return offsets;
    }
  }), new function () {
    function drawHandles(ctx, segments, matrix, size) {
      if (size <= 0) return;
      var half = size / 2,
          miniSize = size - 2,
          miniHalf = half - 1,
          coords = new Array(6),
          pX,
          pY;

      function drawHandle(index) {
        var hX = coords[index],
            hY = coords[index + 1];

        if (pX != hX || pY != hY) {
          ctx.beginPath();
          ctx.moveTo(pX, pY);
          ctx.lineTo(hX, hY);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
          ctx.fill();
        }
      }

      for (var i = 0, l = segments.length; i < l; i++) {
        var segment = segments[i],
            selection = segment._selection;

        segment._transformCoordinates(matrix, coords);

        pX = coords[0];
        pY = coords[1];
        if (selection & 2) drawHandle(2);
        if (selection & 4) drawHandle(4);
        ctx.fillRect(pX - half, pY - half, size, size);

        if (miniSize > 0 && !(selection & 1)) {
          var fillStyle = ctx.fillStyle;
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);
          ctx.fillStyle = fillStyle;
        }
      }
    }

    function drawSegments(ctx, path, matrix) {
      var segments = path._segments,
          length = segments.length,
          coords = new Array(6),
          first = true,
          curX,
          curY,
          prevX,
          prevY,
          inX,
          inY,
          outX,
          outY;

      function drawSegment(segment) {
        if (matrix) {
          segment._transformCoordinates(matrix, coords);

          curX = coords[0];
          curY = coords[1];
        } else {
          var point = segment._point;
          curX = point._x;
          curY = point._y;
        }

        if (first) {
          ctx.moveTo(curX, curY);
          first = false;
        } else {
          if (matrix) {
            inX = coords[2];
            inY = coords[3];
          } else {
            var handle = segment._handleIn;
            inX = curX + handle._x;
            inY = curY + handle._y;
          }

          if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
            ctx.lineTo(curX, curY);
          } else {
            ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
          }
        }

        prevX = curX;
        prevY = curY;

        if (matrix) {
          outX = coords[4];
          outY = coords[5];
        } else {
          var handle = segment._handleOut;
          outX = prevX + handle._x;
          outY = prevY + handle._y;
        }
      }

      for (var i = 0; i < length; i++) drawSegment(segments[i]);

      if (path._closed && length > 0) drawSegment(segments[0]);
    }

    return {
      _draw: function (ctx, param, viewMatrix, strokeMatrix) {
        var dontStart = param.dontStart,
            dontPaint = param.dontFinish || param.clip,
            style = this.getStyle(),
            hasFill = style.hasFill(),
            hasStroke = style.hasStroke(),
            dashArray = style.getDashArray(),
            dashLength = !paper.support.nativeDash && hasStroke && dashArray && dashArray.length;
        if (!dontStart) ctx.beginPath();

        if (hasFill || hasStroke && !dashLength || dontPaint) {
          drawSegments(ctx, this, strokeMatrix);
          if (this._closed) ctx.closePath();
        }

        function getOffset(i) {
          return dashArray[(i % dashLength + dashLength) % dashLength];
        }

        if (!dontPaint && (hasFill || hasStroke)) {
          this._setStyles(ctx, param, viewMatrix);

          if (hasFill) {
            ctx.fill(style.getFillRule());
            ctx.shadowColor = 'rgba(0,0,0,0)';
          }

          if (hasStroke) {
            if (dashLength) {
              if (!dontStart) ctx.beginPath();
              var flattener = new PathFlattener(this, 0.25, 32, false, strokeMatrix),
                  length = flattener.length,
                  from = -style.getDashOffset(),
                  to,
                  i = 0;

              while (from > 0) {
                from -= getOffset(i--) + getOffset(i--);
              }

              while (from < length) {
                to = from + getOffset(i++);
                if (from > 0 || to > 0) flattener.drawPart(ctx, Math.max(from, 0), Math.max(to, 0));
                from = to + getOffset(i++);
              }
            }

            ctx.stroke();
          }
        }
      },
      _drawSelected: function (ctx, matrix) {
        ctx.beginPath();
        drawSegments(ctx, this, matrix);
        ctx.stroke();
        drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
      }
    };
  }(), new function () {
    function getCurrentSegment(that) {
      var segments = that._segments;
      if (!segments.length) throw new Error('Use a moveTo() command first');
      return segments[segments.length - 1];
    }

    return {
      moveTo: function () {
        var segments = this._segments;
        if (segments.length === 1) this.removeSegment(0);
        if (!segments.length) this._add([new Segment(Point.read(arguments))]);
      },
      moveBy: function () {
        throw new Error('moveBy() is unsupported on Path items.');
      },
      lineTo: function () {
        this._add([new Segment(Point.read(arguments))]);
      },
      cubicCurveTo: function () {
        var args = arguments,
            handle1 = Point.read(args),
            handle2 = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this);
        current.setHandleOut(handle1.subtract(current._point));

        this._add([new Segment(to, handle2.subtract(to))]);
      },
      quadraticCurveTo: function () {
        var args = arguments,
            handle = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.cubicCurveTo(handle.add(current.subtract(handle).multiply(1 / 3)), handle.add(to.subtract(handle).multiply(1 / 3)), to);
      },
      curveTo: function () {
        var args = arguments,
            through = Point.read(args),
            to = Point.read(args),
            t = Base.pick(Base.read(args), 0.5),
            t1 = 1 - t,
            current = getCurrentSegment(this)._point,
            handle = through.subtract(current.multiply(t1 * t1)).subtract(to.multiply(t * t)).divide(2 * t * t1);

        if (handle.isNaN()) throw new Error('Cannot put a curve through points with parameter = ' + t);
        this.quadraticCurveTo(handle, to);
      },
      arcTo: function () {
        var args = arguments,
            abs = Math.abs,
            sqrt = Math.sqrt,
            current = getCurrentSegment(this),
            from = current._point,
            to = Point.read(args),
            through,
            peek = Base.peek(args),
            clockwise = Base.pick(peek, true),
            center,
            extent,
            vector,
            matrix;

        if (typeof clockwise === 'boolean') {
          var middle = from.add(to).divide(2),
              through = middle.add(middle.subtract(from).rotate(clockwise ? -90 : 90));
        } else if (Base.remain(args) <= 2) {
          through = to;
          to = Point.read(args);
        } else if (!from.equals(to)) {
          var radius = Size.read(args),
              isZero = Numerical.isZero;
          if (isZero(radius.width) || isZero(radius.height)) return this.lineTo(to);
          var rotation = Base.read(args),
              clockwise = !!Base.read(args),
              large = !!Base.read(args),
              middle = from.add(to).divide(2),
              pt = from.subtract(middle).rotate(-rotation),
              x = pt.x,
              y = pt.y,
              rx = abs(radius.width),
              ry = abs(radius.height),
              rxSq = rx * rx,
              rySq = ry * ry,
              xSq = x * x,
              ySq = y * y;
          var factor = sqrt(xSq / rxSq + ySq / rySq);

          if (factor > 1) {
            rx *= factor;
            ry *= factor;
            rxSq = rx * rx;
            rySq = ry * ry;
          }

          factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) / (rxSq * ySq + rySq * xSq);
          if (abs(factor) < 1e-12) factor = 0;
          if (factor < 0) throw new Error('Cannot create an arc with the given arguments');
          center = new Point(rx * y / ry, -ry * x / rx).multiply((large === clockwise ? -1 : 1) * sqrt(factor)).rotate(rotation).add(middle);
          matrix = new Matrix().translate(center).rotate(rotation).scale(rx, ry);
          vector = matrix._inverseTransform(from);
          extent = vector.getDirectedAngle(matrix._inverseTransform(to));
          if (!clockwise && extent > 0) extent -= 360;else if (clockwise && extent < 0) extent += 360;
        }

        if (through) {
          var l1 = new Line(from.add(through).divide(2), through.subtract(from).rotate(90), true),
              l2 = new Line(through.add(to).divide(2), to.subtract(through).rotate(90), true),
              line = new Line(from, to),
              throughSide = line.getSide(through);
          center = l1.intersect(l2, true);

          if (!center) {
            if (!throughSide) return this.lineTo(to);
            throw new Error('Cannot create an arc with the given arguments');
          }

          vector = from.subtract(center);
          extent = vector.getDirectedAngle(to.subtract(center));
          var centerSide = line.getSide(center, true);

          if (centerSide === 0) {
            extent = throughSide * abs(extent);
          } else if (throughSide === centerSide) {
            extent += extent < 0 ? 360 : -360;
          }
        }

        if (extent) {
          var epsilon = 1e-7,
              ext = abs(extent),
              count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),
              inc = extent / count,
              half = inc * Math.PI / 360,
              z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
              segments = [];

          for (var i = 0; i <= count; i++) {
            var pt = to,
                out = null;

            if (i < count) {
              out = vector.rotate(90).multiply(z);

              if (matrix) {
                pt = matrix._transformPoint(vector);
                out = matrix._transformPoint(vector.add(out)).subtract(pt);
              } else {
                pt = center.add(vector);
              }
            }

            if (!i) {
              current.setHandleOut(out);
            } else {
              var _in = vector.rotate(-90).multiply(z);

              if (matrix) {
                _in = matrix._transformPoint(vector.add(_in)).subtract(pt);
              }

              segments.push(new Segment(pt, _in, out));
            }

            vector = vector.rotate(inc);
          }

          this._add(segments);
        }
      },
      lineBy: function () {
        var to = Point.read(arguments),
            current = getCurrentSegment(this)._point;

        this.lineTo(current.add(to));
      },
      curveBy: function () {
        var args = arguments,
            through = Point.read(args),
            to = Point.read(args),
            parameter = Base.read(args),
            current = getCurrentSegment(this)._point;

        this.curveTo(current.add(through), current.add(to), parameter);
      },
      cubicCurveBy: function () {
        var args = arguments,
            handle1 = Point.read(args),
            handle2 = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.cubicCurveTo(current.add(handle1), current.add(handle2), current.add(to));
      },
      quadraticCurveBy: function () {
        var args = arguments,
            handle = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.quadraticCurveTo(current.add(handle), current.add(to));
      },
      arcBy: function () {
        var args = arguments,
            current = getCurrentSegment(this)._point,
            point = current.add(Point.read(args)),
            clockwise = Base.pick(Base.peek(args), true);

        if (typeof clockwise === 'boolean') {
          this.arcTo(point, clockwise);
        } else {
          this.arcTo(point, current.add(Point.read(args)));
        }
      },
      closePath: function (tolerance) {
        this.setClosed(true);
        this.join(this, tolerance);
      }
    };
  }(), {
    _getBounds: function (matrix, options) {
      var method = options.handle ? 'getHandleBounds' : options.stroke ? 'getStrokeBounds' : 'getBounds';
      return Path[method](this._segments, this._closed, this, matrix, options);
    },
    statics: {
      getBounds: function (segments, closed, path, matrix, options, strokePadding) {
        var first = segments[0];
        if (!first) return new Rectangle();

        var coords = new Array(6),
            prevCoords = first._transformCoordinates(matrix, new Array(6)),
            min = prevCoords.slice(0, 2),
            max = min.slice(),
            roots = new Array(2);

        function processSegment(segment) {
          segment._transformCoordinates(matrix, coords);

          for (var i = 0; i < 2; i++) {
            Curve._addBounds(prevCoords[i], prevCoords[i + 4], coords[i + 2], coords[i], i, strokePadding ? strokePadding[i] : 0, min, max, roots);
          }

          var tmp = prevCoords;
          prevCoords = coords;
          coords = tmp;
        }

        for (var i = 1, l = segments.length; i < l; i++) processSegment(segments[i]);

        if (closed) processSegment(first);
        return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      getStrokeBounds: function (segments, closed, path, matrix, options) {
        var style = path.getStyle(),
            stroke = style.hasStroke(),
            strokeWidth = style.getStrokeWidth(),
            strokeMatrix = stroke && path._getStrokeMatrix(matrix, options),
            strokePadding = stroke && Path._getStrokePadding(strokeWidth, strokeMatrix),
            bounds = Path.getBounds(segments, closed, path, matrix, options, strokePadding);

        if (!stroke) return bounds;
        var strokeRadius = strokeWidth / 2,
            join = style.getStrokeJoin(),
            cap = style.getStrokeCap(),
            miterLimit = style.getMiterLimit(),
            joinBounds = new Rectangle(new Size(strokePadding));

        function addPoint(point) {
          bounds = bounds.include(point);
        }

        function addRound(segment) {
          bounds = bounds.unite(joinBounds.setCenter(segment._point.transform(matrix)));
        }

        function addJoin(segment, join) {
          if (join === 'round' || segment.isSmooth()) {
            addRound(segment);
          } else {
            Path._addBevelJoin(segment, join, strokeRadius, miterLimit, matrix, strokeMatrix, addPoint);
          }
        }

        function addCap(segment, cap) {
          if (cap === 'round') {
            addRound(segment);
          } else {
            Path._addSquareCap(segment, cap, strokeRadius, matrix, strokeMatrix, addPoint);
          }
        }

        var length = segments.length - (closed ? 0 : 1);

        if (length > 0) {
          for (var i = 1; i < length; i++) {
            addJoin(segments[i], join);
          }

          if (closed) {
            addJoin(segments[0], join);
          } else {
            addCap(segments[0], cap);
            addCap(segments[segments.length - 1], cap);
          }
        }

        return bounds;
      },
      _getStrokePadding: function (radius, matrix) {
        if (!matrix) return [radius, radius];
        var hor = new Point(radius, 0).transform(matrix),
            ver = new Point(0, radius).transform(matrix),
            phi = hor.getAngleInRadians(),
            a = hor.getLength(),
            b = ver.getLength();
        var sin = Math.sin(phi),
            cos = Math.cos(phi),
            tan = Math.tan(phi),
            tx = Math.atan2(b * tan, a),
            ty = Math.atan2(b, tan * a);
        return [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin), Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
      },
      _addBevelJoin: function (segment, join, radius, miterLimit, matrix, strokeMatrix, addPoint, isArea) {
        var curve2 = segment.getCurve(),
            curve1 = curve2.getPrevious(),
            point = curve2.getPoint1().transform(matrix),
            normal1 = curve1.getNormalAtTime(1).multiply(radius).transform(strokeMatrix),
            normal2 = curve2.getNormalAtTime(0).multiply(radius).transform(strokeMatrix),
            angle = normal1.getDirectedAngle(normal2);

        if (angle < 0 || angle >= 180) {
          normal1 = normal1.negate();
          normal2 = normal2.negate();
        }

        if (isArea) addPoint(point);
        addPoint(point.add(normal1));

        if (join === 'miter') {
          var corner = new Line(point.add(normal1), new Point(-normal1.y, normal1.x), true).intersect(new Line(point.add(normal2), new Point(-normal2.y, normal2.x), true), true);

          if (corner && point.getDistance(corner) <= miterLimit * radius) {
            addPoint(corner);
          }
        }

        addPoint(point.add(normal2));
      },
      _addSquareCap: function (segment, cap, radius, matrix, strokeMatrix, addPoint, isArea) {
        var point = segment._point.transform(matrix),
            loc = segment.getLocation(),
            normal = loc.getNormal().multiply(loc.getTime() === 0 ? radius : -radius).transform(strokeMatrix);

        if (cap === 'square') {
          if (isArea) {
            addPoint(point.subtract(normal));
            addPoint(point.add(normal));
          }

          point = point.add(normal.rotate(-90));
        }

        addPoint(point.add(normal));
        addPoint(point.subtract(normal));
      },
      getHandleBounds: function (segments, closed, path, matrix, options) {
        var style = path.getStyle(),
            stroke = options.stroke && style.hasStroke(),
            strokePadding,
            joinPadding;

        if (stroke) {
          var strokeMatrix = path._getStrokeMatrix(matrix, options),
              strokeRadius = style.getStrokeWidth() / 2,
              joinRadius = strokeRadius;

          if (style.getStrokeJoin() === 'miter') joinRadius = strokeRadius * style.getMiterLimit();
          if (style.getStrokeCap() === 'square') joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
          strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
          joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
        }

        var coords = new Array(6),
            x1 = Infinity,
            x2 = -x1,
            y1 = x1,
            y2 = x2;

        for (var i = 0, l = segments.length; i < l; i++) {
          var segment = segments[i];

          segment._transformCoordinates(matrix, coords);

          for (var j = 0; j < 6; j += 2) {
            var padding = !j ? joinPadding : strokePadding,
                paddingX = padding ? padding[0] : 0,
                paddingY = padding ? padding[1] : 0,
                x = coords[j],
                y = coords[j + 1],
                xn = x - paddingX,
                xx = x + paddingX,
                yn = y - paddingY,
                yx = y + paddingY;
            if (xn < x1) x1 = xn;
            if (xx > x2) x2 = xx;
            if (yn < y1) y1 = yn;
            if (yx > y2) y2 = yx;
          }
        }

        return new Rectangle(x1, y1, x2 - x1, y2 - y1);
      }
    }
  });
  Path.inject({
    statics: new function () {
      var kappa = 0.5522847498307936,
          ellipseSegments = [new Segment([-1, 0], [0, kappa], [0, -kappa]), new Segment([0, -1], [-kappa, 0], [kappa, 0]), new Segment([1, 0], [0, -kappa], [0, kappa]), new Segment([0, 1], [kappa, 0], [-kappa, 0])];

      function createPath(segments, closed, args) {
        var props = Base.getNamed(args),
            path = new Path(props && props.insert == false && Item.NO_INSERT);

        path._add(segments);

        path._closed = closed;
        return path.set(props, {
          insert: true
        });
      }

      function createEllipse(center, radius, args) {
        var segments = new Array(4);

        for (var i = 0; i < 4; i++) {
          var segment = ellipseSegments[i];
          segments[i] = new Segment(segment._point.multiply(radius).add(center), segment._handleIn.multiply(radius), segment._handleOut.multiply(radius));
        }

        return createPath(segments, true, args);
      }

      return {
        Line: function () {
          var args = arguments;
          return createPath([new Segment(Point.readNamed(args, 'from')), new Segment(Point.readNamed(args, 'to'))], false, args);
        },
        Circle: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              radius = Base.readNamed(args, 'radius');
          return createEllipse(center, new Size(radius), args);
        },
        Rectangle: function () {
          var args = arguments,
              rect = Rectangle.readNamed(args, 'rectangle'),
              radius = Size.readNamed(args, 'radius', 0, {
            readNull: true
          }),
              bl = rect.getBottomLeft(true),
              tl = rect.getTopLeft(true),
              tr = rect.getTopRight(true),
              br = rect.getBottomRight(true),
              segments;

          if (!radius || radius.isZero()) {
            segments = [new Segment(bl), new Segment(tl), new Segment(tr), new Segment(br)];
          } else {
            radius = Size.min(radius, rect.getSize(true).divide(2));
            var rx = radius.width,
                ry = radius.height,
                hx = rx * kappa,
                hy = ry * kappa;
            segments = [new Segment(bl.add(rx, 0), null, [-hx, 0]), new Segment(bl.subtract(0, ry), [0, hy]), new Segment(tl.add(0, ry), null, [0, -hy]), new Segment(tl.add(rx, 0), [-hx, 0], null), new Segment(tr.subtract(rx, 0), null, [hx, 0]), new Segment(tr.add(0, ry), [0, -hy], null), new Segment(br.subtract(0, ry), null, [0, hy]), new Segment(br.subtract(rx, 0), [hx, 0])];
          }

          return createPath(segments, true, args);
        },
        RoundRectangle: '#Rectangle',
        Ellipse: function () {
          var args = arguments,
              ellipse = Shape._readEllipse(args);

          return createEllipse(ellipse.center, ellipse.radius, args);
        },
        Oval: '#Ellipse',
        Arc: function () {
          var args = arguments,
              from = Point.readNamed(args, 'from'),
              through = Point.readNamed(args, 'through'),
              to = Point.readNamed(args, 'to'),
              props = Base.getNamed(args),
              path = new Path(props && props.insert == false && Item.NO_INSERT);
          path.moveTo(from);
          path.arcTo(through, to);
          return path.set(props);
        },
        RegularPolygon: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              sides = Base.readNamed(args, 'sides'),
              radius = Base.readNamed(args, 'radius'),
              step = 360 / sides,
              three = sides % 3 === 0,
              vector = new Point(0, three ? -radius : radius),
              offset = three ? -1 : 0.5,
              segments = new Array(sides);

          for (var i = 0; i < sides; i++) segments[i] = new Segment(center.add(vector.rotate((i + offset) * step)));

          return createPath(segments, true, args);
        },
        Star: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              points = Base.readNamed(args, 'points') * 2,
              radius1 = Base.readNamed(args, 'radius1'),
              radius2 = Base.readNamed(args, 'radius2'),
              step = 360 / points,
              vector = new Point(0, -1),
              segments = new Array(points);

          for (var i = 0; i < points; i++) segments[i] = new Segment(center.add(vector.rotate(step * i).multiply(i % 2 ? radius2 : radius1)));

          return createPath(segments, true, args);
        }
      };
    }()
  });
  var CompoundPath = PathItem.extend({
    _class: 'CompoundPath',
    _serializeFields: {
      children: []
    },
    beans: true,
    initialize: function CompoundPath(arg) {
      this._children = [];
      this._namedChildren = {};

      if (!this._initialize(arg)) {
        if (typeof arg === 'string') {
          this.setPathData(arg);
        } else {
          this.addChildren(Array.isArray(arg) ? arg : arguments);
        }
      }
    },
    insertChildren: function insertChildren(index, items) {
      var list = items,
          first = list[0];
      if (first && typeof first[0] === 'number') list = [list];

      for (var i = items.length - 1; i >= 0; i--) {
        var item = list[i];
        if (list === items && !(item instanceof Path)) list = Base.slice(list);

        if (Array.isArray(item)) {
          list[i] = new Path({
            segments: item,
            insert: false
          });
        } else if (item instanceof CompoundPath) {
          list.splice.apply(list, [i, 1].concat(item.removeChildren()));
          item.remove();
        }
      }

      return insertChildren.base.call(this, index, list);
    },
    reduce: function reduce(options) {
      var children = this._children;

      for (var i = children.length - 1; i >= 0; i--) {
        var path = children[i].reduce(options);
        if (path.isEmpty()) path.remove();
      }

      if (!children.length) {
        var path = new Path(Item.NO_INSERT);
        path.copyAttributes(this);
        path.insertAbove(this);
        this.remove();
        return path;
      }

      return reduce.base.call(this);
    },
    isClosed: function () {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        if (!children[i]._closed) return false;
      }

      return true;
    },
    setClosed: function (closed) {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].setClosed(closed);
      }
    },
    getFirstSegment: function () {
      var first = this.getFirstChild();
      return first && first.getFirstSegment();
    },
    getLastSegment: function () {
      var last = this.getLastChild();
      return last && last.getLastSegment();
    },
    getCurves: function () {
      var children = this._children,
          curves = [];

      for (var i = 0, l = children.length; i < l; i++) {
        Base.push(curves, children[i].getCurves());
      }

      return curves;
    },
    getFirstCurve: function () {
      var first = this.getFirstChild();
      return first && first.getFirstCurve();
    },
    getLastCurve: function () {
      var last = this.getLastChild();
      return last && last.getLastCurve();
    },
    getArea: function () {
      var children = this._children,
          area = 0;

      for (var i = 0, l = children.length; i < l; i++) area += children[i].getArea();

      return area;
    },
    getLength: function () {
      var children = this._children,
          length = 0;

      for (var i = 0, l = children.length; i < l; i++) length += children[i].getLength();

      return length;
    },
    getPathData: function (_matrix, _precision) {
      var children = this._children,
          paths = [];

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i],
            mx = child._matrix;
        paths.push(child.getPathData(_matrix && !mx.isIdentity() ? _matrix.appended(mx) : _matrix, _precision));
      }

      return paths.join('');
    },
    _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
      return _hitTestChildren.base.call(this, point, options.class === Path || options.type === 'path' ? options : Base.set({}, options, {
        fill: false
      }), viewMatrix);
    },
    _draw: function (ctx, param, viewMatrix, strokeMatrix) {
      var children = this._children;
      if (!children.length) return;
      param = param.extend({
        dontStart: true,
        dontFinish: true
      });
      ctx.beginPath();

      for (var i = 0, l = children.length; i < l; i++) children[i].draw(ctx, param, strokeMatrix);

      if (!param.clip) {
        this._setStyles(ctx, param, viewMatrix);

        var style = this._style;

        if (style.hasFill()) {
          ctx.fill(style.getFillRule());
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (style.hasStroke()) ctx.stroke();
      }
    },
    _drawSelected: function (ctx, matrix, selectionItems) {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i],
            mx = child._matrix;

        if (!selectionItems[child._id]) {
          child._drawSelected(ctx, mx.isIdentity() ? matrix : matrix.appended(mx));
        }
      }
    }
  }, new function () {
    function getCurrentPath(that, check) {
      var children = that._children;
      if (check && !children.length) throw new Error('Use a moveTo() command first');
      return children[children.length - 1];
    }

    return Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'], function (key) {
      this[key] = function () {
        var path = getCurrentPath(this, true);
        path[key].apply(path, arguments);
      };
    }, {
      moveTo: function () {
        var current = getCurrentPath(this),
            path = current && current.isEmpty() ? current : new Path(Item.NO_INSERT);
        if (path !== current) this.addChild(path);
        path.moveTo.apply(path, arguments);
      },
      moveBy: function () {
        var current = getCurrentPath(this, true),
            last = current && current.getLastSegment(),
            point = Point.read(arguments);
        this.moveTo(last ? point.add(last._point) : point);
      },
      closePath: function (tolerance) {
        getCurrentPath(this, true).closePath(tolerance);
      }
    });
  }(), Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function (key) {
    this[key] = function (param) {
      var children = this._children,
          res;

      for (var i = 0, l = children.length; i < l; i++) {
        res = children[i][key](param) || res;
      }

      return res;
    };
  }, {}));
  PathItem.inject(new function () {
    var min = Math.min,
        max = Math.max,
        abs = Math.abs,
        operators = {
      unite: {
        '1': true,
        '2': true
      },
      intersect: {
        '2': true
      },
      subtract: {
        '1': true
      },
      exclude: {
        '1': true,
        '-1': true
      }
    };

    function getPaths(path) {
      return path._children || [path];
    }

    function preparePath(path, resolve) {
      var res = path.clone(false).reduce({
        simplify: true
      }).transform(null, true, true);

      if (resolve) {
        var paths = getPaths(res);

        for (var i = 0, l = paths.length; i < l; i++) {
          var path = paths[i];

          if (!path._closed && !path.isEmpty()) {
            path.closePath(1e-12);
            path.getFirstSegment().setHandleIn(0, 0);
            path.getLastSegment().setHandleOut(0, 0);
          }
        }

        res = res.resolveCrossings().reorient(res.getFillRule() === 'nonzero', true);
      }

      return res;
    }

    function createResult(paths, simplify, path1, path2, options) {
      var result = new CompoundPath(Item.NO_INSERT);
      result.addChildren(paths, true);
      result = result.reduce({
        simplify: simplify
      });

      if (!(options && options.insert == false)) {
        result.insertAbove(path2 && path1.isSibling(path2) && path1.getIndex() < path2.getIndex() ? path2 : path1);
      }

      result.copyAttributes(path1, true);
      return result;
    }

    function filterIntersection(inter) {
      return inter.hasOverlap() || inter.isCrossing();
    }

    function traceBoolean(path1, path2, operation, options) {
      if (options && (options.trace == false || options.stroke) && /^(subtract|intersect)$/.test(operation)) return splitBoolean(path1, path2, operation);

      var _path1 = preparePath(path1, true),
          _path2 = path2 && path1 !== path2 && preparePath(path2, true),
          operator = operators[operation];

      operator[operation] = true;
      if (_path2 && (operator.subtract || operator.exclude) ^ (_path2.isClockwise() ^ _path1.isClockwise())) _path2.reverse();

      var crossings = divideLocations(CurveLocation.expand(_path1.getIntersections(_path2, filterIntersection))),
          paths1 = getPaths(_path1),
          paths2 = _path2 && getPaths(_path2),
          segments = [],
          curves = [],
          paths;

      function collectPaths(paths) {
        for (var i = 0, l = paths.length; i < l; i++) {
          var path = paths[i];
          Base.push(segments, path._segments);
          Base.push(curves, path.getCurves());
          path._overlapsOnly = true;
        }
      }

      function getCurves(indices) {
        var list = [];

        for (var i = 0, l = indices && indices.length; i < l; i++) {
          list.push(curves[indices[i]]);
        }

        return list;
      }

      if (crossings.length) {
        collectPaths(paths1);
        if (paths2) collectPaths(paths2);
        var curvesValues = new Array(curves.length);

        for (var i = 0, l = curves.length; i < l; i++) {
          curvesValues[i] = curves[i].getValues();
        }

        var curveCollisions = CollisionDetection.findCurveBoundsCollisions(curvesValues, curvesValues, 0, true);
        var curveCollisionsMap = {};

        for (var i = 0; i < curves.length; i++) {
          var curve = curves[i],
              id = curve._path._id,
              map = curveCollisionsMap[id] = curveCollisionsMap[id] || {};
          map[curve.getIndex()] = {
            hor: getCurves(curveCollisions[i].hor),
            ver: getCurves(curveCollisions[i].ver)
          };
        }

        for (var i = 0, l = crossings.length; i < l; i++) {
          propagateWinding(crossings[i]._segment, _path1, _path2, curveCollisionsMap, operator);
        }

        for (var i = 0, l = segments.length; i < l; i++) {
          var segment = segments[i],
              inter = segment._intersection;

          if (!segment._winding) {
            propagateWinding(segment, _path1, _path2, curveCollisionsMap, operator);
          }

          if (!(inter && inter._overlap)) segment._path._overlapsOnly = false;
        }

        paths = tracePaths(segments, operator);
      } else {
        paths = reorientPaths(paths2 ? paths1.concat(paths2) : paths1.slice(), function (w) {
          return !!operator[w];
        });
      }

      return createResult(paths, true, path1, path2, options);
    }

    function splitBoolean(path1, path2, operation) {
      var _path1 = preparePath(path1),
          _path2 = preparePath(path2),
          crossings = _path1.getIntersections(_path2, filterIntersection),
          subtract = operation === 'subtract',
          divide = operation === 'divide',
          added = {},
          paths = [];

      function addPath(path) {
        if (!added[path._id] && (divide || _path2.contains(path.getPointAt(path.getLength() / 2)) ^ subtract)) {
          paths.unshift(path);
          return added[path._id] = true;
        }
      }

      for (var i = crossings.length - 1; i >= 0; i--) {
        var path = crossings[i].split();

        if (path) {
          if (addPath(path)) path.getFirstSegment().setHandleIn(0, 0);

          _path1.getLastSegment().setHandleOut(0, 0);
        }
      }

      addPath(_path1);
      return createResult(paths, false, path1, path2);
    }

    function linkIntersections(from, to) {
      var prev = from;

      while (prev) {
        if (prev === to) return;
        prev = prev._previous;
      }

      while (from._next && from._next !== to) from = from._next;

      if (!from._next) {
        while (to._previous) to = to._previous;

        from._next = to;
        to._previous = from;
      }
    }

    function clearCurveHandles(curves) {
      for (var i = curves.length - 1; i >= 0; i--) curves[i].clearHandles();
    }

    function reorientPaths(paths, isInside, clockwise) {
      var length = paths && paths.length;

      if (length) {
        var lookup = Base.each(paths, function (path, i) {
          this[path._id] = {
            container: null,
            winding: path.isClockwise() ? 1 : -1,
            index: i
          };
        }, {}),
            sorted = paths.slice().sort(function (a, b) {
          return abs(b.getArea()) - abs(a.getArea());
        }),
            first = sorted[0];
        var collisions = CollisionDetection.findItemBoundsCollisions(sorted, null, Numerical.GEOMETRIC_EPSILON);
        if (clockwise == null) clockwise = first.isClockwise();

        for (var i = 0; i < length; i++) {
          var path1 = sorted[i],
              entry1 = lookup[path1._id],
              containerWinding = 0,
              indices = collisions[i];

          if (indices) {
            var point = null;

            for (var j = indices.length - 1; j >= 0; j--) {
              if (indices[j] < i) {
                point = point || path1.getInteriorPoint();
                var path2 = sorted[indices[j]];

                if (path2.contains(point)) {
                  var entry2 = lookup[path2._id];
                  containerWinding = entry2.winding;
                  entry1.winding += containerWinding;
                  entry1.container = entry2.exclude ? entry2.container : path2;
                  break;
                }
              }
            }
          }

          if (isInside(entry1.winding) === isInside(containerWinding)) {
            entry1.exclude = true;
            paths[entry1.index] = null;
          } else {
            var container = entry1.container;
            path1.setClockwise(container ? !container.isClockwise() : clockwise);
          }
        }
      }

      return paths;
    }

    function divideLocations(locations, include, clearLater) {
      var results = include && [],
          tMin = 1e-8,
          tMax = 1 - tMin,
          clearHandles = false,
          clearCurves = clearLater || [],
          clearLookup = clearLater && {},
          renormalizeLocs,
          prevCurve,
          prevTime;

      function getId(curve) {
        return curve._path._id + '.' + curve._segment1._index;
      }

      for (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {
        var curve = clearLater[i];
        if (curve._path) clearLookup[getId(curve)] = true;
      }

      for (var i = locations.length - 1; i >= 0; i--) {
        var loc = locations[i],
            time = loc._time,
            origTime = time,
            exclude = include && !include(loc),
            curve = loc._curve,
            segment;

        if (curve) {
          if (curve !== prevCurve) {
            clearHandles = !curve.hasHandles() || clearLookup && clearLookup[getId(curve)];
            renormalizeLocs = [];
            prevTime = null;
            prevCurve = curve;
          } else if (prevTime >= tMin) {
            time /= prevTime;
          }
        }

        if (exclude) {
          if (renormalizeLocs) renormalizeLocs.push(loc);
          continue;
        } else if (include) {
          results.unshift(loc);
        }

        prevTime = origTime;

        if (time < tMin) {
          segment = curve._segment1;
        } else if (time > tMax) {
          segment = curve._segment2;
        } else {
          var newCurve = curve.divideAtTime(time, true);
          if (clearHandles) clearCurves.push(curve, newCurve);
          segment = newCurve._segment1;

          for (var j = renormalizeLocs.length - 1; j >= 0; j--) {
            var l = renormalizeLocs[j];
            l._time = (l._time - time) / (1 - time);
          }
        }

        loc._setSegment(segment);

        var inter = segment._intersection,
            dest = loc._intersection;

        if (inter) {
          linkIntersections(inter, dest);
          var other = inter;

          while (other) {
            linkIntersections(other._intersection, inter);
            other = other._next;
          }
        } else {
          segment._intersection = dest;
        }
      }

      if (!clearLater) clearCurveHandles(clearCurves);
      return results || locations;
    }

    function getWinding(point, curves, dir, closed, dontFlip) {
      var curvesList = Array.isArray(curves) ? curves : curves[dir ? 'hor' : 'ver'];
      var ia = dir ? 1 : 0,
          io = ia ^ 1,
          pv = [point.x, point.y],
          pa = pv[ia],
          po = pv[io],
          windingEpsilon = 1e-9,
          qualityEpsilon = 1e-6,
          paL = pa - windingEpsilon,
          paR = pa + windingEpsilon,
          windingL = 0,
          windingR = 0,
          pathWindingL = 0,
          pathWindingR = 0,
          onPath = false,
          onAnyPath = false,
          quality = 1,
          roots = [],
          vPrev,
          vClose;

      function addWinding(v) {
        var o0 = v[io + 0],
            o3 = v[io + 6];

        if (po < min(o0, o3) || po > max(o0, o3)) {
          return;
        }

        var a0 = v[ia + 0],
            a1 = v[ia + 2],
            a2 = v[ia + 4],
            a3 = v[ia + 6];

        if (o0 === o3) {
          if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
            onPath = true;
          }

          return;
        }

        var t = po === o0 ? 0 : po === o3 ? 1 : paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? 1 : Curve.solveCubic(v, io, po, roots, 0, 1) > 0 ? roots[0] : 1,
            a = t === 0 ? a0 : t === 1 ? a3 : Curve.getPoint(v, t)[dir ? 'y' : 'x'],
            winding = o0 > o3 ? 1 : -1,
            windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,
            a3Prev = vPrev[ia + 6];

        if (po !== o0) {
          if (a < paL) {
            pathWindingL += winding;
          } else if (a > paR) {
            pathWindingR += winding;
          } else {
            onPath = true;
          }

          if (a > pa - qualityEpsilon && a < pa + qualityEpsilon) quality /= 2;
        } else {
          if (winding !== windingPrev) {
            if (a0 < paL) {
              pathWindingL += winding;
            } else if (a0 > paR) {
              pathWindingR += winding;
            }
          } else if (a0 != a3Prev) {
            if (a3Prev < paR && a > paR) {
              pathWindingR += winding;
              onPath = true;
            } else if (a3Prev > paL && a < paL) {
              pathWindingL += winding;
              onPath = true;
            }
          }

          quality /= 4;
        }

        vPrev = v;
        return !dontFlip && a > paL && a < paR && Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0 && getWinding(point, curves, !dir, closed, true);
      }

      function handleCurve(v) {
        var o0 = v[io + 0],
            o1 = v[io + 2],
            o2 = v[io + 4],
            o3 = v[io + 6];

        if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {
          var a0 = v[ia + 0],
              a1 = v[ia + 2],
              a2 = v[ia + 4],
              a3 = v[ia + 6],
              monoCurves = paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? [v] : Curve.getMonoCurves(v, dir),
              res;

          for (var i = 0, l = monoCurves.length; i < l; i++) {
            if (res = addWinding(monoCurves[i])) return res;
          }
        }
      }

      for (var i = 0, l = curvesList.length; i < l; i++) {
        var curve = curvesList[i],
            path = curve._path,
            v = curve.getValues(),
            res;

        if (!i || curvesList[i - 1]._path !== path) {
          vPrev = null;

          if (!path._closed) {
            vClose = Curve.getValues(path.getLastCurve().getSegment2(), curve.getSegment1(), null, !closed);

            if (vClose[io] !== vClose[io + 6]) {
              vPrev = vClose;
            }
          }

          if (!vPrev) {
            vPrev = v;
            var prev = path.getLastCurve();

            while (prev && prev !== curve) {
              var v2 = prev.getValues();

              if (v2[io] !== v2[io + 6]) {
                vPrev = v2;
                break;
              }

              prev = prev.getPrevious();
            }
          }
        }

        if (res = handleCurve(v)) return res;

        if (i + 1 === l || curvesList[i + 1]._path !== path) {
          if (vClose && (res = handleCurve(vClose))) return res;

          if (onPath && !pathWindingL && !pathWindingR) {
            pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir ? 1 : -1;
          }

          windingL += pathWindingL;
          windingR += pathWindingR;
          pathWindingL = pathWindingR = 0;

          if (onPath) {
            onAnyPath = true;
            onPath = false;
          }

          vClose = null;
        }
      }

      windingL = abs(windingL);
      windingR = abs(windingR);
      return {
        winding: max(windingL, windingR),
        windingL: windingL,
        windingR: windingR,
        quality: quality,
        onPath: onAnyPath
      };
    }

    function propagateWinding(segment, path1, path2, curveCollisionsMap, operator) {
      var chain = [],
          start = segment,
          totalLength = 0,
          winding;

      do {
        var curve = segment.getCurve();

        if (curve) {
          var length = curve.getLength();
          chain.push({
            segment: segment,
            curve: curve,
            length: length
          });
          totalLength += length;
        }

        segment = segment.getNext();
      } while (segment && !segment._intersection && segment !== start);

      var offsets = [0.5, 0.25, 0.75],
          winding = {
        winding: 0,
        quality: -1
      },
          tMin = 1e-3,
          tMax = 1 - tMin;

      for (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {
        var length = totalLength * offsets[i];

        for (var j = 0, l = chain.length; j < l; j++) {
          var entry = chain[j],
              curveLength = entry.length;

          if (length <= curveLength) {
            var curve = entry.curve,
                path = curve._path,
                parent = path._parent,
                operand = parent instanceof CompoundPath ? parent : path,
                t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),
                pt = curve.getPointAtTime(t),
                dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;
            var wind = null;

            if (operator.subtract && path2) {
              var otherPath = operand === path1 ? path2 : path1,
                  pathWinding = otherPath._getWinding(pt, dir, true);

              if (operand === path1 && pathWinding.winding || operand === path2 && !pathWinding.winding) {
                if (pathWinding.quality < 1) {
                  continue;
                } else {
                  wind = {
                    winding: 0,
                    quality: 1
                  };
                }
              }
            }

            wind = wind || getWinding(pt, curveCollisionsMap[path._id][curve.getIndex()], dir, true);
            if (wind.quality > winding.quality) winding = wind;
            break;
          }

          length -= curveLength;
        }
      }

      for (var j = chain.length - 1; j >= 0; j--) {
        chain[j].segment._winding = winding;
      }
    }

    function tracePaths(segments, operator) {
      var paths = [],
          starts;

      function isValid(seg) {
        var winding;
        return !!(seg && !seg._visited && (!operator || operator[(winding = seg._winding || {}).winding] && !(operator.unite && winding.winding === 2 && winding.windingL && winding.windingR)));
      }

      function isStart(seg) {
        if (seg) {
          for (var i = 0, l = starts.length; i < l; i++) {
            if (seg === starts[i]) return true;
          }
        }

        return false;
      }

      function visitPath(path) {
        var segments = path._segments;

        for (var i = 0, l = segments.length; i < l; i++) {
          segments[i]._visited = true;
        }
      }

      function getCrossingSegments(segment, collectStarts) {
        var inter = segment._intersection,
            start = inter,
            crossings = [];
        if (collectStarts) starts = [segment];

        function collect(inter, end) {
          while (inter && inter !== end) {
            var other = inter._segment,
                path = other && other._path;

            if (path) {
              var next = other.getNext() || path.getFirstSegment(),
                  nextInter = next._intersection;

              if (other !== segment && (isStart(other) || isStart(next) || next && isValid(other) && (isValid(next) || nextInter && isValid(nextInter._segment)))) {
                crossings.push(other);
              }

              if (collectStarts) starts.push(other);
            }

            inter = inter._next;
          }
        }

        if (inter) {
          collect(inter);

          while (inter && inter._previous) inter = inter._previous;

          collect(inter, start);
        }

        return crossings;
      }

      segments.sort(function (seg1, seg2) {
        var inter1 = seg1._intersection,
            inter2 = seg2._intersection,
            over1 = !!(inter1 && inter1._overlap),
            over2 = !!(inter2 && inter2._overlap),
            path1 = seg1._path,
            path2 = seg2._path;
        return over1 ^ over2 ? over1 ? 1 : -1 : !inter1 ^ !inter2 ? inter1 ? 1 : -1 : path1 !== path2 ? path1._id - path2._id : seg1._index - seg2._index;
      });

      for (var i = 0, l = segments.length; i < l; i++) {
        var seg = segments[i],
            valid = isValid(seg),
            path = null,
            finished = false,
            closed = true,
            branches = [],
            branch,
            visited,
            handleIn;

        if (valid && seg._path._overlapsOnly) {
          var path1 = seg._path,
              path2 = seg._intersection._segment._path;

          if (path1.compare(path2)) {
            if (path1.getArea()) paths.push(path1.clone(false));
            visitPath(path1);
            visitPath(path2);
            valid = false;
          }
        }

        while (valid) {
          var first = !path,
              crossings = getCrossingSegments(seg, first),
              other = crossings.shift(),
              finished = !first && (isStart(seg) || isStart(other)),
              cross = !finished && other;

          if (first) {
            path = new Path(Item.NO_INSERT);
            branch = null;
          }

          if (finished) {
            if (seg.isFirst() || seg.isLast()) closed = seg._path._closed;
            seg._visited = true;
            break;
          }

          if (cross && branch) {
            branches.push(branch);
            branch = null;
          }

          if (!branch) {
            if (cross) crossings.push(seg);
            branch = {
              start: path._segments.length,
              crossings: crossings,
              visited: visited = [],
              handleIn: handleIn
            };
          }

          if (cross) seg = other;

          if (!isValid(seg)) {
            path.removeSegments(branch.start);

            for (var j = 0, k = visited.length; j < k; j++) {
              visited[j]._visited = false;
            }

            visited.length = 0;

            do {
              seg = branch && branch.crossings.shift();

              if (!seg || !seg._path) {
                seg = null;
                branch = branches.pop();

                if (branch) {
                  visited = branch.visited;
                  handleIn = branch.handleIn;
                }
              }
            } while (branch && !isValid(seg));

            if (!seg) break;
          }

          var next = seg.getNext();
          path.add(new Segment(seg._point, handleIn, next && seg._handleOut));
          seg._visited = true;
          visited.push(seg);
          seg = next || seg._path.getFirstSegment();
          handleIn = next && next._handleIn;
        }

        if (finished) {
          if (closed) {
            path.getFirstSegment().setHandleIn(handleIn);
            path.setClosed(closed);
          }

          if (path.getArea() !== 0) {
            paths.push(path);
          }
        }
      }

      return paths;
    }

    return {
      _getWinding: function (point, dir, closed) {
        return getWinding(point, this.getCurves(), dir, closed);
      },
      unite: function (path, options) {
        return traceBoolean(this, path, 'unite', options);
      },
      intersect: function (path, options) {
        return traceBoolean(this, path, 'intersect', options);
      },
      subtract: function (path, options) {
        return traceBoolean(this, path, 'subtract', options);
      },
      exclude: function (path, options) {
        return traceBoolean(this, path, 'exclude', options);
      },
      divide: function (path, options) {
        return options && (options.trace == false || options.stroke) ? splitBoolean(this, path, 'divide') : createResult([this.subtract(path, options), this.intersect(path, options)], true, this, path, options);
      },
      resolveCrossings: function () {
        var children = this._children,
            paths = children || [this];

        function hasOverlap(seg, path) {
          var inter = seg && seg._intersection;
          return inter && inter._overlap && inter._path === path;
        }

        var hasOverlaps = false,
            hasCrossings = false,
            intersections = this.getIntersections(null, function (inter) {
          return inter.hasOverlap() && (hasOverlaps = true) || inter.isCrossing() && (hasCrossings = true);
        }),
            clearCurves = hasOverlaps && hasCrossings && [];
        intersections = CurveLocation.expand(intersections);

        if (hasOverlaps) {
          var overlaps = divideLocations(intersections, function (inter) {
            return inter.hasOverlap();
          }, clearCurves);

          for (var i = overlaps.length - 1; i >= 0; i--) {
            var overlap = overlaps[i],
                path = overlap._path,
                seg = overlap._segment,
                prev = seg.getPrevious(),
                next = seg.getNext();

            if (hasOverlap(prev, path) && hasOverlap(next, path)) {
              seg.remove();

              prev._handleOut._set(0, 0);

              next._handleIn._set(0, 0);

              if (prev !== seg && !prev.getCurve().hasLength()) {
                next._handleIn.set(prev._handleIn);

                prev.remove();
              }
            }
          }
        }

        if (hasCrossings) {
          divideLocations(intersections, hasOverlaps && function (inter) {
            var curve1 = inter.getCurve(),
                seg1 = inter.getSegment(),
                other = inter._intersection,
                curve2 = other._curve,
                seg2 = other._segment;
            if (curve1 && curve2 && curve1._path && curve2._path) return true;
            if (seg1) seg1._intersection = null;
            if (seg2) seg2._intersection = null;
          }, clearCurves);
          if (clearCurves) clearCurveHandles(clearCurves);
          paths = tracePaths(Base.each(paths, function (path) {
            Base.push(this, path._segments);
          }, []));
        }

        var length = paths.length,
            item;

        if (length > 1 && children) {
          if (paths !== children) this.setChildren(paths);
          item = this;
        } else if (length === 1 && !children) {
          if (paths[0] !== this) this.setSegments(paths[0].removeSegments());
          item = this;
        }

        if (!item) {
          item = new CompoundPath(Item.NO_INSERT);
          item.addChildren(paths);
          item = item.reduce();
          item.copyAttributes(this);
          this.replaceWith(item);
        }

        return item;
      },
      reorient: function (nonZero, clockwise) {
        var children = this._children;

        if (children && children.length) {
          this.setChildren(reorientPaths(this.removeChildren(), function (w) {
            return !!(nonZero ? w : w & 1);
          }, clockwise));
        } else if (clockwise !== undefined) {
          this.setClockwise(clockwise);
        }

        return this;
      },
      getInteriorPoint: function () {
        var bounds = this.getBounds(),
            point = bounds.getCenter(true);

        if (!this.contains(point)) {
          var curves = this.getCurves(),
              y = point.y,
              intercepts = [],
              roots = [];

          for (var i = 0, l = curves.length; i < l; i++) {
            var v = curves[i].getValues(),
                o0 = v[1],
                o1 = v[3],
                o2 = v[5],
                o3 = v[7];

            if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {
              var monoCurves = Curve.getMonoCurves(v);

              for (var j = 0, m = monoCurves.length; j < m; j++) {
                var mv = monoCurves[j],
                    mo0 = mv[1],
                    mo3 = mv[7];

                if (mo0 !== mo3 && (y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)) {
                  var x = y === mo0 ? mv[0] : y === mo3 ? mv[6] : Curve.solveCubic(mv, 1, y, roots, 0, 1) === 1 ? Curve.getPoint(mv, roots[0]).x : (mv[0] + mv[6]) / 2;
                  intercepts.push(x);
                }
              }
            }
          }

          if (intercepts.length > 1) {
            intercepts.sort(function (a, b) {
              return a - b;
            });
            point.x = (intercepts[0] + intercepts[1]) / 2;
          }
        }

        return point;
      }
    };
  }());
  var PathFlattener = Base.extend({
    _class: 'PathFlattener',
    initialize: function (path, flatness, maxRecursion, ignoreStraight, matrix) {
      var curves = [],
          parts = [],
          length = 0,
          minSpan = 1 / (maxRecursion || 32),
          segments = path._segments,
          segment1 = segments[0],
          segment2;

      function addCurve(segment1, segment2) {
        var curve = Curve.getValues(segment1, segment2, matrix);
        curves.push(curve);
        computeParts(curve, segment1._index, 0, 1);
      }

      function computeParts(curve, index, t1, t2) {
        if (t2 - t1 > minSpan && !(ignoreStraight && Curve.isStraight(curve)) && !Curve.isFlatEnough(curve, flatness || 0.25)) {
          var halves = Curve.subdivide(curve, 0.5),
              tMid = (t1 + t2) / 2;
          computeParts(halves[0], index, t1, tMid);
          computeParts(halves[1], index, tMid, t2);
        } else {
          var dx = curve[6] - curve[0],
              dy = curve[7] - curve[1],
              dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            length += dist;
            parts.push({
              offset: length,
              curve: curve,
              index: index,
              time: t2
            });
          }
        }
      }

      for (var i = 1, l = segments.length; i < l; i++) {
        segment2 = segments[i];
        addCurve(segment1, segment2);
        segment1 = segment2;
      }

      if (path._closed) addCurve(segment2 || segment1, segments[0]);
      this.curves = curves;
      this.parts = parts;
      this.length = length;
      this.index = 0;
    },
    _get: function (offset) {
      var parts = this.parts,
          length = parts.length,
          start,
          i,
          j = this.index;

      for (;;) {
        i = j;
        if (!j || parts[--j].offset < offset) break;
      }

      for (; i < length; i++) {
        var part = parts[i];

        if (part.offset >= offset) {
          this.index = i;
          var prev = parts[i - 1],
              prevTime = prev && prev.index === part.index ? prev.time : 0,
              prevOffset = prev ? prev.offset : 0;
          return {
            index: part.index,
            time: prevTime + (part.time - prevTime) * (offset - prevOffset) / (part.offset - prevOffset)
          };
        }
      }

      return {
        index: parts[length - 1].index,
        time: 1
      };
    },
    drawPart: function (ctx, from, to) {
      var start = this._get(from),
          end = this._get(to);

      for (var i = start.index, l = end.index; i <= l; i++) {
        var curve = Curve.getPart(this.curves[i], i === start.index ? start.time : 0, i === end.index ? end.time : 1);
        if (i === start.index) ctx.moveTo(curve[0], curve[1]);
        ctx.bezierCurveTo.apply(ctx, curve.slice(2));
      }
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    this[name + 'At'] = function (offset) {
      var param = this._get(offset);

      return Curve[name](this.curves[param.index], param.time);
    };
  }, {}));
  var PathFitter = Base.extend({
    initialize: function (path) {
      var points = this.points = [],
          segments = path._segments,
          closed = path._closed;

      for (var i = 0, prev, l = segments.length; i < l; i++) {
        var point = segments[i].point;

        if (!prev || !prev.equals(point)) {
          points.push(prev = point.clone());
        }
      }

      if (closed) {
        points.unshift(points[points.length - 1]);
        points.push(points[1]);
      }

      this.closed = closed;
    },
    fit: function (error) {
      var points = this.points,
          length = points.length,
          segments = null;

      if (length > 0) {
        segments = [new Segment(points[0])];

        if (length > 1) {
          this.fitCubic(segments, error, 0, length - 1, points[1].subtract(points[0]), points[length - 2].subtract(points[length - 1]));

          if (this.closed) {
            segments.shift();
            segments.pop();
          }
        }
      }

      return segments;
    },
    fitCubic: function (segments, error, first, last, tan1, tan2) {
      var points = this.points;

      if (last - first === 1) {
        var pt1 = points[first],
            pt2 = points[last],
            dist = pt1.getDistance(pt2) / 3;
        this.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)), pt2.add(tan2.normalize(dist)), pt2]);
        return;
      }

      var uPrime = this.chordLengthParameterize(first, last),
          maxError = Math.max(error, error * error),
          split,
          parametersInOrder = true;

      for (var i = 0; i <= 4; i++) {
        var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
        var max = this.findMaxError(first, last, curve, uPrime);

        if (max.error < error && parametersInOrder) {
          this.addCurve(segments, curve);
          return;
        }

        split = max.index;
        if (max.error >= maxError) break;
        parametersInOrder = this.reparameterize(first, last, uPrime, curve);
        maxError = max.error;
      }

      var tanCenter = points[split - 1].subtract(points[split + 1]);
      this.fitCubic(segments, error, first, split, tan1, tanCenter);
      this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
    },
    addCurve: function (segments, curve) {
      var prev = segments[segments.length - 1];
      prev.setHandleOut(curve[1].subtract(curve[0]));
      segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
    },
    generateBezier: function (first, last, uPrime, tan1, tan2) {
      var epsilon = 1e-12,
          abs = Math.abs,
          points = this.points,
          pt1 = points[first],
          pt2 = points[last],
          C = [[0, 0], [0, 0]],
          X = [0, 0];

      for (var i = 0, l = last - first + 1; i < l; i++) {
        var u = uPrime[i],
            t = 1 - u,
            b = 3 * u * t,
            b0 = t * t * t,
            b1 = b * t,
            b2 = b * u,
            b3 = u * u * u,
            a1 = tan1.normalize(b1),
            a2 = tan2.normalize(b2),
            tmp = points[first + i].subtract(pt1.multiply(b0 + b1)).subtract(pt2.multiply(b2 + b3));
        C[0][0] += a1.dot(a1);
        C[0][1] += a1.dot(a2);
        C[1][0] = C[0][1];
        C[1][1] += a2.dot(a2);
        X[0] += a1.dot(tmp);
        X[1] += a2.dot(tmp);
      }

      var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
          alpha1,
          alpha2;

      if (abs(detC0C1) > epsilon) {
        var detC0X = C[0][0] * X[1] - C[1][0] * X[0],
            detXC1 = X[0] * C[1][1] - X[1] * C[0][1];
        alpha1 = detXC1 / detC0C1;
        alpha2 = detC0X / detC0C1;
      } else {
        var c0 = C[0][0] + C[0][1],
            c1 = C[1][0] + C[1][1];
        alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0 : abs(c1) > epsilon ? X[1] / c1 : 0;
      }

      var segLength = pt2.getDistance(pt1),
          eps = epsilon * segLength,
          handle1,
          handle2;

      if (alpha1 < eps || alpha2 < eps) {
        alpha1 = alpha2 = segLength / 3;
      } else {
        var line = pt2.subtract(pt1);
        handle1 = tan1.normalize(alpha1);
        handle2 = tan2.normalize(alpha2);

        if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
          alpha1 = alpha2 = segLength / 3;
          handle1 = handle2 = null;
        }
      }

      return [pt1, pt1.add(handle1 || tan1.normalize(alpha1)), pt2.add(handle2 || tan2.normalize(alpha2)), pt2];
    },
    reparameterize: function (first, last, u, curve) {
      for (var i = first; i <= last; i++) {
        u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
      }

      for (var i = 1, l = u.length; i < l; i++) {
        if (u[i] <= u[i - 1]) return false;
      }

      return true;
    },
    findRoot: function (curve, point, u) {
      var curve1 = [],
          curve2 = [];

      for (var i = 0; i <= 2; i++) {
        curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
      }

      for (var i = 0; i <= 1; i++) {
        curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
      }

      var pt = this.evaluate(3, curve, u),
          pt1 = this.evaluate(2, curve1, u),
          pt2 = this.evaluate(1, curve2, u),
          diff = pt.subtract(point),
          df = pt1.dot(pt1) + diff.dot(pt2);
      return Numerical.isMachineZero(df) ? u : u - diff.dot(pt1) / df;
    },
    evaluate: function (degree, curve, t) {
      var tmp = curve.slice();

      for (var i = 1; i <= degree; i++) {
        for (var j = 0; j <= degree - i; j++) {
          tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
        }
      }

      return tmp[0];
    },
    chordLengthParameterize: function (first, last) {
      var u = [0];

      for (var i = first + 1; i <= last; i++) {
        u[i - first] = u[i - first - 1] + this.points[i].getDistance(this.points[i - 1]);
      }

      for (var i = 1, m = last - first; i <= m; i++) {
        u[i] /= u[m];
      }

      return u;
    },
    findMaxError: function (first, last, curve, u) {
      var index = Math.floor((last - first + 1) / 2),
          maxDist = 0;

      for (var i = first + 1; i < last; i++) {
        var P = this.evaluate(3, curve, u[i - first]);
        var v = P.subtract(this.points[i]);
        var dist = v.x * v.x + v.y * v.y;

        if (dist >= maxDist) {
          maxDist = dist;
          index = i;
        }
      }

      return {
        error: maxDist,
        index: index
      };
    }
  });
  var TextItem = Item.extend({
    _class: 'TextItem',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _serializeFields: {
      content: null
    },
    _boundsOptions: {
      stroke: false,
      handle: false
    },
    initialize: function TextItem(arg) {
      this._content = '';
      this._lines = [];
      var hasProps = arg && Base.isPlainObject(arg) && arg.x === undefined && arg.y === undefined;

      this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
    },
    _equals: function (item) {
      return this._content === item._content;
    },
    copyContent: function (source) {
      this.setContent(source._content);
    },
    getContent: function () {
      return this._content;
    },
    setContent: function (content) {
      this._content = '' + content;
      this._lines = this._content.split(/\r\n|\n|\r/mg);

      this._changed(521);
    },
    isEmpty: function () {
      return !this._content;
    },
    getCharacterStyle: '#getStyle',
    setCharacterStyle: '#setStyle',
    getParagraphStyle: '#getStyle',
    setParagraphStyle: '#setStyle'
  });
  var PointText = TextItem.extend({
    _class: 'PointText',
    initialize: function PointText() {
      TextItem.apply(this, arguments);
    },
    getPoint: function () {
      var point = this._matrix.getTranslation();

      return new LinkedPoint(point.x, point.y, this, 'setPoint');
    },
    setPoint: function () {
      var point = Point.read(arguments);
      this.translate(point.subtract(this._matrix.getTranslation()));
    },
    _draw: function (ctx, param, viewMatrix) {
      if (!this._content) return;

      this._setStyles(ctx, param, viewMatrix);

      var lines = this._lines,
          style = this._style,
          hasFill = style.hasFill(),
          hasStroke = style.hasStroke(),
          leading = style.getLeading(),
          shadowColor = ctx.shadowColor;
      ctx.font = style.getFontStyle();
      ctx.textAlign = style.getJustification();

      for (var i = 0, l = lines.length; i < l; i++) {
        ctx.shadowColor = shadowColor;
        var line = lines[i];

        if (hasFill) {
          ctx.fillText(line, 0, 0);
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (hasStroke) ctx.strokeText(line, 0, 0);
        ctx.translate(0, leading);
      }
    },
    _getBounds: function (matrix, options) {
      var style = this._style,
          lines = this._lines,
          numLines = lines.length,
          justification = style.getJustification(),
          leading = style.getLeading(),
          width = this.getView().getTextWidth(style.getFontStyle(), lines),
          x = 0;
      if (justification !== 'left') x -= width / (justification === 'center' ? 2 : 1);
      var rect = new Rectangle(x, numLines ? -0.75 * leading : 0, width, numLines * leading);
      return matrix ? matrix._transformBounds(rect, rect) : rect;
    }
  });
  var Color = Base.extend(new function () {
    var types = {
      gray: ['gray'],
      rgb: ['red', 'green', 'blue'],
      hsb: ['hue', 'saturation', 'brightness'],
      hsl: ['hue', 'saturation', 'lightness'],
      gradient: ['gradient', 'origin', 'destination', 'highlight']
    };
    var componentParsers = {},
        namedColors = {
      transparent: [0, 0, 0, 0]
    },
        colorCtx;

    function fromCSS(string) {
      var match = string.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i) || string.match(/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i),
          type = 'rgb',
          components;

      if (match) {
        var amount = match[4] ? 4 : 3;
        components = new Array(amount);

        for (var i = 0; i < amount; i++) {
          var value = match[i + 1];
          components[i] = parseInt(value.length == 1 ? value + value : value, 16) / 255;
        }
      } else if (match = string.match(/^(rgb|hsl)a?\((.*)\)$/)) {
        type = match[1];
        components = match[2].trim().split(/[,\s]+/g);
        var isHSL = type === 'hsl';

        for (var i = 0, l = Math.min(components.length, 4); i < l; i++) {
          var component = components[i];
          var value = parseFloat(component);

          if (isHSL) {
            if (i === 0) {
              var unit = component.match(/([a-z]*)$/)[1];
              value *= {
                turn: 360,
                rad: 180 / Math.PI,
                grad: 0.9
              }[unit] || 1;
            } else if (i < 3) {
              value /= 100;
            }
          } else if (i < 3) {
            value /= /%$/.test(component) ? 100 : 255;
          }

          components[i] = value;
        }
      } else {
        var color = namedColors[string];

        if (!color) {
          if (window) {
            if (!colorCtx) {
              colorCtx = CanvasProvider.getContext(1, 1);
              colorCtx.globalCompositeOperation = 'copy';
            }

            colorCtx.fillStyle = 'rgba(0,0,0,0)';
            colorCtx.fillStyle = string;
            colorCtx.fillRect(0, 0, 1, 1);
            var data = colorCtx.getImageData(0, 0, 1, 1).data;
            color = namedColors[string] = [data[0] / 255, data[1] / 255, data[2] / 255];
          } else {
            color = [0, 0, 0];
          }
        }

        components = color.slice();
      }

      return [type, components];
    }

    var hsbIndices = [[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]];
    var converters = {
      'rgb-hsb': function (r, g, b) {
        var max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            delta = max - min,
            h = delta === 0 ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60;
        return [h, max === 0 ? 0 : delta / max, max];
      },
      'hsb-rgb': function (h, s, b) {
        h = (h / 60 % 6 + 6) % 6;
        var i = Math.floor(h),
            f = h - i,
            i = hsbIndices[i],
            v = [b, b * (1 - s), b * (1 - s * f), b * (1 - s * (1 - f))];
        return [v[i[0]], v[i[1]], v[i[2]]];
      },
      'rgb-hsl': function (r, g, b) {
        var max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            delta = max - min,
            achromatic = delta === 0,
            h = achromatic ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60,
            l = (max + min) / 2,
            s = achromatic ? 0 : l < 0.5 ? delta / (max + min) : delta / (2 - max - min);
        return [h, s, l];
      },
      'hsl-rgb': function (h, s, l) {
        h = (h / 360 % 1 + 1) % 1;
        if (s === 0) return [l, l, l];
        var t3s = [h + 1 / 3, h, h - 1 / 3],
            t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
            t1 = 2 * l - t2,
            c = [];

        for (var i = 0; i < 3; i++) {
          var t3 = t3s[i];
          if (t3 < 0) t3 += 1;
          if (t3 > 1) t3 -= 1;
          c[i] = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
        }

        return c;
      },
      'rgb-gray': function (r, g, b) {
        return [r * 0.2989 + g * 0.587 + b * 0.114];
      },
      'gray-rgb': function (g) {
        return [g, g, g];
      },
      'gray-hsb': function (g) {
        return [0, 0, g];
      },
      'gray-hsl': function (g) {
        return [0, 0, g];
      },
      'gradient-rgb': function () {
        return [];
      },
      'rgb-gradient': function () {
        return [];
      }
    };
    return Base.each(types, function (properties, type) {
      componentParsers[type] = [];
      Base.each(properties, function (name, index) {
        var part = Base.capitalize(name),
            hasOverlap = /^(hue|saturation)$/.test(name),
            parser = componentParsers[type][index] = type === 'gradient' ? name === 'gradient' ? function (value) {
          var current = this._components[0];
          value = Gradient.read(Array.isArray(value) ? value : arguments, 0, {
            readNull: true
          });

          if (current !== value) {
            if (current) current._removeOwner(this);
            if (value) value._addOwner(this);
          }

          return value;
        } : function () {
          return Point.read(arguments, 0, {
            readNull: name === 'highlight',
            clone: true
          });
        } : function (value) {
          return value == null || isNaN(value) ? 0 : +value;
        };

        this['get' + part] = function () {
          return this._type === type || hasOverlap && /^hs[bl]$/.test(this._type) ? this._components[index] : this._convert(type)[index];
        };

        this['set' + part] = function (value) {
          if (this._type !== type && !(hasOverlap && /^hs[bl]$/.test(this._type))) {
            this._components = this._convert(type);
            this._properties = types[type];
            this._type = type;
          }

          this._components[index] = parser.call(this, value);

          this._changed();
        };
      }, this);
    }, {
      _class: 'Color',
      _readIndex: true,
      initialize: function Color(arg) {
        var args = arguments,
            reading = this.__read,
            read = 0,
            type,
            components,
            alpha,
            values;

        if (Array.isArray(arg)) {
          args = arg;
          arg = args[0];
        }

        var argType = arg != null && typeof arg;

        if (argType === 'string' && arg in types) {
          type = arg;
          arg = args[1];

          if (Array.isArray(arg)) {
            components = arg;
            alpha = args[2];
          } else {
            if (reading) read = 1;
            args = Base.slice(args, 1);
            argType = typeof arg;
          }
        }

        if (!components) {
          values = argType === 'number' ? args : argType === 'object' && arg.length != null ? arg : null;

          if (values) {
            if (!type) type = values.length >= 3 ? 'rgb' : 'gray';
            var length = types[type].length;
            alpha = values[length];

            if (reading) {
              read += values === arguments ? length + (alpha != null ? 1 : 0) : 1;
            }

            if (values.length > length) values = Base.slice(values, 0, length);
          } else if (argType === 'string') {
            var converted = fromCSS(arg);
            type = converted[0];
            components = converted[1];

            if (components.length === 4) {
              alpha = components[3];
              components.length--;
            }
          } else if (argType === 'object') {
            if (arg.constructor === Color) {
              type = arg._type;
              components = arg._components.slice();
              alpha = arg._alpha;

              if (type === 'gradient') {
                for (var i = 1, l = components.length; i < l; i++) {
                  var point = components[i];
                  if (point) components[i] = point.clone();
                }
              }
            } else if (arg.constructor === Gradient) {
              type = 'gradient';
              values = args;
            } else {
              type = 'hue' in arg ? 'lightness' in arg ? 'hsl' : 'hsb' : 'gradient' in arg || 'stops' in arg || 'radial' in arg ? 'gradient' : 'gray' in arg ? 'gray' : 'rgb';
              var properties = types[type],
                  parsers = componentParsers[type];
              this._components = components = [];

              for (var i = 0, l = properties.length; i < l; i++) {
                var value = arg[properties[i]];

                if (value == null && !i && type === 'gradient' && 'stops' in arg) {
                  value = {
                    stops: arg.stops,
                    radial: arg.radial
                  };
                }

                value = parsers[i].call(this, value);
                if (value != null) components[i] = value;
              }

              alpha = arg.alpha;
            }
          }

          if (reading && type) read = 1;
        }

        this._type = type || 'rgb';

        if (!components) {
          this._components = components = [];
          var parsers = componentParsers[this._type];

          for (var i = 0, l = parsers.length; i < l; i++) {
            var value = parsers[i].call(this, values && values[i]);
            if (value != null) components[i] = value;
          }
        }

        this._components = components;
        this._properties = types[this._type];
        this._alpha = alpha;
        if (reading) this.__read = read;
        return this;
      },
      set: '#initialize',
      _serialize: function (options, dictionary) {
        var components = this.getComponents();
        return Base.serialize(/^(gray|rgb)$/.test(this._type) ? components : [this._type].concat(components), options, true, dictionary);
      },
      _changed: function () {
        this._canvasStyle = null;

        if (this._owner) {
          if (this._setter) {
            this._owner[this._setter](this);
          } else {
            this._owner._changed(129);
          }
        }
      },
      _convert: function (type) {
        var converter;
        return this._type === type ? this._components.slice() : (converter = converters[this._type + '-' + type]) ? converter.apply(this, this._components) : converters['rgb-' + type].apply(this, converters[this._type + '-rgb'].apply(this, this._components));
      },
      convert: function (type) {
        return new Color(type, this._convert(type), this._alpha);
      },
      getType: function () {
        return this._type;
      },
      setType: function (type) {
        this._components = this._convert(type);
        this._properties = types[type];
        this._type = type;
      },
      getComponents: function () {
        var components = this._components.slice();

        if (this._alpha != null) components.push(this._alpha);
        return components;
      },
      getAlpha: function () {
        return this._alpha != null ? this._alpha : 1;
      },
      setAlpha: function (alpha) {
        this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);

        this._changed();
      },
      hasAlpha: function () {
        return this._alpha != null;
      },
      equals: function (color) {
        var col = Base.isPlainValue(color, true) ? Color.read(arguments) : color;
        return col === this || col && this._class === col._class && this._type === col._type && this.getAlpha() === col.getAlpha() && Base.equals(this._components, col._components) || false;
      },
      toString: function () {
        var properties = this._properties,
            parts = [],
            isGradient = this._type === 'gradient',
            f = Formatter.instance;

        for (var i = 0, l = properties.length; i < l; i++) {
          var value = this._components[i];
          if (value != null) parts.push(properties[i] + ': ' + (isGradient ? value : f.number(value)));
        }

        if (this._alpha != null) parts.push('alpha: ' + f.number(this._alpha));
        return '{ ' + parts.join(', ') + ' }';
      },
      toCSS: function (hex) {
        var components = this._convert('rgb'),
            alpha = hex || this._alpha == null ? 1 : this._alpha;

        function convert(val) {
          return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
        }

        components = [convert(components[0]), convert(components[1]), convert(components[2])];
        if (alpha < 1) components.push(alpha < 0 ? 0 : alpha);
        return hex ? '#' + ((1 << 24) + (components[0] << 16) + (components[1] << 8) + components[2]).toString(16).slice(1) : (components.length == 4 ? 'rgba(' : 'rgb(') + components.join(',') + ')';
      },
      toCanvasStyle: function (ctx, matrix) {
        if (this._canvasStyle) return this._canvasStyle;
        if (this._type !== 'gradient') return this._canvasStyle = this.toCSS();
        var components = this._components,
            gradient = components[0],
            stops = gradient._stops,
            origin = components[1],
            destination = components[2],
            highlight = components[3],
            inverse = matrix && matrix.inverted(),
            canvasGradient;

        if (inverse) {
          origin = inverse._transformPoint(origin);
          destination = inverse._transformPoint(destination);
          if (highlight) highlight = inverse._transformPoint(highlight);
        }

        if (gradient._radial) {
          var radius = destination.getDistance(origin);

          if (highlight) {
            var vector = highlight.subtract(origin);
            if (vector.getLength() > radius) highlight = origin.add(vector.normalize(radius - 0.1));
          }

          var start = highlight || origin;
          canvasGradient = ctx.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius);
        } else {
          canvasGradient = ctx.createLinearGradient(origin.x, origin.y, destination.x, destination.y);
        }

        for (var i = 0, l = stops.length; i < l; i++) {
          var stop = stops[i],
              offset = stop._offset;
          canvasGradient.addColorStop(offset == null ? i / (l - 1) : offset, stop._color.toCanvasStyle());
        }

        return this._canvasStyle = canvasGradient;
      },
      transform: function (matrix) {
        if (this._type === 'gradient') {
          var components = this._components;

          for (var i = 1, l = components.length; i < l; i++) {
            var point = components[i];

            matrix._transformPoint(point, point, true);
          }

          this._changed();
        }
      },
      statics: {
        _types: types,
        random: function () {
          var random = Math.random;
          return new Color(random(), random(), random());
        },
        _setOwner: function (color, owner, setter) {
          if (color) {
            if (color._owner && owner && color._owner !== owner) {
              color = color.clone();
            }

            if (!color._owner ^ !owner) {
              color._owner = owner || null;
              color._setter = setter || null;
            }
          }

          return color;
        }
      }
    });
  }(), new function () {
    var operators = {
      add: function (a, b) {
        return a + b;
      },
      subtract: function (a, b) {
        return a - b;
      },
      multiply: function (a, b) {
        return a * b;
      },
      divide: function (a, b) {
        return a / b;
      }
    };
    return Base.each(operators, function (operator, name) {
      this[name] = function (color) {
        color = Color.read(arguments);

        var type = this._type,
            components1 = this._components,
            components2 = color._convert(type);

        for (var i = 0, l = components1.length; i < l; i++) components2[i] = operator(components1[i], components2[i]);

        return new Color(type, components2, this._alpha != null ? operator(this._alpha, color.getAlpha()) : null);
      };
    }, {});
  }());
  var Gradient = Base.extend({
    _class: 'Gradient',
    initialize: function Gradient(stops, radial) {
      this._id = UID.get();

      if (stops && Base.isPlainObject(stops)) {
        this.set(stops);
        stops = radial = null;
      }

      if (this._stops == null) {
        this.setStops(stops || ['white', 'black']);
      }

      if (this._radial == null) {
        this.setRadial(typeof radial === 'string' && radial === 'radial' || radial || false);
      }
    },
    _serialize: function (options, dictionary) {
      return dictionary.add(this, function () {
        return Base.serialize([this._stops, this._radial], options, true, dictionary);
      });
    },
    _changed: function () {
      for (var i = 0, l = this._owners && this._owners.length; i < l; i++) {
        this._owners[i]._changed();
      }
    },
    _addOwner: function (color) {
      if (!this._owners) this._owners = [];

      this._owners.push(color);
    },
    _removeOwner: function (color) {
      var index = this._owners ? this._owners.indexOf(color) : -1;

      if (index != -1) {
        this._owners.splice(index, 1);

        if (!this._owners.length) this._owners = undefined;
      }
    },
    clone: function () {
      var stops = [];

      for (var i = 0, l = this._stops.length; i < l; i++) {
        stops[i] = this._stops[i].clone();
      }

      return new Gradient(stops, this._radial);
    },
    getStops: function () {
      return this._stops;
    },
    setStops: function (stops) {
      if (stops.length < 2) {
        throw new Error('Gradient stop list needs to contain at least two stops.');
      }

      var _stops = this._stops;

      if (_stops) {
        for (var i = 0, l = _stops.length; i < l; i++) _stops[i]._owner = undefined;
      }

      _stops = this._stops = GradientStop.readList(stops, 0, {
        clone: true
      });

      for (var i = 0, l = _stops.length; i < l; i++) _stops[i]._owner = this;

      this._changed();
    },
    getRadial: function () {
      return this._radial;
    },
    setRadial: function (radial) {
      this._radial = radial;

      this._changed();
    },
    equals: function (gradient) {
      if (gradient === this) return true;

      if (gradient && this._class === gradient._class) {
        var stops1 = this._stops,
            stops2 = gradient._stops,
            length = stops1.length;

        if (length === stops2.length) {
          for (var i = 0; i < length; i++) {
            if (!stops1[i].equals(stops2[i])) return false;
          }

          return true;
        }
      }

      return false;
    }
  });
  var GradientStop = Base.extend({
    _class: 'GradientStop',
    initialize: function GradientStop(arg0, arg1) {
      var color = arg0,
          offset = arg1;

      if (typeof arg0 === 'object' && arg1 === undefined) {
        if (Array.isArray(arg0) && typeof arg0[0] !== 'number') {
          color = arg0[0];
          offset = arg0[1];
        } else if ('color' in arg0 || 'offset' in arg0 || 'rampPoint' in arg0) {
          color = arg0.color;
          offset = arg0.offset || arg0.rampPoint || 0;
        }
      }

      this.setColor(color);
      this.setOffset(offset);
    },
    clone: function () {
      return new GradientStop(this._color.clone(), this._offset);
    },
    _serialize: function (options, dictionary) {
      var color = this._color,
          offset = this._offset;
      return Base.serialize(offset == null ? [color] : [color, offset], options, true, dictionary);
    },
    _changed: function () {
      if (this._owner) this._owner._changed(129);
    },
    getOffset: function () {
      return this._offset;
    },
    setOffset: function (offset) {
      this._offset = offset;

      this._changed();
    },
    getRampPoint: '#getOffset',
    setRampPoint: '#setOffset',
    getColor: function () {
      return this._color;
    },
    setColor: function () {
      Color._setOwner(this._color, null);

      this._color = Color._setOwner(Color.read(arguments, 0), this, 'setColor');

      this._changed();
    },
    equals: function (stop) {
      return stop === this || stop && this._class === stop._class && this._color.equals(stop._color) && this._offset == stop._offset || false;
    }
  });
  var Style = Base.extend(new function () {
    var itemDefaults = {
      fillColor: null,
      fillRule: 'nonzero',
      strokeColor: null,
      strokeWidth: 1,
      strokeCap: 'butt',
      strokeJoin: 'miter',
      strokeScaling: true,
      miterLimit: 10,
      dashOffset: 0,
      dashArray: [],
      shadowColor: null,
      shadowBlur: 0,
      shadowOffset: new Point(),
      selectedColor: null
    },
        groupDefaults = Base.set({}, itemDefaults, {
      fontFamily: 'sans-serif',
      fontWeight: 'normal',
      fontSize: 12,
      leading: null,
      justification: 'left'
    }),
        textDefaults = Base.set({}, groupDefaults, {
      fillColor: new Color()
    }),
        flags = {
      strokeWidth: 193,
      strokeCap: 193,
      strokeJoin: 193,
      strokeScaling: 201,
      miterLimit: 193,
      fontFamily: 9,
      fontWeight: 9,
      fontSize: 9,
      font: 9,
      leading: 9,
      justification: 9
    },
        item = {
      beans: true
    },
        fields = {
      _class: 'Style',
      beans: true,
      initialize: function Style(style, _owner, _project) {
        this._values = {};
        this._owner = _owner;
        this._project = _owner && _owner._project || _project || paper.project;
        this._defaults = !_owner || _owner instanceof Group ? groupDefaults : _owner instanceof TextItem ? textDefaults : itemDefaults;
        if (style) this.set(style);
      }
    };
    Base.each(groupDefaults, function (value, key) {
      var isColor = /Color$/.test(key),
          isPoint = key === 'shadowOffset',
          part = Base.capitalize(key),
          flag = flags[key],
          set = 'set' + part,
          get = 'get' + part;

      fields[set] = function (value) {
        var owner = this._owner,
            children = owner && owner._children,
            applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath);

        if (applyToChildren) {
          for (var i = 0, l = children.length; i < l; i++) children[i]._style[set](value);
        }

        if ((key === 'selectedColor' || !applyToChildren) && key in this._defaults) {
          var old = this._values[key];

          if (old !== value) {
            if (isColor) {
              if (old) {
                Color._setOwner(old, null);

                old._canvasStyle = null;
              }

              if (value && value.constructor === Color) {
                value = Color._setOwner(value, owner, applyToChildren && set);
              }
            }

            this._values[key] = value;
            if (owner) owner._changed(flag || 129);
          }
        }
      };

      fields[get] = function (_dontMerge) {
        var owner = this._owner,
            children = owner && owner._children,
            applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath),
            value;

        if (applyToChildren && !_dontMerge) {
          for (var i = 0, l = children.length; i < l; i++) {
            var childValue = children[i]._style[get]();

            if (!i) {
              value = childValue;
            } else if (!Base.equals(value, childValue)) {
              return undefined;
            }
          }
        } else if (key in this._defaults) {
          var value = this._values[key];

          if (value === undefined) {
            value = this._defaults[key];

            if (value && value.clone) {
              value = value.clone();
            }
          } else {
            var ctor = isColor ? Color : isPoint ? Point : null;

            if (ctor && !(value && value.constructor === ctor)) {
              this._values[key] = value = ctor.read([value], 0, {
                readNull: true,
                clone: true
              });
            }
          }
        }

        if (value && isColor) {
          value = Color._setOwner(value, owner, applyToChildren && set);
        }

        return value;
      };

      item[get] = function (_dontMerge) {
        return this._style[get](_dontMerge);
      };

      item[set] = function (value) {
        this._style[set](value);
      };
    });
    Base.each({
      Font: 'FontFamily',
      WindingRule: 'FillRule'
    }, function (value, key) {
      var get = 'get' + key,
          set = 'set' + key;
      fields[get] = item[get] = '#get' + value;
      fields[set] = item[set] = '#set' + value;
    });
    Item.inject(item);
    return fields;
  }(), {
    set: function (style) {
      var isStyle = style instanceof Style,
          values = isStyle ? style._values : style;

      if (values) {
        for (var key in values) {
          if (key in this._defaults) {
            var value = values[key];
            this[key] = value && isStyle && value.clone ? value.clone() : value;
          }
        }
      }
    },
    equals: function (style) {
      function compare(style1, style2, secondary) {
        var values1 = style1._values,
            values2 = style2._values,
            defaults2 = style2._defaults;

        for (var key in values1) {
          var value1 = values1[key],
              value2 = values2[key];
          if (!(secondary && key in values2) && !Base.equals(value1, value2 === undefined ? defaults2[key] : value2)) return false;
        }

        return true;
      }

      return style === this || style && this._class === style._class && compare(this, style) && compare(style, this, true) || false;
    },
    _dispose: function () {
      var color;
      color = this.getFillColor();
      if (color) color._canvasStyle = null;
      color = this.getStrokeColor();
      if (color) color._canvasStyle = null;
      color = this.getShadowColor();
      if (color) color._canvasStyle = null;
    },
    hasFill: function () {
      var color = this.getFillColor();
      return !!color && color.alpha > 0;
    },
    hasStroke: function () {
      var color = this.getStrokeColor();
      return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
    },
    hasShadow: function () {
      var color = this.getShadowColor();
      return !!color && color.alpha > 0 && (this.getShadowBlur() > 0 || !this.getShadowOffset().isZero());
    },
    getView: function () {
      return this._project._view;
    },
    getFontStyle: function () {
      var fontSize = this.getFontSize();
      return this.getFontWeight() + ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ') + this.getFontFamily();
    },
    getFont: '#getFontFamily',
    setFont: '#setFontFamily',
    getLeading: function getLeading() {
      var leading = getLeading.base.call(this),
          fontSize = this.getFontSize();
      if (/pt|em|%|px/.test(fontSize)) fontSize = this.getView().getPixelSize(fontSize);
      return leading != null ? leading : fontSize * 1.2;
    }
  });
  var DomElement = new function () {
    function handlePrefix(el, name, set, value) {
      var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
          suffix = name[0].toUpperCase() + name.substring(1);

      for (var i = 0; i < 6; i++) {
        var prefix = prefixes[i],
            key = prefix ? prefix + suffix : name;

        if (key in el) {
          if (set) {
            el[key] = value;
          } else {
            return el[key];
          }

          break;
        }
      }
    }

    return {
      getStyles: function (el) {
        var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
            view = doc && doc.defaultView;
        return view && view.getComputedStyle(el, '');
      },
      getBounds: function (el, viewport) {
        var doc = el.ownerDocument,
            body = doc.body,
            html = doc.documentElement,
            rect;

        try {
          rect = el.getBoundingClientRect();
        } catch (e) {
          rect = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
          };
        }

        var x = rect.left - (html.clientLeft || body.clientLeft || 0),
            y = rect.top - (html.clientTop || body.clientTop || 0);

        if (!viewport) {
          var view = doc.defaultView;
          x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
          y += view.pageYOffset || html.scrollTop || body.scrollTop;
        }

        return new Rectangle(x, y, rect.width, rect.height);
      },
      getViewportBounds: function (el) {
        var doc = el.ownerDocument,
            view = doc.defaultView,
            html = doc.documentElement;
        return new Rectangle(0, 0, view.innerWidth || html.clientWidth, view.innerHeight || html.clientHeight);
      },
      getOffset: function (el, viewport) {
        return DomElement.getBounds(el, viewport).getPoint();
      },
      getSize: function (el) {
        return DomElement.getBounds(el, true).getSize();
      },
      isInvisible: function (el) {
        return DomElement.getSize(el).equals(new Size(0, 0));
      },
      isInView: function (el) {
        return !DomElement.isInvisible(el) && DomElement.getViewportBounds(el).intersects(DomElement.getBounds(el, true));
      },
      isInserted: function (el) {
        return document.body.contains(el);
      },
      getPrefixed: function (el, name) {
        return el && handlePrefix(el, name);
      },
      setPrefixed: function (el, name, value) {
        if (typeof name === 'object') {
          for (var key in name) handlePrefix(el, key, true, name[key]);
        } else {
          handlePrefix(el, name, true, value);
        }
      }
    };
  }();
  var DomEvent = {
    add: function (el, events) {
      if (el) {
        for (var type in events) {
          var func = events[type],
              parts = type.split(/[\s,]+/g);

          for (var i = 0, l = parts.length; i < l; i++) {
            var name = parts[i];
            var options = el === document && (name === 'touchstart' || name === 'touchmove') ? {
              passive: false
            } : false;
            el.addEventListener(name, func, options);
          }
        }
      }
    },
    remove: function (el, events) {
      if (el) {
        for (var type in events) {
          var func = events[type],
              parts = type.split(/[\s,]+/g);

          for (var i = 0, l = parts.length; i < l; i++) el.removeEventListener(parts[i], func, false);
        }
      }
    },
    getPoint: function (event) {
      var pos = event.targetTouches ? event.targetTouches.length ? event.targetTouches[0] : event.changedTouches[0] : event;
      return new Point(pos.pageX || pos.clientX + document.documentElement.scrollLeft, pos.pageY || pos.clientY + document.documentElement.scrollTop);
    },
    getTarget: function (event) {
      return event.target || event.srcElement;
    },
    getRelatedTarget: function (event) {
      return event.relatedTarget || event.toElement;
    },
    getOffset: function (event, target) {
      return DomEvent.getPoint(event).subtract(DomElement.getOffset(target || DomEvent.getTarget(event)));
    }
  };
  DomEvent.requestAnimationFrame = new function () {
    var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
        requested = false,
        callbacks = [],
        timer;

    function handleCallbacks() {
      var functions = callbacks;
      callbacks = [];

      for (var i = 0, l = functions.length; i < l; i++) functions[i]();

      requested = nativeRequest && callbacks.length;
      if (requested) nativeRequest(handleCallbacks);
    }

    return function (callback) {
      callbacks.push(callback);

      if (nativeRequest) {
        if (!requested) {
          nativeRequest(handleCallbacks);
          requested = true;
        }
      } else if (!timer) {
        timer = setInterval(handleCallbacks, 1000 / 60);
      }
    };
  }();
  var View = Base.extend(Emitter, {
    _class: 'View',
    initialize: function View(project, element) {
      function getSize(name) {
        return element[name] || parseInt(element.getAttribute(name), 10);
      }

      function getCanvasSize() {
        var size = DomElement.getSize(element);
        return size.isNaN() || size.isZero() ? new Size(getSize('width'), getSize('height')) : size;
      }

      var size;

      if (window && element) {
        this._id = element.getAttribute('id');
        if (this._id == null) element.setAttribute('id', this._id = 'paper-view-' + View._id++);
        DomEvent.add(element, this._viewEvents);
        var none = 'none';
        DomElement.setPrefixed(element.style, {
          userDrag: none,
          userSelect: none,
          touchCallout: none,
          contentZooming: none,
          tapHighlightColor: 'rgba(0,0,0,0)'
        });

        if (PaperScope.hasAttribute(element, 'resize')) {
          var that = this;
          DomEvent.add(window, this._windowEvents = {
            resize: function () {
              that.setViewSize(getCanvasSize());
            }
          });
        }

        size = getCanvasSize();

        if (PaperScope.hasAttribute(element, 'stats') && typeof Stats !== 'undefined') {
          this._stats = new Stats();
          var stats = this._stats.domElement,
              style = stats.style,
              offset = DomElement.getOffset(element);
          style.position = 'absolute';
          style.left = offset.x + 'px';
          style.top = offset.y + 'px';
          document.body.appendChild(stats);
        }
      } else {
        size = new Size(element);
        element = null;
      }

      this._project = project;
      this._scope = project._scope;
      this._element = element;
      if (!this._pixelRatio) this._pixelRatio = window && window.devicePixelRatio || 1;

      this._setElementSize(size.width, size.height);

      this._viewSize = size;

      View._views.push(this);

      View._viewsById[this._id] = this;
      (this._matrix = new Matrix())._owner = this;
      if (!View._focused) View._focused = this;
      this._frameItems = {};
      this._frameItemCount = 0;
      this._itemEvents = {
        native: {},
        virtual: {}
      };
      this._autoUpdate = !paper.agent.node;
      this._needsUpdate = false;
    },
    remove: function () {
      if (!this._project) return false;
      if (View._focused === this) View._focused = null;

      View._views.splice(View._views.indexOf(this), 1);

      delete View._viewsById[this._id];
      var project = this._project;
      if (project._view === this) project._view = null;
      DomEvent.remove(this._element, this._viewEvents);
      DomEvent.remove(window, this._windowEvents);
      this._element = this._project = null;
      this.off('frame');
      this._animate = false;
      this._frameItems = {};
      return true;
    },
    _events: Base.each(Item._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']), function (name) {
      this[name] = {};
    }, {
      onFrame: {
        install: function () {
          this.play();
        },
        uninstall: function () {
          this.pause();
        }
      }
    }),
    _animate: false,
    _time: 0,
    _count: 0,
    getAutoUpdate: function () {
      return this._autoUpdate;
    },
    setAutoUpdate: function (autoUpdate) {
      this._autoUpdate = autoUpdate;
      if (autoUpdate) this.requestUpdate();
    },
    update: function () {},
    draw: function () {
      this.update();
    },
    requestUpdate: function () {
      if (!this._requested) {
        var that = this;
        DomEvent.requestAnimationFrame(function () {
          that._requested = false;

          if (that._animate) {
            that.requestUpdate();
            var element = that._element;

            if ((!DomElement.getPrefixed(document, 'hidden') || PaperScope.getAttribute(element, 'keepalive') === 'true') && DomElement.isInView(element)) {
              that._handleFrame();
            }
          }

          if (that._autoUpdate) that.update();
        });
        this._requested = true;
      }
    },
    play: function () {
      this._animate = true;
      this.requestUpdate();
    },
    pause: function () {
      this._animate = false;
    },
    _handleFrame: function () {
      paper = this._scope;
      var now = Date.now() / 1000,
          delta = this._last ? now - this._last : 0;
      this._last = now;
      this.emit('frame', new Base({
        delta: delta,
        time: this._time += delta,
        count: this._count++
      }));
      if (this._stats) this._stats.update();
    },
    _animateItem: function (item, animate) {
      var items = this._frameItems;

      if (animate) {
        items[item._id] = {
          item: item,
          time: 0,
          count: 0
        };
        if (++this._frameItemCount === 1) this.on('frame', this._handleFrameItems);
      } else {
        delete items[item._id];

        if (--this._frameItemCount === 0) {
          this.off('frame', this._handleFrameItems);
        }
      }
    },
    _handleFrameItems: function (event) {
      for (var i in this._frameItems) {
        var entry = this._frameItems[i];
        entry.item.emit('frame', new Base(event, {
          time: entry.time += event.delta,
          count: entry.count++
        }));
      }
    },
    _changed: function () {
      this._project._changed(4097);

      this._bounds = this._decomposed = undefined;
    },
    getElement: function () {
      return this._element;
    },
    getPixelRatio: function () {
      return this._pixelRatio;
    },
    getResolution: function () {
      return this._pixelRatio * 72;
    },
    getViewSize: function () {
      var size = this._viewSize;
      return new LinkedSize(size.width, size.height, this, 'setViewSize');
    },
    setViewSize: function () {
      var size = Size.read(arguments),
          delta = size.subtract(this._viewSize);
      if (delta.isZero()) return;

      this._setElementSize(size.width, size.height);

      this._viewSize.set(size);

      this._changed();

      this.emit('resize', {
        size: size,
        delta: delta
      });

      if (this._autoUpdate) {
        this.update();
      }
    },
    _setElementSize: function (width, height) {
      var element = this._element;

      if (element) {
        if (element.width !== width) element.width = width;
        if (element.height !== height) element.height = height;
      }
    },
    getBounds: function () {
      if (!this._bounds) this._bounds = this._matrix.inverted()._transformBounds(new Rectangle(new Point(), this._viewSize));
      return this._bounds;
    },
    getSize: function () {
      return this.getBounds().getSize();
    },
    isVisible: function () {
      return DomElement.isInView(this._element);
    },
    isInserted: function () {
      return DomElement.isInserted(this._element);
    },
    getPixelSize: function (size) {
      var element = this._element,
          pixels;

      if (element) {
        var parent = element.parentNode,
            temp = document.createElement('div');
        temp.style.fontSize = size;
        parent.appendChild(temp);
        pixels = parseFloat(DomElement.getStyles(temp).fontSize);
        parent.removeChild(temp);
      } else {
        pixels = parseFloat(pixels);
      }

      return pixels;
    },
    getTextWidth: function (font, lines) {
      return 0;
    }
  }, Base.each(['rotate', 'scale', 'shear', 'skew'], function (key) {
    var rotate = key === 'rotate';

    this[key] = function () {
      var args = arguments,
          value = (rotate ? Base : Point).read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      return this.transform(new Matrix()[key](value, center || this.getCenter(true)));
    };
  }, {
    _decompose: function () {
      return this._decomposed || (this._decomposed = this._matrix.decompose());
    },
    translate: function () {
      var mx = new Matrix();
      return this.transform(mx.translate.apply(mx, arguments));
    },
    getCenter: function () {
      return this.getBounds().getCenter();
    },
    setCenter: function () {
      var center = Point.read(arguments);
      this.translate(this.getCenter().subtract(center));
    },
    getZoom: function () {
      var scaling = this._decompose().scaling;

      return (scaling.x + scaling.y) / 2;
    },
    setZoom: function (zoom) {
      this.transform(new Matrix().scale(zoom / this.getZoom(), this.getCenter()));
    },
    getRotation: function () {
      return this._decompose().rotation;
    },
    setRotation: function (rotation) {
      var current = this.getRotation();

      if (current != null && rotation != null) {
        this.rotate(rotation - current);
      }
    },
    getScaling: function () {
      var scaling = this._decompose().scaling;

      return new LinkedPoint(scaling.x, scaling.y, this, 'setScaling');
    },
    setScaling: function () {
      var current = this.getScaling(),
          scaling = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });

      if (current && scaling) {
        this.scale(scaling.x / current.x, scaling.y / current.y);
      }
    },
    getMatrix: function () {
      return this._matrix;
    },
    setMatrix: function () {
      var matrix = this._matrix;
      matrix.set.apply(matrix, arguments);
    },
    transform: function (matrix) {
      this._matrix.append(matrix);
    },
    scrollBy: function () {
      this.translate(Point.read(arguments).negate());
    }
  }), {
    projectToView: function () {
      return this._matrix._transformPoint(Point.read(arguments));
    },
    viewToProject: function () {
      return this._matrix._inverseTransform(Point.read(arguments));
    },
    getEventPoint: function (event) {
      return this.viewToProject(DomEvent.getOffset(event, this._element));
    }
  }, {
    statics: {
      _views: [],
      _viewsById: {},
      _id: 0,
      create: function (project, element) {
        if (document && typeof element === 'string') element = document.getElementById(element);
        var ctor = window ? CanvasView : View;
        return new ctor(project, element);
      }
    }
  }, new function () {
    if (!window) return;
    var prevFocus,
        tempFocus,
        dragging = false,
        mouseDown = false;

    function getView(event) {
      var target = DomEvent.getTarget(event);
      return target.getAttribute && View._viewsById[target.getAttribute('id')];
    }

    function updateFocus() {
      var view = View._focused;

      if (!view || !view.isVisible()) {
        for (var i = 0, l = View._views.length; i < l; i++) {
          if ((view = View._views[i]).isVisible()) {
            View._focused = tempFocus = view;
            break;
          }
        }
      }
    }

    function handleMouseMove(view, event, point) {
      view._handleMouseEvent('mousemove', event, point);
    }

    var navigator = window.navigator,
        mousedown,
        mousemove,
        mouseup;

    if (navigator.pointerEnabled || navigator.msPointerEnabled) {
      mousedown = 'pointerdown MSPointerDown';
      mousemove = 'pointermove MSPointerMove';
      mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
    } else {
      mousedown = 'touchstart';
      mousemove = 'touchmove';
      mouseup = 'touchend touchcancel';

      if (!('ontouchstart' in window && navigator.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
        mousedown += ' mousedown';
        mousemove += ' mousemove';
        mouseup += ' mouseup';
      }
    }

    var viewEvents = {},
        docEvents = {
      mouseout: function (event) {
        var view = View._focused,
            target = DomEvent.getRelatedTarget(event);

        if (view && (!target || target.nodeName === 'HTML')) {
          var offset = DomEvent.getOffset(event, view._element),
              x = offset.x,
              abs = Math.abs,
              ax = abs(x),
              max = 1 << 25,
              diff = ax - max;
          offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;
          handleMouseMove(view, event, view.viewToProject(offset));
        }
      },
      scroll: updateFocus
    };

    viewEvents[mousedown] = function (event) {
      var view = View._focused = getView(event);

      if (!dragging) {
        dragging = true;

        view._handleMouseEvent('mousedown', event);
      }
    };

    docEvents[mousemove] = function (event) {
      var view = View._focused;

      if (!mouseDown) {
        var target = getView(event);

        if (target) {
          if (view !== target) {
            if (view) handleMouseMove(view, event);
            if (!prevFocus) prevFocus = view;
            view = View._focused = tempFocus = target;
          }
        } else if (tempFocus && tempFocus === view) {
          if (prevFocus && !prevFocus.isInserted()) prevFocus = null;
          view = View._focused = prevFocus;
          prevFocus = null;
          updateFocus();
        }
      }

      if (view) handleMouseMove(view, event);
    };

    docEvents[mousedown] = function () {
      mouseDown = true;
    };

    docEvents[mouseup] = function (event) {
      var view = View._focused;
      if (view && dragging) view._handleMouseEvent('mouseup', event);
      mouseDown = dragging = false;
    };

    DomEvent.add(document, docEvents);
    DomEvent.add(window, {
      load: updateFocus
    });
    var called = false,
        prevented = false,
        fallbacks = {
      doubleclick: 'click',
      mousedrag: 'mousemove'
    },
        wasInView = false,
        overView,
        downPoint,
        lastPoint,
        downItem,
        overItem,
        dragItem,
        clickItem,
        clickTime,
        dblClick;

    function emitMouseEvent(obj, target, type, event, point, prevPoint, stopItem) {
      var stopped = false,
          mouseEvent;

      function emit(obj, type) {
        if (obj.responds(type)) {
          if (!mouseEvent) {
            mouseEvent = new MouseEvent(type, event, point, target || obj, prevPoint ? point.subtract(prevPoint) : null);
          }

          if (obj.emit(type, mouseEvent)) {
            called = true;
            if (mouseEvent.prevented) prevented = true;
            if (mouseEvent.stopped) return stopped = true;
          }
        } else {
          var fallback = fallbacks[type];
          if (fallback) return emit(obj, fallback);
        }
      }

      while (obj && obj !== stopItem) {
        if (emit(obj, type)) break;
        obj = obj._parent;
      }

      return stopped;
    }

    function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
      view._project.removeOn(type);

      prevented = called = false;
      return dragItem && emitMouseEvent(dragItem, null, type, event, point, prevPoint) || hitItem && hitItem !== dragItem && !hitItem.isDescendant(dragItem) && emitMouseEvent(hitItem, null, type === 'mousedrag' ? 'mousemove' : type, event, point, prevPoint, dragItem) || emitMouseEvent(view, dragItem || hitItem || view, type, event, point, prevPoint);
    }

    var itemEventsMap = {
      mousedown: {
        mousedown: 1,
        mousedrag: 1,
        click: 1,
        doubleclick: 1
      },
      mouseup: {
        mouseup: 1,
        mousedrag: 1,
        click: 1,
        doubleclick: 1
      },
      mousemove: {
        mousedrag: 1,
        mousemove: 1,
        mouseenter: 1,
        mouseleave: 1
      }
    };
    return {
      _viewEvents: viewEvents,
      _handleMouseEvent: function (type, event, point) {
        var itemEvents = this._itemEvents,
            hitItems = itemEvents.native[type],
            nativeMove = type === 'mousemove',
            tool = this._scope.tool,
            view = this;

        function responds(type) {
          return itemEvents.virtual[type] || view.responds(type) || tool && tool.responds(type);
        }

        if (nativeMove && dragging && responds('mousedrag')) type = 'mousedrag';
        if (!point) point = this.getEventPoint(event);

        var inView = this.getBounds().contains(point),
            hit = hitItems && inView && view._project.hitTest(point, {
          tolerance: 0,
          fill: true,
          stroke: true
        }),
            hitItem = hit && hit.item || null,
            handle = false,
            mouse = {};

        mouse[type.substr(5)] = true;

        if (hitItems && hitItem !== overItem) {
          if (overItem) {
            emitMouseEvent(overItem, null, 'mouseleave', event, point);
          }

          if (hitItem) {
            emitMouseEvent(hitItem, null, 'mouseenter', event, point);
          }

          overItem = hitItem;
        }

        if (wasInView ^ inView) {
          emitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave', event, point);
          overView = inView ? this : null;
          handle = true;
        }

        if ((inView || mouse.drag) && !point.equals(lastPoint)) {
          emitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove', event, point, lastPoint);
          handle = true;
        }

        wasInView = inView;

        if (mouse.down && inView || mouse.up && downPoint) {
          emitMouseEvents(this, hitItem, type, event, point, downPoint);

          if (mouse.down) {
            dblClick = hitItem === clickItem && Date.now() - clickTime < 300;
            downItem = clickItem = hitItem;

            if (!prevented && hitItem) {
              var item = hitItem;

              while (item && !item.responds('mousedrag')) item = item._parent;

              if (item) dragItem = hitItem;
            }

            downPoint = point;
          } else if (mouse.up) {
            if (!prevented && hitItem === downItem) {
              clickTime = Date.now();
              emitMouseEvents(this, hitItem, dblClick ? 'doubleclick' : 'click', event, point, downPoint);
              dblClick = false;
            }

            downItem = dragItem = null;
          }

          wasInView = false;
          handle = true;
        }

        lastPoint = point;

        if (handle && tool) {
          called = tool._handleMouseEvent(type, event, point, mouse) || called;
        }

        if (event.cancelable !== false && (called && !mouse.move || mouse.down && responds('mouseup'))) {
          event.preventDefault();
        }
      },
      _handleKeyEvent: function (type, event, key, character) {
        var scope = this._scope,
            tool = scope.tool,
            keyEvent;

        function emit(obj) {
          if (obj.responds(type)) {
            paper = scope;
            obj.emit(type, keyEvent = keyEvent || new KeyEvent(type, event, key, character));
          }
        }

        if (this.isVisible()) {
          emit(this);
          if (tool && tool.responds(type)) emit(tool);
        }
      },
      _countItemEvent: function (type, sign) {
        var itemEvents = this._itemEvents,
            native = itemEvents.native,
            virtual = itemEvents.virtual;

        for (var key in itemEventsMap) {
          native[key] = (native[key] || 0) + (itemEventsMap[key][type] || 0) * sign;
        }

        virtual[type] = (virtual[type] || 0) + sign;
      },
      statics: {
        updateFocus: updateFocus,
        _resetState: function () {
          dragging = mouseDown = called = wasInView = false;
          prevFocus = tempFocus = overView = downPoint = lastPoint = downItem = overItem = dragItem = clickItem = clickTime = dblClick = null;
        }
      }
    };
  }());
  var CanvasView = View.extend({
    _class: 'CanvasView',
    initialize: function CanvasView(project, canvas) {
      if (!(canvas instanceof window.HTMLCanvasElement)) {
        var size = Size.read(arguments, 1);
        if (size.isZero()) throw new Error('Cannot create CanvasView with the provided argument: ' + Base.slice(arguments, 1));
        canvas = CanvasProvider.getCanvas(size);
      }

      var ctx = this._context = canvas.getContext('2d');
      ctx.save();
      this._pixelRatio = 1;

      if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
        var deviceRatio = window.devicePixelRatio || 1,
            backingStoreRatio = DomElement.getPrefixed(ctx, 'backingStorePixelRatio') || 1;
        this._pixelRatio = deviceRatio / backingStoreRatio;
      }

      View.call(this, project, canvas);
      this._needsUpdate = true;
    },
    remove: function remove() {
      this._context.restore();

      return remove.base.call(this);
    },
    _setElementSize: function _setElementSize(width, height) {
      var pixelRatio = this._pixelRatio;

      _setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);

      if (pixelRatio !== 1) {
        var element = this._element,
            ctx = this._context;

        if (!PaperScope.hasAttribute(element, 'resize')) {
          var style = element.style;
          style.width = width + 'px';
          style.height = height + 'px';
        }

        ctx.restore();
        ctx.save();
        ctx.scale(pixelRatio, pixelRatio);
      }
    },
    getContext: function () {
      return this._context;
    },
    getPixelSize: function getPixelSize(size) {
      var agent = paper.agent,
          pixels;

      if (agent && agent.firefox) {
        pixels = getPixelSize.base.call(this, size);
      } else {
        var ctx = this._context,
            prevFont = ctx.font;
        ctx.font = size + ' serif';
        pixels = parseFloat(ctx.font);
        ctx.font = prevFont;
      }

      return pixels;
    },
    getTextWidth: function (font, lines) {
      var ctx = this._context,
          prevFont = ctx.font,
          width = 0;
      ctx.font = font;

      for (var i = 0, l = lines.length; i < l; i++) width = Math.max(width, ctx.measureText(lines[i]).width);

      ctx.font = prevFont;
      return width;
    },
    update: function () {
      if (!this._needsUpdate) return false;
      var project = this._project,
          ctx = this._context,
          size = this._viewSize;
      ctx.clearRect(0, 0, size.width + 1, size.height + 1);
      if (project) project.draw(ctx, this._matrix, this._pixelRatio);
      this._needsUpdate = false;
      return true;
    }
  });
  var Event = Base.extend({
    _class: 'Event',
    initialize: function Event(event) {
      this.event = event;
      this.type = event && event.type;
    },
    prevented: false,
    stopped: false,
    preventDefault: function () {
      this.prevented = true;
      this.event.preventDefault();
    },
    stopPropagation: function () {
      this.stopped = true;
      this.event.stopPropagation();
    },
    stop: function () {
      this.stopPropagation();
      this.preventDefault();
    },
    getTimeStamp: function () {
      return this.event.timeStamp;
    },
    getModifiers: function () {
      return Key.modifiers;
    }
  });
  var KeyEvent = Event.extend({
    _class: 'KeyEvent',
    initialize: function KeyEvent(type, event, key, character) {
      this.type = type;
      this.event = event;
      this.key = key;
      this.character = character;
    },
    toString: function () {
      return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
    }
  });
  var Key = new function () {
    var keyLookup = {
      '\t': 'tab',
      ' ': 'space',
      '\b': 'backspace',
      '\x7f': 'delete',
      'Spacebar': 'space',
      'Del': 'delete',
      'Win': 'meta',
      'Esc': 'escape'
    },
        charLookup = {
      'tab': '\t',
      'space': ' ',
      'enter': '\r'
    },
        keyMap = {},
        charMap = {},
        metaFixMap,
        downKey,
        modifiers = new Base({
      shift: false,
      control: false,
      alt: false,
      meta: false,
      capsLock: false,
      space: false
    }).inject({
      option: {
        get: function () {
          return this.alt;
        }
      },
      command: {
        get: function () {
          var agent = paper && paper.agent;
          return agent && agent.mac ? this.meta : this.control;
        }
      }
    });

    function getKey(event) {
      var key = event.key || event.keyIdentifier;
      key = /^U\+/.test(key) ? String.fromCharCode(parseInt(key.substr(2), 16)) : /^Arrow[A-Z]/.test(key) ? key.substr(5) : key === 'Unidentified' || key === undefined ? String.fromCharCode(event.keyCode) : key;
      return keyLookup[key] || (key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
    }

    function handleKey(down, key, character, event) {
      var type = down ? 'keydown' : 'keyup',
          view = View._focused,
          name;
      keyMap[key] = down;

      if (down) {
        charMap[key] = character;
      } else {
        delete charMap[key];
      }

      if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
        modifiers[name] = down;
        var agent = paper && paper.agent;

        if (name === 'meta' && agent && agent.mac) {
          if (down) {
            metaFixMap = {};
          } else {
            for (var k in metaFixMap) {
              if (k in charMap) handleKey(false, k, metaFixMap[k], event);
            }

            metaFixMap = null;
          }
        }
      } else if (down && metaFixMap) {
        metaFixMap[key] = character;
      }

      if (view) {
        view._handleKeyEvent(down ? 'keydown' : 'keyup', event, key, character);
      }
    }

    DomEvent.add(document, {
      keydown: function (event) {
        var key = getKey(event),
            agent = paper && paper.agent;

        if (key.length > 1 || agent && agent.chrome && (event.altKey || agent.mac && event.metaKey || !agent.mac && event.ctrlKey)) {
          handleKey(true, key, charLookup[key] || (key.length > 1 ? '' : key), event);
        } else {
          downKey = key;
        }
      },
      keypress: function (event) {
        if (downKey) {
          var key = getKey(event),
              code = event.charCode,
              character = code >= 32 ? String.fromCharCode(code) : key.length > 1 ? '' : key;

          if (key !== downKey) {
            key = character.toLowerCase();
          }

          handleKey(true, key, character, event);
          downKey = null;
        }
      },
      keyup: function (event) {
        var key = getKey(event);
        if (key in charMap) handleKey(false, key, charMap[key], event);
      }
    });
    DomEvent.add(window, {
      blur: function (event) {
        for (var key in charMap) handleKey(false, key, charMap[key], event);
      }
    });
    return {
      modifiers: modifiers,
      isDown: function (key) {
        return !!keyMap[key];
      }
    };
  }();
  var MouseEvent = Event.extend({
    _class: 'MouseEvent',
    initialize: function MouseEvent(type, event, point, target, delta) {
      this.type = type;
      this.event = event;
      this.point = point;
      this.target = target;
      this.delta = delta;
    },
    toString: function () {
      return "{ type: '" + this.type + "', point: " + this.point + ', target: ' + this.target + (this.delta ? ', delta: ' + this.delta : '') + ', modifiers: ' + this.getModifiers() + ' }';
    }
  });
  var ToolEvent = Event.extend({
    _class: 'ToolEvent',
    _item: null,
    initialize: function ToolEvent(tool, type, event) {
      this.tool = tool;
      this.type = type;
      this.event = event;
    },
    _choosePoint: function (point, toolPoint) {
      return point ? point : toolPoint ? toolPoint.clone() : null;
    },
    getPoint: function () {
      return this._choosePoint(this._point, this.tool._point);
    },
    setPoint: function (point) {
      this._point = point;
    },
    getLastPoint: function () {
      return this._choosePoint(this._lastPoint, this.tool._lastPoint);
    },
    setLastPoint: function (lastPoint) {
      this._lastPoint = lastPoint;
    },
    getDownPoint: function () {
      return this._choosePoint(this._downPoint, this.tool._downPoint);
    },
    setDownPoint: function (downPoint) {
      this._downPoint = downPoint;
    },
    getMiddlePoint: function () {
      if (!this._middlePoint && this.tool._lastPoint) {
        return this.tool._point.add(this.tool._lastPoint).divide(2);
      }

      return this._middlePoint;
    },
    setMiddlePoint: function (middlePoint) {
      this._middlePoint = middlePoint;
    },
    getDelta: function () {
      return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
    },
    setDelta: function (delta) {
      this._delta = delta;
    },
    getCount: function () {
      return this.tool[/^mouse(down|up)$/.test(this.type) ? '_downCount' : '_moveCount'];
    },
    setCount: function (count) {
      this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count'] = count;
    },
    getItem: function () {
      if (!this._item) {
        var result = this.tool._scope.project.hitTest(this.getPoint());

        if (result) {
          var item = result.item,
              parent = item._parent;

          while (/^(Group|CompoundPath)$/.test(parent._class)) {
            item = parent;
            parent = parent._parent;
          }

          this._item = item;
        }
      }

      return this._item;
    },
    setItem: function (item) {
      this._item = item;
    },
    toString: function () {
      return '{ type: ' + this.type + ', point: ' + this.getPoint() + ', count: ' + this.getCount() + ', modifiers: ' + this.getModifiers() + ' }';
    }
  });
  var Tool = PaperScopeItem.extend({
    _class: 'Tool',
    _list: 'tools',
    _reference: 'tool',
    _events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove', 'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown', 'onKeyUp'],
    initialize: function Tool(props) {
      PaperScopeItem.call(this);
      this._moveCount = -1;
      this._downCount = -1;
      this.set(props);
    },
    getMinDistance: function () {
      return this._minDistance;
    },
    setMinDistance: function (minDistance) {
      this._minDistance = minDistance;

      if (minDistance != null && this._maxDistance != null && minDistance > this._maxDistance) {
        this._maxDistance = minDistance;
      }
    },
    getMaxDistance: function () {
      return this._maxDistance;
    },
    setMaxDistance: function (maxDistance) {
      this._maxDistance = maxDistance;

      if (this._minDistance != null && maxDistance != null && maxDistance < this._minDistance) {
        this._minDistance = maxDistance;
      }
    },
    getFixedDistance: function () {
      return this._minDistance == this._maxDistance ? this._minDistance : null;
    },
    setFixedDistance: function (distance) {
      this._minDistance = this._maxDistance = distance;
    },
    _handleMouseEvent: function (type, event, point, mouse) {
      paper = this._scope;
      if (mouse.drag && !this.responds(type)) type = 'mousemove';
      var move = mouse.move || mouse.drag,
          responds = this.responds(type),
          minDistance = this.minDistance,
          maxDistance = this.maxDistance,
          called = false,
          tool = this;

      function update(minDistance, maxDistance) {
        var pt = point,
            toolPoint = move ? tool._point : tool._downPoint || pt;

        if (move) {
          if (tool._moveCount >= 0 && pt.equals(toolPoint)) {
            return false;
          }

          if (toolPoint && (minDistance != null || maxDistance != null)) {
            var vector = pt.subtract(toolPoint),
                distance = vector.getLength();
            if (distance < (minDistance || 0)) return false;

            if (maxDistance) {
              pt = toolPoint.add(vector.normalize(Math.min(distance, maxDistance)));
            }
          }

          tool._moveCount++;
        }

        tool._point = pt;
        tool._lastPoint = toolPoint || pt;

        if (mouse.down) {
          tool._moveCount = -1;
          tool._downPoint = pt;
          tool._downCount++;
        }

        return true;
      }

      function emit() {
        if (responds) {
          called = tool.emit(type, new ToolEvent(tool, type, event)) || called;
        }
      }

      if (mouse.down) {
        update();
        emit();
      } else if (mouse.up) {
        update(null, maxDistance);
        emit();
      } else if (responds) {
        while (update(minDistance, maxDistance)) emit();
      }

      return called;
    }
  });
  var Tween = Base.extend(Emitter, {
    _class: 'Tween',
    statics: {
      easings: {
        linear: function (t) {
          return t;
        },
        easeInQuad: function (t) {
          return t * t;
        },
        easeOutQuad: function (t) {
          return t * (2 - t);
        },
        easeInOutQuad: function (t) {
          return t < 0.5 ? 2 * t * t : -1 + 2 * (2 - t) * t;
        },
        easeInCubic: function (t) {
          return t * t * t;
        },
        easeOutCubic: function (t) {
          return --t * t * t + 1;
        },
        easeInOutCubic: function (t) {
          return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        },
        easeInQuart: function (t) {
          return t * t * t * t;
        },
        easeOutQuart: function (t) {
          return 1 - --t * t * t * t;
        },
        easeInOutQuart: function (t) {
          return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
        },
        easeInQuint: function (t) {
          return t * t * t * t * t;
        },
        easeOutQuint: function (t) {
          return 1 + --t * t * t * t * t;
        },
        easeInOutQuint: function (t) {
          return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
        }
      }
    },
    initialize: function Tween(object, from, to, duration, easing, start) {
      this.object = object;
      var type = typeof easing;
      var isFunction = type === 'function';
      this.type = isFunction ? type : type === 'string' ? easing : 'linear';
      this.easing = isFunction ? easing : Tween.easings[this.type];
      this.duration = duration;
      this.running = false;
      this._then = null;
      this._startTime = null;
      var state = from || to;
      this._keys = state ? Object.keys(state) : [];
      this._parsedKeys = this._parseKeys(this._keys);
      this._from = state && this._getState(from);
      this._to = state && this._getState(to);

      if (start !== false) {
        this.start();
      }
    },
    then: function (then) {
      this._then = then;
      return this;
    },
    start: function () {
      this._startTime = null;
      this.running = true;
      return this;
    },
    stop: function () {
      this.running = false;
      return this;
    },
    update: function (progress) {
      if (this.running) {
        if (progress >= 1) {
          progress = 1;
          this.running = false;
        }

        var factor = this.easing(progress),
            keys = this._keys,
            getValue = function (value) {
          return typeof value === 'function' ? value(factor, progress) : value;
        };

        for (var i = 0, l = keys && keys.length; i < l; i++) {
          var key = keys[i],
              from = getValue(this._from[key]),
              to = getValue(this._to[key]),
              value = from && to && from.__add && to.__add ? to.__subtract(from).__multiply(factor).__add(from) : (to - from) * factor + from;

          this._setProperty(this._parsedKeys[key], value);
        }

        if (this.responds('update')) {
          this.emit('update', new Base({
            progress: progress,
            factor: factor
          }));
        }

        if (!this.running && this._then) {
          this._then(this.object);
        }
      }

      return this;
    },
    _events: {
      onUpdate: {}
    },
    _handleFrame: function (time) {
      var startTime = this._startTime,
          progress = startTime ? (time - startTime) / this.duration : 0;

      if (!startTime) {
        this._startTime = time;
      }

      this.update(progress);
    },
    _getState: function (state) {
      var keys = this._keys,
          result = {};

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i],
            path = this._parsedKeys[key],
            current = this._getProperty(path),
            value;

        if (state) {
          var resolved = this._resolveValue(current, state[key]);

          this._setProperty(path, resolved);

          value = this._getProperty(path);
          value = value && value.clone ? value.clone() : value;

          this._setProperty(path, current);
        } else {
          value = current && current.clone ? current.clone() : current;
        }

        result[key] = value;
      }

      return result;
    },
    _resolveValue: function (current, value) {
      if (value) {
        if (Array.isArray(value) && value.length === 2) {
          var operator = value[0];
          return operator && operator.match && operator.match(/^[+\-\*\/]=/) ? this._calculate(current, operator[0], value[1]) : value;
        } else if (typeof value === 'string') {
          var match = value.match(/^[+\-*/]=(.*)/);

          if (match) {
            var parsed = JSON.parse(match[1].replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": '));
            return this._calculate(current, value[0], parsed);
          }
        }
      }

      return value;
    },
    _calculate: function (left, operator, right) {
      return paper.PaperScript.calculateBinary(left, operator, right);
    },
    _parseKeys: function (keys) {
      var parsed = {};

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i],
            path = key.replace(/\.([^.]*)/g, '/$1').replace(/\[['"]?([^'"\]]*)['"]?\]/g, '/$1');
        parsed[key] = path.split('/');
      }

      return parsed;
    },
    _getProperty: function (path, offset) {
      var obj = this.object;

      for (var i = 0, l = path.length - (offset || 0); i < l && obj; i++) {
        obj = obj[path[i]];
      }

      return obj;
    },
    _setProperty: function (path, value) {
      var dest = this._getProperty(path, 1);

      if (dest) {
        dest[path[path.length - 1]] = value;
      }
    }
  });
  var Http = {
    request: function (options) {
      var xhr = new self.XMLHttpRequest();
      xhr.open((options.method || 'get').toUpperCase(), options.url, Base.pick(options.async, true));
      if (options.mimeType) xhr.overrideMimeType(options.mimeType);

      xhr.onload = function () {
        var status = xhr.status;

        if (status === 0 || status === 200) {
          if (options.onLoad) {
            options.onLoad.call(xhr, xhr.responseText);
          }
        } else {
          xhr.onerror();
        }
      };

      xhr.onerror = function () {
        var status = xhr.status,
            message = 'Could not load "' + options.url + '" (Status: ' + status + ')';

        if (options.onError) {
          options.onError(message, status);
        } else {
          throw new Error(message);
        }
      };

      return xhr.send(null);
    }
  };
  var CanvasProvider = Base.exports.CanvasProvider = {
    canvases: [],
    getCanvas: function (width, height) {
      if (!window) return null;
      var canvas,
          clear = true;

      if (typeof width === 'object') {
        height = width.height;
        width = width.width;
      }

      if (this.canvases.length) {
        canvas = this.canvases.pop();
      } else {
        canvas = document.createElement('canvas');
        clear = false;
      }

      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Canvas ' + canvas + ' is unable to provide a 2D context.');
      }

      if (canvas.width === width && canvas.height === height) {
        if (clear) ctx.clearRect(0, 0, width + 1, height + 1);
      } else {
        canvas.width = width;
        canvas.height = height;
      }

      ctx.save();
      return canvas;
    },
    getContext: function (width, height) {
      var canvas = this.getCanvas(width, height);
      return canvas ? canvas.getContext('2d') : null;
    },
    release: function (obj) {
      var canvas = obj && obj.canvas ? obj.canvas : obj;

      if (canvas && canvas.getContext) {
        canvas.getContext('2d').restore();
        this.canvases.push(canvas);
      }
    }
  };
  var BlendMode = new function () {
    var min = Math.min,
        max = Math.max,
        abs = Math.abs,
        sr,
        sg,
        sb,
        sa,
        br,
        bg,
        bb,
        ba,
        dr,
        dg,
        db;

    function getLum(r, g, b) {
      return 0.2989 * r + 0.587 * g + 0.114 * b;
    }

    function setLum(r, g, b, l) {
      var d = l - getLum(r, g, b);
      dr = r + d;
      dg = g + d;
      db = b + d;
      var l = getLum(dr, dg, db),
          mn = min(dr, dg, db),
          mx = max(dr, dg, db);

      if (mn < 0) {
        var lmn = l - mn;
        dr = l + (dr - l) * l / lmn;
        dg = l + (dg - l) * l / lmn;
        db = l + (db - l) * l / lmn;
      }

      if (mx > 255) {
        var ln = 255 - l,
            mxl = mx - l;
        dr = l + (dr - l) * ln / mxl;
        dg = l + (dg - l) * ln / mxl;
        db = l + (db - l) * ln / mxl;
      }
    }

    function getSat(r, g, b) {
      return max(r, g, b) - min(r, g, b);
    }

    function setSat(r, g, b, s) {
      var col = [r, g, b],
          mx = max(r, g, b),
          mn = min(r, g, b),
          md;
      mn = mn === r ? 0 : mn === g ? 1 : 2;
      mx = mx === r ? 0 : mx === g ? 1 : 2;
      md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;

      if (col[mx] > col[mn]) {
        col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
        col[mx] = s;
      } else {
        col[md] = col[mx] = 0;
      }

      col[mn] = 0;
      dr = col[0];
      dg = col[1];
      db = col[2];
    }

    var modes = {
      multiply: function () {
        dr = br * sr / 255;
        dg = bg * sg / 255;
        db = bb * sb / 255;
      },
      screen: function () {
        dr = br + sr - br * sr / 255;
        dg = bg + sg - bg * sg / 255;
        db = bb + sb - bb * sb / 255;
      },
      overlay: function () {
        dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
        dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
        db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
      },
      'soft-light': function () {
        var t = sr * br / 255;
        dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
        t = sg * bg / 255;
        dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
        t = sb * bb / 255;
        db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
      },
      'hard-light': function () {
        dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
        dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
        db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
      },
      'color-dodge': function () {
        dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
        dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
        db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
      },
      'color-burn': function () {
        dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
        dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
        db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
      },
      darken: function () {
        dr = br < sr ? br : sr;
        dg = bg < sg ? bg : sg;
        db = bb < sb ? bb : sb;
      },
      lighten: function () {
        dr = br > sr ? br : sr;
        dg = bg > sg ? bg : sg;
        db = bb > sb ? bb : sb;
      },
      difference: function () {
        dr = br - sr;
        if (dr < 0) dr = -dr;
        dg = bg - sg;
        if (dg < 0) dg = -dg;
        db = bb - sb;
        if (db < 0) db = -db;
      },
      exclusion: function () {
        dr = br + sr * (255 - br - br) / 255;
        dg = bg + sg * (255 - bg - bg) / 255;
        db = bb + sb * (255 - bb - bb) / 255;
      },
      hue: function () {
        setSat(sr, sg, sb, getSat(br, bg, bb));
        setLum(dr, dg, db, getLum(br, bg, bb));
      },
      saturation: function () {
        setSat(br, bg, bb, getSat(sr, sg, sb));
        setLum(dr, dg, db, getLum(br, bg, bb));
      },
      luminosity: function () {
        setLum(br, bg, bb, getLum(sr, sg, sb));
      },
      color: function () {
        setLum(sr, sg, sb, getLum(br, bg, bb));
      },
      add: function () {
        dr = min(br + sr, 255);
        dg = min(bg + sg, 255);
        db = min(bb + sb, 255);
      },
      subtract: function () {
        dr = max(br - sr, 0);
        dg = max(bg - sg, 0);
        db = max(bb - sb, 0);
      },
      average: function () {
        dr = (br + sr) / 2;
        dg = (bg + sg) / 2;
        db = (bb + sb) / 2;
      },
      negation: function () {
        dr = 255 - abs(255 - sr - br);
        dg = 255 - abs(255 - sg - bg);
        db = 255 - abs(255 - sb - bb);
      }
    };
    var nativeModes = this.nativeModes = Base.each(['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'darker', 'copy', 'xor'], function (mode) {
      this[mode] = true;
    }, {});
    var ctx = CanvasProvider.getContext(1, 1);

    if (ctx) {
      Base.each(modes, function (func, mode) {
        var darken = mode === 'darken',
            ok = false;
        ctx.save();

        try {
          ctx.fillStyle = darken ? '#300' : '#a00';
          ctx.fillRect(0, 0, 1, 1);
          ctx.globalCompositeOperation = mode;

          if (ctx.globalCompositeOperation === mode) {
            ctx.fillStyle = darken ? '#a00' : '#300';
            ctx.fillRect(0, 0, 1, 1);
            ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
          }
        } catch (e) {}

        ctx.restore();
        nativeModes[mode] = ok;
      });
      CanvasProvider.release(ctx);
    }

    this.process = function (mode, srcContext, dstContext, alpha, offset) {
      var srcCanvas = srcContext.canvas,
          normal = mode === 'normal';

      if (normal || nativeModes[mode]) {
        dstContext.save();
        dstContext.setTransform(1, 0, 0, 1, 0, 0);
        dstContext.globalAlpha = alpha;
        if (!normal) dstContext.globalCompositeOperation = mode;
        dstContext.drawImage(srcCanvas, offset.x, offset.y);
        dstContext.restore();
      } else {
        var process = modes[mode];
        if (!process) return;
        var dstData = dstContext.getImageData(offset.x, offset.y, srcCanvas.width, srcCanvas.height),
            dst = dstData.data,
            src = srcContext.getImageData(0, 0, srcCanvas.width, srcCanvas.height).data;

        for (var i = 0, l = dst.length; i < l; i += 4) {
          sr = src[i];
          br = dst[i];
          sg = src[i + 1];
          bg = dst[i + 1];
          sb = src[i + 2];
          bb = dst[i + 2];
          sa = src[i + 3];
          ba = dst[i + 3];
          process();
          var a1 = sa * alpha / 255,
              a2 = 1 - a1;
          dst[i] = a1 * dr + a2 * br;
          dst[i + 1] = a1 * dg + a2 * bg;
          dst[i + 2] = a1 * db + a2 * bb;
          dst[i + 3] = sa * alpha + a2 * ba;
        }

        dstContext.putImageData(dstData, offset.x, offset.y);
      }
    };
  }();
  var SvgElement = new function () {
    var svg = 'http://www.w3.org/2000/svg',
        xmlns = 'http://www.w3.org/2000/xmlns',
        xlink = 'http://www.w3.org/1999/xlink',
        attributeNamespace = {
      href: xlink,
      xlink: xmlns,
      xmlns: xmlns + '/',
      'xmlns:xlink': xmlns + '/'
    };

    function create(tag, attributes, formatter) {
      return set(document.createElementNS(svg, tag), attributes, formatter);
    }

    function get(node, name) {
      var namespace = attributeNamespace[name],
          value = namespace ? node.getAttributeNS(namespace, name) : node.getAttribute(name);
      return value === 'null' ? null : value;
    }

    function set(node, attributes, formatter) {
      for (var name in attributes) {
        var value = attributes[name],
            namespace = attributeNamespace[name];
        if (typeof value === 'number' && formatter) value = formatter.number(value);

        if (namespace) {
          node.setAttributeNS(namespace, name, value);
        } else {
          node.setAttribute(name, value);
        }
      }

      return node;
    }

    return {
      svg: svg,
      xmlns: xmlns,
      xlink: xlink,
      create: create,
      get: get,
      set: set
    };
  }();
  var SvgStyles = Base.each({
    fillColor: ['fill', 'color'],
    fillRule: ['fill-rule', 'string'],
    strokeColor: ['stroke', 'color'],
    strokeWidth: ['stroke-width', 'number'],
    strokeCap: ['stroke-linecap', 'string'],
    strokeJoin: ['stroke-linejoin', 'string'],
    strokeScaling: ['vector-effect', 'lookup', {
      true: 'none',
      false: 'non-scaling-stroke'
    }, function (item, value) {
      return !value && (item instanceof PathItem || item instanceof Shape || item instanceof TextItem);
    }],
    miterLimit: ['stroke-miterlimit', 'number'],
    dashArray: ['stroke-dasharray', 'array'],
    dashOffset: ['stroke-dashoffset', 'number'],
    fontFamily: ['font-family', 'string'],
    fontWeight: ['font-weight', 'string'],
    fontSize: ['font-size', 'number'],
    justification: ['text-anchor', 'lookup', {
      left: 'start',
      center: 'middle',
      right: 'end'
    }],
    opacity: ['opacity', 'number'],
    blendMode: ['mix-blend-mode', 'style']
  }, function (entry, key) {
    var part = Base.capitalize(key),
        lookup = entry[2];
    this[key] = {
      type: entry[1],
      property: key,
      attribute: entry[0],
      toSVG: lookup,
      fromSVG: lookup && Base.each(lookup, function (value, name) {
        this[value] = name;
      }, {}),
      exportFilter: entry[3],
      get: 'get' + part,
      set: 'set' + part
    };
  }, {});
  new function () {
    var formatter;

    function getTransform(matrix, coordinates, center) {
      var attrs = new Base(),
          trans = matrix.getTranslation();

      if (coordinates) {
        var point;

        if (matrix.isInvertible()) {
          matrix = matrix._shiftless();
          point = matrix._inverseTransform(trans);
          trans = null;
        } else {
          point = new Point();
        }

        attrs[center ? 'cx' : 'x'] = point.x;
        attrs[center ? 'cy' : 'y'] = point.y;
      }

      if (!matrix.isIdentity()) {
        var decomposed = matrix.decompose();

        if (decomposed) {
          var parts = [],
              angle = decomposed.rotation,
              scale = decomposed.scaling,
              skew = decomposed.skewing;
          if (trans && !trans.isZero()) parts.push('translate(' + formatter.point(trans) + ')');
          if (angle) parts.push('rotate(' + formatter.number(angle) + ')');
          if (!Numerical.isZero(scale.x - 1) || !Numerical.isZero(scale.y - 1)) parts.push('scale(' + formatter.point(scale) + ')');
          if (skew.x) parts.push('skewX(' + formatter.number(skew.x) + ')');
          if (skew.y) parts.push('skewY(' + formatter.number(skew.y) + ')');
          attrs.transform = parts.join(' ');
        } else {
          attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
        }
      }

      return attrs;
    }

    function exportGroup(item, options) {
      var attrs = getTransform(item._matrix),
          children = item._children;
      var node = SvgElement.create('g', attrs, formatter);

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        var childNode = exportSVG(child, options);

        if (childNode) {
          if (child.isClipMask()) {
            var clip = SvgElement.create('clipPath');
            clip.appendChild(childNode);
            setDefinition(child, clip, 'clip');
            SvgElement.set(node, {
              'clip-path': 'url(#' + clip.id + ')'
            });
          } else {
            node.appendChild(childNode);
          }
        }
      }

      return node;
    }

    function exportRaster(item, options) {
      var attrs = getTransform(item._matrix, true),
          size = item.getSize(),
          image = item.getImage();
      attrs.x -= size.width / 2;
      attrs.y -= size.height / 2;
      attrs.width = size.width;
      attrs.height = size.height;
      attrs.href = options.embedImages == false && image && image.src || item.toDataURL();
      return SvgElement.create('image', attrs, formatter);
    }

    function exportPath(item, options) {
      var matchShapes = options.matchShapes;

      if (matchShapes) {
        var shape = item.toShape(false);
        if (shape) return exportShape(shape, options);
      }

      var segments = item._segments,
          length = segments.length,
          type,
          attrs = getTransform(item._matrix);

      if (matchShapes && length >= 2 && !item.hasHandles()) {
        if (length > 2) {
          type = item._closed ? 'polygon' : 'polyline';
          var parts = [];

          for (var i = 0; i < length; i++) {
            parts.push(formatter.point(segments[i]._point));
          }

          attrs.points = parts.join(' ');
        } else {
          type = 'line';
          var start = segments[0]._point,
              end = segments[1]._point;
          attrs.set({
            x1: start.x,
            y1: start.y,
            x2: end.x,
            y2: end.y
          });
        }
      } else {
        type = 'path';
        attrs.d = item.getPathData(null, options.precision);
      }

      return SvgElement.create(type, attrs, formatter);
    }

    function exportShape(item) {
      var type = item._type,
          radius = item._radius,
          attrs = getTransform(item._matrix, true, type !== 'rectangle');

      if (type === 'rectangle') {
        type = 'rect';
        var size = item._size,
            width = size.width,
            height = size.height;
        attrs.x -= width / 2;
        attrs.y -= height / 2;
        attrs.width = width;
        attrs.height = height;
        if (radius.isZero()) radius = null;
      }

      if (radius) {
        if (type === 'circle') {
          attrs.r = radius;
        } else {
          attrs.rx = radius.width;
          attrs.ry = radius.height;
        }
      }

      return SvgElement.create(type, attrs, formatter);
    }

    function exportCompoundPath(item, options) {
      var attrs = getTransform(item._matrix);
      var data = item.getPathData(null, options.precision);
      if (data) attrs.d = data;
      return SvgElement.create('path', attrs, formatter);
    }

    function exportSymbolItem(item, options) {
      var attrs = getTransform(item._matrix, true),
          definition = item._definition,
          node = getDefinition(definition, 'symbol'),
          definitionItem = definition._item,
          bounds = definitionItem.getStrokeBounds();

      if (!node) {
        node = SvgElement.create('symbol', {
          viewBox: formatter.rectangle(bounds)
        });
        node.appendChild(exportSVG(definitionItem, options));
        setDefinition(definition, node, 'symbol');
      }

      attrs.href = '#' + node.id;
      attrs.x += bounds.x;
      attrs.y += bounds.y;
      attrs.width = bounds.width;
      attrs.height = bounds.height;
      attrs.overflow = 'visible';
      return SvgElement.create('use', attrs, formatter);
    }

    function exportGradient(color) {
      var gradientNode = getDefinition(color, 'color');

      if (!gradientNode) {
        var gradient = color.getGradient(),
            radial = gradient._radial,
            origin = color.getOrigin(),
            destination = color.getDestination(),
            attrs;

        if (radial) {
          attrs = {
            cx: origin.x,
            cy: origin.y,
            r: origin.getDistance(destination)
          };
          var highlight = color.getHighlight();

          if (highlight) {
            attrs.fx = highlight.x;
            attrs.fy = highlight.y;
          }
        } else {
          attrs = {
            x1: origin.x,
            y1: origin.y,
            x2: destination.x,
            y2: destination.y
          };
        }

        attrs.gradientUnits = 'userSpaceOnUse';
        gradientNode = SvgElement.create((radial ? 'radial' : 'linear') + 'Gradient', attrs, formatter);
        var stops = gradient._stops;

        for (var i = 0, l = stops.length; i < l; i++) {
          var stop = stops[i],
              stopColor = stop._color,
              alpha = stopColor.getAlpha(),
              offset = stop._offset;
          attrs = {
            offset: offset == null ? i / (l - 1) : offset
          };
          if (stopColor) attrs['stop-color'] = stopColor.toCSS(true);
          if (alpha < 1) attrs['stop-opacity'] = alpha;
          gradientNode.appendChild(SvgElement.create('stop', attrs, formatter));
        }

        setDefinition(color, gradientNode, 'color');
      }

      return 'url(#' + gradientNode.id + ')';
    }

    function exportText(item) {
      var node = SvgElement.create('text', getTransform(item._matrix, true), formatter);
      node.textContent = item._content;
      return node;
    }

    var exporters = {
      Group: exportGroup,
      Layer: exportGroup,
      Raster: exportRaster,
      Path: exportPath,
      Shape: exportShape,
      CompoundPath: exportCompoundPath,
      SymbolItem: exportSymbolItem,
      PointText: exportText
    };

    function applyStyle(item, node, isRoot) {
      var attrs = {},
          parent = !isRoot && item.getParent(),
          style = [];
      if (item._name != null) attrs.id = item._name;
      Base.each(SvgStyles, function (entry) {
        var get = entry.get,
            type = entry.type,
            value = item[get]();

        if (entry.exportFilter ? entry.exportFilter(item, value) : !parent || !Base.equals(parent[get](), value)) {
          if (type === 'color' && value != null) {
            var alpha = value.getAlpha();
            if (alpha < 1) attrs[entry.attribute + '-opacity'] = alpha;
          }

          if (type === 'style') {
            style.push(entry.attribute + ': ' + value);
          } else {
            attrs[entry.attribute] = value == null ? 'none' : type === 'color' ? value.gradient ? exportGradient(value, item) : value.toCSS(true) : type === 'array' ? value.join(',') : type === 'lookup' ? entry.toSVG[value] : value;
          }
        }
      });
      if (style.length) attrs.style = style.join(';');
      if (attrs.opacity === 1) delete attrs.opacity;
      if (!item._visible) attrs.visibility = 'hidden';
      return SvgElement.set(node, attrs, formatter);
    }

    var definitions;

    function getDefinition(item, type) {
      if (!definitions) definitions = {
        ids: {},
        svgs: {}
      };
      return item && definitions.svgs[type + '-' + (item._id || item.__id || (item.__id = UID.get('svg')))];
    }

    function setDefinition(item, node, type) {
      if (!definitions) getDefinition();
      var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
      node.id = type + '-' + typeId;
      definitions.svgs[type + '-' + (item._id || item.__id)] = node;
    }

    function exportDefinitions(node, options) {
      var svg = node,
          defs = null;

      if (definitions) {
        svg = node.nodeName.toLowerCase() === 'svg' && node;

        for (var i in definitions.svgs) {
          if (!defs) {
            if (!svg) {
              svg = SvgElement.create('svg');
              svg.appendChild(node);
            }

            defs = svg.insertBefore(SvgElement.create('defs'), svg.firstChild);
          }

          defs.appendChild(definitions.svgs[i]);
        }

        definitions = null;
      }

      return options.asString ? new self.XMLSerializer().serializeToString(svg) : svg;
    }

    function exportSVG(item, options, isRoot) {
      var exporter = exporters[item._class],
          node = exporter && exporter(item, options);

      if (node) {
        var onExport = options.onExport;
        if (onExport) node = onExport(item, node, options) || node;
        var data = JSON.stringify(item._data);
        if (data && data !== '{}' && data !== 'null') node.setAttribute('data-paper-data', data);
      }

      return node && applyStyle(item, node, isRoot);
    }

    function setOptions(options) {
      if (!options) options = {};
      formatter = new Formatter(options.precision);
      return options;
    }

    Item.inject({
      exportSVG: function (options) {
        options = setOptions(options);
        return exportDefinitions(exportSVG(this, options, true), options);
      }
    });
    Project.inject({
      exportSVG: function (options) {
        options = setOptions(options);
        var children = this._children,
            view = this.getView(),
            bounds = Base.pick(options.bounds, 'view'),
            mx = options.matrix || bounds === 'view' && view._matrix,
            matrix = mx && Matrix.read([mx]),
            rect = bounds === 'view' ? new Rectangle([0, 0], view.getViewSize()) : bounds === 'content' ? Item._getBounds(children, matrix, {
          stroke: true
        }).rect : Rectangle.read([bounds], 0, {
          readNull: true
        }),
            attrs = {
          version: '1.1',
          xmlns: SvgElement.svg,
          'xmlns:xlink': SvgElement.xlink
        };

        if (rect) {
          attrs.width = rect.width;
          attrs.height = rect.height;
          if (rect.x || rect.x === 0 || rect.y || rect.y === 0) attrs.viewBox = formatter.rectangle(rect);
        }

        var node = SvgElement.create('svg', attrs, formatter),
            parent = node;

        if (matrix && !matrix.isIdentity()) {
          parent = node.appendChild(SvgElement.create('g', getTransform(matrix), formatter));
        }

        for (var i = 0, l = children.length; i < l; i++) {
          parent.appendChild(exportSVG(children[i], options, true));
        }

        return exportDefinitions(node, options);
      }
    });
  }();
  new function () {
    var definitions = {},
        rootSize;

    function getValue(node, name, isString, allowNull, allowPercent, defaultValue) {
      var value = SvgElement.get(node, name) || defaultValue,
          res = value == null ? allowNull ? null : isString ? '' : 0 : isString ? value : parseFloat(value);
      return /%\s*$/.test(value) ? res / 100 * (allowPercent ? 1 : rootSize[/x|^width/.test(name) ? 'width' : 'height']) : res;
    }

    function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {
      x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);
      y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);
      return allowNull && (x == null || y == null) ? null : new Point(x, y);
    }

    function getSize(node, w, h, allowNull, allowPercent) {
      w = getValue(node, w || 'width', false, allowNull, allowPercent);
      h = getValue(node, h || 'height', false, allowNull, allowPercent);
      return allowNull && (w == null || h == null) ? null : new Size(w, h);
    }

    function convertValue(value, type, lookup) {
      return value === 'none' ? null : type === 'number' ? parseFloat(value) : type === 'array' ? value ? value.split(/[\s,]+/g).map(parseFloat) : [] : type === 'color' ? getDefinition(value) || value : type === 'lookup' ? lookup[value] : value;
    }

    function importGroup(node, type, options, isRoot) {
      var nodes = node.childNodes,
          isClip = type === 'clippath',
          isDefs = type === 'defs',
          item = new Group(),
          project = item._project,
          currentStyle = project._currentStyle,
          children = [];

      if (!isClip && !isDefs) {
        item = applyAttributes(item, node, isRoot);
        project._currentStyle = item._style.clone();
      }

      if (isRoot) {
        var defs = node.querySelectorAll('defs');

        for (var i = 0, l = defs.length; i < l; i++) {
          importNode(defs[i], options, false);
        }
      }

      for (var i = 0, l = nodes.length; i < l; i++) {
        var childNode = nodes[i],
            child;
        if (childNode.nodeType === 1 && !/^defs$/i.test(childNode.nodeName) && (child = importNode(childNode, options, false)) && !(child instanceof SymbolDefinition)) children.push(child);
      }

      item.addChildren(children);
      if (isClip) item = applyAttributes(item.reduce(), node, isRoot);
      project._currentStyle = currentStyle;

      if (isClip || isDefs) {
        item.remove();
        item = null;
      }

      return item;
    }

    function importPoly(node, type) {
      var coords = node.getAttribute('points').match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
          points = [];

      for (var i = 0, l = coords.length; i < l; i += 2) points.push(new Point(parseFloat(coords[i]), parseFloat(coords[i + 1])));

      var path = new Path(points);
      if (type === 'polygon') path.closePath();
      return path;
    }

    function importPath(node) {
      return PathItem.create(node.getAttribute('d'));
    }

    function importGradient(node, type) {
      var id = (getValue(node, 'href', true) || '').substring(1),
          radial = type === 'radialgradient',
          gradient;

      if (id) {
        gradient = definitions[id].getGradient();

        if (gradient._radial ^ radial) {
          gradient = gradient.clone();
          gradient._radial = radial;
        }
      } else {
        var nodes = node.childNodes,
            stops = [];

        for (var i = 0, l = nodes.length; i < l; i++) {
          var child = nodes[i];
          if (child.nodeType === 1) stops.push(applyAttributes(new GradientStop(), child));
        }

        gradient = new Gradient(stops, radial);
      }

      var origin,
          destination,
          highlight,
          scaleToBounds = getValue(node, 'gradientUnits', true) !== 'userSpaceOnUse';

      if (radial) {
        origin = getPoint(node, 'cx', 'cy', false, scaleToBounds, '50%', '50%');
        destination = origin.add(getValue(node, 'r', false, false, scaleToBounds, '50%'), 0);
        highlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);
      } else {
        origin = getPoint(node, 'x1', 'y1', false, scaleToBounds, '0%', '0%');
        destination = getPoint(node, 'x2', 'y2', false, scaleToBounds, '100%', '0%');
      }

      var color = applyAttributes(new Color(gradient, origin, destination, highlight), node);
      color._scaleToBounds = scaleToBounds;
      return null;
    }

    var importers = {
      '#document': function (node, type, options, isRoot) {
        var nodes = node.childNodes;

        for (var i = 0, l = nodes.length; i < l; i++) {
          var child = nodes[i];
          if (child.nodeType === 1) return importNode(child, options, isRoot);
        }
      },
      g: importGroup,
      svg: importGroup,
      clippath: importGroup,
      polygon: importPoly,
      polyline: importPoly,
      path: importPath,
      lineargradient: importGradient,
      radialgradient: importGradient,
      image: function (node) {
        var raster = new Raster(getValue(node, 'href', true));
        raster.on('load', function () {
          var size = getSize(node);
          this.setSize(size);
          var center = getPoint(node).add(size.divide(2));

          this._matrix.append(new Matrix().translate(center));
        });
        return raster;
      },
      symbol: function (node, type, options, isRoot) {
        return new SymbolDefinition(importGroup(node, type, options, isRoot), true);
      },
      defs: importGroup,
      use: function (node) {
        var id = (getValue(node, 'href', true) || '').substring(1),
            definition = definitions[id],
            point = getPoint(node);
        return definition ? definition instanceof SymbolDefinition ? definition.place(point) : definition.clone().translate(point) : null;
      },
      circle: function (node) {
        return new Shape.Circle(getPoint(node, 'cx', 'cy'), getValue(node, 'r'));
      },
      ellipse: function (node) {
        return new Shape.Ellipse({
          center: getPoint(node, 'cx', 'cy'),
          radius: getSize(node, 'rx', 'ry')
        });
      },
      rect: function (node) {
        return new Shape.Rectangle(new Rectangle(getPoint(node), getSize(node)), getSize(node, 'rx', 'ry'));
      },
      line: function (node) {
        return new Path.Line(getPoint(node, 'x1', 'y1'), getPoint(node, 'x2', 'y2'));
      },
      text: function (node) {
        var text = new PointText(getPoint(node).add(getPoint(node, 'dx', 'dy')));
        text.setContent(node.textContent.trim() || '');
        return text;
      },
      switch: importGroup
    };

    function applyTransform(item, value, name, node) {
      if (item.transform) {
        var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
            matrix = new Matrix();

        for (var i = 0, l = transforms.length; i < l; i++) {
          var transform = transforms[i];
          if (!transform) break;
          var parts = transform.split(/\(\s*/),
              command = parts[0],
              v = parts[1].split(/[\s,]+/g);

          for (var j = 0, m = v.length; j < m; j++) v[j] = parseFloat(v[j]);

          switch (command) {
            case 'matrix':
              matrix.append(new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
              break;

            case 'rotate':
              matrix.rotate(v[0], v[1] || 0, v[2] || 0);
              break;

            case 'translate':
              matrix.translate(v[0], v[1] || 0);
              break;

            case 'scale':
              matrix.scale(v);
              break;

            case 'skewX':
              matrix.skew(v[0], 0);
              break;

            case 'skewY':
              matrix.skew(0, v[0]);
              break;
          }
        }

        item.transform(matrix);
      }
    }

    function applyOpacity(item, value, name) {
      var key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',
          color = item[key] && item[key]();
      if (color) color.setAlpha(parseFloat(value));
    }

    var attributes = Base.set(Base.each(SvgStyles, function (entry) {
      this[entry.attribute] = function (item, value) {
        if (item[entry.set]) {
          item[entry.set](convertValue(value, entry.type, entry.fromSVG));

          if (entry.type === 'color') {
            var color = item[entry.get]();

            if (color) {
              if (color._scaleToBounds) {
                var bounds = item.getBounds();
                color.transform(new Matrix().translate(bounds.getPoint()).scale(bounds.getSize()));
              }
            }
          }
        }
      };
    }, {}), {
      id: function (item, value) {
        definitions[value] = item;
        if (item.setName) item.setName(value);
      },
      'clip-path': function (item, value) {
        var clip = getDefinition(value);

        if (clip) {
          clip = clip.clone();
          clip.setClipMask(true);

          if (item instanceof Group) {
            item.insertChild(0, clip);
          } else {
            return new Group(clip, item);
          }
        }
      },
      gradientTransform: applyTransform,
      transform: applyTransform,
      'fill-opacity': applyOpacity,
      'stroke-opacity': applyOpacity,
      visibility: function (item, value) {
        if (item.setVisible) item.setVisible(value === 'visible');
      },
      display: function (item, value) {
        if (item.setVisible) item.setVisible(value !== null);
      },
      'stop-color': function (item, value) {
        if (item.setColor) item.setColor(value);
      },
      'stop-opacity': function (item, value) {
        if (item._color) item._color.setAlpha(parseFloat(value));
      },
      offset: function (item, value) {
        if (item.setOffset) {
          var percent = value.match(/(.*)%$/);
          item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
        }
      },
      viewBox: function (item, value, name, node, styles) {
        var rect = new Rectangle(convertValue(value, 'array')),
            size = getSize(node, null, null, true),
            group,
            matrix;

        if (item instanceof Group) {
          var scale = size ? size.divide(rect.getSize()) : 1,
              matrix = new Matrix().scale(scale).translate(rect.getPoint().negate());
          group = item;
        } else if (item instanceof SymbolDefinition) {
          if (size) rect.setSize(size);
          group = item._item;
        }

        if (group) {
          if (getAttribute(node, 'overflow', styles) !== 'visible') {
            var clip = new Shape.Rectangle(rect);
            clip.setClipMask(true);
            group.addChild(clip);
          }

          if (matrix) group.transform(matrix);
        }
      }
    });

    function getAttribute(node, name, styles) {
      var attr = node.attributes[name],
          value = attr && attr.value;

      if (!value && node.style) {
        var style = Base.camelize(name);
        value = node.style[style];
        if (!value && styles.node[style] !== styles.parent[style]) value = styles.node[style];
      }

      return !value ? undefined : value === 'none' ? null : value;
    }

    function applyAttributes(item, node, isRoot) {
      var parent = node.parentNode,
          styles = {
        node: DomElement.getStyles(node) || {},
        parent: !isRoot && !/^defs$/i.test(parent.tagName) && DomElement.getStyles(parent) || {}
      };
      Base.each(attributes, function (apply, name) {
        var value = getAttribute(node, name, styles);
        item = value !== undefined && apply(item, value, name, node, styles) || item;
      });
      return item;
    }

    function getDefinition(value) {
      var match = value && value.match(/\((?:["'#]*)([^"')]+)/),
          name = match && match[1],
          res = name && definitions[window ? name.replace(window.location.href.split('#')[0] + '#', '') : name];

      if (res && res._scaleToBounds) {
        res = res.clone();
        res._scaleToBounds = true;
      }

      return res;
    }

    function importNode(node, options, isRoot) {
      var type = node.nodeName.toLowerCase(),
          isElement = type !== '#document',
          body = document.body,
          container,
          parent,
          next;

      if (isRoot && isElement) {
        rootSize = paper.getView().getSize();
        rootSize = getSize(node, null, null, true) || rootSize;
        container = SvgElement.create('svg', {
          style: 'stroke-width: 1px; stroke-miterlimit: 10'
        });
        parent = node.parentNode;
        next = node.nextSibling;
        container.appendChild(node);
        body.appendChild(container);
      }

      var settings = paper.settings,
          applyMatrix = settings.applyMatrix,
          insertItems = settings.insertItems;
      settings.applyMatrix = false;
      settings.insertItems = false;
      var importer = importers[type],
          item = importer && importer(node, type, options, isRoot) || null;
      settings.insertItems = insertItems;
      settings.applyMatrix = applyMatrix;

      if (item) {
        if (isElement && !(item instanceof Group)) item = applyAttributes(item, node, isRoot);
        var onImport = options.onImport,
            data = isElement && node.getAttribute('data-paper-data');
        if (onImport) item = onImport(node, item, options) || item;

        if (options.expandShapes && item instanceof Shape) {
          item.remove();
          item = item.toPath();
        }

        if (data) item._data = JSON.parse(data);
      }

      if (container) {
        body.removeChild(container);

        if (parent) {
          if (next) {
            parent.insertBefore(node, next);
          } else {
            parent.appendChild(node);
          }
        }
      }

      if (isRoot) {
        definitions = {};
        if (item && Base.pick(options.applyMatrix, applyMatrix)) item.matrix.apply(true, true);
      }

      return item;
    }

    function importSVG(source, options, owner) {
      if (!source) return null;
      options = typeof options === 'function' ? {
        onLoad: options
      } : options || {};
      var scope = paper,
          item = null;

      function onLoad(svg) {
        try {
          var node = typeof svg === 'object' ? svg : new self.DOMParser().parseFromString(svg.trim(), 'image/svg+xml');

          if (!node.nodeName) {
            node = null;
            throw new Error('Unsupported SVG source: ' + source);
          }

          paper = scope;
          item = importNode(node, options, true);

          if (!options || options.insert !== false) {
            owner._insertItem(undefined, item);
          }

          var onLoad = options.onLoad;
          if (onLoad) onLoad(item, svg);
        } catch (e) {
          onError(e);
        }
      }

      function onError(message, status) {
        var onError = options.onError;

        if (onError) {
          onError(message, status);
        } else {
          throw new Error(message);
        }
      }

      if (typeof source === 'string' && !/^[\s\S]*</.test(source)) {
        var node = document.getElementById(source);

        if (node) {
          onLoad(node);
        } else {
          Http.request({
            url: source,
            async: true,
            onLoad: onLoad,
            onError: onError
          });
        }
      } else if (typeof File !== 'undefined' && source instanceof File) {
        var reader = new FileReader();

        reader.onload = function () {
          onLoad(reader.result);
        };

        reader.onerror = function () {
          onError(reader.error);
        };

        return reader.readAsText(source);
      } else {
        onLoad(source);
      }

      return item;
    }

    Item.inject({
      importSVG: function (node, options) {
        return importSVG(node, options, this);
      }
    });
    Project.inject({
      importSVG: function (node, options) {
        this.activate();
        return importSVG(node, options, this);
      }
    });
  }();

  Base.exports.PaperScript = function () {
    var global = this,
        acorn = global.acorn;

    if (!acorn && "function" !== 'undefined') {
      try {
        acorn = __webpack_require__(/*! acorn */ "./node_modules/acorn/dist/acorn.mjs");
      } catch (e) {}
    }

    if (!acorn) {
      var exports, module;
      acorn = exports = module = {};

      (function (root, mod) {
        if (typeof exports == "object" && typeof module == "object") return mod(exports);
        if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        mod(root.acorn || (root.acorn = {}));
      })(this, function (exports) {
        "use strict";

        exports.version = "0.5.0";
        var options, input, inputLen, sourceFile;

        exports.parse = function (inpt, opts) {
          input = String(inpt);
          inputLen = input.length;
          setOptions(opts);
          initTokenState();
          return parseTopLevel(options.program);
        };

        var defaultOptions = exports.defaultOptions = {
          ecmaVersion: 5,
          strictSemicolons: false,
          allowTrailingCommas: true,
          forbidReserved: false,
          allowReturnOutsideFunction: false,
          locations: false,
          onComment: null,
          ranges: false,
          program: null,
          sourceFile: null,
          directSourceFile: null
        };

        function setOptions(opts) {
          options = opts || {};

          for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt)) options[opt] = defaultOptions[opt];

          sourceFile = options.sourceFile || null;
        }

        var getLineInfo = exports.getLineInfo = function (input, offset) {
          for (var line = 1, cur = 0;;) {
            lineBreak.lastIndex = cur;
            var match = lineBreak.exec(input);

            if (match && match.index < offset) {
              ++line;
              cur = match.index + match[0].length;
            } else break;
          }

          return {
            line: line,
            column: offset - cur
          };
        };

        exports.tokenize = function (inpt, opts) {
          input = String(inpt);
          inputLen = input.length;
          setOptions(opts);
          initTokenState();
          var t = {};

          function getToken(forceRegexp) {
            lastEnd = tokEnd;
            readToken(forceRegexp);
            t.start = tokStart;
            t.end = tokEnd;
            t.startLoc = tokStartLoc;
            t.endLoc = tokEndLoc;
            t.type = tokType;
            t.value = tokVal;
            return t;
          }

          getToken.jumpTo = function (pos, reAllowed) {
            tokPos = pos;

            if (options.locations) {
              tokCurLine = 1;
              tokLineStart = lineBreak.lastIndex = 0;
              var match;

              while ((match = lineBreak.exec(input)) && match.index < pos) {
                ++tokCurLine;
                tokLineStart = match.index + match[0].length;
              }
            }

            tokRegexpAllowed = reAllowed;
            skipSpace();
          };

          return getToken;
        };

        var tokPos;
        var tokStart, tokEnd;
        var tokStartLoc, tokEndLoc;
        var tokType, tokVal;
        var tokRegexpAllowed;
        var tokCurLine, tokLineStart;
        var lastStart, lastEnd, lastEndLoc;
        var inFunction, labels, strict;

        function raise(pos, message) {
          var loc = getLineInfo(input, pos);
          message += " (" + loc.line + ":" + loc.column + ")";
          var err = new SyntaxError(message);
          err.pos = pos;
          err.loc = loc;
          err.raisedAt = tokPos;
          throw err;
        }

        var empty = [];
        var _num = {
          type: "num"
        },
            _regexp = {
          type: "regexp"
        },
            _string = {
          type: "string"
        };
        var _name = {
          type: "name"
        },
            _eof = {
          type: "eof"
        };
        var _break = {
          keyword: "break"
        },
            _case = {
          keyword: "case",
          beforeExpr: true
        },
            _catch = {
          keyword: "catch"
        };
        var _continue = {
          keyword: "continue"
        },
            _debugger = {
          keyword: "debugger"
        },
            _default = {
          keyword: "default"
        };
        var _do = {
          keyword: "do",
          isLoop: true
        },
            _else = {
          keyword: "else",
          beforeExpr: true
        };
        var _finally = {
          keyword: "finally"
        },
            _for = {
          keyword: "for",
          isLoop: true
        },
            _function = {
          keyword: "function"
        };
        var _if = {
          keyword: "if"
        },
            _return = {
          keyword: "return",
          beforeExpr: true
        },
            _switch = {
          keyword: "switch"
        };
        var _throw = {
          keyword: "throw",
          beforeExpr: true
        },
            _try = {
          keyword: "try"
        },
            _var = {
          keyword: "var"
        };
        var _while = {
          keyword: "while",
          isLoop: true
        },
            _with = {
          keyword: "with"
        },
            _new = {
          keyword: "new",
          beforeExpr: true
        };
        var _this = {
          keyword: "this"
        };
        var _null = {
          keyword: "null",
          atomValue: null
        },
            _true = {
          keyword: "true",
          atomValue: true
        };
        var _false = {
          keyword: "false",
          atomValue: false
        };
        var _in = {
          keyword: "in",
          binop: 7,
          beforeExpr: true
        };
        var keywordTypes = {
          "break": _break,
          "case": _case,
          "catch": _catch,
          "continue": _continue,
          "debugger": _debugger,
          "default": _default,
          "do": _do,
          "else": _else,
          "finally": _finally,
          "for": _for,
          "function": _function,
          "if": _if,
          "return": _return,
          "switch": _switch,
          "throw": _throw,
          "try": _try,
          "var": _var,
          "while": _while,
          "with": _with,
          "null": _null,
          "true": _true,
          "false": _false,
          "new": _new,
          "in": _in,
          "instanceof": {
            keyword: "instanceof",
            binop: 7,
            beforeExpr: true
          },
          "this": _this,
          "typeof": {
            keyword: "typeof",
            prefix: true,
            beforeExpr: true
          },
          "void": {
            keyword: "void",
            prefix: true,
            beforeExpr: true
          },
          "delete": {
            keyword: "delete",
            prefix: true,
            beforeExpr: true
          }
        };
        var _bracketL = {
          type: "[",
          beforeExpr: true
        },
            _bracketR = {
          type: "]"
        },
            _braceL = {
          type: "{",
          beforeExpr: true
        };
        var _braceR = {
          type: "}"
        },
            _parenL = {
          type: "(",
          beforeExpr: true
        },
            _parenR = {
          type: ")"
        };
        var _comma = {
          type: ",",
          beforeExpr: true
        },
            _semi = {
          type: ";",
          beforeExpr: true
        };
        var _colon = {
          type: ":",
          beforeExpr: true
        },
            _dot = {
          type: "."
        },
            _question = {
          type: "?",
          beforeExpr: true
        };
        var _slash = {
          binop: 10,
          beforeExpr: true
        },
            _eq = {
          isAssign: true,
          beforeExpr: true
        };
        var _assign = {
          isAssign: true,
          beforeExpr: true
        };
        var _incDec = {
          postfix: true,
          prefix: true,
          isUpdate: true
        },
            _prefix = {
          prefix: true,
          beforeExpr: true
        };
        var _logicalOR = {
          binop: 1,
          beforeExpr: true
        };
        var _logicalAND = {
          binop: 2,
          beforeExpr: true
        };
        var _bitwiseOR = {
          binop: 3,
          beforeExpr: true
        };
        var _bitwiseXOR = {
          binop: 4,
          beforeExpr: true
        };
        var _bitwiseAND = {
          binop: 5,
          beforeExpr: true
        };
        var _equality = {
          binop: 6,
          beforeExpr: true
        };
        var _relational = {
          binop: 7,
          beforeExpr: true
        };
        var _bitShift = {
          binop: 8,
          beforeExpr: true
        };
        var _plusMin = {
          binop: 9,
          prefix: true,
          beforeExpr: true
        };
        var _multiplyModulo = {
          binop: 10,
          beforeExpr: true
        };
        exports.tokTypes = {
          bracketL: _bracketL,
          bracketR: _bracketR,
          braceL: _braceL,
          braceR: _braceR,
          parenL: _parenL,
          parenR: _parenR,
          comma: _comma,
          semi: _semi,
          colon: _colon,
          dot: _dot,
          question: _question,
          slash: _slash,
          eq: _eq,
          name: _name,
          eof: _eof,
          num: _num,
          regexp: _regexp,
          string: _string
        };

        for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

        function makePredicate(words) {
          words = words.split(" ");
          var f = "",
              cats = [];

          out: for (var i = 0; i < words.length; ++i) {
            for (var j = 0; j < cats.length; ++j) if (cats[j][0].length == words[i].length) {
              cats[j].push(words[i]);
              continue out;
            }

            cats.push([words[i]]);
          }

          function compareTo(arr) {
            if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
            f += "switch(str){";

            for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";

            f += "return true}return false;";
          }

          if (cats.length > 3) {
            cats.sort(function (a, b) {
              return b.length - a.length;
            });
            f += "switch(str.length){";

            for (var i = 0; i < cats.length; ++i) {
              var cat = cats[i];
              f += "case " + cat[0].length + ":";
              compareTo(cat);
            }

            f += "}";
          } else {
            compareTo(words);
          }

          return new Function("str", f);
        }

        var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");
        var isReservedWord5 = makePredicate("class enum extends super const export import");
        var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");
        var isStrictBadIdWord = makePredicate("eval arguments");
        var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");
        var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
        var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
        var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        var newline = /[\n\r\u2028\u2029]/;
        var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

        var isIdentifierStart = exports.isIdentifierStart = function (code) {
          if (code < 65) return code === 36;
          if (code < 91) return true;
          if (code < 97) return code === 95;
          if (code < 123) return true;
          return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
        };

        var isIdentifierChar = exports.isIdentifierChar = function (code) {
          if (code < 48) return code === 36;
          if (code < 58) return true;
          if (code < 65) return false;
          if (code < 91) return true;
          if (code < 97) return code === 95;
          if (code < 123) return true;
          return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
        };

        function line_loc_t() {
          this.line = tokCurLine;
          this.column = tokPos - tokLineStart;
        }

        function initTokenState() {
          tokCurLine = 1;
          tokPos = tokLineStart = 0;
          tokRegexpAllowed = true;
          skipSpace();
        }

        function finishToken(type, val) {
          tokEnd = tokPos;
          if (options.locations) tokEndLoc = new line_loc_t();
          tokType = type;
          skipSpace();
          tokVal = val;
          tokRegexpAllowed = type.beforeExpr;
        }

        function skipBlockComment() {
          var startLoc = options.onComment && options.locations && new line_loc_t();
          var start = tokPos,
              end = input.indexOf("*/", tokPos += 2);
          if (end === -1) raise(tokPos - 2, "Unterminated comment");
          tokPos = end + 2;

          if (options.locations) {
            lineBreak.lastIndex = start;
            var match;

            while ((match = lineBreak.exec(input)) && match.index < tokPos) {
              ++tokCurLine;
              tokLineStart = match.index + match[0].length;
            }
          }

          if (options.onComment) options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new line_loc_t());
        }

        function skipLineComment() {
          var start = tokPos;
          var startLoc = options.onComment && options.locations && new line_loc_t();
          var ch = input.charCodeAt(tokPos += 2);

          while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
            ++tokPos;
            ch = input.charCodeAt(tokPos);
          }

          if (options.onComment) options.onComment(false, input.slice(start + 2, tokPos), start, tokPos, startLoc, options.locations && new line_loc_t());
        }

        function skipSpace() {
          while (tokPos < inputLen) {
            var ch = input.charCodeAt(tokPos);

            if (ch === 32) {
              ++tokPos;
            } else if (ch === 13) {
              ++tokPos;
              var next = input.charCodeAt(tokPos);

              if (next === 10) {
                ++tokPos;
              }

              if (options.locations) {
                ++tokCurLine;
                tokLineStart = tokPos;
              }
            } else if (ch === 10 || ch === 8232 || ch === 8233) {
              ++tokPos;

              if (options.locations) {
                ++tokCurLine;
                tokLineStart = tokPos;
              }
            } else if (ch > 8 && ch < 14) {
              ++tokPos;
            } else if (ch === 47) {
              var next = input.charCodeAt(tokPos + 1);

              if (next === 42) {
                skipBlockComment();
              } else if (next === 47) {
                skipLineComment();
              } else break;
            } else if (ch === 160) {
              ++tokPos;
            } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
              ++tokPos;
            } else {
              break;
            }
          }
        }

        function readToken_dot() {
          var next = input.charCodeAt(tokPos + 1);
          if (next >= 48 && next <= 57) return readNumber(true);
          ++tokPos;
          return finishToken(_dot);
        }

        function readToken_slash() {
          var next = input.charCodeAt(tokPos + 1);

          if (tokRegexpAllowed) {
            ++tokPos;
            return readRegexp();
          }

          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_slash, 1);
        }

        function readToken_mult_modulo() {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_multiplyModulo, 1);
        }

        function readToken_pipe_amp(code) {
          var next = input.charCodeAt(tokPos + 1);
          if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
        }

        function readToken_caret() {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_bitwiseXOR, 1);
        }

        function readToken_plus_min(code) {
          var next = input.charCodeAt(tokPos + 1);

          if (next === code) {
            if (next == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd, tokPos))) {
              tokPos += 3;
              skipLineComment();
              skipSpace();
              return readToken();
            }

            return finishOp(_incDec, 2);
          }

          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_plusMin, 1);
        }

        function readToken_lt_gt(code) {
          var next = input.charCodeAt(tokPos + 1);
          var size = 1;

          if (next === code) {
            size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
            if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
            return finishOp(_bitShift, size);
          }

          if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45) {
            tokPos += 4;
            skipLineComment();
            skipSpace();
            return readToken();
          }

          if (next === 61) size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
          return finishOp(_relational, size);
        }

        function readToken_eq_excl(code) {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
          return finishOp(code === 61 ? _eq : _prefix, 1);
        }

        function getTokenFromCode(code) {
          switch (code) {
            case 46:
              return readToken_dot();

            case 40:
              ++tokPos;
              return finishToken(_parenL);

            case 41:
              ++tokPos;
              return finishToken(_parenR);

            case 59:
              ++tokPos;
              return finishToken(_semi);

            case 44:
              ++tokPos;
              return finishToken(_comma);

            case 91:
              ++tokPos;
              return finishToken(_bracketL);

            case 93:
              ++tokPos;
              return finishToken(_bracketR);

            case 123:
              ++tokPos;
              return finishToken(_braceL);

            case 125:
              ++tokPos;
              return finishToken(_braceR);

            case 58:
              ++tokPos;
              return finishToken(_colon);

            case 63:
              ++tokPos;
              return finishToken(_question);

            case 48:
              var next = input.charCodeAt(tokPos + 1);
              if (next === 120 || next === 88) return readHexNumber();

            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return readNumber(false);

            case 34:
            case 39:
              return readString(code);

            case 47:
              return readToken_slash(code);

            case 37:
            case 42:
              return readToken_mult_modulo();

            case 124:
            case 38:
              return readToken_pipe_amp(code);

            case 94:
              return readToken_caret();

            case 43:
            case 45:
              return readToken_plus_min(code);

            case 60:
            case 62:
              return readToken_lt_gt(code);

            case 61:
            case 33:
              return readToken_eq_excl(code);

            case 126:
              return finishOp(_prefix, 1);
          }

          return false;
        }

        function readToken(forceRegexp) {
          if (!forceRegexp) tokStart = tokPos;else tokPos = tokStart + 1;
          if (options.locations) tokStartLoc = new line_loc_t();
          if (forceRegexp) return readRegexp();
          if (tokPos >= inputLen) return finishToken(_eof);
          var code = input.charCodeAt(tokPos);
          if (isIdentifierStart(code) || code === 92) return readWord();
          var tok = getTokenFromCode(code);

          if (tok === false) {
            var ch = String.fromCharCode(code);
            if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
            raise(tokPos, "Unexpected character '" + ch + "'");
          }

          return tok;
        }

        function finishOp(type, size) {
          var str = input.slice(tokPos, tokPos + size);
          tokPos += size;
          finishToken(type, str);
        }

        function readRegexp() {
          var content = "",
              escaped,
              inClass,
              start = tokPos;

          for (;;) {
            if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
            var ch = input.charAt(tokPos);
            if (newline.test(ch)) raise(start, "Unterminated regular expression");

            if (!escaped) {
              if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
              escaped = ch === "\\";
            } else escaped = false;

            ++tokPos;
          }

          var content = input.slice(start, tokPos);
          ++tokPos;
          var mods = readWord1();
          if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");

          try {
            var value = new RegExp(content, mods);
          } catch (e) {
            if (e instanceof SyntaxError) raise(start, e.message);
            raise(e);
          }

          return finishToken(_regexp, value);
        }

        function readInt(radix, len) {
          var start = tokPos,
              total = 0;

          for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
            var code = input.charCodeAt(tokPos),
                val;
            if (code >= 97) val = code - 97 + 10;else if (code >= 65) val = code - 65 + 10;else if (code >= 48 && code <= 57) val = code - 48;else val = Infinity;
            if (val >= radix) break;
            ++tokPos;
            total = total * radix + val;
          }

          if (tokPos === start || len != null && tokPos - start !== len) return null;
          return total;
        }

        function readHexNumber() {
          tokPos += 2;
          var val = readInt(16);
          if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
          if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
          return finishToken(_num, val);
        }

        function readNumber(startsWithDot) {
          var start = tokPos,
              isFloat = false,
              octal = input.charCodeAt(tokPos) === 48;
          if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");

          if (input.charCodeAt(tokPos) === 46) {
            ++tokPos;
            readInt(10);
            isFloat = true;
          }

          var next = input.charCodeAt(tokPos);

          if (next === 69 || next === 101) {
            next = input.charCodeAt(++tokPos);
            if (next === 43 || next === 45) ++tokPos;
            if (readInt(10) === null) raise(start, "Invalid number");
            isFloat = true;
          }

          if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
          var str = input.slice(start, tokPos),
              val;
          if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || strict) raise(start, "Invalid number");else val = parseInt(str, 8);
          return finishToken(_num, val);
        }

        function readString(quote) {
          tokPos++;
          var out = "";

          for (;;) {
            if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
            var ch = input.charCodeAt(tokPos);

            if (ch === quote) {
              ++tokPos;
              return finishToken(_string, out);
            }

            if (ch === 92) {
              ch = input.charCodeAt(++tokPos);
              var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
              if (octal) octal = octal[0];

              while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);

              if (octal === "0") octal = null;
              ++tokPos;

              if (octal) {
                if (strict) raise(tokPos - 2, "Octal literal in strict mode");
                out += String.fromCharCode(parseInt(octal, 8));
                tokPos += octal.length - 1;
              } else {
                switch (ch) {
                  case 110:
                    out += "\n";
                    break;

                  case 114:
                    out += "\r";
                    break;

                  case 120:
                    out += String.fromCharCode(readHexChar(2));
                    break;

                  case 117:
                    out += String.fromCharCode(readHexChar(4));
                    break;

                  case 85:
                    out += String.fromCharCode(readHexChar(8));
                    break;

                  case 116:
                    out += "\t";
                    break;

                  case 98:
                    out += "\b";
                    break;

                  case 118:
                    out += "\u000b";
                    break;

                  case 102:
                    out += "\f";
                    break;

                  case 48:
                    out += "\0";
                    break;

                  case 13:
                    if (input.charCodeAt(tokPos) === 10) ++tokPos;

                  case 10:
                    if (options.locations) {
                      tokLineStart = tokPos;
                      ++tokCurLine;
                    }

                    break;

                  default:
                    out += String.fromCharCode(ch);
                    break;
                }
              }
            } else {
              if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, "Unterminated string constant");
              out += String.fromCharCode(ch);
              ++tokPos;
            }
          }
        }

        function readHexChar(len) {
          var n = readInt(16, len);
          if (n === null) raise(tokStart, "Bad character escape sequence");
          return n;
        }

        var containsEsc;

        function readWord1() {
          containsEsc = false;
          var word,
              first = true,
              start = tokPos;

          for (;;) {
            var ch = input.charCodeAt(tokPos);

            if (isIdentifierChar(ch)) {
              if (containsEsc) word += input.charAt(tokPos);
              ++tokPos;
            } else if (ch === 92) {
              if (!containsEsc) word = input.slice(start, tokPos);
              containsEsc = true;
              if (input.charCodeAt(++tokPos) != 117) raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
              ++tokPos;
              var esc = readHexChar(4);
              var escStr = String.fromCharCode(esc);
              if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
              if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) raise(tokPos - 4, "Invalid Unicode escape");
              word += escStr;
            } else {
              break;
            }

            first = false;
          }

          return containsEsc ? word : input.slice(start, tokPos);
        }

        function readWord() {
          var word = readWord1();
          var type = _name;
          if (!containsEsc && isKeyword(word)) type = keywordTypes[word];
          return finishToken(type, word);
        }

        function next() {
          lastStart = tokStart;
          lastEnd = tokEnd;
          lastEndLoc = tokEndLoc;
          readToken();
        }

        function setStrict(strct) {
          strict = strct;
          tokPos = tokStart;

          if (options.locations) {
            while (tokPos < tokLineStart) {
              tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
              --tokCurLine;
            }
          }

          skipSpace();
          readToken();
        }

        function node_t() {
          this.type = null;
          this.start = tokStart;
          this.end = null;
        }

        function node_loc_t() {
          this.start = tokStartLoc;
          this.end = null;
          if (sourceFile !== null) this.source = sourceFile;
        }

        function startNode() {
          var node = new node_t();
          if (options.locations) node.loc = new node_loc_t();
          if (options.directSourceFile) node.sourceFile = options.directSourceFile;
          if (options.ranges) node.range = [tokStart, 0];
          return node;
        }

        function startNodeFrom(other) {
          var node = new node_t();
          node.start = other.start;

          if (options.locations) {
            node.loc = new node_loc_t();
            node.loc.start = other.loc.start;
          }

          if (options.ranges) node.range = [other.range[0], 0];
          return node;
        }

        function finishNode(node, type) {
          node.type = type;
          node.end = lastEnd;
          if (options.locations) node.loc.end = lastEndLoc;
          if (options.ranges) node.range[1] = lastEnd;
          return node;
        }

        function isUseStrict(stmt) {
          return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
        }

        function eat(type) {
          if (tokType === type) {
            next();
            return true;
          }
        }

        function canInsertSemicolon() {
          return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
        }

        function semicolon() {
          if (!eat(_semi) && !canInsertSemicolon()) unexpected();
        }

        function expect(type) {
          if (tokType === type) next();else unexpected();
        }

        function unexpected() {
          raise(tokStart, "Unexpected token");
        }

        function checkLVal(expr) {
          if (expr.type !== "Identifier" && expr.type !== "MemberExpression") raise(expr.start, "Assigning to rvalue");
          if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name)) raise(expr.start, "Assigning to " + expr.name + " in strict mode");
        }

        function parseTopLevel(program) {
          lastStart = lastEnd = tokPos;
          if (options.locations) lastEndLoc = new line_loc_t();
          inFunction = strict = null;
          labels = [];
          readToken();
          var node = program || startNode(),
              first = true;
          if (!program) node.body = [];

          while (tokType !== _eof) {
            var stmt = parseStatement();
            node.body.push(stmt);
            if (first && isUseStrict(stmt)) setStrict(true);
            first = false;
          }

          return finishNode(node, "Program");
        }

        var loopLabel = {
          kind: "loop"
        },
            switchLabel = {
          kind: "switch"
        };

        function parseStatement() {
          if (tokType === _slash || tokType === _assign && tokVal == "/=") readToken(true);
          var starttype = tokType,
              node = startNode();

          switch (starttype) {
            case _break:
            case _continue:
              next();
              var isBreak = starttype === _break;
              if (eat(_semi) || canInsertSemicolon()) node.label = null;else if (tokType !== _name) unexpected();else {
                node.label = parseIdent();
                semicolon();
              }

              for (var i = 0; i < labels.length; ++i) {
                var lab = labels[i];

                if (node.label == null || lab.name === node.label.name) {
                  if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
                  if (node.label && isBreak) break;
                }
              }

              if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
              return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

            case _debugger:
              next();
              semicolon();
              return finishNode(node, "DebuggerStatement");

            case _do:
              next();
              labels.push(loopLabel);
              node.body = parseStatement();
              labels.pop();
              expect(_while);
              node.test = parseParenExpression();
              semicolon();
              return finishNode(node, "DoWhileStatement");

            case _for:
              next();
              labels.push(loopLabel);
              expect(_parenL);
              if (tokType === _semi) return parseFor(node, null);

              if (tokType === _var) {
                var init = startNode();
                next();
                parseVar(init, true);
                finishNode(init, "VariableDeclaration");
                if (init.declarations.length === 1 && eat(_in)) return parseForIn(node, init);
                return parseFor(node, init);
              }

              var init = parseExpression(false, true);

              if (eat(_in)) {
                checkLVal(init);
                return parseForIn(node, init);
              }

              return parseFor(node, init);

            case _function:
              next();
              return parseFunction(node, true);

            case _if:
              next();
              node.test = parseParenExpression();
              node.consequent = parseStatement();
              node.alternate = eat(_else) ? parseStatement() : null;
              return finishNode(node, "IfStatement");

            case _return:
              if (!inFunction && !options.allowReturnOutsideFunction) raise(tokStart, "'return' outside of function");
              next();
              if (eat(_semi) || canInsertSemicolon()) node.argument = null;else {
                node.argument = parseExpression();
                semicolon();
              }
              return finishNode(node, "ReturnStatement");

            case _switch:
              next();
              node.discriminant = parseParenExpression();
              node.cases = [];
              expect(_braceL);
              labels.push(switchLabel);

              for (var cur, sawDefault; tokType != _braceR;) {
                if (tokType === _case || tokType === _default) {
                  var isCase = tokType === _case;
                  if (cur) finishNode(cur, "SwitchCase");
                  node.cases.push(cur = startNode());
                  cur.consequent = [];
                  next();
                  if (isCase) cur.test = parseExpression();else {
                    if (sawDefault) raise(lastStart, "Multiple default clauses");
                    sawDefault = true;
                    cur.test = null;
                  }
                  expect(_colon);
                } else {
                  if (!cur) unexpected();
                  cur.consequent.push(parseStatement());
                }
              }

              if (cur) finishNode(cur, "SwitchCase");
              next();
              labels.pop();
              return finishNode(node, "SwitchStatement");

            case _throw:
              next();
              if (newline.test(input.slice(lastEnd, tokStart))) raise(lastEnd, "Illegal newline after throw");
              node.argument = parseExpression();
              semicolon();
              return finishNode(node, "ThrowStatement");

            case _try:
              next();
              node.block = parseBlock();
              node.handler = null;

              if (tokType === _catch) {
                var clause = startNode();
                next();
                expect(_parenL);
                clause.param = parseIdent();
                if (strict && isStrictBadIdWord(clause.param.name)) raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
                expect(_parenR);
                clause.guard = null;
                clause.body = parseBlock();
                node.handler = finishNode(clause, "CatchClause");
              }

              node.guardedHandlers = empty;
              node.finalizer = eat(_finally) ? parseBlock() : null;
              if (!node.handler && !node.finalizer) raise(node.start, "Missing catch or finally clause");
              return finishNode(node, "TryStatement");

            case _var:
              next();
              parseVar(node);
              semicolon();
              return finishNode(node, "VariableDeclaration");

            case _while:
              next();
              node.test = parseParenExpression();
              labels.push(loopLabel);
              node.body = parseStatement();
              labels.pop();
              return finishNode(node, "WhileStatement");

            case _with:
              if (strict) raise(tokStart, "'with' in strict mode");
              next();
              node.object = parseParenExpression();
              node.body = parseStatement();
              return finishNode(node, "WithStatement");

            case _braceL:
              return parseBlock();

            case _semi:
              next();
              return finishNode(node, "EmptyStatement");

            default:
              var maybeName = tokVal,
                  expr = parseExpression();

              if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
                for (var i = 0; i < labels.length; ++i) if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");

                var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
                labels.push({
                  name: maybeName,
                  kind: kind
                });
                node.body = parseStatement();
                labels.pop();
                node.label = expr;
                return finishNode(node, "LabeledStatement");
              } else {
                node.expression = expr;
                semicolon();
                return finishNode(node, "ExpressionStatement");
              }

          }
        }

        function parseParenExpression() {
          expect(_parenL);
          var val = parseExpression();
          expect(_parenR);
          return val;
        }

        function parseBlock(allowStrict) {
          var node = startNode(),
              first = true,
              strict = false,
              oldStrict;
          node.body = [];
          expect(_braceL);

          while (!eat(_braceR)) {
            var stmt = parseStatement();
            node.body.push(stmt);

            if (first && allowStrict && isUseStrict(stmt)) {
              oldStrict = strict;
              setStrict(strict = true);
            }

            first = false;
          }

          if (strict && !oldStrict) setStrict(false);
          return finishNode(node, "BlockStatement");
        }

        function parseFor(node, init) {
          node.init = init;
          expect(_semi);
          node.test = tokType === _semi ? null : parseExpression();
          expect(_semi);
          node.update = tokType === _parenR ? null : parseExpression();
          expect(_parenR);
          node.body = parseStatement();
          labels.pop();
          return finishNode(node, "ForStatement");
        }

        function parseForIn(node, init) {
          node.left = init;
          node.right = parseExpression();
          expect(_parenR);
          node.body = parseStatement();
          labels.pop();
          return finishNode(node, "ForInStatement");
        }

        function parseVar(node, noIn) {
          node.declarations = [];
          node.kind = "var";

          for (;;) {
            var decl = startNode();
            decl.id = parseIdent();
            if (strict && isStrictBadIdWord(decl.id.name)) raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
            decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
            node.declarations.push(finishNode(decl, "VariableDeclarator"));
            if (!eat(_comma)) break;
          }

          return node;
        }

        function parseExpression(noComma, noIn) {
          var expr = parseMaybeAssign(noIn);

          if (!noComma && tokType === _comma) {
            var node = startNodeFrom(expr);
            node.expressions = [expr];

            while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));

            return finishNode(node, "SequenceExpression");
          }

          return expr;
        }

        function parseMaybeAssign(noIn) {
          var left = parseMaybeConditional(noIn);

          if (tokType.isAssign) {
            var node = startNodeFrom(left);
            node.operator = tokVal;
            node.left = left;
            next();
            node.right = parseMaybeAssign(noIn);
            checkLVal(left);
            return finishNode(node, "AssignmentExpression");
          }

          return left;
        }

        function parseMaybeConditional(noIn) {
          var expr = parseExprOps(noIn);

          if (eat(_question)) {
            var node = startNodeFrom(expr);
            node.test = expr;
            node.consequent = parseExpression(true);
            expect(_colon);
            node.alternate = parseExpression(true, noIn);
            return finishNode(node, "ConditionalExpression");
          }

          return expr;
        }

        function parseExprOps(noIn) {
          return parseExprOp(parseMaybeUnary(), -1, noIn);
        }

        function parseExprOp(left, minPrec, noIn) {
          var prec = tokType.binop;

          if (prec != null && (!noIn || tokType !== _in)) {
            if (prec > minPrec) {
              var node = startNodeFrom(left);
              node.left = left;
              node.operator = tokVal;
              var op = tokType;
              next();
              node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
              var exprNode = finishNode(node, op === _logicalOR || op === _logicalAND ? "LogicalExpression" : "BinaryExpression");
              return parseExprOp(exprNode, minPrec, noIn);
            }
          }

          return left;
        }

        function parseMaybeUnary() {
          if (tokType.prefix) {
            var node = startNode(),
                update = tokType.isUpdate;
            node.operator = tokVal;
            node.prefix = true;
            tokRegexpAllowed = true;
            next();
            node.argument = parseMaybeUnary();
            if (update) checkLVal(node.argument);else if (strict && node.operator === "delete" && node.argument.type === "Identifier") raise(node.start, "Deleting local variable in strict mode");
            return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
          }

          var expr = parseExprSubscripts();

          while (tokType.postfix && !canInsertSemicolon()) {
            var node = startNodeFrom(expr);
            node.operator = tokVal;
            node.prefix = false;
            node.argument = expr;
            checkLVal(expr);
            next();
            expr = finishNode(node, "UpdateExpression");
          }

          return expr;
        }

        function parseExprSubscripts() {
          return parseSubscripts(parseExprAtom());
        }

        function parseSubscripts(base, noCalls) {
          if (eat(_dot)) {
            var node = startNodeFrom(base);
            node.object = base;
            node.property = parseIdent(true);
            node.computed = false;
            return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
          } else if (eat(_bracketL)) {
            var node = startNodeFrom(base);
            node.object = base;
            node.property = parseExpression();
            node.computed = true;
            expect(_bracketR);
            return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
          } else if (!noCalls && eat(_parenL)) {
            var node = startNodeFrom(base);
            node.callee = base;
            node.arguments = parseExprList(_parenR, false);
            return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
          } else return base;
        }

        function parseExprAtom() {
          switch (tokType) {
            case _this:
              var node = startNode();
              next();
              return finishNode(node, "ThisExpression");

            case _name:
              return parseIdent();

            case _num:
            case _string:
            case _regexp:
              var node = startNode();
              node.value = tokVal;
              node.raw = input.slice(tokStart, tokEnd);
              next();
              return finishNode(node, "Literal");

            case _null:
            case _true:
            case _false:
              var node = startNode();
              node.value = tokType.atomValue;
              node.raw = tokType.keyword;
              next();
              return finishNode(node, "Literal");

            case _parenL:
              var tokStartLoc1 = tokStartLoc,
                  tokStart1 = tokStart;
              next();
              var val = parseExpression();
              val.start = tokStart1;
              val.end = tokEnd;

              if (options.locations) {
                val.loc.start = tokStartLoc1;
                val.loc.end = tokEndLoc;
              }

              if (options.ranges) val.range = [tokStart1, tokEnd];
              expect(_parenR);
              return val;

            case _bracketL:
              var node = startNode();
              next();
              node.elements = parseExprList(_bracketR, true, true);
              return finishNode(node, "ArrayExpression");

            case _braceL:
              return parseObj();

            case _function:
              var node = startNode();
              next();
              return parseFunction(node, false);

            case _new:
              return parseNew();

            default:
              unexpected();
          }
        }

        function parseNew() {
          var node = startNode();
          next();
          node.callee = parseSubscripts(parseExprAtom(), true);
          if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);else node.arguments = empty;
          return finishNode(node, "NewExpression");
        }

        function parseObj() {
          var node = startNode(),
              first = true,
              sawGetSet = false;
          node.properties = [];
          next();

          while (!eat(_braceR)) {
            if (!first) {
              expect(_comma);
              if (options.allowTrailingCommas && eat(_braceR)) break;
            } else first = false;

            var prop = {
              key: parsePropertyName()
            },
                isGetSet = false,
                kind;

            if (eat(_colon)) {
              prop.value = parseExpression(true);
              kind = prop.kind = "init";
            } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set")) {
              isGetSet = sawGetSet = true;
              kind = prop.kind = prop.key.name;
              prop.key = parsePropertyName();
              if (tokType !== _parenL) unexpected();
              prop.value = parseFunction(startNode(), false);
            } else unexpected();

            if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
              for (var i = 0; i < node.properties.length; ++i) {
                var other = node.properties[i];

                if (other.key.name === prop.key.name) {
                  var conflict = kind == other.kind || isGetSet && other.kind === "init" || kind === "init" && (other.kind === "get" || other.kind === "set");
                  if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
                  if (conflict) raise(prop.key.start, "Redefinition of property");
                }
              }
            }

            node.properties.push(prop);
          }

          return finishNode(node, "ObjectExpression");
        }

        function parsePropertyName() {
          if (tokType === _num || tokType === _string) return parseExprAtom();
          return parseIdent(true);
        }

        function parseFunction(node, isStatement) {
          if (tokType === _name) node.id = parseIdent();else if (isStatement) unexpected();else node.id = null;
          node.params = [];
          var first = true;
          expect(_parenL);

          while (!eat(_parenR)) {
            if (!first) expect(_comma);else first = false;
            node.params.push(parseIdent());
          }

          var oldInFunc = inFunction,
              oldLabels = labels;
          inFunction = true;
          labels = [];
          node.body = parseBlock(true);
          inFunction = oldInFunc;
          labels = oldLabels;

          if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
            for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
              var id = i < 0 ? node.id : node.params[i];
              if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name)) raise(id.start, "Defining '" + id.name + "' in strict mode");
              if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name) raise(id.start, "Argument name clash in strict mode");
            }
          }

          return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
        }

        function parseExprList(close, allowTrailingComma, allowEmpty) {
          var elts = [],
              first = true;

          while (!eat(close)) {
            if (!first) {
              expect(_comma);
              if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
            } else first = false;

            if (allowEmpty && tokType === _comma) elts.push(null);else elts.push(parseExpression(true));
          }

          return elts;
        }

        function parseIdent(liberal) {
          var node = startNode();
          if (liberal && options.forbidReserved == "everywhere") liberal = false;

          if (tokType === _name) {
            if (!liberal && (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) || strict && isStrictReservedWord(tokVal)) && input.slice(tokStart, tokEnd).indexOf("\\") == -1) raise(tokStart, "The keyword '" + tokVal + "' is reserved");
            node.name = tokVal;
          } else if (liberal && tokType.keyword) {
            node.name = tokType.keyword;
          } else {
            unexpected();
          }

          tokRegexpAllowed = false;
          next();
          return finishNode(node, "Identifier");
        }
      });

      if (!acorn.version) acorn = null;
    }

    function parse(code, options) {
      return (global.acorn || acorn).parse(code, options);
    }

    var binaryOperators = {
      '+': '__add',
      '-': '__subtract',
      '*': '__multiply',
      '/': '__divide',
      '%': '__modulo',
      '==': '__equals',
      '!=': '__equals'
    };
    var unaryOperators = {
      '-': '__negate',
      '+': '__self'
    };
    var fields = Base.each(['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'], function (name) {
      this['__' + name] = '#' + name;
    }, {
      __self: function () {
        return this;
      }
    });
    Point.inject(fields);
    Size.inject(fields);
    Color.inject(fields);

    function __$__(left, operator, right) {
      var handler = binaryOperators[operator];

      if (left && left[handler]) {
        var res = left[handler](right);
        return operator === '!=' ? !res : res;
      }

      switch (operator) {
        case '+':
          return left + right;

        case '-':
          return left - right;

        case '*':
          return left * right;

        case '/':
          return left / right;

        case '%':
          return left % right;

        case '==':
          return left == right;

        case '!=':
          return left != right;
      }
    }

    function $__(operator, value) {
      var handler = unaryOperators[operator];
      if (value && value[handler]) return value[handler]();

      switch (operator) {
        case '+':
          return +value;

        case '-':
          return -value;
      }
    }

    function compile(code, options) {
      if (!code) return '';
      options = options || {};
      var insertions = [];

      function getOffset(offset) {
        for (var i = 0, l = insertions.length; i < l; i++) {
          var insertion = insertions[i];
          if (insertion[0] >= offset) break;
          offset += insertion[1];
        }

        return offset;
      }

      function getCode(node) {
        return code.substring(getOffset(node.range[0]), getOffset(node.range[1]));
      }

      function getBetween(left, right) {
        return code.substring(getOffset(left.range[1]), getOffset(right.range[0]));
      }

      function replaceCode(node, str) {
        var start = getOffset(node.range[0]),
            end = getOffset(node.range[1]),
            insert = 0;

        for (var i = insertions.length - 1; i >= 0; i--) {
          if (start > insertions[i][0]) {
            insert = i + 1;
            break;
          }
        }

        insertions.splice(insert, 0, [start, str.length - end + start]);
        code = code.substring(0, start) + str + code.substring(end);
      }

      function handleOverloading(node, parent) {
        switch (node.type) {
          case 'UnaryExpression':
            if (node.operator in unaryOperators && node.argument.type !== 'Literal') {
              var arg = getCode(node.argument);
              replaceCode(node, '$__("' + node.operator + '", ' + arg + ')');
            }

            break;

          case 'BinaryExpression':
            if (node.operator in binaryOperators && node.left.type !== 'Literal') {
              var left = getCode(node.left),
                  right = getCode(node.right),
                  between = getBetween(node.left, node.right),
                  operator = node.operator;
              replaceCode(node, '__$__(' + left + ',' + between.replace(new RegExp('\\' + operator), '"' + operator + '"') + ', ' + right + ')');
            }

            break;

          case 'UpdateExpression':
          case 'AssignmentExpression':
            var parentType = parent && parent.type;

            if (!(parentType === 'ForStatement' || parentType === 'BinaryExpression' && /^[=!<>]/.test(parent.operator) || parentType === 'MemberExpression' && parent.computed)) {
              if (node.type === 'UpdateExpression') {
                var arg = getCode(node.argument),
                    exp = '__$__(' + arg + ', "' + node.operator[0] + '", 1)',
                    str = arg + ' = ' + exp;

                if (node.prefix) {
                  str = '(' + str + ')';
                } else if (parentType === 'AssignmentExpression' || parentType === 'VariableDeclarator' || parentType === 'BinaryExpression') {
                  if (getCode(parent.left || parent.id) === arg) str = exp;
                  str = arg + '; ' + str;
                }

                replaceCode(node, str);
              } else {
                if (/^.=$/.test(node.operator) && node.left.type !== 'Literal') {
                  var left = getCode(node.left),
                      right = getCode(node.right),
                      exp = left + ' = __$__(' + left + ', "' + node.operator[0] + '", ' + right + ')';
                  replaceCode(node, /^\(.*\)$/.test(getCode(node)) ? '(' + exp + ')' : exp);
                }
              }
            }

            break;
        }
      }

      function handleExports(node) {
        switch (node.type) {
          case 'ExportDefaultDeclaration':
            replaceCode({
              range: [node.start, node.declaration.start]
            }, 'module.exports = ');
            break;

          case 'ExportNamedDeclaration':
            var declaration = node.declaration;
            var specifiers = node.specifiers;

            if (declaration) {
              var declarations = declaration.declarations;

              if (declarations) {
                declarations.forEach(function (dec) {
                  replaceCode(dec, 'module.exports.' + getCode(dec));
                });
                replaceCode({
                  range: [node.start, declaration.start + declaration.kind.length]
                }, '');
              }
            } else if (specifiers) {
              var exports = specifiers.map(function (specifier) {
                var name = getCode(specifier);
                return 'module.exports.' + name + ' = ' + name + '; ';
              }).join('');

              if (exports) {
                replaceCode(node, exports);
              }
            }

            break;
        }
      }

      function walkAST(node, parent, paperFeatures) {
        if (node) {
          for (var key in node) {
            if (key !== 'range' && key !== 'loc') {
              var value = node[key];

              if (Array.isArray(value)) {
                for (var i = 0, l = value.length; i < l; i++) {
                  walkAST(value[i], node, paperFeatures);
                }
              } else if (value && typeof value === 'object') {
                walkAST(value, node, paperFeatures);
              }
            }
          }

          if (paperFeatures.operatorOverloading !== false) {
            handleOverloading(node, parent);
          }

          if (paperFeatures.moduleExports !== false) {
            handleExports(node);
          }
        }
      }

      function encodeVLQ(value) {
        var res = '',
            base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);

        while (value || !res) {
          var next = value & 32 - 1;
          value >>= 5;
          if (value) next |= 32;
          res += base64[next];
        }

        return res;
      }

      var url = options.url || '',
          sourceMaps = options.sourceMaps,
          paperFeatures = options.paperFeatures || {},
          source = options.source || code,
          offset = options.offset || 0,
          agent = paper.agent,
          version = agent.versionNumber,
          offsetCode = false,
          lineBreaks = /\r\n|\n|\r/mg,
          map;

      if (sourceMaps && (agent.chrome && version >= 30 || agent.webkit && version >= 537.76 || agent.firefox && version >= 23 || agent.node)) {
        if (agent.node) {
          offset -= 2;
        } else if (window && url && !window.location.href.indexOf(url)) {
          var html = document.getElementsByTagName('html')[0].innerHTML;
          offset = html.substr(0, html.indexOf(code) + 1).match(lineBreaks).length + 1;
        }

        offsetCode = offset > 0 && !(agent.chrome && version >= 36 || agent.safari && version >= 600 || agent.firefox && version >= 40 || agent.node);
        var mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];
        mappings.length = (code.match(lineBreaks) || []).length + 1 + (offsetCode ? offset : 0);
        map = {
          version: 3,
          file: url,
          names: [],
          mappings: mappings.join(';AACA'),
          sourceRoot: '',
          sources: [url],
          sourcesContent: [source]
        };
      }

      if (paperFeatures.operatorOverloading !== false || paperFeatures.moduleExports !== false) {
        walkAST(parse(code, {
          ranges: true,
          preserveParens: true,
          sourceType: 'module'
        }), null, paperFeatures);
      }

      if (map) {
        if (offsetCode) {
          code = new Array(offset + 1).join('\n') + code;
        }

        if (/^(inline|both)$/.test(sourceMaps)) {
          code += "\n//# sourceMappingURL=data:application/json;base64," + self.btoa(unescape(encodeURIComponent(JSON.stringify(map))));
        }

        code += "\n//# sourceURL=" + (url || 'paperscript');
      }

      return {
        url: url,
        source: source,
        code: code,
        map: map
      };
    }

    function execute(code, scope, options) {
      paper = scope;
      var view = scope.getView(),
          tool = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code) && !/\bnew\s+Tool\b/.test(code) ? new Tool() : null,
          toolHandlers = tool ? tool._events : [],
          handlers = ['onFrame', 'onResize'].concat(toolHandlers),
          params = [],
          args = [],
          func,
          compiled = typeof code === 'object' ? code : compile(code, options);
      code = compiled.code;

      function expose(scope, hidden) {
        for (var key in scope) {
          if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)' + key.replace(/\$/g, '\\$') + '\\b').test(code)) {
            params.push(key);
            args.push(scope[key]);
          }
        }
      }

      expose({
        __$__: __$__,
        $__: $__,
        paper: scope,
        tool: tool
      }, true);
      expose(scope);
      code = 'var module = { exports: {} }; ' + code;
      var exports = Base.each(handlers, function (key) {
        if (new RegExp('\\s+' + key + '\\b').test(code)) {
          params.push(key);
          this.push('module.exports.' + key + ' = ' + key + ';');
        }
      }, []).join('\n');

      if (exports) {
        code += '\n' + exports;
      }

      code += '\nreturn module.exports;';
      var agent = paper.agent;

      if (document && (agent.chrome || agent.firefox && agent.versionNumber < 40)) {
        var script = document.createElement('script'),
            head = document.head || document.getElementsByTagName('head')[0];
        if (agent.firefox) code = '\n' + code;
        script.appendChild(document.createTextNode('document.__paperscript__ = function(' + params + ') {' + code + '\n}'));
        head.appendChild(script);
        func = document.__paperscript__;
        delete document.__paperscript__;
        head.removeChild(script);
      } else {
        func = Function(params, code);
      }

      var exports = func && func.apply(scope, args);
      var obj = exports || {};
      Base.each(toolHandlers, function (key) {
        var value = obj[key];
        if (value) tool[key] = value;
      });

      if (view) {
        if (obj.onResize) view.setOnResize(obj.onResize);
        view.emit('resize', {
          size: view.size,
          delta: new Point()
        });
        if (obj.onFrame) view.setOnFrame(obj.onFrame);
        view.requestUpdate();
      }

      return exports;
    }

    function loadScript(script) {
      if (/^text\/(?:x-|)paperscript$/.test(script.type) && PaperScope.getAttribute(script, 'ignore') !== 'true') {
        var canvasId = PaperScope.getAttribute(script, 'canvas'),
            canvas = document.getElementById(canvasId),
            src = script.src || script.getAttribute('data-src'),
            async = PaperScope.hasAttribute(script, 'async'),
            scopeAttribute = 'data-paper-scope';
        if (!canvas) throw new Error('Unable to find canvas with id "' + canvasId + '"');
        var scope = PaperScope.get(canvas.getAttribute(scopeAttribute)) || new PaperScope().setup(canvas);
        canvas.setAttribute(scopeAttribute, scope._id);

        if (src) {
          Http.request({
            url: src,
            async: async,
            mimeType: 'text/plain',
            onLoad: function (code) {
              execute(code, scope, src);
            }
          });
        } else {
          execute(script.innerHTML, scope, script.baseURI);
        }

        script.setAttribute('data-paper-ignore', 'true');
        return scope;
      }
    }

    function loadAll() {
      Base.each(document && document.getElementsByTagName('script'), loadScript);
    }

    function load(script) {
      return script ? loadScript(script) : loadAll();
    }

    if (window) {
      if (document.readyState === 'complete') {
        setTimeout(loadAll);
      } else {
        DomEvent.add(window, {
          load: loadAll
        });
      }
    }

    return {
      compile: compile,
      execute: execute,
      load: load,
      parse: parse,
      calculateBinary: __$__,
      calculateUnary: $__
    };
  }.call(this);

  var paper = new (PaperScope.inject(Base.exports, {
    Base: Base,
    Numerical: Numerical,
    Key: Key,
    DomEvent: DomEvent,
    DomElement: DomElement,
    document: document,
    window: window,
    Symbol: SymbolDefinition,
    PlacedSymbol: SymbolItem
  }))();

  if (paper.agent.node) {
    __webpack_require__(/*! ./node/extend.js */ 1)(paper);
  }

  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

  return paper;
}.call(this, typeof self === 'object' ? self : null);

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/index.scss */ "./src/styles/index.scss");
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_index_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-full.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _scripts_sidebar_sidebar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/sidebar/sidebar */ "./src/scripts/sidebar/sidebar.js");
/* harmony import */ var _scripts_util_sidebar_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/util/sidebar_data */ "./src/scripts/util/sidebar_data.js");
/* harmony import */ var _scripts_canvas_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scripts/canvas/canvas */ "./src/scripts/canvas/canvas.js");
/* harmony import */ var _scripts_intro_info__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scripts/intro/info */ "./src/scripts/intro/info.js");
/* harmony import */ var _scripts_intro_message__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scripts/intro/message */ "./src/scripts/intro/message.js");







window.addEventListener("DOMContentLoaded", function (main) {
  // canvas
  var canvasElement = document.getElementById('myCanvas');
  var myCanvas = new _scripts_canvas_canvas__WEBPACK_IMPORTED_MODULE_4__["default"](canvasElement); //sidebar

  var sidebarElement = document.getElementById('section-content-sidebar');
  var sidebar = new _scripts_sidebar_sidebar__WEBPACK_IMPORTED_MODULE_2__["default"](_scripts_util_sidebar_data__WEBPACK_IMPORTED_MODULE_3__["default"][0], sidebarElement, myCanvas.drawShapes); //info side bar

  var infoSidebar = new _scripts_intro_info__WEBPACK_IMPORTED_MODULE_5__["default"]("Tips", _scripts_intro_message__WEBPACK_IMPORTED_MODULE_6__["message"]);
});

/***/ }),

/***/ "./src/scripts/canvas/canvas.js":
/*!**************************************!*\
  !*** ./src/scripts/canvas/canvas.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constants */ "./src/scripts/util/constants.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-full.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _modal_modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modal/modal */ "./src/scripts/modal/modal.js");
/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/util */ "./src/scripts/util/util.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





var boundsIdentifierObj = {
  1: 'topLeft',
  2: 'topRight',
  3: 'bottomRight',
  0: 'bottomLeft'
};
var boundsCenterIdentifierObj = {
  1: 'topCenter',
  2: 'rightCenter',
  3: 'bottomCenter',
  0: 'leftCenter'
};
var LINE = 'line';

var MyCanvas =
/*#__PURE__*/
function () {
  function MyCanvas(canvasElement) {
    _classCallCheck(this, MyCanvas);

    this.canvasElement = canvasElement;
    this.centerPosition = this.getCenterPosition();
    this.strokeColor = 'black';
    this.fillColor = "white";
    this.defaultSize = [100, 100];
    this.currentActiveItem = null;
    this.strokeWidth = 2; // sets up paper js on canvas

    paper__WEBPACK_IMPORTED_MODULE_1___default.a.setup(canvasElement); //creates new project in paper

    this.project = new paper__WEBPACK_IMPORTED_MODULE_1__["Project"](canvasElement); //canvas scale value

    this.canvasScaleValue = 1; //creating tool

    this.tool = new paper__WEBPACK_IMPORTED_MODULE_1__["Tool"](); // has moved at least 10 points:

    paper__WEBPACK_IMPORTED_MODULE_1__["tool"].minDistance = 2; //binds methods
    //shapes method binding

    this.drawShapes = this.drawShapes.bind(this);
    this.drawClassShape = this.drawClassShape.bind(this);
    this.drawLineShape = this.drawLineShape.bind(this);
    this.drawObjectShape = this.drawObjectShape.bind(this);
    this.drawTextShape = this.drawTextShape.bind(this);
    this.drawUserCaseShape = this.drawUseCaseShape.bind(this);
    this.drawComponentShape = this.drawComponentShape.bind(this);
    this.drawModuleShape = this.drawModuleShape.bind(this);
    this.drawActivityShape = this.drawActivityShape.bind(this);
    this.drawDecisionShape = this.drawDecisionShape.bind(this);
    this.drawActorShape = this.drawActorShape.bind(this); //general method binding

    this.getCenterPosition = this.getCenterPosition.bind(this); //user interaction method binding

    this.onToolDoubleClick = this.onToolDoubleClick.bind(this);
    this.onToolMouseDown = this.onToolMouseDown.bind(this);
    this.setOneItemSelected = this.setOneItemSelected.bind(this);
    this.onToolDrag = this.onToolDrag.bind(this);
    this.onToolKeyDown = this.onToolKeyDown.bind(this); //tool level clicklistener

    this.tool.onMouseDown = this.onToolMouseDown;
    this.tool.onMouseUp = this.onToolMouseUp;
    this.tool.onMouseDrag = this.onToolDrag;
    this.tool.onKeyDown = this.onToolKeyDown; //add double click listener on canvas because tool have no double click listener

    this.canvasElement.addEventListener("dblclick", this.onToolDoubleClick); //set right menu liteners

    this.setMenuClickListener = this.setMenuClickListener.bind(this); //line attachement function binding

    this.checkLineAttachment = this.checkLineAttachment.bind(this); //line render function

    this.reRenderLine = this.reRenderLine.bind(this);
    this.setMenuClickListener();
  } //set right menu click listener


  _createClass(MyCanvas, [{
    key: "setMenuClickListener",
    value: function setMenuClickListener() {
      var openFileElement = document.getElementById('open-file');
      var downloadFileElement = document.getElementById('download-file');
      var bringToFrontElement = document.getElementById('bring-to-front');
      var moveToBackElement = document.getElementById('move-to-back');
      openFileElement.addEventListener('click', this.openFile.bind(this));
      downloadFileElement.addEventListener('click', this.downloadAsSVG.bind(this));
      bringToFrontElement.addEventListener('click', this.bringToFront.bind(this));
      moveToBackElement.addEventListener('click', this.moveToBack.bind(this));
    } //set input to open file picker dialog

  }, {
    key: "openFile",
    value: function openFile() {
      var _this = this;

      var input = document.createElement('input');
      input.type = 'file';
      input.multiple = false;
      input.accept = 'image/svg+xml';

      input.onchange = function () {
        _this.project.importSVG(URL.createObjectURL(input.files[0]), function (group, svg) {
          _this.project.clear();

          var that = _this;

          while (group.children[1].children.length > 0) {
            that.project.activeLayer.addChild(group.children[1].children[0]);
          }
        });
      };

      input.click();
    } // set download project as svg

  }, {
    key: "downloadAsSVG",
    value: function downloadAsSVG() {
      if (this.project.activeLayer.children.length == 0) return;
      var fileName = "umlchart_".concat(Date.now(), ".svg");
      var url = "data:image/svg+xml;utf8," + encodeURIComponent(this.project.exportSVG({
        asString: true
      }));
      var downloadLinkElement = document.createElement("a");
      downloadLinkElement.download = fileName;
      downloadLinkElement.href = url;
      downloadLinkElement.click();
    } //set bring to front listener for items

  }, {
    key: "bringToFront",
    value: function bringToFront() {
      this.currentActiveItem.bringToFront();
    } //set move to back listener for items

  }, {
    key: "moveToBack",
    value: function moveToBack() {
      this.currentActiveItem.sendToBack();
    } //shape draw distributor

  }, {
    key: "drawShapes",
    value: function drawShapes(shapeName) {
      switch (shapeName) {
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CLASS:
          this.drawClassShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ASSOCIATION:
          var startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 50, this.centerPosition.y);
          var endPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 50, this.centerPosition.y);
          this.drawLineShape(startPoint, endPoint, shapeName);
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].SQUARE:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].OBJECT:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].INTERFACE:
          this.drawObjectShape(shapeName);
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].TITLE:
          startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 25, this.centerPosition.y - 25);
          this.drawTextShape(startPoint, "Add Text");
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CIRCLE:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].USECASE:
          this.drawUseCaseShape(shapeName);
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPONENT:
          this.drawComponentShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].MODULE:
          this.drawModuleShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTIVITY:
          this.drawActivityShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DECISION:
          this.drawDecisionShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTOR:
          this.drawActorShape();

        default:
          break;
      }
    } // Creates three rectangle to make a class UML

  }, {
    key: "drawClassShape",
    value: function drawClassShape() {
      //creates group and add shapes
      //create class rectangle
      var groupClass = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      var firstRectX = this.centerPosition.x - 50;
      var firstRectY = this.centerPosition.y - 50;
      var firstRectHeight = 20;
      var fristRectWidth = this.defaultSize[1];
      var classNameRectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(firstRectX, firstRectY, fristRectWidth, firstRectHeight);
      this.setStrokeAndFill(classNameRectangle);
      groupClass.addChild(classNameRectangle); //create varaible rectangle

      var secRectX = firstRectX;
      var secRectY = firstRectY + firstRectHeight;
      var secRectHeight = 50;
      var secRectWidth = this.defaultSize[1];
      var variableNameRectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(secRectX, secRectY, secRectWidth, secRectHeight);
      this.setStrokeAndFill(variableNameRectangle);
      groupClass.addChild(variableNameRectangle); //create method rectangle

      var thirdRectX = firstRectX;
      var thirdRectY = secRectY + secRectHeight;
      var thirdRectHeight = 30;
      var thirdRectWidth = this.defaultSize[1];
      var methodNameRectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(thirdRectX, thirdRectY, thirdRectWidth, thirdRectHeight);
      this.setStrokeAndFill(methodNameRectangle);
      groupClass.addChild(methodNameRectangle);
    } // adds text to the clicked area

  }, {
    key: "drawTextShape",
    value: function drawTextShape(position, text) {
      //create text shape
      var textShape = new paper__WEBPACK_IMPORTED_MODULE_1__["PointText"](position);
      textShape.fillColor = this.strokeColor;
      textShape.content = text; //adds doubleclick listner to text

      textShape.onDoubleClick = function (e) {
        //show modal to update text
        if (textShape.bounds.selected) {
          new _modal_modal__WEBPACK_IMPORTED_MODULE_2__["default"](function (updatedText) {
            textShape.content = updatedText;
          }).show();
        }
      };

      return textShape;
    } //add Divider/Association/Compositioin/Aggregation with head shape and three circles (to aid movement and drag)

  }, {
    key: "drawLineShape",
    value: function drawLineShape(startPoint, endPoint, lineType) {
      var mainGroup = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"](); //draw line

      var line = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(startPoint, endPoint);
      this.setStrokeAndFill(line); // draw head circle

      var headCircle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(endPoint, 5);
      headCircle.fillColor = 'black';
      headCircle.strokeWidth = 1; //draw middle circle

      var midPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"]((startPoint.x + endPoint.x) / 2, (startPoint.y + endPoint.y) / 2);
      var midCircle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(midPoint, 4);
      midCircle.fillColor = 'black';
      midCircle.strokeWidth = 1; //draw tail circle

      var tailCircle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(startPoint, 5);
      tailCircle.fillColor = 'black';
      tailCircle.strokeWidth = 1; //add circles and line to group

      group.addChild(line);
      group.addChild(tailCircle);
      group.addChild(midCircle);
      group.addChild(headCircle); //draw arrow shape

      var headShape = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"]();
      headShape.strokeColor = this.strokeColor;
      headShape.strokeWidth = this.strokeWidth;
      var arrowCenter = endPoint; //based on line type draw shape

      if (lineType !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER) {
        var leftEdge = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](arrowCenter.x - 10, arrowCenter.y - 10);
        var rightEdge = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](arrowCenter.x - 10, arrowCenter.y + 10);
        headShape.add(leftEdge);
        headShape.add(arrowCenter);
        headShape.add(rightEdge);

        if (lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION || lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION) {
          var bottomRightEdge = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](arrowCenter.x - 20, arrowCenter.y);
          var bottomLeftEdge = leftEdge;
          headShape.add(bottomRightEdge);
          headShape.add(bottomLeftEdge);

          if (lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION) {
            headShape.strokeColor = 'white';
            headShape.fillColor = 'white';
            headShape.shadowColor = 'gray';
            headShape.shadowOffset = 1;
          }

          if (lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION) {
            headShape.fillColor = 'black';
          }
        }
      } //rotate the head shape


      if (lineType !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER) headShape.rotate(Object(_util_util__WEBPACK_IMPORTED_MODULE_3__["getAngleDeg"])(endPoint.x, endPoint.y, startPoint.x, startPoint.y), arrowCenter); //add group to main group

      mainGroup.addChild(group);
      if (lineType !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER) mainGroup.addChild(headShape);
      mainGroup.data.type = LINE;
      mainGroup.data.lineType = lineType;
      mainGroup.data.lineId = Date.now();
      return mainGroup;
    } //add Object/Interface shape

  }, {
    key: "drawObjectShape",
    value: function drawObjectShape(type) {
      //creates object rectangle
      var startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 50, this.centerPosition.y - 25);
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(startPoint.x, startPoint.y, this.defaultSize[0], this.defaultSize[0] / 2);
      this.setStrokeAndFill(rectangle); //create textshape

      if (type !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].SQUARE) {
        var textShapeStartPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](startPoint.x + 30, startPoint.y + 30);
        var textShape = this.drawTextShape(textShapeStartPoint, type);
      }
    } //add Usecase/Activity shape

  }, {
    key: "drawUseCaseShape",
    value: function drawUseCaseShape(type) {
      //draw circle
      var circlePath = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(this.centerPosition, 25);
      circlePath.scale(2, 1.2); //scale to make it an oval

      this.setStrokeAndFill(circlePath);

      if (type === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].USECASE) {
        //add Text
        var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 25, this.centerPosition.y + 5), type);
      }
    } //add Component shape

  }, {
    key: "drawComponentShape",
    value: function drawComponentShape() {
      //draw main rectangle
      var startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 50, this.centerPosition.y - 25);
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(startPoint.x, startPoint.y, this.defaultSize[0] + 20, this.defaultSize[0] - 45);
      this.setStrokeAndFill(rectangle); // draw sub part of the shape

      var subRect = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topRight.x - 25, startPoint.y + 6, 20, 25);
      this.setStrokeAndFill(subRect);
      subRect.strokeWidth = 2 / this.strokeWidth; //draw two sub rec

      var subRect1 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topRight.x - 28, startPoint.y + 9, 7, 7);
      this.setStrokeAndFill(subRect1);
      subRect1.strokeWidth = 2 / this.strokeWidth;
      var subRect2 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topRight.x - 28, startPoint.y + 20, 7, 7);
      this.setStrokeAndFill(subRect2);
      subRect2.strokeWidth = 2 / this.strokeWidth; //create group and add shapes

      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      group.addChild(rectangle);
      group.addChild(subRect);
      group.addChild(subRect1);
      group.addChild(subRect2); //add text to shape

      var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 25, this.centerPosition.y + 8), _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPONENT);
    } //add module shape

  }, {
    key: "drawModuleShape",
    value: function drawModuleShape() {
      // draw main rect
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(this.centerPosition.x - 50, this.centerPosition.y - 50, this.defaultSize[0] + 20, this.defaultSize[0] - 40);
      this.setStrokeAndFill(rectangle); //draw two sub rec

      var subRect1 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topLeft.x - 7, rectangle.bounds.topLeft.y + 12, 15, 12);
      this.setStrokeAndFill(subRect1);
      var subRect2 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topLeft.x - 7, rectangle.bounds.topLeft.y + 35, 15, 12);
      this.setStrokeAndFill(subRect2); //create group and add shapes

      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      group.addChild(rectangle);
      group.addChild(subRect1);
      group.addChild(subRect2); //add text to shape

      var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 10, this.centerPosition.y - 15), _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].MODULE);
    } //add activity shape

  }, {
    key: "drawActivityShape",
    value: function drawActivityShape() {
      //create rounded shape rectangle
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](this.centerPosition.subtract(50), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 70, this.centerPosition.y));
      var radius = new paper__WEBPACK_IMPORTED_MODULE_1__["Size"](30, 30);
      var path = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle, radius);
      this.setStrokeAndFill(path); //add text to shape

      var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 10, this.centerPosition.y - 20), _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTIVITY);
    } //add decision shape

  }, {
    key: "drawDecisionShape",
    value: function drawDecisionShape() {
      //create rectangle
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(this.centerPosition.x - 20, this.centerPosition.y - 20, this.defaultSize[0] / 2.5, this.defaultSize[0] / 2.5);
      this.setStrokeAndFill(rectangle); //rotate

      rectangle.rotate(45);
    } //on tool click

  }, {
    key: "onToolMouseDown",
    value: function onToolMouseDown(e) {
      //toggle item selected
      this.setOneItemSelected(e); //return if no currentActiveItem

      if (!this.currentActiveItem) return; //clearing currentActiveItem data to fix the issue of unintended moves

      this.currentActiveItem.data.state = null;

      if (this.currentActiveItem.contains(e.point)) {
        this.currentActiveItem.data.state = 'move';
      } //set items data based on item mouseDown point


      if (this.currentActiveItem.data.type !== LINE) {
        if (this.currentActiveItem.hitTest(e.point, {
          bounds: true,
          tolerance: 5
        })) {
          //get bounds of the shape
          var bounds = this.currentActiveItem.bounds; //itrating to find the exact bound point

          for (var _i = 0, _Object$entries = Object.entries(boundsIdentifierObj); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                key = _Object$entries$_i[0],
                value = _Object$entries$_i[1];

            if (bounds[value].isClose(e.point, 5)) {
              var oppositeBound = bounds[boundsIdentifierObj[(parseInt(key) + 2) % 4]]; //get opposite bound point

              var oppositePoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](oppositeBound.x, oppositeBound.y); //get current bound point

              var centerPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](bounds[value].x, bounds[value].y); //set shape data to be used for resizing later

              this.currentActiveItem.data.state = 'resize';
              this.currentActiveItem.data.from = oppositePoint;
              this.currentActiveItem.data.to = centerPoint;
              break;
            }
          }
        }
      } else {
        //only for shapes with type LINE
        var headCircleItem = this.currentActiveItem.firstChild.children[3];

        if (headCircleItem.contains(e.point)) {
          this.currentActiveItem.data.state = 'resize';
        }
      }
    } //draw actor shape

  }, {
    key: "drawActorShape",
    value: function drawActorShape() {
      //draw actor head
      var head = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 50), 7);
      this.setStrokeAndFill(head); //draw actor body

      var body = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 43), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 10));
      this.setStrokeAndFill(body); //draw actor arms

      var arms = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 20, this.centerPosition.y - 38), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 20, this.centerPosition.y - 38));
      this.setStrokeAndFill(arms); //draw feet

      var leftFeet = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 20, this.centerPosition.y + 5), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 10));
      this.setStrokeAndFill(leftFeet);
      var rightFeet = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 10), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 20, this.centerPosition.y + 5));
      this.setStrokeAndFill(rightFeet); //add shapes to group to make full actor

      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      group.addChild(head);
      group.addChild(body);
      group.addChild(arms);
      group.addChild(leftFeet);
      group.addChild(rightFeet);
    } //item drag listener

  }, {
    key: "onToolDrag",
    value: function onToolDrag(e) {
      // debugger
      if (this.currentActiveItem == null) return;

      if (this.currentActiveItem.data.state === 'move') {
        this.currentActiveItem.position = e.point; //check if the shape has any attached lines

        if (this.currentActiveItem.data.lineShape) {
          var lineShapeObject = this.currentActiveItem.data.lineShape;

          for (var _i2 = 0, _Object$entries2 = Object.entries(lineShapeObject); _i2 < _Object$entries2.length; _i2++) {
            var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
                key = _Object$entries2$_i[0],
                value = _Object$entries2$_i[1];

            var element = value[1];
            var lineStartPoint = element.firstChild.firstChild.segments[0].point;
            var lineType = element.data.lineType;
            var lineId = element.data.lineId;
            element.remove();
            element = this.drawLineShape(lineStartPoint, this.currentActiveItem.bounds[value[0]], lineType);
            element.data.lineId = lineId;
            lineShapeObject[key] = [value[0], element];
          }
        }
      } else if (this.currentActiveItem.data.state === 'resize') {
        if (this.currentActiveItem.data.type === LINE) {
          //shapes with type line, re-rendering line on each user move
          this.reRenderLine(e.point);
          this.checkLineAttachment(e);
        } else {
          //shapes other than line, updating the bounds
          this.currentActiveItem.bounds = new paper__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](this.currentActiveItem.data.from, e.point);
        }

        this.currentActiveItem.bounds.selected = true;
      }
    }
  }, {
    key: "reRenderLine",
    value: function reRenderLine(headPosition) {
      var lineStartPoint = this.currentActiveItem.firstChild.firstChild.segments[0].point;
      var lineType = this.currentActiveItem.data.lineType;
      var lineId = this.currentActiveItem.data.lineId;
      this.currentActiveItem.remove();
      this.currentActiveItem = this.drawLineShape(lineStartPoint, headPosition, lineType);
      this.currentActiveItem.data.state = 'resize';
      this.currentActiveItem.data.lineId = lineId;
    } // attach line to shapes

  }, {
    key: "checkLineAttachment",
    value: function checkLineAttachment(event) {
      var _this2 = this;

      //iteratethough each element to find the intresecting shape
      this.project.activeLayer.children.forEach(function (child) {
        // find the shapes that line intersected with
        if (child != _this2.currentActiveItem && child.hitTest(event.point, {
          bounds: true,
          tolerance: 5
        })) {
          //add line to attached shapes
          var bounds = child.bounds; //itrating to find the exact bound point

          for (var _i3 = 0, _Object$entries3 = Object.entries(boundsCenterIdentifierObj); _i3 < _Object$entries3.length; _i3++) {
            var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
                key = _Object$entries3$_i[0],
                value = _Object$entries3$_i[1];

            if (bounds[value].isClose(event.point, 5)) {
              //get center bound point of the side line touches
              var centerPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](bounds[value].x, bounds[value].y);

              _this2.reRenderLine(centerPoint); //set data to shape to allow shape to move line head with it as it is dragged
              // check if the lineShape already exists


              if (!child.data.lineShape) {
                child.data.lineShape = {};
              } // add line currentActive Line Shape and also the side it is attached with


              child.data.lineShape[_this2.currentActiveItem.data.lineId] = [value, _this2.currentActiveItem];
              break;
            }
          }
        } else {
          //remove line attachement with shapes
          if (child.data.lineShape) {
            delete child.data.lineShape[_this2.currentActiveItem.data.lineId];
          }
        }
      });
    } //on tool double click

  }, {
    key: "onToolDoubleClick",
    value: function onToolDoubleClick(e) {
      if (e.ctrlKey) {
        this.drawTextShape({
          x: e.layerX,
          y: e.layerY
        }, "Add Text");
      }
    } //toggle item selecteion and saving currentActiveItem

  }, {
    key: "setOneItemSelected",
    value: function setOneItemSelected(e) {
      var position = e.point;
      var clickedItems = [];
      this.project.activeLayer.children.forEach(function (child) {
        if (child.contains(position)) {
          clickedItems.push(child);
        } else {
          child.bounds.selected = false;
        }
      }); //return if no item is selected

      if (clickedItems.length === 0) return; //select the clicked item

      var latestItem = clickedItems[0];

      for (var i = 0; i < clickedItems.length; i++) {
        if (latestItem.id < clickedItems[i].id) {
          latestItem = clickedItems[i];
        } else {
          clickedItems[i].bounds.selected = false;
        }
      }

      this.currentActiveItem = latestItem;
      latestItem.bounds.selected = true;
    } // keyboard intraction to move shapes

  }, {
    key: "onToolKeyDown",
    value: function onToolKeyDown(e) {
      if (!this.currentActiveItem) return;
      var position = this.currentActiveItem.position;
      var step = 5;

      switch (e.key) {
        case 'left':
          position.x -= step;
          break;

        case 'right':
          position.x += step;
          break;

        case 'up':
          position.y -= step;
          break;

        case 'down':
          position.y += step;
          break;

        case 'delete':
          this.currentActiveItem.remove();
          break;
      }

      this.currentActiveItem.position = position;
    } //----------------------- general methods --------------------------------------
    // return center position of canvas

  }, {
    key: "getCenterPosition",
    value: function getCenterPosition() {
      return new paper__WEBPACK_IMPORTED_MODULE_1__["Point"]({
        x: this.canvasElement.clientWidth / 2,
        y: this.canvasElement.clientHeight / 2
      });
    } // helper to set stroke and fill

  }, {
    key: "setStrokeAndFill",
    value: function setStrokeAndFill(item) {
      item.strokeWidth = this.strokeWidth;
      item.strokeColor = this.strokeColor;
      item.fillColor = this.fillColor;
    }
  }]);

  return MyCanvas;
}();

/* harmony default export */ __webpack_exports__["default"] = (MyCanvas);

/***/ }),

/***/ "./src/scripts/intro/info.js":
/*!***********************************!*\
  !*** ./src/scripts/intro/info.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Info; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Info =
/*#__PURE__*/
function () {
  function Info(title, text) {
    _classCallCheck(this, Info);

    this.title = title;
    this.text = text;
    this.show = this.show.bind(this);
    this.show();
  }

  _createClass(Info, [{
    key: "show",
    value: function show() {
      //set up info view
      var infoSectionContainerElement = document.getElementById('info-sidebar');
      var topBarConatinerElement = document.createElement('div');
      topBarConatinerElement.setAttribute('class', 'top-bar-container');
      var titleElement = document.createElement('h1');
      titleElement.setAttribute('class', 'info-title');
      titleElement.innerHTML = this.title;
      var closeElement = document.createElement('span');
      closeElement.setAttribute('class', 'info-close');
      closeElement.innerHTML = 'X';
      topBarConatinerElement.appendChild(titleElement);
      topBarConatinerElement.appendChild(closeElement);
      var bodyElement = document.createElement('div');
      bodyElement.setAttribute('class', 'info-body');
      bodyElement.innerHTML = this.text;
      infoSectionContainerElement.appendChild(topBarConatinerElement);
      infoSectionContainerElement.appendChild(bodyElement); //set up listener

      closeElement.addEventListener('click', function () {
        infoSectionContainerElement.setAttribute('class', 'hidden');
      });
    }
  }]);

  return Info;
}();



/***/ }),

/***/ "./src/scripts/intro/message.js":
/*!**************************************!*\
  !*** ./src/scripts/intro/message.js ***!
  \**************************************/
/*! exports provided: message */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "message", function() { return message; });
var message = "<p> - Click any shape from the UML section to add it to the canvas.<br/> </p>" + "<p> - Then select a shape and drag it form any corner to resize.<br/> </p>" + "<p> - You can also move a shape with arrow keys form the keyboard.<br/> </p>" + "<p> - Select any line shape and use middle circle to move the line around and the head circle to rotate it at different angles.<br/> </p>" + "<p> - Drag line head to middle of either side of the shape to attach it and move it away to detach it.<br/> </p>" + "<p> - Select a shape and press 'delete' key to delete the shape.<br/> </p>" + "<p> - Press 'Ctrl + Mouse Double Click' to add text.<br/> </p>" + "<p> - Use 'Move-To-Front' and 'Send-To-Back' icon to move the shapes.<br/> </p>" + "<p> - For saving and opening exisiting project utilize the menu bar.<br/> </p>";

/***/ }),

/***/ "./src/scripts/modal/modal.js":
/*!************************************!*\
  !*** ./src/scripts/modal/modal.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Modal; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Modal =
/*#__PURE__*/
function () {
  function Modal(textCallback) {
    _classCallCheck(this, Modal);

    this.textCallback = textCallback;
    this.show = this.show.bind(this);
  }

  _createClass(Modal, [{
    key: "show",
    value: function show() {
      var _this = this;

      var bodyElement = document.getElementById('body');
      var modalMainContainerElement = document.createElement('div');
      modalMainContainerElement.setAttribute('class', 'modal-main-container');
      var modalContainerElement = document.createElement('div');
      modalContainerElement.setAttribute('class', 'modal-container');
      var modalTitleConainerElement = document.createElement('div');
      modalTitleConainerElement.setAttribute('class', 'modal-title-container');
      var modalTitleElement = document.createElement('h1');
      modalTitleElement.innerHTML = "Add Text";
      modalTitleElement.setAttribute('class', 'modal-title');
      var modalCloseElement = document.createElement('span');
      modalCloseElement.innerHTML = "X";
      modalCloseElement.setAttribute('class', 'modal-close');
      var modalInputElement = document.createElement('input');
      modalInputElement.placeholder = "Add text here";
      modalInputElement.setAttribute('class', 'modal-input');
      var modalSubmitElement = document.createElement('button');
      modalSubmitElement.innerHTML = "Submit";
      modalSubmitElement.setAttribute('class', 'modal-submit');
      modalTitleConainerElement.appendChild(modalTitleElement);
      modalTitleConainerElement.appendChild(modalCloseElement);
      modalContainerElement.appendChild(modalTitleConainerElement);
      modalContainerElement.appendChild(modalInputElement);
      modalContainerElement.appendChild(modalSubmitElement);
      modalMainContainerElement.appendChild(modalContainerElement);
      bodyElement.appendChild(modalMainContainerElement); //adds listeners
      //close modal on outside click

      modalMainContainerElement.addEventListener('click', function (e) {
        modalMainContainerElement.setAttribute('class', 'hiddden');
      }); //stops modal from closing if clicked inside modal

      modalContainerElement.addEventListener('click', function (e) {
        e.stopPropagation();
      }); //closes modal on click

      modalCloseElement.addEventListener('click', function (e) {
        modalMainContainerElement.setAttribute('class', 'hiddden');
      }); //gets text form input on submit and sending to callback

      modalSubmitElement.addEventListener('click', function (e) {
        var inputText = modalInputElement.value;

        _this.textCallback(inputText);

        modalMainContainerElement.setAttribute('class', 'hiddden');
      });
    }
  }]);

  return Modal;
}();



/***/ }),

/***/ "./src/scripts/sidebar/sidebar.js":
/*!****************************************!*\
  !*** ./src/scripts/sidebar/sidebar.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Sidebar; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Sidebar =
/*#__PURE__*/
function () {
  function Sidebar(categoryObj, sidebarElement, onShapeClickCallback) {
    _classCallCheck(this, Sidebar);

    this.categoryTitle = categoryObj.categoryName;
    this.shapes = categoryObj.shapes;
    this.sidebarElement = sidebarElement;
    this.onShapeClickCallback = onShapeClickCallback;
    this.draw();
    this.shapeClickListener = this.shapeClickListener.bind(this);
  }

  _createClass(Sidebar, [{
    key: "shapeClickListener",
    value: function shapeClickListener(shapeName) {
      var _this = this;

      return function (e) {
        _this.onShapeClickCallback(shapeName);
      };
    }
  }, {
    key: "draw",
    value: function draw() {
      //adds category title in sidebar
      var categoryTitleElement = document.createElement('h1');
      categoryTitleElement.innerHTML = this.categoryTitle;
      categoryTitleElement.setAttribute('class', 'sidebar-category-title');
      this.sidebarElement.appendChild(categoryTitleElement); //adds category shapes in sidebar

      var shapesUlElement = document.createElement('ul');
      shapesUlElement.setAttribute('class', "sidebar-category-shapes-ul");

      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];
        var shapeLiElement = document.createElement('li');
        shapeLiElement.setAttribute('class', "sidebar-category-shapes-li");
        shapeLiElement.addEventListener("click", this.shapeClickListener(shape.name));
        var shapeImageElement = document.createElement('img');
        shapeImageElement.setAttribute('class', "sidebar-category-images");
        shapeImageElement.src = shape.uri;
        shapeLiElement.appendChild(shapeImageElement);
        shapesUlElement.appendChild(shapeLiElement);
      }

      this.sidebarElement.appendChild(shapesUlElement);
    }
  }]);

  return Sidebar;
}();



/***/ }),

/***/ "./src/scripts/util/constants.js":
/*!***************************************!*\
  !*** ./src/scripts/util/constants.js ***!
  \***************************************/
/*! exports provided: SHAPES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHAPES", function() { return SHAPES; });
var SHAPES = {
  CLASS: 'Class',
  SQUARE: 'Square',
  DIVIDER: 'Divider',
  CIRCLE: 'Circle',
  OBJECT: 'Object',
  INTERFACE: 'Interface',
  ACTOR: 'Actor',
  AGGREGATION: 'Aggregation',
  COMPOSITION: 'Composition',
  ASSOCIATION: 'Association',
  COMPONENT: 'Component',
  MODULE: 'Module',
  TITLE: 'Title',
  ACTIVITY: 'Activity',
  USECASE: 'Use Case',
  DECISION: 'Decision'
};

/***/ }),

/***/ "./src/scripts/util/sidebar_data.js":
/*!******************************************!*\
  !*** ./src/scripts/util/sidebar_data.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/scripts/util/constants.js");

var sidebarData = [{
  categoryName: "UML",
  shapes: [{
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].OBJECT,
    uri: './src/images/object.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].INTERFACE,
    uri: './src/images/interface.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CLASS,
    uri: './src/images/class.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER,
    uri: './src/images/divider.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].TITLE,
    uri: './src/images/title.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPONENT,
    uri: './src/images/component.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].MODULE,
    uri: './src/images/module.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTOR,
    uri: './src/images/actor.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].USECASE,
    uri: './src/images/usercase.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTIVITY,
    uri: './src/images/activity.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DECISION,
    uri: './src/images/decision.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION,
    uri: './src/images/aggregation.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION,
    uri: './src/images/composition.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ASSOCIATION,
    uri: './src/images/association.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CIRCLE,
    uri: './src/images/circle.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].SQUARE,
    uri: './src/images/square.svg'
  }]
}];
/* harmony default export */ __webpack_exports__["default"] = (sidebarData);

/***/ }),

/***/ "./src/scripts/util/util.js":
/*!**********************************!*\
  !*** ./src/scripts/util/util.js ***!
  \**********************************/
/*! exports provided: getAngleDeg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngleDeg", function() { return getAngleDeg; });
function getAngleDeg(ex, ey, cx, cy) {
  var dy = ey - cy;
  var dx = ex - cx;
  var theta = Math.atan2(dy, dx);
  theta *= 180 / Math.PI;
  return theta;
}

/***/ }),

/***/ "./src/styles/index.scss":
/*!*******************************!*\
  !*** ./src/styles/index.scss ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 0:
/*!********************************!*\
  !*** ./node/self.js (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************************!*\
  !*** ./node/extend.js (ignored) ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fjb3JuL2Rpc3QvYWNvcm4ubWpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWZ1bGwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NhbnZhcy9jYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvaW50cm8vaW5mby5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9pbnRyby9tZXNzYWdlLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL21vZGFsL21vZGFsLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3NpZGViYXIvc2lkZWJhci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy91dGlsL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy91dGlsL3NpZGViYXJfZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9pbmRleC5zY3NzP2M4MDciLCJ3ZWJwYWNrOi8vLy4vbm9kZS9zZWxmLmpzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9ub2RlL2V4dGVuZC5qcyAoaWdub3JlZCkiXSwibmFtZXMiOlsid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1haW4iLCJjYW52YXNFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm15Q2FudmFzIiwiTXlDYW52YXMiLCJzaWRlYmFyRWxlbWVudCIsInNpZGViYXIiLCJTaWRlYmFyIiwic2lkZWJhckRhdGEiLCJkcmF3U2hhcGVzIiwiaW5mb1NpZGViYXIiLCJJbmZvIiwibWVzc2FnZSIsImJvdW5kc0lkZW50aWZpZXJPYmoiLCJib3VuZHNDZW50ZXJJZGVudGlmaWVyT2JqIiwiTElORSIsImNlbnRlclBvc2l0aW9uIiwiZ2V0Q2VudGVyUG9zaXRpb24iLCJzdHJva2VDb2xvciIsImZpbGxDb2xvciIsImRlZmF1bHRTaXplIiwiY3VycmVudEFjdGl2ZUl0ZW0iLCJzdHJva2VXaWR0aCIsInBhcGVyIiwic2V0dXAiLCJwcm9qZWN0IiwiUHJvamVjdCIsImNhbnZhc1NjYWxlVmFsdWUiLCJ0b29sIiwiVG9vbCIsIm1pbkRpc3RhbmNlIiwiYmluZCIsImRyYXdDbGFzc1NoYXBlIiwiZHJhd0xpbmVTaGFwZSIsImRyYXdPYmplY3RTaGFwZSIsImRyYXdUZXh0U2hhcGUiLCJkcmF3VXNlckNhc2VTaGFwZSIsImRyYXdVc2VDYXNlU2hhcGUiLCJkcmF3Q29tcG9uZW50U2hhcGUiLCJkcmF3TW9kdWxlU2hhcGUiLCJkcmF3QWN0aXZpdHlTaGFwZSIsImRyYXdEZWNpc2lvblNoYXBlIiwiZHJhd0FjdG9yU2hhcGUiLCJvblRvb2xEb3VibGVDbGljayIsIm9uVG9vbE1vdXNlRG93biIsInNldE9uZUl0ZW1TZWxlY3RlZCIsIm9uVG9vbERyYWciLCJvblRvb2xLZXlEb3duIiwib25Nb3VzZURvd24iLCJvbk1vdXNlVXAiLCJvblRvb2xNb3VzZVVwIiwib25Nb3VzZURyYWciLCJvbktleURvd24iLCJzZXRNZW51Q2xpY2tMaXN0ZW5lciIsImNoZWNrTGluZUF0dGFjaG1lbnQiLCJyZVJlbmRlckxpbmUiLCJvcGVuRmlsZUVsZW1lbnQiLCJkb3dubG9hZEZpbGVFbGVtZW50IiwiYnJpbmdUb0Zyb250RWxlbWVudCIsIm1vdmVUb0JhY2tFbGVtZW50Iiwib3BlbkZpbGUiLCJkb3dubG9hZEFzU1ZHIiwiYnJpbmdUb0Zyb250IiwibW92ZVRvQmFjayIsImlucHV0IiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJtdWx0aXBsZSIsImFjY2VwdCIsIm9uY2hhbmdlIiwiaW1wb3J0U1ZHIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiZmlsZXMiLCJncm91cCIsInN2ZyIsImNsZWFyIiwidGhhdCIsImNoaWxkcmVuIiwibGVuZ3RoIiwiYWN0aXZlTGF5ZXIiLCJhZGRDaGlsZCIsImNsaWNrIiwiZmlsZU5hbWUiLCJEYXRlIiwibm93IiwidXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZXhwb3J0U1ZHIiwiYXNTdHJpbmciLCJkb3dubG9hZExpbmtFbGVtZW50IiwiZG93bmxvYWQiLCJocmVmIiwic2VuZFRvQmFjayIsInNoYXBlTmFtZSIsIlNIQVBFUyIsIkNMQVNTIiwiQUdHUkVHQVRJT04iLCJDT01QT1NJVElPTiIsIkRJVklERVIiLCJBU1NPQ0lBVElPTiIsInN0YXJ0UG9pbnQiLCJQb2ludCIsIngiLCJ5IiwiZW5kUG9pbnQiLCJTUVVBUkUiLCJPQkpFQ1QiLCJJTlRFUkZBQ0UiLCJUSVRMRSIsIkNJUkNMRSIsIlVTRUNBU0UiLCJDT01QT05FTlQiLCJNT0RVTEUiLCJBQ1RJVklUWSIsIkRFQ0lTSU9OIiwiQUNUT1IiLCJncm91cENsYXNzIiwiR3JvdXAiLCJmaXJzdFJlY3RYIiwiZmlyc3RSZWN0WSIsImZpcnN0UmVjdEhlaWdodCIsImZyaXN0UmVjdFdpZHRoIiwiY2xhc3NOYW1lUmVjdGFuZ2xlIiwiUGF0aCIsIlJlY3RhbmdsZSIsInNldFN0cm9rZUFuZEZpbGwiLCJzZWNSZWN0WCIsInNlY1JlY3RZIiwic2VjUmVjdEhlaWdodCIsInNlY1JlY3RXaWR0aCIsInZhcmlhYmxlTmFtZVJlY3RhbmdsZSIsInRoaXJkUmVjdFgiLCJ0aGlyZFJlY3RZIiwidGhpcmRSZWN0SGVpZ2h0IiwidGhpcmRSZWN0V2lkdGgiLCJtZXRob2ROYW1lUmVjdGFuZ2xlIiwicG9zaXRpb24iLCJ0ZXh0IiwidGV4dFNoYXBlIiwiUG9pbnRUZXh0IiwiY29udGVudCIsIm9uRG91YmxlQ2xpY2siLCJlIiwiYm91bmRzIiwic2VsZWN0ZWQiLCJNb2RhbCIsInVwZGF0ZWRUZXh0Iiwic2hvdyIsImxpbmVUeXBlIiwibWFpbkdyb3VwIiwibGluZSIsIkxpbmUiLCJoZWFkQ2lyY2xlIiwiQ2lyY2xlIiwibWlkUG9pbnQiLCJtaWRDaXJjbGUiLCJ0YWlsQ2lyY2xlIiwiaGVhZFNoYXBlIiwiYXJyb3dDZW50ZXIiLCJsZWZ0RWRnZSIsInJpZ2h0RWRnZSIsImFkZCIsImJvdHRvbVJpZ2h0RWRnZSIsImJvdHRvbUxlZnRFZGdlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dPZmZzZXQiLCJyb3RhdGUiLCJnZXRBbmdsZURlZyIsImRhdGEiLCJsaW5lSWQiLCJyZWN0YW5nbGUiLCJ0ZXh0U2hhcGVTdGFydFBvaW50IiwiY2lyY2xlUGF0aCIsInNjYWxlIiwic3ViUmVjdCIsInRvcFJpZ2h0Iiwic3ViUmVjdDEiLCJzdWJSZWN0MiIsInRvcExlZnQiLCJzdWJ0cmFjdCIsInJhZGl1cyIsIlNpemUiLCJwYXRoIiwic3RhdGUiLCJjb250YWlucyIsInBvaW50IiwiaGl0VGVzdCIsInRvbGVyYW5jZSIsIk9iamVjdCIsImVudHJpZXMiLCJrZXkiLCJ2YWx1ZSIsImlzQ2xvc2UiLCJvcHBvc2l0ZUJvdW5kIiwicGFyc2VJbnQiLCJvcHBvc2l0ZVBvaW50IiwiY2VudGVyUG9pbnQiLCJmcm9tIiwidG8iLCJoZWFkQ2lyY2xlSXRlbSIsImZpcnN0Q2hpbGQiLCJoZWFkIiwiYm9keSIsImFybXMiLCJsZWZ0RmVldCIsInJpZ2h0RmVldCIsImxpbmVTaGFwZSIsImxpbmVTaGFwZU9iamVjdCIsImVsZW1lbnQiLCJsaW5lU3RhcnRQb2ludCIsInNlZ21lbnRzIiwicmVtb3ZlIiwiaGVhZFBvc2l0aW9uIiwiZXZlbnQiLCJmb3JFYWNoIiwiY2hpbGQiLCJjdHJsS2V5IiwibGF5ZXJYIiwibGF5ZXJZIiwiY2xpY2tlZEl0ZW1zIiwicHVzaCIsImxhdGVzdEl0ZW0iLCJpIiwiaWQiLCJzdGVwIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJpdGVtIiwidGl0bGUiLCJpbmZvU2VjdGlvbkNvbnRhaW5lckVsZW1lbnQiLCJ0b3BCYXJDb25hdGluZXJFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwidGl0bGVFbGVtZW50IiwiaW5uZXJIVE1MIiwiY2xvc2VFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJib2R5RWxlbWVudCIsInRleHRDYWxsYmFjayIsIm1vZGFsTWFpbkNvbnRhaW5lckVsZW1lbnQiLCJtb2RhbENvbnRhaW5lckVsZW1lbnQiLCJtb2RhbFRpdGxlQ29uYWluZXJFbGVtZW50IiwibW9kYWxUaXRsZUVsZW1lbnQiLCJtb2RhbENsb3NlRWxlbWVudCIsIm1vZGFsSW5wdXRFbGVtZW50IiwicGxhY2Vob2xkZXIiLCJtb2RhbFN1Ym1pdEVsZW1lbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJpbnB1dFRleHQiLCJjYXRlZ29yeU9iaiIsIm9uU2hhcGVDbGlja0NhbGxiYWNrIiwiY2F0ZWdvcnlUaXRsZSIsImNhdGVnb3J5TmFtZSIsInNoYXBlcyIsImRyYXciLCJzaGFwZUNsaWNrTGlzdGVuZXIiLCJjYXRlZ29yeVRpdGxlRWxlbWVudCIsInNoYXBlc1VsRWxlbWVudCIsInNoYXBlIiwic2hhcGVMaUVsZW1lbnQiLCJuYW1lIiwic2hhcGVJbWFnZUVsZW1lbnQiLCJzcmMiLCJ1cmkiLCJleCIsImV5IiwiY3giLCJjeSIsImR5IiwiZHgiLCJ0aGV0YSIsIk1hdGgiLCJhdGFuMiIsIlBJIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNy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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0NBQXNDO0FBQzNDO0FBQ0EsS0FBSyx1Q0FBdUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzQ0FBc0M7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxL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QUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSwyREFBMkQ7QUFDMUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSw2RUFBNkU7QUFDNUYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSx1SUFBdUk7QUFDdEosS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCO0FBQ2xCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLE9BQU87QUFDbkQ7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLE9BQU87O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZEQUE2RCxPQUFPO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsT0FBTztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0QsT0FBTzs7QUFFL0Q7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEsc0RBQXNELE9BQU87QUFDN0QsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxPQUFPOztBQUV6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCLE9BQU87QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxpR0FBaUc7QUFDakc7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixPQUFPO0FBQ2hDOztBQUVBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsWUFBWTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTzs7QUFFOUI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZTtBQUNmO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUIsV0FBVztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFlBQVk7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUUsVUFBVTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCx1QkFBdUIsaUJBQWlCO0FBQ3hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBOztBQUVBLDhDQUE4QyxPQUFPO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFlBQVk7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLE9BQU87O0FBRW5EO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDs7QUFFQTs7QUFFQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFdBQVc7O0FBRXBDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsWUFBWTs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4SEFBOEg7QUFDOUg7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFFBQVE7QUFDaEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEscUJBQXFCLDZDQUE2QztBQUNsRTs7QUFFQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVgsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLFlBQVksWUFBWTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELE9BQU87QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBOztBQUVBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQyx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsMkNBQTJDLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUU7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQsT0FBTztBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0NBQWtDO0FBQ2xDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSxrSUFBa0k7QUFDako7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLDJLQUEySztBQUMxTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSxrSUFBa0k7QUFDako7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsc0RBQXNELGNBQWM7QUFDcEU7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pEO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixVQUFjO0FBQ2hDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0RBQU87QUFDL0IsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxJQUF5QyxTQUFTLGlDQUFPLENBQUMsT0FBUyxDQUFDLG9DQUFFLEdBQUc7QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDdEYsMENBQTBDO0FBQzFDLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixrQkFBa0I7QUFDaEQsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRGQUE0RjtBQUM1Riw4QkFBOEI7O0FBRTlCLDJCQUEyQixnQkFBZ0I7O0FBRTNDLDhCQUE4QixhQUFhO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQ0FBcUM7O0FBRXJDLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDSUgsUUFBSSxFQUFFckssaURBQU0sQ0FBQ0UsV0FEakI7QUFFSXNLLE9BQUcsRUFBRTtBQUZULEdBN0NJLEVBaURKO0FBQ0lILFFBQUksRUFBRXJLLGlEQUFNLENBQUNHLFdBRGpCO0FBRUlxSyxPQUFHLEVBQUU7QUFGVCxHQWpESSxFQXFESjtBQUNJSCxRQUFJLEVBQUVySyxpREFBTSxDQUFDSyxXQURqQjtBQUVJbUssT0FBRyxFQUFFO0FBRlQsR0FyREksRUF5REo7QUFDSUgsUUFBSSxFQUFFckssaURBQU0sQ0FBQ2UsTUFEakI7QUFFSXlKLE9BQUcsRUFBRTtBQUZULEdBekRJLEVBNkRKO0FBQ0lILFFBQUksRUFBRXJLLGlEQUFNLENBQUNXLE1BRGpCO0FBRUk2SixPQUFHLEVBQUU7QUFGVCxHQTdESTtBQUZYLENBRG9CLENBQXJCO0FBd0VlL1AsMEVBQWYsRTs7Ozs7Ozs7Ozs7O0FDMUVBO0FBQUE7QUFBTyxTQUFTZ0ssV0FBVCxDQUFxQmdHLEVBQXJCLEVBQXdCQyxFQUF4QixFQUEyQkMsRUFBM0IsRUFBOEJDLEVBQTlCLEVBQWtDO0FBQ3ZDLE1BQUlDLEVBQUUsR0FBR0gsRUFBRSxHQUFHRSxFQUFkO0FBQ0EsTUFBSUUsRUFBRSxHQUFHTCxFQUFFLEdBQUdFLEVBQWQ7QUFDQSxNQUFJSSxLQUFLLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXSixFQUFYLEVBQWVDLEVBQWYsQ0FBWjtBQUNBQyxPQUFLLElBQUksTUFBTUMsSUFBSSxDQUFDRSxFQUFwQjtBQUNBLFNBQU9ILEtBQVA7QUFDRCxDOzs7Ozs7Ozs7OztBQ05ELHVDOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZSIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvZGlzdC9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCIvLyBSZXNlcnZlZCB3b3JkIGxpc3RzIGZvciB2YXJpb3VzIGRpYWxlY3RzIG9mIHRoZSBsYW5ndWFnZVxuXG52YXIgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gIDU6IFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIixcbiAgNjogXCJlbnVtXCIsXG4gIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gIHN0cmljdEJpbmQ6IFwiZXZhbCBhcmd1bWVudHNcIlxufTtcblxuLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG52YXIgZWNtYTVBbmRMZXNzS2V5d29yZHMgPSBcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiO1xuXG52YXIga2V5d29yZHMgPSB7XG4gIDU6IGVjbWE1QW5kTGVzc0tleXdvcmRzLFxuICBcIjVtb2R1bGVcIjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBleHBvcnQgaW1wb3J0XCIsXG4gIDY6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHN1cGVyXCJcbn07XG5cbnZhciBrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yID0gL15pbihzdGFuY2VvZik/JC87XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuLy8gR2VuZXJhdGVkIGJ5IGBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwOGEwLVxcdTA4YjRcXHUwOGI2LVxcdTA4YmRcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDU0LVxcdTBkNTZcXHUwZDVmLVxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg2LVxcdTBlOGFcXHUwZThjLVxcdTBlYTNcXHUwZWE1XFx1MGVhNy1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjVcXHUxM2Y4LVxcdTEzZmRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjhcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWVcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWIwLVxcdTE5YzlcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxYzgwLVxcdTFjODhcXHUxYzkwLVxcdTFjYmFcXHUxY2JkLVxcdTFjYmZcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjNcXHUxY2Y1XFx1MWNmNlxcdTFjZmFcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDliLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmZcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmZWZcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5ZFxcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTdiZlxcdWE3YzItXFx1YTdjNlxcdWE3ZjctXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOGZkXFx1YThmZVxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjdcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDdmZFxcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4ZDMtXFx1MDhlMVxcdTA4ZTMtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MDlmZVxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGFmYS1cXHUwYWZmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMC1cXHUwZDAzXFx1MGQzYlxcdTBkM2NcXHUwZDNlLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmOVxcdTFkZmItXFx1MWRmZlxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODBcXHVhODgxXFx1YThiNC1cXHVhOGM1XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGYxXFx1YThmZi1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUzXFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YTlkMC1cXHVhOWQ5XFx1YTllNVxcdWE5ZjAtXFx1YTlmOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2ItXFx1YWE3ZFxcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFhZWItXFx1YWFlZlxcdWFhZjVcXHVhYWY2XFx1YWJlMy1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IG51bGw7XG5cbi8vIFRoZXNlIGFyZSBhIHJ1bi1sZW5ndGggYW5kIG9mZnNldCBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuLy8gPjB4ZmZmZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBhIHZhbGlkIHBhcnQgb2YgaWRlbnRpZmllcnMuIFRoZVxuLy8gb2Zmc2V0IHN0YXJ0cyBhdCAweDEwMDAwLCBhbmQgZWFjaCBwYWlyIG9mIG51bWJlcnMgcmVwcmVzZW50cyBhblxuLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IHJhbmdlLCBhbmQgdGhlbiBhIHNpemUgb2YgdGhlIHJhbmdlLiBUaGV5IHdlcmVcbi8vIGdlbmVyYXRlZCBieSBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xudmFyIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsMTEsMiwyNSwyLDE4LDIsMSwyLDE0LDMsMTMsMzUsMTIyLDcwLDUyLDI2OCwyOCw0LDQ4LDQ4LDMxLDE0LDI5LDYsMzcsMTEsMjksMywzNSw1LDcsMiw0LDQzLDE1NywxOSwzNSw1LDM1LDUsMzksOSw1MSwxNTcsMzEwLDEwLDIxLDExLDcsMTUzLDUsMywwLDIsNDMsMiwxLDQsMCwzLDIyLDExLDIyLDEwLDMwLDY2LDE4LDIsMSwxMSwyMSwxMSwyNSw3MSw1NSw3LDEsNjUsMCwxNiwzLDIsMiwyLDI4LDQzLDI4LDQsMjgsMzYsNywyLDI3LDI4LDUzLDExLDIxLDExLDE4LDE0LDE3LDExMSw3Miw1Niw1MCwxNCw1MCwxNCwzNSw0NzcsMjgsMTEsMCw5LDIxLDE1NSwyMiwxMyw1Miw3Niw0NCwzMywyNCwyNywzNSwzMCwwLDEyLDM0LDQsMCwxMyw0NywxNSwzLDIyLDAsMiwwLDM2LDE3LDIsMjQsODUsNiwyLDAsMiwzLDIsMTQsMiw5LDgsNDYsMzksNywzLDEsMywyMSwyLDYsMiwxLDIsNCw0LDAsMTksMCwxMyw0LDE1OSw1MiwxOSwzLDIxLDAsMzMsNDcsMjEsMSwyLDAsMTg1LDQ2LDQyLDMsMzcsNDcsMjEsMCw2MCw0MiwxNCwwLDcyLDI2LDIzMCw0MywxMTcsNjMsMzIsMCwxNjEsNywzLDM4LDE3LDAsMiwwLDI5LDAsMTEsMzksOCwwLDIyLDAsMTIsNDUsMjAsMCwzNSw1NiwyNjQsOCwyLDM2LDE4LDAsNTAsMjksMTEzLDYsMiwxLDIsMzcsMjIsMCwyNiw1LDIsMSwyLDMxLDE1LDAsMzI4LDE4LDI3MCw5MjEsMTAzLDExMCwxOCwxOTUsMjc0OSwxMDcwLDQwNTAsNTgyLDg2MzQsNTY4LDgsMzAsMTE0LDI5LDE5LDQ3LDE3LDMsMzIsMjAsNiwxOCw2ODksNjMsMTI5LDc0LDYsMCw2NywxMiw2NSwxLDIsMCwyOSw2MTM1LDksNzU0LDk0ODYsMjg2LDUwLDIsMTgsMyw5LDM5NSwyMzA5LDEwNiw2LDEyLDQsOCw4LDksNTk5MSw4NCwyLDcwLDIsMSwzLDAsMywxLDMsMywyLDExLDIsMCwyLDYsMiw2NCwyLDMsMyw3LDIsNiwyLDI3LDIsMywyLDQsMiwwLDQsNiwyLDMzOSwzLDI0LDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsNywyMzU3LDQ0LDExLDYsMTcsMCwzNzAsNDMsMTMwMSwxOTYsNjAsNjcsOCwwLDEyMDUsMywyLDI2LDIsMSwyLDAsMywwLDIsOSwyLDMsMiwwLDIsMCw3LDAsNSwwLDIsMCwyLDAsMiwyLDIsMSwyLDAsMywwLDIsMCwyLDAsMiwwLDIsMCwyLDEsMiwwLDMsMywyLDYsMiwzLDIsMywyLDAsMiw5LDIsMTYsNiwyLDIsNCwyLDE2LDQ0MjEsNDI3MTAsNDIsNDE0OCwxMiwyMjEsMyw1NzYxLDE1LDc0NzIsMzEwNCw1NDFdO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xudmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksMCwyMjcsMCwxNTAsNCwyOTQsOSwxMzY4LDIsMiwxLDYsMyw0MSwyLDUsMCwxNjYsMSw1NzQsMyw5LDksNTI1LDEwLDE3NiwyLDU0LDE0LDMyLDksMTYsMyw0NiwxMCw1NCw5LDcsMiwzNywxMywyLDksNiwxLDQ1LDAsMTMsMiw0OSwxMyw5LDMsNCw5LDgzLDExLDcsMCwxNjEsMTEsNiw5LDcsMyw1NiwxLDIsNiwzLDEsMywyLDEwLDAsMTEsMSwzLDYsNCw0LDE5MywxNywxMCw5LDUsMCw4MiwxOSwxMyw5LDIxNCw2LDMsOCwyOCwxLDgzLDE2LDE2LDksODIsMTIsOSw5LDg0LDE0LDUsOSwyNDMsMTQsMTY2LDksMjMyLDYsMyw2LDQsMCwyOSw5LDQxLDYsMiwzLDksMCwxMCwxMCw0NywxNSw0MDYsNywyLDcsMTcsOSw1NywyMSwyLDEzLDEyMyw1LDQsMCwyLDEsMiw2LDIsMCw5LDksNDksNCwyLDEsMiw0LDksOSwzMzAsMywxOTMwNiw5LDEzNSw0LDYwLDYsMjYsOSwxMDE0LDAsMiw1NCw4LDMsMTk3MjMsMSw1MzE5LDQsNCw1LDksNywzLDYsMzEsMywxNDksMiwxNDE4LDQ5LDUxMyw1NCw1LDQ5LDksMCwxNSwwLDIzLDQsMiwxNCwxMzYxLDYsMiwxNiwzLDYsMiwxLDIsNCwyNjIsNiwxMCw5LDQxOSwxMywxNDk1LDYsMTEwLDYsNiw5LDc5MjQ4NywyMzldO1xuXG4vLyBUaGlzIGhhcyBhIGNvbXBsZXhpdHkgbGluZWFyIHRvIHRoZSB2YWx1ZSBvZiB0aGUgY29kZS4gVGhlXG4vLyBhc3N1bXB0aW9uIGlzIHRoYXQgbG9va2luZyB1cCBhc3RyYWwgaWRlbnRpZmllciBjaGFyYWN0ZXJzIGlzXG4vLyByYXJlLlxuZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgdmFyIHBvcyA9IDB4MTAwMDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcG9zICs9IHNldFtpXTtcbiAgICBpZiAocG9zID4gY29kZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgIGlmIChwb3MgPj0gY29kZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbn1cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIGFzdHJhbCkge1xuICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gIGlmIChjb2RlIDwgOTEpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8IDk3KSB7IHJldHVybiBjb2RlID09PSA5NSB9XG4gIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7IHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKVxufVxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgaXMgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUsIGFzdHJhbCkge1xuICBpZiAoY29kZSA8IDQ4KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gIGlmIChjb2RlIDwgNTgpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChjb2RlIDwgOTEpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8IDk3KSB7IHJldHVybiBjb2RlID09PSA5NSB9XG4gIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7IHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpXG59XG5cbi8vICMjIFRva2VuIHR5cGVzXG5cbi8vIFRoZSBhc3NpZ25tZW50IG9mIGZpbmUtZ3JhaW5lZCwgaW5mb3JtYXRpb24tY2FycnlpbmcgdHlwZSBvYmplY3RzXG4vLyBhbGxvd3MgdGhlIHRva2VuaXplciB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gaXQgaGFzIGFib3V0IGFcbi8vIHRva2VuIGluIGEgd2F5IHRoYXQgaXMgdmVyeSBjaGVhcCBmb3IgdGhlIHBhcnNlciB0byBsb29rIHVwLlxuXG4vLyBBbGwgdG9rZW4gdHlwZSB2YXJpYWJsZXMgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlLCB0byBtYWtlIHRoZW1cbi8vIGVhc3kgdG8gcmVjb2duaXplLlxuXG4vLyBUaGUgYGJlZm9yZUV4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gZGlzYW1iaWd1YXRlIGJldHdlZW4gcmVndWxhclxuLy8gZXhwcmVzc2lvbnMgYW5kIGRpdmlzaW9ucy4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGNhblxuLy8gYmUgZm9sbG93ZWQgYnkgYW4gZXhwcmVzc2lvbiAodGh1cywgYSBzbGFzaCBhZnRlciB0aGVtIHdvdWxkIGJlIGFcbi8vIHJlZ3VsYXIgZXhwcmVzc2lvbikuXG4vL1xuLy8gVGhlIGBzdGFydHNFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGNoZWNrIGlmIHRoZSB0b2tlbiBlbmRzIGFcbi8vIGB5aWVsZGAgZXhwcmVzc2lvbi4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGVpdGhlciBjYW5cbi8vIGRpcmVjdGx5IHN0YXJ0IGFuIGV4cHJlc3Npb24gKGxpa2UgYSBxdW90YXRpb24gbWFyaykgb3IgY2FuXG4vLyBjb250aW51ZSBhbiBleHByZXNzaW9uIChsaWtlIHRoZSBib2R5IG9mIGEgc3RyaW5nKS5cbi8vXG4vLyBgaXNMb29wYCBtYXJrcyBhIGtleXdvcmQgYXMgc3RhcnRpbmcgYSBsb29wLCB3aGljaCBpcyBpbXBvcnRhbnRcbi8vIHRvIGtub3cgd2hlbiBwYXJzaW5nIGEgbGFiZWwsIGluIG9yZGVyIHRvIGFsbG93IG9yIGRpc2FsbG93XG4vLyBjb250aW51ZSBqdW1wcyB0byB0aGF0IGxhYmVsLlxuXG52YXIgVG9rZW5UeXBlID0gZnVuY3Rpb24gVG9rZW5UeXBlKGxhYmVsLCBjb25mKSB7XG4gIGlmICggY29uZiA9PT0gdm9pZCAwICkgY29uZiA9IHt9O1xuXG4gIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICB0aGlzLmJlZm9yZUV4cHIgPSAhIWNvbmYuYmVmb3JlRXhwcjtcbiAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHI7XG4gIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgdGhpcy5pc0Fzc2lnbiA9ICEhY29uZi5pc0Fzc2lnbjtcbiAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4O1xuICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgdGhpcy5iaW5vcCA9IGNvbmYuYmlub3AgfHwgbnVsbDtcbiAgdGhpcy51cGRhdGVDb250ZXh0ID0gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGJpbm9wKG5hbWUsIHByZWMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlblR5cGUobmFtZSwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiBwcmVjfSlcbn1cbnZhciBiZWZvcmVFeHByID0ge2JlZm9yZUV4cHI6IHRydWV9LCBzdGFydHNFeHByID0ge3N0YXJ0c0V4cHI6IHRydWV9O1xuXG4vLyBNYXAga2V5d29yZCBuYW1lcyB0byB0b2tlbiB0eXBlcy5cblxudmFyIGtleXdvcmRzJDEgPSB7fTtcblxuLy8gU3VjY2luY3QgZGVmaW5pdGlvbnMgb2Yga2V5d29yZCB0b2tlbiB0eXBlc1xuZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuICByZXR1cm4ga2V5d29yZHMkMVtuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucylcbn1cblxudmFyIHR5cGVzID0ge1xuICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHN0YXJ0c0V4cHIpLFxuICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgZW9mOiBuZXcgVG9rZW5UeXBlKFwiZW9mXCIpLFxuXG4gIC8vIFB1bmN0dWF0aW9uIHRva2VuIHR5cGVzLlxuICBicmFja2V0TDogbmV3IFRva2VuVHlwZShcIltcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgYnJhY2tldFI6IG5ldyBUb2tlblR5cGUoXCJdXCIpLFxuICBicmFjZUw6IG5ldyBUb2tlblR5cGUoXCJ7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGJyYWNlUjogbmV3IFRva2VuVHlwZShcIn1cIiksXG4gIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgcGFyZW5SOiBuZXcgVG9rZW5UeXBlKFwiKVwiKSxcbiAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIGJlZm9yZUV4cHIpLFxuICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCBiZWZvcmVFeHByKSxcbiAgY29sb246IG5ldyBUb2tlblR5cGUoXCI6XCIsIGJlZm9yZUV4cHIpLFxuICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgYmVmb3JlRXhwciksXG4gIGFycm93OiBuZXcgVG9rZW5UeXBlKFwiPT5cIiwgYmVmb3JlRXhwciksXG4gIHRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwidGVtcGxhdGVcIiksXG4gIGludmFsaWRUZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcImludmFsaWRUZW1wbGF0ZVwiKSxcbiAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgYmVmb3JlRXhwciksXG4gIGJhY2tRdW90ZTogbmV3IFRva2VuVHlwZShcImBcIiwgc3RhcnRzRXhwciksXG4gIGRvbGxhckJyYWNlTDogbmV3IFRva2VuVHlwZShcIiR7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG5cbiAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgLy8gcGFyc2VyIHVzZSB0aGVtIHByb3Blcmx5ICh0aGUgcHJlc2VuY2Ugb2YgdGhlc2UgcHJvcGVydGllcyBpc1xuICAvLyB3aGF0IGNhdGVnb3JpemVzIHRoZW0gYXMgb3BlcmF0b3JzKS5cbiAgLy9cbiAgLy8gYGJpbm9wYCwgd2hlbiBwcmVzZW50LCBzcGVjaWZpZXMgdGhhdCB0aGlzIG9wZXJhdG9yIGlzIGEgYmluYXJ5XG4gIC8vIG9wZXJhdG9yLCBhbmQgd2lsbCByZWZlciB0byBpdHMgcHJlY2VkZW5jZS5cbiAgLy9cbiAgLy8gYHByZWZpeGAgYW5kIGBwb3N0Zml4YCBtYXJrIHRoZSBvcGVyYXRvciBhcyBhIHByZWZpeCBvciBwb3N0Zml4XG4gIC8vIHVuYXJ5IG9wZXJhdG9yLlxuICAvL1xuICAvLyBgaXNBc3NpZ25gIG1hcmtzIGFsbCBvZiBgPWAsIGArPWAsIGAtPWAgZXRjZXRlcmEsIHdoaWNoIGFjdCBhc1xuICAvLyBiaW5hcnkgb3BlcmF0b3JzIHdpdGggYSB2ZXJ5IGxvdyBwcmVjZWRlbmNlLCB0aGF0IHNob3VsZCByZXN1bHRcbiAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgZXE6IG5ldyBUb2tlblR5cGUoXCI9XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICBhc3NpZ246IG5ldyBUb2tlblR5cGUoXCJfPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwge3ByZWZpeDogdHJ1ZSwgcG9zdGZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBwcmVmaXg6IG5ldyBUb2tlblR5cGUoXCIhL35cIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBsb2dpY2FsT1I6IGJpbm9wKFwifHxcIiwgMSksXG4gIGxvZ2ljYWxBTkQ6IGJpbm9wKFwiJiZcIiwgMiksXG4gIGJpdHdpc2VPUjogYmlub3AoXCJ8XCIsIDMpLFxuICBiaXR3aXNlWE9SOiBiaW5vcChcIl5cIiwgNCksXG4gIGJpdHdpc2VBTkQ6IGJpbm9wKFwiJlwiLCA1KSxcbiAgZXF1YWxpdHk6IGJpbm9wKFwiPT0vIT0vPT09LyE9PVwiLCA2KSxcbiAgcmVsYXRpb25hbDogYmlub3AoXCI8Lz4vPD0vPj1cIiwgNyksXG4gIGJpdFNoaWZ0OiBiaW5vcChcIjw8Lz4+Lz4+PlwiLCA4KSxcbiAgcGx1c01pbjogbmV3IFRva2VuVHlwZShcIisvLVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDksIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBtb2R1bG86IGJpbm9wKFwiJVwiLCAxMCksXG4gIHN0YXI6IGJpbm9wKFwiKlwiLCAxMCksXG4gIHNsYXNoOiBiaW5vcChcIi9cIiwgMTApLFxuICBzdGFyc3RhcjogbmV3IFRva2VuVHlwZShcIioqXCIsIHtiZWZvcmVFeHByOiB0cnVlfSksXG5cbiAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgX2JyZWFrOiBrdyhcImJyZWFrXCIpLFxuICBfY2FzZToga3coXCJjYXNlXCIsIGJlZm9yZUV4cHIpLFxuICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gIF9jb250aW51ZToga3coXCJjb250aW51ZVwiKSxcbiAgX2RlYnVnZ2VyOiBrdyhcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICBfZG86IGt3KFwiZG9cIiwge2lzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0pLFxuICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICBfZm9yOiBrdyhcImZvclwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF9mdW5jdGlvbjoga3coXCJmdW5jdGlvblwiLCBzdGFydHNFeHByKSxcbiAgX2lmOiBrdyhcImlmXCIpLFxuICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgX3N3aXRjaDoga3coXCJzd2l0Y2hcIiksXG4gIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgX3RyeToga3coXCJ0cnlcIiksXG4gIF92YXI6IGt3KFwidmFyXCIpLFxuICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gIF93aGlsZToga3coXCJ3aGlsZVwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF93aXRoOiBrdyhcIndpdGhcIiksXG4gIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF90aGlzOiBrdyhcInRoaXNcIiwgc3RhcnRzRXhwciksXG4gIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgX2NsYXNzOiBrdyhcImNsYXNzXCIsIHN0YXJ0c0V4cHIpLFxuICBfZXh0ZW5kczoga3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpLFxuICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiwgc3RhcnRzRXhwciksXG4gIF9udWxsOiBrdyhcIm51bGxcIiwgc3RhcnRzRXhwciksXG4gIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgX2luOiBrdyhcImluXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfaW5zdGFuY2VvZjoga3coXCJpbnN0YW5jZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF92b2lkOiBrdyhcInZvaWRcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfZGVsZXRlOiBrdyhcImRlbGV0ZVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSlcbn07XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG52YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG52YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiBpc05ld0xpbmUoY29kZSwgZWNtYTIwMTlTdHJpbmcpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwIHx8IGNvZGUgPT09IDEzIHx8ICghZWNtYTIwMTlTdHJpbmcgJiYgKGNvZGUgPT09IDB4MjAyOCB8fCBjb2RlID09PSAweDIwMjkpKVxufVxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuXG52YXIgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcblxudmFyIHJlZiA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSByZWYudG9TdHJpbmc7XG5cbi8vIENoZWNrcyBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuXG5cbmZ1bmN0aW9uIGhhcyhvYmosIHByb3BOYW1lKSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcE5hbWUpXG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gKFxuICB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIlxuKTsgfSk7XG5cbmZ1bmN0aW9uIHdvcmRzUmVnZXhwKHdvcmRzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMucmVwbGFjZSgvIC9nLCBcInxcIikgKyBcIikkXCIpXG59XG5cbi8vIFRoZXNlIGFyZSB1c2VkIHdoZW4gYG9wdGlvbnMubG9jYXRpb25zYCBpcyBvbiwgZm9yIHRoZVxuLy8gYHN0YXJ0TG9jYCBhbmQgYGVuZExvY2AgcHJvcGVydGllcy5cblxudmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gIHRoaXMubGluZSA9IGxpbmU7XG4gIHRoaXMuY29sdW1uID0gY29sO1xufTtcblxuUG9zaXRpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCAobikge1xuICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxufTtcblxudmFyIFNvdXJjZUxvY2F0aW9uID0gZnVuY3Rpb24gU291cmNlTG9jYXRpb24ocCwgc3RhcnQsIGVuZCkge1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuZW5kID0gZW5kO1xuICBpZiAocC5zb3VyY2VGaWxlICE9PSBudWxsKSB7IHRoaXMuc291cmNlID0gcC5zb3VyY2VGaWxlOyB9XG59O1xuXG4vLyBUaGUgYGdldExpbmVJbmZvYCBmdW5jdGlvbiBpcyBtb3N0bHkgdXNlZnVsIHdoZW4gdGhlXG4vLyBgbG9jYXRpb25zYCBvcHRpb24gaXMgb2ZmIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykgYW5kIHlvdVxuLy8gd2FudCB0byBmaW5kIHRoZSBsaW5lL2NvbHVtbiBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbi8vIG9mZnNldC4gYGlucHV0YCBzaG91bGQgYmUgdGhlIGNvZGUgc3RyaW5nIHRoYXQgdGhlIG9mZnNldCByZWZlcnNcbi8vIGludG8uXG5cbmZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgZm9yICh2YXIgbGluZSA9IDEsIGN1ciA9IDA7Oykge1xuICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gY3VyO1xuICAgIHZhciBtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyhpbnB1dCk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4IDwgb2Zmc2V0KSB7XG4gICAgICArK2xpbmU7XG4gICAgICBjdXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBjdXIpXG4gICAgfVxuICB9XG59XG5cbi8vIEEgc2Vjb25kIG9wdGlvbmFsIGFyZ3VtZW50IGNhbiBiZSBnaXZlbiB0byBmdXJ0aGVyIGNvbmZpZ3VyZVxuLy8gdGhlIHBhcnNlciBwcm9jZXNzLiBUaGVzZSBvcHRpb25zIGFyZSByZWNvZ25pemVkOlxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8vIGBlY21hVmVyc2lvbmAgaW5kaWNhdGVzIHRoZSBFQ01BU2NyaXB0IHZlcnNpb24gdG8gcGFyc2UuIE11c3QgYmVcbiAgLy8gZWl0aGVyIDMsIDUsIDYgKDIwMTUpLCA3ICgyMDE2KSwgOCAoMjAxNyksIDkgKDIwMTgpLCBvciAxMFxuICAvLyAoMjAxOSkuIFRoaXMgaW5mbHVlbmNlcyBzdXBwb3J0IGZvciBzdHJpY3QgbW9kZSwgdGhlIHNldCBvZlxuICAvLyByZXNlcnZlZCB3b3JkcywgYW5kIHN1cHBvcnQgZm9yIG5ldyBzeW50YXggZmVhdHVyZXMuIFRoZSBkZWZhdWx0XG4gIC8vIGlzIDkuXG4gIGVjbWFWZXJzaW9uOiA5LFxuICAvLyBgc291cmNlVHlwZWAgaW5kaWNhdGVzIHRoZSBtb2RlIHRoZSBjb2RlIHNob3VsZCBiZSBwYXJzZWQgaW4uXG4gIC8vIENhbiBiZSBlaXRoZXIgYFwic2NyaXB0XCJgIG9yIGBcIm1vZHVsZVwiYC4gVGhpcyBpbmZsdWVuY2VzIGdsb2JhbFxuICAvLyBzdHJpY3QgbW9kZSBhbmQgcGFyc2luZyBvZiBgaW1wb3J0YCBhbmQgYGV4cG9ydGAgZGVjbGFyYXRpb25zLlxuICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAvLyBgb25JbnNlcnRlZFNlbWljb2xvbmAgY2FuIGJlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZFxuICAvLyB3aGVuIGEgc2VtaWNvbG9uIGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQuIEl0IHdpbGwgYmUgcGFzc2VkXG4gIC8vIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29tbWEgYXMgYW4gb2Zmc2V0LCBhbmQgaWYgYGxvY2F0aW9uc2AgaXNcbiAgLy8gZW5hYmxlZCwgaXQgaXMgZ2l2ZW4gdGhlIGxvY2F0aW9uIGFzIGEgYHtsaW5lLCBjb2x1bW59YCBvYmplY3RcbiAgLy8gYXMgc2Vjb25kIGFyZ3VtZW50LlxuICBvbkluc2VydGVkU2VtaWNvbG9uOiBudWxsLFxuICAvLyBgb25UcmFpbGluZ0NvbW1hYCBpcyBzaW1pbGFyIHRvIGBvbkluc2VydGVkU2VtaWNvbG9uYCwgYnV0IGZvclxuICAvLyB0cmFpbGluZyBjb21tYXMuXG4gIG9uVHJhaWxpbmdDb21tYTogbnVsbCxcbiAgLy8gQnkgZGVmYXVsdCwgcmVzZXJ2ZWQgd29yZHMgYXJlIG9ubHkgZW5mb3JjZWQgaWYgZWNtYVZlcnNpb24gPj0gNS5cbiAgLy8gU2V0IGBhbGxvd1Jlc2VydmVkYCB0byBhIGJvb2xlYW4gdmFsdWUgdG8gZXhwbGljaXRseSB0dXJuIHRoaXMgb25cbiAgLy8gYW4gb2ZmLiBXaGVuIHRoaXMgb3B0aW9uIGhhcyB0aGUgdmFsdWUgXCJuZXZlclwiLCByZXNlcnZlZCB3b3Jkc1xuICAvLyBhbmQga2V5d29yZHMgY2FuIGFsc28gbm90IGJlIHVzZWQgYXMgcHJvcGVydHkgbmFtZXMuXG4gIGFsbG93UmVzZXJ2ZWQ6IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgYSByZXR1cm4gYXQgdGhlIHRvcCBsZXZlbCBpcyBub3QgY29uc2lkZXJlZCBhblxuICAvLyBlcnJvci5cbiAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAvLyBXaGVuIGVuYWJsZWQsIGltcG9ydC9leHBvcnQgc3RhdGVtZW50cyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gIC8vIGFwcGVhcmluZyBhdCB0aGUgdG9wIG9mIHRoZSBwcm9ncmFtLlxuICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IGZhbHNlLFxuICAvLyBXaGVuIGVuYWJsZWQsIGF3YWl0IGlkZW50aWZpZXJzIGFyZSBhbGxvd2VkIHRvIGFwcGVhciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlLFxuICAvLyBidXQgdGhleSBhcmUgc3RpbGwgbm90IGFsbG93ZWQgaW4gbm9uLWFzeW5jIGZ1bmN0aW9ucy5cbiAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gZW5hYmxlZCwgaGFzaGJhbmcgZGlyZWN0aXZlIGluIHRoZSBiZWdpbm5pbmcgb2YgZmlsZVxuICAvLyBpcyBhbGxvd2VkIGFuZCB0cmVhdGVkIGFzIGEgbGluZSBjb21tZW50LlxuICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgYGxvY2AgcHJvcGVydGllcyBob2xkaW5nIG9iamVjdHMgd2l0aFxuICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIGluIGB7bGluZSwgY29sdW1ufWAgZm9ybSAod2l0aFxuICAvLyBsaW5lIGJlaW5nIDEtYmFzZWQgYW5kIGNvbHVtbiAwLWJhc2VkKSB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZVxuICAvLyBub2Rlcy5cbiAgbG9jYXRpb25zOiBmYWxzZSxcbiAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvblRva2VuYCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggb2JqZWN0IGluIHRoZSBzYW1lXG4gIC8vIGZvcm1hdCBhcyB0b2tlbnMgcmV0dXJuZWQgZnJvbSBgdG9rZW5pemVyKCkuZ2V0VG9rZW4oKWAuIE5vdGVcbiAgLy8gdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlIHBhcnNlciBmcm9tIHRoZVxuICAvLyBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgb25Ub2tlbjogbnVsbCxcbiAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvbkNvbW1lbnRgIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBgKGJsb2NrLCB0ZXh0LCBzdGFydCxcbiAgLy8gZW5kKWAgcGFyYW1ldGVycyB3aGVuZXZlciBhIGNvbW1lbnQgaXMgc2tpcHBlZC4gYGJsb2NrYCBpcyBhXG4gIC8vIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgaXMgYSBibG9jayAoYC8qICovYCkgY29tbWVudCxcbiAgLy8gYHRleHRgIGlzIHRoZSBjb250ZW50IG9mIHRoZSBjb21tZW50LCBhbmQgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlXG4gIC8vIGNoYXJhY3RlciBvZmZzZXRzIHRoYXQgZGVub3RlIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBjb21tZW50LlxuICAvLyBXaGVuIHRoZSBgbG9jYXRpb25zYCBvcHRpb24gaXMgb24sIHR3byBtb3JlIHBhcmFtZXRlcnMgYXJlXG4gIC8vIHBhc3NlZCwgdGhlIGZ1bGwgYHtsaW5lLCBjb2x1bW59YCBsb2NhdGlvbnMgb2YgdGhlIHN0YXJ0IGFuZFxuICAvLyBlbmQgb2YgdGhlIGNvbW1lbnRzLiBOb3RlIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZVxuICAvLyBwYXJzZXIgZnJvbSB0aGUgY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gIG9uQ29tbWVudDogbnVsbCxcbiAgLy8gTm9kZXMgaGF2ZSB0aGVpciBzdGFydCBhbmQgZW5kIGNoYXJhY3RlcnMgb2Zmc2V0cyByZWNvcmRlZCBpblxuICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIChkaXJlY3RseSBvbiB0aGUgbm9kZSwgcmF0aGVyIHRoYW5cbiAgLy8gdGhlIGBsb2NgIG9iamVjdCwgd2hpY2ggaG9sZHMgbGluZS9jb2x1bW4gZGF0YS4gVG8gYWxzbyBhZGQgYVxuICAvLyBbc2VtaS1zdGFuZGFyZGl6ZWRdW3JhbmdlXSBgcmFuZ2VgIHByb3BlcnR5IGhvbGRpbmcgYSBgW3N0YXJ0LFxuICAvLyBlbmRdYCBhcnJheSB3aXRoIHRoZSBzYW1lIG51bWJlcnMsIHNldCB0aGUgYHJhbmdlc2Agb3B0aW9uIHRvXG4gIC8vIGB0cnVlYC5cbiAgLy9cbiAgLy8gW3JhbmdlXTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzQ1Njc4XG4gIHJhbmdlczogZmFsc2UsXG4gIC8vIEl0IGlzIHBvc3NpYmxlIHRvIHBhcnNlIG11bHRpcGxlIGZpbGVzIGludG8gYSBzaW5nbGUgQVNUIGJ5XG4gIC8vIHBhc3NpbmcgdGhlIHRyZWUgcHJvZHVjZWQgYnkgcGFyc2luZyB0aGUgZmlyc3QgZmlsZSBhc1xuICAvLyBgcHJvZ3JhbWAgb3B0aW9uIGluIHN1YnNlcXVlbnQgcGFyc2VzLiBUaGlzIHdpbGwgYWRkIHRoZVxuICAvLyB0b3BsZXZlbCBmb3JtcyBvZiB0aGUgcGFyc2VkIGZpbGUgdG8gdGhlIGBQcm9ncmFtYCAodG9wKSBub2RlXG4gIC8vIG9mIGFuIGV4aXN0aW5nIHBhcnNlIHRyZWUuXG4gIHByb2dyYW06IG51bGwsXG4gIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIHlvdSBjYW4gcGFzcyB0aGlzIHRvIHJlY29yZCB0aGUgc291cmNlXG4gIC8vIGZpbGUgaW4gZXZlcnkgbm9kZSdzIGBsb2NgIG9iamVjdC5cbiAgc291cmNlRmlsZTogbnVsbCxcbiAgLy8gVGhpcyB2YWx1ZSwgaWYgZ2l2ZW4sIGlzIHN0b3JlZCBpbiBldmVyeSBub2RlLCB3aGV0aGVyXG4gIC8vIGBsb2NhdGlvbnNgIGlzIG9uIG9yIG9mZi5cbiAgZGlyZWN0U291cmNlRmlsZTogbnVsbCxcbiAgLy8gV2hlbiBlbmFibGVkLCBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25zIGFyZSByZXByZXNlbnRlZCBieVxuICAvLyAobm9uLXN0YW5kYXJkKSBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiBub2Rlc1xuICBwcmVzZXJ2ZVBhcmVuczogZmFsc2Vcbn07XG5cbi8vIEludGVycHJldCBhbmQgZGVmYXVsdCBhbiBvcHRpb25zIG9iamVjdFxuXG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpXG4gICAgeyBvcHRpb25zW29wdF0gPSBvcHRzICYmIGhhcyhvcHRzLCBvcHQpID8gb3B0c1tvcHRdIDogZGVmYXVsdE9wdGlvbnNbb3B0XTsgfVxuXG4gIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDIwMTUpXG4gICAgeyBvcHRpb25zLmVjbWFWZXJzaW9uIC09IDIwMDk7IH1cblxuICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpXG4gICAgeyBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPSBvcHRpb25zLmVjbWFWZXJzaW9uIDwgNTsgfVxuXG4gIGlmIChpc0FycmF5KG9wdGlvbnMub25Ub2tlbikpIHtcbiAgICB2YXIgdG9rZW5zID0gb3B0aW9ucy5vblRva2VuO1xuICAgIG9wdGlvbnMub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW5zLnB1c2godG9rZW4pOyB9O1xuICB9XG4gIGlmIChpc0FycmF5KG9wdGlvbnMub25Db21tZW50KSlcbiAgICB7IG9wdGlvbnMub25Db21tZW50ID0gcHVzaENvbW1lbnQob3B0aW9ucywgb3B0aW9ucy5vbkNvbW1lbnQpOyB9XG5cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcHVzaENvbW1lbnQob3B0aW9ucywgYXJyYXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICB0eXBlOiBibG9jayA/IFwiQmxvY2tcIiA6IFwiTGluZVwiLFxuICAgICAgdmFsdWU6IHRleHQsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyBjb21tZW50LmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBzdGFydExvYywgZW5kTG9jKTsgfVxuICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgIHsgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTsgfVxuICAgIGFycmF5LnB1c2goY29tbWVudCk7XG4gIH1cbn1cblxuLy8gRWFjaCBzY29wZSBnZXRzIGEgYml0c2V0IHRoYXQgbWF5IGNvbnRhaW4gdGhlc2UgZmxhZ3NcbnZhclxuICAgIFNDT1BFX1RPUCA9IDEsXG4gICAgU0NPUEVfRlVOQ1RJT04gPSAyLFxuICAgIFNDT1BFX1ZBUiA9IFNDT1BFX1RPUCB8IFNDT1BFX0ZVTkNUSU9OLFxuICAgIFNDT1BFX0FTWU5DID0gNCxcbiAgICBTQ09QRV9HRU5FUkFUT1IgPSA4LFxuICAgIFNDT1BFX0FSUk9XID0gMTYsXG4gICAgU0NPUEVfU0lNUExFX0NBVENIID0gMzIsXG4gICAgU0NPUEVfU1VQRVIgPSA2NCxcbiAgICBTQ09QRV9ESVJFQ1RfU1VQRVIgPSAxMjg7XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoYXN5bmMsIGdlbmVyYXRvcikge1xuICByZXR1cm4gU0NPUEVfRlVOQ1RJT04gfCAoYXN5bmMgPyBTQ09QRV9BU1lOQyA6IDApIHwgKGdlbmVyYXRvciA/IFNDT1BFX0dFTkVSQVRPUiA6IDApXG59XG5cbi8vIFVzZWQgaW4gY2hlY2tMVmFsIGFuZCBkZWNsYXJlTmFtZSB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYSBiaW5kaW5nXG52YXJcbiAgICBCSU5EX05PTkUgPSAwLCAvLyBOb3QgYSBiaW5kaW5nXG4gICAgQklORF9WQVIgPSAxLCAvLyBWYXItc3R5bGUgYmluZGluZ1xuICAgIEJJTkRfTEVYSUNBTCA9IDIsIC8vIExldC0gb3IgY29uc3Qtc3R5bGUgYmluZGluZ1xuICAgIEJJTkRfRlVOQ1RJT04gPSAzLCAvLyBGdW5jdGlvbiBkZWNsYXJhdGlvblxuICAgIEJJTkRfU0lNUExFX0NBVENIID0gNCwgLy8gU2ltcGxlIChpZGVudGlmaWVyIHBhdHRlcm4pIGNhdGNoIGJpbmRpbmdcbiAgICBCSU5EX09VVFNJREUgPSA1OyAvLyBTcGVjaWFsIGNhc2UgZm9yIGZ1bmN0aW9uIG5hbWVzIGFzIGJvdW5kIGluc2lkZSB0aGUgZnVuY3Rpb25cblxudmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuc291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZTtcbiAgdGhpcy5rZXl3b3JkcyA9IHdvcmRzUmVnZXhwKGtleXdvcmRzW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIgPyBcIjVtb2R1bGVcIiA6IDVdKTtcbiAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gdHJ1ZSkge1xuICAgIGZvciAodmFyIHYgPSBvcHRpb25zLmVjbWFWZXJzaW9uOzsgdi0tKVxuICAgICAgeyBpZiAocmVzZXJ2ZWQgPSByZXNlcnZlZFdvcmRzW3ZdKSB7IGJyZWFrIH0gfVxuICAgIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIpIHsgcmVzZXJ2ZWQgKz0gXCIgYXdhaXRcIjsgfVxuICB9XG4gIHRoaXMucmVzZXJ2ZWRXb3JkcyA9IHdvcmRzUmVnZXhwKHJlc2VydmVkKTtcbiAgdmFyIHJlc2VydmVkU3RyaWN0ID0gKHJlc2VydmVkID8gcmVzZXJ2ZWQgKyBcIiBcIiA6IFwiXCIpICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3Q7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0ICsgXCIgXCIgKyByZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuICB0aGlzLmlucHV0ID0gU3RyaW5nKGlucHV0KTtcblxuICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgLy8gY29udGFpbmVkIGFueSBlc2NhcGUgc2VxdWVuY2VzLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHdvcmRzIHdpdGhcbiAgLy8gZXNjYXBlIHNlcXVlbmNlcyBtdXN0IG5vdCBiZSBpbnRlcnByZXRlZCBhcyBrZXl3b3Jkcy5cbiAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG4gIC8vIFNldCB1cCB0b2tlbiBzdGF0ZVxuXG4gIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuICBpZiAoc3RhcnRQb3MpIHtcbiAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcyAtIDEpICsgMTtcbiAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICB9XG5cbiAgLy8gUHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0b2tlbjpcbiAgLy8gSXRzIHR5cGVcbiAgdGhpcy50eXBlID0gdHlwZXMuZW9mO1xuICAvLyBGb3IgdG9rZW5zIHRoYXQgaW5jbHVkZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgdHlwZSwgdGhlIHZhbHVlXG4gIHRoaXMudmFsdWUgPSBudWxsO1xuICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAvLyBQb3NpdGlvbnMgdG8gZGVsYXllZC1jaGVjayB0aGF0IHlpZWxkL2F3YWl0IGRvZXMgbm90IGV4aXN0IGluIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgdGhpcy55aWVsZFBvcyA9IHRoaXMuYXdhaXRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gIHRoaXMubGFiZWxzID0gW107XG4gIC8vIFRodXMtZmFyIHVuZGVmaW5lZCBleHBvcnRzLlxuICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSB7fTtcblxuICAvLyBJZiBlbmFibGVkLCBza2lwIGxlYWRpbmcgaGFzaGJhbmcgbGluZS5cbiAgaWYgKHRoaXMucG9zID09PSAwICYmIG9wdGlvbnMuYWxsb3dIYXNoQmFuZyAmJiB0aGlzLmlucHV0LnNsaWNlKDAsIDIpID09PSBcIiMhXCIpXG4gICAgeyB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTsgfVxuXG4gIC8vIFNjb3BlIHRyYWNraW5nIGZvciBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMgKHNlZSBzY29wZS5qcylcbiAgdGhpcy5zY29wZVN0YWNrID0gW107XG4gIHRoaXMuZW50ZXJTY29wZShTQ09QRV9UT1ApO1xuXG4gIC8vIEZvciBSZWdFeHAgdmFsaWRhdGlvblxuICB0aGlzLnJlZ2V4cFN0YXRlID0gbnVsbDtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGluRnVuY3Rpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5HZW5lcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5Bc3luYzogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd1N1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93RGlyZWN0U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sdHJlYXRGdW5jdGlvbnNBc1ZhcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKCkge1xuICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dFRva2VuKCk7XG4gIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwobm9kZSlcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkZ1bmN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xucHJvdG90eXBlQWNjZXNzb3JzLmluR2VuZXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfR0VORVJBVE9SKSA+IDAgfTtcbnByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9O1xucHJvdG90eXBlQWNjZXNzb3JzLmFsbG93U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfU1VQRVIpID4gMCB9O1xucHJvdG90eXBlQWNjZXNzb3JzLmFsbG93RGlyZWN0U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDAgfTtcbnByb3RvdHlwZUFjY2Vzc29ycy50cmVhdEZ1bmN0aW9uc0FzVmFyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSkgfTtcblxuLy8gU3dpdGNoIHRvIGEgZ2V0dGVyIGZvciA3LjAuMC5cblBhcnNlci5wcm90b3R5cGUuaW5Ob25BcnJvd0Z1bmN0aW9uID0gZnVuY3Rpb24gaW5Ob25BcnJvd0Z1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA+IDAgfTtcblxuUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG4gICAgdmFyIHBsdWdpbnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgcGx1Z2luc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHZhciBjbHMgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHsgY2xzID0gcGx1Z2luc1tpXShjbHMpOyB9XG4gIHJldHVybiBjbHNcbn07XG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpLnBhcnNlKClcbn07XG5cblBhcnNlci5wYXJzZUV4cHJlc3Npb25BdCA9IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0IChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCwgcG9zKTtcbiAgcGFyc2VyLm5leHRUb2tlbigpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbigpXG59O1xuXG5QYXJzZXIudG9rZW5pemVyID0gZnVuY3Rpb24gdG9rZW5pemVyIChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggUGFyc2VyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBwcCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vICMjIFBhcnNlciB1dGlsaXRpZXNcblxudmFyIGxpdGVyYWwgPSAvXig/OicoKD86XFxcXC58W14nXSkqPyknfFwiKCg/OlxcXFwufFteXCJdKSo/KVwiKS87XG5wcC5zdHJpY3REaXJlY3RpdmUgPSBmdW5jdGlvbihzdGFydCkge1xuICBmb3IgKDs7KSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgc3RyaW5nIGxpdGVyYWwuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoID0gbGl0ZXJhbC5leGVjKHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQpKTtcbiAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKChtYXRjaFsxXSB8fCBtYXRjaFsyXSkgPT09IFwidXNlIHN0cmljdFwiKSB7IHJldHVybiB0cnVlIH1cbiAgICBzdGFydCArPSBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAvLyBTa2lwIHNlbWljb2xvbiwgaWYgYW55LlxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmlucHV0W3N0YXJ0XSA9PT0gXCI7XCIpXG4gICAgICB7IHN0YXJ0Kys7IH1cbiAgfVxufTtcblxuLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbi8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbnBwLmVhdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbi8vIFRlc3RzIHdoZXRoZXIgcGFyc2VkIHRva2VuIGlzIGEgY29udGV4dHVhbCBrZXl3b3JkLlxuXG5wcC5pc0NvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xufTtcblxuLy8gQ29uc3VtZXMgY29udGV4dHVhbCBrZXl3b3JkIGlmIHBvc3NpYmxlLlxuXG5wcC5lYXRDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKG5hbWUpKSB7IHJldHVybiBmYWxzZSB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gQXNzZXJ0cyB0aGF0IGZvbGxvd2luZyB0b2tlbiBpcyBnaXZlbiBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwLmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG4vLyBUZXN0IHdoZXRoZXIgYSBzZW1pY29sb24gY2FuIGJlIGluc2VydGVkIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXG5wcC5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMuZW9mIHx8XG4gICAgdGhpcy50eXBlID09PSB0eXBlcy5icmFjZVIgfHxcbiAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG59O1xuXG5wcC5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuLy8gcHJldGVuZCB0aGF0IHRoZXJlIGlzIGEgc2VtaWNvbG9uIGF0IHRoaXMgcG9zaXRpb24uXG5cbnBwLnNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZWF0KHR5cGVzLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG5wcC5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSlcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpOyB9XG4gICAgaWYgKCFub3ROZXh0KVxuICAgICAgeyB0aGlzLm5leHQoKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbi8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwLmV4cGVjdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdGhpcy5lYXQodHlwZSkgfHwgdGhpcy51bmV4cGVjdGVkKCk7XG59O1xuXG4vLyBSYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG5wcC51bmV4cGVjdGVkID0gZnVuY3Rpb24ocG9zKSB7XG4gIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG59O1xuXG5mdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICB0aGlzLnNob3J0aGFuZEFzc2lnbiA9XG4gIHRoaXMudHJhaWxpbmdDb21tYSA9XG4gIHRoaXMucGFyZW50aGVzaXplZEFzc2lnbiA9XG4gIHRoaXMucGFyZW50aGVzaXplZEJpbmQgPVxuICB0aGlzLmRvdWJsZVByb3RvID1cbiAgICAtMTtcbn1cblxucHAuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgaXNBc3NpZ24pIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPiAtMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gIGlmIChwYXJlbnMgPiAtMSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocGFyZW5zLCBcIlBhcmVudGhlc2l6ZWQgcGF0dGVyblwiKTsgfVxufTtcblxucHAuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBzaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgdmFyIGRvdWJsZVByb3RvID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90bztcbiAgaWYgKCFhbmRUaHJvdykgeyByZXR1cm4gc2hvcnRoYW5kQXNzaWduID49IDAgfHwgZG91YmxlUHJvdG8gPj0gMCB9XG4gIGlmIChzaG9ydGhhbmRBc3NpZ24gPj0gMClcbiAgICB7IHRoaXMucmFpc2Uoc2hvcnRoYW5kQXNzaWduLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpOyB9XG4gIGlmIChkb3VibGVQcm90byA+PSAwKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGRvdWJsZVByb3RvLCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbn07XG5cbnBwLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy55aWVsZFBvcyAmJiAoIXRoaXMuYXdhaXRQb3MgfHwgdGhpcy55aWVsZFBvcyA8IHRoaXMuYXdhaXRQb3MpKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLnlpZWxkUG9zLCBcIllpZWxkIGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICBpZiAodGhpcy5hd2FpdFBvcylcbiAgICB7IHRoaXMucmFpc2UodGhpcy5hd2FpdFBvcywgXCJBd2FpdCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbn07XG5cbnBwLmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICBpZiAoZXhwci50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgeyByZXR1cm4gdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByLmV4cHJlc3Npb24pIH1cbiAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxufTtcblxudmFyIHBwJDEgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuLy8gUGFyc2UgYSBwcm9ncmFtLiBJbml0aWFsaXplcyB0aGUgcGFyc2VyLCByZWFkcyBhbnkgbnVtYmVyIG9mXG4vLyBzdGF0ZW1lbnRzLCBhbmQgd3JhcHMgdGhlbSBpbiBhIFByb2dyYW0gbm9kZS4gIE9wdGlvbmFsbHkgdGFrZXMgYVxuLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuLy8gdG8gaXRzIGJvZHkgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBub2RlLlxuXG5wcCQxLnBhcnNlVG9wTGV2ZWwgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBleHBvcnRzID0ge307XG4gIGlmICghbm9kZS5ib2R5KSB7IG5vZGUuYm9keSA9IFtdOyB9XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLmVvZikge1xuICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsLCB0cnVlLCBleHBvcnRzKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgfVxuICBpZiAodGhpcy5pbk1vZHVsZSlcbiAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gT2JqZWN0LmtleXModGhpcy51bmRlZmluZWRFeHBvcnRzKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICAgIHZhciBuYW1lID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdLnN0YXJ0LCAoXCJFeHBvcnQgJ1wiICsgbmFtZSArIFwiJyBpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICB9IH1cbiAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keSk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb2dyYW1cIilcbn07XG5cbnZhciBsb29wTGFiZWwgPSB7a2luZDogXCJsb29wXCJ9LCBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxucHAkMS5pc0xldCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpKSB7IHJldHVybiBmYWxzZSB9XG4gIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAvLyBGb3IgYW1iaWd1b3VzIGNhc2VzLCBkZXRlcm1pbmUgaWYgYSBMZXhpY2FsRGVjbGFyYXRpb24gKG9yIG9ubHkgYVxuICAvLyBTdGF0ZW1lbnQpIGlzIGFsbG93ZWQgaGVyZS4gSWYgY29udGV4dCBpcyBub3QgZW1wdHkgdGhlbiBvbmx5IGEgU3RhdGVtZW50XG4gIC8vIGlzIGFsbG93ZWQuIEhvd2V2ZXIsIGBsZXQgW2AgaXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgbG9va2FoZWFkIGZvclxuICAvLyBFeHByZXNzaW9uU3RhdGVtZW50LCBzbyBzcGVjaWFsLWNhc2UgaXQgZmlyc3QuXG4gIGlmIChuZXh0Q2ggPT09IDkxKSB7IHJldHVybiB0cnVlIH0gLy8gJ1snXG4gIGlmIChjb250ZXh0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKG5leHRDaCA9PT0gMTIzKSB7IHJldHVybiB0cnVlIH0gLy8gJ3snXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgdmFyIHBvcyA9IG5leHQgKyAxO1xuICAgIHdoaWxlIChpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpLCB0cnVlKSkgeyArK3BvczsgfVxuICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICBpZiAoIWtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IudGVzdChpZGVudCkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gY2hlY2sgJ2FzeW5jIFtubyBMaW5lVGVybWluYXRvciBoZXJlXSBmdW5jdGlvbidcbi8vIC0gJ2FzeW5jIC8qZm9vKi8gZnVuY3Rpb24nIGlzIE9LLlxuLy8gLSAnYXN5bmMgLypcXG4qLyBmdW5jdGlvbicgaXMgaW52YWxpZC5cbnBwJDEuaXNBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGg7XG4gIHJldHVybiAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgbmV4dCkpICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShuZXh0LCBuZXh0ICsgOCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIChuZXh0ICsgOCA9PT0gdGhpcy5pbnB1dC5sZW5ndGggfHwgIWlzSWRlbnRpZmllckNoYXIodGhpcy5pbnB1dC5jaGFyQXQobmV4dCArIDgpKSlcbn07XG5cbi8vIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC5cbi8vXG4vLyBJZiBleHBlY3RpbmcgYSBzdGF0ZW1lbnQgYW5kIGZpbmRpbmcgYSBzbGFzaCBvcGVyYXRvciwgcGFyc2UgYVxuLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwuIFRoaXMgaXMgdG8gaGFuZGxlIGNhc2VzIGxpa2Vcbi8vIGBpZiAoZm9vKSAvYmxhaC8uZXhlYyhmb28pYCwgd2hlcmUgbG9va2luZyBhdCB0aGUgcHJldmlvdXMgdG9rZW5cbi8vIGRvZXMgbm90IGhlbHAuXG5cbnBwJDEucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbihjb250ZXh0LCB0b3BMZXZlbCwgZXhwb3J0cykge1xuICB2YXIgc3RhcnR0eXBlID0gdGhpcy50eXBlLCBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwga2luZDtcblxuICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgIHN0YXJ0dHlwZSA9IHR5cGVzLl92YXI7XG4gICAga2luZCA9IFwibGV0XCI7XG4gIH1cblxuICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgLy8gY29tcGxleGl0eS5cblxuICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICBjYXNlIHR5cGVzLl9icmVhazogY2FzZSB0eXBlcy5fY29udGludWU6IHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZClcbiAgY2FzZSB0eXBlcy5fZGVidWdnZXI6IHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZm9yOiByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICAvLyBGdW5jdGlvbiBhcyBzb2xlIGJvZHkgb2YgZWl0aGVyIGFuIGlmIHN0YXRlbWVudCBvciBhIGxhYmVsZWQgc3RhdGVtZW50XG4gICAgLy8gd29ya3MsIGJ1dCBub3Qgd2hlbiBpdCBpcyBwYXJ0IG9mIGEgbGFiZWxlZCBzdGF0ZW1lbnQgdGhhdCBpcyB0aGUgc29sZVxuICAgIC8vIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50LlxuICAgIGlmICgoY29udGV4dCAmJiAodGhpcy5zdHJpY3QgfHwgY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikpICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhub2RlLCB0cnVlKVxuICBjYXNlIHR5cGVzLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3N3aXRjaDogcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9jb25zdDogY2FzZSB0eXBlcy5fdmFyOlxuICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgaWYgKGNvbnRleHQgJiYga2luZCAhPT0gXCJ2YXJcIikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpXG4gIGNhc2UgdHlwZXMuX3doaWxlOiByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3dpdGg6IHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLmJyYWNlTDogcmV0dXJuIHRoaXMucGFyc2VCbG9jayh0cnVlLCBub2RlKVxuICBjYXNlIHR5cGVzLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZXhwb3J0OlxuICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIHN0YXJ0dHlwZSA9PT0gdHlwZXMuX2ltcG9ydCkge1xuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIGlmIChuZXh0Q2ggPT09IDQwKSAvLyAnKCdcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIpOyB9XG4gICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZXhwb3J0cylcblxuICAgIC8vIElmIHRoZSBzdGF0ZW1lbnQgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHN0YXRlbWVudCBrZXl3b3JkIG9yIGFcbiAgICAvLyBicmFjZSwgaXQncyBhbiBFeHByZXNzaW9uU3RhdGVtZW50IG9yIExhYmVsZWRTdGF0ZW1lbnQuIFdlXG4gICAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAgIC8vIG5leHQgdG9rZW4gaXMgYSBjb2xvbiBhbmQgdGhlIGV4cHJlc3Npb24gd2FzIGEgc2ltcGxlXG4gICAgLy8gSWRlbnRpZmllciBub2RlLCB3ZSBzd2l0Y2ggdG8gaW50ZXJwcmV0aW5nIGl0IGFzIGEgbGFiZWwuXG4gIGRlZmF1bHQ6XG4gICAgaWYgKHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgdHJ1ZSwgIWNvbnRleHQpXG4gICAgfVxuXG4gICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGlmIChzdGFydHR5cGUgPT09IHR5cGVzLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCh0eXBlcy5jb2xvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIH1cbiAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgfVxufTtcblxucHAkMS5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgZWxzZSBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIGVsc2Uge1xuICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYW4gYWN0dWFsIGRlc3RpbmF0aW9uIHRvIGJyZWFrIG9yXG4gIC8vIGNvbnRpbnVlIHRvLlxuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbGFiID0gdGhpcy5sYWJlbHNbaV07XG4gICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSB7IGJyZWFrIH1cbiAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuICBpZiAoaSA9PT0gdGhpcy5sYWJlbHMubGVuZ3RoKSB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIGtleXdvcmQpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZURvU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZG9cIik7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5fd2hpbGUpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICB7IHRoaXMuZWF0KHR5cGVzLnNlbWkpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIilcbn07XG5cbi8vIERpc2FtYmlndWF0aW5nIGJldHdlZW4gYSBgZm9yYCBhbmQgYSBgZm9yYC9gaW5gIG9yIGBmb3JgL2BvZmBcbi8vIGxvb3AgaXMgbm9uLXRyaXZpYWwuIEJhc2ljYWxseSwgd2UgaGF2ZSB0byBwYXJzZSB0aGUgaW5pdCBgdmFyYFxuLy8gc3RhdGVtZW50IG9yIGV4cHJlc3Npb24sIGRpc2FsbG93aW5nIHRoZSBgaW5gIG9wZXJhdG9yIChzZWVcbi8vIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGBwYXJzZUV4cHJlc3Npb25gKSwgYW5kIHRoZW4gY2hlY2tcbi8vIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgYGluYCBvciBgb2ZgLiBXaGVuIHRoZXJlIGlzIG5vIGluaXRcbi8vIHBhcnQgKHNlbWljb2xvbiBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyksIGl0XG4vLyBpcyBhIHJlZ3VsYXIgYGZvcmAgbG9vcC5cblxucHAkMS5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHZhciBhd2FpdEF0ID0gKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkgPyB0aGlzLmxhc3RUb2tTdGFydCA6IC0xO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSkge1xuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgbnVsbClcbiAgfVxuICB2YXIgaXNMZXQgPSB0aGlzLmlzTGV0KCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl92YXIgfHwgdGhpcy50eXBlID09PSB0eXBlcy5fY29uc3QgfHwgaXNMZXQpIHtcbiAgICB2YXIgaW5pdCQxID0gdGhpcy5zdGFydE5vZGUoKSwga2luZCA9IGlzTGV0ID8gXCJsZXRcIiA6IHRoaXMudmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5wYXJzZVZhcihpbml0JDEsIHRydWUsIGtpbmQpO1xuICAgIHRoaXMuZmluaXNoTm9kZShpbml0JDEsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkgJiYgaW5pdCQxLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4pIHtcbiAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSlcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0JDEpXG4gIH1cbiAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgfVxuICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICB0aGlzLmNoZWNrTFZhbChpbml0KTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gIH1cbiAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbn07XG5cbnBwJDEucGFyc2VGdW5jdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMsIGRlY2xhcmF0aW9uUG9zaXRpb24pIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgRlVOQ19TVEFURU1FTlQgfCAoZGVjbGFyYXRpb25Qb3NpdGlvbiA/IDAgOiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSwgZmFsc2UsIGlzQXN5bmMpXG59O1xuXG5wcCQxLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIC8vIGFsbG93IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBpbiBicmFuY2hlcywgYnV0IG9ubHkgaW4gbm9uLXN0cmljdCBtb2RlXG4gIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKTtcbiAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcy5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIikgOiBudWxsO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICghdGhpcy5pbkZ1bmN0aW9uICYmICF0aGlzLm9wdGlvbnMuYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24pXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTsgfVxuICB0aGlzLm5leHQoKTtcblxuICAvLyBJbiBgcmV0dXJuYCAoYW5kIGBicmVha2AvYGNvbnRpbnVlYCksIHRoZSBrZXl3b3JkcyB3aXRoXG4gIC8vIG9wdGlvbmFsIGFyZ3VtZW50cywgd2UgZWFnZXJseSBsb29rIGZvciBhIHNlbWljb2xvbiBvciB0aGVcbiAgLy8gcG9zc2liaWxpdHkgdG8gaW5zZXJ0IG9uZS5cblxuICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmNhc2VzID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHRoaXMubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICB0aGlzLmVudGVyU2NvcGUoMCk7XG5cbiAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gIC8vIGFkZGluZyBzdGF0ZW1lbnRzIHRvLlxuXG4gIHZhciBjdXI7XG4gIGZvciAodmFyIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVI7KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2Nhc2UgfHwgdGhpcy50eXBlID09PSB0eXBlcy5fZGVmYXVsdCkge1xuICAgICAgdmFyIGlzQ2FzZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2Nhc2U7XG4gICAgICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICBjdXIudGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5sYXN0VG9rU3RhcnQsIFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpOyB9XG4gICAgICAgIHNhd0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICBjdXIudGVzdCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY3VyKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCkpO1xuICAgIH1cbiAgfVxuICB0aGlzLmV4aXRTY29wZSgpO1xuICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICB0aGlzLm5leHQoKTsgLy8gQ2xvc2luZyBicmFjZVxuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVRocm93U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIik7IH1cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKVxufTtcblxuLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbnZhciBlbXB0eSA9IFtdO1xuXG5wcCQxLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5ibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xuICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2F0Y2gpIHtcbiAgICB2YXIgY2xhdXNlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgICAgY2xhdXNlLnBhcmFtID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgICB2YXIgc2ltcGxlID0gY2xhdXNlLnBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICAgICAgdGhpcy5lbnRlclNjb3BlKHNpbXBsZSA/IFNDT1BFX1NJTVBMRV9DQVRDSCA6IDApO1xuICAgICAgdGhpcy5jaGVja0xWYWwoY2xhdXNlLnBhcmFtLCBzaW1wbGUgPyBCSU5EX1NJTVBMRV9DQVRDSCA6IEJJTkRfTEVYSUNBTCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgMTApIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgfVxuICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gIH1cbiAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCh0eXBlcy5fZmluYWxseSkgPyB0aGlzLnBhcnNlQmxvY2soKSA6IG51bGw7XG4gIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcilcbiAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBraW5kKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnBhcnNlVmFyKG5vZGUsIGZhbHNlLCBraW5kKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDEucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2hpbGVcIik7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAodGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aXRoXCIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkge1xuICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gdGhpcy5sYWJlbHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICB7XG4gICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSlcbiAgICAgIHsgdGhpcy5yYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICB9IH1cbiAgdmFyIGtpbmQgPSB0aGlzLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl9zd2l0Y2ggPyBcInN3aXRjaFwiIDogbnVsbDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhYmVsJDEgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICBpZiAobGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9PT0gbm9kZS5zdGFydCkge1xuICAgICAgLy8gVXBkYXRlIGluZm9ybWF0aW9uIGFib3V0IHByZXZpb3VzIGxhYmVscyBvbiB0aGlzIG5vZGVcbiAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgbGFiZWwkMS5raW5kID0ga2luZDtcbiAgICB9IGVsc2UgeyBicmVhayB9XG4gIH1cbiAgdGhpcy5sYWJlbHMucHVzaCh7bmFtZTogbWF5YmVOYW1lLCBraW5kOiBraW5kLCBzdGF0ZW1lbnRTdGFydDogdGhpcy5zdGFydH0pO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGNvbnRleHQgPyBjb250ZXh0LmluZGV4T2YoXCJsYWJlbFwiKSA9PT0gLTEgPyBjb250ZXh0ICsgXCJsYWJlbFwiIDogY29udGV4dCA6IFwibGFiZWxcIik7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICBub2RlLmxhYmVsID0gZXhwcjtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgZXhwcikge1xuICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSBzZW1pY29sb24tZW5jbG9zZWQgYmxvY2sgb2Ygc3RhdGVtZW50cywgaGFuZGxpbmcgYFwidXNlXG4vLyBzdHJpY3RcImAgZGVjbGFyYXRpb25zIHdoZW4gYGFsbG93U3RyaWN0YCBpcyB0cnVlICh1c2VkIGZvclxuLy8gZnVuY3Rpb24gYm9kaWVzKS5cblxucHAkMS5wYXJzZUJsb2NrID0gZnVuY3Rpb24oY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBub2RlKSB7XG4gIGlmICggY3JlYXRlTmV3TGV4aWNhbFNjb3BlID09PSB2b2lkIDAgKSBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPSB0cnVlO1xuICBpZiAoIG5vZGUgPT09IHZvaWQgMCApIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gIG5vZGUuYm9keSA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZW50ZXJTY29wZSgwKTsgfVxuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmV4aXRTY29wZSgpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4vLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3Jcbi8vIGV4cHJlc3Npb24uXG5cbnBwJDEucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIG5vZGUuaW5pdCA9IGluaXQ7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICBub2RlLnRlc3QgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgYGZvcmAvYGluYCBhbmQgYGZvcmAvYG9mYCBsb29wLCB3aGljaCBhcmUgYWxtb3N0XG4vLyBzYW1lIGZyb20gcGFyc2VyJ3MgcGVyc3BlY3RpdmUuXG5cbnBwJDEucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgdmFyIGlzRm9ySW4gPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9pbjtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgaWYgKFxuICAgIGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiZcbiAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0ICE9IG51bGwgJiZcbiAgICAoXG4gICAgICAhaXNGb3JJbiB8fFxuICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fFxuICAgICAgdGhpcy5zdHJpY3QgfHxcbiAgICAgIGluaXQua2luZCAhPT0gXCJ2YXJcIiB8fFxuICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCJcbiAgICApXG4gICkge1xuICAgIHRoaXMucmFpc2UoXG4gICAgICBpbml0LnN0YXJ0LFxuICAgICAgKChpc0ZvckluID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCIpICsgXCIgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXJcIilcbiAgICApO1xuICB9IGVsc2UgaWYgKGluaXQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBcIkludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWxvb3BcIik7XG4gIH1cbiAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgbm9kZS5yaWdodCA9IGlzRm9ySW4gPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgdmFyaWFibGUgZGVjbGFyYXRpb25zLlxuXG5wcCQxLnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQpIHtcbiAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgbm9kZS5raW5kID0ga2luZDtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkZWNsID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmVxKSkge1xuICAgICAgZGVjbC5pbml0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwiY29uc3RcIiAmJiAhKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH0gZWxzZSBpZiAoZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIkNvbXBsZXggYmluZGluZyBwYXR0ZXJucyByZXF1aXJlIGFuIGluaXRpYWxpemF0aW9uIHZhbHVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNsLmluaXQgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgYnJlYWsgfVxuICB9XG4gIHJldHVybiBub2RlXG59O1xuXG5wcCQxLnBhcnNlVmFySWQgPSBmdW5jdGlvbihkZWNsLCBraW5kKSB7XG4gIGRlY2wuaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgdGhpcy5jaGVja0xWYWwoZGVjbC5pZCwga2luZCA9PT0gXCJ2YXJcIiA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMLCBmYWxzZSk7XG59O1xuXG52YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cbi8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UYCkuXG5cbi8vIFJlbW92ZSBgYWxsb3dFeHByZXNzaW9uQm9keWAgZm9yIDcuMC4wLCBhcyBpdCBpcyBvbmx5IGNhbGxlZCB3aXRoIGZhbHNlXG5wcCQxLnBhcnNlRnVuY3Rpb24gPSBmdW5jdGlvbihub2RlLCBzdGF0ZW1lbnQsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzQXN5bmMpIHtcbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIgJiYgKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIG5vZGUuZ2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIGlmIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkge1xuICAgIG5vZGUuaWQgPSAoc3RhdGVtZW50ICYgRlVOQ19OVUxMQUJMRV9JRCkgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5uYW1lID8gbnVsbCA6IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAvLyBJZiBpdCBpcyBhIHJlZ3VsYXIgZnVuY3Rpb24gZGVjbGFyYXRpb24gaW4gc2xvcHB5IG1vZGUsIHRoZW4gaXQgaXNcbiAgICAgIC8vIHN1YmplY3QgdG8gQW5uZXggQiBzZW1hbnRpY3MgKEJJTkRfRlVOQ1RJT04pLiBPdGhlcndpc2UsIHRoZSBiaW5kaW5nXG4gICAgICAvLyBtb2RlIGRlcGVuZHMgb24gcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBzY29wZSAoc2VlXG4gICAgICAvLyB0cmVhdEZ1bmN0aW9uc0FzVmFyKS5cbiAgICAgIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgKHRoaXMuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMpID8gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwgOiBCSU5EX0ZVTkNUSU9OKTsgfVxuICB9XG5cbiAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKG5vZGUuYXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSk7XG5cbiAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgIHsgbm9kZS5pZCA9IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogbnVsbDsgfVxuXG4gIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBmYWxzZSk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbnBwJDEucGFyc2VGdW5jdGlvblBhcmFtcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xufTtcblxuLy8gUGFyc2UgYSBjbGFzcyBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbnBwJDEucGFyc2VDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIGVjbWEtMjYyIDE0LjYgQ2xhc3MgRGVmaW5pdGlvbnNcbiAgLy8gQSBjbGFzcyBkZWZpbml0aW9uIGlzIGFsd2F5cyBzdHJpY3QgbW9kZSBjb2RlLlxuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3Q7XG4gIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gIGNsYXNzQm9keS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudChub2RlLnN1cGVyQ2xhc3MgIT09IG51bGwpO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGVsZW1lbnQpO1xuICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgZWxlbWVudC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7IHRoaXMucmFpc2UoZWxlbWVudC5zdGFydCwgXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3NcIik7IH1cbiAgICAgICAgaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoY2xhc3NCb2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24oY29uc3RydWN0b3JBbGxvd3NTdXBlcikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkpIHsgcmV0dXJuIG51bGwgfVxuXG4gIHZhciBtZXRob2QgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgdHJ5Q29udGV4dHVhbCA9IGZ1bmN0aW9uIChrLCBub0xpbmVCcmVhaykge1xuICAgIGlmICggbm9MaW5lQnJlYWsgPT09IHZvaWQgMCApIG5vTGluZUJyZWFrID0gZmFsc2U7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzJDEuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcyQxLnN0YXJ0TG9jO1xuICAgIGlmICghdGhpcyQxLmVhdENvbnRleHR1YWwoaykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodGhpcyQxLnR5cGUgIT09IHR5cGVzLnBhcmVuTCAmJiAoIW5vTGluZUJyZWFrIHx8ICF0aGlzJDEuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAobWV0aG9kLmtleSkgeyB0aGlzJDEudW5leHBlY3RlZCgpOyB9XG4gICAgbWV0aG9kLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgbWV0aG9kLmtleSA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydCwgc3RhcnRMb2MpO1xuICAgIG1ldGhvZC5rZXkubmFtZSA9IGs7XG4gICAgdGhpcyQxLmZpbmlzaE5vZGUobWV0aG9kLmtleSwgXCJJZGVudGlmaWVyXCIpO1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgbWV0aG9kLnN0YXRpYyA9IHRyeUNvbnRleHR1YWwoXCJzdGF0aWNcIik7XG4gIHZhciBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICBpZiAoIWlzR2VuZXJhdG9yKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIHRyeUNvbnRleHR1YWwoXCJhc3luY1wiLCB0cnVlKSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcImdldFwiKSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcImdldFwiO1xuICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcInNldFwiKSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcInNldFwiO1xuICAgIH1cbiAgfVxuICBpZiAoIW1ldGhvZC5rZXkpIHsgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpOyB9XG4gIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICB2YXIgYWxsb3dzRGlyZWN0U3VwZXIgPSBmYWxzZTtcbiAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgIW1ldGhvZC5zdGF0aWMgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8XG4gICAgICBrZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYga2V5LnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgaWYgKG1ldGhvZC5raW5kICE9PSBcIm1ldGhvZFwiKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGhhdmUgZ2V0L3NldCBtb2RpZmllclwiKTsgfVxuICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgIGlmIChpc0FzeW5jKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIG1ldGhvZFwiKTsgfVxuICAgIG1ldGhvZC5raW5kID0gXCJjb25zdHJ1Y3RvclwiO1xuICAgIGFsbG93c0RpcmVjdFN1cGVyID0gY29uc3RydWN0b3JBbGxvd3NTdXBlcjtcbiAgfSBlbHNlIGlmIChtZXRob2Quc3RhdGljICYmIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgIHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZVwiKTtcbiAgfVxuICB0aGlzLnBhcnNlQ2xhc3NNZXRob2QobWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDApXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5zdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgcmV0dXJuIG1ldGhvZFxufTtcblxucHAkMS5wYXJzZUNsYXNzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgbWV0aG9kLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NJZCA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgaWYgKGlzU3RhdGVtZW50KVxuICAgICAgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX0xFWElDQUwsIGZhbHNlKTsgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc1N0YXRlbWVudCA9PT0gdHJ1ZSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLmlkID0gbnVsbDtcbiAgfVxufTtcblxucHAkMS5wYXJzZUNsYXNzU3VwZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHR5cGVzLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cygpIDogbnVsbDtcbn07XG5cbi8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQxLnBhcnNlRXhwb3J0ID0gZnVuY3Rpb24obm9kZSwgZXhwb3J0cykge1xuICB0aGlzLm5leHQoKTtcbiAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJ1xuICBpZiAodGhpcy5lYXQodHlwZXMuc3RhcikpIHtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIilcbiAgfVxuICBpZiAodGhpcy5lYXQodHlwZXMuX2RlZmF1bHQpKSB7IC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxuICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICB2YXIgaXNBc3luYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fZnVuY3Rpb24gfHwgKGlzQXN5bmMgPSB0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSkge1xuICAgICAgdmFyIGZOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb24oZk5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgRlVOQ19OVUxMQUJMRV9JRCwgZmFsc2UsIGlzQXN5bmMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2xhc3MpIHtcbiAgICAgIHZhciBjTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUNsYXNzKGNOb2RlLCBcIm51bGxhYmxlSURcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIilcbiAgfVxuICAvLyBleHBvcnQgdmFyfGNvbnN0fGxldHxmdW5jdGlvbnxjbGFzcyAuLi5cbiAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQoKSkge1xuICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uaWQubmFtZSwgbm9kZS5kZWNsYXJhdGlvbi5pZC5zdGFydCk7IH1cbiAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gIH0gZWxzZSB7IC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgIG5vZGUuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKGV4cG9ydHMpO1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpKSB7XG4gICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgICB2YXIgc3BlYyA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGV4cG9ydCBpcyBkZWZpbmVkXG4gICAgICAgIHRoaXMuY2hlY2tMb2NhbEV4cG9ydChzcGVjLmxvY2FsKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpXG59O1xuXG5wcCQxLmNoZWNrRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgcG9zKSB7XG4gIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICBpZiAoaGFzKGV4cG9ydHMsIG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgXCJEdXBsaWNhdGUgZXhwb3J0ICdcIiArIG5hbWUgKyBcIidcIik7IH1cbiAgZXhwb3J0c1tuYW1lXSA9IHRydWU7XG59O1xuXG5wcCQxLmNoZWNrUGF0dGVybkV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIHBhdCkge1xuICB2YXIgdHlwZSA9IHBhdC50eXBlO1xuICBpZiAodHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIHBhdC5uYW1lLCBwYXQuc3RhcnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXQucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwcm9wKTtcbiAgICAgIH0gfVxuICBlbHNlIGlmICh0eXBlID09PSBcIkFycmF5UGF0dGVyblwiKVxuICAgIHsgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gcGF0LmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgdmFyIGVsdCA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgIGlmIChlbHQpIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZWx0KTsgfVxuICAgIH0gfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlByb3BlcnR5XCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQudmFsdWUpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5sZWZ0KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuYXJndW1lbnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5leHByZXNzaW9uKTsgfVxufTtcblxucHAkMS5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZGVjbHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBkZWNsLmlkKTtcbiAgfVxufTtcblxucHAkMS5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlLmtleXdvcmQgPT09IFwidmFyXCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjb25zdFwiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY2xhc3NcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICB0aGlzLmlzTGV0KCkgfHxcbiAgICB0aGlzLmlzQXN5bmNGdW5jdGlvbigpXG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgZXhwb3J0cy5cblxucHAkMS5wYXJzZUV4cG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgbm9kZS5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZUlkZW50KHRydWUpIDogbm9kZS5sb2NhbDtcbiAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZXhwb3J0ZWQubmFtZSwgbm9kZS5leHBvcnRlZC5zdGFydCk7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG4gIHJldHVybiBub2Rlc1xufTtcblxuLy8gUGFyc2VzIGltcG9ydCBkZWNsYXJhdGlvbi5cblxucHAkMS5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGltcG9ydCAnLi4uJ1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBpbXBvcnRzLlxuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgLy8gaW1wb3J0IGRlZmF1bHRPYmosIHsgeCwgeSBhcyB6IH0gZnJvbSAnLi4uJ1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikpO1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IHJldHVybiBub2RlcyB9XG4gIH1cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICAgIG5vZGUkMS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZSQyLmltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgbm9kZSQyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUkMi5pbXBvcnRlZCk7XG4gICAgICBub2RlJDIubG9jYWwgPSBub2RlJDIuaW1wb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMi5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKTtcbiAgfVxuICByZXR1cm4gbm9kZXNcbn07XG5cbi8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxucHAkMS5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlID0gZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gIH1cbn07XG5wcCQxLmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGVtZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG4gICAgc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiZcbiAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAvLyBSZWplY3QgcGFyZW50aGVzaXplZCBzdHJpbmdzLlxuICAgICh0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiXFxcIlwiIHx8IHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCInXCIpXG4gIClcbn07XG5cbnZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4vLyBpZiBwb3NzaWJsZS5cblxucHAkMi50b0Fzc2lnbmFibGUgPSBmdW5jdGlvbihub2RlLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nKTtcbiAgICAgICAgLy8gRWFybHkgZXJyb3I6XG4gICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgLy8gICAgIGAuLi5gIERlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0W1lpZWxkLCBBd2FpdF1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmXG4gICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHByb3AuYXJndW1lbnQuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICAgIGlmIChub2RlLmtpbmQgIT09IFwiaW5pdFwiKSB7IHRoaXMucmFpc2Uobm9kZS5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpOyB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiUmVzdEVsZW1lbnRcIjtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGlzQmluZGluZyk7XG4gICAgICBpZiAobm9kZS5hcmd1bWVudC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZShub2RlLmFyZ3VtZW50LnN0YXJ0LCBcIlJlc3QgZWxlbWVudHMgY2Fubm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICBpZiAobm9kZS5vcGVyYXRvciAhPT0gXCI9XCIpIHsgdGhpcy5yYWlzZShub2RlLmxlZnQuZW5kLCBcIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuXCIpOyB9XG4gICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNCaW5kaW5nKTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2ggdG8gQXNzaWdubWVudFBhdHRlcm5cblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBpZiAoIWlzQmluZGluZykgeyBicmVhayB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbi8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxucHAkMi50b0Fzc2lnbmFibGVMaXN0ID0gZnVuY3Rpb24oZXhwckxpc3QsIGlzQmluZGluZykge1xuICB2YXIgZW5kID0gZXhwckxpc3QubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIGVsdCA9IGV4cHJMaXN0W2ldO1xuICAgIGlmIChlbHQpIHsgdGhpcy50b0Fzc2lnbmFibGUoZWx0LCBpc0JpbmRpbmcpOyB9XG4gIH1cbiAgaWYgKGVuZCkge1xuICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQobGFzdC5hcmd1bWVudC5zdGFydCk7IH1cbiAgfVxuICByZXR1cm4gZXhwckxpc3Rcbn07XG5cbi8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxucHAkMi5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTcHJlYWRFbGVtZW50XCIpXG59O1xuXG5wcCQyLnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcblxuICAvLyBSZXN0RWxlbWVudCBpbnNpZGUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpZGVudGlmaWVyXG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKVxuICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlc3RFbGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZXMgbHZhbHVlIChhc3NpZ25hYmxlKSBhdG9tLlxuXG5wcCQyLnBhcnNlQmluZGluZ0F0b20gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIilcblxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmoodHJ1ZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMucGFyc2VJZGVudCgpXG59O1xuXG5wcCQyLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dFbXB0eSwgYWxsb3dUcmFpbGluZ0NvbW1hKSB7XG4gIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgIGVsc2UgeyB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7IH1cbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgdmFyIHJlc3QgPSB0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKTtcbiAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0ocmVzdCk7XG4gICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYyk7XG4gICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKGVsZW0pO1xuICAgICAgZWx0cy5wdXNoKGVsZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWx0c1xufTtcblxucHAkMi5wYXJzZUJpbmRpbmdMaXN0SXRlbSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gIHJldHVybiBwYXJhbVxufTtcblxuLy8gUGFyc2VzIGFzc2lnbm1lbnQgcGF0dGVybiBhcm91bmQgZ2l2ZW4gYXRvbSBpZiBwb3NzaWJsZS5cblxucHAkMi5wYXJzZU1heWJlRGVmYXVsdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCkge1xuICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuZWF0KHR5cGVzLmVxKSkgeyByZXR1cm4gbGVmdCB9XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxufTtcblxuLy8gVmVyaWZ5IHRoYXQgYSBub2RlIGlzIGFuIGx2YWwg4oCUIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBhc3NpZ25lZFxuLy8gdG8uXG4vLyBiaW5kaW5nVHlwZSBjYW4gYmUgZWl0aGVyOlxuLy8gJ3ZhcicgaW5kaWNhdGluZyB0aGF0IHRoZSBsdmFsIGNyZWF0ZXMgYSAndmFyJyBiaW5kaW5nXG4vLyAnbGV0JyBpbmRpY2F0aW5nIHRoYXQgdGhlIGx2YWwgY3JlYXRlcyBhIGxleGljYWwgKCdsZXQnIG9yICdjb25zdCcpIGJpbmRpbmdcbi8vICdub25lJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGJpbmRpbmcgc2hvdWxkIGJlIGNoZWNrZWQgZm9yIGlsbGVnYWwgaWRlbnRpZmllcnMsIGJ1dCBub3QgZm9yIGR1cGxpY2F0ZSByZWZlcmVuY2VzXG5cbnBwJDIuY2hlY2tMVmFsID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMICYmIGV4cHIubmFtZSA9PT0gXCJsZXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZyBcIiA6IFwiQXNzaWduaW5nIHRvIFwiKSArIGV4cHIubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgaWYgKGhhcyhjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaFwiKTsgfVxuICAgICAgY2hlY2tDbGFzaGVzW2V4cHIubmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgIT09IEJJTkRfTk9ORSAmJiBiaW5kaW5nVHlwZSAhPT0gQklORF9PVVRTSURFKSB7IHRoaXMuZGVjbGFyZU5hbWUoZXhwci5uYW1lLCBiaW5kaW5nVHlwZSwgZXhwci5zdGFydCk7IH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgaWYgKGJpbmRpbmdUeXBlKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb25cIik7IH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgIHRoaXMuY2hlY2tMVmFsKHByb3AsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGV4cHIuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICB2YXIgZWxlbSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgaWYgKGVsZW0pIHsgdGhpcy5jaGVja0xWYWwoZWxlbSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7IH1cbiAgICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLmxlZnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLmV4cHJlc3Npb24sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZ1wiIDogXCJBc3NpZ25pbmcgdG9cIikgKyBcIiBydmFsdWVcIik7XG4gIH1cbn07XG5cbi8vIEEgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyIG9wZXJhdGVzIGJ5IGRlZmluaW5nIGZ1bmN0aW9ucyBmb3IgYWxsXG5cbnZhciBwcCQzID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ2hlY2sgaWYgcHJvcGVydHkgbmFtZSBjbGFzaGVzIHdpdGggYWxyZWFkeSBhZGRlZC5cbi8vIE9iamVjdC9jbGFzcyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGFyZSBub3QgYWxsb3dlZCB0byBjbGFzaCDigJRcbi8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbi8vIHN0cmljdCBtb2RlLCBpbml0IHByb3BlcnRpZXMgYXJlIGFsc28gbm90IGFsbG93ZWQgdG8gYmUgcmVwZWF0ZWQuXG5cbnBwJDMuY2hlY2tQcm9wQ2xhc2ggPSBmdW5jdGlvbihwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICB7IHJldHVybiB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAocHJvcC5jb21wdXRlZCB8fCBwcm9wLm1ldGhvZCB8fCBwcm9wLnNob3J0aGFuZCkpXG4gICAgeyByZXR1cm4gfVxuICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gIHZhciBuYW1lO1xuICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgY2FzZSBcIkxpdGVyYWxcIjogbmFtZSA9IFN0cmluZyhrZXkudmFsdWUpOyBicmVha1xuICBkZWZhdWx0OiByZXR1cm5cbiAgfVxuICB2YXIga2luZCA9IHByb3Aua2luZDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIGlmIChwcm9wSGFzaC5wcm90bykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvIDwgMCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0ga2V5LnN0YXJ0OyB9XG4gICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXQga2x1ZGdlLiBDYW4gYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDYuMFxuICAgICAgICBlbHNlIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG4gICAgICB9XG4gICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gIHZhciBvdGhlciA9IHByb3BIYXNoW25hbWVdO1xuICBpZiAob3RoZXIpIHtcbiAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgIGlmIChraW5kID09PSBcImluaXRcIikge1xuICAgICAgcmVkZWZpbml0aW9uID0gdGhpcy5zdHJpY3QgJiYgb3RoZXIuaW5pdCB8fCBvdGhlci5nZXQgfHwgb3RoZXIuc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRlZmluaXRpb24gPSBvdGhlci5pbml0IHx8IG90aGVyW2tpbmRdO1xuICAgIH1cbiAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKTsgfVxuICB9IGVsc2Uge1xuICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICBpbml0OiBmYWxzZSxcbiAgICAgIGdldDogZmFsc2UsXG4gICAgICBzZXQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBvdGhlcltraW5kXSA9IHRydWU7XG59O1xuXG4vLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbi8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2Zcbi8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbihzKSBiZWxvdyB0aGVtIHBhcnNlLFxuLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbi8vIHRoZSBBU1Qgbm9kZSB0aGF0IHRoZSBpbm5lciBwYXJzZXIgZ2F2ZSB0aGVtIGluIGFub3RoZXIgbm9kZS5cblxuLy8gUGFyc2UgYSBmdWxsIGV4cHJlc3Npb24uIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgdG9cbi8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4vLyBhbmQgcHJvdmlkZSByZWZlcmVuY2UgZm9yIHN0b3JpbmcgJz0nIG9wZXJhdG9yIGluc2lkZSBzaG9ydGhhbmRcbi8vIHByb3BlcnR5IGFzc2lnbm1lbnQgaW4gY29udGV4dHMgd2hlcmUgYm90aCBvYmplY3QgZXhwcmVzc2lvblxuLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuLy8gZGVsYXllZCBzeW50YXggZXJyb3IgYXQgY29ycmVjdCBwb3NpdGlvbikuXG5cbnBwJDMucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG4gICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIilcbiAgfVxuICByZXR1cm4gZXhwclxufTtcblxuLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuLy8gb3BlcmF0b3JzIGxpa2UgYCs9YC5cblxucHAkMy5wYXJzZU1heWJlQXNzaWduID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICBpZiAodGhpcy5pbkdlbmVyYXRvcikgeyByZXR1cm4gdGhpcy5wYXJzZVlpZWxkKG5vSW4pIH1cbiAgICAvLyBUaGUgdG9rZW5pemVyIHdpbGwgYXNzdW1lIGFuIGV4cHJlc3Npb24gaXMgYWxsb3dlZCBhZnRlclxuICAgIC8vIGB5aWVsZGAsIGJ1dCB0aGlzIGlzbid0IHRoYXQga2luZCBvZiB5aWVsZFxuICAgIGVsc2UgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgfVxuXG4gIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMSwgb2xkU2hvcnRoYW5kQXNzaWduID0gLTE7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgb2xkVHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgICBvbGRTaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IC0xO1xuICB9IGVsc2Uge1xuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSlcbiAgICB7IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhcnQ7IH1cbiAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7IGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7IH1cbiAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUubGVmdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgPyB0aGlzLnRvQXNzaWduYWJsZShsZWZ0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgOiBsZWZ0O1xuICAgIGlmICghb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyBEZXN0cnVjdHVyaW5nRXJyb3JzLmNhbGwocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IC0xOyAvLyByZXNldCBiZWNhdXNlIHNob3J0aGFuZCBkZWZhdWx0IHdhcyB1c2VkIGNvcnJlY3RseVxuICAgIHRoaXMuY2hlY2tMVmFsKGxlZnQpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpXG4gIH0gZWxzZSB7XG4gICAgaWYgKG93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgfVxuICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICBpZiAob2xkVHJhaWxpbmdDb21tYSA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IG9sZFRyYWlsaW5nQ29tbWE7IH1cbiAgaWYgKG9sZFNob3J0aGFuZEFzc2lnbiA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gb2xkU2hvcnRoYW5kQXNzaWduOyB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG4vLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG5wcCQzLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICB9XG4gIHJldHVybiBleHByXG59O1xuXG4vLyBTdGFydCB0aGUgcHJlY2VkZW5jZSBwYXJzZXIuXG5cbnBwJDMucGFyc2VFeHByT3BzID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICByZXR1cm4gZXhwci5zdGFydCA9PT0gc3RhcnRQb3MgJiYgZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPyBleHByIDogdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIC0xLCBub0luKVxufTtcblxuLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbi8vIGFsZ29yaXRobS4gYGxlZnRgIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgb3BlcmF0b3IuXG4vLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbi8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbi8vIG9wZXJhdG9yIHRoYXQgaGFzIGEgbG93ZXIgcHJlY2VkZW5jZSB0aGFuIHRoZSBzZXQgaXQgaXMgcGFyc2luZy5cblxucHAkMy5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKSB7XG4gIHZhciBwcmVjID0gdGhpcy50eXBlLmJpbm9wO1xuICBpZiAocHJlYyAhPSBudWxsICYmICghbm9JbiB8fCB0aGlzLnR5cGUgIT09IHR5cGVzLl9pbikpIHtcbiAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgIHZhciBsb2dpY2FsID0gdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsQU5EO1xuICAgICAgdmFyIG9wID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIHN0YXJ0UG9zLCBzdGFydExvYywgcHJlYywgbm9Jbik7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYnVpbGRCaW5hcnkobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9JbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlZnRcbn07XG5cbnBwJDMuYnVpbGRCaW5hcnkgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgbm9kZS5vcGVyYXRvciA9IG9wO1xuICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbG9naWNhbCA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxucHAkMy5wYXJzZU1heWJlVW5hcnkgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBzYXdVbmFyeSkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSkge1xuICAgIGV4cHIgPSB0aGlzLnBhcnNlQXdhaXQoKTtcbiAgICBzYXdVbmFyeSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlLnByZWZpeCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgdXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5pbmNEZWM7XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICBpZiAodXBkYXRlKSB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQpOyB9XG4gICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJlxuICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgZWxzZSB7IHNhd1VuYXJ5ID0gdHJ1ZTsgfVxuICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNhd1VuYXJ5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXJzdGFyKSlcbiAgICB7IHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBcIioqXCIsIGZhbHNlKSB9XG4gIGVsc2VcbiAgICB7IHJldHVybiBleHByIH1cbn07XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHZhciBza2lwQXJyb3dTdWJzY3JpcHRzID0gZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCI7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB8fCBza2lwQXJyb3dTdWJzY3JpcHRzKSB7IHJldHVybiBleHByIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlc3VsdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IC0xOyB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSAtMTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbnBwJDMucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICB0aGlzLmxhc3RUb2tFbmQgPT09IGJhc2UuZW5kICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuaW5wdXQuc2xpY2UoYmFzZS5zdGFydCwgYmFzZS5lbmQpID09PSBcImFzeW5jXCI7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93KTtcbiAgICBpZiAoZWxlbWVudCA9PT0gYmFzZSB8fCBlbGVtZW50LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikgeyByZXR1cm4gZWxlbWVudCB9XG4gICAgYmFzZSA9IGVsZW1lbnQ7XG4gIH1cbn07XG5cbnBwJDMucGFyc2VTdWJzY3JpcHQgPSBmdW5jdGlvbihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIG1heWJlQXN5bmNBcnJvdykge1xuICB2YXIgY29tcHV0ZWQgPSB0aGlzLmVhdCh0eXBlcy5icmFja2V0TCk7XG4gIGlmIChjb21wdXRlZCB8fCB0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgIG5vZGUucHJvcGVydHkgPSBjb21wdXRlZCA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIik7XG4gICAgbm9kZS5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gICAgaWYgKGNvbXB1dGVkKSB7IHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTsgfVxuICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgIHZhciBleHByTGlzdCA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5wYXJlblIsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSAhPT0gXCJJbXBvcnRcIiwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChtYXliZUFzeW5jQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgaWYgKHRoaXMuYXdhaXRJZGVudFBvcyA+IDApXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0SWRlbnRQb3MsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgdHJ1ZSlcbiAgICB9XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcyB8fCB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlJDEuY2FsbGVlID0gYmFzZTtcbiAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgaWYgKG5vZGUkMS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgICAgaWYgKG5vZGUkMS5hcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZSQxLnN0YXJ0LCBcImltcG9ydCgpIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50XCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1wb3J0QXJnID0gbm9kZSQxLmFyZ3VtZW50c1swXTtcbiAgICAgIGlmIChpbXBvcnRBcmcgJiYgaW1wb3J0QXJnLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoaW1wb3J0QXJnLnN0YXJ0LCBcIi4uLiBpcyBub3QgYWxsb3dlZCBpbiBpbXBvcnQoKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGUpIHtcbiAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgIG5vZGUkMi5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh7aXNUYWdnZWQ6IHRydWV9KTtcbiAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIGJhc2Vcbn07XG5cbi8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuLy8gZXhwcmVzc2lvbiwgYW4gZXhwcmVzc2lvbiBzdGFydGVkIGJ5IGEga2V5d29yZCBsaWtlIGBmdW5jdGlvbmAgb3Jcbi8vIGBuZXdgLCBvciBhbiBleHByZXNzaW9uIHdyYXBwZWQgaW4gcHVuY3R1YXRpb24gbGlrZSBgKClgLCBgW11gLFxuLy8gb3IgYHt9YC5cblxucHAkMy5wYXJzZUV4cHJBdG9tID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAvLyBJZiBhIGRpdmlzaW9uIG9wZXJhdG9yIGFwcGVhcnMgaW4gYW4gZXhwcmVzc2lvbiBwb3NpdGlvbiwgdGhlXG4gIC8vIHRva2VuaXplciBnb3QgY29uZnVzZWQsIGFuZCB3ZSBmb3JjZSBpdCB0byByZWFkIGEgcmVnZXhwIGluc3RlYWQuXG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNsYXNoKSB7IHRoaXMucmVhZFJlZ2V4cCgpOyB9XG5cbiAgdmFyIG5vZGUsIGNhbkJlQXJyb3cgPSB0aGlzLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhcnQ7XG4gIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gIGNhc2UgdHlwZXMuX3N1cGVyOlxuICAgIGlmICghdGhpcy5hbGxvd1N1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgJiYgIXRoaXMuYWxsb3dEaXJlY3RTdXBlcilcbiAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcInN1cGVyKCkgY2FsbCBvdXRzaWRlIGNvbnN0cnVjdG9yIG9mIGEgc3ViY2xhc3NcIik7IH1cbiAgICAvLyBUaGUgYHN1cGVyYCBrZXl3b3JkIGNhbiBhcHBlYXIgYXQgYmVsb3c6XG4gICAgLy8gU3VwZXJQcm9wZXJ0eTpcbiAgICAvLyAgICAgc3VwZXIgWyBFeHByZXNzaW9uIF1cbiAgICAvLyAgICAgc3VwZXIgLiBJZGVudGlmaWVyTmFtZVxuICAgIC8vIFN1cGVyQ2FsbDpcbiAgICAvLyAgICAgc3VwZXIgQXJndW1lbnRzXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuZG90ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2tldEwgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5wYXJlbkwpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN1cGVyXCIpXG5cbiAgY2FzZSB0eXBlcy5fdGhpczpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIilcblxuICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWNvbnRhaW5zRXNjICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5fZnVuY3Rpb24pKVxuICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgMCwgZmFsc2UsIHRydWUpIH1cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIGZhbHNlKSB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSAmJiAhY29udGFpbnNFc2MpIHtcbiAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAhdGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCB0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWRcblxuICBjYXNlIHR5cGVzLnJlZ2V4cDpcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUgPSB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZS52YWx1ZSk7XG4gICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWx1ZS5wYXR0ZXJuLCBmbGFnczogdmFsdWUuZmxhZ3N9O1xuICAgIHJldHVybiBub2RlXG5cbiAgY2FzZSB0eXBlcy5udW06IGNhc2UgdHlwZXMuc3RyaW5nOlxuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKVxuXG4gIGNhc2UgdHlwZXMuX251bGw6IGNhc2UgdHlwZXMuX3RydWU6IGNhc2UgdHlwZXMuX2ZhbHNlOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9udWxsID8gbnVsbCA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3RydWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuXG4gIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsIGV4cHIgPSB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyk7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwICYmICF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIpKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHN0YXJ0OyB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHN0YXJ0OyB9XG4gICAgfVxuICAgIHJldHVybiBleHByXG5cbiAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPYmooZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpXG5cbiAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAwKVxuXG4gIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpXG5cbiAgY2FzZSB0eXBlcy5fbmV3OlxuICAgIHJldHVybiB0aGlzLnBhcnNlTmV3KClcblxuICBjYXNlIHR5cGVzLmJhY2tRdW90ZTpcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUR5bmFtaWNJbXBvcnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICB9XG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxufTtcblxucHAkMy5wYXJzZUR5bmFtaWNJbXBvcnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydFwiKVxufTtcblxucHAkMy5wYXJzZUxpdGVyYWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgbm9kZS5yYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgaWYgKG5vZGUucmF3LmNoYXJDb2RlQXQobm9kZS5yYXcubGVuZ3RoIC0gMSkgPT09IDExMCkgeyBub2RlLmJpZ2ludCA9IG5vZGUucmF3LnNsaWNlKDAsIC0xKTsgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbn07XG5cbnBwJDMucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIHJldHVybiB2YWxcbn07XG5cbnBwJDMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNhbkJlQXJyb3cpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHJMaXN0ID0gW10sIGZpcnN0ID0gdHJ1ZSwgbGFzdElzQ29tbWEgPSBmYWxzZTtcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgc3ByZWFkU3RhcnQ7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgLy8gRG8gbm90IHNhdmUgYXdhaXRJZGVudFBvcyB0byBhbGxvdyBjaGVja2luZyBhd2FpdHMgbmVzdGVkIGluIHBhcmFtZXRlcnNcbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5wYXJlblIpIHtcbiAgICAgIGZpcnN0ID8gZmlyc3QgPSBmYWxzZSA6IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMucGFyZW5SLCB0cnVlKSkge1xuICAgICAgICBsYXN0SXNDb21tYSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgc3ByZWFkU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3RCaW5kaW5nKCkpKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGlubmVyRW5kUG9zID0gdGhpcy5zdGFydCwgaW5uZXJFbmRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG5cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVBhcmVuQXJyb3dMaXN0KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpXG4gICAgfVxuXG4gICAgaWYgKCFleHByTGlzdC5sZW5ndGggfHwgbGFzdElzQ29tbWEpIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgIGlmIChzcHJlYWRTdGFydCkgeyB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnQpOyB9XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG5cbiAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgdmFsID0gdGhpcy5zdGFydE5vZGVBdChpbm5lclN0YXJ0UG9zLCBpbm5lclN0YXJ0TG9jKTtcbiAgICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0O1xuICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBleHByTGlzdFswXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVBhcmVucykge1xuICAgIHZhciBwYXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXIsIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsXG4gIH1cbn07XG5cbnBwJDMucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIHJldHVybiBpdGVtXG59O1xuXG5wcCQzLnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KSB7XG4gIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QpXG59O1xuXG4vLyBOZXcncyBwcmVjZWRlbmNlIGlzIHNsaWdodGx5IHRyaWNreS4gSXQgbXVzdCBhbGxvdyBpdHMgYXJndW1lbnQgdG9cbi8vIGJlIGEgYFtdYCBvciBkb3Qgc3Vic2NyaXB0IGV4cHJlc3Npb24sIGJ1dCBub3QgYSBjYWxsIOKAlCBhdCBsZWFzdCxcbi8vIG5vdCB3aXRob3V0IHdyYXBwaW5nIGl0IGluIHBhcmVudGhlc2VzLiBUaHVzLCBpdCB1c2VzIHRoZSBub0NhbGxzXG4vLyBhcmd1bWVudCB0byBwYXJzZVN1YnNjcmlwdHMgdG8gcHJldmVudCBpdCBmcm9tIGNvbnN1bWluZyB0aGVcbi8vIGFyZ3VtZW50IGxpc3QuXG5cbnZhciBlbXB0eSQxID0gW107XG5cbnBwJDMucGFyc2VOZXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICBub2RlLm1ldGEgPSBtZXRhO1xuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcInRhcmdldFwiIHx8IGNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBuZXcgaXMgbmV3LnRhcmdldFwiKTsgfVxuICAgIGlmICghdGhpcy5pbk5vbkFycm93RnVuY3Rpb24oKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwibmV3LnRhcmdldCBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9uc1wiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbiAgfVxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiBub2RlLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgdGhpcy5yYWlzZShub2RlLmNhbGxlZS5zdGFydCwgXCJDYW5ub3QgdXNlIG5ldyB3aXRoIGltcG9ydCguLi4pXCIpO1xuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7IG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgbm9kZS5jYWxsZWUudHlwZSAhPT0gXCJJbXBvcnRcIiwgZmFsc2UpOyB9XG4gIGVsc2UgeyBub2RlLmFyZ3VtZW50cyA9IGVtcHR5JDE7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIHRlbXBsYXRlIGV4cHJlc3Npb24uXG5cbnBwJDMucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbihyZWYpIHtcbiAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkO1xuXG4gIHZhciBlbGVtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSB7XG4gICAgaWYgKCFpc1RhZ2dlZCkge1xuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQmFkIGVzY2FwZSBzZXF1ZW5jZSBpbiB1bnRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgIH1cbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLnZhbHVlLFxuICAgICAgY29va2VkOiBudWxsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgfTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgZWxlbS50YWlsID0gdGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbn07XG5cbnBwJDMucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDsgaWYgKCBpc1RhZ2dlZCA9PT0gdm9pZCAwICkgaXNUYWdnZWQgPSBmYWxzZTtcblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmV4cHJlc3Npb25zID0gW107XG4gIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KTtcbiAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVvZikgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpOyB9XG4gICAgdGhpcy5leHBlY3QodHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKVxufTtcblxucHAkMy5pc0FzeW5jUHJvcCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgfHwgdGhpcy50eXBlID09PSB0eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgfHwgdGhpcy50eXBlID09PSB0eXBlcy5icmFja2V0TCB8fCB0aGlzLnR5cGUua2V5d29yZCB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSkgJiZcbiAgICAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxufTtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYmluZGluZyBwYXR0ZXJuLlxuXG5wcCQzLnBhcnNlT2JqID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBwcm9wSGFzaCA9IHt9O1xuICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgdGhpcy5uZXh0KCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2VQcm9wZXJ0eShpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICghaXNQYXR0ZXJuKSB7IHRoaXMuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1BhdHRlcm4gPyBcIk9iamVjdFBhdHRlcm5cIiA6IFwiT2JqZWN0RXhwcmVzc2lvblwiKVxufTtcblxucHAkMy5wYXJzZVByb3BlcnR5ID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBwcm9wID0gdGhpcy5zdGFydE5vZGUoKSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYztcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLmVsbGlwc2lzKSkge1xuICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJSZXN0RWxlbWVudFwiKVxuICAgIH1cbiAgICAvLyBUbyBkaXNhbGxvdyBwYXJlbnRoZXNpemVkIGlkZW50aWZpZXIgdmlhIGB0aGlzLnRvQXNzaWduYWJsZSgpYC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDApIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMCkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUGFyc2UgYXJndW1lbnQuXG4gICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgLy8gVG8gZGlzYWxsb3cgdHJhaWxpbmcgY29tbWEgdmlhIGB0aGlzLnRvQXNzaWduYWJsZSgpYC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIC8vIEZpbmlzaFxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJTcHJlYWRFbGVtZW50XCIpXG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIGlmIChpc1BhdHRlcm4gfHwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIH1cbiAgICBpZiAoIWlzUGF0dGVybilcbiAgICAgIHsgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTsgfVxuICB9XG4gIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5pc0FzeW5jUHJvcChwcm9wKSkge1xuICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgfSBlbHNlIHtcbiAgICBpc0FzeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wYXJzZVByb3BlcnR5VmFsdWUocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKVxufTtcblxucHAkMy5wYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKSB7XG4gIGlmICgoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb2xvbilcbiAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLmNvbG9uKSkge1xuICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCkge1xuICAgIGlmIChpc1BhdHRlcm4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICBwcm9wLm1ldGhvZCA9IHRydWU7XG4gICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICB9IGVsc2UgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcbiAgICAgICAgICAgICAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSAmJlxuICAgICAgICAgICAgICh0aGlzLnR5cGUgIT09IHR5cGVzLmNvbW1hICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSKSkge1xuICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcHJvcC5raW5kID0gcHJvcC5rZXkubmFtZTtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGZhbHNlKTtcbiAgICB2YXIgcGFyYW1Db3VudCA9IHByb3Aua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIHZhciBzdGFydCA9IHByb3AudmFsdWUuc3RhcnQ7XG4gICAgICBpZiAocHJvcC5raW5kID09PSBcImdldFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcC5raW5kID09PSBcInNldFwiICYmIHByb3AudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocHJvcC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICBpZiAocHJvcC5rZXkubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IHN0YXJ0UG9zOyB9XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVxICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA8IDApXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSB0aGlzLnN0YXJ0OyB9XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC52YWx1ZSA9IHByb3Aua2V5O1xuICAgIH1cbiAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gIH0gZWxzZSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG5wcCQzLnBhcnNlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24ocHJvcCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgIHByb3Aua2V5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgICByZXR1cm4gcHJvcC5rZXlcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcC5rZXkgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpXG59O1xuXG4vLyBJbml0aWFsaXplIGVtcHR5IGZ1bmN0aW9uIG5vZGUuXG5cbnBwJDMuaW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLmlkID0gbnVsbDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IG5vZGUuZ2VuZXJhdG9yID0gbm9kZS5leHByZXNzaW9uID0gZmFsc2U7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxufTtcblxuLy8gUGFyc2Ugb2JqZWN0IG9yIGNsYXNzIG1ldGhvZC5cblxucHAkMy5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd0RpcmVjdFN1cGVyKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICB7IG5vZGUuZ2VuZXJhdG9yID0gaXNHZW5lcmF0b3I7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpIHwgU0NPUEVfU1VQRVIgfCAoYWxsb3dEaXJlY3RTdXBlciA/IFNDT1BFX0RJUkVDVF9TVVBFUiA6IDApKTtcblxuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UsIHRydWUpO1xuXG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy5cblxucHAkMy5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYykge1xuICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgZmFsc2UpIHwgU0NPUEVfQVJST1cpO1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG5cbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cnVlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBmYWxzZSk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cblxucHAkMy5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbiwgaXNNZXRob2QpIHtcbiAgdmFyIGlzRXhwcmVzc2lvbiA9IGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlTDtcbiAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0LCB1c2VTdHJpY3QgPSBmYWxzZTtcblxuICBpZiAoaXNFeHByZXNzaW9uKSB7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9uU2ltcGxlID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgIGlmICghb2xkU3RyaWN0IHx8IG5vblNpbXBsZSkge1xuICAgICAgdXNlU3RyaWN0ID0gdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5lbmQpO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmljdCBtb2RlIGZ1bmN0aW9uLCB2ZXJpZnkgdGhhdCBhcmd1bWVudCBuYW1lc1xuICAgICAgLy8gYXJlIG5vdCByZXBlYXRlZCwgYW5kIGl0IGRvZXMgbm90IHRyeSB0byBiaW5kIHRoZSB3b3JkcyBgZXZhbGBcbiAgICAgIC8vIG9yIGBhcmd1bWVudHNgLlxuICAgICAgaWYgKHVzZVN0cmljdCAmJiBub25TaW1wbGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdFwiKTsgfVxuICAgIH1cbiAgICAvLyBTdGFydCBhIG5ldyBzY29wZSB3aXRoIHJlZ2FyZCB0byBsYWJlbHMgYW5kIHRoZSBgaW5GdW5jdGlvbmBcbiAgICAvLyBmbGFnIChyZXN0b3JlIHRoZW0gdG8gdGhlaXIgb2xkIHZhbHVlIGFmdGVyd2FyZHMpLlxuICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIGlmICh1c2VTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSB0cnVlOyB9XG5cbiAgICAvLyBBZGQgdGhlIHBhcmFtcyB0byB2YXJEZWNsYXJlZE5hbWVzIHRvIGVuc3VyZSB0aGF0IGFuIGVycm9yIGlzIHRocm93blxuICAgIC8vIGlmIGEgbGV0L2NvbnN0IGRlY2xhcmF0aW9uIGluIHRoZSBmdW5jdGlvbiBjbGFzaGVzIHdpdGggb25lIG9mIHRoZSBwYXJhbXMuXG4gICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhb2xkU3RyaWN0ICYmICF1c2VTdHJpY3QgJiYgIWlzQXJyb3dGdW5jdGlvbiAmJiAhaXNNZXRob2QgJiYgdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcykpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keS5ib2R5KTtcbiAgICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcbiAgfVxuICB0aGlzLmV4aXRTY29wZSgpO1xuXG4gIC8vIEVuc3VyZSB0aGUgZnVuY3Rpb24gbmFtZSBpc24ndCBhIGZvcmJpZGRlbiBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLCBlLmcuICdldmFsJ1xuICBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5pZCkgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX09VVFNJREUpOyB9XG4gIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xufTtcblxucHAkMy5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHsgcmV0dXJuIGZhbHNlXG4gIH0gfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gQ2hlY2tzIGZ1bmN0aW9uIHBhcmFtcyBmb3IgdmFyaW91cyBkaXNhbGxvd2VkIHBhdHRlcm5zIHN1Y2ggYXMgdXNpbmcgXCJldmFsXCJcbi8vIG9yIFwiYXJndW1lbnRzXCIgYW5kIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzLlxuXG5wcCQzLmNoZWNrUGFyYW1zID0gZnVuY3Rpb24obm9kZSwgYWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBuYW1lSGFzaCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIHRoaXMuY2hlY2tMVmFsKHBhcmFtLCBCSU5EX1ZBUiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoKTtcbiAgfVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhwcmVzc2lvbnMsIGFuZCByZXR1cm5zIHRoZW0gYXNcbi8vIGFuIGFycmF5LiBgY2xvc2VgIGlzIHRoZSB0b2tlbiB0eXBlIHRoYXQgZW5kcyB0aGUgbGlzdCwgYW5kXG4vLyBgYWxsb3dFbXB0eWAgY2FuIGJlIHR1cm5lZCBvbiB0byBhbGxvdyBzdWJzZXF1ZW50IGNvbW1hcyB3aXRoXG4vLyBub3RoaW5nIGluIGJldHdlZW4gdGhlbSB0byBiZSBwYXJzZWQgYXMgYG51bGxgICh3aGljaCBpcyBuZWVkZWRcbi8vIGZvciBhcnJheSBsaXRlcmFscykuXG5cbnBwJDMucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgZWx0ID0gKHZvaWQgMCk7XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSlcbiAgICAgIHsgZWx0ID0gbnVsbDsgfVxuICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VTcHJlYWQocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIH1cbiAgICBlbHRzLnB1c2goZWx0KTtcbiAgfVxuICByZXR1cm4gZWx0c1xufTtcblxucHAkMy5jaGVja1VucmVzZXJ2ZWQgPSBmdW5jdGlvbihyZWYpIHtcbiAgdmFyIHN0YXJ0ID0gcmVmLnN0YXJ0O1xuICB2YXIgZW5kID0gcmVmLmVuZDtcbiAgdmFyIG5hbWUgPSByZWYubmFtZTtcblxuICBpZiAodGhpcy5pbkdlbmVyYXRvciAmJiBuYW1lID09PSBcInlpZWxkXCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gIGlmICh0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShzdGFydCwgZW5kKS5pbmRleE9mKFwiXFxcXFwiKSAhPT0gLTEpIHsgcmV0dXJuIH1cbiAgdmFyIHJlID0gdGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgOiB0aGlzLnJlc2VydmVkV29yZHM7XG4gIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgaWYgKCF0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gIH1cbn07XG5cbi8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4vLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbi8vIGlkZW50aWZpZXJzLlxuXG5wcCQzLnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsLCBpc0JpbmRpbmcpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2V5d29yZCkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMudHlwZS5rZXl3b3JkO1xuXG4gICAgLy8gVG8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hY29ybmpzL2Fjb3JuL2lzc3Vlcy81NzVcbiAgICAvLyBgY2xhc3NgIGFuZCBgZnVuY3Rpb25gIGtleXdvcmRzIHB1c2ggbmV3IGNvbnRleHQgaW50byB0aGlzLmNvbnRleHQuXG4gICAgLy8gQnV0IHRoZXJlIGlzIG5vIGNoYW5jZSB0byBwb3AgdGhlIGNvbnRleHQgaWYgdGhlIGtleXdvcmQgaXMgY29uc3VtZWQgYXMgYW4gaWRlbnRpZmllciBzdWNoIGFzIGEgcHJvcGVydHkgbmFtZS5cbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgdG9rZW4gaXMgYSBkb3QsIHRoaXMgZG9lcyBub3QgYXBwbHkgYmVjYXVzZSB0aGUgY29udGV4dC1tYW5hZ2luZyBjb2RlIGFscmVhZHkgaWdub3JlZCB0aGUga2V5d29yZFxuICAgIGlmICgobm9kZS5uYW1lID09PSBcImNsYXNzXCIgfHwgbm9kZS5uYW1lID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICh0aGlzLmxhc3RUb2tFbmQgIT09IHRoaXMubGFzdFRva1N0YXJ0ICsgMSB8fCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQpICE9PSA0NikpIHtcbiAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gIGlmICghbGliZXJhbCkge1xuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUpO1xuICAgIGlmIChub2RlLm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBub2RlLnN0YXJ0OyB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbi8vIFBhcnNlcyB5aWVsZCBleHByZXNzaW9uIGluc2lkZSBnZW5lcmF0b3IuXG5cbnBwJDMucGFyc2VZaWVsZCA9IGZ1bmN0aW9uKG5vSW4pIHtcbiAgaWYgKCF0aGlzLnlpZWxkUG9zKSB7IHRoaXMueWllbGRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSB8fCB0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0YXIgJiYgIXRoaXMudHlwZS5zdGFydHNFeHByKSkge1xuICAgIG5vZGUuZGVsZWdhdGUgPSBmYWxzZTtcbiAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRlbGVnYXRlID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQzLnBhcnNlQXdhaXQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmF3YWl0UG9zKSB7IHRoaXMuYXdhaXRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG59O1xuXG52YXIgcHAkNCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbi8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4vLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4vLyBtZXNzYWdlLlxuXG5wcCQ0LnJhaXNlID0gZnVuY3Rpb24ocG9zLCBtZXNzYWdlKSB7XG4gIHZhciBsb2MgPSBnZXRMaW5lSW5mbyh0aGlzLmlucHV0LCBwb3MpO1xuICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG4gIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gIGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICB0aHJvdyBlcnJcbn07XG5cbnBwJDQucmFpc2VSZWNvdmVyYWJsZSA9IHBwJDQucmFpc2U7XG5cbnBwJDQuY3VyUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydClcbiAgfVxufTtcblxudmFyIHBwJDUgPSBQYXJzZXIucHJvdG90eXBlO1xuXG52YXIgU2NvcGUgPSBmdW5jdGlvbiBTY29wZShmbGFncykge1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIC8vIEEgbGlzdCBvZiB2YXItZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICB0aGlzLnZhciA9IFtdO1xuICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgdGhpcy5sZXhpY2FsID0gW107XG4gIC8vIEEgbGlzdCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgRnVuY3Rpb25EZWNsYXJhdGlvbiBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIHRoaXMuZnVuY3Rpb25zID0gW107XG59O1xuXG4vLyBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGtlZXAgdHJhY2sgb2YgZGVjbGFyZWQgdmFyaWFibGVzIGluIHRoZSBjdXJyZW50IHNjb3BlIGluIG9yZGVyIHRvIGRldGVjdCBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMuXG5cbnBwJDUuZW50ZXJTY29wZSA9IGZ1bmN0aW9uKGZsYWdzKSB7XG4gIHRoaXMuc2NvcGVTdGFjay5wdXNoKG5ldyBTY29wZShmbGFncykpO1xufTtcblxucHAkNS5leGl0U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xufTtcblxuLy8gVGhlIHNwZWMgc2F5czpcbi8vID4gQXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZ1bmN0aW9uLCBvciBzY3JpcHQsIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmVcbi8vID4gdHJlYXRlZCBsaWtlIHZhciBkZWNsYXJhdGlvbnMgcmF0aGVyIHRoYW4gbGlrZSBsZXhpY2FsIGRlY2xhcmF0aW9ucy5cbnBwJDUudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUgPSBmdW5jdGlvbihzY29wZSkge1xuICByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHx8ICF0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUClcbn07XG5cbnBwJDUuZGVjbGFyZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKSB7XG4gIHZhciByZWRlY2xhcmVkID0gZmFsc2U7XG4gIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICByZWRlY2xhcmVkID0gc2NvcGUubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS52YXIuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgIHNjb3BlLmxleGljYWwucHVzaChuYW1lKTtcbiAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfU0lNUExFX0NBVENIKSB7XG4gICAgdmFyIHNjb3BlJDEgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIHNjb3BlJDEubGV4aWNhbC5wdXNoKG5hbWUpO1xuICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0ZVTkNUSU9OKSB7XG4gICAgdmFyIHNjb3BlJDIgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGlmICh0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIpXG4gICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgZWxzZVxuICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZSQyLnZhci5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICBzY29wZSQyLmZ1bmN0aW9ucy5wdXNoKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBzY29wZSQzID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlJDMubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgJiYgISgoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1NJTVBMRV9DQVRDSCkgJiYgc2NvcGUkMy5sZXhpY2FsWzBdID09PSBuYW1lKSB8fFxuICAgICAgICAgICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlJDMpICYmIHNjb3BlJDMuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICByZWRlY2xhcmVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHNjb3BlJDMudmFyLnB1c2gobmFtZSk7XG4gICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgICAgaWYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9WQVIpIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuICBpZiAocmVkZWNsYXJlZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCAoXCJJZGVudGlmaWVyICdcIiArIG5hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7IH1cbn07XG5cbnBwJDUuY2hlY2tMb2NhbEV4cG9ydCA9IGZ1bmN0aW9uKGlkKSB7XG4gIC8vIHNjb3BlLmZ1bmN0aW9ucyBtdXN0IGJlIGVtcHR5IGFzIE1vZHVsZSBjb2RlIGlzIGFsd2F5cyBzdHJpY3QuXG4gIGlmICh0aGlzLnNjb3BlU3RhY2tbMF0ubGV4aWNhbC5pbmRleE9mKGlkLm5hbWUpID09PSAtMSAmJlxuICAgICAgdGhpcy5zY29wZVN0YWNrWzBdLnZhci5pbmRleE9mKGlkLm5hbWUpID09PSAtMSkge1xuICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tpZC5uYW1lXSA9IGlkO1xuICB9XG59O1xuXG5wcCQ1LmN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXVxufTtcblxucHAkNS5jdXJyZW50VmFyU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUikgeyByZXR1cm4gc2NvcGUgfVxuICB9XG59O1xuXG4vLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGB0aGlzYCwgYG5ldy50YXJnZXRgLCBgc3VwZXIoKWAsIGBzdXBlci5wcm9wZXJ0eWAsIGFuZCBgc3VwZXJbcHJvcGVydHldYC5cbnBwJDUuY3VycmVudFRoaXNTY29wZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSICYmICEoc2NvcGUuZmxhZ3MgJiBTQ09QRV9BUlJPVykpIHsgcmV0dXJuIHNjb3BlIH1cbiAgfVxufTtcblxudmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgdGhpcy50eXBlID0gXCJcIjtcbiAgdGhpcy5zdGFydCA9IHBvcztcbiAgdGhpcy5lbmQgPSAwO1xuICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocGFyc2VyLCBsb2MpOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICBpZiAocGFyc2VyLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwb3MsIDBdOyB9XG59O1xuXG4vLyBTdGFydCBhbiBBU1Qgbm9kZSwgYXR0YWNoaW5nIGEgc3RhcnQgb2Zmc2V0LlxuXG52YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnBwJDYuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKVxufTtcblxucHAkNi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbn07XG5cbi8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIG5vZGUudHlwZSA9IHR5cGU7XG4gIG5vZGUuZW5kID0gcG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IG5vZGUubG9jLmVuZCA9IGxvYzsgfVxuICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgcmV0dXJuIG5vZGVcbn1cblxucHAkNi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgdGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpXG59O1xuXG4vLyBGaW5pc2ggbm9kZSBhdCBnaXZlbiBwb3NpdGlvblxuXG5wcCQ2LmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbn07XG5cbi8vIFRoZSBhbGdvcml0aG0gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHJlZ2V4cCBjYW4gYXBwZWFyIGF0IGFcblxudmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlLCBnZW5lcmF0b3IpIHtcbiAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICB0aGlzLnByZXNlcnZlU3BhY2UgPSAhIXByZXNlcnZlU3BhY2U7XG4gIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgdGhpcy5nZW5lcmF0b3IgPSAhIWdlbmVyYXRvcjtcbn07XG5cbnZhciB0eXBlcyQxID0ge1xuICBiX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICBiX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiJHtcIiwgZmFsc2UpLFxuICBwX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50cnlSZWFkVGVtcGxhdGVUb2tlbigpOyB9KSxcbiAgZl9zdGF0OiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlKSxcbiAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICBmX2V4cHJfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUsIGZhbHNlLCBudWxsLCB0cnVlKSxcbiAgZl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCBudWxsLCB0cnVlKVxufTtcblxudmFyIHBwJDcgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5wcCQ3LmluaXRpYWxDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdHlwZXMkMS5iX3N0YXRdXG59O1xuXG5wcCQ3LmJyYWNlSXNCbG9jayA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKHBhcmVudCA9PT0gdHlwZXMkMS5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcyQxLmZfc3RhdClcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiAmJiAocGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB8fCBwYXJlbnQgPT09IHR5cGVzJDEuYl9leHByKSlcbiAgICB7IHJldHVybiAhcGFyZW50LmlzRXhwciB9XG5cbiAgLy8gVGhlIGNoZWNrIGZvciBgdHQubmFtZSAmJiBleHByQWxsb3dlZGAgZGV0ZWN0cyB3aGV0aGVyIHdlIGFyZVxuICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAvLyBgdHQubmFtZWAuXG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMubmFtZSAmJiB0aGlzLmV4cHJBbGxvd2VkKVxuICAgIHsgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcy5zZW1pIHx8IHByZXZUeXBlID09PSB0eXBlcy5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzLnBhcmVuUiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYXJyb3cpXG4gICAgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKVxuICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl92YXIgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9jb25zdCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMubmFtZSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiAhdGhpcy5leHByQWxsb3dlZFxufTtcblxucHAkNy5pbkdlbmVyYXRvckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0W2ldO1xuICAgIGlmIChjb250ZXh0LnRva2VuID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICB7IHJldHVybiBjb250ZXh0LmdlbmVyYXRvciB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG5wcCQ3LnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgdXBkYXRlLCB0eXBlID0gdGhpcy50eXBlO1xuICBpZiAodHlwZS5rZXl3b3JkICYmIHByZXZUeXBlID09PSB0eXBlcy5kb3QpXG4gICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgZWxzZSBpZiAodXBkYXRlID0gdHlwZS51cGRhdGVDb250ZXh0KVxuICAgIHsgdXBkYXRlLmNhbGwodGhpcywgcHJldlR5cGUpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7IH1cbn07XG5cbi8vIFRva2VuLXNwZWNpZmljIGNvbnRleHQgdXBkYXRlIGNvZGVcblxudHlwZXMucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gIGlmIChvdXQgPT09IHR5cGVzJDEuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xufTtcblxudHlwZXMuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0aGlzLmJyYWNlSXNCbG9jayhwcmV2VHlwZSkgPyB0eXBlcyQxLmJfc3RhdCA6IHR5cGVzJDEuYl9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmJfdG1wbCk7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgc3RhdGVtZW50UGFyZW5zID0gcHJldlR5cGUgPT09IHR5cGVzLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2ZvciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3dpdGggfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aGlsZTtcbiAgdGhpcy5jb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gdHlwZXMkMS5wX3N0YXQgOiB0eXBlcyQxLnBfZXhwcik7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgLy8gdG9rRXhwckFsbG93ZWQgc3RheXMgdW5jaGFuZ2VkXG59O1xuXG50eXBlcy5fZnVuY3Rpb24udXBkYXRlQ29udGV4dCA9IHR5cGVzLl9jbGFzcy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlLmJlZm9yZUV4cHIgJiYgcHJldlR5cGUgIT09IHR5cGVzLnNlbWkgJiYgcHJldlR5cGUgIT09IHR5cGVzLl9lbHNlICYmXG4gICAgICAhKHByZXZUeXBlID09PSB0eXBlcy5fcmV0dXJuICYmIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpICYmXG4gICAgICAhKChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gfHwgcHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTCkgJiYgdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEuYl9zdGF0KSlcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9leHByKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmZfc3RhdCk7IH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxudHlwZXMuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLnFfdG1wbClcbiAgICB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLnFfdG1wbCk7IH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxudHlwZXMuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fZnVuY3Rpb24pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTtcbiAgICBpZiAodGhpcy5jb250ZXh0W2luZGV4XSA9PT0gdHlwZXMkMS5mX2V4cHIpXG4gICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcyQxLmZfZXhwcl9nZW47IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcyQxLmZfZ2VuOyB9XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5uYW1lLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgYWxsb3dlZCA9IGZhbHNlO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgcHJldlR5cGUgIT09IHR5cGVzLmRvdCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBcIm9mXCIgJiYgIXRoaXMuZXhwckFsbG93ZWQgfHxcbiAgICAgICAgdGhpcy52YWx1ZSA9PT0gXCJ5aWVsZFwiICYmIHRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpXG4gICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGFsbG93ZWQ7XG59O1xuXG4vLyBUaGlzIGZpbGUgY29udGFpbnMgVW5pY29kZSBwcm9wZXJ0aWVzIGV4dHJhY3RlZCBmcm9tIHRoZSBFQ01BU2NyaXB0XG4vLyBzcGVjaWZpY2F0aW9uLiBUaGUgbGlzdHMgYXJlIGV4dHJhY3RlZCBsaWtlIHNvOlxuLy8gJCQoJyN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzID4gZmlndXJlID4gdGFibGUgPiB0Ym9keSA+IHRyID4gdGQ6bnRoLWNoaWxkKDEpIGNvZGUnKS5tYXAoZWwgPT4gZWwuaW5uZXJUZXh0KVxuXG4vLyAjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllc1xudmFyIGVjbWE5QmluYXJ5UHJvcGVydGllcyA9IFwiQVNDSUkgQVNDSUlfSGV4X0RpZ2l0IEFIZXggQWxwaGFiZXRpYyBBbHBoYSBBbnkgQXNzaWduZWQgQmlkaV9Db250cm9sIEJpZGlfQyBCaWRpX01pcnJvcmVkIEJpZGlfTSBDYXNlX0lnbm9yYWJsZSBDSSBDYXNlZCBDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGIENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkIENXQ00gQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQgQ1dMIENoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0YgQ2hhbmdlc19XaGVuX1RpdGxlY2FzZWQgQ1dUIENoYW5nZXNfV2hlbl9VcHBlcmNhc2VkIENXVSBEYXNoIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgREkgRGVwcmVjYXRlZCBEZXAgRGlhY3JpdGljIERpYSBFbW9qaSBFbW9qaV9Db21wb25lbnQgRW1vamlfTW9kaWZpZXIgRW1vamlfTW9kaWZpZXJfQmFzZSBFbW9qaV9QcmVzZW50YXRpb24gRXh0ZW5kZXIgRXh0IEdyYXBoZW1lX0Jhc2UgR3JfQmFzZSBHcmFwaGVtZV9FeHRlbmQgR3JfRXh0IEhleF9EaWdpdCBIZXggSURTX0JpbmFyeV9PcGVyYXRvciBJRFNCIElEU19UcmluYXJ5X09wZXJhdG9yIElEU1QgSURfQ29udGludWUgSURDIElEX1N0YXJ0IElEUyBJZGVvZ3JhcGhpYyBJZGVvIEpvaW5fQ29udHJvbCBKb2luX0MgTG9naWNhbF9PcmRlcl9FeGNlcHRpb24gTE9FIExvd2VyY2FzZSBMb3dlciBNYXRoIE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50IE5DaGFyIFBhdHRlcm5fU3ludGF4IFBhdF9TeW4gUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1MgUXVvdGF0aW9uX01hcmsgUU1hcmsgUmFkaWNhbCBSZWdpb25hbF9JbmRpY2F0b3IgUkkgU2VudGVuY2VfVGVybWluYWwgU1Rlcm0gU29mdF9Eb3R0ZWQgU0QgVGVybWluYWxfUHVuY3R1YXRpb24gVGVybSBVbmlmaWVkX0lkZW9ncmFwaCBVSWRlbyBVcHBlcmNhc2UgVXBwZXIgVmFyaWF0aW9uX1NlbGVjdG9yIFZTIFdoaXRlX1NwYWNlIHNwYWNlIFhJRF9Db250aW51ZSBYSURDIFhJRF9TdGFydCBYSURTXCI7XG52YXIgZWNtYTEwQmluYXJ5UHJvcGVydGllcyA9IGVjbWE5QmluYXJ5UHJvcGVydGllcyArIFwiIEV4dGVuZGVkX1BpY3RvZ3JhcGhpY1wiO1xudmFyIGVjbWExMUJpbmFyeVByb3BlcnRpZXMgPSBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzO1xudmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzID0ge1xuICA5OiBlY21hOUJpbmFyeVByb3BlcnRpZXMsXG4gIDEwOiBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzLFxuICAxMTogZWNtYTExQmluYXJ5UHJvcGVydGllc1xufTtcblxuLy8gI3RhYmxlLXVuaWNvZGUtZ2VuZXJhbC1jYXRlZ29yeS12YWx1ZXNcbnZhciB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzID0gXCJDYXNlZF9MZXR0ZXIgTEMgQ2xvc2VfUHVuY3R1YXRpb24gUGUgQ29ubmVjdG9yX1B1bmN0dWF0aW9uIFBjIENvbnRyb2wgQ2MgY250cmwgQ3VycmVuY3lfU3ltYm9sIFNjIERhc2hfUHVuY3R1YXRpb24gUGQgRGVjaW1hbF9OdW1iZXIgTmQgZGlnaXQgRW5jbG9zaW5nX01hcmsgTWUgRmluYWxfUHVuY3R1YXRpb24gUGYgRm9ybWF0IENmIEluaXRpYWxfUHVuY3R1YXRpb24gUGkgTGV0dGVyIEwgTGV0dGVyX051bWJlciBObCBMaW5lX1NlcGFyYXRvciBabCBMb3dlcmNhc2VfTGV0dGVyIExsIE1hcmsgTSBDb21iaW5pbmdfTWFyayBNYXRoX1N5bWJvbCBTbSBNb2RpZmllcl9MZXR0ZXIgTG0gTW9kaWZpZXJfU3ltYm9sIFNrIE5vbnNwYWNpbmdfTWFyayBNbiBOdW1iZXIgTiBPcGVuX1B1bmN0dWF0aW9uIFBzIE90aGVyIEMgT3RoZXJfTGV0dGVyIExvIE90aGVyX051bWJlciBObyBPdGhlcl9QdW5jdHVhdGlvbiBQbyBPdGhlcl9TeW1ib2wgU28gUGFyYWdyYXBoX1NlcGFyYXRvciBacCBQcml2YXRlX1VzZSBDbyBQdW5jdHVhdGlvbiBQIHB1bmN0IFNlcGFyYXRvciBaIFNwYWNlX1NlcGFyYXRvciBacyBTcGFjaW5nX01hcmsgTWMgU3Vycm9nYXRlIENzIFN5bWJvbCBTIFRpdGxlY2FzZV9MZXR0ZXIgTHQgVW5hc3NpZ25lZCBDbiBVcHBlcmNhc2VfTGV0dGVyIEx1XCI7XG5cbi8vICN0YWJsZS11bmljb2RlLXNjcmlwdC12YWx1ZXNcbnZhciBlY21hOVNjcmlwdFZhbHVlcyA9IFwiQWRsYW0gQWRsbSBBaG9tIEFob20gQW5hdG9saWFuX0hpZXJvZ2x5cGhzIEhsdXcgQXJhYmljIEFyYWIgQXJtZW5pYW4gQXJtbiBBdmVzdGFuIEF2c3QgQmFsaW5lc2UgQmFsaSBCYW11bSBCYW11IEJhc3NhX1ZhaCBCYXNzIEJhdGFrIEJhdGsgQmVuZ2FsaSBCZW5nIEJoYWlrc3VraSBCaGtzIEJvcG9tb2ZvIEJvcG8gQnJhaG1pIEJyYWggQnJhaWxsZSBCcmFpIEJ1Z2luZXNlIEJ1Z2kgQnVoaWQgQnVoZCBDYW5hZGlhbl9BYm9yaWdpbmFsIENhbnMgQ2FyaWFuIENhcmkgQ2F1Y2FzaWFuX0FsYmFuaWFuIEFnaGIgQ2hha21hIENha20gQ2hhbSBDaGFtIENoZXJva2VlIENoZXIgQ29tbW9uIFp5eXkgQ29wdGljIENvcHQgUWFhYyBDdW5laWZvcm0gWHN1eCBDeXByaW90IENwcnQgQ3lyaWxsaWMgQ3lybCBEZXNlcmV0IERzcnQgRGV2YW5hZ2FyaSBEZXZhIER1cGxveWFuIER1cGwgRWd5cHRpYW5fSGllcm9nbHlwaHMgRWd5cCBFbGJhc2FuIEVsYmEgRXRoaW9waWMgRXRoaSBHZW9yZ2lhbiBHZW9yIEdsYWdvbGl0aWMgR2xhZyBHb3RoaWMgR290aCBHcmFudGhhIEdyYW4gR3JlZWsgR3JlayBHdWphcmF0aSBHdWpyIEd1cm11a2hpIEd1cnUgSGFuIEhhbmkgSGFuZ3VsIEhhbmcgSGFudW5vbyBIYW5vIEhhdHJhbiBIYXRyIEhlYnJldyBIZWJyIEhpcmFnYW5hIEhpcmEgSW1wZXJpYWxfQXJhbWFpYyBBcm1pIEluaGVyaXRlZCBaaW5oIFFhYWkgSW5zY3JpcHRpb25hbF9QYWhsYXZpIFBobGkgSW5zY3JpcHRpb25hbF9QYXJ0aGlhbiBQcnRpIEphdmFuZXNlIEphdmEgS2FpdGhpIEt0aGkgS2FubmFkYSBLbmRhIEthdGFrYW5hIEthbmEgS2F5YWhfTGkgS2FsaSBLaGFyb3NodGhpIEtoYXIgS2htZXIgS2htciBLaG9qa2kgS2hvaiBLaHVkYXdhZGkgU2luZCBMYW8gTGFvbyBMYXRpbiBMYXRuIExlcGNoYSBMZXBjIExpbWJ1IExpbWIgTGluZWFyX0EgTGluYSBMaW5lYXJfQiBMaW5iIExpc3UgTGlzdSBMeWNpYW4gTHljaSBMeWRpYW4gTHlkaSBNYWhhamFuaSBNYWhqIE1hbGF5YWxhbSBNbHltIE1hbmRhaWMgTWFuZCBNYW5pY2hhZWFuIE1hbmkgTWFyY2hlbiBNYXJjIE1hc2FyYW1fR29uZGkgR29ubSBNZWV0ZWlfTWF5ZWsgTXRlaSBNZW5kZV9LaWtha3VpIE1lbmQgTWVyb2l0aWNfQ3Vyc2l2ZSBNZXJjIE1lcm9pdGljX0hpZXJvZ2x5cGhzIE1lcm8gTWlhbyBQbHJkIE1vZGkgTW9kaSBNb25nb2xpYW4gTW9uZyBNcm8gTXJvbyBNdWx0YW5pIE11bHQgTXlhbm1hciBNeW1yIE5hYmF0YWVhbiBOYmF0IE5ld19UYWlfTHVlIFRhbHUgTmV3YSBOZXdhIE5rbyBOa29vIE51c2h1IE5zaHUgT2doYW0gT2dhbSBPbF9DaGlraSBPbGNrIE9sZF9IdW5nYXJpYW4gSHVuZyBPbGRfSXRhbGljIEl0YWwgT2xkX05vcnRoX0FyYWJpYW4gTmFyYiBPbGRfUGVybWljIFBlcm0gT2xkX1BlcnNpYW4gWHBlbyBPbGRfU291dGhfQXJhYmlhbiBTYXJiIE9sZF9UdXJraWMgT3JraCBPcml5YSBPcnlhIE9zYWdlIE9zZ2UgT3NtYW55YSBPc21hIFBhaGF3aF9IbW9uZyBIbW5nIFBhbG15cmVuZSBQYWxtIFBhdV9DaW5fSGF1IFBhdWMgUGhhZ3NfUGEgUGhhZyBQaG9lbmljaWFuIFBobnggUHNhbHRlcl9QYWhsYXZpIFBobHAgUmVqYW5nIFJqbmcgUnVuaWMgUnVuciBTYW1hcml0YW4gU2FtciBTYXVyYXNodHJhIFNhdXIgU2hhcmFkYSBTaHJkIFNoYXZpYW4gU2hhdyBTaWRkaGFtIFNpZGQgU2lnbldyaXRpbmcgU2dudyBTaW5oYWxhIFNpbmggU29yYV9Tb21wZW5nIFNvcmEgU295b21ibyBTb3lvIFN1bmRhbmVzZSBTdW5kIFN5bG90aV9OYWdyaSBTeWxvIFN5cmlhYyBTeXJjIFRhZ2Fsb2cgVGdsZyBUYWdiYW53YSBUYWdiIFRhaV9MZSBUYWxlIFRhaV9UaGFtIExhbmEgVGFpX1ZpZXQgVGF2dCBUYWtyaSBUYWtyIFRhbWlsIFRhbWwgVGFuZ3V0IFRhbmcgVGVsdWd1IFRlbHUgVGhhYW5hIFRoYWEgVGhhaSBUaGFpIFRpYmV0YW4gVGlidCBUaWZpbmFnaCBUZm5nIFRpcmh1dGEgVGlyaCBVZ2FyaXRpYyBVZ2FyIFZhaSBWYWlpIFdhcmFuZ19DaXRpIFdhcmEgWWkgWWlpaSBaYW5hYmF6YXJfU3F1YXJlIFphbmJcIjtcbnZhciBlY21hMTBTY3JpcHRWYWx1ZXMgPSBlY21hOVNjcmlwdFZhbHVlcyArIFwiIERvZ3JhIERvZ3IgR3VuamFsYV9Hb25kaSBHb25nIEhhbmlmaV9Sb2hpbmd5YSBSb2hnIE1ha2FzYXIgTWFrYSBNZWRlZmFpZHJpbiBNZWRmIE9sZF9Tb2dkaWFuIFNvZ28gU29nZGlhbiBTb2dkXCI7XG52YXIgZWNtYTExU2NyaXB0VmFsdWVzID0gZWNtYTEwU2NyaXB0VmFsdWVzICsgXCIgRWx5bWFpYyBFbHltIE5hbmRpbmFnYXJpIE5hbmQgTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyBIbW5wIFdhbmNobyBXY2hvXCI7XG52YXIgdW5pY29kZVNjcmlwdFZhbHVlcyA9IHtcbiAgOTogZWNtYTlTY3JpcHRWYWx1ZXMsXG4gIDEwOiBlY21hMTBTY3JpcHRWYWx1ZXMsXG4gIDExOiBlY21hMTFTY3JpcHRWYWx1ZXNcbn07XG5cbnZhciBkYXRhID0ge307XG5mdW5jdGlvbiBidWlsZFVuaWNvZGVEYXRhKGVjbWFWZXJzaW9uKSB7XG4gIHZhciBkID0gZGF0YVtlY21hVmVyc2lvbl0gPSB7XG4gICAgYmluYXJ5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlQmluYXJ5UHJvcGVydGllc1tlY21hVmVyc2lvbl0gKyBcIiBcIiArIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgIG5vbkJpbmFyeToge1xuICAgICAgR2VuZXJhbF9DYXRlZ29yeTogd29yZHNSZWdleHAodW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICBTY3JpcHQ6IHdvcmRzUmVnZXhwKHVuaWNvZGVTY3JpcHRWYWx1ZXNbZWNtYVZlcnNpb25dKVxuICAgIH1cbiAgfTtcbiAgZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnMgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG5cbiAgZC5ub25CaW5hcnkuZ2MgPSBkLm5vbkJpbmFyeS5HZW5lcmFsX0NhdGVnb3J5O1xuICBkLm5vbkJpbmFyeS5zYyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcbiAgZC5ub25CaW5hcnkuc2N4ID0gZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnM7XG59XG5idWlsZFVuaWNvZGVEYXRhKDkpO1xuYnVpbGRVbmljb2RlRGF0YSgxMCk7XG5idWlsZFVuaWNvZGVEYXRhKDExKTtcblxudmFyIHBwJDggPSBQYXJzZXIucHJvdG90eXBlO1xuXG52YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIik7XG4gIHRoaXMudW5pY29kZVByb3BlcnRpZXMgPSBkYXRhW3BhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExID8gMTEgOiBwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbl07XG4gIHRoaXMuc291cmNlID0gXCJcIjtcbiAgdGhpcy5mbGFncyA9IFwiXCI7XG4gIHRoaXMuc3RhcnQgPSAwO1xuICB0aGlzLnN3aXRjaFUgPSBmYWxzZTtcbiAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgdGhpcy5ncm91cE5hbWVzID0gW107XG4gIHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzID0gW107XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICB2YXIgdW5pY29kZSA9IGZsYWdzLmluZGV4T2YoXCJ1XCIpICE9PSAtMTtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0IHwgMDtcbiAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuICsgXCJcIjtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgdGhpcy5wYXJzZXIucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCAoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogL1wiICsgKHRoaXMuc291cmNlKSArIFwiLzogXCIgKyBtZXNzYWdlKSk7XG59O1xuXG4vLyBJZiB1IGZsYWcgaXMgZ2l2ZW4sIHRoaXMgcmV0dXJucyB0aGUgY29kZSBwb2ludCBhdCB0aGUgaW5kZXggKGl0IGNvbWJpbmVzIGEgc3Vycm9nYXRlIHBhaXIpLlxuLy8gT3RoZXJ3aXNlLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiB0aGUgaW5kZXggKGNhbiBiZSBhIHBhcnQgb2YgYSBzdXJyb2dhdGUgcGFpcikuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQgKGkpIHtcbiAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgaWYgKGkgPj0gbCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICBpZiAoIXRoaXMuc3dpdGNoVSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsKSB7XG4gICAgcmV0dXJuIGNcbiAgfVxuICB2YXIgbmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIHJldHVybiBuZXh0ID49IDB4REMwMCAmJiBuZXh0IDw9IDB4REZGRiA/IChjIDw8IDEwKSArIG5leHQgLSAweDM1RkRDMDAgOiBjXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLm5leHRJbmRleCA9IGZ1bmN0aW9uIG5leHRJbmRleCAoaSkge1xuICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICB2YXIgbCA9IHMubGVuZ3RoO1xuICBpZiAoaSA+PSBsKSB7XG4gICAgcmV0dXJuIGxcbiAgfVxuICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKSwgbmV4dDtcbiAgaWYgKCF0aGlzLnN3aXRjaFUgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCB8fFxuICAgICAgKG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4REMwMCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgcmV0dXJuIGkgKyAxXG4gIH1cbiAgcmV0dXJuIGkgKyAyXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5wb3MpXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmxvb2thaGVhZCA9IGZ1bmN0aW9uIGxvb2thaGVhZCAoKSB7XG4gIHJldHVybiB0aGlzLmF0KHRoaXMubmV4dEluZGV4KHRoaXMucG9zKSlcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2UgKCkge1xuICB0aGlzLnBvcyA9IHRoaXMubmV4dEluZGV4KHRoaXMucG9zKTtcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gZWF0IChjaCkge1xuICBpZiAodGhpcy5jdXJyZW50KCkgPT09IGNoKSB7XG4gICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nKGNoKSB7XG4gIGlmIChjaCA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpIH1cbiAgY2ggLT0gMHgxMDAwMDtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNoID4+IDEwKSArIDB4RDgwMCwgKGNoICYgMHgwM0ZGKSArIDB4REMwMClcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgZmxhZ3MgcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gKlxuICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xucHAkOC52YWxpZGF0ZVJlZ0V4cEZsYWdzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHZhbGlkRmxhZ3MgPSBzdGF0ZS52YWxpZEZsYWdzO1xuICB2YXIgZmxhZ3MgPSBzdGF0ZS5mbGFncztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZsYWcgPSBmbGFncy5jaGFyQXQoaSk7XG4gICAgaWYgKHZhbGlkRmxhZ3MuaW5kZXhPZihmbGFnKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLmluZGV4T2YoZmxhZywgaSArIDEpID4gLTEpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgcGF0dGVybiBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5wcCQ4LnZhbGlkYXRlUmVnRXhwUGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuXG4gIC8vIFRoZSBnb2FsIHN5bWJvbCBmb3IgdGhlIHBhcnNlIGlzIHxQYXR0ZXJuW35VLCB+Tl18LiBJZiB0aGUgcmVzdWx0IG9mXG4gIC8vIHBhcnNpbmcgY29udGFpbnMgYSB8R3JvdXBOYW1lfCwgcmVwYXJzZSB3aXRoIHRoZSBnb2FsIHN5bWJvbFxuICAvLyB8UGF0dGVyblt+VSwgK05dfCBhbmQgdXNlIHRoaXMgcmVzdWx0IGluc3RlYWQuIFRocm93IGEgKlN5bnRheEVycm9yKlxuICAvLyBleGNlcHRpb24gaWYgX1BfIGRpZCBub3QgY29uZm9ybSB0byB0aGUgZ3JhbW1hciwgaWYgYW55IGVsZW1lbnRzIG9mIF9QX1xuICAvLyB3ZXJlIG5vdCBtYXRjaGVkIGJ5IHRoZSBwYXJzZSwgb3IgaWYgYW55IEVhcmx5IEVycm9yIGNvbmRpdGlvbnMgZXhpc3QuXG4gIGlmICghc3RhdGUuc3dpdGNoTiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICBzdGF0ZS5zd2l0Y2hOID0gdHJ1ZTtcbiAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVyblxucHAkOC5yZWdleHBfcGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLnBvcyA9IDA7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPSAwO1xuICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMubGVuZ3RoID0gMDtcblxuICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgaWYgKHN0YXRlLnBvcyAhPT0gc3RhdGUuc291cmNlLmxlbmd0aCkge1xuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZXMgYXMgVjguXG4gICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIlVubWF0Y2hlZCAnKSdcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBbICovKSB8fCBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID4gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIGNhcHR1cmUgcmVmZXJlbmNlZFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURpc2p1bmN0aW9uXG5wcCQ4LnJlZ2V4cF9kaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgd2hpbGUgKHN0YXRlLmVhdCgweDdDIC8qIHwgKi8pKSB7XG4gICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICB9XG5cbiAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICB9XG4gIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BbHRlcm5hdGl2ZVxucHAkOC5yZWdleHBfYWx0ZXJuYXRpdmUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlLmxlbmd0aCAmJiB0aGlzLnJlZ2V4cF9lYXRUZXJtKHN0YXRlKSlcbiAgICB7IH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1UZXJtXG5wcCQ4LnJlZ2V4cF9lYXRUZXJtID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdEFzc2VydGlvbihzdGF0ZSkpIHtcbiAgICAvLyBIYW5kbGUgYFF1YW50aWZpYWJsZUFzc2VydGlvbiBRdWFudGlmaWVyYCBhbHRlcm5hdGl2ZS5cbiAgICAvLyBgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlYCBpcyB0cnVlIGlmIHRoZSBsYXN0IGVhdGVuIEFzc2VydGlvblxuICAgIC8vIGlzIGEgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uLlxuICAgIGlmIChzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgJiYgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSkpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBxdWFudGlmaWVyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN0YXRlLnN3aXRjaFUgPyB0aGlzLnJlZ2V4cF9lYXRBdG9tKHN0YXRlKSA6IHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkQXRvbShzdGF0ZSkpIHtcbiAgICB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXNzZXJ0aW9uXG5wcCQ4LnJlZ2V4cF9lYXRBc3NlcnRpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuXG4gIC8vIF4sICRcbiAgaWYgKHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pIHx8IHN0YXRlLmVhdCgweDI0IC8qICQgKi8pKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIFxcYiBcXEJcbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg0MiAvKiBCICovKSB8fCBzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICAvLyBMb29rYWhlYWQgLyBMb29rYmVoaW5kXG4gIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSAmJiBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgIHZhciBsb29rYmVoaW5kID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICBsb29rYmVoaW5kID0gc3RhdGUuZWF0KDB4M0MgLyogPCAqLyk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSB8fCBzdGF0ZS5lYXQoMHgyMSAvKiAhICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKCFzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9ICFsb29rYmVoaW5kO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyXG5wcCQ4LnJlZ2V4cF9lYXRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgaWYgKCBub0Vycm9yID09PSB2b2lkIDAgKSBub0Vycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgoc3RhdGUsIG5vRXJyb3IpKSB7XG4gICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLyk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJQcmVmaXhcbnBwJDgucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXggPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICByZXR1cm4gKFxuICAgIHN0YXRlLmVhdCgweDJBIC8qICogKi8pIHx8XG4gICAgc3RhdGUuZWF0KDB4MkIgLyogKyAqLykgfHxcbiAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIG5vRXJyb3IpXG4gIClcbn07XG5wcCQ4LnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICB2YXIgbWluID0gMCwgbWF4ID0gLTE7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICBtaW4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkMgLyogLCAqLykgJiYgdGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgbWF4ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgIC8vIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtdGVybVxuICAgICAgICBpZiAobWF4ICE9PSAtMSAmJiBtYXggPCBtaW4gJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIm51bWJlcnMgb3V0IG9mIG9yZGVyIGluIHt9IHF1YW50aWZpZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgIW5vRXJyb3IpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW5jb21wbGV0ZSBxdWFudGlmaWVyXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUF0b21cbnBwJDgucmVnZXhwX2VhdEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzKHN0YXRlKSB8fFxuICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpXG4gIClcbn07XG5wcCQ4LnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QXRvbUVzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDgucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSAmJiBzdGF0ZS5lYXQoMHgzQSAvKiA6ICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOC5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2dyb3VwU3BlY2lmaWVyKHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzRiAvKiA/ICovKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyArPSAxO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRBdG9tXG5wcCQ4LnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyKHN0YXRlKVxuICApXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItSW52YWxpZEJyYWNlZFF1YW50aWZpZXJcbnBwJDgucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVN5bnRheENoYXJhY3RlclxucHAkOC5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNTeW50YXhDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIChcbiAgICBjaCA9PT0gMHgyNCAvKiAkICovIHx8XG4gICAgY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLyB8fFxuICAgIGNoID09PSAweDJFIC8qIC4gKi8gfHxcbiAgICBjaCA9PT0gMHgzRiAvKiA/ICovIHx8XG4gICAgY2ggPj0gMHg1QiAvKiBbICovICYmIGNoIDw9IDB4NUUgLyogXiAqLyB8fFxuICAgIGNoID49IDB4N0IgLyogeyAqLyAmJiBjaCA8PSAweDdEIC8qIH0gKi9cbiAgKVxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1QYXR0ZXJuQ2hhcmFjdGVyXG4vLyBCdXQgZWF0IGVhZ2VyLlxucHAkOC5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IDA7XG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpICE9PSAtMSAmJiAhaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyXG5wcCQ4LnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChcbiAgICBjaCAhPT0gLTEgJiZcbiAgICBjaCAhPT0gMHgyNCAvKiAkICovICYmXG4gICAgIShjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovKSAmJlxuICAgIGNoICE9PSAweDJFIC8qIC4gKi8gJiZcbiAgICBjaCAhPT0gMHgzRiAvKiA/ICovICYmXG4gICAgY2ggIT09IDB4NUIgLyogWyAqLyAmJlxuICAgIGNoICE9PSAweDVFIC8qIF4gKi8gJiZcbiAgICBjaCAhPT0gMHg3QyAvKiB8ICovXG4gICkge1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gR3JvdXBTcGVjaWZpZXJbVV0gOjpcbi8vICAgW2VtcHR5XVxuLy8gICBgP2AgR3JvdXBOYW1lWz9VXVxucHAkOC5yZWdleHBfZ3JvdXBTcGVjaWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpICE9PSAtMSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5ncm91cE5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gIH1cbn07XG5cbi8vIEdyb3VwTmFtZVtVXSA6OlxuLy8gICBgPGAgUmVnRXhwSWRlbnRpZmllck5hbWVbP1VdIGA+YFxuLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG5wcCQ4LnJlZ2V4cF9lYXRHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBpZiAoc3RhdGUuZWF0KDB4M0MgLyogPCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNFIC8qID4gKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gUmVnRXhwSWRlbnRpZmllck5hbWVbVV0gOjpcbi8vICAgUmVnRXhwSWRlbnRpZmllclN0YXJ0Wz9VXVxuLy8gICBSZWdFeHBJZGVudGlmaWVyTmFtZVs/VV0gUmVnRXhwSWRlbnRpZmllclBhcnRbP1VdXG4vLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbnBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydChzdGF0ZSkpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICB3aGlsZSAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQoc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJTdGFydFtVXSA6OlxuLy8gICBVbmljb2RlSURTdGFydFxuLy8gICBgJGBcbi8vICAgYF9gXG4vLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWz9VXVxucHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIHN0YXRlLmFkdmFuY2UoKTtcblxuICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSkge1xuICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICB9XG4gIGlmIChpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJTdGFydChjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG59XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJQYXJ0W1VdIDo6XG4vLyAgIFVuaWNvZGVJRENvbnRpbnVlXG4vLyAgIGAkYFxuLy8gICBgX2Bcbi8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbP1VdXG4vLyAgIDxaV05KPlxuLy8gICA8WldKPlxucHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgc3RhdGUuYWR2YW5jZSgpO1xuXG4gIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB7XG4gICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gIH1cbiAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi8gfHwgY2ggPT09IDB4MjAwQyAvKiA8WldOSj4gKi8gfHwgY2ggPT09IDB4MjAwRCAvKiA8WldKPiAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXRvbUVzY2FwZVxucHAkOC5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSkgfHxcbiAgICAoc3RhdGUuc3dpdGNoTiAmJiB0aGlzLnJlZ2V4cF9lYXRLR3JvdXBOYW1lKHN0YXRlKSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDYzIC8qIGMgKi8pIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZShzdGF0ZSkpIHtcbiAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gRm9yIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtYXRvbWVzY2FwZVxuICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKG4gPD0gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDZCIC8qIGsgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNoYXJhY3RlckVzY2FwZVxucHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENDb250cm9sTGV0dGVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSB8fFxuICAgICghc3RhdGUuc3dpdGNoVSAmJiB0aGlzLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlKHN0YXRlKSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShzdGF0ZSlcbiAgKVxufTtcbnBwJDgucmVnZXhwX2VhdENDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDgucmVnZXhwX2VhdFplcm8gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDMwIC8qIDAgKi8gJiYgIWlzRGVjaW1hbERpZ2l0KHN0YXRlLmxvb2thaGVhZCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sRXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggPT09IDB4NzQgLyogdCAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDk7IC8qIFxcdCAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg2RSAvKiBuICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQTsgLyogXFxuICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDc2IC8qIHYgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBCOyAvKiBcXHYgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NjYgLyogZiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEM7IC8qIFxcZiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg3MiAvKiByICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwRDsgLyogXFxyICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sTGV0dGVyXG5wcCQ4LnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNDb250cm9sTGV0dGVyKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHtcbiAgcmV0dXJuIChcbiAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NUEgLyogWiAqLykgfHxcbiAgICAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4N0EgLyogeiAqLylcbiAgKVxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1SZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VcbnBwJDgucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NzUgLyogdSAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICB2YXIgbGVhZCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIGxlYWQgPj0gMHhEODAwICYmIGxlYWQgPD0gMHhEQkZGKSB7XG4gICAgICAgIHZhciBsZWFkU3Vycm9nYXRlRW5kID0gc3RhdGUucG9zO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pICYmIHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pICYmIHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgICAgIHZhciB0cmFpbCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgICBpZiAodHJhaWwgPj0gMHhEQzAwICYmIHRyYWlsIDw9IDB4REZGRikge1xuICAgICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gKGxlYWQgLSAweEQ4MDApICogMHg0MDAgKyAodHJhaWwgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyA9IGxlYWRTdXJyb2dhdGVFbmQ7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGxlYWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoXG4gICAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgdGhpcy5yZWdleHBfZWF0SGV4RGlnaXRzKHN0YXRlKSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykgJiZcbiAgICAgIGlzVmFsaWRVbmljb2RlKHN0YXRlLmxhc3RJbnRWYWx1ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNWYWxpZFVuaWNvZGUoY2gpIHtcbiAgcmV0dXJuIGNoID49IDAgJiYgY2ggPD0gMHgxMEZGRkZcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUlkZW50aXR5RXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHgyRiAvKiAvICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRjsgLyogLyAqL1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCAhPT0gMHg2MyAvKiBjICovICYmICghc3RhdGUuc3dpdGNoTiB8fCBjaCAhPT0gMHg2QiAvKiBrICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggPj0gMHgzMSAvKiAxICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykge1xuICAgIGRvIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9IHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzRXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcblxuICBpZiAoaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChcbiAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiZcbiAgICAoY2ggPT09IDB4NTAgLyogUCAqLyB8fCBjaCA9PT0gMHg3MCAvKiBwICovKVxuICApIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgaWYgKFxuICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihzdGF0ZSkgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpIHtcbiAgcmV0dXJuIChcbiAgICBjaCA9PT0gMHg2NCAvKiBkICovIHx8XG4gICAgY2ggPT09IDB4NDQgLyogRCAqLyB8fFxuICAgIGNoID09PSAweDczIC8qIHMgKi8gfHxcbiAgICBjaCA9PT0gMHg1MyAvKiBTICovIHx8XG4gICAgY2ggPT09IDB4NzcgLyogdyAqLyB8fFxuICAgIGNoID09PSAweDU3IC8qIFcgKi9cbiAgKVxufVxuXG4vLyBVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gOjpcbi8vICAgVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbi8vICAgTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG5wcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbiAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNEIC8qID0gKi8pKSB7XG4gICAgdmFyIG5hbWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoc3RhdGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuXG4gIC8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxuICBpZiAodGhpcy5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlKSkge1xuICAgIHZhciBuYW1lT3JWYWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlLCBuYW1lT3JWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWhhcyhzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnksIG5hbWUpKVxuICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgaWYgKCFzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnlbbmFtZV0udGVzdCh2YWx1ZSkpXG4gICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgdmFsdWVcIik7IH1cbn07XG5wcCQ4LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWVPclZhbHVlKSB7XG4gIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMuYmluYXJ5LnRlc3QobmFtZU9yVmFsdWUpKVxuICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbn07XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcnNcbnBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbn07XG5mdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIGlzQ29udHJvbExldHRlcihjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqL1xufVxuXG4vLyBVbmljb2RlUHJvcGVydHlWYWx1ZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbnBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxufTtcbmZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpXG59XG5cbi8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbnBwJDgucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSlcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzXG5wcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHg1QiAvKiBbICovKSkge1xuICAgIHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgIHRoaXMucmVnZXhwX2NsYXNzUmFuZ2VzKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogWyAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIFVucmVhY2hhYmxlIHNpbmNlIGl0IHRocmV3IFwidW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiIGVycm9yIGJlZm9yZS5cbiAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc1Jhbmdlc1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxucHAkOC5yZWdleHBfY2xhc3NSYW5nZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB3aGlsZSAodGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgIHZhciBsZWZ0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICB2YXIgcmlnaHQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21Ob0Rhc2hcbnBwJDgucmVnZXhwX2VhdENsYXNzQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzRXNjYXBlKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIHZhciBjaCQxID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgaWYgKGNoJDEgPT09IDB4NjMgLyogYyAqLyB8fCBpc09jdGFsRGlnaXQoY2gkMSkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNsYXNzIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggIT09IDB4NUQgLyogWyAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NFc2NhcGVcbnBwJDgucmVnZXhwX2VhdENsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IC8qIDxCUz4gKi9cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4MkQgLyogLSAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJEOyAvKiAtICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICghc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKVxuICApXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NDb250cm9sTGV0dGVyXG5wcCQ4LnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc0RlY2ltYWxEaWdpdChjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQ4LnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDc4IC8qIHggKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbERpZ2l0c1xucHAkOC5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5mdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdHNcbnBwJDgucmVnZXhwX2VhdEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzSGV4RGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICByZXR1cm4gKFxuICAgIChjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB8fFxuICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB8fFxuICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKVxuICApXG59XG5mdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICBpZiAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgLyogQSAqLylcbiAgfVxuICBpZiAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgLyogYSAqLylcbiAgfVxuICByZXR1cm4gY2ggLSAweDMwIC8qIDAgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUxlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Vcbi8vIEFsbG93cyBvbmx5IDAtMzc3KG9jdGFsKSBpLmUuIDAtMjU1KGRlY2ltYWwpLlxucHAkOC5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgIHZhciBuMSA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgIHZhciBuMiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChuMSA8PSAzICYmIHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDggKyBuMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1PY3RhbERpZ2l0XG5wcCQ4LnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgLyogMCAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzcgLyogNyAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXg0RGlnaXRzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdFxuLy8gQW5kIEhleERpZ2l0IEhleERpZ2l0IGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQ4LnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuLy8gdXNlZCBmb3IgdGhlIG9uVG9rZW4gY2FsbGJhY2sgYW5kIHRoZSBleHRlcm5hbCB0b2tlbml6ZXIuXG5cbnZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgdGhpcy50eXBlID0gcC50eXBlO1xuICB0aGlzLnZhbHVlID0gcC52YWx1ZTtcbiAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gIHRoaXMuZW5kID0gcC5lbmQ7XG4gIGlmIChwLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpOyB9XG4gIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwLnN0YXJ0LCBwLmVuZF07IH1cbn07XG5cbi8vICMjIFRva2VuaXplclxuXG52YXIgcHAkOSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIE1vdmUgdG8gdGhlIG5leHQgdG9rZW5cblxucHAkOS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbilcbiAgICB7IHRoaXMub3B0aW9ucy5vblRva2VuKG5ldyBUb2tlbih0aGlzKSk7IH1cblxuICB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB0aGlzLm5leHRUb2tlbigpO1xufTtcblxucHAkOS5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIG5ldyBUb2tlbih0aGlzKVxufTtcblxuLy8gSWYgd2UncmUgaW4gYW4gRVM2IGVudmlyb25tZW50LCBtYWtlIHBhcnNlcnMgaXRlcmFibGVcbmlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKVxuICB7IHBwJDlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcyQxLmdldFRva2VuKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdG9rZW4udHlwZSA9PT0gdHlwZXMuZW9mLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyB9XG5cbi8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2Vcbi8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxucHAkOS5jdXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG59O1xuXG4vLyBSZWFkIGEgc2luZ2xlIHRva2VuLCB1cGRhdGluZyB0aGUgcGFyc2VyIG9iamVjdCdzIHRva2VuLXJlbGF0ZWRcbi8vIHByb3BlcnRpZXMuXG5cbnBwJDkubmV4dFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gIGlmICghY3VyQ29udGV4dCB8fCAhY3VyQ29udGV4dC5wcmVzZXJ2ZVNwYWNlKSB7IHRoaXMuc2tpcFNwYWNlKCk7IH1cblxuICB0aGlzLnN0YXJ0ID0gdGhpcy5wb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuc3RhcnRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVvZikgfVxuXG4gIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7IHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpIH1cbiAgZWxzZSB7IHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7IH1cbn07XG5cbnBwJDkucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkge1xuICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgLy8gaWRlbnRpZmllcnMsIHNvICdcXCcgYWxzbyBkaXNwYXRjaGVzIHRvIHRoYXQuXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLylcbiAgICB7IHJldHVybiB0aGlzLnJlYWRXb3JkKCkgfVxuXG4gIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSlcbn07XG5cbnBwJDkuZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGUwMDApIHsgcmV0dXJuIGNvZGUgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICByZXR1cm4gKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxufTtcblxucHAkOS5za2lwQmxvY2tDb21tZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5wb3MgKz0gMik7XG4gIGlmIChlbmQgPT09IC0xKSB7IHRoaXMucmFpc2UodGhpcy5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpOyB9XG4gIHRoaXMucG9zID0gZW5kICsgMjtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrRy5leGVjKHRoaXMuaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRoaXMucG9zKSB7XG4gICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgIHRoaXMubGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudCh0cnVlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbn07XG5cbnBwJDkuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24oc3RhcnRTa2lwKSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICs9IHN0YXJ0U2tpcCk7XG4gIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoICYmICFpc05ld0xpbmUoY2gpKSB7XG4gICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KGZhbHNlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0aGlzLnBvcyksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG59O1xuXG4vLyBDYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBhbmQgYWZ0ZXIgZXZlcnkgdG9rZW4uIFNraXBzXG4vLyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYW5kLlxuXG5wcCQ5LnNraXBTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICBsb29wOiB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMzI6IGNhc2UgMTYwOiAvLyAnICdcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBicmVha1xuICAgIGNhc2UgMTM6XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEwKSB7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9XG4gICAgY2FzZSAxMDogY2FzZSA4MjMyOiBjYXNlIDgyMzM6XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgNDc6IC8vICcvJ1xuICAgICAgc3dpdGNoICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSkge1xuICAgICAgY2FzZSA0MjogLy8gJyonXG4gICAgICAgIHRoaXMuc2tpcEJsb2NrQ29tbWVudCgpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhayBsb29wXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPiA4ICYmIGNoIDwgMTQgfHwgY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrIGxvb3BcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIENhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHRva2VuLiBTZXRzIGBlbmRgLCBgdmFsYCwgYW5kXG4vLyBtYWludGFpbnMgYGNvbnRleHRgIGFuZCBgZXhwckFsbG93ZWRgLCBhbmQgc2tpcHMgdGhlIHNwYWNlIGFmdGVyXG4vLyB0aGUgdG9rZW4sIHNvIHRoYXQgdGhlIG5leHQgb25lJ3MgYHN0YXJ0YCB3aWxsIHBvaW50IGF0IHRoZVxuLy8gcmlnaHQgcG9zaXRpb24uXG5cbnBwJDkuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIHtcbiAgdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG59O1xuXG4vLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4vLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbi8vIGlzIHNvbWV3aGF0IG9ic2N1cmUsIGJlY2F1c2UgaXQgd29ya3MgaW4gY2hhcmFjdGVyIGNvZGVzIHJhdGhlclxuLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbi8vIGludG8gaXQuXG4vL1xuLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuLy9cbnBwJDkucmVhZFRva2VuX2RvdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7IHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSkgfVxuICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5leHQgPT09IDQ2ICYmIG5leHQyID09PSA0NikgeyAvLyA0NiA9IGRvdCAnLidcbiAgICB0aGlzLnBvcyArPSAzO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVsbGlwc2lzKVxuICB9IGVsc2Uge1xuICAgICsrdGhpcy5wb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG90KVxuICB9XG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9zbGFzaCA9IGZ1bmN0aW9uKCkgeyAvLyAnLydcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5zbGFzaCwgMSlcbn07XG5cbnBwJDkucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJyUqJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICB2YXIgc2l6ZSA9IDE7XG4gIHZhciB0b2tlbnR5cGUgPSBjb2RlID09PSA0MiA/IHR5cGVzLnN0YXIgOiB0eXBlcy5tb2R1bG87XG5cbiAgLy8gZXhwb25lbnRpYXRpb24gb3BlcmF0b3IgKiogYW5kICoqPVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICArK3NpemU7XG4gICAgdG9rZW50eXBlID0gdHlwZXMuc3RhcnN0YXI7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodG9rZW50eXBlLCBzaXplKVxufTtcblxucHAkOS5yZWFkVG9rZW5fcGlwZV9hbXAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICd8JidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMubG9naWNhbE9SIDogdHlwZXMubG9naWNhbEFORCwgMikgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmJpdHdpc2VPUiA6IHR5cGVzLmJpdHdpc2VBTkQsIDEpXG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9jYXJldCA9IGZ1bmN0aW9uKCkgeyAvLyAnXidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXR3aXNlWE9SLCAxKVxufTtcblxucHAkOS5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbihjb2RlKSB7IC8vICcrLSdcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICBpZiAobmV4dCA9PT0gNDUgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyICYmXG4gICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuaW5jRGVjLCAyKVxuICB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucGx1c01pbiwgMSlcbn07XG5cbnBwJDkucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPD4nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHZhciBzaXplID0gMTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICBzaXplID0gY29kZSA9PT0gNjIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyID8gMyA6IDI7XG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIHNpemUpID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYml0U2hpZnQsIHNpemUpXG4gIH1cbiAgaWYgKG5leHQgPT09IDMzICYmIGNvZGUgPT09IDYwICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA0NSAmJlxuICAgICAgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMykgPT09IDQ1KSB7XG4gICAgLy8gYDwhLS1gLCBhbiBYTUwtc3R5bGUgY29tbWVudCB0aGF0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIGxpbmUgY29tbWVudFxuICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgc2l6ZSA9IDI7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucmVsYXRpb25hbCwgc2l6ZSlcbn07XG5cbnBwJDkucmVhZFRva2VuX2VxX2V4Y2wgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc9ISdcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMikgfVxuICBpZiAoY29kZSA9PT0gNjEgJiYgbmV4dCA9PT0gNjIgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgLy8gJz0+J1xuICAgIHRoaXMucG9zICs9IDI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYXJyb3cpXG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcy5lcSA6IHR5cGVzLnByZWZpeCwgMSlcbn07XG5cbnBwJDkuZ2V0VG9rZW5Gcm9tQ29kZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gIC8vIFRoZSBpbnRlcnByZXRhdGlvbiBvZiBhIGRvdCBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaXMgZm9sbG93ZWRcbiAgLy8gYnkgYSBkaWdpdCBvciBhbm90aGVyIHR3byBkb3RzLlxuICBjYXNlIDQ2OiAvLyAnLidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZG90KClcblxuICAvLyBQdW5jdHVhdGlvbiB0b2tlbnMuXG4gIGNhc2UgNDA6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuTClcbiAgY2FzZSA0MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5SKVxuICBjYXNlIDU5OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zZW1pKVxuICBjYXNlIDQ0OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb21tYSlcbiAgY2FzZSA5MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldEwpXG4gIGNhc2UgOTM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRSKVxuICBjYXNlIDEyMzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VMKVxuICBjYXNlIDEyNTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VSKVxuICBjYXNlIDU4OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb2xvbilcbiAgY2FzZSA2MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucXVlc3Rpb24pXG5cbiAgY2FzZSA5NjogLy8gJ2AnXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgYnJlYWsgfVxuICAgICsrdGhpcy5wb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuXG4gIGNhc2UgNDg6IC8vICcwJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpIH0gLy8gJzBvJywgJzBPJyAtIG9jdGFsIG51bWJlclxuICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgfVxuXG4gIC8vIEFueXRoaW5nIGVsc2UgYmVnaW5uaW5nIHdpdGggYSBkaWdpdCBpcyBhbiBpbnRlZ2VyLCBvY3RhbFxuICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiAvLyAxLTlcbiAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKVxuXG4gIC8vIFF1b3RlcyBwcm9kdWNlIHN0cmluZ3MuXG4gIGNhc2UgMzQ6IGNhc2UgMzk6IC8vICdcIicsIFwiJ1wiXG4gICAgcmV0dXJuIHRoaXMucmVhZFN0cmluZyhjb2RlKVxuXG4gIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAvLyBjaGFyYWN0ZXJzIGl0IGlzIGdpdmVuIGFzIHNlY29uZCBhcmd1bWVudCwgYW5kIHJldHVybnMgYSB0b2tlblxuICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG5cbiAgY2FzZSA0NzogLy8gJy8nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3NsYXNoKClcblxuICBjYXNlIDM3OiBjYXNlIDQyOiAvLyAnJSonXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChjb2RlKVxuXG4gIGNhc2UgMTI0OiBjYXNlIDM4OiAvLyAnfCYnXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpXG5cbiAgY2FzZSA5NDogLy8gJ14nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KClcblxuICBjYXNlIDQzOiBjYXNlIDQ1OiAvLyAnKy0nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpXG5cbiAgY2FzZSA2MDogY2FzZSA2MjogLy8gJzw+J1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9sdF9ndChjb2RlKVxuXG4gIGNhc2UgNjE6IGNhc2UgMzM6IC8vICc9ISdcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKVxuXG4gIGNhc2UgMTI2OiAvLyAnfidcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wcmVmaXgsIDEpXG4gIH1cblxuICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nJDEoY29kZSkgKyBcIidcIik7XG59O1xuXG5wcCQ5LmZpbmlzaE9wID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgKyBzaXplKTtcbiAgdGhpcy5wb3MgKz0gc2l6ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKVxufTtcblxucHAkOS5yZWFkUmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICArK3RoaXMucG9zO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICArK3RoaXMucG9zO1xuICB2YXIgZmxhZ3NTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgZmxhZ3MgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnVuZXhwZWN0ZWQoZmxhZ3NTdGFydCk7IH1cblxuICAvLyBWYWxpZGF0ZSBwYXR0ZXJuXG4gIHZhciBzdGF0ZSA9IHRoaXMucmVnZXhwU3RhdGUgfHwgKHRoaXMucmVnZXhwU3RhdGUgPSBuZXcgUmVnRXhwVmFsaWRhdGlvblN0YXRlKHRoaXMpKTtcbiAgc3RhdGUucmVzZXQoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKTtcbiAgdGhpcy52YWxpZGF0ZVJlZ0V4cEZsYWdzKHN0YXRlKTtcbiAgdGhpcy52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4oc3RhdGUpO1xuXG4gIC8vIENyZWF0ZSBMaXRlcmFsI3ZhbHVlIHByb3BlcnR5IHZhbHVlLlxuICB2YXIgdmFsdWUgPSBudWxsO1xuICB0cnkge1xuICAgIHZhbHVlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFU1RyZWUgcmVxdWlyZXMgbnVsbCBpZiBpdCBmYWlsZWQgdG8gaW5zdGFudGlhdGUgUmVnRXhwIG9iamVjdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXN0cmVlL2VzdHJlZS9ibG9iL2EyNzAwM2FkZjRmZDdiZmFkNDRkZTljZWYzNzJhMmVhY2Q1MjdiMWMvZXM1Lm1kI3JlZ2V4cGxpdGVyYWxcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnJlZ2V4cCwge3BhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncywgdmFsdWU6IHZhbHVlfSlcbn07XG5cbi8vIFJlYWQgYW4gaW50ZWdlciBpbiB0aGUgZ2l2ZW4gcmFkaXguIFJldHVybiBudWxsIGlmIHplcm8gZGlnaXRzXG4vLyB3ZXJlIHJlYWQsIHRoZSBpbnRlZ2VyIHZhbHVlIG90aGVyd2lzZS4gV2hlbiBgbGVuYCBpcyBnaXZlbiwgdGhpc1xuLy8gd2lsbCByZXR1cm4gYG51bGxgIHVubGVzcyB0aGUgaW50ZWdlciBoYXMgZXhhY3RseSBgbGVuYCBkaWdpdHMuXG5cbnBwJDkucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4pIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIHRvdGFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCB2YWwgPSAodm9pZCAwKTtcbiAgICBpZiAoY29kZSA+PSA5NykgeyB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgfSAvLyBhXG4gICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgeyB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgfSAvLyBBXG4gICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICBlbHNlIHsgdmFsID0gSW5maW5pdHk7IH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICArK3RoaXMucG9zO1xuICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgfVxuICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgeyByZXR1cm4gbnVsbCB9XG5cbiAgcmV0dXJuIHRvdGFsXG59O1xuXG5wcCQ5LnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICB0aGlzLnBvcyArPSAyOyAvLyAweFxuICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgaWYgKHZhbCA9PSBudWxsKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCArIDIsIFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4IFwiICsgcmFkaXgpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTEwKSB7XG4gICAgdmFsID0gdHlwZW9mIEJpZ0ludCAhPT0gXCJ1bmRlZmluZWRcIiA/IEJpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpIDogbnVsbDtcbiAgICArK3RoaXMucG9zO1xuICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbn07XG5cbi8vIFJlYWQgYW4gaW50ZWdlciwgb2N0YWwgaW50ZWdlciwgb3IgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXG5wcCQ5LnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIHZhciBvY3RhbCA9IHRoaXMucG9zIC0gc3RhcnQgPj0gMiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc3RhcnQpID09PSA0ODtcbiAgaWYgKG9jdGFsICYmIHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgaWYgKG9jdGFsICYmIC9bODldLy50ZXN0KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSkpIHsgb2N0YWwgPSBmYWxzZTsgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIGlmICghb2N0YWwgJiYgIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIG5leHQgPT09IDExMCkge1xuICAgIHZhciBzdHIkMSA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgICB2YXIgdmFsJDEgPSB0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiID8gQmlnSW50KHN0ciQxKSA6IG51bGw7XG4gICAgKyt0aGlzLnBvcztcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwkMSlcbiAgfVxuICBpZiAobmV4dCA9PT0gNDYgJiYgIW9jdGFsKSB7IC8vICcuJ1xuICAgICsrdGhpcy5wb3M7XG4gICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgfVxuICBpZiAoKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkgJiYgIW9jdGFsKSB7IC8vICdlRSdcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgeyArK3RoaXMucG9zOyB9IC8vICcrLSdcbiAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIH1cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuXG4gIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gIHZhciB2YWwgPSBvY3RhbCA/IHBhcnNlSW50KHN0ciwgOCkgOiBwYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxufTtcblxuLy8gUmVhZCBhIHN0cmluZyB2YWx1ZSwgaW50ZXJwcmV0aW5nIGJhY2tzbGFzaC1lc2NhcGVzLlxuXG5wcCQ5LnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZTtcblxuICBpZiAoY2ggPT09IDEyMykgeyAvLyAneydcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7IH1cbiAgfSBlbHNlIHtcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcig0KTtcbiAgfVxuICByZXR1cm4gY29kZVxufTtcblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmckMShjb2RlKSB7XG4gIC8vIFVURi0xNiBEZWNvZGluZ1xuICBpZiAoY29kZSA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgfVxuICBjb2RlIC09IDB4MTAwMDA7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4RDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4REMwMClcbn1cblxucHAkOS5yZWFkU3RyaW5nID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSArK3RoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY2ggPT09IHF1b3RlKSB7IGJyZWFrIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc05ld0xpbmUoY2gsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMCkpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICB9XG4gIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zdHJpbmcsIG91dClcbn07XG5cbi8vIFJlYWRzIHRlbXBsYXRlIHN0cmluZyB0b2tlbnMuXG5cbnZhciBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUiA9IHt9O1xuXG5wcCQ5LnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSB0cnVlO1xuICB0cnkge1xuICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyID09PSBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUikge1xuICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IGZhbHNlO1xufTtcblxucHAkOS5pbnZhbGlkU3RyaW5nVG9rZW4gPSBmdW5jdGlvbihwb3NpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5pblRlbXBsYXRlRWxlbWVudCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgIHRocm93IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yYWlzZShwb3NpdGlvbiwgbWVzc2FnZSk7XG4gIH1cbn07XG5cbnBwJDkucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7IH1cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmIChjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMjMpIHsgLy8gJ2AnLCAnJHsnXG4gICAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuc3RhcnQgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMudGVtcGxhdGUgfHwgdGhpcy50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmRvbGxhckJyYWNlTClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMudGVtcGxhdGUsIG91dClcbiAgICB9XG4gICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIodHJ1ZSk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH1cbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICB9XG59O1xuXG4vLyBSZWFkcyBhIHRlbXBsYXRlIHRva2VuIHRvIHNlYXJjaCBmb3IgdGhlIGVuZCwgd2l0aG91dCB2YWxpZGF0aW5nIGFueSBlc2NhcGUgc2VxdWVuY2VzXG5wcCQ5LnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKDsgdGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aDsgdGhpcy5wb3MrKykge1xuICAgIHN3aXRjaCAodGhpcy5pbnB1dFt0aGlzLnBvc10pIHtcbiAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiJFwiOlxuICAgICAgaWYgKHRoaXMuaW5wdXRbdGhpcy5wb3MgKyAxXSAhPT0gXCJ7XCIpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAvLyBmYWxscyB0aHJvdWdoXG5cbiAgICBjYXNlIFwiYFwiOlxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuaW52YWxpZFRlbXBsYXRlLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKSlcblxuICAgIC8vIG5vIGRlZmF1bHRcbiAgICB9XG4gIH1cbiAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBlc2NhcGVkIGNoYXJhY3RlcnNcblxucHAkOS5yZWFkRXNjYXBlZENoYXIgPSBmdW5jdGlvbihpblRlbXBsYXRlKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgKyt0aGlzLnBvcztcbiAgc3dpdGNoIChjaCkge1xuICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgLy8gJ24nIC0+ICdcXG4nXG4gIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIiAvLyAncicgLT4gJ1xccidcbiAgY2FzZSAxMjA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEhleENoYXIoMikpIC8vICd4J1xuICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nJDEodGhpcy5yZWFkQ29kZVBvaW50KCkpIC8vICd1J1xuICBjYXNlIDExNjogcmV0dXJuIFwiXFx0XCIgLy8gJ3QnIC0+ICdcXHQnXG4gIGNhc2UgOTg6IHJldHVybiBcIlxcYlwiIC8vICdiJyAtPiAnXFxiJ1xuICBjYXNlIDExODogcmV0dXJuIFwiXFx1MDAwYlwiIC8vICd2JyAtPiAnXFx1MDAwYidcbiAgY2FzZSAxMDI6IHJldHVybiBcIlxcZlwiIC8vICdmJyAtPiAnXFxmJ1xuICBjYXNlIDEzOiBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfSAvLyAnXFxyXFxuJ1xuICBjYXNlIDEwOiAvLyAnIFxcbidcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zOyArK3RoaXMuY3VyTGluZTsgfVxuICAgIHJldHVybiBcIlwiXG4gIGRlZmF1bHQ6XG4gICAgaWYgKGNoID49IDQ4ICYmIGNoIDw9IDU1KSB7XG4gICAgICB2YXIgb2N0YWxTdHIgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcyAtIDEsIDMpLm1hdGNoKC9eWzAtN10rLylbMF07XG4gICAgICB2YXIgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICBpZiAob2N0YWwgPiAyNTUpIHtcbiAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmICgob2N0YWxTdHIgIT09IFwiMFwiIHx8IGNoID09PSA1NiB8fCBjaCA9PT0gNTcpICYmICh0aGlzLnN0cmljdCB8fCBpblRlbXBsYXRlKSkge1xuICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICB0aGlzLnBvcyAtIDEgLSBvY3RhbFN0ci5sZW5ndGgsXG4gICAgICAgICAgaW5UZW1wbGF0ZVxuICAgICAgICAgICAgPyBcIk9jdGFsIGxpdGVyYWwgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgICAgIDogXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdGFsKVxuICAgIH1cbiAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgLy8gVW5pY29kZSBuZXcgbGluZSBjaGFyYWN0ZXJzIGFmdGVyIFxcIGdldCByZW1vdmVkIGZyb20gb3V0cHV0IGluIGJvdGhcbiAgICAgIC8vIHRlbXBsYXRlIGxpdGVyYWxzIGFuZCBzdHJpbmdzXG4gICAgICByZXR1cm4gXCJcIlxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaClcbiAgfVxufTtcblxuLy8gVXNlZCB0byByZWFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VzICgnXFx4JywgJ1xcdScsICdcXFUnKS5cblxucHAkOS5yZWFkSGV4Q2hhciA9IGZ1bmN0aW9uKGxlbikge1xuICB2YXIgY29kZVBvcyA9IHRoaXMucG9zO1xuICB2YXIgbiA9IHRoaXMucmVhZEludCgxNiwgbGVuKTtcbiAgaWYgKG4gPT09IG51bGwpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKTsgfVxuICByZXR1cm4gblxufTtcblxuLy8gUmVhZCBhbiBpZGVudGlmaWVyLCBhbmQgcmV0dXJuIGl0IGFzIGEgc3RyaW5nLiBTZXRzIGB0aGlzLmNvbnRhaW5zRXNjYFxuLy8gdG8gd2hldGhlciB0aGUgd29yZCBjb250YWluZWQgYSAnXFx1JyBlc2NhcGUuXG4vL1xuLy8gSW5jcmVtZW50YWxseSBhZGRzIG9ubHkgZXNjYXBlZCBjaGFycywgYWRkaW5nIG90aGVyIGNodW5rcyBhcy1pc1xuLy8gYXMgYSBtaWNyby1vcHRpbWl6YXRpb24uXG5cbnBwJDkucmVhZFdvcmQxID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgdmFyIHdvcmQgPSBcIlwiLCBmaXJzdCA9IHRydWUsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIGFzdHJhbCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgIHZhciBjaCA9IHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCwgYXN0cmFsKSkge1xuICAgICAgdGhpcy5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHsgLy8gXCJcXFwiXG4gICAgICB0aGlzLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgIHdvcmQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICB2YXIgZXNjU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykgIT09IDExNykgLy8gXCJ1XCJcbiAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbih0aGlzLnBvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpOyB9XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgdmFyIGVzYyA9IHRoaXMucmVhZENvZGVQb2ludCgpO1xuICAgICAgaWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydCA6IGlzSWRlbnRpZmllckNoYXIpKGVzYywgYXN0cmFsKSlcbiAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihlc2NTdGFydCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpOyB9XG4gICAgICB3b3JkICs9IGNvZGVQb2ludFRvU3RyaW5nJDEoZXNjKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZmlyc3QgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG59O1xuXG4vLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbi8vIHdvcmRzIHdoZW4gbmVjZXNzYXJ5LlxuXG5wcCQ5LnJlYWRXb3JkID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgdmFyIHR5cGUgPSB0eXBlcy5uYW1lO1xuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgXCIgKyB3b3JkKTsgfVxuICAgIHR5cGUgPSBrZXl3b3JkcyQxW3dvcmRdO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpXG59O1xuXG4vLyBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlxuXG52YXIgdmVyc2lvbiA9IFwiNi40LjBcIjtcblxuUGFyc2VyLmFjb3JuID0ge1xuICBQYXJzZXI6IFBhcnNlcixcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgZGVmYXVsdE9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxuICBQb3NpdGlvbjogUG9zaXRpb24sXG4gIFNvdXJjZUxvY2F0aW9uOiBTb3VyY2VMb2NhdGlvbixcbiAgZ2V0TGluZUluZm86IGdldExpbmVJbmZvLFxuICBOb2RlOiBOb2RlLFxuICBUb2tlblR5cGU6IFRva2VuVHlwZSxcbiAgdG9rVHlwZXM6IHR5cGVzLFxuICBrZXl3b3JkVHlwZXM6IGtleXdvcmRzJDEsXG4gIFRva0NvbnRleHQ6IFRva0NvbnRleHQsXG4gIHRva0NvbnRleHRzOiB0eXBlcyQxLFxuICBpc0lkZW50aWZpZXJDaGFyOiBpc0lkZW50aWZpZXJDaGFyLFxuICBpc0lkZW50aWZpZXJTdGFydDogaXNJZGVudGlmaWVyU3RhcnQsXG4gIFRva2VuOiBUb2tlbixcbiAgaXNOZXdMaW5lOiBpc05ld0xpbmUsXG4gIGxpbmVCcmVhazogbGluZUJyZWFrLFxuICBsaW5lQnJlYWtHOiBsaW5lQnJlYWtHLFxuICBub25BU0NJSXdoaXRlc3BhY2U6IG5vbkFTQ0lJd2hpdGVzcGFjZVxufTtcblxuLy8gVGhlIG1haW4gZXhwb3J0ZWQgaW50ZXJmYWNlICh1bmRlciBgc2VsZi5hY29ybmAgd2hlbiBpbiB0aGVcbi8vIGJyb3dzZXIpIGlzIGEgYHBhcnNlYCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgY29kZSBzdHJpbmcgYW5kXG4vLyByZXR1cm5zIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlIGFzIHNwZWNpZmllZCBieSBbTW96aWxsYSBwYXJzZXJcbi8vIEFQSV1bYXBpXS5cbi8vXG4vLyBbYXBpXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9TcGlkZXJNb25rZXkvUGFyc2VyX0FQSVxuXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gUGFyc2VyLnBhcnNlKGlucHV0LCBvcHRpb25zKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGEgc2luZ2xlIGV4cHJlc3Npb24gYXQgYSBnaXZlblxuLy8gb2Zmc2V0IGluIGEgc3RyaW5nLiBVc2VmdWwgZm9yIHBhcnNpbmcgbWl4ZWQtbGFuZ3VhZ2UgZm9ybWF0c1xuLy8gdGhhdCBlbWJlZCBKYXZhU2NyaXB0IGV4cHJlc3Npb25zLlxuXG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gIHJldHVybiBQYXJzZXIucGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucylcbn1cblxuLy8gQWNvcm4gaXMgb3JnYW5pemVkIGFzIGEgdG9rZW5pemVyIGFuZCBhIHJlY3Vyc2l2ZS1kZXNjZW50IHBhcnNlci5cbi8vIFRoZSBgdG9rZW5pemVyYCBleHBvcnQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRvIHRoZSB0b2tlbml6ZXIuXG5cbmZ1bmN0aW9uIHRva2VuaXplcihpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gUGFyc2VyLnRva2VuaXplcihpbnB1dCwgb3B0aW9ucylcbn1cblxuZXhwb3J0IHsgTm9kZSwgUGFyc2VyLCBQb3NpdGlvbiwgU291cmNlTG9jYXRpb24sIFRva0NvbnRleHQsIFRva2VuLCBUb2tlblR5cGUsIGRlZmF1bHRPcHRpb25zLCBnZXRMaW5lSW5mbywgaXNJZGVudGlmaWVyQ2hhciwgaXNJZGVudGlmaWVyU3RhcnQsIGlzTmV3TGluZSwga2V5d29yZHMkMSBhcyBrZXl3b3JkVHlwZXMsIGxpbmVCcmVhaywgbGluZUJyZWFrRywgbm9uQVNDSUl3aGl0ZXNwYWNlLCBwYXJzZSwgcGFyc2VFeHByZXNzaW9uQXQsIHR5cGVzJDEgYXMgdG9rQ29udGV4dHMsIHR5cGVzIGFzIHRva1R5cGVzLCB0b2tlbml6ZXIsIHZlcnNpb24gfTtcbiIsIi8qIVxuICogUGFwZXIuanMgdjAuMTIuMTEgLSBUaGUgU3dpc3MgQXJteSBLbmlmZSBvZiBWZWN0b3IgR3JhcGhpY3MgU2NyaXB0aW5nLlxuICogaHR0cDovL3BhcGVyanMub3JnL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSAtIDIwMjAsIErDvHJnIExlaG5pICYgSm9uYXRoYW4gUHVja2V5XG4gKiBodHRwOi8vanVlcmdsZWhuaS5jb20vICYgaHR0cHM6Ly9wdWNrZXkuc3R1ZGlvL1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbiAqXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIERhdGU6IEZyaSBKdW4gMTkgMTk6MTQ6MzMgMjAyMCArMDIwMFxuICpcbiAqKipcbiAqXG4gKiBTdHJhcHMuanMgLSBDbGFzcyBpbmhlcml0YW5jZSBsaWJyYXJ5IHdpdGggc3VwcG9ydCBmb3IgYmVhbi1zdHlsZSBhY2Nlc3NvcnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDYgLSAyMDIwIErDvHJnIExlaG5pXG4gKiBodHRwOi8vanVlcmdsZWhuaS5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICpcbiAqKipcbiAqXG4gKiBBY29ybi5qc1xuICogaHR0cHM6Ly9tYXJpam5oYXZlcmJla2UubmwvYWNvcm4vXG4gKlxuICogQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdCxcbiAqIGNyZWF0ZWQgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4gKlxuICovXG52YXIgcGFwZXIgPSBmdW5jdGlvbiAoc2VsZiwgdW5kZWZpbmVkKSB7XG4gIHNlbGYgPSBzZWxmIHx8IHJlcXVpcmUoJy4vbm9kZS9zZWxmLmpzJyk7XG4gIHZhciB3aW5kb3cgPSBzZWxmLndpbmRvdyxcbiAgICAgIGRvY3VtZW50ID0gc2VsZi5kb2N1bWVudDtcbiAgdmFyIEJhc2UgPSBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoaWRkZW4gPSAvXihzdGF0aWNzfGVudW1lcmFibGV8YmVhbnN8cHJlc2VydmUpJC8sXG4gICAgICAgIGFycmF5ID0gW10sXG4gICAgICAgIHNsaWNlID0gYXJyYXkuc2xpY2UsXG4gICAgICAgIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICAgIGRlc2NyaWJlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICAgICAgZGVmaW5lID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICBmb3JFYWNoID0gYXJyYXkuZm9yRWFjaCB8fCBmdW5jdGlvbiAoaXRlciwgYmluZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgZm9ySW4gPSBmdW5jdGlvbiAoaXRlciwgYmluZCkge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGkpKSBpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgc2V0ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAoZHN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkc3Q7XG4gICAgfSxcbiAgICAgICAgZWFjaCA9IGZ1bmN0aW9uIChvYmosIGl0ZXIsIGJpbmQpIHtcbiAgICAgIGlmIChvYmopIHtcbiAgICAgICAgdmFyIGRlc2MgPSBkZXNjcmliZShvYmosICdsZW5ndGgnKTtcbiAgICAgICAgKGRlc2MgJiYgdHlwZW9mIGRlc2MudmFsdWUgPT09ICdudW1iZXInID8gZm9yRWFjaCA6IGZvckluKS5jYWxsKG9iaiwgaXRlciwgYmluZCA9IGJpbmQgfHwgb2JqKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGluamVjdChkZXN0LCBzcmMsIGVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSkge1xuICAgICAgdmFyIGJlYW5zTmFtZXMgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gZmllbGQobmFtZSwgdmFsKSB7XG4gICAgICAgIHZhbCA9IHZhbCB8fCAodmFsID0gZGVzY3JpYmUoc3JjLCBuYW1lKSkgJiYgKHZhbC5nZXQgPyB2YWwgOiB2YWwudmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnIycpIHZhbCA9IGRlc3RbdmFsLnN1YnN0cmluZygxKV0gfHwgdmFsO1xuICAgICAgICB2YXIgaXNGdW5jID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgIHJlcyA9IHZhbCxcbiAgICAgICAgICAgIHByZXYgPSBwcmVzZXJ2ZSB8fCBpc0Z1bmMgJiYgIXZhbC5iYXNlID8gdmFsICYmIHZhbC5nZXQgPyBuYW1lIGluIGRlc3QgOiBkZXN0W25hbWVdIDogbnVsbCxcbiAgICAgICAgICAgIGJlYW47XG5cbiAgICAgICAgaWYgKCFwcmVzZXJ2ZSB8fCAhcHJldikge1xuICAgICAgICAgIGlmIChpc0Z1bmMgJiYgcHJldikgdmFsLmJhc2UgPSBwcmV2O1xuICAgICAgICAgIGlmIChpc0Z1bmMgJiYgYmVhbnMgIT09IGZhbHNlICYmIChiZWFuID0gbmFtZS5tYXRjaCgvXihbZ3NdZXR8aXMpKChbQS1aXSkoLiopKSQvKSkpIGJlYW5zTmFtZXNbYmVhblszXS50b0xvd2VyQ2FzZSgpICsgYmVhbls0XV0gPSBiZWFuWzJdO1xuXG4gICAgICAgICAgaWYgKCFyZXMgfHwgaXNGdW5jIHx8ICFyZXMuZ2V0IHx8IHR5cGVvZiByZXMuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8ICFCYXNlLmlzUGxhaW5PYmplY3QocmVzKSkge1xuICAgICAgICAgICAgcmVzID0ge1xuICAgICAgICAgICAgICB2YWx1ZTogcmVzLFxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoKGRlc2NyaWJlKGRlc3QsIG5hbWUpIHx8IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgcmVzLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICByZXMuZW51bWVyYWJsZSA9IGVudW1lcmFibGUgIT0gbnVsbCA/IGVudW1lcmFibGUgOiAhYmVhbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZpbmUoZGVzdCwgbmFtZSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gc3JjKSB7XG4gICAgICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhaGlkZGVuLnRlc3QobmFtZSkpIGZpZWxkKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBiZWFuc05hbWVzKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBiZWFuc05hbWVzW25hbWVdLFxuICAgICAgICAgICAgICBzZXQgPSBkZXN0WydzZXQnICsgcGFydF0sXG4gICAgICAgICAgICAgIGdldCA9IGRlc3RbJ2dldCcgKyBwYXJ0XSB8fCBzZXQgJiYgZGVzdFsnaXMnICsgcGFydF07XG4gICAgICAgICAgaWYgKGdldCAmJiAoYmVhbnMgPT09IHRydWUgfHwgZ2V0Lmxlbmd0aCA9PT0gMCkpIGZpZWxkKG5hbWUsIHtcbiAgICAgICAgICAgIGdldDogZ2V0LFxuICAgICAgICAgICAgc2V0OiBzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCYXNlKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlmIChzcmMpIHNldCh0aGlzLCBzcmMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5qZWN0KEJhc2UsIHtcbiAgICAgIGluamVjdDogZnVuY3Rpb24gKHNyYykge1xuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgdmFyIHN0YXRpY3MgPSBzcmMuc3RhdGljcyA9PT0gdHJ1ZSA/IHNyYyA6IHNyYy5zdGF0aWNzLFxuICAgICAgICAgICAgICBiZWFucyA9IHNyYy5iZWFucyxcbiAgICAgICAgICAgICAgcHJlc2VydmUgPSBzcmMucHJlc2VydmU7XG4gICAgICAgICAgaWYgKHN0YXRpY3MgIT09IHNyYykgaW5qZWN0KHRoaXMucHJvdG90eXBlLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpO1xuICAgICAgICAgIGluamVjdCh0aGlzLCBzdGF0aWNzLCBudWxsLCBiZWFucywgcHJlc2VydmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB0aGlzLmluamVjdChhcmd1bWVudHNbaV0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGV4dGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmFzZSA9IHRoaXMsXG4gICAgICAgICAgICBjdG9yLFxuICAgICAgICAgICAgcHJvdG87XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9iaiwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsICYmICEoY3RvciAmJiBwcm90byk7IGkrKykge1xuICAgICAgICAgIG9iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBjdG9yID0gY3RvciB8fCBvYmouaW5pdGlhbGl6ZTtcbiAgICAgICAgICBwcm90byA9IHByb3RvIHx8IG9iai5wcm90b3R5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBjdG9yID0gY3RvciB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByb3RvID0gY3Rvci5wcm90b3R5cGUgPSBwcm90byB8fCBjcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAgICAgICBkZWZpbmUocHJvdG8sICdjb25zdHJ1Y3RvcicsIHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGluamVjdChjdG9yLCB0aGlzKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHRoaXMuaW5qZWN0LmFwcGx5KGN0b3IsIGFyZ3VtZW50cyk7XG4gICAgICAgIGN0b3IuYmFzZSA9IGJhc2U7XG4gICAgICAgIHJldHVybiBjdG9yO1xuICAgICAgfVxuICAgIH0pLmluamVjdCh7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxpemU6IEJhc2UsXG4gICAgICBzZXQ6IEJhc2UsXG4gICAgICBpbmplY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgIGluamVjdCh0aGlzLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBzcmMuYmVhbnMsIHNyYy5wcmVzZXJ2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBjcmVhdGUodGhpcyk7XG4gICAgICAgIHJldHVybiByZXMuaW5qZWN0LmFwcGx5KHJlcywgYXJndW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBlYWNoOiBmdW5jdGlvbiAoaXRlciwgYmluZCkge1xuICAgICAgICByZXR1cm4gZWFjaCh0aGlzLCBpdGVyLCBiaW5kKTtcbiAgICAgIH0sXG4gICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gICAgICB9LFxuICAgICAgc3RhdGljczoge1xuICAgICAgICBzZXQ6IHNldCxcbiAgICAgICAgZWFjaDogZWFjaCxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgICAgIGRlZmluZTogZGVmaW5lLFxuICAgICAgICBkZXNjcmliZTogZGVzY3JpYmUsXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIHNldChuZXcgb2JqLmNvbnN0cnVjdG9yKCksIG9iaik7XG4gICAgICAgIH0sXG4gICAgICAgIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICB2YXIgY3RvciA9IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICByZXR1cm4gY3RvciAmJiAoY3RvciA9PT0gT2JqZWN0IHx8IGN0b3IgPT09IEJhc2UgfHwgY3Rvci5uYW1lID09PSAnT2JqZWN0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIHBpY2s6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEgIT09IHVuZGVmaW5lZCA/IGEgOiBiO1xuICAgICAgICB9LFxuICAgICAgICBzbGljZTogZnVuY3Rpb24gKGxpc3QsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChsaXN0LCBiZWdpbiwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KCk7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuICBCYXNlLmluamVjdCh7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pZCAhPSBudWxsID8gKHRoaXMuX2NsYXNzIHx8ICdPYmplY3QnKSArICh0aGlzLl9uYW1lID8gXCIgJ1wiICsgdGhpcy5fbmFtZSArIFwiJ1wiIDogJyBAJyArIHRoaXMuX2lkKSA6ICd7ICcgKyBCYXNlLmVhY2godGhpcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKCEvXl8vLnRlc3Qoa2V5KSkge1xuICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgIHRoaXMucHVzaChrZXkgKyAnOiAnICsgKHR5cGUgPT09ICdudW1iZXInID8gRm9ybWF0dGVyLmluc3RhbmNlLm51bWJlcih2YWx1ZSkgOiB0eXBlID09PSAnc3RyaW5nJyA/IFwiJ1wiICsgdmFsdWUgKyBcIidcIiA6IHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtdKS5qb2luKCcsICcpICsgJyB9JztcbiAgICB9LFxuICAgIGdldENsYXNzTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzIHx8ICcnO1xuICAgIH0sXG4gICAgaW1wb3J0SlNPTjogZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgIHJldHVybiBCYXNlLmltcG9ydEpTT04oanNvbiwgdGhpcyk7XG4gICAgfSxcbiAgICBleHBvcnRKU09OOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIEJhc2UuZXhwb3J0SlNPTih0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAocHJvcHMsIGV4Y2x1ZGUpIHtcbiAgICAgIGlmIChwcm9wcykgQmFzZS5maWx0ZXIodGhpcywgcHJvcHMsIGV4Y2x1ZGUsIHRoaXMuX3ByaW9yaXRpemUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAgYmVhbnM6IGZhbHNlLFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIGV4cG9ydHM6IHt9LFxuICAgICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgICAgIHZhciByZXMgPSBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgbmFtZSA9IHJlcy5wcm90b3R5cGUuX2NsYXNzO1xuICAgICAgICBpZiAobmFtZSAmJiAhQmFzZS5leHBvcnRzW25hbWVdKSBCYXNlLmV4cG9ydHNbbmFtZV0gPSByZXM7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9LFxuICAgICAgZXF1YWxzOiBmdW5jdGlvbiAob2JqMSwgb2JqMikge1xuICAgICAgICBpZiAob2JqMSA9PT0gb2JqMikgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvYmoxICYmIG9iajEuZXF1YWxzKSByZXR1cm4gb2JqMS5lcXVhbHMob2JqMik7XG4gICAgICAgIGlmIChvYmoyICYmIG9iajIuZXF1YWxzKSByZXR1cm4gb2JqMi5lcXVhbHMob2JqMSk7XG5cbiAgICAgICAgaWYgKG9iajEgJiYgb2JqMiAmJiB0eXBlb2Ygb2JqMSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iajIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqMSkgJiYgQXJyYXkuaXNBcnJheShvYmoyKSkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IG9iajEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICAgIGlmICghQmFzZS5lcXVhbHMob2JqMVtsZW5ndGhdLCBvYmoyW2xlbmd0aF0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqMSksXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgICAgICAgIGlmICghKG9iajIuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBCYXNlLmVxdWFscyhvYmoxW2tleV0sIG9iajJba2V5XSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gKGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IEJhc2UpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBlZWsobGlzdCwgc3RhcnQpO1xuICAgICAgICAgIGxpc3QuX19pbmRleCsrO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlLFxuICAgICAgICAgICAgcmVhZEluZGV4ID0gcHJvdG8uX3JlYWRJbmRleCxcbiAgICAgICAgICAgIGJlZ2luID0gc3RhcnQgfHwgcmVhZEluZGV4ICYmIGxpc3QuX19pbmRleCB8fCAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gbGlzdC5sZW5ndGgsXG4gICAgICAgICAgICBvYmogPSBsaXN0W2JlZ2luXTtcbiAgICAgICAgYW1vdW50ID0gYW1vdW50IHx8IGxlbmd0aCAtIGJlZ2luO1xuXG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiB0aGlzIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkTnVsbCAmJiBvYmogPT0gbnVsbCAmJiBhbW91bnQgPD0gMSkge1xuICAgICAgICAgIGlmIChyZWFkSW5kZXgpIGxpc3QuX19pbmRleCA9IGJlZ2luICsgMTtcbiAgICAgICAgICByZXR1cm4gb2JqICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5jbG9uZSA/IG9iai5jbG9uZSgpIDogb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gQmFzZS5jcmVhdGUocHJvdG8pO1xuICAgICAgICBpZiAocmVhZEluZGV4KSBvYmouX19yZWFkID0gdHJ1ZTtcbiAgICAgICAgb2JqID0gb2JqLmluaXRpYWxpemUuYXBwbHkob2JqLCBiZWdpbiA+IDAgfHwgYmVnaW4gKyBhbW91bnQgPCBsZW5ndGggPyBCYXNlLnNsaWNlKGxpc3QsIGJlZ2luLCBiZWdpbiArIGFtb3VudCkgOiBsaXN0KSB8fCBvYmo7XG5cbiAgICAgICAgaWYgKHJlYWRJbmRleCkge1xuICAgICAgICAgIGxpc3QuX19pbmRleCA9IGJlZ2luICsgb2JqLl9fcmVhZDtcbiAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBvYmouX19maWx0ZXJlZDtcblxuICAgICAgICAgIGlmIChmaWx0ZXJlZCkge1xuICAgICAgICAgICAgbGlzdC5fX2ZpbHRlcmVkID0gZmlsdGVyZWQ7XG4gICAgICAgICAgICBvYmouX19maWx0ZXJlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYmouX19yZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICBwZWVrOiBmdW5jdGlvbiAobGlzdCwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RbbGlzdC5fX2luZGV4ID0gc3RhcnQgfHwgbGlzdC5fX2luZGV4IHx8IDBdO1xuICAgICAgfSxcbiAgICAgIHJlbWFpbjogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QubGVuZ3RoIC0gKGxpc3QuX19pbmRleCB8fCAwKTtcbiAgICAgIH0sXG4gICAgICByZWFkTGlzdDogZnVuY3Rpb24gKGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBhbW91bnQpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICBiZWdpbiA9IHN0YXJ0IHx8IDAsXG4gICAgICAgICAgICBlbmQgPSBhbW91bnQgPyBiZWdpbiArIGFtb3VudCA6IGxpc3QubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgcmVzLnB1c2goQXJyYXkuaXNBcnJheShlbnRyeSA9IGxpc3RbaV0pID8gdGhpcy5yZWFkKGVudHJ5LCAwLCBvcHRpb25zKSA6IHRoaXMucmVhZChsaXN0LCBpLCBvcHRpb25zLCAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSxcbiAgICAgIHJlYWROYW1lZDogZnVuY3Rpb24gKGxpc3QsIG5hbWUsIHN0YXJ0LCBvcHRpb25zLCBhbW91bnQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKSxcbiAgICAgICAgICAgIGhhc1ZhbHVlID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBsaXN0Ll9fZmlsdGVyZWQ7XG5cbiAgICAgICAgICBpZiAoIWZpbHRlcmVkKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UobGlzdCk7XG4gICAgICAgICAgICBmaWx0ZXJlZCA9IGxpc3QuX19maWx0ZXJlZCA9IEJhc2UuY3JlYXRlKHNvdXJjZSk7XG4gICAgICAgICAgICBmaWx0ZXJlZC5fX3VuZmlsdGVyZWQgPSBzb3VyY2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlsdGVyZWRbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkKGhhc1ZhbHVlID8gW3ZhbHVlXSA6IGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBhbW91bnQpO1xuICAgICAgfSxcbiAgICAgIHJlYWRTdXBwb3J0ZWQ6IGZ1bmN0aW9uIChsaXN0LCBkZXN0KSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZShsaXN0KSxcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgcmVhZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBkZXN0KSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoYXQucmVhZE5hbWVkKGxpc3QsIGtleSk7XG5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlYWQ7XG4gICAgICB9LFxuICAgICAgZ2V0U291cmNlOiBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICB2YXIgc291cmNlID0gbGlzdC5fX3NvdXJjZTtcblxuICAgICAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgYXJnID0gbGlzdC5sZW5ndGggPT09IDEgJiYgbGlzdFswXTtcbiAgICAgICAgICBzb3VyY2UgPSBsaXN0Ll9fc291cmNlID0gYXJnICYmIEJhc2UuaXNQbGFpbk9iamVjdChhcmcpID8gYXJnIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9LFxuICAgICAgZ2V0TmFtZWQ6IGZ1bmN0aW9uIChsaXN0LCBuYW1lKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZShsaXN0KTtcblxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWUgPyBzb3VyY2VbbmFtZV0gOiBsaXN0Ll9fZmlsdGVyZWQgfHwgc291cmNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzTmFtZWQ6IGZ1bmN0aW9uIChsaXN0LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSk7XG4gICAgICB9LFxuICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoZGVzdCwgc291cmNlLCBleGNsdWRlLCBwcmlvcml0aXplKSB7XG4gICAgICAgIHZhciBwcm9jZXNzZWQ7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlS2V5KGtleSkge1xuICAgICAgICAgIGlmICghKGV4Y2x1ZGUgJiYga2V5IGluIGV4Y2x1ZGUpICYmICEocHJvY2Vzc2VkICYmIGtleSBpbiBwcm9jZXNzZWQpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSBkZXN0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJpb3JpdGl6ZSkge1xuICAgICAgICAgIHZhciBrZXlzID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5LCBsID0gcHJpb3JpdGl6ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoa2V5ID0gcHJpb3JpdGl6ZVtpXSkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUtleShrZXkpO1xuICAgICAgICAgICAgICBrZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb2Nlc3NlZCA9IGtleXM7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UuX191bmZpbHRlcmVkIHx8IHNvdXJjZSkuZm9yRWFjaChoYW5kbGVLZXkpO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG4gICAgICBpc1BsYWluVmFsdWU6IGZ1bmN0aW9uIChvYmosIGFzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBCYXNlLmlzUGxhaW5PYmplY3Qob2JqKSB8fCBBcnJheS5pc0FycmF5KG9iaikgfHwgYXNTdHJpbmcgJiYgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG4gICAgICB9LFxuICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAob2JqLCBvcHRpb25zLCBjb21wYWN0LCBkaWN0aW9uYXJ5KSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgaXNSb290ID0gIWRpY3Rpb25hcnksXG4gICAgICAgICAgICByZXM7XG5cbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG4gICAgICAgICAgZGljdGlvbmFyeSA9IHtcbiAgICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgICAgIGRlZmluaXRpb25zOiB7fSxcbiAgICAgICAgICAgIHJlZmVyZW5jZXM6IHt9LFxuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAoaXRlbSwgY3JlYXRlKSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9ICcjJyArIGl0ZW0uX2lkLFxuICAgICAgICAgICAgICAgICAgcmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXTtcblxuICAgICAgICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGNyZWF0ZS5jYWxsKGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gaXRlbS5fY2xhc3M7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgJiYgcmVzWzBdICE9PSBuYW1lKSByZXMudW5zaGlmdChuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmluaXRpb25zW2lkXSA9IHJlcztcbiAgICAgICAgICAgICAgICByZWYgPSB0aGlzLnJlZmVyZW5jZXNbaWRdID0gW2lkXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmogJiYgb2JqLl9zZXJpYWxpemUpIHtcbiAgICAgICAgICByZXMgPSBvYmouX3NlcmlhbGl6ZShvcHRpb25zLCBkaWN0aW9uYXJ5KTtcbiAgICAgICAgICB2YXIgbmFtZSA9IG9iai5fY2xhc3M7XG5cbiAgICAgICAgICBpZiAobmFtZSAmJiAhb2JqLl9jb21wYWN0U2VyaWFsaXplICYmIChpc1Jvb3QgfHwgIWNvbXBhY3QpICYmIHJlc1swXSAhPT0gbmFtZSkge1xuICAgICAgICAgICAgcmVzLnVuc2hpZnQobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgIHJlcyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSByZXNbaV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpbaV0sIG9wdGlvbnMsIGNvbXBhY3QsIGRpY3Rpb25hcnkpO1xuICAgICAgICB9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgICAgICAgcmVzID0ge307XG4gICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICByZXNba2V5XSA9IEJhc2Uuc2VyaWFsaXplKG9ialtrZXldLCBvcHRpb25zLCBjb21wYWN0LCBkaWN0aW9uYXJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXMgPSBvcHRpb25zLmZvcm1hdHRlci5udW1iZXIob2JqLCBvcHRpb25zLnByZWNpc2lvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzUm9vdCAmJiBkaWN0aW9uYXJ5Lmxlbmd0aCA+IDAgPyBbWydkaWN0aW9uYXJ5JywgZGljdGlvbmFyeS5kZWZpbml0aW9uc10sIHJlc10gOiByZXM7XG4gICAgICB9LFxuICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChqc29uLCBjcmVhdGUsIF9kYXRhLCBfc2V0RGljdGlvbmFyeSwgX2lzUm9vdCkge1xuICAgICAgICB2YXIgcmVzID0ganNvbixcbiAgICAgICAgICAgIGlzRmlyc3QgPSAhX2RhdGEsXG4gICAgICAgICAgICBoYXNEaWN0aW9uYXJ5ID0gaXNGaXJzdCAmJiBqc29uICYmIGpzb24ubGVuZ3RoICYmIGpzb25bMF1bMF0gPT09ICdkaWN0aW9uYXJ5JztcbiAgICAgICAgX2RhdGEgPSBfZGF0YSB8fCB7fTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgICAgIHZhciB0eXBlID0ganNvblswXSxcbiAgICAgICAgICAgICAgaXNEaWN0aW9uYXJ5ID0gdHlwZSA9PT0gJ2RpY3Rpb25hcnknO1xuXG4gICAgICAgICAgaWYgKGpzb24ubGVuZ3RoID09IDEgJiYgL14jLy50ZXN0KHR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gX2RhdGEuZGljdGlvbmFyeVt0eXBlXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0eXBlID0gQmFzZS5leHBvcnRzW3R5cGVdO1xuICAgICAgICAgIHJlcyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHR5cGUgPyAxIDogMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICByZXMucHVzaChCYXNlLmRlc2VyaWFsaXplKGpzb25baV0sIGNyZWF0ZSwgX2RhdGEsIGlzRGljdGlvbmFyeSwgaGFzRGljdGlvbmFyeSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHJlcztcblxuICAgICAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodHlwZSwgYXJncywgaXNGaXJzdCB8fCBfaXNSb290KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcyA9IG5ldyB0eXBlKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoanNvbikpIHtcbiAgICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgICBpZiAoX3NldERpY3Rpb25hcnkpIF9kYXRhLmRpY3Rpb25hcnkgPSByZXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbikgcmVzW2tleV0gPSBCYXNlLmRlc2VyaWFsaXplKGpzb25ba2V5XSwgY3JlYXRlLCBfZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzRGljdGlvbmFyeSA/IHJlc1sxXSA6IHJlcztcbiAgICAgIH0sXG4gICAgICBleHBvcnRKU09OOiBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBqc29uID0gQmFzZS5zZXJpYWxpemUob2JqLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA9PSBmYWxzZSA/IGpzb24gOiBKU09OLnN0cmluZ2lmeShqc29uKTtcbiAgICAgIH0sXG4gICAgICBpbXBvcnRKU09OOiBmdW5jdGlvbiAoanNvbiwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBCYXNlLmRlc2VyaWFsaXplKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uLCBmdW5jdGlvbiAoY3RvciwgYXJncywgaXNSb290KSB7XG4gICAgICAgICAgdmFyIHVzZVRhcmdldCA9IGlzUm9vdCAmJiB0YXJnZXQgJiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSBjdG9yLFxuICAgICAgICAgICAgICBvYmogPSB1c2VUYXJnZXQgPyB0YXJnZXQgOiBCYXNlLmNyZWF0ZShjdG9yLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgb2JqIGluc3RhbmNlb2YgSXRlbSAmJiAodXNlVGFyZ2V0IHx8ICEob2JqIGluc3RhbmNlb2YgTGF5ZXIpKSkge1xuICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbMF07XG5cbiAgICAgICAgICAgIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoYXJnKSkge1xuICAgICAgICAgICAgICBhcmcuaW5zZXJ0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgaWYgKHVzZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbe1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0OiB0cnVlXG4gICAgICAgICAgICAgICAgfV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgKHVzZVRhcmdldCA/IG9iai5zZXQgOiBjdG9yKS5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgICAgIGlmICh1c2VUYXJnZXQpIHRhcmdldCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcHVzaDogZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XG4gICAgICAgIHZhciBpdGVtc0xlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcblxuICAgICAgICBpZiAoaXRlbXNMZW5ndGggPCA0MDk2KSB7XG4gICAgICAgICAgbGlzdC5wdXNoLmFwcGx5KGxpc3QsIGl0ZW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhcnRMZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgICBsaXN0Lmxlbmd0aCArPSBpdGVtc0xlbmd0aDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdFtzdGFydExlbmd0aCArIGldID0gaXRlbXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9LFxuICAgICAgc3BsaWNlOiBmdW5jdGlvbiAobGlzdCwgaXRlbXMsIGluZGV4LCByZW1vdmUpIHtcbiAgICAgICAgdmFyIGFtb3VudCA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIGFwcGVuZCA9IGluZGV4ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGluZGV4ID0gYXBwZW5kID8gbGlzdC5sZW5ndGggOiBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID4gbGlzdC5sZW5ndGgpIGluZGV4ID0gbGlzdC5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykgaXRlbXNbaV0uX2luZGV4ID0gaW5kZXggKyBpO1xuXG4gICAgICAgIGlmIChhcHBlbmQpIHtcbiAgICAgICAgICBCYXNlLnB1c2gobGlzdCwgaXRlbXMpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtpbmRleCwgcmVtb3ZlXTtcbiAgICAgICAgICBpZiAoaXRlbXMpIEJhc2UucHVzaChhcmdzLCBpdGVtcyk7XG4gICAgICAgICAgdmFyIHJlbW92ZWQgPSBsaXN0LnNwbGljZS5hcHBseShsaXN0LCBhcmdzKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVtb3ZlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHJlbW92ZWRbaV0uX2luZGV4ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgYW1vdW50LCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIGxpc3RbaV0uX2luZGV4ID0gaTtcblxuICAgICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcYlthLXpdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjYW1lbGl6ZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24gKG1hdGNoLCBjaHIpIHtcbiAgICAgICAgICByZXR1cm4gY2hyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGh5cGhlbmF0ZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIEVtaXR0ZXIgPSB7XG4gICAgb246IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIHRoaXMub24oa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcbiAgICAgICAgICAgIGVudHJ5ID0gdHlwZXMgJiYgdHlwZXNbdHlwZV0sXG4gICAgICAgICAgICBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICAgICAgaGFuZGxlcnMgPSBoYW5kbGVyc1t0eXBlXSA9IGhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuXG4gICAgICAgIGlmIChoYW5kbGVycy5pbmRleE9mKGZ1bmMpID09PSAtMSkge1xuICAgICAgICAgIGhhbmRsZXJzLnB1c2goZnVuYyk7XG4gICAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5Lmluc3RhbGwgJiYgaGFuZGxlcnMubGVuZ3RoID09PSAxKSBlbnRyeS5pbnN0YWxsLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIHRoaXMub2ZmKGtleSwgdmFsdWUpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuICAgICAgICAgIGVudHJ5ID0gdHlwZXMgJiYgdHlwZXNbdHlwZV0sXG4gICAgICAgICAgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdLFxuICAgICAgICAgIGluZGV4O1xuXG4gICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgaWYgKCFmdW5jIHx8IChpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YoZnVuYykpICE9PSAtMSAmJiBoYW5kbGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkudW5pbnN0YWxsKSBlbnRyeS51bmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmNlOiBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgICAgcmV0dXJuIHRoaXMub24odHlwZSwgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm9mZih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gKHR5cGUsIGV2ZW50KSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgaWYgKCFoYW5kbGVycykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGFyZ3MgPSBCYXNlLnNsaWNlKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgc2V0VGFyZ2V0ID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmICFldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgaGFuZGxlcnMgPSBoYW5kbGVycy5zbGljZSgpO1xuICAgICAgaWYgKHNldFRhcmdldCkgZXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChoYW5kbGVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKSA9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChldmVudCAmJiBldmVudC5zdG9wKSBldmVudC5zdG9wKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNldFRhcmdldCkgZGVsZXRlIGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHJlc3BvbmRzOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0pO1xuICAgIH0sXG4gICAgYXR0YWNoOiAnI29uJyxcbiAgICBkZXRhY2g6ICcjb2ZmJyxcbiAgICBmaXJlOiAnI2VtaXQnLFxuICAgIF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbiAoaW5zdGFsbCkge1xuICAgICAgdmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcbiAgICAgICAgICBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyxcbiAgICAgICAgICBrZXkgPSBpbnN0YWxsID8gJ2luc3RhbGwnIDogJ3VuaW5zdGFsbCc7XG5cbiAgICAgIGlmICh0eXBlcykge1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIGhhbmRsZXJzKSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXJzW3R5cGVdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHR5cGVzW3R5cGVdLFxuICAgICAgICAgICAgICAgIGZ1bmMgPSBlbnRyeSAmJiBlbnRyeVtrZXldO1xuICAgICAgICAgICAgaWYgKGZ1bmMpIGZ1bmMuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KHNyYykge1xuICAgICAgICB2YXIgZXZlbnRzID0gc3JjLl9ldmVudHM7XG5cbiAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgIHZhciB0eXBlcyA9IHt9O1xuICAgICAgICAgIEJhc2UuZWFjaChldmVudHMsIGZ1bmN0aW9uIChlbnRyeSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBpc1N0cmluZyA/IGVudHJ5IDoga2V5LFxuICAgICAgICAgICAgICAgIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG4gICAgICAgICAgICAgICAgdHlwZSA9IG5hbWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0eXBlc1t0eXBlXSA9IGlzU3RyaW5nID8ge30gOiBlbnRyeTtcbiAgICAgICAgICAgIG5hbWUgPSAnXycgKyBuYW1lO1xuXG4gICAgICAgICAgICBzcmNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbbmFtZV07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzcmNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgICAgaWYgKHByZXYpIHRoaXMub2ZmKHR5cGUsIHByZXYpO1xuICAgICAgICAgICAgICBpZiAoZnVuYykgdGhpcy5vbih0eXBlLCBmdW5jKTtcbiAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGZ1bmM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNyYy5fZXZlbnRUeXBlcyA9IHR5cGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluamVjdC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgUGFwZXJTY29wZSA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdQYXBlclNjb3BlJyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQYXBlclNjb3BlKCkge1xuICAgICAgcGFwZXIgPSB0aGlzO1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBCYXNlKHtcbiAgICAgICAgYXBwbHlNYXRyaXg6IHRydWUsXG4gICAgICAgIGluc2VydEl0ZW1zOiB0cnVlLFxuICAgICAgICBoYW5kbGVTaXplOiA0LFxuICAgICAgICBoaXRUb2xlcmFuY2U6IDBcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9qZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMucHJvamVjdHMgPSBbXTtcbiAgICAgIHRoaXMudG9vbHMgPSBbXTtcbiAgICAgIHRoaXMuX2lkID0gUGFwZXJTY29wZS5faWQrKztcbiAgICAgIFBhcGVyU2NvcGUuX3Njb3Blc1t0aGlzLl9pZF0gPSB0aGlzO1xuICAgICAgdmFyIHByb3RvID0gUGFwZXJTY29wZS5wcm90b3R5cGU7XG5cbiAgICAgIGlmICghdGhpcy5zdXBwb3J0KSB7XG4gICAgICAgIHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpIHx8IHt9O1xuICAgICAgICBwcm90by5zdXBwb3J0ID0ge1xuICAgICAgICAgIG5hdGl2ZURhc2g6ICdzZXRMaW5lRGFzaCcgaW4gY3R4IHx8ICdtb3pEYXNoJyBpbiBjdHgsXG4gICAgICAgICAgbmF0aXZlQmxlbmRNb2RlczogQmxlbmRNb2RlLm5hdGl2ZU1vZGVzXG4gICAgICAgIH07XG4gICAgICAgIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmFnZW50KSB7XG4gICAgICAgIHZhciB1c2VyID0gc2VsZi5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBvcyA9ICgvKGRhcndpbnx3aW58bWFjfGxpbnV4fGZyZWVic2R8c3Vub3MpLy5leGVjKHVzZXIpIHx8IFtdKVswXSxcbiAgICAgICAgICAgIHBsYXRmb3JtID0gb3MgPT09ICdkYXJ3aW4nID8gJ21hYycgOiBvcyxcbiAgICAgICAgICAgIGFnZW50ID0gcHJvdG8uYWdlbnQgPSBwcm90by5icm93c2VyID0ge1xuICAgICAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVxuICAgICAgICB9O1xuICAgICAgICBpZiAocGxhdGZvcm0pIGFnZW50W3BsYXRmb3JtXSA9IHRydWU7XG4gICAgICAgIHVzZXIucmVwbGFjZSgvKG9wZXJhfGNocm9tZXxzYWZhcml8d2Via2l0fGZpcmVmb3h8bXNpZXx0cmlkZW50fGF0b218bm9kZXxqc2RvbSlcXC8/XFxzKihbLlxcZF0rKSg/Oi4qdmVyc2lvblxcLyhbLlxcZF0rKSk/KD86LipydlxcOnY/KFsuXFxkXSspKT8vZywgZnVuY3Rpb24gKG1hdGNoLCBuLCB2MSwgdjIsIHJ2KSB7XG4gICAgICAgICAgaWYgKCFhZ2VudC5jaHJvbWUpIHtcbiAgICAgICAgICAgIHZhciB2ID0gbiA9PT0gJ29wZXJhJyA/IHYyIDogL14obm9kZXx0cmlkZW50KSQvLnRlc3QobikgPyBydiA6IHYxO1xuICAgICAgICAgICAgYWdlbnQudmVyc2lvbiA9IHY7XG4gICAgICAgICAgICBhZ2VudC52ZXJzaW9uTnVtYmVyID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgICAgICAgIG4gPSB7XG4gICAgICAgICAgICAgIHRyaWRlbnQ6ICdtc2llJyxcbiAgICAgICAgICAgICAganNkb206ICdub2RlJ1xuICAgICAgICAgICAgfVtuXSB8fCBuO1xuICAgICAgICAgICAgYWdlbnQubmFtZSA9IG47XG4gICAgICAgICAgICBhZ2VudFtuXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFnZW50LmNocm9tZSkgZGVsZXRlIGFnZW50LndlYmtpdDtcbiAgICAgICAgaWYgKGFnZW50LmF0b20pIGRlbGV0ZSBhZ2VudC5jaHJvbWU7XG4gICAgICB9XG4gICAgfSxcbiAgICB2ZXJzaW9uOiBcIjAuMTIuMTFcIixcbiAgICBnZXRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvamVjdCA9IHRoaXMucHJvamVjdDtcbiAgICAgIHJldHVybiBwcm9qZWN0ICYmIHByb2plY3QuX3ZpZXc7XG4gICAgfSxcbiAgICBnZXRQYXBlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBleGVjdXRlOiBmdW5jdGlvbiAoY29kZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGV4cG9ydHMgPSBwYXBlci5QYXBlclNjcmlwdC5leGVjdXRlKGNvZGUsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgVmlldy51cGRhdGVGb2N1cygpO1xuICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfSxcbiAgICBpbnN0YWxsOiBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIEJhc2UuZWFjaChbJ3Byb2plY3QnLCAndmlldycsICd0b29sJ10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgQmFzZS5kZWZpbmUoc2NvcGUsIGtleSwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGF0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykgaWYgKCEvXl8vLnRlc3Qoa2V5KSAmJiB0aGlzW2tleV0pIHNjb3BlW2tleV0gPSB0aGlzW2tleV07XG4gICAgfSxcbiAgICBzZXR1cDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHBhcGVyID0gdGhpcztcbiAgICAgIHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjcmVhdGVDYW52YXM6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHBhcGVyID0gdGhpcztcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvamVjdHMgPSB0aGlzLnByb2plY3RzLFxuICAgICAgICAgIHRvb2xzID0gdGhpcy50b29scztcblxuICAgICAgZm9yICh2YXIgaSA9IHByb2plY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBwcm9qZWN0c1tpXS5yZW1vdmUoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IHRvb2xzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB0b29sc1tpXS5yZW1vdmUoKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgZGVsZXRlIFBhcGVyU2NvcGUuX3Njb3Blc1t0aGlzLl9pZF07XG4gICAgfSxcbiAgICBzdGF0aWNzOiBuZXcgZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgbmFtZSArPSAnQXR0cmlidXRlJztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbCwgYXR0cikge1xuICAgICAgICAgIHJldHVybiBlbFtuYW1lXShhdHRyKSB8fCBlbFtuYW1lXSgnZGF0YS1wYXBlci0nICsgYXR0cik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9zY29wZXM6IHt9LFxuICAgICAgICBfaWQ6IDAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3Blc1tpZF0gfHwgbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QXR0cmlidXRlOiBoYW5kbGVBdHRyaWJ1dGUoJ2dldCcpLFxuICAgICAgICBoYXNBdHRyaWJ1dGU6IGhhbmRsZUF0dHJpYnV0ZSgnaGFzJylcbiAgICAgIH07XG4gICAgfSgpXG4gIH0pO1xuICB2YXIgUGFwZXJTY29wZUl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKGFjdGl2YXRlKSB7XG4gICAgICB0aGlzLl9zY29wZSA9IHBhcGVyO1xuICAgICAgdGhpcy5faW5kZXggPSB0aGlzLl9zY29wZVt0aGlzLl9saXN0XS5wdXNoKHRoaXMpIC0gMTtcbiAgICAgIGlmIChhY3RpdmF0ZSB8fCAhdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSkgdGhpcy5hY3RpdmF0ZSgpO1xuICAgIH0sXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fc2NvcGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXTtcbiAgICAgIGlmIChwcmV2ICYmIHByZXYgIT09IHRoaXMpIHByZXYuZW1pdCgnZGVhY3RpdmF0ZScpO1xuICAgICAgdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IHRoaXM7XG4gICAgICB0aGlzLmVtaXQoJ2FjdGl2YXRlJywgcHJldik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PT0gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2luZGV4ID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIEJhc2Uuc3BsaWNlKHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG4gICAgICBpZiAodGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PSB0aGlzKSB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID0gbnVsbDtcbiAgICAgIHRoaXMuX3Njb3BlID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0VmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlLmdldFZpZXcoKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgQ29sbGlzaW9uRGV0ZWN0aW9uID0ge1xuICAgIGZpbmRJdGVtQm91bmRzQ29sbGlzaW9uczogZnVuY3Rpb24gKGl0ZW1zMSwgaXRlbXMyLCB0b2xlcmFuY2UpIHtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kcyhpdGVtcykge1xuICAgICAgICB2YXIgYm91bmRzID0gbmV3IEFycmF5KGl0ZW1zLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZWN0ID0gaXRlbXNbaV0uZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgYm91bmRzW2ldID0gW3JlY3QubGVmdCwgcmVjdC50b3AsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG5cbiAgICAgIHZhciBib3VuZHMxID0gZ2V0Qm91bmRzKGl0ZW1zMSksXG4gICAgICAgICAgYm91bmRzMiA9ICFpdGVtczIgfHwgaXRlbXMyID09PSBpdGVtczEgPyBib3VuZHMxIDogZ2V0Qm91bmRzKGl0ZW1zMik7XG4gICAgICByZXR1cm4gdGhpcy5maW5kQm91bmRzQ29sbGlzaW9ucyhib3VuZHMxLCBib3VuZHMyLCB0b2xlcmFuY2UgfHwgMCk7XG4gICAgfSxcbiAgICBmaW5kQ3VydmVCb3VuZHNDb2xsaXNpb25zOiBmdW5jdGlvbiAoY3VydmVzMSwgY3VydmVzMiwgdG9sZXJhbmNlLCBib3RoQXhpcykge1xuICAgICAgZnVuY3Rpb24gZ2V0Qm91bmRzKGN1cnZlcykge1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4sXG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heCxcbiAgICAgICAgICAgIGJvdW5kcyA9IG5ldyBBcnJheShjdXJ2ZXMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB2ID0gY3VydmVzW2ldO1xuICAgICAgICAgIGJvdW5kc1tpXSA9IFttaW4odlswXSwgdlsyXSwgdls0XSwgdls2XSksIG1pbih2WzFdLCB2WzNdLCB2WzVdLCB2WzddKSwgbWF4KHZbMF0sIHZbMl0sIHZbNF0sIHZbNl0pLCBtYXgodlsxXSwgdlszXSwgdls1XSwgdls3XSldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdW5kczEgPSBnZXRCb3VuZHMoY3VydmVzMSksXG4gICAgICAgICAgYm91bmRzMiA9ICFjdXJ2ZXMyIHx8IGN1cnZlczIgPT09IGN1cnZlczEgPyBib3VuZHMxIDogZ2V0Qm91bmRzKGN1cnZlczIpO1xuXG4gICAgICBpZiAoYm90aEF4aXMpIHtcbiAgICAgICAgdmFyIGhvciA9IHRoaXMuZmluZEJvdW5kc0NvbGxpc2lvbnMoYm91bmRzMSwgYm91bmRzMiwgdG9sZXJhbmNlIHx8IDAsIGZhbHNlLCB0cnVlKSxcbiAgICAgICAgICAgIHZlciA9IHRoaXMuZmluZEJvdW5kc0NvbGxpc2lvbnMoYm91bmRzMSwgYm91bmRzMiwgdG9sZXJhbmNlIHx8IDAsIHRydWUsIHRydWUpLFxuICAgICAgICAgICAgbGlzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9yLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGxpc3RbaV0gPSB7XG4gICAgICAgICAgICBob3I6IGhvcltpXSxcbiAgICAgICAgICAgIHZlcjogdmVyW2ldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5maW5kQm91bmRzQ29sbGlzaW9ucyhib3VuZHMxLCBib3VuZHMyLCB0b2xlcmFuY2UgfHwgMCk7XG4gICAgfSxcbiAgICBmaW5kQm91bmRzQ29sbGlzaW9uczogZnVuY3Rpb24gKGJvdW5kc0EsIGJvdW5kc0IsIHRvbGVyYW5jZSwgc3dlZXBWZXJ0aWNhbCwgb25seVN3ZWVwQXhpc0NvbGxpc2lvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gIWJvdW5kc0IgfHwgYm91bmRzQSA9PT0gYm91bmRzQixcbiAgICAgICAgICBhbGxCb3VuZHMgPSBzZWxmID8gYm91bmRzQSA6IGJvdW5kc0EuY29uY2F0KGJvdW5kc0IpLFxuICAgICAgICAgIGxlbmd0aEEgPSBib3VuZHNBLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGhBbGwgPSBhbGxCb3VuZHMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBiaW5hcnlTZWFyY2goaW5kaWNlcywgY29vcmQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBsbyA9IDAsXG4gICAgICAgICAgICBoaSA9IGluZGljZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IGhpICsgbG8gPj4+IDE7XG5cbiAgICAgICAgICBpZiAoYWxsQm91bmRzW2luZGljZXNbbWlkXV1bY29vcmRdIDwgdmFsdWUpIHtcbiAgICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvIC0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByaTAgPSBzd2VlcFZlcnRpY2FsID8gMSA6IDAsXG4gICAgICAgICAgcHJpMSA9IHByaTAgKyAyLFxuICAgICAgICAgIHNlYzAgPSBzd2VlcFZlcnRpY2FsID8gMCA6IDEsXG4gICAgICAgICAgc2VjMSA9IHNlYzAgKyAyO1xuICAgICAgdmFyIGFsbEluZGljZXNCeVByaTAgPSBuZXcgQXJyYXkobGVuZ3RoQWxsKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhBbGw7IGkrKykge1xuICAgICAgICBhbGxJbmRpY2VzQnlQcmkwW2ldID0gaTtcbiAgICAgIH1cblxuICAgICAgYWxsSW5kaWNlc0J5UHJpMC5zb3J0KGZ1bmN0aW9uIChpMSwgaTIpIHtcbiAgICAgICAgcmV0dXJuIGFsbEJvdW5kc1tpMV1bcHJpMF0gLSBhbGxCb3VuZHNbaTJdW3ByaTBdO1xuICAgICAgfSk7XG4gICAgICB2YXIgYWN0aXZlSW5kaWNlc0J5UHJpMSA9IFtdLFxuICAgICAgICAgIGFsbENvbGxpc2lvbnMgPSBuZXcgQXJyYXkobGVuZ3RoQSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoQWxsOyBpKyspIHtcbiAgICAgICAgdmFyIGN1ckluZGV4ID0gYWxsSW5kaWNlc0J5UHJpMFtpXSxcbiAgICAgICAgICAgIGN1ckJvdW5kcyA9IGFsbEJvdW5kc1tjdXJJbmRleF0sXG4gICAgICAgICAgICBvcmlnSW5kZXggPSBzZWxmID8gY3VySW5kZXggOiBjdXJJbmRleCAtIGxlbmd0aEEsXG4gICAgICAgICAgICBpc0N1cnJlbnRBID0gY3VySW5kZXggPCBsZW5ndGhBLFxuICAgICAgICAgICAgaXNDdXJyZW50QiA9IHNlbGYgfHwgIWlzQ3VycmVudEEsXG4gICAgICAgICAgICBjdXJDb2xsaXNpb25zID0gaXNDdXJyZW50QSA/IFtdIDogbnVsbDtcblxuICAgICAgICBpZiAoYWN0aXZlSW5kaWNlc0J5UHJpMS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcHJ1bmVDb3VudCA9IGJpbmFyeVNlYXJjaChhY3RpdmVJbmRpY2VzQnlQcmkxLCBwcmkxLCBjdXJCb3VuZHNbcHJpMF0gLSB0b2xlcmFuY2UpICsgMTtcbiAgICAgICAgICBhY3RpdmVJbmRpY2VzQnlQcmkxLnNwbGljZSgwLCBwcnVuZUNvdW50KTtcblxuICAgICAgICAgIGlmIChzZWxmICYmIG9ubHlTd2VlcEF4aXNDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICBjdXJDb2xsaXNpb25zID0gY3VyQ29sbGlzaW9ucy5jb25jYXQoYWN0aXZlSW5kaWNlc0J5UHJpMSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWN0aXZlSW5kaWNlc0J5UHJpMS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgYWN0aXZlSW5kZXggPSBhY3RpdmVJbmRpY2VzQnlQcmkxW2pdO1xuICAgICAgICAgICAgICBhbGxDb2xsaXNpb25zW2FjdGl2ZUluZGV4XS5wdXNoKG9yaWdJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjdXJTZWMxID0gY3VyQm91bmRzW3NlYzFdLFxuICAgICAgICAgICAgICAgIGN1clNlYzAgPSBjdXJCb3VuZHNbc2VjMF07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWN0aXZlSW5kaWNlc0J5UHJpMS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgYWN0aXZlSW5kZXggPSBhY3RpdmVJbmRpY2VzQnlQcmkxW2pdLFxuICAgICAgICAgICAgICAgICAgYWN0aXZlQm91bmRzID0gYWxsQm91bmRzW2FjdGl2ZUluZGV4XSxcbiAgICAgICAgICAgICAgICAgIGlzQWN0aXZlQSA9IGFjdGl2ZUluZGV4IDwgbGVuZ3RoQSxcbiAgICAgICAgICAgICAgICAgIGlzQWN0aXZlQiA9IHNlbGYgfHwgYWN0aXZlSW5kZXggPj0gbGVuZ3RoQTtcblxuICAgICAgICAgICAgICBpZiAob25seVN3ZWVwQXhpc0NvbGxpc2lvbnMgfHwgKGlzQ3VycmVudEEgJiYgaXNBY3RpdmVCIHx8IGlzQ3VycmVudEIgJiYgaXNBY3RpdmVBKSAmJiBjdXJTZWMxID49IGFjdGl2ZUJvdW5kc1tzZWMwXSAtIHRvbGVyYW5jZSAmJiBjdXJTZWMwIDw9IGFjdGl2ZUJvdW5kc1tzZWMxXSArIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRBICYmIGlzQWN0aXZlQikge1xuICAgICAgICAgICAgICAgICAgY3VyQ29sbGlzaW9ucy5wdXNoKHNlbGYgPyBhY3RpdmVJbmRleCA6IGFjdGl2ZUluZGV4IC0gbGVuZ3RoQSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEIgJiYgaXNBY3RpdmVBKSB7XG4gICAgICAgICAgICAgICAgICBhbGxDb2xsaXNpb25zW2FjdGl2ZUluZGV4XS5wdXNoKG9yaWdJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ3VycmVudEEpIHtcbiAgICAgICAgICBpZiAoYm91bmRzQSA9PT0gYm91bmRzQikge1xuICAgICAgICAgICAgY3VyQ29sbGlzaW9ucy5wdXNoKGN1ckluZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbGxDb2xsaXNpb25zW2N1ckluZGV4XSA9IGN1ckNvbGxpc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aXZlSW5kaWNlc0J5UHJpMS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY3VyUHJpMSA9IGN1ckJvdW5kc1twcmkxXSxcbiAgICAgICAgICAgICAgaW5kZXggPSBiaW5hcnlTZWFyY2goYWN0aXZlSW5kaWNlc0J5UHJpMSwgcHJpMSwgY3VyUHJpMSk7XG4gICAgICAgICAgYWN0aXZlSW5kaWNlc0J5UHJpMS5zcGxpY2UoaW5kZXggKyAxLCAwLCBjdXJJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aXZlSW5kaWNlc0J5UHJpMS5wdXNoKGN1ckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbENvbGxpc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBhbGxDb2xsaXNpb25zW2ldO1xuXG4gICAgICAgIGlmIChjb2xsaXNpb25zKSB7XG4gICAgICAgICAgY29sbGlzaW9ucy5zb3J0KGZ1bmN0aW9uIChpMSwgaTIpIHtcbiAgICAgICAgICAgIHJldHVybiBpMSAtIGkyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGxDb2xsaXNpb25zO1xuICAgIH1cbiAgfTtcbiAgdmFyIEZvcm1hdHRlciA9IEJhc2UuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XG4gICAgICB0aGlzLnByZWNpc2lvbiA9IEJhc2UucGljayhwcmVjaXNpb24sIDUpO1xuICAgICAgdGhpcy5tdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHRoaXMucHJlY2lzaW9uKTtcbiAgICB9LFxuICAgIG51bWJlcjogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlY2lzaW9uIDwgMTYgPyBNYXRoLnJvdW5kKHZhbCAqIHRoaXMubXVsdGlwbGllcikgLyB0aGlzLm11bHRpcGxpZXIgOiB2YWw7XG4gICAgfSxcbiAgICBwYWlyOiBmdW5jdGlvbiAodmFsMSwgdmFsMiwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXIodmFsMSkgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLm51bWJlcih2YWwyKTtcbiAgICB9LFxuICAgIHBvaW50OiBmdW5jdGlvbiAodmFsLCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWJlcih2YWwueCkgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLm51bWJlcih2YWwueSk7XG4gICAgfSxcbiAgICBzaXplOiBmdW5jdGlvbiAodmFsLCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWJlcih2YWwud2lkdGgpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsLmhlaWdodCk7XG4gICAgfSxcbiAgICByZWN0YW5nbGU6IGZ1bmN0aW9uICh2YWwsIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHRoaXMucG9pbnQodmFsLCBzZXBhcmF0b3IpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5zaXplKHZhbCwgc2VwYXJhdG9yKTtcbiAgICB9XG4gIH0pO1xuICBGb3JtYXR0ZXIuaW5zdGFuY2UgPSBuZXcgRm9ybWF0dGVyKCk7XG4gIHZhciBOdW1lcmljYWwgPSBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhYnNjaXNzYXMgPSBbWzAuNTc3MzUwMjY5MTg5NjI1NzY0NTA5MTQ4OF0sIFswLCAwLjc3NDU5NjY2OTI0MTQ4MzM3NzAzNTg1MzFdLCBbMC4zMzk5ODEwNDM1ODQ4NTYyNjQ4MDI2NjU4LCAwLjg2MTEzNjMxMTU5NDA1MjU3NTIyMzk0NjVdLCBbMCwgMC41Mzg0NjkzMTAxMDU2ODMwOTEwMzYzMTQ0LCAwLjkwNjE3OTg0NTkzODY2Mzk5Mjc5NzYyNjldLCBbMC4yMzg2MTkxODYwODMxOTY5MDg2MzA1MDE3LCAwLjY2MTIwOTM4NjQ2NjI2NDUxMzY2MTM5OTYsIDAuOTMyNDY5NTE0MjAzMTUyMDI3ODEyMzAxNl0sIFswLCAwLjQwNTg0NTE1MTM3NzM5NzE2NjkwNjYwNjQsIDAuNzQxNTMxMTg1NTk5Mzk0NDM5ODYzODY0OCwgMC45NDkxMDc5MTIzNDI3NTg1MjQ1MjYxODk3XSwgWzAuMTgzNDM0NjQyNDk1NjQ5ODA0OTM5NDc2MSwgMC41MjU1MzI0MDk5MTYzMjg5ODU4MTc3MzkwLCAwLjc5NjY2NjQ3NzQxMzYyNjczOTU5MTU1MzksIDAuOTYwMjg5ODU2NDk3NTM2MjMxNjgzNTYwOV0sIFswLCAwLjMyNDI1MzQyMzQwMzgwODkyOTAzODUzODAsIDAuNjEzMzcxNDMyNzAwNTkwMzk3MzA4NzAyMCwgMC44MzYwMzExMDczMjY2MzU3OTQyOTk0Mjk4LCAwLjk2ODE2MDIzOTUwNzYyNjA4OTgzNTU3NjJdLCBbMC4xNDg4NzQzMzg5ODE2MzEyMTA4ODQ4MjYwLCAwLjQzMzM5NTM5NDEyOTI0NzE5MDc5OTI2NTksIDAuNjc5NDA5NTY4Mjk5MDI0NDA2MjM0MzI3NCwgMC44NjUwNjMzNjY2ODg5ODQ1MTA3MzIwOTY3LCAwLjk3MzkwNjUyODUxNzE3MTcyMDA3Nzk2NDBdLCBbMCwgMC4yNjk1NDMxNTU5NTIzNDQ5NzIzMzE1MzIwLCAwLjUxOTA5NjEyOTIwNjgxMTgxNTkyNTcyNTcsIDAuNzMwMTUyMDA1NTc0MDQ5MzI0MDkzNDE2MywgMC44ODcwNjI1OTk3NjgwOTUyOTkwNzUxNTc4LCAwLjk3ODIyODY1ODE0NjA1Njk5MjgwMzkzODBdLCBbMC4xMjUyMzM0MDg1MTE0Njg5MTU0NzI0NDE0LCAwLjM2NzgzMTQ5ODk5ODE4MDE5Mzc1MjY5MTUsIDAuNTg3MzE3OTU0Mjg2NjE3NDQ3Mjk2NzAyNCwgMC43Njk5MDI2NzQxOTQzMDQ2ODcwMzY4OTM4LCAwLjkwNDExNzI1NjM3MDQ3NDg1NjY3ODQ2NTksIDAuOTgxNTYwNjM0MjQ2NzE5MjUwNjkwNTQ5MV0sIFswLCAwLjIzMDQ1ODMxNTk1NTEzNDc5NDA2NTUyODEsIDAuNDQ4NDkyNzUxMDM2NDQ2ODUyODc3OTEyOSwgMC42NDIzNDkzMzk0NDAzNDAyMjA2NDM5ODQ2LCAwLjgwMTU3ODA5MDczMzMwOTkxMjc5NDIwNjUsIDAuOTE3NTk4Mzk5MjIyOTc3OTY1MjA2NTQ3OCwgMC45ODQxODMwNTQ3MTg1ODgxNDk0NzI4Mjk0XSwgWzAuMTA4MDU0OTQ4NzA3MzQzNjYyMDY2MjQ0NywgMC4zMTkxMTIzNjg5Mjc4ODk3NjA0MzU2NzE4LCAwLjUxNTI0ODYzNjM1ODE1NDA5MTk2NTI5MDcsIDAuNjg3MjkyOTA0ODExNjg1NDcwMTQ4MDE5OCwgMC44MjcyMDEzMTUwNjk3NjQ5OTMxODk3OTQ3LCAwLjkyODQzNDg4MzY2MzU3MzUxNzMzNjM5MTEsIDAuOTg2MjgzODA4Njk2ODEyMzM4ODQxNTk3M10sIFswLCAwLjIwMTE5NDA5Mzk5NzQzNDUyMjMwMDYyODMsIDAuMzk0MTUxMzQ3MDc3NTYzMzY5ODk3MjA3NCwgMC41NzA5NzIxNzI2MDg1Mzg4NDc1MzcyMjY3LCAwLjcyNDQxNzczMTM2MDE3MDA0NzQxNjE4NjEsIDAuODQ4MjA2NTgzNDEwNDI3MjE2MjAwNjQ4MywgMC45MzcyNzMzOTI0MDA3MDU5MDQzMDc3NTg5LCAwLjk4Nzk5MjUxODAyMDQ4NTQyODQ4OTU2NTddLCBbMC4wOTUwMTI1MDk4Mzc2Mzc0NDAxODUzMTkzLCAwLjI4MTYwMzU1MDc3OTI1ODkxMzIzMDQ2MDUsIDAuNDU4MDE2Nzc3NjU3MjI3Mzg2MzQyNDE5NCwgMC42MTc4NzYyNDQ0MDI2NDM3NDg0NDY2NzE4LCAwLjc1NTQwNDQwODM1NTAwMzAzMzg5NTEwMTIsIDAuODY1NjMxMjAyMzg3ODMxNzQzODgwNDY3OSwgMC45NDQ1NzUwMjMwNzMyMzI1NzYwNzc5ODg0LCAwLjk4OTQwMDkzNDk5MTY0OTkzMjU5NjE1NDJdXTtcbiAgICB2YXIgd2VpZ2h0cyA9IFtbMV0sIFswLjg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksIDAuNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1Nl0sIFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsIDAuMzQ3ODU0ODQ1MTM3NDUzODU3MzczMDYzOV0sIFswLjU2ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksIDAuNDc4NjI4NjcwNDk5MzY2NDY4MDQxMjkxNSwgMC4yMzY5MjY4ODUwNTYxODkwODc1MTQyNjQwXSwgWzAuNDY3OTEzOTM0NTcyNjkxMDQ3Mzg5ODcwMywgMC4zNjA3NjE1NzMwNDgxMzg2MDc1Njk4MzM1LCAwLjE3MTMyNDQ5MjM3OTE3MDM0NTA0MDI5NjFdLCBbMC40MTc5NTkxODM2NzM0NjkzODc3NTUxMDIwLCAwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsIDAuMjc5NzA1MzkxNDg5Mjc2NjY3OTAxNDY3OCwgMC4xMjk0ODQ5NjYxNjg4Njk2OTMyNzA2MTE0XSwgWzAuMzYyNjgzNzgzMzc4MzYxOTgyOTY1MTUwNCwgMC4zMTM3MDY2NDU4Nzc4ODcyODczMzc5NjIyLCAwLjIyMjM4MTAzNDQ1MzM3NDQ3MDU0NDM1NjAsIDAuMTAxMjI4NTM2MjkwMzc2MjU5MTUyNTMxNF0sIFswLjMzMDIzOTM1NTAwMTI1OTc2MzE2NDUyNTEsIDAuMzEyMzQ3MDc3MDQwMDAyODQwMDY4NjMwNCwgMC4yNjA2MTA2OTY0MDI5MzU0NjIzMTg3NDI5LCAwLjE4MDY0ODE2MDY5NDg1NzQwNDA1ODQ3MjAsIDAuMDgxMjc0Mzg4MzYxNTc0NDExOTcxODkyMl0sIFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsIDAuMjY5MjY2NzE5MzA5OTk2MzU1MDkxMjI2OSwgMC4yMTkwODYzNjI1MTU5ODIwNDM5OTU1MzQ5LCAwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsIDAuMDY2NjcxMzQ0MzA4Njg4MTM3NTkzNTY4OF0sIFswLjI3MjkyNTA4Njc3NzkwMDYzMDcxNDQ4MzUsIDAuMjYyODA0NTQ0NTEwMjQ2NjYyMTgwNjg4OSwgMC4yMzMxOTM3NjQ1OTE5OTA0Nzk5MTg1MjM3LCAwLjE4NjI5MDIxMDkyNzczNDI1MTQyNjA5NzYsIDAuMTI1NTgwMzY5NDY0OTA0NjI0NjM0Njk0MywgMC4wNTU2Njg1NjcxMTYxNzM2NjY0ODI3NTM3XSwgWzAuMjQ5MTQ3MDQ1ODEzNDAyNzg1MDAwNTYyNCwgMC4yMzM0OTI1MzY1MzgzNTQ4MDg3NjA4NDk5LCAwLjIwMzE2NzQyNjcyMzA2NTkyMTc0OTA2NDUsIDAuMTYwMDc4MzI4NTQzMzQ2MjI2MzM0NjUyNSwgMC4xMDY5MzkzMjU5OTUzMTg0MzA5NjAyNTQ3LCAwLjA0NzE3NTMzNjM4NjUxMTgyNzE5NDYxNjBdLCBbMC4yMzI1NTE1NTMyMzA4NzM5MTAxOTQ1ODk1LCAwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsIDAuMjA3ODE2MDQ3NTM2ODg4NTAyMzEyNTIzMiwgMC4xNzgxNDU5ODA3NjE5NDU3MzgyODAwNDY3LCAwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsIDAuMDkyMTIxNDk5ODM3NzI4NDQ3OTE0NDIxOCwgMC4wNDA0ODQwMDQ3NjUzMTU4Nzk1MjAwMjE2XSwgWzAuMjE1MjYzODUzNDYzMTU3NzkwMTk1ODc2NCwgMC4yMDUxOTg0NjM3MjEyOTU2MDM5NjU5MjQxLCAwLjE4NTUzODM5NzQ3NzkzNzgxMzc0MTcxNjYsIDAuMTU3MjAzMTY3MTU4MTkzNTM0NTY5NjAxOSwgMC4xMjE1MTg1NzA2ODc5MDMxODQ2ODk0MTQ4LCAwLjA4MDE1ODA4NzE1OTc2MDIwOTgwNTYzMzMsIDAuMDM1MTE5NDYwMzMxNzUxODYzMDMxODMyOV0sIFswLjIwMjU3ODI0MTkyNTU2MTI3Mjg4MDYyMDIsIDAuMTk4NDMxNDg1MzI3MTExNTc2NDU2MTE4MywgMC4xODYxNjEwMDAwMTU1NjIyMTEwMjY4MDA2LCAwLjE2NjI2OTIwNTgxNjk5MzkzMzU1MzIwMDksIDAuMTM5NTcwNjc3OTI2MTU0MzE0NDQ3ODA0OCwgMC4xMDcxNTkyMjA0NjcxNzE5MzUwMTE4Njk1LCAwLjA3MDM2NjA0NzQ4ODEwODEyNDcwOTI2NzQsIDAuMDMwNzUzMjQxOTk2MTE3MjY4MzU0NjI4NF0sIFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsIDAuMTgyNjAzNDE1MDQ0OTIzNTg4ODY2NzYzNywgMC4xNjkxNTY1MTkzOTUwMDI1MzgxODkzMTIxLCAwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsIDAuMTI0NjI4OTcxMjU1NTMzODcyMDUyNDc2MywgMC4wOTUxNTg1MTE2ODI0OTI3ODQ4MDk5MjUxLCAwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsIDAuMDI3MTUyNDU5NDExNzU0MDk0ODUxNzgwNl1dO1xuXG4gICAgdmFyIGFicyA9IE1hdGguYWJzLFxuICAgICAgICBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgICBwb3cgPSBNYXRoLnBvdyxcbiAgICAgICAgbG9nMiA9IE1hdGgubG9nMiB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cyRTtcbiAgICB9LFxuICAgICAgICBFUFNJTE9OID0gMWUtMTIsXG4gICAgICAgIE1BQ0hJTkVfRVBTSUxPTiA9IDEuMTJlLTE2O1xuXG4gICAgZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERpc2NyaW1pbmFudChhLCBiLCBjKSB7XG4gICAgICBmdW5jdGlvbiBzcGxpdCh2KSB7XG4gICAgICAgIHZhciB4ID0gdiAqIDEzNDIxNzcyOSxcbiAgICAgICAgICAgIHkgPSB2IC0geCxcbiAgICAgICAgICAgIGhpID0geSArIHgsXG4gICAgICAgICAgICBsbyA9IHYgLSBoaTtcbiAgICAgICAgcmV0dXJuIFtoaSwgbG9dO1xuICAgICAgfVxuXG4gICAgICB2YXIgRCA9IGIgKiBiIC0gYSAqIGMsXG4gICAgICAgICAgRSA9IGIgKiBiICsgYSAqIGM7XG5cbiAgICAgIGlmIChhYnMoRCkgKiAzIDwgRSkge1xuICAgICAgICB2YXIgYWQgPSBzcGxpdChhKSxcbiAgICAgICAgICAgIGJkID0gc3BsaXQoYiksXG4gICAgICAgICAgICBjZCA9IHNwbGl0KGMpLFxuICAgICAgICAgICAgcCA9IGIgKiBiLFxuICAgICAgICAgICAgZHAgPSBiZFswXSAqIGJkWzBdIC0gcCArIDIgKiBiZFswXSAqIGJkWzFdICsgYmRbMV0gKiBiZFsxXSxcbiAgICAgICAgICAgIHEgPSBhICogYyxcbiAgICAgICAgICAgIGRxID0gYWRbMF0gKiBjZFswXSAtIHEgKyBhZFswXSAqIGNkWzFdICsgYWRbMV0gKiBjZFswXSArIGFkWzFdICogY2RbMV07XG4gICAgICAgIEQgPSBwIC0gcSArIChkcCAtIGRxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvbkZhY3RvcigpIHtcbiAgICAgIHZhciBub3JtID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBub3JtICYmIChub3JtIDwgMWUtOCB8fCBub3JtID4gMWU4KSA/IHBvdygyLCAtTWF0aC5yb3VuZChsb2cyKG5vcm0pKSkgOiAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBFUFNJTE9OOiBFUFNJTE9OLFxuICAgICAgTUFDSElORV9FUFNJTE9OOiBNQUNISU5FX0VQU0lMT04sXG4gICAgICBDVVJWRVRJTUVfRVBTSUxPTjogMWUtOCxcbiAgICAgIEdFT01FVFJJQ19FUFNJTE9OOiAxZS03LFxuICAgICAgVFJJR09OT01FVFJJQ19FUFNJTE9OOiAxZS04LFxuICAgICAgS0FQUEE6IDQgKiAoc3FydCgyKSAtIDEpIC8gMyxcbiAgICAgIGlzWmVybzogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID49IC1FUFNJTE9OICYmIHZhbCA8PSBFUFNJTE9OO1xuICAgICAgfSxcbiAgICAgIGlzTWFjaGluZVplcm86IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSAtTUFDSElORV9FUFNJTE9OICYmIHZhbCA8PSBNQUNISU5FX0VQU0lMT047XG4gICAgICB9LFxuICAgICAgY2xhbXA6IGNsYW1wLFxuICAgICAgaW50ZWdyYXRlOiBmdW5jdGlvbiAoZiwgYSwgYiwgbikge1xuICAgICAgICB2YXIgeCA9IGFic2Npc3Nhc1tuIC0gMl0sXG4gICAgICAgICAgICB3ID0gd2VpZ2h0c1tuIC0gMl0sXG4gICAgICAgICAgICBBID0gKGIgLSBhKSAqIDAuNSxcbiAgICAgICAgICAgIEIgPSBBICsgYSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbSA9IG4gKyAxID4+IDEsXG4gICAgICAgICAgICBzdW0gPSBuICYgMSA/IHdbaSsrXSAqIGYoQikgOiAwO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbSkge1xuICAgICAgICAgIHZhciBBeCA9IEEgKiB4W2ldO1xuICAgICAgICAgIHN1bSArPSB3W2krK10gKiAoZihCICsgQXgpICsgZihCIC0gQXgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBICogc3VtO1xuICAgICAgfSxcbiAgICAgIGZpbmRSb290OiBmdW5jdGlvbiAoZiwgZGYsIHgsIGEsIGIsIG4sIHRvbGVyYW5jZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHZhciBmeCA9IGYoeCksXG4gICAgICAgICAgICAgIGR4ID0gZnggLyBkZih4KSxcbiAgICAgICAgICAgICAgbnggPSB4IC0gZHg7XG5cbiAgICAgICAgICBpZiAoYWJzKGR4KSA8IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgeCA9IG54O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZ4ID4gMCkge1xuICAgICAgICAgICAgYiA9IHg7XG4gICAgICAgICAgICB4ID0gbnggPD0gYSA/IChhICsgYikgKiAwLjUgOiBueDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYSA9IHg7XG4gICAgICAgICAgICB4ID0gbnggPj0gYiA/IChhICsgYikgKiAwLjUgOiBueDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhbXAoeCwgYSwgYik7XG4gICAgICB9LFxuICAgICAgc29sdmVRdWFkcmF0aWM6IGZ1bmN0aW9uIChhLCBiLCBjLCByb290cywgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHgxLFxuICAgICAgICAgICAgeDIgPSBJbmZpbml0eTtcblxuICAgICAgICBpZiAoYWJzKGEpIDwgRVBTSUxPTikge1xuICAgICAgICAgIGlmIChhYnMoYikgPCBFUFNJTE9OKSByZXR1cm4gYWJzKGMpIDwgRVBTSUxPTiA/IC0xIDogMDtcbiAgICAgICAgICB4MSA9IC1jIC8gYjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiICo9IC0wLjU7XG4gICAgICAgICAgdmFyIEQgPSBnZXREaXNjcmltaW5hbnQoYSwgYiwgYyk7XG5cbiAgICAgICAgICBpZiAoRCAmJiBhYnMoRCkgPCBNQUNISU5FX0VQU0lMT04pIHtcbiAgICAgICAgICAgIHZhciBmID0gZ2V0Tm9ybWFsaXphdGlvbkZhY3RvcihhYnMoYSksIGFicyhiKSwgYWJzKGMpKTtcblxuICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgYSAqPSBmO1xuICAgICAgICAgICAgICBiICo9IGY7XG4gICAgICAgICAgICAgIGMgKj0gZjtcbiAgICAgICAgICAgICAgRCA9IGdldERpc2NyaW1pbmFudChhLCBiLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoRCA+PSAtTUFDSElORV9FUFNJTE9OKSB7XG4gICAgICAgICAgICB2YXIgUSA9IEQgPCAwID8gMCA6IHNxcnQoRCksXG4gICAgICAgICAgICAgICAgUiA9IGIgKyAoYiA8IDAgPyAtUSA6IFEpO1xuXG4gICAgICAgICAgICBpZiAoUiA9PT0gMCkge1xuICAgICAgICAgICAgICB4MSA9IGMgLyBhO1xuICAgICAgICAgICAgICB4MiA9IC14MTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHgxID0gUiAvIGE7XG4gICAgICAgICAgICAgIHgyID0gYyAvIFI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICAgIGJvdW5kbGVzcyA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgICAgbWluQiA9IG1pbiAtIEVQU0lMT04sXG4gICAgICAgICAgICBtYXhCID0gbWF4ICsgRVBTSUxPTjtcbiAgICAgICAgaWYgKGlzRmluaXRlKHgxKSAmJiAoYm91bmRsZXNzIHx8IHgxID4gbWluQiAmJiB4MSA8IG1heEIpKSByb290c1tjb3VudCsrXSA9IGJvdW5kbGVzcyA/IHgxIDogY2xhbXAoeDEsIG1pbiwgbWF4KTtcbiAgICAgICAgaWYgKHgyICE9PSB4MSAmJiBpc0Zpbml0ZSh4MikgJiYgKGJvdW5kbGVzcyB8fCB4MiA+IG1pbkIgJiYgeDIgPCBtYXhCKSkgcm9vdHNbY291bnQrK10gPSBib3VuZGxlc3MgPyB4MiA6IGNsYW1wKHgyLCBtaW4sIG1heCk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgIH0sXG4gICAgICBzb2x2ZUN1YmljOiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgcm9vdHMsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciBmID0gZ2V0Tm9ybWFsaXphdGlvbkZhY3RvcihhYnMoYSksIGFicyhiKSwgYWJzKGMpLCBhYnMoZCkpLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIGIxLFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBxZCxcbiAgICAgICAgICAgIHE7XG5cbiAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICBhICo9IGY7XG4gICAgICAgICAgYiAqPSBmO1xuICAgICAgICAgIGMgKj0gZjtcbiAgICAgICAgICBkICo9IGY7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBldmFsdWF0ZSh4MCkge1xuICAgICAgICAgIHggPSB4MDtcbiAgICAgICAgICB2YXIgdG1wID0gYSAqIHg7XG4gICAgICAgICAgYjEgPSB0bXAgKyBiO1xuICAgICAgICAgIGMyID0gYjEgKiB4ICsgYztcbiAgICAgICAgICBxZCA9ICh0bXAgKyBiMSkgKiB4ICsgYzI7XG4gICAgICAgICAgcSA9IGMyICogeCArIGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWJzKGEpIDwgRVBTSUxPTikge1xuICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgIGIxID0gYztcbiAgICAgICAgICBjMiA9IGQ7XG4gICAgICAgICAgeCA9IEluZmluaXR5O1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhkKSA8IEVQU0lMT04pIHtcbiAgICAgICAgICBiMSA9IGI7XG4gICAgICAgICAgYzIgPSBjO1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2YWx1YXRlKC0oYiAvIGEpIC8gMyk7XG4gICAgICAgICAgdmFyIHQgPSBxIC8gYSxcbiAgICAgICAgICAgICAgciA9IHBvdyhhYnModCksIDEgLyAzKSxcbiAgICAgICAgICAgICAgcyA9IHQgPCAwID8gLTEgOiAxLFxuICAgICAgICAgICAgICB0ZCA9IC1xZCAvIGEsXG4gICAgICAgICAgICAgIHJkID0gdGQgPiAwID8gMS4zMjQ3MTc5NTcyNDQ3NDYgKiBNYXRoLm1heChyLCBzcXJ0KHRkKSkgOiByLFxuICAgICAgICAgICAgICB4MCA9IHggLSBzICogcmQ7XG5cbiAgICAgICAgICBpZiAoeDAgIT09IHgpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgZXZhbHVhdGUoeDApO1xuICAgICAgICAgICAgICB4MCA9IHFkID09PSAwID8geCA6IHggLSBxIC8gcWQgLyAoMSArIE1BQ0hJTkVfRVBTSUxPTik7XG4gICAgICAgICAgICB9IHdoaWxlIChzICogeDAgPiBzICogeCk7XG5cbiAgICAgICAgICAgIGlmIChhYnMoYSkgKiB4ICogeCA+IGFicyhkIC8geCkpIHtcbiAgICAgICAgICAgICAgYzIgPSAtZCAvIHg7XG4gICAgICAgICAgICAgIGIxID0gKGMyIC0gYykgLyB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiMSwgYzIsIHJvb3RzLCBtaW4sIG1heCksXG4gICAgICAgICAgICBib3VuZGxlc3MgPSBtaW4gPT0gbnVsbDtcbiAgICAgICAgaWYgKGlzRmluaXRlKHgpICYmIChjb3VudCA9PT0gMCB8fCBjb3VudCA+IDAgJiYgeCAhPT0gcm9vdHNbMF0gJiYgeCAhPT0gcm9vdHNbMV0pICYmIChib3VuZGxlc3MgfHwgeCA+IG1pbiAtIEVQU0lMT04gJiYgeCA8IG1heCArIEVQU0lMT04pKSByb290c1tjb3VudCsrXSA9IGJvdW5kbGVzcyA/IHggOiBjbGFtcCh4LCBtaW4sIG1heCk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG4gIHZhciBVSUQgPSB7XG4gICAgX2lkOiAxLFxuICAgIF9wb29sczoge30sXG4gICAgZ2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgdmFyIHBvb2wgPSB0aGlzLl9wb29sc1tuYW1lXTtcbiAgICAgICAgaWYgKCFwb29sKSBwb29sID0gdGhpcy5fcG9vbHNbbmFtZV0gPSB7XG4gICAgICAgICAgX2lkOiAxXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwb29sLl9pZCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkKys7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgUG9pbnQgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUG9pbnQnLFxuICAgIF9yZWFkSW5kZXg6IHRydWUsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoYXJnMCwgYXJnMSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnMCxcbiAgICAgICAgICByZWFkaW5nID0gdGhpcy5fX3JlYWQsXG4gICAgICAgICAgcmVhZCA9IDA7XG5cbiAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgaGFzWSA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblxuICAgICAgICB0aGlzLl9zZXQoYXJnMCwgaGFzWSA/IGFyZzEgOiBhcmcwKTtcblxuICAgICAgICBpZiAocmVhZGluZykgcmVhZCA9IGhhc1kgPyAyIDogMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9zZXQoMCwgMCk7XG5cbiAgICAgICAgaWYgKHJlYWRpbmcpIHJlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2JqID0gdHlwZSA9PT0gJ3N0cmluZycgPyBhcmcwLnNwbGl0KC9bXFxzLF0rLykgfHwgW10gOiBhcmcwO1xuICAgICAgICByZWFkID0gMTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgdGhpcy5fc2V0KCtvYmpbMF0sICsob2JqLmxlbmd0aCA+IDEgPyBvYmpbMV0gOiBvYmpbMF0pKTtcbiAgICAgICAgfSBlbHNlIGlmICgneCcgaW4gb2JqKSB7XG4gICAgICAgICAgdGhpcy5fc2V0KG9iai54IHx8IDAsIG9iai55IHx8IDApO1xuICAgICAgICB9IGVsc2UgaWYgKCd3aWR0aCcgaW4gb2JqKSB7XG4gICAgICAgICAgdGhpcy5fc2V0KG9iai53aWR0aCB8fCAwLCBvYmouaGVpZ2h0IHx8IDApO1xuICAgICAgICB9IGVsc2UgaWYgKCdhbmdsZScgaW4gb2JqKSB7XG4gICAgICAgICAgdGhpcy5fc2V0KG9iai5sZW5ndGggfHwgMCwgMCk7XG5cbiAgICAgICAgICB0aGlzLnNldEFuZ2xlKG9iai5hbmdsZSB8fCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZXQoMCwgMCk7XG5cbiAgICAgICAgICByZWFkID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVhZGluZykgdGhpcy5fX3JlYWQgPSByZWFkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXQ6ICcjaW5pdGlhbGl6ZScsXG4gICAgX3NldDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMgPT09IHBvaW50IHx8IHBvaW50ICYmICh0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55IHx8IEFycmF5LmlzQXJyYXkocG9pbnQpICYmIHRoaXMueCA9PT0gcG9pbnRbMF0gJiYgdGhpcy55ID09PSBwb2ludFsxXSkgfHwgZmFsc2U7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG4gICAgICByZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueCkgKyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KSArICcgfSc7XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcbiAgICAgIHJldHVybiBbZi5udW1iZXIodGhpcy54KSwgZi5udW1iZXIodGhpcy55KV07XG4gICAgfSxcbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICB9LFxuICAgIHNldExlbmd0aDogZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5fYW5nbGUgfHwgMDtcblxuICAgICAgICB0aGlzLl9zZXQoTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLCBNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNjYWxlID0gbGVuZ3RoIC8gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICAgICAgaWYgKE51bWVyaWNhbC5pc1plcm8oc2NhbGUpKSB0aGlzLmdldEFuZ2xlKCk7XG5cbiAgICAgICAgdGhpcy5fc2V0KHRoaXMueCAqIHNjYWxlLCB0aGlzLnkgKiBzY2FsZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRBbmdsZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5nbGVJblJhZGlhbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgfSxcbiAgICBzZXRBbmdsZTogZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICB0aGlzLnNldEFuZ2xlSW5SYWRpYW5zLmNhbGwodGhpcywgYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICB9LFxuICAgIGdldEFuZ2xlSW5EZWdyZWVzOiAnI2dldEFuZ2xlJyxcbiAgICBzZXRBbmdsZUluRGVncmVlczogJyNzZXRBbmdsZScsXG4gICAgZ2V0QW5nbGVJblJhZGlhbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1plcm8oKSA/IHRoaXMuX2FuZ2xlIHx8IDAgOiB0aGlzLl9hbmdsZSA9IE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgZGl2ID0gdGhpcy5nZXRMZW5ndGgoKSAqIHBvaW50LmdldExlbmd0aCgpO1xuXG4gICAgICAgIGlmIChOdW1lcmljYWwuaXNaZXJvKGRpdikpIHtcbiAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhID0gdGhpcy5kb3QocG9pbnQpIC8gZGl2O1xuICAgICAgICAgIHJldHVybiBNYXRoLmFjb3MoYSA8IC0xID8gLTEgOiBhID4gMSA/IDEgOiBhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2V0QW5nbGVJblJhZGlhbnM6IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgdGhpcy5fYW5nbGUgPSBhbmdsZTtcblxuICAgICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuXG4gICAgICAgIHRoaXMuX3NldChNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsIE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRRdWFkcmFudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCA+PSAwID8gdGhpcy55ID49IDAgPyAxIDogNCA6IHRoaXMueSA+PSAwID8gMiA6IDM7XG4gICAgfVxuICB9LCB7XG4gICAgYmVhbnM6IGZhbHNlLFxuICAgIGdldERpcmVjdGVkQW5nbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMuY3Jvc3MocG9pbnQpLCB0aGlzLmRvdChwb2ludCkpICogMTgwIC8gTWF0aC5QSTtcbiAgICB9LFxuICAgIGdldERpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBwb2ludCA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgeCA9IHBvaW50LnggLSB0aGlzLngsXG4gICAgICAgICAgeSA9IHBvaW50LnkgLSB0aGlzLnksXG4gICAgICAgICAgZCA9IHggKiB4ICsgeSAqIHksXG4gICAgICAgICAgc3F1YXJlZCA9IEJhc2UucmVhZChhcmdzKTtcbiAgICAgIHJldHVybiBzcXVhcmVkID8gZCA6IE1hdGguc3FydChkKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSBsZW5ndGggPSAxO1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldExlbmd0aCgpLFxuICAgICAgICAgIHNjYWxlID0gY3VycmVudCAhPT0gMCA/IGxlbmd0aCAvIGN1cnJlbnQgOiAwLFxuICAgICAgICAgIHBvaW50ID0gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxlLCB0aGlzLnkgKiBzY2FsZSk7XG4gICAgICBpZiAoc2NhbGUgPj0gMCkgcG9pbnQuX2FuZ2xlID0gdGhpcy5fYW5nbGU7XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSxcbiAgICByb3RhdGU6IGZ1bmN0aW9uIChhbmdsZSwgY2VudGVyKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHJldHVybiB0aGlzLmNsb25lKCk7XG4gICAgICBhbmdsZSA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICAgIHZhciBwb2ludCA9IGNlbnRlciA/IHRoaXMuc3VidHJhY3QoY2VudGVyKSA6IHRoaXMsXG4gICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHBvaW50ID0gbmV3IFBvaW50KHBvaW50LnggKiBjb3MgLSBwb2ludC55ICogc2luLCBwb2ludC54ICogc2luICsgcG9pbnQueSAqIGNvcyk7XG4gICAgICByZXR1cm4gY2VudGVyID8gcG9pbnQuYWRkKGNlbnRlcikgOiBwb2ludDtcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgcmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodGhpcykgOiB0aGlzO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHBvaW50LngsIHRoaXMueSArIHBvaW50LnkpO1xuICAgIH0sXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gcG9pbnQueCwgdGhpcy55IC0gcG9pbnQueSk7XG4gICAgfSxcbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcbiAgICB9LFxuICAgIGRpdmlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcbiAgICB9LFxuICAgIG1vZHVsbzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggJSBwb2ludC54LCB0aGlzLnkgJSBwb2ludC55KTtcbiAgICB9LFxuICAgIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCgtdGhpcy54LCAtdGhpcy55KTtcbiAgICB9LFxuICAgIGlzSW5zaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzKTtcbiAgICB9LFxuICAgIGlzQ2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHBvaW50ID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICB0b2xlcmFuY2UgPSBCYXNlLnJlYWQoYXJncyk7XG4gICAgICByZXR1cm4gdGhpcy5nZXREaXN0YW5jZShwb2ludCkgPD0gdG9sZXJhbmNlO1xuICAgIH0sXG4gICAgaXNDb2xsaW5lYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBQb2ludC5pc0NvbGxpbmVhcih0aGlzLngsIHRoaXMueSwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgfSxcbiAgICBpc0NvbGluZWFyOiAnI2lzQ29sbGluZWFyJyxcbiAgICBpc09ydGhvZ29uYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBQb2ludC5pc09ydGhvZ29uYWwodGhpcy54LCB0aGlzLnksIHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG4gICAgaXNaZXJvOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcbiAgICAgIHJldHVybiBpc1plcm8odGhpcy54KSAmJiBpc1plcm8odGhpcy55KTtcbiAgICB9LFxuICAgIGlzTmFOOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXNOYU4odGhpcy54KSB8fCBpc05hTih0aGlzLnkpO1xuICAgIH0sXG4gICAgaXNJblF1YWRyYW50OiBmdW5jdGlvbiAocSkge1xuICAgICAgcmV0dXJuIHRoaXMueCAqIChxID4gMSAmJiBxIDwgNCA/IC0xIDogMSkgPj0gMCAmJiB0aGlzLnkgKiAocSA+IDIgPyAtMSA6IDEpID49IDA7XG4gICAgfSxcbiAgICBkb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzLnggKiBwb2ludC54ICsgdGhpcy55ICogcG9pbnQueTtcbiAgICB9LFxuICAgIGNyb3NzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy54ICogcG9pbnQueSAtIHRoaXMueSAqIHBvaW50Lng7XG4gICAgfSxcbiAgICBwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgc2NhbGUgPSBwb2ludC5pc1plcm8oKSA/IDAgOiB0aGlzLmRvdChwb2ludCkgLyBwb2ludC5kb3QocG9pbnQpO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChwb2ludC54ICogc2NhbGUsIHBvaW50LnkgKiBzY2FsZSk7XG4gICAgfSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBtaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBwb2ludDEgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgcG9pbnQyID0gUG9pbnQucmVhZChhcmdzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLm1pbihwb2ludDEueCwgcG9pbnQyLngpLCBNYXRoLm1pbihwb2ludDEueSwgcG9pbnQyLnkpKTtcbiAgICAgIH0sXG4gICAgICBtYXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBwb2ludDEgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgcG9pbnQyID0gUG9pbnQucmVhZChhcmdzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLm1heChwb2ludDEueCwgcG9pbnQyLngpLCBNYXRoLm1heChwb2ludDEueSwgcG9pbnQyLnkpKTtcbiAgICAgIH0sXG4gICAgICByYW5kb206IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcbiAgICAgIH0sXG4gICAgICBpc0NvbGxpbmVhcjogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh4MSAqIHkyIC0geTEgKiB4MikgPD0gTWF0aC5zcXJ0KCh4MSAqIHgxICsgeTEgKiB5MSkgKiAoeDIgKiB4MiArIHkyICogeTIpKSAqIDFlLTg7XG4gICAgICB9LFxuICAgICAgaXNPcnRob2dvbmFsOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHgxICogeDIgKyB5MSAqIHkyKSA8PSBNYXRoLnNxcnQoKHgxICogeDEgKyB5MSAqIHkxKSAqICh4MiAqIHgyICsgeTIgKiB5MikpICogMWUtODtcbiAgICAgIH1cbiAgICB9XG4gIH0sIEJhc2UuZWFjaChbJ3JvdW5kJywgJ2NlaWwnLCAnZmxvb3InLCAnYWJzJ10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgb3AgPSBNYXRoW2tleV07XG5cbiAgICB0aGlzW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KG9wKHRoaXMueCksIG9wKHRoaXMueSkpO1xuICAgIH07XG4gIH0sIHt9KSk7XG4gIHZhciBMaW5rZWRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoeCwgeSwgb3duZXIsIHNldHRlcikge1xuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICB0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG4gICAgfSxcbiAgICBfc2V0OiBmdW5jdGlvbiAoeCwgeSwgX2RvbnROb3RpZnkpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICBpZiAoIV9kb250Tm90aWZ5KSB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRYOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9LFxuICAgIHNldFg6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl94ID0geDtcblxuICAgICAgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICB9LFxuICAgIGdldFk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH0sXG4gICAgc2V0WTogZnVuY3Rpb24gKHkpIHtcbiAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgIH0sXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuX293bmVyLl9zZWxlY3Rpb24gJiB0aGlzLl9nZXRTZWxlY3Rpb24oKSk7XG4gICAgfSxcbiAgICBzZXRTZWxlY3RlZDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICB0aGlzLl9vd25lci5fY2hhbmdlU2VsZWN0aW9uKHRoaXMuX2dldFNlbGVjdGlvbigpLCBzZWxlY3RlZCk7XG4gICAgfSxcbiAgICBfZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0dGVyID09PSAnc2V0UG9zaXRpb24nID8gNCA6IDA7XG4gICAgfVxuICB9KTtcbiAgdmFyIFNpemUgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnU2l6ZScsXG4gICAgX3JlYWRJbmRleDogdHJ1ZSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKGFyZzAsIGFyZzEpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGFyZzAsXG4gICAgICAgICAgcmVhZGluZyA9IHRoaXMuX19yZWFkLFxuICAgICAgICAgIHJlYWQgPSAwO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGhhc0hlaWdodCA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblxuICAgICAgICB0aGlzLl9zZXQoYXJnMCwgaGFzSGVpZ2h0ID8gYXJnMSA6IGFyZzApO1xuXG4gICAgICAgIGlmIChyZWFkaW5nKSByZWFkID0gaGFzSGVpZ2h0ID8gMiA6IDE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2V0KDAsIDApO1xuXG4gICAgICAgIGlmIChyZWFkaW5nKSByZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9iaiA9IHR5cGUgPT09ICdzdHJpbmcnID8gYXJnMC5zcGxpdCgvW1xccyxdKy8pIHx8IFtdIDogYXJnMDtcbiAgICAgICAgcmVhZCA9IDE7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgIHRoaXMuX3NldCgrb2JqWzBdLCArKG9iai5sZW5ndGggPiAxID8gb2JqWzFdIDogb2JqWzBdKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ3dpZHRoJyBpbiBvYmopIHtcbiAgICAgICAgICB0aGlzLl9zZXQob2JqLndpZHRoIHx8IDAsIG9iai5oZWlnaHQgfHwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ3gnIGluIG9iaikge1xuICAgICAgICAgIHRoaXMuX3NldChvYmoueCB8fCAwLCBvYmoueSB8fCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZXQoMCwgMCk7XG5cbiAgICAgICAgICByZWFkID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVhZGluZykgdGhpcy5fX3JlYWQgPSByZWFkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXQ6ICcjaW5pdGlhbGl6ZScsXG4gICAgX3NldDogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICByZXR1cm4gc2l6ZSA9PT0gdGhpcyB8fCBzaXplICYmICh0aGlzLndpZHRoID09PSBzaXplLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBzaXplLmhlaWdodCB8fCBBcnJheS5pc0FycmF5KHNpemUpICYmIHRoaXMud2lkdGggPT09IHNpemVbMF0gJiYgdGhpcy5oZWlnaHQgPT09IHNpemVbMV0pIHx8IGZhbHNlO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG4gICAgICByZXR1cm4gJ3sgd2lkdGg6ICcgKyBmLm51bWJlcih0aGlzLndpZHRoKSArICcsIGhlaWdodDogJyArIGYubnVtYmVyKHRoaXMuaGVpZ2h0KSArICcgfSc7XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcbiAgICAgIHJldHVybiBbZi5udW1iZXIodGhpcy53aWR0aCksIGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCArIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICsgc2l6ZS5oZWlnaHQpO1xuICAgIH0sXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAtIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpO1xuICAgIH0sXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAqIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICogc2l6ZS5oZWlnaHQpO1xuICAgIH0sXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLyBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAvIHNpemUuaGVpZ2h0KTtcbiAgICB9LFxuICAgIG1vZHVsbzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICUgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgJSBzaXplLmhlaWdodCk7XG4gICAgfSxcbiAgICBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2l6ZSgtdGhpcy53aWR0aCwgLXRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuICAgIGlzWmVybzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG4gICAgICByZXR1cm4gaXNaZXJvKHRoaXMud2lkdGgpICYmIGlzWmVybyh0aGlzLmhlaWdodCk7XG4gICAgfSxcbiAgICBpc05hTjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlzTmFOKHRoaXMud2lkdGgpIHx8IGlzTmFOKHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIG1pbjogZnVuY3Rpb24gKHNpemUxLCBzaXplMikge1xuICAgICAgICByZXR1cm4gbmV3IFNpemUoTWF0aC5taW4oc2l6ZTEud2lkdGgsIHNpemUyLndpZHRoKSwgTWF0aC5taW4oc2l6ZTEuaGVpZ2h0LCBzaXplMi5oZWlnaHQpKTtcbiAgICAgIH0sXG4gICAgICBtYXg6IGZ1bmN0aW9uIChzaXplMSwgc2l6ZTIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaXplKE1hdGgubWF4KHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksIE1hdGgubWF4KHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG4gICAgICB9LFxuICAgICAgcmFuZG9tOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZShNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIEJhc2UuZWFjaChbJ3JvdW5kJywgJ2NlaWwnLCAnZmxvb3InLCAnYWJzJ10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgb3AgPSBNYXRoW2tleV07XG5cbiAgICB0aGlzW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFNpemUob3AodGhpcy53aWR0aCksIG9wKHRoaXMuaGVpZ2h0KSk7XG4gICAgfTtcbiAgfSwge30pKTtcbiAgdmFyIExpbmtlZFNpemUgPSBTaXplLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZSh3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5fb3duZXIgPSBvd25lcjtcbiAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlcjtcbiAgICB9LFxuICAgIF9zZXQ6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgIGlmICghX2RvbnROb3RpZnkpIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfSxcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuXG4gICAgICB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgfVxuICB9KTtcbiAgdmFyIFJlY3RhbmdsZSA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdSZWN0YW5nbGUnLFxuICAgIF9yZWFkSW5kZXg6IHRydWUsXG4gICAgYmVhbnM6IHRydWUsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHR5cGUgPSB0eXBlb2YgYXJnMCxcbiAgICAgICAgICByZWFkO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5fc2V0KGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuXG4gICAgICAgIHJlYWQgPSA0O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NldCgwLCAwLCAwLCAwKTtcblxuICAgICAgICByZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuICAgICAgICAgIHRoaXMuX3NldC5hcHBseSh0aGlzLCBhcmcwKTtcblxuICAgICAgICAgIHJlYWQgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZzAueCAhPT0gdW5kZWZpbmVkIHx8IGFyZzAud2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3NldChhcmcwLnggfHwgMCwgYXJnMC55IHx8IDAsIGFyZzAud2lkdGggfHwgMCwgYXJnMC5oZWlnaHQgfHwgMCk7XG5cbiAgICAgICAgICByZWFkID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmcwLmZyb20gPT09IHVuZGVmaW5lZCAmJiBhcmcwLnRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9zZXQoMCwgMCwgMCwgMCk7XG5cbiAgICAgICAgICBpZiAoQmFzZS5yZWFkU3VwcG9ydGVkKGFyZ3MsIHRoaXMpKSB7XG4gICAgICAgICAgICByZWFkID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZnJtID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdmcm9tJyksXG4gICAgICAgICAgICBuZXh0ID0gQmFzZS5wZWVrKGFyZ3MpLFxuICAgICAgICAgICAgeCA9IGZybS54LFxuICAgICAgICAgICAgeSA9IGZybS55LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dC54ICE9PSB1bmRlZmluZWQgfHwgQmFzZS5oYXNOYW1lZChhcmdzLCAndG8nKSkge1xuICAgICAgICAgIHZhciB0byA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAndG8nKTtcbiAgICAgICAgICB3aWR0aCA9IHRvLnggLSB4O1xuICAgICAgICAgIGhlaWdodCA9IHRvLnkgLSB5O1xuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgeCA9IHRvLng7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgeSA9IHRvLnk7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmdzKTtcbiAgICAgICAgICB3aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgcmVhZCA9IGFyZ3MuX19pbmRleDtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbHRlcmVkID0gYXJncy5fX2ZpbHRlcmVkO1xuICAgICAgaWYgKGZpbHRlcmVkKSB0aGlzLl9fZmlsdGVyZWQgPSBmaWx0ZXJlZDtcbiAgICAgIGlmICh0aGlzLl9fcmVhZCkgdGhpcy5fX3JlYWQgPSByZWFkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXQ6ICcjaW5pdGlhbGl6ZScsXG4gICAgX3NldDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgdmFyIHJ0ID0gQmFzZS5pc1BsYWluVmFsdWUocmVjdCkgPyBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpIDogcmVjdDtcbiAgICAgIHJldHVybiBydCA9PT0gdGhpcyB8fCBydCAmJiB0aGlzLnggPT09IHJ0LnggJiYgdGhpcy55ID09PSBydC55ICYmIHRoaXMud2lkdGggPT09IHJ0LndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBydC5oZWlnaHQgfHwgZmFsc2U7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG4gICAgICByZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueCkgKyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KSArICcsIHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aCkgKyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodCkgKyAnIH0nO1xuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG4gICAgICByZXR1cm4gW2YubnVtYmVyKHRoaXMueCksIGYubnVtYmVyKHRoaXMueSksIGYubnVtYmVyKHRoaXMud2lkdGgpLCBmLm51bWJlcih0aGlzLmhlaWdodCldO1xuICAgIH0sXG4gICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uIChfZG9udExpbmspIHtcbiAgICAgIHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcbiAgICAgIHJldHVybiBuZXcgY3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcywgJ3NldFBvaW50Jyk7XG4gICAgfSxcbiAgICBzZXRQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgdGhpcy54ID0gcG9pbnQueDtcbiAgICAgIHRoaXMueSA9IHBvaW50Lnk7XG4gICAgfSxcbiAgICBnZXRTaXplOiBmdW5jdGlvbiAoX2RvbnRMaW5rKSB7XG4gICAgICB2YXIgY3RvciA9IF9kb250TGluayA/IFNpemUgOiBMaW5rZWRTaXplO1xuICAgICAgcmV0dXJuIG5ldyBjdG9yKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuICAgIH0sXG4gICAgX2Z3OiAxLFxuICAgIF9maDogMSxcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIHN4ID0gdGhpcy5fc3gsXG4gICAgICAgICAgc3kgPSB0aGlzLl9zeSxcbiAgICAgICAgICB3ID0gc2l6ZS53aWR0aCxcbiAgICAgICAgICBoID0gc2l6ZS5oZWlnaHQ7XG5cbiAgICAgIGlmIChzeCkge1xuICAgICAgICB0aGlzLnggKz0gKHRoaXMud2lkdGggLSB3KSAqIHN4O1xuICAgICAgfVxuXG4gICAgICBpZiAoc3kpIHtcbiAgICAgICAgdGhpcy55ICs9ICh0aGlzLmhlaWdodCAtIGgpICogc3k7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgICAgdGhpcy5fZncgPSB0aGlzLl9maCA9IDE7XG4gICAgfSxcbiAgICBnZXRMZWZ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy54O1xuICAgIH0sXG4gICAgc2V0TGVmdDogZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgIGlmICghdGhpcy5fZncpIHtcbiAgICAgICAgdmFyIGFtb3VudCA9IGxlZnQgLSB0aGlzLng7XG4gICAgICAgIHRoaXMud2lkdGggLT0gdGhpcy5fc3ggPT09IDAuNSA/IGFtb3VudCAqIDIgOiBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueCA9IGxlZnQ7XG4gICAgICB0aGlzLl9zeCA9IHRoaXMuX2Z3ID0gMDtcbiAgICB9LFxuICAgIGdldFRvcDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICB9LFxuICAgIHNldFRvcDogZnVuY3Rpb24gKHRvcCkge1xuICAgICAgaWYgKCF0aGlzLl9maCkge1xuICAgICAgICB2YXIgYW1vdW50ID0gdG9wIC0gdGhpcy55O1xuICAgICAgICB0aGlzLmhlaWdodCAtPSB0aGlzLl9zeSA9PT0gMC41ID8gYW1vdW50ICogMiA6IGFtb3VudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy55ID0gdG9wO1xuICAgICAgdGhpcy5fc3kgPSB0aGlzLl9maCA9IDA7XG4gICAgfSxcbiAgICBnZXRSaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgfSxcbiAgICBzZXRSaWdodDogZnVuY3Rpb24gKHJpZ2h0KSB7XG4gICAgICBpZiAoIXRoaXMuX2Z3KSB7XG4gICAgICAgIHZhciBhbW91bnQgPSByaWdodCAtIHRoaXMueDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX3N4ID09PSAwLjUgPyBhbW91bnQgKiAyIDogYW1vdW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnggPSByaWdodCAtIHRoaXMud2lkdGg7XG4gICAgICB0aGlzLl9zeCA9IDE7XG4gICAgICB0aGlzLl9mdyA9IDA7XG4gICAgfSxcbiAgICBnZXRCb3R0b206IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9LFxuICAgIHNldEJvdHRvbTogZnVuY3Rpb24gKGJvdHRvbSkge1xuICAgICAgaWYgKCF0aGlzLl9maCkge1xuICAgICAgICB2YXIgYW1vdW50ID0gYm90dG9tIC0gdGhpcy55O1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX3N5ID09PSAwLjUgPyBhbW91bnQgKiAyIDogYW1vdW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnkgPSBib3R0b20gLSB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuX3N5ID0gMTtcbiAgICAgIHRoaXMuX2ZoID0gMDtcbiAgICB9LFxuICAgIGdldENlbnRlclg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoIC8gMjtcbiAgICB9LFxuICAgIHNldENlbnRlclg6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fZncgfHwgdGhpcy5fc3ggPT09IDAuNSkge1xuICAgICAgICB0aGlzLnggPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fc3gpIHtcbiAgICAgICAgICB0aGlzLnggKz0gKHggLSB0aGlzLngpICogMiAqIHRoaXMuX3N4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53aWR0aCA9ICh4IC0gdGhpcy54KSAqIDI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N4ID0gMC41O1xuICAgICAgdGhpcy5fZncgPSAwO1xuICAgIH0sXG4gICAgZ2V0Q2VudGVyWTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICB9LFxuICAgIHNldENlbnRlclk6IGZ1bmN0aW9uICh5KSB7XG4gICAgICBpZiAodGhpcy5fZmggfHwgdGhpcy5fc3kgPT09IDAuNSkge1xuICAgICAgICB0aGlzLnkgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX3N5KSB7XG4gICAgICAgICAgdGhpcy55ICs9ICh5IC0gdGhpcy55KSAqIDIgKiB0aGlzLl9zeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gKHkgLSB0aGlzLnkpICogMjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3kgPSAwLjU7XG4gICAgICB0aGlzLl9maCA9IDA7XG4gICAgfSxcbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uIChfZG9udExpbmspIHtcbiAgICAgIHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcbiAgICAgIHJldHVybiBuZXcgY3Rvcih0aGlzLmdldENlbnRlclgoKSwgdGhpcy5nZXRDZW50ZXJZKCksIHRoaXMsICdzZXRDZW50ZXInKTtcbiAgICB9LFxuICAgIHNldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgdGhpcy5zZXRDZW50ZXJYKHBvaW50LngpO1xuICAgICAgdGhpcy5zZXRDZW50ZXJZKHBvaW50LnkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRBcmVhOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IDAgfHwgdGhpcy5oZWlnaHQgPT09IDA7XG4gICAgfSxcbiAgICBjb250YWluczogZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZyAmJiBhcmcud2lkdGggIT09IHVuZGVmaW5lZCB8fCAoQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKS5sZW5ndGggPT09IDQgPyB0aGlzLl9jb250YWluc1JlY3RhbmdsZShSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpKSA6IHRoaXMuX2NvbnRhaW5zUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgIHJldHVybiB4ID49IHRoaXMueCAmJiB5ID49IHRoaXMueSAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGggJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9LFxuICAgIF9jb250YWluc1JlY3RhbmdsZTogZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgIHZhciB4ID0gcmVjdC54LFxuICAgICAgICAgIHkgPSByZWN0Lnk7XG4gICAgICByZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnkgJiYgeCArIHJlY3Qud2lkdGggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAmJiB5ICsgcmVjdC5oZWlnaHQgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgZXBzaWxvbiA9IEJhc2UucmVhZChhcmd1bWVudHMpIHx8IDA7XG4gICAgICByZXR1cm4gcmVjdC54ICsgcmVjdC53aWR0aCA+IHRoaXMueCAtIGVwc2lsb24gJiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPiB0aGlzLnkgLSBlcHNpbG9uICYmIHJlY3QueCA8IHRoaXMueCArIHRoaXMud2lkdGggKyBlcHNpbG9uICYmIHJlY3QueSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0ICsgZXBzaWxvbjtcbiAgICB9LFxuICAgIGludGVyc2VjdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIHgxID0gTWF0aC5tYXgodGhpcy54LCByZWN0LngpLFxuICAgICAgICAgIHkxID0gTWF0aC5tYXgodGhpcy55LCByZWN0LnkpLFxuICAgICAgICAgIHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG4gICAgICAgICAgeTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICB9LFxuICAgIHVuaXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgeDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3QueCksXG4gICAgICAgICAgeTEgPSBNYXRoLm1pbih0aGlzLnksIHJlY3QueSksXG4gICAgICAgICAgeDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKSxcbiAgICAgICAgICB5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG4gICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgIH0sXG4gICAgaW5jbHVkZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgdmFyIHgxID0gTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcbiAgICAgICAgICB5MSA9IE1hdGgubWluKHRoaXMueSwgcG9pbnQueSksXG4gICAgICAgICAgeDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCBwb2ludC54KSxcbiAgICAgICAgICB5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBwb2ludC55KTtcbiAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG4gICAgfSxcbiAgICBleHBhbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhbW91bnQgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICBob3IgPSBhbW91bnQud2lkdGgsXG4gICAgICAgICAgdmVyID0gYW1vdW50LmhlaWdodDtcbiAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIGhvciAvIDIsIHRoaXMueSAtIHZlciAvIDIsIHRoaXMud2lkdGggKyBob3IsIHRoaXMuaGVpZ2h0ICsgdmVyKTtcbiAgICB9LFxuICAgIHNjYWxlOiBmdW5jdGlvbiAoaG9yLCB2ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGFuZCh0aGlzLndpZHRoICogaG9yIC0gdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQgKiAodmVyID09PSB1bmRlZmluZWQgPyBob3IgOiB2ZXIpIC0gdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgfSwgQmFzZS5lYWNoKFtbJ1RvcCcsICdMZWZ0J10sIFsnVG9wJywgJ1JpZ2h0J10sIFsnQm90dG9tJywgJ0xlZnQnXSwgWydCb3R0b20nLCAnUmlnaHQnXSwgWydMZWZ0JywgJ0NlbnRlciddLCBbJ1RvcCcsICdDZW50ZXInXSwgWydSaWdodCcsICdDZW50ZXInXSwgWydCb3R0b20nLCAnQ2VudGVyJ11dLCBmdW5jdGlvbiAocGFydHMsIGluZGV4KSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0cy5qb2luKCcnKSxcbiAgICAgICAgeEZpcnN0ID0gL15bUkxdLy50ZXN0KHBhcnQpO1xuICAgIGlmIChpbmRleCA+PSA0KSBwYXJ0c1sxXSArPSB4Rmlyc3QgPyAnWScgOiAnWCc7XG4gICAgdmFyIHggPSBwYXJ0c1t4Rmlyc3QgPyAwIDogMV0sXG4gICAgICAgIHkgPSBwYXJ0c1t4Rmlyc3QgPyAxIDogMF0sXG4gICAgICAgIGdldFggPSAnZ2V0JyArIHgsXG4gICAgICAgIGdldFkgPSAnZ2V0JyArIHksXG4gICAgICAgIHNldFggPSAnc2V0JyArIHgsXG4gICAgICAgIHNldFkgPSAnc2V0JyArIHksXG4gICAgICAgIGdldCA9ICdnZXQnICsgcGFydCxcbiAgICAgICAgc2V0ID0gJ3NldCcgKyBwYXJ0O1xuXG4gICAgdGhpc1tnZXRdID0gZnVuY3Rpb24gKF9kb250TGluaykge1xuICAgICAgdmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuICAgICAgcmV0dXJuIG5ldyBjdG9yKHRoaXNbZ2V0WF0oKSwgdGhpc1tnZXRZXSgpLCB0aGlzLCBzZXQpO1xuICAgIH07XG5cbiAgICB0aGlzW3NldF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICB0aGlzW3NldFhdKHBvaW50LngpO1xuICAgICAgdGhpc1tzZXRZXShwb2ludC55KTtcbiAgICB9O1xuICB9LCB7XG4gICAgYmVhbnM6IHRydWVcbiAgfSkpO1xuICB2YXIgTGlua2VkUmVjdGFuZ2xlID0gUmVjdGFuZ2xlLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcbiAgICAgIHRoaXMuX3NldCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcblxuICAgICAgdGhpcy5fb3duZXIgPSBvd25lcjtcbiAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlcjtcbiAgICB9LFxuICAgIF9zZXQ6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBpZiAoIV9kb250Tm90aWZ5KSB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm90byA9IFJlY3RhbmdsZS5wcm90b3R5cGU7XG4gICAgcmV0dXJuIEJhc2UuZWFjaChbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcbiAgICAgICAgICBpbnRlcm5hbCA9ICdfJyArIGtleTtcblxuICAgICAgdGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tpbnRlcm5hbF07XG4gICAgICB9O1xuXG4gICAgICB0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpc1tpbnRlcm5hbF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9kb250Tm90aWZ5KSB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgICAgfTtcbiAgICB9LCBCYXNlLmVhY2goWydQb2ludCcsICdTaXplJywgJ0NlbnRlcicsICdMZWZ0JywgJ1RvcCcsICdSaWdodCcsICdCb3R0b20nLCAnQ2VudGVyWCcsICdDZW50ZXJZJywgJ1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsICdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG5hbWUgPSAnc2V0JyArIGtleTtcblxuICAgICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZG9udE5vdGlmeSA9IHRydWU7XG4gICAgICAgIHByb3RvW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2RvbnROb3RpZnkgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgICAgfTtcbiAgICB9LCB7XG4gICAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLl9vd25lci5fc2VsZWN0aW9uICYgMik7XG4gICAgICB9LFxuICAgICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgICB2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblxuICAgICAgICBpZiAob3duZXIuX2NoYW5nZVNlbGVjdGlvbikge1xuICAgICAgICAgIG93bmVyLl9jaGFuZ2VTZWxlY3Rpb24oMiwgc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpO1xuICB9KCkpO1xuICB2YXIgTWF0cml4ID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ01hdHJpeCcsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gTWF0cml4KGFyZywgX2RvbnROb3RpZnkpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGNvdW50ID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgb2sgPSB0cnVlO1xuXG4gICAgICBpZiAoY291bnQgPj0gNikge1xuICAgICAgICB0aGlzLl9zZXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAxIHx8IGNvdW50ID09PSAyKSB7XG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICB0aGlzLl9zZXQoYXJnLl9hLCBhcmcuX2IsIGFyZy5fYywgYXJnLl9kLCBhcmcuX3R4LCBhcmcuX3R5LCBfZG9udE5vdGlmeSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgdGhpcy5fc2V0LmFwcGx5KHRoaXMsIF9kb250Tm90aWZ5ID8gYXJnLmNvbmNhdChbX2RvbnROb3RpZnldKSA6IGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghY291bnQpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG1hdHJpeCBwYXJhbWV0ZXJzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0OiAnI2luaXRpYWxpemUnLFxuICAgIF9zZXQ6IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB0eCwgdHksIF9kb250Tm90aWZ5KSB7XG4gICAgICB0aGlzLl9hID0gYTtcbiAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIHRoaXMuX3R4ID0gdHg7XG4gICAgICB0aGlzLl90eSA9IHR5O1xuICAgICAgaWYgKCFfZG9udE5vdGlmeSkgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuZ2V0VmFsdWVzKCksIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgaWYgKG93bmVyLl9hcHBseU1hdHJpeCkge1xuICAgICAgICAgIG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvd25lci5fY2hhbmdlZCgyNSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9iLCB0aGlzLl9jLCB0aGlzLl9kLCB0aGlzLl90eCwgdGhpcy5fdHkpO1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAobXgpIHtcbiAgICAgIHJldHVybiBteCA9PT0gdGhpcyB8fCBteCAmJiB0aGlzLl9hID09PSBteC5fYSAmJiB0aGlzLl9iID09PSBteC5fYiAmJiB0aGlzLl9jID09PSBteC5fYyAmJiB0aGlzLl9kID09PSBteC5fZCAmJiB0aGlzLl90eCA9PT0gbXguX3R4ICYmIHRoaXMuX3R5ID09PSBteC5fdHk7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG4gICAgICByZXR1cm4gJ1tbJyArIFtmLm51bWJlcih0aGlzLl9hKSwgZi5udW1iZXIodGhpcy5fYyksIGYubnVtYmVyKHRoaXMuX3R4KV0uam9pbignLCAnKSArICddLCBbJyArIFtmLm51bWJlcih0aGlzLl9iKSwgZi5udW1iZXIodGhpcy5fZCksIGYubnVtYmVyKHRoaXMuX3R5KV0uam9pbignLCAnKSArICddXSc7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gKF9kb250Tm90aWZ5KSB7XG4gICAgICB0aGlzLl9hID0gdGhpcy5fZCA9IDE7XG4gICAgICB0aGlzLl9iID0gdGhpcy5fYyA9IHRoaXMuX3R4ID0gdGhpcy5fdHkgPSAwO1xuICAgICAgaWYgKCFfZG9udE5vdGlmeSkgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHJlY3Vyc2l2ZWx5LCBfc2V0QXBwbHlNYXRyaXgpIHtcbiAgICAgIHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgb3duZXIudHJhbnNmb3JtKG51bGwsIEJhc2UucGljayhyZWN1cnNpdmVseSwgdHJ1ZSksIF9zZXRBcHBseU1hdHJpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgeCA9IHBvaW50LngsXG4gICAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgICB0aGlzLl90eCArPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9jO1xuICAgICAgdGhpcy5fdHkgKz0geCAqIHRoaXMuX2IgKyB5ICogdGhpcy5fZDtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBzY2FsZSA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZChhcmdzLCAwLCB7XG4gICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChjZW50ZXIpIHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG4gICAgICB0aGlzLl9hICo9IHNjYWxlLng7XG4gICAgICB0aGlzLl9iICo9IHNjYWxlLng7XG4gICAgICB0aGlzLl9jICo9IHNjYWxlLnk7XG4gICAgICB0aGlzLl9kICo9IHNjYWxlLnk7XG4gICAgICBpZiAoY2VudGVyKSB0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcm90YXRlOiBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgIGFuZ2xlICo9IE1hdGguUEkgLyAxODA7XG4gICAgICB2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgIHggPSBjZW50ZXIueCxcbiAgICAgICAgICB5ID0gY2VudGVyLnksXG4gICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICB0eCA9IHggLSB4ICogY29zICsgeSAqIHNpbixcbiAgICAgICAgICB0eSA9IHkgLSB4ICogc2luIC0geSAqIGNvcyxcbiAgICAgICAgICBhID0gdGhpcy5fYSxcbiAgICAgICAgICBiID0gdGhpcy5fYixcbiAgICAgICAgICBjID0gdGhpcy5fYyxcbiAgICAgICAgICBkID0gdGhpcy5fZDtcbiAgICAgIHRoaXMuX2EgPSBjb3MgKiBhICsgc2luICogYztcbiAgICAgIHRoaXMuX2IgPSBjb3MgKiBiICsgc2luICogZDtcbiAgICAgIHRoaXMuX2MgPSAtc2luICogYSArIGNvcyAqIGM7XG4gICAgICB0aGlzLl9kID0gLXNpbiAqIGIgKyBjb3MgKiBkO1xuICAgICAgdGhpcy5fdHggKz0gdHggKiBhICsgdHkgKiBjO1xuICAgICAgdGhpcy5fdHkgKz0gdHggKiBiICsgdHkgKiBkO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2hlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHNoZWFyID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3MsIDAsIHtcbiAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGNlbnRlcikgdGhpcy50cmFuc2xhdGUoY2VudGVyKTtcbiAgICAgIHZhciBhID0gdGhpcy5fYSxcbiAgICAgICAgICBiID0gdGhpcy5fYjtcbiAgICAgIHRoaXMuX2EgKz0gc2hlYXIueSAqIHRoaXMuX2M7XG4gICAgICB0aGlzLl9iICs9IHNoZWFyLnkgKiB0aGlzLl9kO1xuICAgICAgdGhpcy5fYyArPSBzaGVhci54ICogYTtcbiAgICAgIHRoaXMuX2QgKz0gc2hlYXIueCAqIGI7XG4gICAgICBpZiAoY2VudGVyKSB0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2tldzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc2tldyA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZChhcmdzLCAwLCB7XG4gICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICB9KSxcbiAgICAgICAgICB0b1JhZGlhbnMgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgICAgIHNoZWFyID0gbmV3IFBvaW50KE1hdGgudGFuKHNrZXcueCAqIHRvUmFkaWFucyksIE1hdGgudGFuKHNrZXcueSAqIHRvUmFkaWFucykpO1xuICAgICAgcmV0dXJuIHRoaXMuc2hlYXIoc2hlYXIsIGNlbnRlcik7XG4gICAgfSxcbiAgICBhcHBlbmQ6IGZ1bmN0aW9uIChteCwgX2RvbnROb3RpZnkpIHtcbiAgICAgIGlmIChteCkge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLl9hLFxuICAgICAgICAgICAgYjEgPSB0aGlzLl9iLFxuICAgICAgICAgICAgYzEgPSB0aGlzLl9jLFxuICAgICAgICAgICAgZDEgPSB0aGlzLl9kLFxuICAgICAgICAgICAgYTIgPSBteC5fYSxcbiAgICAgICAgICAgIGIyID0gbXguX2MsXG4gICAgICAgICAgICBjMiA9IG14Ll9iLFxuICAgICAgICAgICAgZDIgPSBteC5fZCxcbiAgICAgICAgICAgIHR4MiA9IG14Ll90eCxcbiAgICAgICAgICAgIHR5MiA9IG14Ll90eTtcbiAgICAgICAgdGhpcy5fYSA9IGEyICogYTEgKyBjMiAqIGMxO1xuICAgICAgICB0aGlzLl9jID0gYjIgKiBhMSArIGQyICogYzE7XG4gICAgICAgIHRoaXMuX2IgPSBhMiAqIGIxICsgYzIgKiBkMTtcbiAgICAgICAgdGhpcy5fZCA9IGIyICogYjEgKyBkMiAqIGQxO1xuICAgICAgICB0aGlzLl90eCArPSB0eDIgKiBhMSArIHR5MiAqIGMxO1xuICAgICAgICB0aGlzLl90eSArPSB0eDIgKiBiMSArIHR5MiAqIGQxO1xuICAgICAgICBpZiAoIV9kb250Tm90aWZ5KSB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcHJlcGVuZDogZnVuY3Rpb24gKG14LCBfZG9udE5vdGlmeSkge1xuICAgICAgaWYgKG14KSB7XG4gICAgICAgIHZhciBhMSA9IHRoaXMuX2EsXG4gICAgICAgICAgICBiMSA9IHRoaXMuX2IsXG4gICAgICAgICAgICBjMSA9IHRoaXMuX2MsXG4gICAgICAgICAgICBkMSA9IHRoaXMuX2QsXG4gICAgICAgICAgICB0eDEgPSB0aGlzLl90eCxcbiAgICAgICAgICAgIHR5MSA9IHRoaXMuX3R5LFxuICAgICAgICAgICAgYTIgPSBteC5fYSxcbiAgICAgICAgICAgIGIyID0gbXguX2MsXG4gICAgICAgICAgICBjMiA9IG14Ll9iLFxuICAgICAgICAgICAgZDIgPSBteC5fZCxcbiAgICAgICAgICAgIHR4MiA9IG14Ll90eCxcbiAgICAgICAgICAgIHR5MiA9IG14Ll90eTtcbiAgICAgICAgdGhpcy5fYSA9IGEyICogYTEgKyBiMiAqIGIxO1xuICAgICAgICB0aGlzLl9jID0gYTIgKiBjMSArIGIyICogZDE7XG4gICAgICAgIHRoaXMuX2IgPSBjMiAqIGExICsgZDIgKiBiMTtcbiAgICAgICAgdGhpcy5fZCA9IGMyICogYzEgKyBkMiAqIGQxO1xuICAgICAgICB0aGlzLl90eCA9IGEyICogdHgxICsgYjIgKiB0eTEgKyB0eDI7XG4gICAgICAgIHRoaXMuX3R5ID0gYzIgKiB0eDEgKyBkMiAqIHR5MSArIHR5MjtcbiAgICAgICAgaWYgKCFfZG9udE5vdGlmeSkgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFwcGVuZGVkOiBmdW5jdGlvbiAobXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuYXBwZW5kKG14KTtcbiAgICB9LFxuICAgIHByZXBlbmRlZDogZnVuY3Rpb24gKG14KSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnByZXBlbmQobXgpO1xuICAgIH0sXG4gICAgaW52ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuX2EsXG4gICAgICAgICAgYiA9IHRoaXMuX2IsXG4gICAgICAgICAgYyA9IHRoaXMuX2MsXG4gICAgICAgICAgZCA9IHRoaXMuX2QsXG4gICAgICAgICAgdHggPSB0aGlzLl90eCxcbiAgICAgICAgICB0eSA9IHRoaXMuX3R5LFxuICAgICAgICAgIGRldCA9IGEgKiBkIC0gYiAqIGMsXG4gICAgICAgICAgcmVzID0gbnVsbDtcblxuICAgICAgaWYgKGRldCAmJiAhaXNOYU4oZGV0KSAmJiBpc0Zpbml0ZSh0eCkgJiYgaXNGaW5pdGUodHkpKSB7XG4gICAgICAgIHRoaXMuX2EgPSBkIC8gZGV0O1xuICAgICAgICB0aGlzLl9iID0gLWIgLyBkZXQ7XG4gICAgICAgIHRoaXMuX2MgPSAtYyAvIGRldDtcbiAgICAgICAgdGhpcy5fZCA9IGEgLyBkZXQ7XG4gICAgICAgIHRoaXMuX3R4ID0gKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXQ7XG4gICAgICAgIHRoaXMuX3R5ID0gKGIgKiB0eCAtIGEgKiB0eSkgLyBkZXQ7XG4gICAgICAgIHJlcyA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBpbnZlcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbnZlcnQoKTtcbiAgICB9LFxuICAgIGNvbmNhdGVuYXRlOiAnI2FwcGVuZCcsXG4gICAgcHJlQ29uY2F0ZW5hdGU6ICcjcHJlcGVuZCcsXG4gICAgY2hhaW46ICcjYXBwZW5kZWQnLFxuICAgIF9zaGlmdGxlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgTWF0cml4KHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsIDAsIDApO1xuICAgIH0sXG4gICAgX29yTnVsbElmSWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKSA/IG51bGwgOiB0aGlzO1xuICAgIH0sXG4gICAgaXNJZGVudGl0eTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2EgPT09IDEgJiYgdGhpcy5fYiA9PT0gMCAmJiB0aGlzLl9jID09PSAwICYmIHRoaXMuX2QgPT09IDEgJiYgdGhpcy5fdHggPT09IDAgJiYgdGhpcy5fdHkgPT09IDA7XG4gICAgfSxcbiAgICBpc0ludmVydGlibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZXQgPSB0aGlzLl9hICogdGhpcy5fZCAtIHRoaXMuX2MgKiB0aGlzLl9iO1xuICAgICAgcmV0dXJuIGRldCAmJiAhaXNOYU4oZGV0KSAmJiBpc0Zpbml0ZSh0aGlzLl90eCkgJiYgaXNGaW5pdGUodGhpcy5fdHkpO1xuICAgIH0sXG4gICAgaXNTaW5ndWxhcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmlzSW52ZXJ0aWJsZSgpO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoc3JjLCBkc3QsIGNvdW50KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0aGlzLl90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpIDogdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoc3JjLCBkc3QsIGNvdW50KTtcbiAgICB9LFxuICAgIF90cmFuc2Zvcm1Qb2ludDogZnVuY3Rpb24gKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuICAgICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICAgIHkgPSBwb2ludC55O1xuICAgICAgaWYgKCFkZXN0KSBkZXN0ID0gbmV3IFBvaW50KCk7XG4gICAgICByZXR1cm4gZGVzdC5fc2V0KHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2MgKyB0aGlzLl90eCwgeCAqIHRoaXMuX2IgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5LCBfZG9udE5vdGlmeSk7XG4gICAgfSxcbiAgICBfdHJhbnNmb3JtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uIChzcmMsIGRzdCwgY291bnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSAyICogY291bnQ7IGkgPCBtYXg7IGkgKz0gMikge1xuICAgICAgICB2YXIgeCA9IHNyY1tpXSxcbiAgICAgICAgICAgIHkgPSBzcmNbaSArIDFdO1xuICAgICAgICBkc3RbaV0gPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9jICsgdGhpcy5fdHg7XG4gICAgICAgIGRzdFtpICsgMV0gPSB4ICogdGhpcy5fYiArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkc3Q7XG4gICAgfSxcbiAgICBfdHJhbnNmb3JtQ29ybmVyczogZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgIHZhciB4MSA9IHJlY3QueCxcbiAgICAgICAgICB5MSA9IHJlY3QueSxcbiAgICAgICAgICB4MiA9IHgxICsgcmVjdC53aWR0aCxcbiAgICAgICAgICB5MiA9IHkxICsgcmVjdC5oZWlnaHQsXG4gICAgICAgICAgY29vcmRzID0gW3gxLCB5MSwgeDIsIHkxLCB4MiwgeTIsIHgxLCB5Ml07XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIDQpO1xuICAgIH0sXG4gICAgX3RyYW5zZm9ybUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgZGVzdCwgX2RvbnROb3RpZnkpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLl90cmFuc2Zvcm1Db3JuZXJzKGJvdW5kcyksXG4gICAgICAgICAgbWluID0gY29vcmRzLnNsaWNlKDAsIDIpLFxuICAgICAgICAgIG1heCA9IG1pbi5zbGljZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IDg7IGkrKykge1xuICAgICAgICB2YXIgdmFsID0gY29vcmRzW2ldLFxuICAgICAgICAgICAgaiA9IGkgJiAxO1xuXG4gICAgICAgIGlmICh2YWwgPCBtaW5bal0pIHtcbiAgICAgICAgICBtaW5bal0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsID4gbWF4W2pdKSB7XG4gICAgICAgICAgbWF4W2pdID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZGVzdCkgZGVzdCA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICAgIHJldHVybiBkZXN0Ll9zZXQobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdLCBfZG9udE5vdGlmeSk7XG4gICAgfSxcbiAgICBpbnZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgX2ludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgZGVzdCwgX2RvbnROb3RpZnkpIHtcbiAgICAgIHZhciBhID0gdGhpcy5fYSxcbiAgICAgICAgICBiID0gdGhpcy5fYixcbiAgICAgICAgICBjID0gdGhpcy5fYyxcbiAgICAgICAgICBkID0gdGhpcy5fZCxcbiAgICAgICAgICB0eCA9IHRoaXMuX3R4LFxuICAgICAgICAgIHR5ID0gdGhpcy5fdHksXG4gICAgICAgICAgZGV0ID0gYSAqIGQgLSBiICogYyxcbiAgICAgICAgICByZXMgPSBudWxsO1xuXG4gICAgICBpZiAoZGV0ICYmICFpc05hTihkZXQpICYmIGlzRmluaXRlKHR4KSAmJiBpc0Zpbml0ZSh0eSkpIHtcbiAgICAgICAgdmFyIHggPSBwb2ludC54IC0gdGhpcy5fdHgsXG4gICAgICAgICAgICB5ID0gcG9pbnQueSAtIHRoaXMuX3R5O1xuICAgICAgICBpZiAoIWRlc3QpIGRlc3QgPSBuZXcgUG9pbnQoKTtcbiAgICAgICAgcmVzID0gZGVzdC5fc2V0KCh4ICogZCAtIHkgKiBjKSAvIGRldCwgKHkgKiBhIC0geCAqIGIpIC8gZGV0LCBfZG9udE5vdGlmeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhID0gdGhpcy5fYSxcbiAgICAgICAgICBiID0gdGhpcy5fYixcbiAgICAgICAgICBjID0gdGhpcy5fYyxcbiAgICAgICAgICBkID0gdGhpcy5fZCxcbiAgICAgICAgICBkZXQgPSBhICogZCAtIGIgKiBjLFxuICAgICAgICAgIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICAgICAgYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgICAgICAgIGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJLFxuICAgICAgICAgIHJvdGF0ZSxcbiAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICBza2V3O1xuXG4gICAgICBpZiAoYSAhPT0gMCB8fCBiICE9PSAwKSB7XG4gICAgICAgIHZhciByID0gc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgICAgcm90YXRlID0gTWF0aC5hY29zKGEgLyByKSAqIChiID4gMCA/IDEgOiAtMSk7XG4gICAgICAgIHNjYWxlID0gW3IsIGRldCAvIHJdO1xuICAgICAgICBza2V3ID0gW2F0YW4yKGEgKiBjICsgYiAqIGQsIHIgKiByKSwgMF07XG4gICAgICB9IGVsc2UgaWYgKGMgIT09IDAgfHwgZCAhPT0gMCkge1xuICAgICAgICB2YXIgcyA9IHNxcnQoYyAqIGMgKyBkICogZCk7XG4gICAgICAgIHJvdGF0ZSA9IE1hdGguYXNpbihjIC8gcykgKiAoZCA+IDAgPyAxIDogLTEpO1xuICAgICAgICBzY2FsZSA9IFtkZXQgLyBzLCBzXTtcbiAgICAgICAgc2tldyA9IFswLCBhdGFuMihhICogYyArIGIgKiBkLCBzICogcyldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm90YXRlID0gMDtcbiAgICAgICAgc2tldyA9IHNjYWxlID0gWzAsIDBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy5nZXRUcmFuc2xhdGlvbigpLFxuICAgICAgICByb3RhdGlvbjogcm90YXRlICogZGVncmVlcyxcbiAgICAgICAgc2NhbGluZzogbmV3IFBvaW50KHNjYWxlKSxcbiAgICAgICAgc2tld2luZzogbmV3IFBvaW50KHNrZXdbMF0gKiBkZWdyZWVzLCBza2V3WzFdICogZGVncmVlcylcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbdGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYywgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5XTtcbiAgICB9LFxuICAgIGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuX3R4LCB0aGlzLl90eSk7XG4gICAgfSxcbiAgICBnZXRTY2FsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvbXBvc2UoKS5zY2FsaW5nO1xuICAgIH0sXG4gICAgZ2V0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY29tcG9zZSgpLnJvdGF0aW9uO1xuICAgIH0sXG4gICAgYXBwbHlUb0NvbnRleHQ6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIGlmICghdGhpcy5pc0lkZW50aXR5KCkpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSh0aGlzLl9hLCB0aGlzLl9iLCB0aGlzLl9jLCB0aGlzLl9kLCB0aGlzLl90eCwgdGhpcy5fdHkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgQmFzZS5lYWNoKFsnYScsICdiJywgJ2MnLCAnZCcsICd0eCcsICd0eSddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcbiAgICAgICAgcHJvcCA9ICdfJyArIGtleTtcblxuICAgIHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzW3Byb3BdO1xuICAgIH07XG5cbiAgICB0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXNbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH07XG4gIH0sIHt9KSk7XG4gIHZhciBMaW5lID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0xpbmUnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIExpbmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgdmFyIGFzVmVjdG9yID0gZmFsc2U7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcbiAgICAgICAgdGhpcy5fcHggPSBhcmcwO1xuICAgICAgICB0aGlzLl9weSA9IGFyZzE7XG4gICAgICAgIHRoaXMuX3Z4ID0gYXJnMjtcbiAgICAgICAgdGhpcy5fdnkgPSBhcmczO1xuICAgICAgICBhc1ZlY3RvciA9IGFyZzQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9weCA9IGFyZzAueDtcbiAgICAgICAgdGhpcy5fcHkgPSBhcmcwLnk7XG4gICAgICAgIHRoaXMuX3Z4ID0gYXJnMS54O1xuICAgICAgICB0aGlzLl92eSA9IGFyZzEueTtcbiAgICAgICAgYXNWZWN0b3IgPSBhcmcyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFzVmVjdG9yKSB7XG4gICAgICAgIHRoaXMuX3Z4IC09IHRoaXMuX3B4O1xuICAgICAgICB0aGlzLl92eSAtPSB0aGlzLl9weTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuX3B4LCB0aGlzLl9weSk7XG4gICAgfSxcbiAgICBnZXRWZWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5fdngsIHRoaXMuX3Z5KTtcbiAgICB9LFxuICAgIGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmVjdG9yKCkuZ2V0TGVuZ3RoKCk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChsaW5lLCBpc0luZmluaXRlKSB7XG4gICAgICByZXR1cm4gTGluZS5pbnRlcnNlY3QodGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksIGxpbmUuX3B4LCBsaW5lLl9weSwgbGluZS5fdngsIGxpbmUuX3Z5LCB0cnVlLCBpc0luZmluaXRlKTtcbiAgICB9LFxuICAgIGdldFNpZGU6IGZ1bmN0aW9uIChwb2ludCwgaXNJbmZpbml0ZSkge1xuICAgICAgcmV0dXJuIExpbmUuZ2V0U2lkZSh0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSwgcG9pbnQueCwgcG9pbnQueSwgdHJ1ZSwgaXNJbmZpbml0ZSk7XG4gICAgfSxcbiAgICBnZXREaXN0YW5jZTogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5nZXRTaWduZWREaXN0YW5jZShwb2ludCkpO1xuICAgIH0sXG4gICAgZ2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UodGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksIHBvaW50LngsIHBvaW50LnksIHRydWUpO1xuICAgIH0sXG4gICAgaXNDb2xsaW5lYXI6IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICByZXR1cm4gUG9pbnQuaXNDb2xsaW5lYXIodGhpcy5fdngsIHRoaXMuX3Z5LCBsaW5lLl92eCwgbGluZS5fdnkpO1xuICAgIH0sXG4gICAgaXNPcnRob2dvbmFsOiBmdW5jdGlvbiAobGluZSkge1xuICAgICAgcmV0dXJuIFBvaW50LmlzT3J0aG9nb25hbCh0aGlzLl92eCwgdGhpcy5fdnksIGxpbmUuX3Z4LCBsaW5lLl92eSk7XG4gICAgfSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChwMXgsIHAxeSwgdjF4LCB2MXksIHAyeCwgcDJ5LCB2MngsIHYyeSwgYXNWZWN0b3IsIGlzSW5maW5pdGUpIHtcbiAgICAgICAgaWYgKCFhc1ZlY3Rvcikge1xuICAgICAgICAgIHYxeCAtPSBwMXg7XG4gICAgICAgICAgdjF5IC09IHAxeTtcbiAgICAgICAgICB2MnggLT0gcDJ4O1xuICAgICAgICAgIHYyeSAtPSBwMnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3Jvc3MgPSB2MXggKiB2MnkgLSB2MXkgKiB2Mng7XG5cbiAgICAgICAgaWYgKCFOdW1lcmljYWwuaXNNYWNoaW5lWmVybyhjcm9zcykpIHtcbiAgICAgICAgICB2YXIgZHggPSBwMXggLSBwMngsXG4gICAgICAgICAgICAgIGR5ID0gcDF5IC0gcDJ5LFxuICAgICAgICAgICAgICB1MSA9ICh2MnggKiBkeSAtIHYyeSAqIGR4KSAvIGNyb3NzLFxuICAgICAgICAgICAgICB1MiA9ICh2MXggKiBkeSAtIHYxeSAqIGR4KSAvIGNyb3NzLFxuICAgICAgICAgICAgICBlcHNpbG9uID0gMWUtMTIsXG4gICAgICAgICAgICAgIHVNaW4gPSAtZXBzaWxvbixcbiAgICAgICAgICAgICAgdU1heCA9IDEgKyBlcHNpbG9uO1xuXG4gICAgICAgICAgaWYgKGlzSW5maW5pdGUgfHwgdU1pbiA8IHUxICYmIHUxIDwgdU1heCAmJiB1TWluIDwgdTIgJiYgdTIgPCB1TWF4KSB7XG4gICAgICAgICAgICBpZiAoIWlzSW5maW5pdGUpIHtcbiAgICAgICAgICAgICAgdTEgPSB1MSA8PSAwID8gMCA6IHUxID49IDEgPyAxIDogdTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocDF4ICsgdTEgKiB2MXgsIHAxeSArIHUxICogdjF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRTaWRlOiBmdW5jdGlvbiAocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yLCBpc0luZmluaXRlKSB7XG4gICAgICAgIGlmICghYXNWZWN0b3IpIHtcbiAgICAgICAgICB2eCAtPSBweDtcbiAgICAgICAgICB2eSAtPSBweTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2MnggPSB4IC0gcHgsXG4gICAgICAgICAgICB2MnkgPSB5IC0gcHksXG4gICAgICAgICAgICBjY3cgPSB2MnggKiB2eSAtIHYyeSAqIHZ4O1xuXG4gICAgICAgIGlmICghaXNJbmZpbml0ZSAmJiBOdW1lcmljYWwuaXNNYWNoaW5lWmVybyhjY3cpKSB7XG4gICAgICAgICAgY2N3ID0gKHYyeCAqIHZ4ICsgdjJ4ICogdngpIC8gKHZ4ICogdnggKyB2eSAqIHZ5KTtcbiAgICAgICAgICBpZiAoY2N3ID49IDAgJiYgY2N3IDw9IDEpIGNjdyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2N3IDwgMCA/IC0xIDogY2N3ID4gMCA/IDEgOiAwO1xuICAgICAgfSxcbiAgICAgIGdldFNpZ25lZERpc3RhbmNlOiBmdW5jdGlvbiAocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSB7XG4gICAgICAgIGlmICghYXNWZWN0b3IpIHtcbiAgICAgICAgICB2eCAtPSBweDtcbiAgICAgICAgICB2eSAtPSBweTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2eCA9PT0gMCA/IHZ5ID4gMCA/IHggLSBweCA6IHB4IC0geCA6IHZ5ID09PSAwID8gdnggPCAwID8geSAtIHB5IDogcHkgLSB5IDogKCh4IC0gcHgpICogdnkgLSAoeSAtIHB5KSAqIHZ4KSAvICh2eSA+IHZ4ID8gdnkgKiBNYXRoLnNxcnQoMSArIHZ4ICogdnggLyAodnkgKiB2eSkpIDogdnggKiBNYXRoLnNxcnQoMSArIHZ5ICogdnkgLyAodnggKiB2eCkpKTtcbiAgICAgIH0sXG4gICAgICBnZXREaXN0YW5jZTogZnVuY3Rpb24gKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoTGluZS5nZXRTaWduZWREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgUHJvamVjdCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUHJvamVjdCcsXG4gICAgX2xpc3Q6ICdwcm9qZWN0cycsXG4gICAgX3JlZmVyZW5jZTogJ3Byb2plY3QnLFxuICAgIF9jb21wYWN0U2VyaWFsaXplOiB0cnVlLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFByb2plY3QoZWxlbWVudCkge1xuICAgICAgUGFwZXJTY29wZUl0ZW0uY2FsbCh0aGlzLCB0cnVlKTtcbiAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICB0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG4gICAgICB0aGlzLl9hY3RpdmVMYXllciA9IG51bGw7XG4gICAgICB0aGlzLl9jdXJyZW50U3R5bGUgPSBuZXcgU3R5bGUobnVsbCwgbnVsbCwgdGhpcyk7XG4gICAgICB0aGlzLl92aWV3ID0gVmlldy5jcmVhdGUodGhpcywgZWxlbWVudCB8fCBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoMSwgMSkpO1xuICAgICAgdGhpcy5fc2VsZWN0aW9uSXRlbXMgPSB7fTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkNvdW50ID0gMDtcbiAgICAgIHRoaXMuX3VwZGF0ZVZlcnNpb24gPSAwO1xuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcbiAgICAgIHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLl9jaGlsZHJlbiwgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gKGZsYWdzLCBpdGVtKSB7XG4gICAgICBpZiAoZmxhZ3MgJiAxKSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fdmlldztcblxuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgIHZpZXcuX25lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXZpZXcuX3JlcXVlc3RlZCAmJiB2aWV3Ll9hdXRvVXBkYXRlKSB2aWV3LnJlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZXM7XG5cbiAgICAgIGlmIChjaGFuZ2VzICYmIGl0ZW0pIHtcbiAgICAgICAgdmFyIGNoYW5nZXNCeUlkID0gdGhpcy5fY2hhbmdlc0J5SWQsXG4gICAgICAgICAgICBpZCA9IGl0ZW0uX2lkLFxuICAgICAgICAgICAgZW50cnkgPSBjaGFuZ2VzQnlJZFtpZF07XG5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkuZmxhZ3MgfD0gZmxhZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZXNCeUlkW2lkXSA9IHtcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBmbGFnczogZmxhZ3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGNoaWxkcmVuW2ldLnJlbW92ZSgpO1xuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGlmICghcmVtb3ZlLmJhc2UuY2FsbCh0aGlzKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX3ZpZXcpIHRoaXMuX3ZpZXcucmVtb3ZlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldFZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aWV3O1xuICAgIH0sXG4gICAgZ2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0eWxlO1xuICAgIH0sXG4gICAgc2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRTdHlsZS5zZXQoc3R5bGUpO1xuICAgIH0sXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9LFxuICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY29wZS5zZXR0aW5ncztcbiAgICB9LFxuICAgIGdldExheWVyczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICAgIH0sXG4gICAgZ2V0QWN0aXZlTGF5ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVMYXllciB8fCBuZXcgTGF5ZXIoe1xuICAgICAgICBwcm9qZWN0OiB0aGlzLFxuICAgICAgICBpbnNlcnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0U3ltYm9sRGVmaW5pdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZWZpbml0aW9ucyA9IFtdLFxuICAgICAgICAgIGlkcyA9IHt9O1xuICAgICAgdGhpcy5nZXRJdGVtcyh7XG4gICAgICAgIGNsYXNzOiBTeW1ib2xJdGVtLFxuICAgICAgICBtYXRjaDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IGl0ZW0uX2RlZmluaXRpb24sXG4gICAgICAgICAgICAgIGlkID0gZGVmaW5pdGlvbi5faWQ7XG5cbiAgICAgICAgICBpZiAoIWlkc1tpZF0pIHtcbiAgICAgICAgICAgIGlkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgZGVmaW5pdGlvbnMucHVzaChkZWZpbml0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRlZmluaXRpb25zO1xuICAgIH0sXG4gICAgZ2V0U3ltYm9sczogJ2dldFN5bWJvbERlZmluaXRpb25zJyxcbiAgICBnZXRTZWxlY3RlZEl0ZW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uSXRlbXMgPSB0aGlzLl9zZWxlY3Rpb25JdGVtcyxcbiAgICAgICAgICBpdGVtcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpZCBpbiBzZWxlY3Rpb25JdGVtcykge1xuICAgICAgICB2YXIgaXRlbSA9IHNlbGVjdGlvbkl0ZW1zW2lkXSxcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IGl0ZW0uX3NlbGVjdGlvbjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uICYgMSAmJiBpdGVtLmlzSW5zZXJ0ZWQoKSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcbiAgICBfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGlkID0gaXRlbS5faWQsXG4gICAgICAgICAgc2VsZWN0aW9uSXRlbXMgPSB0aGlzLl9zZWxlY3Rpb25JdGVtcztcblxuICAgICAgaWYgKGl0ZW0uX3NlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uSXRlbXNbaWRdICE9PSBpdGVtKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQ291bnQrKztcbiAgICAgICAgICBzZWxlY3Rpb25JdGVtc1tpZF0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbkl0ZW1zW2lkXSA9PT0gaXRlbSkge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb25Db3VudC0tO1xuICAgICAgICBkZWxldGUgc2VsZWN0aW9uSXRlbXNbaWRdO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGNoaWxkcmVuW2ldLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG4gICAgfSxcbiAgICBkZXNlbGVjdEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGVjdGlvbkl0ZW1zID0gdGhpcy5fc2VsZWN0aW9uSXRlbXM7XG5cbiAgICAgIGZvciAodmFyIGkgaW4gc2VsZWN0aW9uSXRlbXMpIHNlbGVjdGlvbkl0ZW1zW2ldLnNldEZ1bGx5U2VsZWN0ZWQoZmFsc2UpO1xuICAgIH0sXG4gICAgYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0TGF5ZXIodW5kZWZpbmVkLCBsYXllcik7XG4gICAgfSxcbiAgICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKGluZGV4LCBsYXllcikge1xuICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX3JlbW92ZShmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgQmFzZS5zcGxpY2UodGhpcy5fY2hpbGRyZW4sIFtsYXllcl0sIGluZGV4LCAwKTtcblxuICAgICAgICBsYXllci5fc2V0UHJvamVjdCh0aGlzLCB0cnVlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IGxheWVyLl9uYW1lO1xuICAgICAgICBpZiAobmFtZSkgbGF5ZXIuc2V0TmFtZShuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZXMpIGxheWVyLl9jaGFuZ2VkKDUpO1xuICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZUxheWVyKSB0aGlzLl9hY3RpdmVMYXllciA9IGxheWVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfSxcbiAgICBfaW5zZXJ0SXRlbTogZnVuY3Rpb24gKGluZGV4LCBpdGVtLCBfY3JlYXRlZCkge1xuICAgICAgaXRlbSA9IHRoaXMuaW5zZXJ0TGF5ZXIoaW5kZXgsIGl0ZW0pIHx8ICh0aGlzLl9hY3RpdmVMYXllciB8fCB0aGlzLl9pbnNlcnRJdGVtKHVuZGVmaW5lZCwgbmV3IExheWVyKEl0ZW0uTk9fSU5TRVJUKSwgdHJ1ZSkpLmluc2VydENoaWxkKGluZGV4LCBpdGVtKTtcbiAgICAgIGlmIChfY3JlYXRlZCAmJiBpdGVtLmFjdGl2YXRlKSBpdGVtLmFjdGl2YXRlKCk7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9LFxuICAgIGdldEl0ZW1zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZ2V0SXRlbTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLCBvcHRpb25zLCBudWxsLCBudWxsLCB0cnVlKVswXSB8fCBudWxsO1xuICAgIH0sXG4gICAgaW1wb3J0SlNPTjogZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuX2FjdGl2ZUxheWVyO1xuICAgICAgcmV0dXJuIEJhc2UuaW1wb3J0SlNPTihqc29uLCBsYXllciAmJiBsYXllci5pc0VtcHR5KCkgJiYgbGF5ZXIpO1xuICAgIH0sXG4gICAgcmVtb3ZlT246IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgc2V0cyA9IHRoaXMuX3JlbW92ZVNldHM7XG5cbiAgICAgIGlmIChzZXRzKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnbW91c2V1cCcpIHNldHMubW91c2VkcmFnID0gbnVsbDtcbiAgICAgICAgdmFyIHNldCA9IHNldHNbdHlwZV07XG5cbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgIGZvciAodmFyIGlkIGluIHNldCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBzZXRbaWRdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2V0cykge1xuICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBzZXRzW2tleV07XG4gICAgICAgICAgICAgIGlmIChvdGhlciAmJiBvdGhlciAhPSBzZXQpIGRlbGV0ZSBvdGhlcltpdGVtLl9pZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0c1t0eXBlXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIChjdHgsIG1hdHJpeCwgcGl4ZWxSYXRpbykge1xuICAgICAgdGhpcy5fdXBkYXRlVmVyc2lvbisrO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgcGFyYW0gPSBuZXcgQmFzZSh7XG4gICAgICAgIG9mZnNldDogbmV3IFBvaW50KDAsIDApLFxuICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuICAgICAgICB2aWV3TWF0cml4OiBtYXRyaXguaXNJZGVudGl0eSgpID8gbnVsbCA6IG1hdHJpeCxcbiAgICAgICAgbWF0cmljZXM6IFtuZXcgTWF0cml4KCldLFxuICAgICAgICB1cGRhdGVNYXRyaXg6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjaGlsZHJlbltpXS5kcmF3KGN0eCwgcGFyYW0pO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICBpZiAodGhpcy5fc2VsZWN0aW9uQ291bnQgPiAwKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zdHJva2VXaWR0aCA9IDE7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuX3NlbGVjdGlvbkl0ZW1zLFxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuX3Njb3BlLnNldHRpbmdzLmhhbmRsZVNpemUsXG4gICAgICAgICAgICB2ZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbjtcblxuICAgICAgICBmb3IgKHZhciBpZCBpbiBpdGVtcykge1xuICAgICAgICAgIGl0ZW1zW2lkXS5fZHJhd1NlbGVjdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgaXRlbXMsIHZlcnNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgSXRlbSA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcbiAgICBzdGF0aWNzOiB7XG4gICAgICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChzcmMpIHtcbiAgICAgICAgaWYgKHNyYy5fc2VyaWFsaXplRmllbGRzKSBzcmMuX3NlcmlhbGl6ZUZpZWxkcyA9IEJhc2Uuc2V0KHt9LCB0aGlzLnByb3RvdHlwZS5fc2VyaWFsaXplRmllbGRzLCBzcmMuX3NlcmlhbGl6ZUZpZWxkcyk7XG4gICAgICAgIHJldHVybiBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSxcbiAgICAgIE5PX0lOU0VSVDoge1xuICAgICAgICBpbnNlcnQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBfY2xhc3M6ICdJdGVtJyxcbiAgICBfbmFtZTogbnVsbCxcbiAgICBfYXBwbHlNYXRyaXg6IHRydWUsXG4gICAgX2NhbkFwcGx5TWF0cml4OiB0cnVlLFxuICAgIF9jYW5TY2FsZVN0cm9rZTogZmFsc2UsXG4gICAgX3Bpdm90OiBudWxsLFxuICAgIF92aXNpYmxlOiB0cnVlLFxuICAgIF9ibGVuZE1vZGU6ICdub3JtYWwnLFxuICAgIF9vcGFjaXR5OiAxLFxuICAgIF9sb2NrZWQ6IGZhbHNlLFxuICAgIF9ndWlkZTogZmFsc2UsXG4gICAgX2NsaXBNYXNrOiBmYWxzZSxcbiAgICBfc2VsZWN0aW9uOiAwLFxuICAgIF9zZWxlY3RCb3VuZHM6IHRydWUsXG4gICAgX3NlbGVjdENoaWxkcmVuOiBmYWxzZSxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICBuYW1lOiBudWxsLFxuICAgICAgYXBwbHlNYXRyaXg6IG51bGwsXG4gICAgICBtYXRyaXg6IG5ldyBNYXRyaXgoKSxcbiAgICAgIHBpdm90OiBudWxsLFxuICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgIGJsZW5kTW9kZTogJ25vcm1hbCcsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgbG9ja2VkOiBmYWxzZSxcbiAgICAgIGd1aWRlOiBmYWxzZSxcbiAgICAgIGNsaXBNYXNrOiBmYWxzZSxcbiAgICAgIHNlbGVjdGVkOiBmYWxzZSxcbiAgICAgIGRhdGE6IHt9XG4gICAgfSxcbiAgICBfcHJpb3JpdGl6ZTogWydhcHBseU1hdHJpeCddXG4gIH0sIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gWydvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25DbGljaycsICdvbkRvdWJsZUNsaWNrJywgJ29uTW91c2VNb3ZlJywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnXTtcbiAgICByZXR1cm4gQmFzZS5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdGhpcy5fZXZlbnRzW25hbWVdID0ge1xuICAgICAgICBpbnN0YWxsOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHRoaXMuZ2V0VmlldygpLl9jb3VudEl0ZW1FdmVudCh0eXBlLCAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHRoaXMuZ2V0VmlldygpLl9jb3VudEl0ZW1FdmVudCh0eXBlLCAtMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwge1xuICAgICAgX2V2ZW50czoge1xuICAgICAgICBvbkZyYW1lOiB7XG4gICAgICAgICAgaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5nZXRWaWV3KCkuX2FuaW1hdGVJdGVtKHRoaXMsIHRydWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmdldFZpZXcoKS5fYW5pbWF0ZUl0ZW0odGhpcywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Mb2FkOiB7fSxcbiAgICAgICAgb25FcnJvcjoge31cbiAgICAgIH0sXG4gICAgICBzdGF0aWNzOiB7XG4gICAgICAgIF9pdGVtSGFuZGxlcnM6IGhhbmRsZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH0oKSwge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEl0ZW0oKSB7fSxcbiAgICBfaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHByb3BzLCBwb2ludCkge1xuICAgICAgdmFyIGhhc1Byb3BzID0gcHJvcHMgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHByb3BzKSxcbiAgICAgICAgICBpbnRlcm5hbCA9IGhhc1Byb3BzICYmIHByb3BzLmludGVybmFsID09PSB0cnVlLFxuICAgICAgICAgIG1hdHJpeCA9IHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSxcbiAgICAgICAgICBwcm9qZWN0ID0gaGFzUHJvcHMgJiYgcHJvcHMucHJvamVjdCB8fCBwYXBlci5wcm9qZWN0LFxuICAgICAgICAgIHNldHRpbmdzID0gcGFwZXIuc2V0dGluZ3M7XG4gICAgICB0aGlzLl9pZCA9IGludGVybmFsID8gbnVsbCA6IFVJRC5nZXQoKTtcbiAgICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX2luZGV4ID0gbnVsbDtcbiAgICAgIHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgc2V0dGluZ3MuYXBwbHlNYXRyaXg7XG4gICAgICBpZiAocG9pbnQpIG1hdHJpeC50cmFuc2xhdGUocG9pbnQpO1xuICAgICAgbWF0cml4Ll9vd25lciA9IHRoaXM7XG4gICAgICB0aGlzLl9zdHlsZSA9IG5ldyBTdHlsZShwcm9qZWN0Ll9jdXJyZW50U3R5bGUsIHRoaXMsIHByb2plY3QpO1xuXG4gICAgICBpZiAoaW50ZXJuYWwgfHwgaGFzUHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09IGZhbHNlIHx8ICFzZXR0aW5ncy5pbnNlcnRJdGVtcyAmJiAhKGhhc1Byb3BzICYmIHByb3BzLmluc2VydCA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvamVjdChwcm9qZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChoYXNQcm9wcyAmJiBwcm9wcy5wYXJlbnQgfHwgcHJvamVjdCkuX2luc2VydEl0ZW0odW5kZWZpbmVkLCB0aGlzLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1Byb3BzICYmIHByb3BzICE9PSBJdGVtLk5PX0lOU0VSVCkge1xuICAgICAgICB0aGlzLnNldChwcm9wcywge1xuICAgICAgICAgIGludGVybmFsOiB0cnVlLFxuICAgICAgICAgIGluc2VydDogdHJ1ZSxcbiAgICAgICAgICBwcm9qZWN0OiB0cnVlLFxuICAgICAgICAgIHBhcmVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc1Byb3BzO1xuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcbiAgICAgIHZhciBwcm9wcyA9IHt9LFxuICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBzZXJpYWxpemUoZmllbGRzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBmaWVsZHMpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGF0W2tleV07XG5cbiAgICAgICAgICBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBrZXkgPT09ICdsZWFkaW5nJyA/IGZpZWxkcy5mb250U2l6ZSAqIDEuMiA6IGZpZWxkc1trZXldKSkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IEJhc2Uuc2VyaWFsaXplKHZhbHVlLCBvcHRpb25zLCBrZXkgIT09ICdkYXRhJywgZGljdGlvbmFyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlcmlhbGl6ZSh0aGlzLl9zZXJpYWxpemVGaWVsZHMpO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdyb3VwKSkgc2VyaWFsaXplKHRoaXMuX3N0eWxlLl9kZWZhdWx0cyk7XG4gICAgICByZXR1cm4gW3RoaXMuX2NsYXNzLCBwcm9wc107XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gKGZsYWdzKSB7XG4gICAgICB2YXIgc3ltYm9sID0gdGhpcy5fc3ltYm9sLFxuICAgICAgICAgIGNhY2hlUGFyZW50ID0gdGhpcy5fcGFyZW50IHx8IHN5bWJvbCxcbiAgICAgICAgICBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblxuICAgICAgaWYgKGZsYWdzICYgOCkge1xuICAgICAgICB0aGlzLl9ib3VuZHMgPSB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGFncyAmIDE2KSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbE1hdHJpeCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhY2hlUGFyZW50ICYmIGZsYWdzICYgNzIpIHtcbiAgICAgICAgSXRlbS5fY2xlYXJCb3VuZHNDYWNoZShjYWNoZVBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgSXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2plY3QpIHByb2plY3QuX2NoYW5nZWQoZmxhZ3MsIHRoaXMpO1xuICAgICAgaWYgKHN5bWJvbCkgc3ltYm9sLl9jaGFuZ2VkKGZsYWdzKTtcbiAgICB9LFxuICAgIGdldElkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfSxcbiAgICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9LFxuICAgIHNldE5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAodGhpcy5fbmFtZSkgdGhpcy5fcmVtb3ZlTmFtZWQoKTtcbiAgICAgIGlmIChuYW1lID09PSArbmFtZSArICcnKSB0aHJvdyBuZXcgRXJyb3IoJ05hbWVzIGNvbnNpc3Rpbmcgb25seSBvZiBudW1iZXJzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuXG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXG4gICAgICBpZiAobmFtZSAmJiBvd25lcikge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBvd25lci5fY2hpbGRyZW4sXG4gICAgICAgICAgICBuYW1lZENoaWxkcmVuID0gb3duZXIuX25hbWVkQ2hpbGRyZW47XG4gICAgICAgIChuYW1lZENoaWxkcmVuW25hbWVdID0gbmFtZWRDaGlsZHJlbltuYW1lXSB8fCBbXSkucHVzaCh0aGlzKTtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBjaGlsZHJlbikpIGNoaWxkcmVuW25hbWVdID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbmFtZSA9IG5hbWUgfHwgdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKDI1Nik7XG4gICAgfSxcbiAgICBnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICAgIH0sXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgdGhpcy5nZXRTdHlsZSgpLnNldChzdHlsZSk7XG4gICAgfVxuICB9LCBCYXNlLmVhY2goWydsb2NrZWQnLCAndmlzaWJsZScsICdibGVuZE1vZGUnLCAnb3BhY2l0eScsICdndWlkZSddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuICAgICAgICBrZXkgPSAnXycgKyBuYW1lLFxuICAgICAgICBmbGFncyA9IHtcbiAgICAgIGxvY2tlZDogMjU2LFxuICAgICAgdmlzaWJsZTogMjY1XG4gICAgfTtcblxuICAgIHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzW2tleV07XG4gICAgfTtcblxuICAgIHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9IHRoaXNba2V5XSkge1xuICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKGZsYWdzW25hbWVdIHx8IDI1Nyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwge30pLCB7XG4gICAgYmVhbnM6IHRydWUsXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uICE9PSB0aGlzLl9zZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cbiAgICAgICAgaWYgKHByb2plY3QpIHtcbiAgICAgICAgICBwcm9qZWN0Ll91cGRhdGVTZWxlY3Rpb24odGhpcyk7XG5cbiAgICAgICAgICB0aGlzLl9jaGFuZ2VkKDI1Nyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9jaGFuZ2VTZWxlY3Rpb246IGZ1bmN0aW9uIChmbGFnLCBzZWxlY3RlZCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbjtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGVkID8gc2VsZWN0aW9uIHwgZmxhZyA6IHNlbGVjdGlvbiAmIH5mbGFnKTtcbiAgICB9LFxuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9zZWxlY3RDaGlsZHJlbikge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgaWYgKGNoaWxkcmVuW2ldLmlzU2VsZWN0ZWQoKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhISh0aGlzLl9zZWxlY3Rpb24gJiAxKTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGVkOiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIGlmICh0aGlzLl9zZWxlY3RDaGlsZHJlbikge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgY2hpbGRyZW5baV0uc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGFuZ2VTZWxlY3Rpb24oMSwgc2VsZWN0ZWQpO1xuICAgIH0sXG4gICAgaXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICBzZWxlY3RlZCA9ICEhKHRoaXMuX3NlbGVjdGlvbiAmIDEpO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gJiYgc2VsZWN0ZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGlmICghY2hpbGRyZW5baV0uaXNGdWxseVNlbGVjdGVkKCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH0sXG4gICAgc2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBjaGlsZHJlbltpXS5zZXRGdWxseVNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hhbmdlU2VsZWN0aW9uKDEsIHNlbGVjdGVkKTtcbiAgICB9LFxuICAgIGlzQ2xpcE1hc2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbGlwTWFzaztcbiAgICB9LFxuICAgIHNldENsaXBNYXNrOiBmdW5jdGlvbiAoY2xpcE1hc2spIHtcbiAgICAgIGlmICh0aGlzLl9jbGlwTWFzayAhPSAoY2xpcE1hc2sgPSAhIWNsaXBNYXNrKSkge1xuICAgICAgICB0aGlzLl9jbGlwTWFzayA9IGNsaXBNYXNrO1xuXG4gICAgICAgIGlmIChjbGlwTWFzaykge1xuICAgICAgICAgIHRoaXMuc2V0RmlsbENvbG9yKG51bGwpO1xuICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlQ29sb3IobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKDI1Nyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkgdGhpcy5fcGFyZW50Ll9jaGFuZ2VkKDIwNDgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9kYXRhKSB0aGlzLl9kYXRhID0ge307XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9LFxuICAgIHNldERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9LFxuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoX2RvbnRMaW5rKSB7XG4gICAgICB2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uIHx8ICh0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uRnJvbUJvdW5kcygpKTtcblxuICAgICAgcmV0dXJuIG5ldyBjdG9yKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHRoaXMsICdzZXRQb3NpdGlvbicpO1xuICAgIH0sXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5zdWJ0cmFjdCh0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG4gICAgfSxcbiAgICBfZ2V0UG9zaXRpb25Gcm9tQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGl2b3QgPyB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHRoaXMuX3Bpdm90KSA6IChib3VuZHMgfHwgdGhpcy5nZXRCb3VuZHMoKSkuZ2V0Q2VudGVyKHRydWUpO1xuICAgIH0sXG4gICAgZ2V0UGl2b3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuICAgICAgcmV0dXJuIHBpdm90ID8gbmV3IExpbmtlZFBvaW50KHBpdm90LngsIHBpdm90LnksIHRoaXMsICdzZXRQaXZvdCcpIDogbnVsbDtcbiAgICB9LFxuICAgIHNldFBpdm90OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9waXZvdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7XG4gICAgICAgIGNsb25lOiB0cnVlLFxuICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIEJhc2UuZWFjaCh7XG4gICAgZ2V0U3Ryb2tlQm91bmRzOiB7XG4gICAgICBzdHJva2U6IHRydWVcbiAgICB9LFxuICAgIGdldEhhbmRsZUJvdW5kczoge1xuICAgICAgaGFuZGxlOiB0cnVlXG4gICAgfSxcbiAgICBnZXRJbnRlcm5hbEJvdW5kczoge1xuICAgICAgaW50ZXJuYWw6IHRydWVcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChvcHRpb25zLCBrZXkpIHtcbiAgICB0aGlzW2tleV0gPSBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMobWF0cml4LCBvcHRpb25zKTtcbiAgICB9O1xuICB9LCB7XG4gICAgYmVhbnM6IHRydWUsXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbiAobWF0cml4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgaGFzTWF0cml4ID0gb3B0aW9ucyB8fCBtYXRyaXggaW5zdGFuY2VvZiBNYXRyaXgsXG4gICAgICAgICAgb3B0cyA9IEJhc2Uuc2V0KHt9LCBoYXNNYXRyaXggPyBvcHRpb25zIDogbWF0cml4LCB0aGlzLl9ib3VuZHNPcHRpb25zKTtcbiAgICAgIGlmICghb3B0cy5zdHJva2UgfHwgdGhpcy5nZXRTdHJva2VTY2FsaW5nKCkpIG9wdHMuY2FjaGVJdGVtID0gdGhpcztcblxuICAgICAgdmFyIHJlY3QgPSB0aGlzLl9nZXRDYWNoZWRCb3VuZHMoaGFzTWF0cml4ICYmIG1hdHJpeCwgb3B0cykucmVjdDtcblxuICAgICAgcmV0dXJuICFhcmd1bWVudHMubGVuZ3RoID8gbmV3IExpbmtlZFJlY3RhbmdsZShyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIHRoaXMsICdzZXRCb3VuZHMnKSA6IHJlY3Q7XG4gICAgfSxcbiAgICBzZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuICAgICAgICAgIF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG4gICAgICAgICAgbWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuICAgICAgICAgIGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKCk7XG4gICAgICBtYXRyaXgudHJhbnNsYXRlKGNlbnRlcik7XG5cbiAgICAgIGlmIChyZWN0LndpZHRoICE9IGJvdW5kcy53aWR0aCB8fCByZWN0LmhlaWdodCAhPSBib3VuZHMuaGVpZ2h0KSB7XG4gICAgICAgIGlmICghX21hdHJpeC5pc0ludmVydGlibGUoKSkge1xuICAgICAgICAgIF9tYXRyaXguc2V0KF9tYXRyaXguX2JhY2t1cCB8fCBuZXcgTWF0cml4KCkudHJhbnNsYXRlKF9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKSkpO1xuXG4gICAgICAgICAgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeC5zY2FsZShib3VuZHMud2lkdGggIT09IDAgPyByZWN0LndpZHRoIC8gYm91bmRzLndpZHRoIDogMCwgYm91bmRzLmhlaWdodCAhPT0gMCA/IHJlY3QuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCA6IDApO1xuICAgICAgfVxuXG4gICAgICBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG4gICAgICBtYXRyaXgudHJhbnNsYXRlKC1jZW50ZXIueCwgLWNlbnRlci55KTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgfSxcbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbiAobWF0cml4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblxuICAgICAgSXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcywgb3B0aW9ucy5jYWNoZUl0ZW0pO1xuXG4gICAgICByZXR1cm4gSXRlbS5fZ2V0Qm91bmRzKGNoaWxkcmVuLCBtYXRyaXgsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgX2dldEJvdW5kc0NhY2hlS2V5OiBmdW5jdGlvbiAob3B0aW9ucywgaW50ZXJuYWwpIHtcbiAgICAgIHJldHVybiBbb3B0aW9ucy5zdHJva2UgPyAxIDogMCwgb3B0aW9ucy5oYW5kbGUgPyAxIDogMCwgaW50ZXJuYWwgPyAxIDogMF0uam9pbignJyk7XG4gICAgfSxcbiAgICBfZ2V0Q2FjaGVkQm91bmRzOiBmdW5jdGlvbiAobWF0cml4LCBvcHRpb25zLCBub0ludGVybmFsKSB7XG4gICAgICBtYXRyaXggPSBtYXRyaXggJiYgbWF0cml4Ll9vck51bGxJZklkZW50aXR5KCk7XG5cbiAgICAgIHZhciBpbnRlcm5hbCA9IG9wdGlvbnMuaW50ZXJuYWwgJiYgIW5vSW50ZXJuYWwsXG4gICAgICAgICAgY2FjaGVJdGVtID0gb3B0aW9ucy5jYWNoZUl0ZW0sXG4gICAgICAgICAgX21hdHJpeCA9IGludGVybmFsID8gbnVsbCA6IHRoaXMuX21hdHJpeC5fb3JOdWxsSWZJZGVudGl0eSgpLFxuICAgICAgICAgIGNhY2hlS2V5ID0gY2FjaGVJdGVtICYmICghbWF0cml4IHx8IG1hdHJpeC5lcXVhbHMoX21hdHJpeCkpICYmIHRoaXMuX2dldEJvdW5kc0NhY2hlS2V5KG9wdGlvbnMsIGludGVybmFsKSxcbiAgICAgICAgICBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cbiAgICAgIEl0ZW0uX3VwZGF0ZUJvdW5kc0NhY2hlKHRoaXMuX3BhcmVudCB8fCB0aGlzLl9zeW1ib2wsIGNhY2hlSXRlbSk7XG5cbiAgICAgIGlmIChjYWNoZUtleSAmJiBib3VuZHMgJiYgY2FjaGVLZXkgaW4gYm91bmRzKSB7XG4gICAgICAgIHZhciBjYWNoZWQgPSBib3VuZHNbY2FjaGVLZXldO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlY3Q6IGNhY2hlZC5yZWN0LmNsb25lKCksXG4gICAgICAgICAgbm9uc2NhbGluZzogY2FjaGVkLm5vbnNjYWxpbmdcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcyA9IHRoaXMuX2dldEJvdW5kcyhtYXRyaXggfHwgX21hdHJpeCwgb3B0aW9ucyksXG4gICAgICAgICAgcmVjdCA9IHJlcy5yZWN0IHx8IHJlcyxcbiAgICAgICAgICBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuICAgICAgICAgIG5vbnNjYWxpbmcgPSByZXMubm9uc2NhbGluZyB8fCBzdHlsZS5oYXNTdHJva2UoKSAmJiAhc3R5bGUuZ2V0U3Ryb2tlU2NhbGluZygpO1xuXG4gICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgICB0aGlzLl9ib3VuZHMgPSBib3VuZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWNoZWQgPSBib3VuZHNbY2FjaGVLZXldID0ge1xuICAgICAgICAgIHJlY3Q6IHJlY3QuY2xvbmUoKSxcbiAgICAgICAgICBub25zY2FsaW5nOiBub25zY2FsaW5nLFxuICAgICAgICAgIGludGVybmFsOiBpbnRlcm5hbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICBub25zY2FsaW5nOiBub25zY2FsaW5nXG4gICAgICB9O1xuICAgIH0sXG4gICAgX2dldFN0cm9rZU1hdHJpeDogZnVuY3Rpb24gKG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0U3Ryb2tlU2NhbGluZygpID8gbnVsbCA6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRlcm5hbCA/IHRoaXMgOiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5fc3ltYm9sICYmIHRoaXMuX3N5bWJvbC5faXRlbSxcbiAgICAgICAgICBteCA9IHBhcmVudCA/IHBhcmVudC5nZXRWaWV3TWF0cml4KCkuaW52ZXJ0KCkgOiBtYXRyaXg7XG4gICAgICByZXR1cm4gbXggJiYgbXguX3NoaWZ0bGVzcygpO1xuICAgIH0sXG4gICAgc3RhdGljczoge1xuICAgICAgX3VwZGF0ZUJvdW5kc0NhY2hlOiBmdW5jdGlvbiAocGFyZW50LCBpdGVtKSB7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgaXRlbSkge1xuICAgICAgICAgIHZhciBpZCA9IGl0ZW0uX2lkLFxuICAgICAgICAgICAgICByZWYgPSBwYXJlbnQuX2JvdW5kc0NhY2hlID0gcGFyZW50Ll9ib3VuZHNDYWNoZSB8fCB7XG4gICAgICAgICAgICBpZHM6IHt9LFxuICAgICAgICAgICAgbGlzdDogW11cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCFyZWYuaWRzW2lkXSkge1xuICAgICAgICAgICAgcmVmLmxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHJlZi5pZHNbaWRdID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY2xlYXJCb3VuZHNDYWNoZTogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGNhY2hlID0gaXRlbS5fYm91bmRzQ2FjaGU7XG5cbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgaXRlbS5fYm91bmRzID0gaXRlbS5fcG9zaXRpb24gPSBpdGVtLl9ib3VuZHNDYWNoZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gY2FjaGUubGlzdCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgICBpZiAob3RoZXIgIT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgb3RoZXIuX2JvdW5kcyA9IG90aGVyLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgaWYgKG90aGVyLl9ib3VuZHNDYWNoZSkgSXRlbS5fY2xlYXJCb3VuZHNDYWNoZShvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2dldEJvdW5kczogZnVuY3Rpb24gKGl0ZW1zLCBtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHgxID0gSW5maW5pdHksXG4gICAgICAgICAgICB4MiA9IC14MSxcbiAgICAgICAgICAgIHkxID0geDEsXG4gICAgICAgICAgICB5MiA9IHgyLFxuICAgICAgICAgICAgbm9uc2NhbGluZyA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgICBpZiAoaXRlbS5fdmlzaWJsZSAmJiAhaXRlbS5pc0VtcHR5KHRydWUpKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gaXRlbS5fZ2V0Q2FjaGVkQm91bmRzKG1hdHJpeCAmJiBtYXRyaXguYXBwZW5kZWQoaXRlbS5fbWF0cml4KSwgb3B0aW9ucywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgcmVjdCA9IGJvdW5kcy5yZWN0O1xuXG4gICAgICAgICAgICB4MSA9IE1hdGgubWluKHJlY3QueCwgeDEpO1xuICAgICAgICAgICAgeTEgPSBNYXRoLm1pbihyZWN0LnksIHkxKTtcbiAgICAgICAgICAgIHgyID0gTWF0aC5tYXgocmVjdC54ICsgcmVjdC53aWR0aCwgeDIpO1xuICAgICAgICAgICAgeTIgPSBNYXRoLm1heChyZWN0LnkgKyByZWN0LmhlaWdodCwgeTIpO1xuICAgICAgICAgICAgaWYgKGJvdW5kcy5ub25zY2FsaW5nKSBub25zY2FsaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlY3Q6IGlzRmluaXRlKHgxKSA/IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKSA6IG5ldyBSZWN0YW5nbGUoKSxcbiAgICAgICAgICBub25zY2FsaW5nOiBub25zY2FsaW5nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9KSwge1xuICAgIGJlYW5zOiB0cnVlLFxuICAgIF9kZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseU1hdHJpeCA/IG51bGwgOiB0aGlzLl9kZWNvbXBvc2VkIHx8ICh0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpKTtcbiAgICB9LFxuICAgIGdldFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZSgpO1xuXG4gICAgICByZXR1cm4gZGVjb21wb3NlZCA/IGRlY29tcG9zZWQucm90YXRpb24gOiAwO1xuICAgIH0sXG4gICAgc2V0Um90YXRpb246IGZ1bmN0aW9uIChyb3RhdGlvbikge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFJvdGF0aW9uKCk7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgcm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQ7XG4gICAgICAgIHRoaXMucm90YXRlKHJvdGF0aW9uIC0gY3VycmVudCk7XG5cbiAgICAgICAgaWYgKGRlY29tcG9zZWQpIHtcbiAgICAgICAgICBkZWNvbXBvc2VkLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgICAgdGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFNjYWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlKCksXG4gICAgICAgICAgcyA9IGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5zY2FsaW5nO1xuXG4gICAgICByZXR1cm4gbmV3IExpbmtlZFBvaW50KHMgPyBzLnggOiAxLCBzID8gcy55IDogMSwgdGhpcywgJ3NldFNjYWxpbmcnKTtcbiAgICB9LFxuICAgIHNldFNjYWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRTY2FsaW5nKCksXG4gICAgICAgICAgc2NhbGluZyA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7XG4gICAgICAgIGNsb25lOiB0cnVlLFxuICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjdXJyZW50ICYmIHNjYWxpbmcgJiYgIWN1cnJlbnQuZXF1YWxzKHNjYWxpbmcpKSB7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgICAgICAgIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkLFxuICAgICAgICAgICAgbWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuICAgICAgICAgICAgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblxuICAgICAgICBpZiAoaXNaZXJvKGN1cnJlbnQueCkgfHwgaXNaZXJvKGN1cnJlbnQueSkpIHtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKGRlY29tcG9zZWQudHJhbnNsYXRpb24pO1xuXG4gICAgICAgICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICAgICAgICBtYXRyaXgucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRyaXguc2NhbGUoc2NhbGluZy54LCBzY2FsaW5nLnkpO1xuXG4gICAgICAgICAgdGhpcy5fbWF0cml4LnNldChtYXRyaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpO1xuICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUoY2VudGVyKTtcbiAgICAgICAgICBpZiAocm90YXRpb24pIG1hdHJpeC5yb3RhdGUocm90YXRpb24pO1xuICAgICAgICAgIG1hdHJpeC5zY2FsZShzY2FsaW5nLnggLyBjdXJyZW50LngsIHNjYWxpbmcueSAvIGN1cnJlbnQueSk7XG4gICAgICAgICAgaWYgKHJvdGF0aW9uKSBtYXRyaXgucm90YXRlKC1yb3RhdGlvbik7XG4gICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuICAgICAgICAgIHRoaXMudHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVjb21wb3NlZCkge1xuICAgICAgICAgIGRlY29tcG9zZWQuc2NhbGluZyA9IHNjYWxpbmc7XG4gICAgICAgICAgdGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdldE1hdHJpeDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeDtcbiAgICB9LFxuICAgIHNldE1hdHJpeDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcbiAgICAgIG1hdHJpeC5zZXQuYXBwbHkobWF0cml4LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZ2V0R2xvYmFsTWF0cml4OiBmdW5jdGlvbiAoX2RvbnRDbG9uZSkge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeDtcblxuICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICB2YXIgcGFyZW50cyA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIXBhcmVudC5fZ2xvYmFsTWF0cml4KSB7XG4gICAgICAgICAgICBtYXRyaXggPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIHBhcmVudHNbaV0uX2dsb2JhbE1hdHJpeCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbWF0cml4KSB7XG4gICAgICAgIG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeCA9IHRoaXMuX21hdHJpeC5jbG9uZSgpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICBpZiAocGFyZW50KSBtYXRyaXgucHJlcGVuZChwYXJlbnQuZ2V0R2xvYmFsTWF0cml4KHRydWUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9kb250Q2xvbmUgPyBtYXRyaXggOiBtYXRyaXguY2xvbmUoKTtcbiAgICB9LFxuICAgIGdldFZpZXdNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLnByZXBlbmQodGhpcy5nZXRWaWV3KCkuX21hdHJpeCk7XG4gICAgfSxcbiAgICBnZXRBcHBseU1hdHJpeDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TWF0cml4O1xuICAgIH0sXG4gICAgc2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uIChhcHBseSkge1xuICAgICAgaWYgKHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgISFhcHBseSkgdGhpcy50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBnZXRUcmFuc2Zvcm1Db250ZW50OiAnI2dldEFwcGx5TWF0cml4JyxcbiAgICBzZXRUcmFuc2Zvcm1Db250ZW50OiAnI3NldEFwcGx5TWF0cml4J1xuICB9LCB7XG4gICAgZ2V0UHJvamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3Q7XG4gICAgfSxcbiAgICBfc2V0UHJvamVjdDogZnVuY3Rpb24gKHByb2plY3QsIGluc3RhbGxFdmVudHMpIHtcbiAgICAgIGlmICh0aGlzLl9wcm9qZWN0ICE9PSBwcm9qZWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9qZWN0KSB0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fcHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBjaGlsZHJlbltpXS5fc2V0UHJvamVjdChwcm9qZWN0KTtcblxuICAgICAgICBpbnN0YWxsRXZlbnRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3RhbGxFdmVudHMpIHRoaXMuX2luc3RhbGxFdmVudHModHJ1ZSk7XG4gICAgfSxcbiAgICBnZXRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvamVjdC5fdmlldztcbiAgICB9LFxuICAgIF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbiBfaW5zdGFsbEV2ZW50cyhpbnN0YWxsKSB7XG4gICAgICBfaW5zdGFsbEV2ZW50cy5iYXNlLmNhbGwodGhpcywgaW5zdGFsbCk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgY2hpbGRyZW5baV0uX2luc3RhbGxFdmVudHMoaW5zdGFsbCk7XG4gICAgfSxcbiAgICBnZXRMYXllcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgTGF5ZXIpIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgIH0sXG4gICAgc2V0UGFyZW50OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uYWRkQ2hpbGQodGhpcyk7XG4gICAgfSxcbiAgICBfZ2V0T3duZXI6ICcjZ2V0UGFyZW50JyxcbiAgICBnZXRDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICAgIH0sXG4gICAgc2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuICAgICAgdGhpcy5hZGRDaGlsZHJlbihpdGVtcyk7XG4gICAgfSxcbiAgICBnZXRGaXJzdENoaWxkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bMF0gfHwgbnVsbDtcbiAgICB9LFxuICAgIGdldExhc3RDaGlsZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuW3RoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgfSxcbiAgICBnZXROZXh0U2libGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblxuICAgICAgcmV0dXJuIG93bmVyICYmIG93bmVyLl9jaGlsZHJlblt0aGlzLl9pbmRleCArIDFdIHx8IG51bGw7XG4gICAgfSxcbiAgICBnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cbiAgICAgIHJldHVybiBvd25lciAmJiBvd25lci5fY2hpbGRyZW5bdGhpcy5faW5kZXggLSAxXSB8fCBudWxsO1xuICAgIH0sXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtID09PSB0aGlzIHx8IGl0ZW0gJiYgdGhpcy5fY2xhc3MgPT09IGl0ZW0uX2NsYXNzICYmIHRoaXMuX3N0eWxlLmVxdWFscyhpdGVtLl9zdHlsZSkgJiYgdGhpcy5fbWF0cml4LmVxdWFscyhpdGVtLl9tYXRyaXgpICYmIHRoaXMuX2xvY2tlZCA9PT0gaXRlbS5fbG9ja2VkICYmIHRoaXMuX3Zpc2libGUgPT09IGl0ZW0uX3Zpc2libGUgJiYgdGhpcy5fYmxlbmRNb2RlID09PSBpdGVtLl9ibGVuZE1vZGUgJiYgdGhpcy5fb3BhY2l0eSA9PT0gaXRlbS5fb3BhY2l0eSAmJiB0aGlzLl9jbGlwTWFzayA9PT0gaXRlbS5fY2xpcE1hc2sgJiYgdGhpcy5fZ3VpZGUgPT09IGl0ZW0uX2d1aWRlICYmIHRoaXMuX2VxdWFscyhpdGVtKSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIF9lcXVhbHM6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gQmFzZS5lcXVhbHModGhpcy5fY2hpbGRyZW4sIGl0ZW0uX2NoaWxkcmVuKTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJdGVtLk5PX0lOU0VSVCksXG4gICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICBpbnNlcnQgPSBCYXNlLnBpY2sob3B0aW9ucyA/IG9wdGlvbnMuaW5zZXJ0IDogdW5kZWZpbmVkLCBvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucyA9PT0gdHJ1ZSksXG4gICAgICAgICAgZGVlcCA9IEJhc2UucGljayhvcHRpb25zID8gb3B0aW9ucy5kZWVwIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIGlmIChjaGlsZHJlbikgY29weS5jb3B5QXR0cmlidXRlcyh0aGlzKTtcbiAgICAgIGlmICghY2hpbGRyZW4gfHwgZGVlcCkgY29weS5jb3B5Q29udGVudCh0aGlzKTtcbiAgICAgIGlmICghY2hpbGRyZW4pIGNvcHkuY29weUF0dHJpYnV0ZXModGhpcyk7XG4gICAgICBpZiAoaW5zZXJ0KSBjb3B5Lmluc2VydEFib3ZlKHRoaXMpO1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgICAgIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblxuICAgICAgaWYgKG5hbWUgJiYgcGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fY2hpbGRyZW4sXG4gICAgICAgICAgICBvcmlnID0gbmFtZSxcbiAgICAgICAgICAgIGkgPSAxO1xuXG4gICAgICAgIHdoaWxlIChjaGlsZHJlbltuYW1lXSkgbmFtZSA9IG9yaWcgKyAnICcgKyBpKys7XG5cbiAgICAgICAgaWYgKG5hbWUgIT09IG9yaWcpIGNvcHkuc2V0TmFtZShuYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfSxcbiAgICBjb3B5Q29udGVudDogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gc291cmNlLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZHJlbltpXS5jbG9uZShmYWxzZSksIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29weUF0dHJpYnV0ZXM6IGZ1bmN0aW9uIChzb3VyY2UsIGV4Y2x1ZGVNYXRyaXgpIHtcbiAgICAgIHRoaXMuc2V0U3R5bGUoc291cmNlLl9zdHlsZSk7XG4gICAgICB2YXIga2V5cyA9IFsnX2xvY2tlZCcsICdfdmlzaWJsZScsICdfYmxlbmRNb2RlJywgJ19vcGFjaXR5JywgJ19jbGlwTWFzaycsICdfZ3VpZGUnXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB0aGlzW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFleGNsdWRlTWF0cml4KSB0aGlzLl9tYXRyaXguc2V0KHNvdXJjZS5fbWF0cml4LCB0cnVlKTtcbiAgICAgIHRoaXMuc2V0QXBwbHlNYXRyaXgoc291cmNlLl9hcHBseU1hdHJpeCk7XG4gICAgICB0aGlzLnNldFBpdm90KHNvdXJjZS5fcGl2b3QpO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc291cmNlLl9zZWxlY3Rpb24pO1xuICAgICAgdmFyIGRhdGEgPSBzb3VyY2UuX2RhdGEsXG4gICAgICAgICAgbmFtZSA9IHNvdXJjZS5fbmFtZTtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhID8gQmFzZS5jbG9uZShkYXRhKSA6IG51bGw7XG4gICAgICBpZiAobmFtZSkgdGhpcy5zZXROYW1lKG5hbWUpO1xuICAgIH0sXG4gICAgcmFzdGVyaXplOiBmdW5jdGlvbiAocmVzb2x1dGlvbiwgaW5zZXJ0KSB7XG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHMoKSxcbiAgICAgICAgICBzY2FsZSA9IChyZXNvbHV0aW9uIHx8IHRoaXMuZ2V0VmlldygpLmdldFJlc29sdXRpb24oKSkgLyA3MixcbiAgICAgICAgICB0b3BMZWZ0ID0gYm91bmRzLmdldFRvcExlZnQoKS5mbG9vcigpLFxuICAgICAgICAgIGJvdHRvbVJpZ2h0ID0gYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkuY2VpbCgpLFxuICAgICAgICAgIHNpemUgPSBuZXcgU2l6ZShib3R0b21SaWdodC5zdWJ0cmFjdCh0b3BMZWZ0KSksXG4gICAgICAgICAgcmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cbiAgICAgIGlmICghc2l6ZS5pc1plcm8oKSkge1xuICAgICAgICB2YXIgY2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUubXVsdGlwbHkoc2NhbGUpKSxcbiAgICAgICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgICAgbWF0cml4ID0gbmV3IE1hdHJpeCgpLnNjYWxlKHNjYWxlKS50cmFuc2xhdGUodG9wTGVmdC5uZWdhdGUoKSk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuICAgICAgICB0aGlzLmRyYXcoY3R4LCBuZXcgQmFzZSh7XG4gICAgICAgICAgbWF0cmljZXM6IFttYXRyaXhdXG4gICAgICAgIH0pKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgcmFzdGVyLnNldENhbnZhcyhjYW52YXMpO1xuICAgICAgfVxuXG4gICAgICByYXN0ZXIudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUodG9wTGVmdC5hZGQoc2l6ZS5kaXZpZGUoMikpKS5zY2FsZSgxIC8gc2NhbGUpKTtcbiAgICAgIGlmIChpbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBpbnNlcnQpIHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcbiAgICAgIHJldHVybiByYXN0ZXI7XG4gICAgfSxcbiAgICBjb250YWluczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcbiAgICAgIHJldHVybiBtYXRyaXguaXNJbnZlcnRpYmxlKCkgJiYgISF0aGlzLl9jb250YWlucyhtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG4gICAgfSxcbiAgICBfY29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5baV0uY29udGFpbnMocG9pbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvaW50LmlzSW5zaWRlKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG4gICAgfSxcbiAgICBpc0luc2lkZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykuY29udGFpbnModGhpcy5nZXRCb3VuZHMoKSk7XG4gICAgfSxcbiAgICBfYXNQYXRoSXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG4gICAgICAgIHJlY3RhbmdsZTogdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpLFxuICAgICAgICBtYXRyaXg6IHRoaXMuX21hdHJpeCxcbiAgICAgICAgaW5zZXJ0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbiAoaXRlbSwgX21hdHJpeCkge1xuICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIEl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5fYXNQYXRoSXRlbSgpLmdldEludGVyc2VjdGlvbnMoaXRlbS5fYXNQYXRoSXRlbSgpLCBudWxsLCBfbWF0cml4LCB0cnVlKS5sZW5ndGggPiAwO1xuICAgIH1cbiAgfSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBoaXRUZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gdGhpcy5faGl0VGVzdChQb2ludC5yZWFkKGFyZ3MpLCBIaXRSZXN1bHQuZ2V0T3B0aW9ucyhhcmdzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGl0VGVzdEFsbCgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHBvaW50ID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICBvcHRpb25zID0gSGl0UmVzdWx0LmdldE9wdGlvbnMoYXJncyksXG4gICAgICAgICAgYWxsID0gW107XG5cbiAgICAgIHRoaXMuX2hpdFRlc3QocG9pbnQsIG5ldyBCYXNlKHtcbiAgICAgICAgYWxsOiBhbGxcbiAgICAgIH0sIG9wdGlvbnMpKTtcblxuICAgICAgcmV0dXJuIGFsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoaXRUZXN0Q2hpbGRyZW4ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgsIF9leGNsdWRlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgdmFyIHJlcyA9IGNoaWxkICE9PSBfZXhjbHVkZSAmJiBjaGlsZC5faGl0VGVzdChwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCk7XG5cbiAgICAgICAgICBpZiAocmVzICYmICFvcHRpb25zLmFsbCkgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBQcm9qZWN0LmluamVjdCh7XG4gICAgICBoaXRUZXN0OiBoaXRUZXN0LFxuICAgICAgaGl0VGVzdEFsbDogaGl0VGVzdEFsbCxcbiAgICAgIF9oaXRUZXN0OiBoaXRUZXN0Q2hpbGRyZW5cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaGl0VGVzdDogaGl0VGVzdCxcbiAgICAgIGhpdFRlc3RBbGw6IGhpdFRlc3RBbGwsXG4gICAgICBfaGl0VGVzdENoaWxkcmVuOiBoaXRUZXN0Q2hpbGRyZW5cbiAgICB9O1xuICB9KCksIHtcbiAgICBfaGl0VGVzdDogZnVuY3Rpb24gKHBvaW50LCBvcHRpb25zLCBwYXJlbnRWaWV3TWF0cml4KSB7XG4gICAgICBpZiAodGhpcy5fbG9ja2VkIHx8ICF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX2d1aWRlICYmICFvcHRpb25zLmd1aWRlcyB8fCB0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcbiAgICAgICAgICB2aWV3TWF0cml4ID0gcGFyZW50Vmlld01hdHJpeCA/IHBhcmVudFZpZXdNYXRyaXguYXBwZW5kZWQobWF0cml4KSA6IHRoaXMuZ2V0R2xvYmFsTWF0cml4KCkucHJlcGVuZCh0aGlzLmdldFZpZXcoKS5fbWF0cml4KSxcbiAgICAgICAgICB0b2xlcmFuY2UgPSBNYXRoLm1heChvcHRpb25zLnRvbGVyYW5jZSwgMWUtMTIpLFxuICAgICAgICAgIHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nID0gbmV3IFNpemUoUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyh0b2xlcmFuY2UsIG1hdHJpeC5fc2hpZnRsZXNzKCkuaW52ZXJ0KCkpKTtcbiAgICAgIHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHBvaW50KTtcblxuICAgICAgaWYgKCFwb2ludCB8fCAhdGhpcy5fY2hpbGRyZW4gJiYgIXRoaXMuZ2V0Qm91bmRzKHtcbiAgICAgICAgaW50ZXJuYWw6IHRydWUsXG4gICAgICAgIHN0cm9rZTogdHJ1ZSxcbiAgICAgICAgaGFuZGxlOiB0cnVlXG4gICAgICB9KS5leHBhbmQodG9sZXJhbmNlUGFkZGluZy5tdWx0aXBseSgyKSkuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hlY2tTZWxmID0gIShvcHRpb25zLmd1aWRlcyAmJiAhdGhpcy5fZ3VpZGUgfHwgb3B0aW9ucy5zZWxlY3RlZCAmJiAhdGhpcy5pc1NlbGVjdGVkKCkgfHwgb3B0aW9ucy50eXBlICYmIG9wdGlvbnMudHlwZSAhPT0gQmFzZS5oeXBoZW5hdGUodGhpcy5fY2xhc3MpIHx8IG9wdGlvbnMuY2xhc3MgJiYgISh0aGlzIGluc3RhbmNlb2Ygb3B0aW9ucy5jbGFzcykpLFxuICAgICAgICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgcmVzO1xuXG4gICAgICBmdW5jdGlvbiBmaWx0ZXIoaGl0KSB7XG4gICAgICAgIGlmIChoaXQgJiYgbWF0Y2ggJiYgIW1hdGNoKGhpdCkpIGhpdCA9IG51bGw7XG4gICAgICAgIGlmIChoaXQgJiYgb3B0aW9ucy5hbGwpIG9wdGlvbnMuYWxsLnB1c2goaGl0KTtcbiAgICAgICAgcmV0dXJuIGhpdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tQb2ludCh0eXBlLCBwYXJ0KSB7XG4gICAgICAgIHZhciBwdCA9IHBhcnQgPyBib3VuZHNbJ2dldCcgKyBwYXJ0XSgpIDogdGhhdC5nZXRQb3NpdGlvbigpO1xuXG4gICAgICAgIGlmIChwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHRvbGVyYW5jZVBhZGRpbmcpLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBIaXRSZXN1bHQodHlwZSwgdGhhdCwge1xuICAgICAgICAgICAgbmFtZTogcGFydCA/IEJhc2UuaHlwaGVuYXRlKHBhcnQpIDogdHlwZSxcbiAgICAgICAgICAgIHBvaW50OiBwdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGVja1Bvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbixcbiAgICAgICAgICBjaGVja0NlbnRlciA9IG9wdGlvbnMuY2VudGVyLFxuICAgICAgICAgIGNoZWNrQm91bmRzID0gb3B0aW9ucy5ib3VuZHM7XG5cbiAgICAgIGlmIChjaGVja1NlbGYgJiYgdGhpcy5fcGFyZW50ICYmIChjaGVja1Bvc2l0aW9uIHx8IGNoZWNrQ2VudGVyIHx8IGNoZWNrQm91bmRzKSkge1xuICAgICAgICBpZiAoY2hlY2tDZW50ZXIgfHwgY2hlY2tCb3VuZHMpIHtcbiAgICAgICAgICBib3VuZHMgPSB0aGlzLmdldEludGVybmFsQm91bmRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXMgPSBjaGVja1Bvc2l0aW9uICYmIGNoZWNrUG9pbnQoJ3Bvc2l0aW9uJykgfHwgY2hlY2tDZW50ZXIgJiYgY2hlY2tQb2ludCgnY2VudGVyJywgJ0NlbnRlcicpO1xuXG4gICAgICAgIGlmICghcmVzICYmIGNoZWNrQm91bmRzKSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IFsnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21MZWZ0JywgJ0JvdHRvbVJpZ2h0JywgJ0xlZnRDZW50ZXInLCAnVG9wQ2VudGVyJywgJ1JpZ2h0Q2VudGVyJywgJ0JvdHRvbUNlbnRlciddO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4ICYmICFyZXM7IGkrKykge1xuICAgICAgICAgICAgcmVzID0gY2hlY2tQb2ludCgnYm91bmRzJywgcG9pbnRzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXMgPSBmaWx0ZXIocmVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmVzID0gdGhpcy5faGl0VGVzdENoaWxkcmVuKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4KSB8fCBjaGVja1NlbGYgJiYgZmlsdGVyKHRoaXMuX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LCB0aGlzLmdldFN0cm9rZVNjYWxpbmcoKSA/IG51bGwgOiB2aWV3TWF0cml4Ll9zaGlmdGxlc3MoKS5pbnZlcnQoKSkpIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXMgJiYgcmVzLnBvaW50KSB7XG4gICAgICAgIHJlcy5wb2ludCA9IG1hdHJpeC50cmFuc2Zvcm0ocmVzLnBvaW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIF9oaXRUZXN0U2VsZjogZnVuY3Rpb24gKHBvaW50LCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5maWxsICYmIHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuX2NvbnRhaW5zKHBvaW50KSkgcmV0dXJuIG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKTtcbiAgICB9LFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIChuYW1lLCBjb21wYXJlKSB7XG4gICAgICBmdW5jdGlvbiBtYXRjaE9iamVjdChvYmoxLCBvYmoyKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gb2JqMSkge1xuICAgICAgICAgIGlmIChvYmoxLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB2YXIgdmFsMSA9IG9iajFbaV0sXG4gICAgICAgICAgICAgICAgdmFsMiA9IG9iajJbaV07XG5cbiAgICAgICAgICAgIGlmIChCYXNlLmlzUGxhaW5PYmplY3QodmFsMSkgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHZhbDIpKSB7XG4gICAgICAgICAgICAgIGlmICghbWF0Y2hPYmplY3QodmFsMSwgdmFsMikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgbmFtZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgICAgaWYgKG5hbWUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdGhpcy5tYXRjaGVzKGtleSwgbmFtZVtrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdtYXRjaCcpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSAvXihlbXB0eXxlZGl0YWJsZSkkLy50ZXN0KG5hbWUpID8gdGhpc1snaXMnICsgQmFzZS5jYXBpdGFsaXplKG5hbWUpXSgpIDogbmFtZSA9PT0gJ3R5cGUnID8gQmFzZS5oeXBoZW5hdGUodGhpcy5fY2xhc3MpIDogdGhpc1tuYW1lXTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBjb21wYXJlO1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5fY2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gISFjb21wYXJlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wYXJlKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmUudGVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUudGVzdCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoY29tcGFyZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaE9iamVjdChjb21wYXJlLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEJhc2UuZXF1YWxzKHZhbHVlLCBjb21wYXJlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEl0ZW1zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMsIG9wdGlvbnMsIHRoaXMuX21hdHJpeCk7XG4gICAgfSxcbiAgICBnZXRJdGVtOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMsIG9wdGlvbnMsIHRoaXMuX21hdHJpeCwgbnVsbCwgdHJ1ZSlbMF0gfHwgbnVsbDtcbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIF9nZXRJdGVtczogZnVuY3Rpb24gX2dldEl0ZW1zKGl0ZW0sIG9wdGlvbnMsIG1hdHJpeCwgcGFyYW0sIGZpcnN0T25seSkge1xuICAgICAgICBpZiAoIXBhcmFtKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zLFxuICAgICAgICAgICAgICBvdmVybGFwcGluZyA9IG9iaiAmJiBvYmoub3ZlcmxhcHBpbmcsXG4gICAgICAgICAgICAgIGluc2lkZSA9IG9iaiAmJiBvYmouaW5zaWRlLFxuICAgICAgICAgICAgICBib3VuZHMgPSBvdmVybGFwcGluZyB8fCBpbnNpZGUsXG4gICAgICAgICAgICAgIHJlY3QgPSBib3VuZHMgJiYgUmVjdGFuZ2xlLnJlYWQoW2JvdW5kc10pO1xuICAgICAgICAgIHBhcmFtID0ge1xuICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgcmVjdXJzaXZlOiBvYmogJiYgb2JqLnJlY3Vyc2l2ZSAhPT0gZmFsc2UsXG4gICAgICAgICAgICBpbnNpZGU6ICEhaW5zaWRlLFxuICAgICAgICAgICAgb3ZlcmxhcHBpbmc6ICEhb3ZlcmxhcHBpbmcsXG4gICAgICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICAgICAgcGF0aDogb3ZlcmxhcHBpbmcgJiYgbmV3IFBhdGguUmVjdGFuZ2xlKHtcbiAgICAgICAgICAgICAgcmVjdGFuZ2xlOiByZWN0LFxuICAgICAgICAgICAgICBpbnNlcnQ6IGZhbHNlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gQmFzZS5maWx0ZXIoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICBpbnNpZGU6IHRydWUsXG4gICAgICAgICAgICAgIG92ZXJsYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBpdGVtLl9jaGlsZHJlbixcbiAgICAgICAgICAgIGl0ZW1zID0gcGFyYW0uaXRlbXMsXG4gICAgICAgICAgICByZWN0ID0gcGFyYW0ucmVjdDtcbiAgICAgICAgbWF0cml4ID0gcmVjdCAmJiAobWF0cml4IHx8IG5ldyBNYXRyaXgoKSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcbiAgICAgICAgICAgICAgY2hpbGRNYXRyaXggPSBtYXRyaXggJiYgbWF0cml4LmFwcGVuZGVkKGNoaWxkLl9tYXRyaXgpLFxuICAgICAgICAgICAgICBhZGQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBjaGlsZC5nZXRCb3VuZHMoY2hpbGRNYXRyaXgpO1xuICAgICAgICAgICAgaWYgKCFyZWN0LmludGVyc2VjdHMoYm91bmRzKSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIShyZWN0LmNvbnRhaW5zKGJvdW5kcykgfHwgcGFyYW0ub3ZlcmxhcHBpbmcgJiYgKGJvdW5kcy5jb250YWlucyhyZWN0KSB8fCBwYXJhbS5wYXRoLmludGVyc2VjdHMoY2hpbGQsIGNoaWxkTWF0cml4KSkpKSBhZGQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWRkICYmIGNoaWxkLm1hdGNoZXMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgaWYgKGZpcnN0T25seSkgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcmFtLnJlY3Vyc2l2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF9nZXRJdGVtcyhjaGlsZCwgb3B0aW9ucywgY2hpbGRNYXRyaXgsIHBhcmFtLCBmaXJzdE9ubHkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaXJzdE9ubHkgJiYgaXRlbXMubGVuZ3RoID4gMCkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgaW1wb3J0SlNPTjogZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgIHZhciByZXMgPSBCYXNlLmltcG9ydEpTT04oanNvbiwgdGhpcyk7XG4gICAgICByZXR1cm4gcmVzICE9PSB0aGlzID8gdGhpcy5hZGRDaGlsZChyZXMpIDogcmVzO1xuICAgIH0sXG4gICAgYWRkQ2hpbGQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnRDaGlsZCh1bmRlZmluZWQsIGl0ZW0pO1xuICAgIH0sXG4gICAgaW5zZXJ0Q2hpbGQ6IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgdmFyIHJlcyA9IGl0ZW0gPyB0aGlzLmluc2VydENoaWxkcmVuKGluZGV4LCBbaXRlbV0pIDogbnVsbDtcbiAgICAgIHJldHVybiByZXMgJiYgcmVzWzBdO1xuICAgIH0sXG4gICAgYWRkQ2hpbGRyZW46IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4ubGVuZ3RoLCBpdGVtcyk7XG4gICAgfSxcbiAgICBpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24gKGluZGV4LCBpdGVtcykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGl0ZW1zID0gQmFzZS5zbGljZShpdGVtcyk7XG4gICAgICAgIHZhciBpbnNlcnRlZCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV0sXG4gICAgICAgICAgICAgIGlkID0gaXRlbSAmJiBpdGVtLl9pZDtcblxuICAgICAgICAgIGlmICghaXRlbSB8fCBpbnNlcnRlZFtpZF0pIHtcbiAgICAgICAgICAgIGl0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgICAgaW5zZXJ0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBCYXNlLnNwbGljZShjaGlsZHJlbiwgaXRlbXMsIGluZGV4LCAwKTtcbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuICAgICAgICAgICAgbm90aWZ5U2VsZiA9IHByb2plY3QuX2NoYW5nZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldLFxuICAgICAgICAgICAgICBuYW1lID0gaXRlbS5fbmFtZTtcbiAgICAgICAgICBpdGVtLl9wYXJlbnQgPSB0aGlzO1xuXG4gICAgICAgICAgaXRlbS5fc2V0UHJvamVjdChwcm9qZWN0LCB0cnVlKTtcblxuICAgICAgICAgIGlmIChuYW1lKSBpdGVtLnNldE5hbWUobmFtZSk7XG4gICAgICAgICAgaWYgKG5vdGlmeVNlbGYpIGl0ZW0uX2NoYW5nZWQoNSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKDExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG4gICAgX2luc2VydEl0ZW06ICcjaW5zZXJ0Q2hpbGQnLFxuICAgIF9pbnNlcnRBdDogZnVuY3Rpb24gKGl0ZW0sIG9mZnNldCkge1xuICAgICAgdmFyIG93bmVyID0gaXRlbSAmJiBpdGVtLl9nZXRPd25lcigpLFxuICAgICAgICAgIHJlcyA9IGl0ZW0gIT09IHRoaXMgJiYgb3duZXIgPyB0aGlzIDogbnVsbDtcblxuICAgICAgaWYgKHJlcykge1xuICAgICAgICByZXMuX3JlbW92ZShmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgb3duZXIuX2luc2VydEl0ZW0oaXRlbS5faW5kZXggKyBvZmZzZXQsIHJlcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBpbnNlcnRBYm92ZTogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRBdChpdGVtLCAxKTtcbiAgICB9LFxuICAgIGluc2VydEJlbG93OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luc2VydEF0KGl0ZW0sIDApO1xuICAgIH0sXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblxuICAgICAgcmV0dXJuIG93bmVyID8gb3duZXIuX2luc2VydEl0ZW0oMCwgdGhpcykgOiBudWxsO1xuICAgIH0sXG4gICAgYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXG4gICAgICByZXR1cm4gb3duZXIgPyBvd25lci5faW5zZXJ0SXRlbSh1bmRlZmluZWQsIHRoaXMpIDogbnVsbDtcbiAgICB9LFxuICAgIGFwcGVuZFRvcDogJyNhZGRDaGlsZCcsXG4gICAgYXBwZW5kQm90dG9tOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQoMCwgaXRlbSk7XG4gICAgfSxcbiAgICBtb3ZlQWJvdmU6ICcjaW5zZXJ0QWJvdmUnLFxuICAgIG1vdmVCZWxvdzogJyNpbnNlcnRCZWxvdycsXG4gICAgYWRkVG86IGZ1bmN0aW9uIChvd25lcikge1xuICAgICAgcmV0dXJuIG93bmVyLl9pbnNlcnRJdGVtKHVuZGVmaW5lZCwgdGhpcyk7XG4gICAgfSxcbiAgICBjb3B5VG86IGZ1bmN0aW9uIChvd25lcikge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoZmFsc2UpLmFkZFRvKG93bmVyKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuWzBdLnJlZHVjZShvcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfcmVtb3ZlTmFtZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBvd25lci5fY2hpbGRyZW4sXG4gICAgICAgICAgICBuYW1lZENoaWxkcmVuID0gb3duZXIuX25hbWVkQ2hpbGRyZW4sXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgICAgICAgIG5hbWVkQXJyYXkgPSBuYW1lZENoaWxkcmVuW25hbWVdLFxuICAgICAgICAgICAgaW5kZXggPSBuYW1lZEFycmF5ID8gbmFtZWRBcnJheS5pbmRleE9mKHRoaXMpIDogLTE7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIGlmIChjaGlsZHJlbltuYW1lXSA9PSB0aGlzKSBkZWxldGUgY2hpbGRyZW5bbmFtZV07XG4gICAgICAgICAgbmFtZWRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgaWYgKG5hbWVkQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGlsZHJlbltuYW1lXSA9IG5hbWVkQXJyYXlbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuYW1lZENoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX3JlbW92ZTogZnVuY3Rpb24gKG5vdGlmeVNlbGYsIG5vdGlmeVBhcmVudCkge1xuICAgICAgdmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKSxcbiAgICAgICAgICBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcbiAgICAgICAgICBpbmRleCA9IHRoaXMuX2luZGV4O1xuXG4gICAgICBpZiAodGhpcy5fc3R5bGUpIHRoaXMuX3N0eWxlLl9kaXNwb3NlKCk7XG5cbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBpZiAodGhpcy5fbmFtZSkgdGhpcy5fcmVtb3ZlTmFtZWQoKTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwcm9qZWN0Ll9hY3RpdmVMYXllciA9PT0gdGhpcykgcHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzLmdldE5leHRTaWJsaW5nKCkgfHwgdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgICBCYXNlLnNwbGljZShvd25lci5fY2hpbGRyZW4sIG51bGwsIGluZGV4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXG4gICAgICAgIGlmIChub3RpZnlTZWxmICYmIHByb2plY3QuX2NoYW5nZXMpIHRoaXMuX2NoYW5nZWQoNSk7XG4gICAgICAgIGlmIChub3RpZnlQYXJlbnQpIG93bmVyLl9jaGFuZ2VkKDExLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZSh0cnVlLCB0cnVlKTtcbiAgICB9LFxuICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIG9rID0gaXRlbSAmJiBpdGVtLmluc2VydEJlbG93KHRoaXMpO1xuICAgICAgaWYgKG9rKSB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuIG9rO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIXRoaXMuX2NoaWxkcmVuKSByZXR1cm4gbnVsbDtcbiAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICAgIGVuZCA9IEJhc2UucGljayhlbmQsIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCk7XG4gICAgICB2YXIgcmVtb3ZlZCA9IEJhc2Uuc3BsaWNlKHRoaXMuX2NoaWxkcmVuLCBudWxsLCBzdGFydCwgZW5kIC0gc3RhcnQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZW1vdmVkW2ldLl9yZW1vdmUodHJ1ZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlZC5sZW5ndGggPiAwKSB0aGlzLl9jaGFuZ2VkKDExKTtcbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG4gICAgY2xlYXI6ICcjcmVtb3ZlQ2hpbGRyZW4nLFxuICAgIHJldmVyc2VDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnJldmVyc2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgdGhpcy5fY2hpbGRyZW5baV0uX2luZGV4ID0gaTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKDExKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIChyZWN1cnNpdmVseSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICB2YXIgbnVtQ2hpbGRyZW4gPSBjaGlsZHJlbiA/IGNoaWxkcmVuLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChyZWN1cnNpdmVseSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNoaWxkcmVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWNoaWxkcmVuW2ldLmlzRW1wdHkocmVjdXJzaXZlbHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhbnVtQ2hpbGRyZW47XG4gICAgfSxcbiAgICBpc0VkaXRhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5fdmlzaWJsZSB8fCBpdGVtLl9sb2NrZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaXRlbSA9IGl0ZW0uX3BhcmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBoYXNGaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc0ZpbGwoKTtcbiAgICB9LFxuICAgIGhhc1N0cm9rZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNTdHJva2UoKTtcbiAgICB9LFxuICAgIGhhc1NoYWRvdzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNTaGFkb3coKTtcbiAgICB9LFxuICAgIF9nZXRPcmRlcjogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGZ1bmN0aW9uIGdldExpc3QoaXRlbSkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBsaXN0LnVuc2hpZnQoaXRlbSk7XG4gICAgICAgIH0gd2hpbGUgKGl0ZW0gPSBpdGVtLl9wYXJlbnQpO1xuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgbGlzdDEgPSBnZXRMaXN0KHRoaXMpLFxuICAgICAgICAgIGxpc3QyID0gZ2V0TGlzdChpdGVtKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBNYXRoLm1pbihsaXN0MS5sZW5ndGgsIGxpc3QyLmxlbmd0aCk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGxpc3QxW2ldICE9IGxpc3QyW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3QxW2ldLl9pbmRleCA8IGxpc3QyW2ldLl9pbmRleCA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGhhc0NoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICB9LFxuICAgIGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuaXNJbnNlcnRlZCgpIDogZmFsc2U7XG4gICAgfSxcbiAgICBpc0Fib3ZlOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAtMTtcbiAgICB9LFxuICAgIGlzQmVsb3c6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IDE7XG4gICAgfSxcbiAgICBpc1BhcmVudDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPT09IGl0ZW07XG4gICAgfSxcbiAgICBpc0NoaWxkOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5fcGFyZW50ID09PSB0aGlzO1xuICAgIH0sXG4gICAgaXNEZXNjZW5kYW50OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBpdGVtKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNBbmNlc3RvcjogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtID8gaXRlbS5pc0Rlc2NlbmRhbnQodGhpcykgOiBmYWxzZTtcbiAgICB9LFxuICAgIGlzU2libGluZzogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPT09IGl0ZW0uX3BhcmVudDtcbiAgICB9LFxuICAgIGlzR3JvdXBlZFdpdGg6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQuX3BhcmVudCAmJiAvXihHcm91cHxMYXllcnxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKSAmJiBpdGVtLmlzRGVzY2VuZGFudChwYXJlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIEJhc2UuZWFjaChbJ3JvdGF0ZScsICdzY2FsZScsICdzaGVhcicsICdza2V3J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcm90YXRlID0ga2V5ID09PSAncm90YXRlJztcblxuICAgIHRoaXNba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHZhbHVlID0gKHJvdGF0ZSA/IEJhc2UgOiBQb2ludCkucmVhZChhcmdzKSxcbiAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3MsIDAsIHtcbiAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKVtrZXldKHZhbHVlLCBjZW50ZXIgfHwgdGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuICAgIH07XG4gIH0sIHtcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBteCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShteC50cmFuc2xhdGUuYXBwbHkobXgsIGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAobWF0cml4LCBfYXBwbHlSZWN1cnNpdmVseSwgX3NldEFwcGx5TWF0cml4KSB7XG4gICAgICB2YXIgX21hdHJpeCA9IHRoaXMuX21hdHJpeCxcbiAgICAgICAgICB0cmFuc2Zvcm1NYXRyaXggPSBtYXRyaXggJiYgIW1hdHJpeC5pc0lkZW50aXR5KCksXG4gICAgICAgICAgYXBwbHlNYXRyaXggPSBfc2V0QXBwbHlNYXRyaXggJiYgdGhpcy5fY2FuQXBwbHlNYXRyaXggfHwgdGhpcy5fYXBwbHlNYXRyaXggJiYgKHRyYW5zZm9ybU1hdHJpeCB8fCAhX21hdHJpeC5pc0lkZW50aXR5KCkgfHwgX2FwcGx5UmVjdXJzaXZlbHkgJiYgdGhpcy5fY2hpbGRyZW4pO1xuICAgICAgaWYgKCF0cmFuc2Zvcm1NYXRyaXggJiYgIWFwcGx5TWF0cml4KSByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKHRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICBpZiAoIW1hdHJpeC5pc0ludmVydGlibGUoKSAmJiBfbWF0cml4LmlzSW52ZXJ0aWJsZSgpKSBfbWF0cml4Ll9iYWNrdXAgPSBfbWF0cml4LmdldFZhbHVlcygpO1xuXG4gICAgICAgIF9tYXRyaXgucHJlcGVuZChtYXRyaXgsIHRydWUpO1xuXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuICAgICAgICAgICAgZmlsbENvbG9yID0gc3R5bGUuZ2V0RmlsbENvbG9yKHRydWUpLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3IgPSBzdHlsZS5nZXRTdHJva2VDb2xvcih0cnVlKTtcbiAgICAgICAgaWYgKGZpbGxDb2xvcikgZmlsbENvbG9yLnRyYW5zZm9ybShtYXRyaXgpO1xuICAgICAgICBpZiAoc3Ryb2tlQ29sb3IpIHN0cm9rZUNvbG9yLnRyYW5zZm9ybShtYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXBwbHlNYXRyaXggJiYgKGFwcGx5TWF0cml4ID0gdGhpcy5fdHJhbnNmb3JtQ29udGVudChfbWF0cml4LCBfYXBwbHlSZWN1cnNpdmVseSwgX3NldEFwcGx5TWF0cml4KSkpIHtcbiAgICAgICAgdmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG4gICAgICAgIGlmIChwaXZvdCkgX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQocGl2b3QsIHBpdm90LCB0cnVlKTtcblxuICAgICAgICBfbWF0cml4LnJlc2V0KHRydWUpO1xuXG4gICAgICAgIGlmIChfc2V0QXBwbHlNYXRyaXggJiYgdGhpcy5fY2FuQXBwbHlNYXRyaXgpIHRoaXMuX2FwcGx5TWF0cml4ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcyxcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xuXG4gICAgICBpZiAodHJhbnNmb3JtTWF0cml4IHx8IGFwcGx5TWF0cml4KSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoMjUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVjb21wID0gdHJhbnNmb3JtTWF0cml4ICYmIGJvdW5kcyAmJiBtYXRyaXguZGVjb21wb3NlKCk7XG5cbiAgICAgIGlmIChkZWNvbXAgJiYgZGVjb21wLnNrZXdpbmcuaXNaZXJvKCkgJiYgZGVjb21wLnJvdGF0aW9uICUgOTAgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGJvdW5kcykge1xuICAgICAgICAgIHZhciBjYWNoZSA9IGJvdW5kc1trZXldO1xuXG4gICAgICAgICAgaWYgKGNhY2hlLm5vbnNjYWxpbmcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBib3VuZHNba2V5XTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFwcGx5TWF0cml4IHx8ICFjYWNoZS5pbnRlcm5hbCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBjYWNoZS5yZWN0O1xuXG4gICAgICAgICAgICBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0LCByZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ib3VuZHMgPSBib3VuZHM7XG5cbiAgICAgICAgdmFyIGNhY2hlZCA9IGJvdW5kc1t0aGlzLl9nZXRCb3VuZHNDYWNoZUtleSh0aGlzLl9ib3VuZHNPcHRpb25zIHx8IHt9KV07XG5cbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb25Gcm9tQm91bmRzKGNhY2hlZC5yZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFuc2Zvcm1NYXRyaXggJiYgcG9zaXRpb24gJiYgdGhpcy5fcGl2b3QpIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX3RyYW5zZm9ybUNvbnRlbnQ6IGZ1bmN0aW9uIChtYXRyaXgsIGFwcGx5UmVjdXJzaXZlbHksIHNldEFwcGx5TWF0cml4KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0udHJhbnNmb3JtKG1hdHJpeCwgYXBwbHlSZWN1cnNpdmVseSwgc2V0QXBwbHlNYXRyaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbG9iYWxUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkuX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGxvY2FsVG9HbG9iYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIHBhcmVudFRvTG9jYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGxvY2FsVG9QYXJlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBmaXRCb3VuZHM6IGZ1bmN0aW9uIChyZWN0YW5nbGUsIGZpbGwpIHtcbiAgICAgIHJlY3RhbmdsZSA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcbiAgICAgICAgICBpdGVtUmF0aW8gPSBib3VuZHMuaGVpZ2h0IC8gYm91bmRzLndpZHRoLFxuICAgICAgICAgIHJlY3RSYXRpbyA9IHJlY3RhbmdsZS5oZWlnaHQgLyByZWN0YW5nbGUud2lkdGgsXG4gICAgICAgICAgc2NhbGUgPSAoZmlsbCA/IGl0ZW1SYXRpbyA+IHJlY3RSYXRpbyA6IGl0ZW1SYXRpbyA8IHJlY3RSYXRpbykgPyByZWN0YW5nbGUud2lkdGggLyBib3VuZHMud2lkdGggOiByZWN0YW5nbGUuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCxcbiAgICAgICAgICBuZXdCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLCBuZXcgU2l6ZShib3VuZHMud2lkdGggKiBzY2FsZSwgYm91bmRzLmhlaWdodCAqIHNjYWxlKSk7XG4gICAgICBuZXdCb3VuZHMuc2V0Q2VudGVyKHJlY3RhbmdsZS5nZXRDZW50ZXIoKSk7XG4gICAgICB0aGlzLnNldEJvdW5kcyhuZXdCb3VuZHMpO1xuICAgIH1cbiAgfSksIHtcbiAgICBfc2V0U3R5bGVzOiBmdW5jdGlvbiAoY3R4LCBwYXJhbSwgdmlld01hdHJpeCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG4gICAgICAgICAgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuXG4gICAgICBpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5nZXRGaWxsQ29sb3IoKS50b0NhbnZhc1N0eWxlKGN0eCwgbWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKCkudG9DYW52YXNTdHlsZShjdHgsIG1hdHJpeCk7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpO1xuICAgICAgICB2YXIgc3Ryb2tlSm9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcbiAgICAgICAgICAgIHN0cm9rZUNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuICAgICAgICAgICAgbWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKTtcbiAgICAgICAgaWYgKHN0cm9rZUpvaW4pIGN0eC5saW5lSm9pbiA9IHN0cm9rZUpvaW47XG4gICAgICAgIGlmIChzdHJva2VDYXApIGN0eC5saW5lQ2FwID0gc3Ryb2tlQ2FwO1xuICAgICAgICBpZiAobWl0ZXJMaW1pdCkgY3R4Lm1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuXG4gICAgICAgIGlmIChwYXBlci5zdXBwb3J0Lm5hdGl2ZURhc2gpIHtcbiAgICAgICAgICB2YXIgZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG4gICAgICAgICAgICAgIGRhc2hPZmZzZXQgPSBzdHlsZS5nZXREYXNoT2Zmc2V0KCk7XG5cbiAgICAgICAgICBpZiAoZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgnc2V0TGluZURhc2gnIGluIGN0eCkge1xuICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5tb3pEYXNoID0gZGFzaEFycmF5O1xuICAgICAgICAgICAgICBjdHgubW96RGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5oYXNTaGFkb3coKSkge1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHBhcmFtLnBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgICAgIG14ID0gdmlld01hdHJpeC5fc2hpZnRsZXNzKCkucHJlcGVuZChuZXcgTWF0cml4KCkuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbykpLFxuICAgICAgICAgICAgYmx1ciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQoc3R5bGUuZ2V0U2hhZG93Qmx1cigpLCAwKSksXG4gICAgICAgICAgICBvZmZzZXQgPSBteC50cmFuc2Zvcm0odGhpcy5nZXRTaGFkb3dPZmZzZXQoKSk7XG5cbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gc3R5bGUuZ2V0U2hhZG93Q29sb3IoKS50b0NhbnZhc1N0eWxlKGN0eCk7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gYmx1ci5nZXRMZW5ndGgoKTtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBvZmZzZXQueDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBvZmZzZXQueTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIChjdHgsIHBhcmFtLCBwYXJlbnRTdHJva2VNYXRyaXgpIHtcbiAgICAgIHZhciB1cGRhdGVWZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG4gICAgICBpZiAoIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fb3BhY2l0eSA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIG1hdHJpY2VzID0gcGFyYW0ubWF0cmljZXMsXG4gICAgICAgICAgdmlld01hdHJpeCA9IHBhcmFtLnZpZXdNYXRyaXgsXG4gICAgICAgICAgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuICAgICAgICAgIGdsb2JhbE1hdHJpeCA9IG1hdHJpY2VzW21hdHJpY2VzLmxlbmd0aCAtIDFdLmFwcGVuZGVkKG1hdHJpeCk7XG4gICAgICBpZiAoIWdsb2JhbE1hdHJpeC5pc0ludmVydGlibGUoKSkgcmV0dXJuO1xuICAgICAgdmlld01hdHJpeCA9IHZpZXdNYXRyaXggPyB2aWV3TWF0cml4LmFwcGVuZGVkKGdsb2JhbE1hdHJpeCkgOiBnbG9iYWxNYXRyaXg7XG4gICAgICBtYXRyaWNlcy5wdXNoKGdsb2JhbE1hdHJpeCk7XG5cbiAgICAgIGlmIChwYXJhbS51cGRhdGVNYXRyaXgpIHtcbiAgICAgICAgdGhpcy5fZ2xvYmFsTWF0cml4ID0gZ2xvYmFsTWF0cml4O1xuICAgICAgfVxuXG4gICAgICB2YXIgYmxlbmRNb2RlID0gdGhpcy5fYmxlbmRNb2RlLFxuICAgICAgICAgIG9wYWNpdHkgPSBOdW1lcmljYWwuY2xhbXAodGhpcy5fb3BhY2l0eSwgMCwgMSksXG4gICAgICAgICAgbm9ybWFsQmxlbmQgPSBibGVuZE1vZGUgPT09ICdub3JtYWwnLFxuICAgICAgICAgIG5hdGl2ZUJsZW5kID0gQmxlbmRNb2RlLm5hdGl2ZU1vZGVzW2JsZW5kTW9kZV0sXG4gICAgICAgICAgZGlyZWN0ID0gbm9ybWFsQmxlbmQgJiYgb3BhY2l0eSA9PT0gMSB8fCBwYXJhbS5kb250U3RhcnQgfHwgcGFyYW0uY2xpcCB8fCAobmF0aXZlQmxlbmQgfHwgbm9ybWFsQmxlbmQgJiYgb3BhY2l0eSA8IDEpICYmIHRoaXMuX2NhbkNvbXBvc2l0ZSgpLFxuICAgICAgICAgIHBpeGVsUmF0aW8gPSBwYXJhbS5waXhlbFJhdGlvIHx8IDEsXG4gICAgICAgICAgbWFpbkN0eCxcbiAgICAgICAgICBpdGVtT2Zmc2V0LFxuICAgICAgICAgIHByZXZPZmZzZXQ7XG5cbiAgICAgIGlmICghZGlyZWN0KSB7XG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcyh2aWV3TWF0cml4KTtcblxuICAgICAgICBpZiAoIWJvdW5kcy53aWR0aCB8fCAhYm91bmRzLmhlaWdodCkge1xuICAgICAgICAgIG1hdHJpY2VzLnBvcCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZPZmZzZXQgPSBwYXJhbS5vZmZzZXQ7XG4gICAgICAgIGl0ZW1PZmZzZXQgPSBwYXJhbS5vZmZzZXQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCk7XG4gICAgICAgIG1haW5DdHggPSBjdHg7XG4gICAgICAgIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoYm91bmRzLmdldFNpemUoKS5jZWlsKCkuYWRkKDEpLm11bHRpcGx5KHBpeGVsUmF0aW8pKTtcbiAgICAgICAgaWYgKHBpeGVsUmF0aW8gIT09IDEpIGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBzdHJva2VNYXRyaXggPSBwYXJlbnRTdHJva2VNYXRyaXggPyBwYXJlbnRTdHJva2VNYXRyaXguYXBwZW5kZWQobWF0cml4KSA6IHRoaXMuX2NhblNjYWxlU3Ryb2tlICYmICF0aGlzLmdldFN0cm9rZVNjYWxpbmcodHJ1ZSkgJiYgdmlld01hdHJpeCxcbiAgICAgICAgICBjbGlwID0gIWRpcmVjdCAmJiBwYXJhbS5jbGlwSXRlbSxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSAhc3Ryb2tlTWF0cml4IHx8IGNsaXA7XG5cbiAgICAgIGlmIChkaXJlY3QpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgaWYgKG5hdGl2ZUJsZW5kKSBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gYmxlbmRNb2RlO1xuICAgICAgfSBlbHNlIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtaXRlbU9mZnNldC54LCAtaXRlbU9mZnNldC55KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAoZGlyZWN0ID8gbWF0cml4IDogdmlld01hdHJpeCkuYXBwbHlUb0NvbnRleHQoY3R4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgcGFyYW0uY2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7XG4gICAgICAgICAgY2xpcDogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJva2VNYXRyaXgpIHtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcmFtLm9mZnNldDtcbiAgICAgICAgaWYgKG9mZnNldCkgY3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LngsIC1vZmZzZXQueSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RyYXcoY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KTtcblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIG1hdHJpY2VzLnBvcCgpO1xuXG4gICAgICBpZiAocGFyYW0uY2xpcCAmJiAhcGFyYW0uZG9udEZpbmlzaCkge1xuICAgICAgICBjdHguY2xpcCh0aGlzLmdldEZpbGxSdWxlKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdCkge1xuICAgICAgICBCbGVuZE1vZGUucHJvY2VzcyhibGVuZE1vZGUsIGN0eCwgbWFpbkN0eCwgb3BhY2l0eSwgaXRlbU9mZnNldC5zdWJ0cmFjdChwcmV2T2Zmc2V0KS5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG4gICAgICAgIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcbiAgICAgICAgcGFyYW0ub2Zmc2V0ID0gcHJldk9mZnNldDtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9pc1VwZGF0ZWQ6IGZ1bmN0aW9uICh1cGRhdGVWZXJzaW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkgcmV0dXJuIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pO1xuICAgICAgdmFyIHVwZGF0ZWQgPSB0aGlzLl91cGRhdGVWZXJzaW9uID09PSB1cGRhdGVWZXJzaW9uO1xuXG4gICAgICBpZiAoIXVwZGF0ZWQgJiYgcGFyZW50ICYmIHBhcmVudC5fdmlzaWJsZSAmJiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuICAgICAgICB0aGlzLl91cGRhdGVWZXJzaW9uID0gdXBkYXRlVmVyc2lvbjtcbiAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0sXG4gICAgX2RyYXdTZWxlY3Rpb246IGZ1bmN0aW9uIChjdHgsIG1hdHJpeCwgc2l6ZSwgc2VsZWN0aW9uSXRlbXMsIHVwZGF0ZVZlcnNpb24pIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb24sXG4gICAgICAgICAgaXRlbVNlbGVjdGVkID0gc2VsZWN0aW9uICYgMSxcbiAgICAgICAgICBib3VuZHNTZWxlY3RlZCA9IHNlbGVjdGlvbiAmIDIgfHwgaXRlbVNlbGVjdGVkICYmIHRoaXMuX3NlbGVjdEJvdW5kcyxcbiAgICAgICAgICBwb3NpdGlvblNlbGVjdGVkID0gc2VsZWN0aW9uICYgNDtcbiAgICAgIGlmICghdGhpcy5fZHJhd1NlbGVjdGVkKSBpdGVtU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKChpdGVtU2VsZWN0ZWQgfHwgYm91bmRzU2VsZWN0ZWQgfHwgcG9zaXRpb25TZWxlY3RlZCkgJiYgdGhpcy5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pKSB7XG4gICAgICAgIHZhciBsYXllcixcbiAgICAgICAgICAgIGNvbG9yID0gdGhpcy5nZXRTZWxlY3RlZENvbG9yKHRydWUpIHx8IChsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSkgJiYgbGF5ZXIuZ2V0U2VsZWN0ZWRDb2xvcih0cnVlKSxcbiAgICAgICAgICAgIG14ID0gbWF0cml4LmFwcGVuZGVkKHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpKSxcbiAgICAgICAgICAgIGhhbGYgPSBzaXplIC8gMjtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IGNvbG9yID8gY29sb3IudG9DYW52YXNTdHlsZShjdHgpIDogJyMwMDlkZWMnO1xuICAgICAgICBpZiAoaXRlbVNlbGVjdGVkKSB0aGlzLl9kcmF3U2VsZWN0ZWQoY3R4LCBteCwgc2VsZWN0aW9uSXRlbXMpO1xuXG4gICAgICAgIGlmIChwb3NpdGlvblNlbGVjdGVkKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksXG4gICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMuX3BhcmVudCxcbiAgICAgICAgICAgICAgcG9pbnQgPSBwYXJlbnQgPyBwYXJlbnQubG9jYWxUb0dsb2JhbChwb3MpIDogcG9zLFxuICAgICAgICAgICAgICB4ID0gcG9pbnQueCxcbiAgICAgICAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5hcmMoeCwgeSwgaGFsZiwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB2YXIgZGVsdGFzID0gW1swLCAtMV0sIFsxLCAwXSwgWzAsIDFdLCBbLTEsIDBdXSxcbiAgICAgICAgICAgICAgc3RhcnQgPSBoYWxmLFxuICAgICAgICAgICAgICBlbmQgPSBzaXplICsgMTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV0sXG4gICAgICAgICAgICAgICAgZHggPSBkZWx0YVswXSxcbiAgICAgICAgICAgICAgICBkeSA9IGRlbHRhWzFdO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgZHggKiBzdGFydCwgeSArIGR5ICogc3RhcnQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgZHggKiBlbmQsIHkgKyBkeSAqIGVuZCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvdW5kc1NlbGVjdGVkKSB7XG4gICAgICAgICAgdmFyIGNvb3JkcyA9IG14Ll90cmFuc2Zvcm1Db3JuZXJzKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG5cbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgY3R4WyFpID8gJ21vdmVUbycgOiAnbGluZVRvJ10oY29vcmRzW2ldLCBjb29yZHNbKytpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoY29vcmRzW2ldIC0gaGFsZiwgY29vcmRzWysraV0gLSBoYWxmLCBzaXplLCBzaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIEJhc2UuZWFjaChbJ2Rvd24nLCAnZHJhZycsICd1cCcsICdtb3ZlJ10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0aGlzWydyZW1vdmVPbicgKyBCYXNlLmNhcGl0YWxpemUoa2V5KV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGFzaCA9IHt9O1xuICAgICAgaGFzaFtrZXldID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZU9uKGhhc2gpO1xuICAgIH07XG4gIH0sIHtcbiAgICByZW1vdmVPbjogZnVuY3Rpb24gKG9iaikge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9ialtuYW1lXSkge1xuICAgICAgICAgIHZhciBrZXkgPSAnbW91c2UnICsgbmFtZSxcbiAgICAgICAgICAgICAgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG4gICAgICAgICAgICAgIHNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyB8fCB7fTtcbiAgICAgICAgICBzZXRzW2tleV0gPSBzZXRzW2tleV0gfHwge307XG4gICAgICAgICAgc2V0c1trZXldW3RoaXMuX2lkXSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KSwge1xuICAgIHR3ZWVuOiBmdW5jdGlvbiAoZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gdG87XG4gICAgICAgIHRvID0gZnJvbTtcbiAgICAgICAgZnJvbSA9IG51bGw7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRvO1xuICAgICAgICAgIHRvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZWFzaW5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmVhc2luZyxcbiAgICAgICAgICBzdGFydCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zdGFydCxcbiAgICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMgIT0gbnVsbCAmJiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInID8gb3B0aW9ucyA6IG9wdGlvbnMuZHVyYXRpb24pLFxuICAgICAgICAgIHR3ZWVuID0gbmV3IFR3ZWVuKHRoaXMsIGZyb20sIHRvLCBkdXJhdGlvbiwgZWFzaW5nLCBzdGFydCk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRnJhbWUoZXZlbnQpIHtcbiAgICAgICAgdHdlZW4uX2hhbmRsZUZyYW1lKGV2ZW50LnRpbWUgKiAxMDAwKTtcblxuICAgICAgICBpZiAoIXR3ZWVuLnJ1bm5pbmcpIHtcbiAgICAgICAgICB0aGlzLm9mZignZnJhbWUnLCBvbkZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5vbignZnJhbWUnLCBvbkZyYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgIH0sXG4gICAgdHdlZW5UbzogZnVuY3Rpb24gKHRvLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy50d2VlbihudWxsLCB0bywgb3B0aW9ucyk7XG4gICAgfSxcbiAgICB0d2VlbkZyb206IGZ1bmN0aW9uIChmcm9tLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy50d2Vlbihmcm9tLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgR3JvdXAgPSBJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnR3JvdXAnLFxuICAgIF9zZWxlY3RCb3VuZHM6IGZhbHNlLFxuICAgIF9zZWxlY3RDaGlsZHJlbjogdHJ1ZSxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyb3VwKGFyZykge1xuICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgIHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcbiAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKSB0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gX2NoYW5nZWQoZmxhZ3MpIHtcbiAgICAgIF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cbiAgICAgIGlmIChmbGFncyAmIDIwNTApIHtcbiAgICAgICAgdGhpcy5fY2xpcEl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0Q2xpcEl0ZW06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjbGlwSXRlbSA9IHRoaXMuX2NsaXBJdGVtO1xuXG4gICAgICBpZiAoY2xpcEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbGlwSXRlbSA9IG51bGw7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLl9jbGlwTWFzaykge1xuICAgICAgICAgICAgY2xpcEl0ZW0gPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsaXBJdGVtID0gY2xpcEl0ZW07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbGlwSXRlbTtcbiAgICB9LFxuICAgIGlzQ2xpcHBlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcbiAgICB9LFxuICAgIHNldENsaXBwZWQ6IGZ1bmN0aW9uIChjbGlwcGVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChjaGlsZCkgY2hpbGQuc2V0Q2xpcE1hc2soY2xpcHBlZCk7XG4gICAgfSxcbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbiBfZ2V0Qm91bmRzKG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgdmFyIGNsaXBJdGVtID0gdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblxuICAgICAgcmV0dXJuIGNsaXBJdGVtID8gY2xpcEl0ZW0uX2dldENhY2hlZEJvdW5kcyhjbGlwSXRlbS5fbWF0cml4LnByZXBlbmRlZChtYXRyaXgpLCBCYXNlLnNldCh7fSwgb3B0aW9ucywge1xuICAgICAgICBzdHJva2U6IGZhbHNlXG4gICAgICB9KSkgOiBfZ2V0Qm91bmRzLmJhc2UuY2FsbCh0aGlzLCBtYXRyaXgsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgX2hpdFRlc3RDaGlsZHJlbjogZnVuY3Rpb24gX2hpdFRlc3RDaGlsZHJlbihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCkge1xuICAgICAgdmFyIGNsaXBJdGVtID0gdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblxuICAgICAgcmV0dXJuICghY2xpcEl0ZW0gfHwgY2xpcEl0ZW0uY29udGFpbnMocG9pbnQpKSAmJiBfaGl0VGVzdENoaWxkcmVuLmJhc2UuY2FsbCh0aGlzLCBwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCwgY2xpcEl0ZW0pO1xuICAgIH0sXG4gICAgX2RyYXc6IGZ1bmN0aW9uIChjdHgsIHBhcmFtKSB7XG4gICAgICB2YXIgY2xpcCA9IHBhcmFtLmNsaXAsXG4gICAgICAgICAgY2xpcEl0ZW0gPSAhY2xpcCAmJiB0aGlzLl9nZXRDbGlwSXRlbSgpO1xuXG4gICAgICBwYXJhbSA9IHBhcmFtLmV4dGVuZCh7XG4gICAgICAgIGNsaXBJdGVtOiBjbGlwSXRlbSxcbiAgICAgICAgY2xpcDogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY2xpcCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHBhcmFtLmRvbnRTdGFydCA9IHBhcmFtLmRvbnRGaW5pc2ggPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjbGlwSXRlbSkge1xuICAgICAgICBjbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHtcbiAgICAgICAgICBjbGlwOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpdGVtICE9PSBjbGlwSXRlbSkgaXRlbS5kcmF3KGN0eCwgcGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBMYXllciA9IEdyb3VwLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnTGF5ZXInLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIExheWVyKCkge1xuICAgICAgR3JvdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIF9nZXRPd25lcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLl9pbmRleCAhPSBudWxsICYmIHRoaXMuX3Byb2plY3Q7XG4gICAgfSxcbiAgICBpc0luc2VydGVkOiBmdW5jdGlvbiBpc0luc2VydGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IGlzSW5zZXJ0ZWQuYmFzZS5jYWxsKHRoaXMpIDogdGhpcy5faW5kZXggIT0gbnVsbDtcbiAgICB9LFxuICAgIGFjdGl2YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9wcm9qZWN0Ll9hY3RpdmVMYXllciA9IHRoaXM7XG4gICAgfSxcbiAgICBfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uICgpIHt9XG4gIH0pO1xuICB2YXIgU2hhcGUgPSBJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnU2hhcGUnLFxuICAgIF9hcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfY2FuU2NhbGVTdHJva2U6IHRydWUsXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgdHlwZTogbnVsbCxcbiAgICAgIHNpemU6IG51bGwsXG4gICAgICByYWRpdXM6IG51bGxcbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFNoYXBlKHByb3BzLCBwb2ludCkge1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZShwcm9wcywgcG9pbnQpO1xuICAgIH0sXG4gICAgX2VxdWFsczogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl90eXBlID09PSBpdGVtLl90eXBlICYmIHRoaXMuX3NpemUuZXF1YWxzKGl0ZW0uX3NpemUpICYmIEJhc2UuZXF1YWxzKHRoaXMuX3JhZGl1cywgaXRlbS5fcmFkaXVzKTtcbiAgICB9LFxuICAgIGNvcHlDb250ZW50OiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICB0aGlzLnNldFR5cGUoc291cmNlLl90eXBlKTtcbiAgICAgIHRoaXMuc2V0U2l6ZShzb3VyY2UuX3NpemUpO1xuICAgICAgdGhpcy5zZXRSYWRpdXMoc291cmNlLl9yYWRpdXMpO1xuICAgIH0sXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfSxcbiAgICBzZXRUeXBlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgfSxcbiAgICBnZXRTaGFwZTogJyNnZXRUeXBlJyxcbiAgICBzZXRTaGFwZTogJyNzZXRUeXBlJyxcbiAgICBnZXRTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgICByZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG4gICAgfSxcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXG4gICAgICBpZiAoIXRoaXMuX3NpemUpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemUuY2xvbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3NpemUuZXF1YWxzKHNpemUpKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZSxcbiAgICAgICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG4gICAgICAgIGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuICAgICAgICAgIHRoaXMuX3JhZGl1cy5zZXQoU2l6ZS5taW4odGhpcy5fcmFkaXVzLCBzaXplLmRpdmlkZSgyKS5hYnMoKSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQgPSAod2lkdGggKyBoZWlnaHQpIC8gMjtcbiAgICAgICAgICB0aGlzLl9yYWRpdXMgPSB3aWR0aCAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG4gICAgICAgICAgdGhpcy5fcmFkaXVzLl9zZXQod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NpemUuX3NldCh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKDkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmFkID0gdGhpcy5fcmFkaXVzO1xuICAgICAgcmV0dXJuIHRoaXMuX3R5cGUgPT09ICdjaXJjbGUnID8gcmFkIDogbmV3IExpbmtlZFNpemUocmFkLndpZHRoLCByYWQuaGVpZ2h0LCB0aGlzLCAnc2V0UmFkaXVzJyk7XG4gICAgfSxcbiAgICBzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgIGlmIChyYWRpdXMgPT09IHRoaXMuX3JhZGl1cykgcmV0dXJuO1xuICAgICAgICB2YXIgc2l6ZSA9IHJhZGl1cyAqIDI7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblxuICAgICAgICB0aGlzLl9zaXplLl9zZXQoc2l6ZSwgc2l6ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYWRpdXMgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3JhZGl1cykge1xuICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cy5jbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLl9yYWRpdXMuZXF1YWxzKHJhZGl1cykpIHJldHVybjtcblxuICAgICAgICAgIHRoaXMuX3JhZGl1cy5zZXQocmFkaXVzKTtcblxuICAgICAgICAgIGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuICAgICAgICAgICAgdmFyIHNpemUgPSBTaXplLm1heCh0aGlzLl9zaXplLCByYWRpdXMubXVsdGlwbHkoMikpO1xuXG4gICAgICAgICAgICB0aGlzLl9zaXplLnNldChzaXplKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlbGxpcHNlJykge1xuICAgICAgICAgICAgdGhpcy5fc2l6ZS5fc2V0KHJhZGl1cy53aWR0aCAqIDIsIHJhZGl1cy5oZWlnaHQgKiAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hhbmdlZCg5KTtcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHRvUGF0aDogZnVuY3Rpb24gKGluc2VydCkge1xuICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aFtCYXNlLmNhcGl0YWxpemUodGhpcy5fdHlwZSldKHtcbiAgICAgICAgY2VudGVyOiBuZXcgUG9pbnQoKSxcbiAgICAgICAgc2l6ZTogdGhpcy5fc2l6ZSxcbiAgICAgICAgcmFkaXVzOiB0aGlzLl9yYWRpdXMsXG4gICAgICAgIGluc2VydDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcGF0aC5jb3B5QXR0cmlidXRlcyh0aGlzKTtcbiAgICAgIGlmIChwYXBlci5zZXR0aW5ncy5hcHBseU1hdHJpeCkgcGF0aC5zZXRBcHBseU1hdHJpeCh0cnVlKTtcbiAgICAgIGlmIChpbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBpbnNlcnQpIHBhdGguaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuICAgIHRvU2hhcGU6ICcjY2xvbmUnLFxuICAgIF9hc1BhdGhJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1BhdGgoZmFsc2UpO1xuICAgIH0sXG4gICAgX2RyYXc6IGZ1bmN0aW9uIChjdHgsIHBhcmFtLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuICAgICAgICAgIGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG4gICAgICAgICAgaGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG4gICAgICAgICAgZG9udFBhaW50ID0gcGFyYW0uZG9udEZpbmlzaCB8fCBwYXJhbS5jbGlwLFxuICAgICAgICAgIHVudHJhbnNmb3JtZWQgPSAhc3Ryb2tlTWF0cml4O1xuXG4gICAgICBpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgfHwgZG9udFBhaW50KSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZSxcbiAgICAgICAgICAgIHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcbiAgICAgICAgICAgIGlzQ2lyY2xlID0gdHlwZSA9PT0gJ2NpcmNsZSc7XG4gICAgICAgIGlmICghcGFyYW0uZG9udFN0YXJ0KSBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgaWYgKHVudHJhbnNmb3JtZWQgJiYgaXNDaXJjbGUpIHtcbiAgICAgICAgICBjdHguYXJjKDAsIDAsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByeCA9IGlzQ2lyY2xlID8gcmFkaXVzIDogcmFkaXVzLndpZHRoLFxuICAgICAgICAgICAgICByeSA9IGlzQ2lyY2xlID8gcmFkaXVzIDogcmFkaXVzLmhlaWdodCxcbiAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMuX3NpemUsXG4gICAgICAgICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgICBpZiAodW50cmFuc2Zvcm1lZCAmJiB0eXBlID09PSAncmVjdGFuZ2xlJyAmJiByeCA9PT0gMCAmJiByeSA9PT0gMCkge1xuICAgICAgICAgICAgY3R4LnJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgeCA9IHdpZHRoIC8gMixcbiAgICAgICAgICAgICAgICB5ID0gaGVpZ2h0IC8gMixcbiAgICAgICAgICAgICAgICBrYXBwYSA9IDEgLSAwLjU1MjI4NDc0OTgzMDc5MzYsXG4gICAgICAgICAgICAgICAgY3ggPSByeCAqIGthcHBhLFxuICAgICAgICAgICAgICAgIGN5ID0gcnkgKiBrYXBwYSxcbiAgICAgICAgICAgICAgICBjID0gWy14LCAteSArIHJ5LCAteCwgLXkgKyBjeSwgLXggKyBjeCwgLXksIC14ICsgcngsIC15LCB4IC0gcngsIC15LCB4IC0gY3gsIC15LCB4LCAteSArIGN5LCB4LCAteSArIHJ5LCB4LCB5IC0gcnksIHgsIHkgLSBjeSwgeCAtIGN4LCB5LCB4IC0gcngsIHksIC14ICsgcngsIHksIC14ICsgY3gsIHksIC14LCB5IC0gY3ksIC14LCB5IC0gcnldO1xuICAgICAgICAgICAgaWYgKHN0cm9rZU1hdHJpeCkgc3Ryb2tlTWF0cml4LnRyYW5zZm9ybShjLCBjLCAzMik7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNbMF0sIGNbMV0pO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY1syXSwgY1szXSwgY1s0XSwgY1s1XSwgY1s2XSwgY1s3XSk7XG4gICAgICAgICAgICBpZiAoeCAhPT0gcngpIGN0eC5saW5lVG8oY1s4XSwgY1s5XSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjWzEwXSwgY1sxMV0sIGNbMTJdLCBjWzEzXSwgY1sxNF0sIGNbMTVdKTtcbiAgICAgICAgICAgIGlmICh5ICE9PSByeSkgY3R4LmxpbmVUbyhjWzE2XSwgY1sxN10pO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY1sxOF0sIGNbMTldLCBjWzIwXSwgY1syMV0sIGNbMjJdLCBjWzIzXSk7XG4gICAgICAgICAgICBpZiAoeCAhPT0gcngpIGN0eC5saW5lVG8oY1syNF0sIGNbMjVdKTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNbMjZdLCBjWzI3XSwgY1syOF0sIGNbMjldLCBjWzMwXSwgY1szMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuICAgICAgICB0aGlzLl9zZXRTdHlsZXMoY3R4LCBwYXJhbSwgdmlld01hdHJpeCk7XG5cbiAgICAgICAgaWYgKGhhc0ZpbGwpIHtcbiAgICAgICAgICBjdHguZmlsbChzdHlsZS5nZXRGaWxsUnVsZSgpKTtcbiAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU3Ryb2tlKSBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcbiAgICB9LFxuICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uIChtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCksXG4gICAgICAgICAgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpICYmIHN0eWxlLmdldFN0cm9rZVdpZHRoKCk7XG4gICAgICBpZiAobWF0cml4KSByZWN0ID0gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCk7XG4gICAgICByZXR1cm4gc3Ryb2tlV2lkdGggPyByZWN0LmV4cGFuZChQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVdpZHRoLCB0aGlzLl9nZXRTdHJva2VNYXRyaXgobWF0cml4LCBvcHRpb25zKSkpIDogcmVjdDtcbiAgICB9XG4gIH0sIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29ybmVyQ2VudGVyKHRoYXQsIHBvaW50LCBleHBhbmQpIHtcbiAgICAgIHZhciByYWRpdXMgPSB0aGF0Ll9yYWRpdXM7XG5cbiAgICAgIGlmICghcmFkaXVzLmlzWmVybygpKSB7XG4gICAgICAgIHZhciBoYWxmU2l6ZSA9IHRoYXQuX3NpemUuZGl2aWRlKDIpO1xuXG4gICAgICAgIGZvciAodmFyIHEgPSAxOyBxIDw9IDQ7IHErKykge1xuICAgICAgICAgIHZhciBkaXIgPSBuZXcgUG9pbnQocSA+IDEgJiYgcSA8IDQgPyAtMSA6IDEsIHEgPiAyID8gLTEgOiAxKSxcbiAgICAgICAgICAgICAgY29ybmVyID0gZGlyLm11bHRpcGx5KGhhbGZTaXplKSxcbiAgICAgICAgICAgICAgY2VudGVyID0gY29ybmVyLnN1YnRyYWN0KGRpci5tdWx0aXBseShyYWRpdXMpKSxcbiAgICAgICAgICAgICAgcmVjdCA9IG5ldyBSZWN0YW5nbGUoZXhwYW5kID8gY29ybmVyLmFkZChkaXIubXVsdGlwbHkoZXhwYW5kKSkgOiBjb3JuZXIsIGNlbnRlcik7XG4gICAgICAgICAgaWYgKHJlY3QuY29udGFpbnMocG9pbnQpKSByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnQ6IGNlbnRlcixcbiAgICAgICAgICAgIHF1YWRyYW50OiBxXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT25FbGxpcHNlU3Ryb2tlKHBvaW50LCByYWRpdXMsIHBhZGRpbmcsIHF1YWRyYW50KSB7XG4gICAgICB2YXIgdmVjdG9yID0gcG9pbnQuZGl2aWRlKHJhZGl1cyk7XG4gICAgICByZXR1cm4gKCFxdWFkcmFudCB8fCB2ZWN0b3IuaXNJblF1YWRyYW50KHF1YWRyYW50KSkgJiYgdmVjdG9yLnN1YnRyYWN0KHZlY3Rvci5ub3JtYWxpemUoKSkubXVsdGlwbHkocmFkaXVzKS5kaXZpZGUocGFkZGluZykubGVuZ3RoIDw9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIF9jb250YWluczogZnVuY3Rpb24gX2NvbnRhaW5zKHBvaW50KSB7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09PSAncmVjdGFuZ2xlJykge1xuICAgICAgICAgIHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQpO1xuICAgICAgICAgIHJldHVybiBjZW50ZXIgPyBwb2ludC5zdWJ0cmFjdChjZW50ZXIucG9pbnQpLmRpdmlkZSh0aGlzLl9yYWRpdXMpLmdldExlbmd0aCgpIDw9IDEgOiBfY29udGFpbnMuYmFzZS5jYWxsKHRoaXMsIHBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcG9pbnQuZGl2aWRlKHRoaXMuc2l6ZSkuZ2V0TGVuZ3RoKCkgPD0gMC41O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2hpdFRlc3RTZWxmOiBmdW5jdGlvbiBfaGl0VGVzdFNlbGYocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCkge1xuICAgICAgICB2YXIgaGl0ID0gZmFsc2UsXG4gICAgICAgICAgICBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuICAgICAgICAgICAgaGl0U3Ryb2tlID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKCksXG4gICAgICAgICAgICBoaXRGaWxsID0gb3B0aW9ucy5maWxsICYmIHN0eWxlLmhhc0ZpbGwoKTtcblxuICAgICAgICBpZiAoaGl0U3Ryb2tlIHx8IGhpdEZpbGwpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG4gICAgICAgICAgICAgIHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcbiAgICAgICAgICAgICAgc3Ryb2tlUmFkaXVzID0gaGl0U3Ryb2tlID8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIgOiAwLFxuICAgICAgICAgICAgICBzdHJva2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZy5hZGQoUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VSYWRpdXMsICFzdHlsZS5nZXRTdHJva2VTY2FsaW5nKCkgJiYgc3Ryb2tlTWF0cml4KSk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gc3Ryb2tlUGFkZGluZy5tdWx0aXBseSgyKSxcbiAgICAgICAgICAgICAgICBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQsIHBhZGRpbmcpO1xuXG4gICAgICAgICAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgICAgICAgIGhpdCA9IGlzT25FbGxpcHNlU3Ryb2tlKHBvaW50LnN1YnRyYWN0KGNlbnRlci5wb2ludCksIHJhZGl1cywgc3Ryb2tlUGFkZGluZywgY2VudGVyLnF1YWRyYW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCksXG4gICAgICAgICAgICAgICAgICBvdXRlciA9IHJlY3QuZXhwYW5kKHBhZGRpbmcpLFxuICAgICAgICAgICAgICAgICAgaW5uZXIgPSByZWN0LmV4cGFuZChwYWRkaW5nLm5lZ2F0ZSgpKTtcbiAgICAgICAgICAgICAgaGl0ID0gb3V0ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpICYmICFpbm5lci5fY29udGFpbnNQb2ludChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpdCA9IGlzT25FbGxpcHNlU3Ryb2tlKHBvaW50LCByYWRpdXMsIHN0cm9rZVBhZGRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoaXQgPyBuZXcgSGl0UmVzdWx0KGhpdFN0cm9rZSA/ICdzdHJva2UnIDogJ2ZpbGwnLCB0aGlzKSA6IF9oaXRUZXN0U2VsZi5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpLCB7XG4gICAgc3RhdGljczogbmV3IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlKHR5cGUsIHBvaW50LCBzaXplLCByYWRpdXMsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBCYXNlLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUpO1xuICAgICAgICBpdGVtLl90eXBlID0gdHlwZTtcbiAgICAgICAgaXRlbS5fc2l6ZSA9IHNpemU7XG4gICAgICAgIGl0ZW0uX3JhZGl1cyA9IHJhZGl1cztcblxuICAgICAgICBpdGVtLl9pbml0aWFsaXplKEJhc2UuZ2V0TmFtZWQoYXJncyksIHBvaW50KTtcblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgQ2lyY2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyksXG4gICAgICAgICAgICAgIHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlU2hhcGUoJ2NpcmNsZScsIGNlbnRlciwgbmV3IFNpemUocmFkaXVzICogMiksIHJhZGl1cywgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJlY3RhbmdsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyksXG4gICAgICAgICAgICAgIHJhZGl1cyA9IFNpemUubWluKFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKSwgcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVNoYXBlKCdyZWN0YW5nbGUnLCByZWN0LmdldENlbnRlcih0cnVlKSwgcmVjdC5nZXRTaXplKHRydWUpLCByYWRpdXMsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBFbGxpcHNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJncyksXG4gICAgICAgICAgICAgIHJhZGl1cyA9IGVsbGlwc2UucmFkaXVzO1xuXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVNoYXBlKCdlbGxpcHNlJywgZWxsaXBzZS5jZW50ZXIsIHJhZGl1cy5tdWx0aXBseSgyKSwgcmFkaXVzLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3JlYWRFbGxpcHNlOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgIHZhciBjZW50ZXIsIHJhZGl1cztcblxuICAgICAgICAgIGlmIChCYXNlLmhhc05hbWVkKGFyZ3MsICdyYWRpdXMnKSkge1xuICAgICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdjZW50ZXInKTtcbiAgICAgICAgICAgIHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3MsICdyZWN0YW5nbGUnKTtcbiAgICAgICAgICAgIGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuICAgICAgICAgICAgcmFkaXVzID0gcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgICByYWRpdXM6IHJhZGl1c1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSgpXG4gIH0pO1xuICB2YXIgUmFzdGVyID0gSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1Jhc3RlcicsXG4gICAgX2FwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuICAgIF9ib3VuZHNPcHRpb25zOiB7XG4gICAgICBzdHJva2U6IGZhbHNlLFxuICAgICAgaGFuZGxlOiBmYWxzZVxuICAgIH0sXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgICBzb3VyY2U6IG51bGxcbiAgICB9LFxuICAgIF9wcmlvcml0aXplOiBbJ2Nyb3NzT3JpZ2luJ10sXG4gICAgX3Ntb290aGluZzogdHJ1ZSxcbiAgICBiZWFuczogdHJ1ZSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBSYXN0ZXIoc291cmNlLCBwb3NpdGlvbikge1xuICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplKHNvdXJjZSwgcG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cykpKSB7XG4gICAgICAgIHZhciBpbWFnZSxcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlb2Ygc291cmNlLFxuICAgICAgICAgICAgb2JqZWN0ID0gdHlwZSA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzb3VyY2UpIDogdHlwZSA9PT0gJ29iamVjdCcgPyBzb3VyY2UgOiBudWxsO1xuXG4gICAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0ICE9PSBJdGVtLk5PX0lOU0VSVCkge1xuICAgICAgICAgIGlmIChvYmplY3QuZ2V0Q29udGV4dCB8fCBvYmplY3QubmF0dXJhbEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbWFnZSA9IG9iamVjdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKCFzaXplLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgIGltYWdlID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgIHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9zaXplKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBuZXcgU2l6ZSgpO1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9lcXVhbHM6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UoKSA9PT0gaXRlbS5nZXRTb3VyY2UoKTtcbiAgICB9LFxuICAgIGNvcHlDb250ZW50OiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICB2YXIgaW1hZ2UgPSBzb3VyY2UuX2ltYWdlLFxuICAgICAgICAgIGNhbnZhcyA9IHNvdXJjZS5fY2FudmFzO1xuXG4gICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgdGhpcy5fc2V0SW1hZ2UoaW1hZ2UpO1xuICAgICAgfSBlbHNlIGlmIChjYW52YXMpIHtcbiAgICAgICAgdmFyIGNvcHlDYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc291cmNlLl9zaXplKTtcbiAgICAgICAgY29weUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuXG4gICAgICAgIHRoaXMuX3NldEltYWdlKGNvcHlDYW52YXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jcm9zc09yaWdpbiA9IHNvdXJjZS5fY3Jvc3NPcmlnaW47XG4gICAgfSxcbiAgICBnZXRTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgICByZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZSA/IHNpemUud2lkdGggOiAwLCBzaXplID8gc2l6ZS5oZWlnaHQgOiAwLCB0aGlzLCAnc2V0U2l6ZScpO1xuICAgIH0sXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblxuICAgICAgaWYgKCFzaXplLmVxdWFscyh0aGlzLl9zaXplKSkge1xuICAgICAgICBpZiAoc2l6ZS53aWR0aCA+IDAgJiYgc2l6ZS5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblxuICAgICAgICAgIHRoaXMuX3NldEltYWdlKENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKSk7XG5cbiAgICAgICAgICBpZiAoZWxlbWVudCkgdGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShlbGVtZW50LCAwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykgQ2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuICAgICAgICAgIHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUud2lkdGggOiAwO1xuICAgIH0sXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgdGhpcy5zZXRTaXplKHdpZHRoLCB0aGlzLmdldEhlaWdodCgpKTtcbiAgICB9LFxuICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NpemUgPyB0aGlzLl9zaXplLmhlaWdodCA6IDA7XG4gICAgfSxcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZSh0aGlzLmdldFdpZHRoKCksIGhlaWdodCk7XG4gICAgfSxcbiAgICBnZXRMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkZWQ7XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgICByZXR1cm4gIXNpemUgfHwgc2l6ZS53aWR0aCA9PT0gMCAmJiBzaXplLmhlaWdodCA9PT0gMDtcbiAgICB9LFxuICAgIGdldFJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG4gICAgICAgICAgb3JpZyA9IG5ldyBQb2ludCgwLCAwKS50cmFuc2Zvcm0obWF0cml4KSxcbiAgICAgICAgICB1ID0gbmV3IFBvaW50KDEsIDApLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpLFxuICAgICAgICAgIHYgPSBuZXcgUG9pbnQoMCwgMSkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyk7XG4gICAgICByZXR1cm4gbmV3IFNpemUoNzIgLyB1LmdldExlbmd0aCgpLCA3MiAvIHYuZ2V0TGVuZ3RoKCkpO1xuICAgIH0sXG4gICAgZ2V0UHBpOiAnI2dldFJlc29sdXRpb24nLFxuICAgIGdldEltYWdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW1hZ2U7XG4gICAgfSxcbiAgICBzZXRJbWFnZTogZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGF0LmdldFZpZXcoKSxcbiAgICAgICAgICAgIHR5cGUgPSBldmVudCAmJiBldmVudC50eXBlIHx8ICdsb2FkJztcblxuICAgICAgICBpZiAodmlldyAmJiB0aGF0LnJlc3BvbmRzKHR5cGUpKSB7XG4gICAgICAgICAgcGFwZXIgPSB2aWV3Ll9zY29wZTtcbiAgICAgICAgICB0aGF0LmVtaXQodHlwZSwgbmV3IEV2ZW50KGV2ZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0SW1hZ2UoaW1hZ2UpO1xuXG4gICAgICBpZiAodGhpcy5fbG9hZGVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZW1pdCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGltYWdlKSB7XG4gICAgICAgIERvbUV2ZW50LmFkZChpbWFnZSwge1xuICAgICAgICAgIGxvYWQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhhdC5fc2V0SW1hZ2UoaW1hZ2UpO1xuXG4gICAgICAgICAgICBlbWl0KGV2ZW50KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBlbWl0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgX3NldEltYWdlOiBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIGlmICh0aGlzLl9jYW52YXMpIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UodGhpcy5fY2FudmFzKTtcblxuICAgICAgaWYgKGltYWdlICYmIGltYWdlLmdldENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5faW1hZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9ICEhKGltYWdlICYmIGltYWdlLnNyYyAmJiBpbWFnZS5jb21wbGV0ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NpemUgPSBuZXcgU2l6ZShpbWFnZSA/IGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS53aWR0aCA6IDAsIGltYWdlID8gaW1hZ2UubmF0dXJhbEhlaWdodCB8fCBpbWFnZS5oZWlnaHQgOiAwKTtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKDEwMzMpO1xuICAgIH0sXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NhbnZhcykge1xuICAgICAgICB2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCh0aGlzLl9zaXplKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbWFnZSkgY3R4LmRyYXdJbWFnZSh0aGlzLl9pbWFnZSwgMCwgMCk7XG4gICAgICAgICAgdGhpcy5fY2FudmFzID0gY3R4LmNhbnZhcztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICAgIH0sXG4gICAgc2V0Q2FudmFzOiAnI3NldEltYWdlJyxcbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoX2NoYW5nZSkge1xuICAgICAgaWYgKCF0aGlzLl9jb250ZXh0KSB0aGlzLl9jb250ZXh0ID0gdGhpcy5nZXRDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICBpZiAoX2NoYW5nZSkge1xuICAgICAgICB0aGlzLl9pbWFnZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCgxMDI1KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gICAgfSxcbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfSxcbiAgICBnZXRTb3VyY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlO1xuICAgICAgcmV0dXJuIGltYWdlICYmIGltYWdlLnNyYyB8fCB0aGlzLnRvRGF0YVVSTCgpO1xuICAgIH0sXG4gICAgc2V0U291cmNlOiBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICB2YXIgaW1hZ2UgPSBuZXcgc2VsZi5JbWFnZSgpLFxuICAgICAgICAgIGNyb3NzT3JpZ2luID0gdGhpcy5fY3Jvc3NPcmlnaW47XG4gICAgICBpZiAoY3Jvc3NPcmlnaW4pIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICBpZiAoc3JjKSBpbWFnZS5zcmMgPSBzcmM7XG4gICAgICB0aGlzLnNldEltYWdlKGltYWdlKTtcbiAgICB9LFxuICAgIGdldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcbiAgICAgIHJldHVybiBpbWFnZSAmJiBpbWFnZS5jcm9zc09yaWdpbiB8fCB0aGlzLl9jcm9zc09yaWdpbiB8fCAnJztcbiAgICB9LFxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoY3Jvc3NPcmlnaW4pIHtcbiAgICAgIHRoaXMuX2Nyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcbiAgICAgIGlmIChpbWFnZSkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICB9LFxuICAgIGdldFNtb290aGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Ntb290aGluZztcbiAgICB9LFxuICAgIHNldFNtb290aGluZzogZnVuY3Rpb24gKHNtb290aGluZykge1xuICAgICAgdGhpcy5fc21vb3RoaW5nID0gc21vb3RoaW5nO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKDI1Nyk7XG4gICAgfSxcbiAgICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FudmFzIHx8IHRoaXMuX2xvYWRlZCAmJiB0aGlzLl9pbWFnZTtcbiAgICB9XG4gIH0sIHtcbiAgICBiZWFuczogZmFsc2UsXG4gICAgZ2V0U3ViQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChyZWN0LmdldFNpemUoKSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuZ2V0Q2FudmFzKCksIHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCwgMCwgMCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgcmV0dXJuIGN0eC5jYW52YXM7XG4gICAgfSxcbiAgICBnZXRTdWJSYXN0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICByYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblxuICAgICAgcmFzdGVyLl9zZXRJbWFnZSh0aGlzLmdldFN1YkNhbnZhcyhyZWN0KSk7XG5cbiAgICAgIHJhc3Rlci50cmFuc2xhdGUocmVjdC5nZXRDZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLmdldFNpemUoKS5kaXZpZGUoMikpKTtcblxuICAgICAgcmFzdGVyLl9tYXRyaXgucHJlcGVuZCh0aGlzLl9tYXRyaXgpO1xuXG4gICAgICByYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICByZXR1cm4gcmFzdGVyO1xuICAgIH0sXG4gICAgdG9EYXRhVVJMOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcbiAgICAgICAgICBzcmMgPSBpbWFnZSAmJiBpbWFnZS5zcmM7XG4gICAgICBpZiAoL15kYXRhOi8udGVzdChzcmMpKSByZXR1cm4gc3JjO1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgICByZXR1cm4gY2FudmFzID8gY2FudmFzLnRvRGF0YVVSTC5hcHBseShjYW52YXMsIGFyZ3VtZW50cykgOiBudWxsO1xuICAgIH0sXG4gICAgZHJhd0ltYWdlOiBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKTtcbiAgICAgIHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoaW1hZ2UsIHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG4gICAgZ2V0QXZlcmFnZUNvbG9yOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICB2YXIgYm91bmRzLCBwYXRoO1xuXG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBQYXRoSXRlbSkge1xuICAgICAgICBwYXRoID0gb2JqZWN0O1xuICAgICAgICBib3VuZHMgPSBvYmplY3QuZ2V0Qm91bmRzKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICgnd2lkdGgnIGluIG9iamVjdCkge1xuICAgICAgICAgIGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmICgneCcgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgYm91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QueCAtIDAuNSwgb2JqZWN0LnkgLSAwLjUsIDEsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYm91bmRzKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzYW1wbGVTaXplID0gMzIsXG4gICAgICAgICAgd2lkdGggPSBNYXRoLm1pbihib3VuZHMud2lkdGgsIHNhbXBsZVNpemUpLFxuICAgICAgICAgIGhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5oZWlnaHQsIHNhbXBsZVNpemUpO1xuICAgICAgdmFyIGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dDtcblxuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgY3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChuZXcgU2l6ZShzYW1wbGVTaXplKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHNhbXBsZVNpemUgKyAxLCBzYW1wbGVTaXplICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeCgpLnNjYWxlKHdpZHRoIC8gYm91bmRzLndpZHRoLCBoZWlnaHQgLyBib3VuZHMuaGVpZ2h0KS50cmFuc2xhdGUoLWJvdW5kcy54LCAtYm91bmRzLnkpO1xuICAgICAgbWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG4gICAgICBpZiAocGF0aCkgcGF0aC5kcmF3KGN0eCwgbmV3IEJhc2Uoe1xuICAgICAgICBjbGlwOiB0cnVlLFxuICAgICAgICBtYXRyaWNlczogW21hdHJpeF1cbiAgICAgIH0pKTtcblxuICAgICAgdGhpcy5fbWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCksXG4gICAgICAgICAgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgICBpZiAoZWxlbWVudCkgY3R4LmRyYXdJbWFnZShlbGVtZW50LCAtc2l6ZS53aWR0aCAvIDIsIC1zaXplLmhlaWdodCAvIDIpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHZhciBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAuNSwgMC41LCBNYXRoLmNlaWwod2lkdGgpLCBNYXRoLmNlaWwoaGVpZ2h0KSkuZGF0YSxcbiAgICAgICAgICBjaGFubmVscyA9IFswLCAwLCAwXSxcbiAgICAgICAgICB0b3RhbCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICB2YXIgYWxwaGEgPSBwaXhlbHNbaSArIDNdO1xuICAgICAgICB0b3RhbCArPSBhbHBoYTtcbiAgICAgICAgYWxwaGEgLz0gMjU1O1xuICAgICAgICBjaGFubmVsc1swXSArPSBwaXhlbHNbaV0gKiBhbHBoYTtcbiAgICAgICAgY2hhbm5lbHNbMV0gKz0gcGl4ZWxzW2kgKyAxXSAqIGFscGhhO1xuICAgICAgICBjaGFubmVsc1syXSArPSBwaXhlbHNbaSArIDJdICogYWxwaGE7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSBjaGFubmVsc1tpXSAvPSB0b3RhbDtcblxuICAgICAgcmV0dXJuIHRvdGFsID8gQ29sb3IucmVhZChjaGFubmVscykgOiBudWxsO1xuICAgIH0sXG4gICAgZ2V0UGl4ZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKHBvaW50LngsIHBvaW50LnksIDEsIDEpLmRhdGE7XG4gICAgICByZXR1cm4gbmV3IENvbG9yKCdyZ2InLCBbZGF0YVswXSAvIDI1NSwgZGF0YVsxXSAvIDI1NSwgZGF0YVsyXSAvIDI1NV0sIGRhdGFbM10gLyAyNTUpO1xuICAgIH0sXG4gICAgc2V0UGl4ZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHBvaW50ID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICBjb2xvciA9IENvbG9yLnJlYWQoYXJncyksXG4gICAgICAgICAgY29tcG9uZW50cyA9IGNvbG9yLl9jb252ZXJ0KCdyZ2InKSxcbiAgICAgICAgICBhbHBoYSA9IGNvbG9yLl9hbHBoYSxcbiAgICAgICAgICBjdHggPSB0aGlzLmdldENvbnRleHQodHJ1ZSksXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgxLCAxKSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgICAgIGRhdGFbMF0gPSBjb21wb25lbnRzWzBdICogMjU1O1xuICAgICAgZGF0YVsxXSA9IGNvbXBvbmVudHNbMV0gKiAyNTU7XG4gICAgICBkYXRhWzJdID0gY29tcG9uZW50c1syXSAqIDI1NTtcbiAgICAgIGRhdGFbM10gPSBhbHBoYSAhPSBudWxsID8gYWxwaGEgKiAyNTUgOiAyNTU7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgICAgdGhpcy5nZXRDb250ZXh0KHRydWUpLmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoICsgMSwgc2l6ZS5oZWlnaHQgKyAxKTtcbiAgICB9LFxuICAgIGNyZWF0ZUltYWdlRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzLmdldENvbnRleHQoKS5jcmVhdGVJbWFnZURhdGEoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgIH0sXG4gICAgZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVjdC5pc0VtcHR5KCkpIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgIH0sXG4gICAgc2V0SW1hZ2VEYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpO1xuICAgICAgdGhpcy5nZXRDb250ZXh0KHRydWUpLnB1dEltYWdlRGF0YShkYXRhLCBwb2ludC54LCBwb2ludC55KTtcbiAgICB9LFxuICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uIChtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG4gICAgICByZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCkgOiByZWN0O1xuICAgIH0sXG4gICAgX2hpdFRlc3RTZWxmOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLl9jb250YWlucyhwb2ludCkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhpdFJlc3VsdCgncGl4ZWwnLCB0aGF0LCB7XG4gICAgICAgICAgb2Zmc2V0OiBwb2ludC5hZGQodGhhdC5fc2l6ZS5kaXZpZGUoMikpLnJvdW5kKCksXG4gICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhhdC5nZXRQaXhlbCh0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9kcmF3OiBmdW5jdGlvbiAoY3R4LCBwYXJhbSwgdmlld01hdHJpeCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblxuICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC53aWR0aCA+IDAgJiYgZWxlbWVudC5oZWlnaHQgPiAwKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IE51bWVyaWNhbC5jbGFtcCh0aGlzLl9vcGFjaXR5LCAwLCAxKTtcblxuICAgICAgICB0aGlzLl9zZXRTdHlsZXMoY3R4LCBwYXJhbSwgdmlld01hdHJpeCk7XG5cbiAgICAgICAgRG9tRWxlbWVudC5zZXRQcmVmaXhlZChjdHgsICdpbWFnZVNtb290aGluZ0VuYWJsZWQnLCB0aGlzLl9zbW9vdGhpbmcpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGVsZW1lbnQsIC10aGlzLl9zaXplLndpZHRoIC8gMiwgLXRoaXMuX3NpemUuaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgU3ltYm9sSXRlbSA9IEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdTeW1ib2xJdGVtJyxcbiAgICBfYXBwbHlNYXRyaXg6IGZhbHNlLFxuICAgIF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX2JvdW5kc09wdGlvbnM6IHtcbiAgICAgIHN0cm9rZTogdHJ1ZVxuICAgIH0sXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgc3ltYm9sOiBudWxsXG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBTeW1ib2xJdGVtKGFyZzAsIGFyZzEpIHtcbiAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcwLCBhcmcxICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMsIDEpKSkgdGhpcy5zZXREZWZpbml0aW9uKGFyZzAgaW5zdGFuY2VvZiBTeW1ib2xEZWZpbml0aW9uID8gYXJnMCA6IG5ldyBTeW1ib2xEZWZpbml0aW9uKGFyZzApKTtcbiAgICB9LFxuICAgIF9lcXVhbHM6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbiA9PT0gaXRlbS5fZGVmaW5pdGlvbjtcbiAgICB9LFxuICAgIGNvcHlDb250ZW50OiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICB0aGlzLnNldERlZmluaXRpb24oc291cmNlLl9kZWZpbml0aW9uKTtcbiAgICB9LFxuICAgIGdldERlZmluaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuICAgIH0sXG4gICAgc2V0RGVmaW5pdGlvbjogZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgIHRoaXMuX2RlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKDkpO1xuICAgIH0sXG4gICAgZ2V0U3ltYm9sOiAnI2dldERlZmluaXRpb24nLFxuICAgIHNldFN5bWJvbDogJyNzZXREZWZpbml0aW9uJyxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbi5faXRlbS5pc0VtcHR5KCk7XG4gICAgfSxcbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbiAobWF0cml4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuX2RlZmluaXRpb24uX2l0ZW07XG4gICAgICByZXR1cm4gaXRlbS5fZ2V0Q2FjaGVkQm91bmRzKGl0ZW0uX21hdHJpeC5wcmVwZW5kZWQobWF0cml4KSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uIChwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCkge1xuICAgICAgdmFyIG9wdHMgPSBvcHRpb25zLmV4dGVuZCh7XG4gICAgICAgIGFsbDogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVzID0gdGhpcy5fZGVmaW5pdGlvbi5faXRlbS5faGl0VGVzdChwb2ludCwgb3B0cywgdmlld01hdHJpeCk7XG5cbiAgICAgIGlmIChyZXMpIHJlcy5pdGVtID0gdGhpcztcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBfZHJhdzogZnVuY3Rpb24gKGN0eCwgcGFyYW0pIHtcbiAgICAgIHRoaXMuX2RlZmluaXRpb24uX2l0ZW0uZHJhdyhjdHgsIHBhcmFtKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgU3ltYm9sRGVmaW5pdGlvbiA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdTeW1ib2xEZWZpbml0aW9uJyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBTeW1ib2xEZWZpbml0aW9uKGl0ZW0sIGRvbnRDZW50ZXIpIHtcbiAgICAgIHRoaXMuX2lkID0gVUlELmdldCgpO1xuICAgICAgdGhpcy5wcm9qZWN0ID0gcGFwZXIucHJvamVjdDtcbiAgICAgIGlmIChpdGVtKSB0aGlzLnNldEl0ZW0oaXRlbSwgZG9udENlbnRlcik7XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgcmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jbGFzcywgdGhpcy5faXRlbV0sIG9wdGlvbnMsIGZhbHNlLCBkaWN0aW9uYXJ5KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uIChmbGFncykge1xuICAgICAgaWYgKGZsYWdzICYgOCkgSXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcbiAgICAgIGlmIChmbGFncyAmIDEpIHRoaXMucHJvamVjdC5fY2hhbmdlZChmbGFncyk7XG4gICAgfSxcbiAgICBnZXRJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlbTtcbiAgICB9LFxuICAgIHNldEl0ZW06IGZ1bmN0aW9uIChpdGVtLCBfZG9udENlbnRlcikge1xuICAgICAgaWYgKGl0ZW0uX3N5bWJvbCkgaXRlbSA9IGl0ZW0uY2xvbmUoKTtcbiAgICAgIGlmICh0aGlzLl9pdGVtKSB0aGlzLl9pdGVtLl9zeW1ib2wgPSBudWxsO1xuICAgICAgdGhpcy5faXRlbSA9IGl0ZW07XG4gICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgaXRlbS5zZXRTZWxlY3RlZChmYWxzZSk7XG4gICAgICBpZiAoIV9kb250Q2VudGVyKSBpdGVtLnNldFBvc2l0aW9uKG5ldyBQb2ludCgpKTtcbiAgICAgIGl0ZW0uX3N5bWJvbCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoOSk7XG4gICAgfSxcbiAgICBnZXREZWZpbml0aW9uOiAnI2dldEl0ZW0nLFxuICAgIHNldERlZmluaXRpb246ICcjc2V0SXRlbScsXG4gICAgcGxhY2U6IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIG5ldyBTeW1ib2xJdGVtKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFN5bWJvbERlZmluaXRpb24odGhpcy5faXRlbS5jbG9uZShmYWxzZSkpO1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sID09PSB0aGlzIHx8IHN5bWJvbCAmJiB0aGlzLl9pdGVtLmVxdWFscyhzeW1ib2wuX2l0ZW0pIHx8IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBIaXRSZXN1bHQgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnSGl0UmVzdWx0JyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBIaXRSZXN1bHQodHlwZSwgaXRlbSwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAgIGlmICh2YWx1ZXMpIHRoaXMuaW5qZWN0KHZhbHVlcyk7XG4gICAgfSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBnZXRPcHRpb25zOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3MgJiYgQmFzZS5yZWFkKGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV3IEJhc2Uoe1xuICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgdG9sZXJhbmNlOiBwYXBlci5zZXR0aW5ncy5oaXRUb2xlcmFuY2UsXG4gICAgICAgICAgZmlsbDogIW9wdGlvbnMsXG4gICAgICAgICAgc3Ryb2tlOiAhb3B0aW9ucyxcbiAgICAgICAgICBzZWdtZW50czogIW9wdGlvbnMsXG4gICAgICAgICAgaGFuZGxlczogZmFsc2UsXG4gICAgICAgICAgZW5kczogZmFsc2UsXG4gICAgICAgICAgcG9zaXRpb246IGZhbHNlLFxuICAgICAgICAgIGNlbnRlcjogZmFsc2UsXG4gICAgICAgICAgYm91bmRzOiBmYWxzZSxcbiAgICAgICAgICBndWlkZXM6IGZhbHNlLFxuICAgICAgICAgIHNlbGVjdGVkOiBmYWxzZVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgU2VnbWVudCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdTZWdtZW50JyxcbiAgICBiZWFuczogdHJ1ZSxcbiAgICBfc2VsZWN0aW9uOiAwLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnQoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICAgICAgdmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBwb2ludCxcbiAgICAgICAgICBoYW5kbGVJbixcbiAgICAgICAgICBoYW5kbGVPdXQsXG4gICAgICAgICAgc2VsZWN0aW9uO1xuXG4gICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgIGlmIChhcmcwID09IG51bGwgfHwgdHlwZW9mIGFyZzAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID09PSAxICYmIGFyZzAgJiYgJ3BvaW50JyBpbiBhcmcwKSB7XG4gICAgICAgICAgICBwb2ludCA9IGFyZzAucG9pbnQ7XG4gICAgICAgICAgICBoYW5kbGVJbiA9IGFyZzAuaGFuZGxlSW47XG4gICAgICAgICAgICBoYW5kbGVPdXQgPSBhcmcwLmhhbmRsZU91dDtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IGFyZzAuc2VsZWN0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludCA9IGFyZzA7XG4gICAgICAgICAgICBoYW5kbGVJbiA9IGFyZzE7XG4gICAgICAgICAgICBoYW5kbGVPdXQgPSBhcmcyO1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gYXJnMztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnQgPSBbYXJnMCwgYXJnMV07XG4gICAgICAgICAgaGFuZGxlSW4gPSBhcmcyICE9PSB1bmRlZmluZWQgPyBbYXJnMiwgYXJnM10gOiBudWxsO1xuICAgICAgICAgIGhhbmRsZU91dCA9IGFyZzQgIT09IHVuZGVmaW5lZCA/IFthcmc0LCBhcmc1XSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3IFNlZ21lbnRQb2ludChwb2ludCwgdGhpcywgJ19wb2ludCcpO1xuICAgICAgbmV3IFNlZ21lbnRQb2ludChoYW5kbGVJbiwgdGhpcywgJ19oYW5kbGVJbicpO1xuICAgICAgbmV3IFNlZ21lbnRQb2ludChoYW5kbGVPdXQsIHRoaXMsICdfaGFuZGxlT3V0Jyk7XG4gICAgICBpZiAoc2VsZWN0aW9uKSB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMuX3BvaW50LFxuICAgICAgICAgIHNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbixcbiAgICAgICAgICBvYmogPSBzZWxlY3Rpb24gfHwgdGhpcy5oYXNIYW5kbGVzKCkgPyBbcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdIDogcG9pbnQ7XG4gICAgICBpZiAoc2VsZWN0aW9uKSBvYmoucHVzaChzZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKG9iaiwgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICBpZiAoIXBhdGgpIHJldHVybjtcbiAgICAgIHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG4gICAgICAgICAgaW5kZXggPSB0aGlzLl9pbmRleCxcbiAgICAgICAgICBjdXJ2ZTtcblxuICAgICAgaWYgKGN1cnZlcykge1xuICAgICAgICBpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZUluKSAmJiAoY3VydmUgPSBpbmRleCA+IDAgPyBjdXJ2ZXNbaW5kZXggLSAxXSA6IHBhdGguX2Nsb3NlZCA/IGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0gOiBudWxsKSkgY3VydmUuX2NoYW5nZWQoKTtcbiAgICAgICAgaWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVPdXQpICYmIChjdXJ2ZSA9IGN1cnZlc1tpbmRleF0pKSBjdXJ2ZS5fY2hhbmdlZCgpO1xuICAgICAgfVxuXG4gICAgICBwYXRoLl9jaGFuZ2VkKDQxKTtcbiAgICB9LFxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9pbnQ7XG4gICAgfSxcbiAgICBzZXRQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcG9pbnQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBnZXRIYW5kbGVJbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUluO1xuICAgIH0sXG4gICAgc2V0SGFuZGxlSW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUluLnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZ2V0SGFuZGxlT3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlT3V0O1xuICAgIH0sXG4gICAgc2V0SGFuZGxlT3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9oYW5kbGVPdXQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBoYXNIYW5kbGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2hhbmRsZUluLmlzWmVybygpIHx8ICF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCk7XG4gICAgfSxcbiAgICBpc1Ntb290aDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhhbmRsZUluID0gdGhpcy5faGFuZGxlSW4sXG4gICAgICAgICAgaGFuZGxlT3V0ID0gdGhpcy5faGFuZGxlT3V0O1xuICAgICAgcmV0dXJuICFoYW5kbGVJbi5pc1plcm8oKSAmJiAhaGFuZGxlT3V0LmlzWmVybygpICYmIGhhbmRsZUluLmlzQ29sbGluZWFyKGhhbmRsZU91dCk7XG4gICAgfSxcbiAgICBjbGVhckhhbmRsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUluLl9zZXQoMCwgMCk7XG5cbiAgICAgIHRoaXMuX2hhbmRsZU91dC5fc2V0KDAsIDApO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICB2YXIgb2xkU2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uLFxuICAgICAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgdGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uID0gc2VsZWN0aW9uIHx8IDA7XG5cbiAgICAgIGlmIChwYXRoICYmIHNlbGVjdGlvbiAhPT0gb2xkU2VsZWN0aW9uKSB7XG4gICAgICAgIHBhdGguX3VwZGF0ZVNlbGVjdGlvbih0aGlzLCBvbGRTZWxlY3Rpb24sIHNlbGVjdGlvbik7XG5cbiAgICAgICAgcGF0aC5fY2hhbmdlZCgyNTcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NoYW5nZVNlbGVjdGlvbjogZnVuY3Rpb24gKGZsYWcsIHNlbGVjdGVkKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0ZWQgPyBzZWxlY3Rpb24gfCBmbGFnIDogc2VsZWN0aW9uICYgfmZsYWcpO1xuICAgIH0sXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuX3NlbGVjdGlvbiAmIDcpO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgdGhpcy5fY2hhbmdlU2VsZWN0aW9uKDcsIHNlbGVjdGVkKTtcbiAgICB9LFxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcbiAgICB9LFxuICAgIGdldFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXRoIHx8IG51bGw7XG4gICAgfSxcbiAgICBnZXRDdXJ2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuICAgICAgICAgIGluZGV4ID0gdGhpcy5faW5kZXg7XG5cbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIGlmIChpbmRleCA+IDAgJiYgIXBhdGguX2Nsb3NlZCAmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSkgaW5kZXgtLTtcbiAgICAgICAgcmV0dXJuIHBhdGguZ2V0Q3VydmVzKClbaW5kZXhdIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0TG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcbiAgICAgIHJldHVybiBjdXJ2ZSA/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSkgOiBudWxsO1xuICAgIH0sXG4gICAgZ2V0TmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcbiAgICAgIHJldHVybiBzZWdtZW50cyAmJiAoc2VnbWVudHNbdGhpcy5faW5kZXggKyAxXSB8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgc2VnbWVudHNbMF0pIHx8IG51bGw7XG4gICAgfSxcbiAgICBzbW9vdGg6IGZ1bmN0aW9uIChvcHRpb25zLCBfZmlyc3QsIF9sYXN0KSB7XG4gICAgICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgICAgdHlwZSA9IG9wdHMudHlwZSxcbiAgICAgICAgICBmYWN0b3IgPSBvcHRzLmZhY3RvcixcbiAgICAgICAgICBwcmV2ID0gdGhpcy5nZXRQcmV2aW91cygpLFxuICAgICAgICAgIG5leHQgPSB0aGlzLmdldE5leHQoKSxcbiAgICAgICAgICBwMCA9IChwcmV2IHx8IHRoaXMpLl9wb2ludCxcbiAgICAgICAgICBwMSA9IHRoaXMuX3BvaW50LFxuICAgICAgICAgIHAyID0gKG5leHQgfHwgdGhpcykuX3BvaW50LFxuICAgICAgICAgIGQxID0gcDAuZ2V0RGlzdGFuY2UocDEpLFxuICAgICAgICAgIGQyID0gcDEuZ2V0RGlzdGFuY2UocDIpO1xuXG4gICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ2NhdG11bGwtcm9tJykge1xuICAgICAgICB2YXIgYSA9IGZhY3RvciA9PT0gdW5kZWZpbmVkID8gMC41IDogZmFjdG9yLFxuICAgICAgICAgICAgZDFfYSA9IE1hdGgucG93KGQxLCBhKSxcbiAgICAgICAgICAgIGQxXzJhID0gZDFfYSAqIGQxX2EsXG4gICAgICAgICAgICBkMl9hID0gTWF0aC5wb3coZDIsIGEpLFxuICAgICAgICAgICAgZDJfMmEgPSBkMl9hICogZDJfYTtcblxuICAgICAgICBpZiAoIV9maXJzdCAmJiBwcmV2KSB7XG4gICAgICAgICAgdmFyIEEgPSAyICogZDJfMmEgKyAzICogZDJfYSAqIGQxX2EgKyBkMV8yYSxcbiAgICAgICAgICAgICAgTiA9IDMgKiBkMl9hICogKGQyX2EgKyBkMV9hKTtcbiAgICAgICAgICB0aGlzLnNldEhhbmRsZUluKE4gIT09IDAgPyBuZXcgUG9pbnQoKGQyXzJhICogcDAuX3ggKyBBICogcDEuX3ggLSBkMV8yYSAqIHAyLl94KSAvIE4gLSBwMS5feCwgKGQyXzJhICogcDAuX3kgKyBBICogcDEuX3kgLSBkMV8yYSAqIHAyLl95KSAvIE4gLSBwMS5feSkgOiBuZXcgUG9pbnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV9sYXN0ICYmIG5leHQpIHtcbiAgICAgICAgICB2YXIgQSA9IDIgKiBkMV8yYSArIDMgKiBkMV9hICogZDJfYSArIGQyXzJhLFxuICAgICAgICAgICAgICBOID0gMyAqIGQxX2EgKiAoZDFfYSArIGQyX2EpO1xuICAgICAgICAgIHRoaXMuc2V0SGFuZGxlT3V0KE4gIT09IDAgPyBuZXcgUG9pbnQoKGQxXzJhICogcDIuX3ggKyBBICogcDEuX3ggLSBkMl8yYSAqIHAwLl94KSAvIE4gLSBwMS5feCwgKGQxXzJhICogcDIuX3kgKyBBICogcDEuX3kgLSBkMl8yYSAqIHAwLl95KSAvIE4gLSBwMS5feSkgOiBuZXcgUG9pbnQoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2dlb21ldHJpYycpIHtcbiAgICAgICAgaWYgKHByZXYgJiYgbmV4dCkge1xuICAgICAgICAgIHZhciB2ZWN0b3IgPSBwMC5zdWJ0cmFjdChwMiksXG4gICAgICAgICAgICAgIHQgPSBmYWN0b3IgPT09IHVuZGVmaW5lZCA/IDAuNCA6IGZhY3RvcixcbiAgICAgICAgICAgICAgayA9IHQgKiBkMSAvIChkMSArIGQyKTtcbiAgICAgICAgICBpZiAoIV9maXJzdCkgdGhpcy5zZXRIYW5kbGVJbih2ZWN0b3IubXVsdGlwbHkoaykpO1xuICAgICAgICAgIGlmICghX2xhc3QpIHRoaXMuc2V0SGFuZGxlT3V0KHZlY3Rvci5tdWx0aXBseShrIC0gdCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Ntb290aGluZyBtZXRob2QgXFwnJyArIHR5cGUgKyAnXFwnIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQcmV2aW91czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcbiAgICAgIHJldHVybiBzZWdtZW50cyAmJiAoc2VnbWVudHNbdGhpcy5faW5kZXggLSAxXSB8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0pIHx8IG51bGw7XG4gICAgfSxcbiAgICBpc0ZpcnN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2luZGV4O1xuICAgIH0sXG4gICAgaXNMYXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICByZXR1cm4gcGF0aCAmJiB0aGlzLl9pbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoYW5kbGVJbiA9IHRoaXMuX2hhbmRsZUluLFxuICAgICAgICAgIGhhbmRsZU91dCA9IHRoaXMuX2hhbmRsZU91dCxcbiAgICAgICAgICB0bXAgPSBoYW5kbGVJbi5jbG9uZSgpO1xuICAgICAgaGFuZGxlSW4uc2V0KGhhbmRsZU91dCk7XG4gICAgICBoYW5kbGVPdXQuc2V0KHRtcCk7XG4gICAgfSxcbiAgICByZXZlcnNlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTZWdtZW50KHRoaXMuX3BvaW50LCB0aGlzLl9oYW5kbGVPdXQsIHRoaXMuX2hhbmRsZUluKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhdGggPyAhIXRoaXMuX3BhdGgucmVtb3ZlU2VnbWVudCh0aGlzLl9pbmRleCkgOiBmYWxzZTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgcmV0dXJuIHNlZ21lbnQgPT09IHRoaXMgfHwgc2VnbWVudCAmJiB0aGlzLl9jbGFzcyA9PT0gc2VnbWVudC5fY2xhc3MgJiYgdGhpcy5fcG9pbnQuZXF1YWxzKHNlZ21lbnQuX3BvaW50KSAmJiB0aGlzLl9oYW5kbGVJbi5lcXVhbHMoc2VnbWVudC5faGFuZGxlSW4pICYmIHRoaXMuX2hhbmRsZU91dC5lcXVhbHMoc2VnbWVudC5faGFuZGxlT3V0KSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFydHMgPSBbJ3BvaW50OiAnICsgdGhpcy5fcG9pbnRdO1xuICAgICAgaWYgKCF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSkgcGFydHMucHVzaCgnaGFuZGxlSW46ICcgKyB0aGlzLl9oYW5kbGVJbik7XG4gICAgICBpZiAoIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKSkgcGFydHMucHVzaCgnaGFuZGxlT3V0OiAnICsgdGhpcy5faGFuZGxlT3V0KTtcbiAgICAgIHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgbmV3IEFycmF5KDYpLCB0cnVlKTtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH0sXG4gICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgICB2YXIgdSA9IDEgLSBmYWN0b3IsXG4gICAgICAgICAgdiA9IGZhY3RvcixcbiAgICAgICAgICBwb2ludDEgPSBmcm9tLl9wb2ludCxcbiAgICAgICAgICBwb2ludDIgPSB0by5fcG9pbnQsXG4gICAgICAgICAgaGFuZGxlSW4xID0gZnJvbS5faGFuZGxlSW4sXG4gICAgICAgICAgaGFuZGxlSW4yID0gdG8uX2hhbmRsZUluLFxuICAgICAgICAgIGhhbmRsZU91dDIgPSB0by5faGFuZGxlT3V0LFxuICAgICAgICAgIGhhbmRsZU91dDEgPSBmcm9tLl9oYW5kbGVPdXQ7XG5cbiAgICAgIHRoaXMuX3BvaW50Ll9zZXQodSAqIHBvaW50MS5feCArIHYgKiBwb2ludDIuX3gsIHUgKiBwb2ludDEuX3kgKyB2ICogcG9pbnQyLl95LCB0cnVlKTtcblxuICAgICAgdGhpcy5faGFuZGxlSW4uX3NldCh1ICogaGFuZGxlSW4xLl94ICsgdiAqIGhhbmRsZUluMi5feCwgdSAqIGhhbmRsZUluMS5feSArIHYgKiBoYW5kbGVJbjIuX3ksIHRydWUpO1xuXG4gICAgICB0aGlzLl9oYW5kbGVPdXQuX3NldCh1ICogaGFuZGxlT3V0MS5feCArIHYgKiBoYW5kbGVPdXQyLl94LCB1ICogaGFuZGxlT3V0MS5feSArIHYgKiBoYW5kbGVPdXQyLl95LCB0cnVlKTtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH0sXG4gICAgX3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbiAobWF0cml4LCBjb29yZHMsIGNoYW5nZSkge1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5fcG9pbnQsXG4gICAgICAgICAgaGFuZGxlSW4gPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSA/IHRoaXMuX2hhbmRsZUluIDogbnVsbCxcbiAgICAgICAgICBoYW5kbGVPdXQgPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkgPyB0aGlzLl9oYW5kbGVPdXQgOiBudWxsLFxuICAgICAgICAgIHggPSBwb2ludC5feCxcbiAgICAgICAgICB5ID0gcG9pbnQuX3ksXG4gICAgICAgICAgaSA9IDI7XG4gICAgICBjb29yZHNbMF0gPSB4O1xuICAgICAgY29vcmRzWzFdID0geTtcblxuICAgICAgaWYgKGhhbmRsZUluKSB7XG4gICAgICAgIGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3ggKyB4O1xuICAgICAgICBjb29yZHNbaSsrXSA9IGhhbmRsZUluLl95ICsgeTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhbmRsZU91dCkge1xuICAgICAgICBjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feCArIHg7XG4gICAgICAgIGNvb3Jkc1tpKytdID0gaGFuZGxlT3V0Ll95ICsgeTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICBtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCBpIC8gMik7XG5cbiAgICAgICAgeCA9IGNvb3Jkc1swXTtcbiAgICAgICAgeSA9IGNvb3Jkc1sxXTtcblxuICAgICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICAgcG9pbnQuX3ggPSB4O1xuICAgICAgICAgIHBvaW50Ll95ID0geTtcbiAgICAgICAgICBpID0gMjtcblxuICAgICAgICAgIGlmIChoYW5kbGVJbikge1xuICAgICAgICAgICAgaGFuZGxlSW4uX3ggPSBjb29yZHNbaSsrXSAtIHg7XG4gICAgICAgICAgICBoYW5kbGVJbi5feSA9IGNvb3Jkc1tpKytdIC0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlT3V0KSB7XG4gICAgICAgICAgICBoYW5kbGVPdXQuX3ggPSBjb29yZHNbaSsrXSAtIHg7XG4gICAgICAgICAgICBoYW5kbGVPdXQuX3kgPSBjb29yZHNbaSsrXSAtIHk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghaGFuZGxlSW4pIHtcbiAgICAgICAgICAgIGNvb3Jkc1tpKytdID0geDtcbiAgICAgICAgICAgIGNvb3Jkc1tpKytdID0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWhhbmRsZU91dCkge1xuICAgICAgICAgICAgY29vcmRzW2krK10gPSB4O1xuICAgICAgICAgICAgY29vcmRzW2krK10gPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29vcmRzO1xuICAgIH1cbiAgfSk7XG4gIHZhciBTZWdtZW50UG9pbnQgPSBQb2ludC5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnRQb2ludChwb2ludCwgb3duZXIsIGtleSkge1xuICAgICAgdmFyIHgsIHksIHNlbGVjdGVkO1xuXG4gICAgICBpZiAoIXBvaW50KSB7XG4gICAgICAgIHggPSB5ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoKHggPSBwb2ludFswXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5ID0gcG9pbnRbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHQgPSBwb2ludDtcblxuICAgICAgICBpZiAoKHggPSBwdC54KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgICAgeCA9IHB0Lng7XG4gICAgICAgIH1cblxuICAgICAgICB5ID0gcHQueTtcbiAgICAgICAgc2VsZWN0ZWQgPSBwdC5zZWxlY3RlZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICBvd25lcltrZXldID0gdGhpcztcbiAgICAgIGlmIChzZWxlY3RlZCkgdGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcbiAgICB9LFxuICAgIF9zZXQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICB0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRYOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9LFxuICAgIHNldFg6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl94ID0geDtcblxuICAgICAgdGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG4gICAgfSxcbiAgICBnZXRZOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9LFxuICAgIHNldFk6IGZ1bmN0aW9uICh5KSB7XG4gICAgICB0aGlzLl95ID0geTtcblxuICAgICAgdGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG4gICAgfSxcbiAgICBpc1plcm86IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuICAgICAgcmV0dXJuIGlzWmVybyh0aGlzLl94KSAmJiBpc1plcm8odGhpcy5feSk7XG4gICAgfSxcbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISEodGhpcy5fb3duZXIuX3NlbGVjdGlvbiAmIHRoaXMuX2dldFNlbGVjdGlvbigpKTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGVkOiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuX293bmVyLl9jaGFuZ2VTZWxlY3Rpb24odGhpcy5fZ2V0U2VsZWN0aW9uKCksIHNlbGVjdGVkKTtcbiAgICB9LFxuICAgIF9nZXRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuICAgICAgcmV0dXJuIHRoaXMgPT09IG93bmVyLl9wb2ludCA/IDEgOiB0aGlzID09PSBvd25lci5faGFuZGxlSW4gPyAyIDogdGhpcyA9PT0gb3duZXIuX2hhbmRsZU91dCA/IDQgOiAwO1xuICAgIH1cbiAgfSk7XG4gIHZhciBDdXJ2ZSA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdDdXJ2ZScsXG4gICAgYmVhbnM6IHRydWUsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNykge1xuICAgICAgdmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBzZWcxLFxuICAgICAgICAgIHNlZzIsXG4gICAgICAgICAgcG9pbnQxLFxuICAgICAgICAgIHBvaW50MixcbiAgICAgICAgICBoYW5kbGUxLFxuICAgICAgICAgIGhhbmRsZTI7XG5cbiAgICAgIGlmIChjb3VudCA9PT0gMykge1xuICAgICAgICB0aGlzLl9wYXRoID0gYXJnMDtcbiAgICAgICAgc2VnMSA9IGFyZzE7XG4gICAgICAgIHNlZzIgPSBhcmcyO1xuICAgICAgfSBlbHNlIGlmICghY291bnQpIHtcbiAgICAgICAgc2VnMSA9IG5ldyBTZWdtZW50KCk7XG4gICAgICAgIHNlZzIgPSBuZXcgU2VnbWVudCgpO1xuICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICBpZiAoJ3NlZ21lbnQxJyBpbiBhcmcwKSB7XG4gICAgICAgICAgc2VnMSA9IG5ldyBTZWdtZW50KGFyZzAuc2VnbWVudDEpO1xuICAgICAgICAgIHNlZzIgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQyKTtcbiAgICAgICAgfSBlbHNlIGlmICgncG9pbnQxJyBpbiBhcmcwKSB7XG4gICAgICAgICAgcG9pbnQxID0gYXJnMC5wb2ludDE7XG4gICAgICAgICAgaGFuZGxlMSA9IGFyZzAuaGFuZGxlMTtcbiAgICAgICAgICBoYW5kbGUyID0gYXJnMC5oYW5kbGUyO1xuICAgICAgICAgIHBvaW50MiA9IGFyZzAucG9pbnQyO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICBwb2ludDEgPSBbYXJnMFswXSwgYXJnMFsxXV07XG4gICAgICAgICAgcG9pbnQyID0gW2FyZzBbNl0sIGFyZzBbN11dO1xuICAgICAgICAgIGhhbmRsZTEgPSBbYXJnMFsyXSAtIGFyZzBbMF0sIGFyZzBbM10gLSBhcmcwWzFdXTtcbiAgICAgICAgICBoYW5kbGUyID0gW2FyZzBbNF0gLSBhcmcwWzZdLCBhcmcwWzVdIC0gYXJnMFs3XV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDIpIHtcbiAgICAgICAgc2VnMSA9IG5ldyBTZWdtZW50KGFyZzApO1xuICAgICAgICBzZWcyID0gbmV3IFNlZ21lbnQoYXJnMSk7XG4gICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSA0KSB7XG4gICAgICAgIHBvaW50MSA9IGFyZzA7XG4gICAgICAgIGhhbmRsZTEgPSBhcmcxO1xuICAgICAgICBoYW5kbGUyID0gYXJnMjtcbiAgICAgICAgcG9pbnQyID0gYXJnMztcbiAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDgpIHtcbiAgICAgICAgcG9pbnQxID0gW2FyZzAsIGFyZzFdO1xuICAgICAgICBwb2ludDIgPSBbYXJnNiwgYXJnN107XG4gICAgICAgIGhhbmRsZTEgPSBbYXJnMiAtIGFyZzAsIGFyZzMgLSBhcmcxXTtcbiAgICAgICAgaGFuZGxlMiA9IFthcmc0IC0gYXJnNiwgYXJnNSAtIGFyZzddO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZWdtZW50MSA9IHNlZzEgfHwgbmV3IFNlZ21lbnQocG9pbnQxLCBudWxsLCBoYW5kbGUxKTtcbiAgICAgIHRoaXMuX3NlZ21lbnQyID0gc2VnMiB8fCBuZXcgU2VnbWVudChwb2ludDIsIGhhbmRsZTIsIG51bGwpO1xuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcbiAgICAgIHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmhhc0hhbmRsZXMoKSA/IFt0aGlzLmdldFBvaW50MSgpLCB0aGlzLmdldEhhbmRsZTEoKSwgdGhpcy5nZXRIYW5kbGUyKCksIHRoaXMuZ2V0UG9pbnQyKCldIDogW3RoaXMuZ2V0UG9pbnQxKCksIHRoaXMuZ2V0UG9pbnQyKCldLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9sZW5ndGggPSB0aGlzLl9ib3VuZHMgPSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIpO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFsncG9pbnQxOiAnICsgdGhpcy5fc2VnbWVudDEuX3BvaW50XTtcbiAgICAgIGlmICghdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKSkgcGFydHMucHVzaCgnaGFuZGxlMTogJyArIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQpO1xuICAgICAgaWYgKCF0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCkpIHBhcnRzLnB1c2goJ2hhbmRsZTI6ICcgKyB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4pO1xuICAgICAgcGFydHMucHVzaCgncG9pbnQyOiAnICsgdGhpcy5fc2VnbWVudDIuX3BvaW50KTtcbiAgICAgIHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG4gICAgfSxcbiAgICBjbGFzc2lmeTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEN1cnZlLmNsYXNzaWZ5KHRoaXMuZ2V0VmFsdWVzKCkpO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5fcGF0aCkge1xuICAgICAgICB2YXIgc2VnbWVudDIgPSB0aGlzLl9zZWdtZW50MixcbiAgICAgICAgICAgIGhhbmRsZU91dCA9IHNlZ21lbnQyLl9oYW5kbGVPdXQ7XG4gICAgICAgIHJlbW92ZWQgPSBzZWdtZW50Mi5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGhhbmRsZU91dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG4gICAgZ2V0UG9pbnQxOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VnbWVudDEuX3BvaW50O1xuICAgIH0sXG4gICAgc2V0UG9pbnQxOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zZWdtZW50MS5fcG9pbnQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBnZXRQb2ludDI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50Mi5fcG9pbnQ7XG4gICAgfSxcbiAgICBzZXRQb2ludDI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3NlZ21lbnQyLl9wb2ludC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGdldEhhbmRsZTE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0O1xuICAgIH0sXG4gICAgc2V0SGFuZGxlMTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGdldEhhbmRsZTI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW47XG4gICAgfSxcbiAgICBzZXRIYW5kbGUyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBnZXRTZWdtZW50MTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQxO1xuICAgIH0sXG4gICAgZ2V0U2VnbWVudDI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50MjtcbiAgICB9LFxuICAgIGdldFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXRoO1xuICAgIH0sXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50MS5faW5kZXg7XG4gICAgfSxcbiAgICBnZXROZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG4gICAgICByZXR1cm4gY3VydmVzICYmIChjdXJ2ZXNbdGhpcy5fc2VnbWVudDEuX2luZGV4ICsgMV0gfHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIGN1cnZlc1swXSkgfHwgbnVsbDtcbiAgICB9LFxuICAgIGdldFByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG4gICAgICByZXR1cm4gY3VydmVzICYmIChjdXJ2ZXNbdGhpcy5fc2VnbWVudDEuX2luZGV4IC0gMV0gfHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0pIHx8IG51bGw7XG4gICAgfSxcbiAgICBpc0ZpcnN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX3NlZ21lbnQxLl9pbmRleDtcbiAgICB9LFxuICAgIGlzTGFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgcmV0dXJuIHBhdGggJiYgdGhpcy5fc2VnbWVudDEuX2luZGV4ID09PSBwYXRoLl9jdXJ2ZXMubGVuZ3RoIC0gMSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBvaW50MSgpLmlzU2VsZWN0ZWQoKSAmJiB0aGlzLmdldEhhbmRsZTEoKS5pc1NlbGVjdGVkKCkgJiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpICYmIHRoaXMuZ2V0UG9pbnQyKCkuaXNTZWxlY3RlZCgpO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgdGhpcy5nZXRQb2ludDEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG4gICAgICB0aGlzLmdldEhhbmRsZTEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG4gICAgICB0aGlzLmdldEhhbmRsZTIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG4gICAgICB0aGlzLmdldFBvaW50MigpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICB9LFxuICAgIGdldFZhbHVlczogZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgcmV0dXJuIEN1cnZlLmdldFZhbHVlcyh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIsIG1hdHJpeCk7XG4gICAgfSxcbiAgICBnZXRQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldFZhbHVlcygpLFxuICAgICAgICAgIHBvaW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkgKz0gMikgcG9pbnRzLnB1c2gobmV3IFBvaW50KGNvb3Jkc1tpXSwgY29vcmRzW2kgKyAxXSkpO1xuXG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PSBudWxsKSB0aGlzLl9sZW5ndGggPSBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgMCwgMSk7XG4gICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgIH0sXG4gICAgZ2V0QXJlYTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEN1cnZlLmdldEFyZWEodGhpcy5nZXRWYWx1ZXMoKSk7XG4gICAgfSxcbiAgICBnZXRMaW5lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IExpbmUodGhpcy5fc2VnbWVudDEuX3BvaW50LCB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuICAgIH0sXG4gICAgZ2V0UGFydDogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gbmV3IEN1cnZlKEN1cnZlLmdldFBhcnQodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pKTtcbiAgICB9LFxuICAgIGdldFBhcnRMZW5ndGg6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIEN1cnZlLmdldExlbmd0aCh0aGlzLmdldFZhbHVlcygpLCBmcm9tLCB0byk7XG4gICAgfSxcbiAgICBkaXZpZGVBdDogZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXZpZGVBdFRpbWUobG9jYXRpb24gJiYgbG9jYXRpb24uY3VydmUgPT09IHRoaXMgPyBsb2NhdGlvbi50aW1lIDogdGhpcy5nZXRUaW1lQXQobG9jYXRpb24pKTtcbiAgICB9LFxuICAgIGRpdmlkZUF0VGltZTogZnVuY3Rpb24gKHRpbWUsIF9zZXRIYW5kbGVzKSB7XG4gICAgICB2YXIgdE1pbiA9IDFlLTgsXG4gICAgICAgICAgdE1heCA9IDEgLSB0TWluLFxuICAgICAgICAgIHJlcyA9IG51bGw7XG5cbiAgICAgIGlmICh0aW1lID49IHRNaW4gJiYgdGltZSA8PSB0TWF4KSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh0aGlzLmdldFZhbHVlcygpLCB0aW1lKSxcbiAgICAgICAgICAgIGxlZnQgPSBwYXJ0c1swXSxcbiAgICAgICAgICAgIHJpZ2h0ID0gcGFydHNbMV0sXG4gICAgICAgICAgICBzZXRIYW5kbGVzID0gX3NldEhhbmRsZXMgfHwgdGhpcy5oYXNIYW5kbGVzKCksXG4gICAgICAgICAgICBzZWcxID0gdGhpcy5fc2VnbWVudDEsXG4gICAgICAgICAgICBzZWcyID0gdGhpcy5fc2VnbWVudDIsXG4gICAgICAgICAgICBwYXRoID0gdGhpcy5fcGF0aDtcblxuICAgICAgICBpZiAoc2V0SGFuZGxlcykge1xuICAgICAgICAgIHNlZzEuX2hhbmRsZU91dC5fc2V0KGxlZnRbMl0gLSBsZWZ0WzBdLCBsZWZ0WzNdIC0gbGVmdFsxXSk7XG5cbiAgICAgICAgICBzZWcyLl9oYW5kbGVJbi5fc2V0KHJpZ2h0WzRdIC0gcmlnaHRbNl0sIHJpZ2h0WzVdIC0gcmlnaHRbN10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSBsZWZ0WzZdLFxuICAgICAgICAgICAgeSA9IGxlZnRbN10sXG4gICAgICAgICAgICBzZWdtZW50ID0gbmV3IFNlZ21lbnQobmV3IFBvaW50KHgsIHkpLCBzZXRIYW5kbGVzICYmIG5ldyBQb2ludChsZWZ0WzRdIC0geCwgbGVmdFs1XSAtIHkpLCBzZXRIYW5kbGVzICYmIG5ldyBQb2ludChyaWdodFsyXSAtIHgsIHJpZ2h0WzNdIC0geSkpO1xuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgcGF0aC5pbnNlcnQoc2VnMS5faW5kZXggKyAxLCBzZWdtZW50KTtcbiAgICAgICAgICByZXMgPSB0aGlzLmdldE5leHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZWdtZW50MiA9IHNlZ21lbnQ7XG5cbiAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG5cbiAgICAgICAgICByZXMgPSBuZXcgQ3VydmUoc2VnbWVudCwgc2VnMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIHNwbGl0QXQ6IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgcmV0dXJuIHBhdGggPyBwYXRoLnNwbGl0QXQobG9jYXRpb24pIDogbnVsbDtcbiAgICB9LFxuICAgIHNwbGl0QXRUaW1lOiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaXRBdCh0aGlzLmdldExvY2F0aW9uQXRUaW1lKHRpbWUpKTtcbiAgICB9LFxuICAgIGRpdmlkZTogZnVuY3Rpb24gKG9mZnNldCwgaXNUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXZpZGVBdFRpbWUob2Zmc2V0ID09PSB1bmRlZmluZWQgPyAwLjUgOiBpc1RpbWUgPyBvZmZzZXQgOiB0aGlzLmdldFRpbWVBdChvZmZzZXQpKTtcbiAgICB9LFxuICAgIHNwbGl0OiBmdW5jdGlvbiAob2Zmc2V0LCBpc1RpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGl0QXRUaW1lKG9mZnNldCA9PT0gdW5kZWZpbmVkID8gMC41IDogaXNUaW1lID8gb2Zmc2V0IDogdGhpcy5nZXRUaW1lQXQob2Zmc2V0KSk7XG4gICAgfSxcbiAgICByZXZlcnNlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50Mi5yZXZlcnNlZCgpLCB0aGlzLl9zZWdtZW50MS5yZXZlcnNlZCgpKTtcbiAgICB9LFxuICAgIGNsZWFySGFuZGxlczogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5fc2V0KDAsIDApO1xuXG4gICAgICB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uX3NldCgwLCAwKTtcbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIGdldFZhbHVlczogZnVuY3Rpb24gKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4LCBzdHJhaWdodCkge1xuICAgICAgICB2YXIgcDEgPSBzZWdtZW50MS5fcG9pbnQsXG4gICAgICAgICAgICBoMSA9IHNlZ21lbnQxLl9oYW5kbGVPdXQsXG4gICAgICAgICAgICBoMiA9IHNlZ21lbnQyLl9oYW5kbGVJbixcbiAgICAgICAgICAgIHAyID0gc2VnbWVudDIuX3BvaW50LFxuICAgICAgICAgICAgeDEgPSBwMS54LFxuICAgICAgICAgICAgeTEgPSBwMS55LFxuICAgICAgICAgICAgeDIgPSBwMi54LFxuICAgICAgICAgICAgeTIgPSBwMi55LFxuICAgICAgICAgICAgdmFsdWVzID0gc3RyYWlnaHQgPyBbeDEsIHkxLCB4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXSA6IFt4MSwgeTEsIHgxICsgaDEuX3gsIHkxICsgaDEuX3ksIHgyICsgaDIuX3gsIHkyICsgaDIuX3ksIHgyLCB5Ml07XG4gICAgICAgIGlmIChtYXRyaXgpIG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXModmFsdWVzLCB2YWx1ZXMsIDQpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSxcbiAgICAgIHN1YmRpdmlkZTogZnVuY3Rpb24gKHYsIHQpIHtcbiAgICAgICAgdmFyIHgwID0gdlswXSxcbiAgICAgICAgICAgIHkwID0gdlsxXSxcbiAgICAgICAgICAgIHgxID0gdlsyXSxcbiAgICAgICAgICAgIHkxID0gdlszXSxcbiAgICAgICAgICAgIHgyID0gdls0XSxcbiAgICAgICAgICAgIHkyID0gdls1XSxcbiAgICAgICAgICAgIHgzID0gdls2XSxcbiAgICAgICAgICAgIHkzID0gdls3XTtcbiAgICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgdCA9IDAuNTtcbiAgICAgICAgdmFyIHUgPSAxIC0gdCxcbiAgICAgICAgICAgIHg0ID0gdSAqIHgwICsgdCAqIHgxLFxuICAgICAgICAgICAgeTQgPSB1ICogeTAgKyB0ICogeTEsXG4gICAgICAgICAgICB4NSA9IHUgKiB4MSArIHQgKiB4MixcbiAgICAgICAgICAgIHk1ID0gdSAqIHkxICsgdCAqIHkyLFxuICAgICAgICAgICAgeDYgPSB1ICogeDIgKyB0ICogeDMsXG4gICAgICAgICAgICB5NiA9IHUgKiB5MiArIHQgKiB5MyxcbiAgICAgICAgICAgIHg3ID0gdSAqIHg0ICsgdCAqIHg1LFxuICAgICAgICAgICAgeTcgPSB1ICogeTQgKyB0ICogeTUsXG4gICAgICAgICAgICB4OCA9IHUgKiB4NSArIHQgKiB4NixcbiAgICAgICAgICAgIHk4ID0gdSAqIHk1ICsgdCAqIHk2LFxuICAgICAgICAgICAgeDkgPSB1ICogeDcgKyB0ICogeDgsXG4gICAgICAgICAgICB5OSA9IHUgKiB5NyArIHQgKiB5ODtcbiAgICAgICAgcmV0dXJuIFtbeDAsIHkwLCB4NCwgeTQsIHg3LCB5NywgeDksIHk5XSwgW3g5LCB5OSwgeDgsIHk4LCB4NiwgeTYsIHgzLCB5M11dO1xuICAgICAgfSxcbiAgICAgIGdldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uICh2LCBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnZlcyA9IFtdLFxuICAgICAgICAgICAgaW8gPSBkaXIgPyAwIDogMSxcbiAgICAgICAgICAgIG8wID0gdltpbyArIDBdLFxuICAgICAgICAgICAgbzEgPSB2W2lvICsgMl0sXG4gICAgICAgICAgICBvMiA9IHZbaW8gKyA0XSxcbiAgICAgICAgICAgIG8zID0gdltpbyArIDZdO1xuXG4gICAgICAgIGlmIChvMCA+PSBvMSA9PT0gbzEgPj0gbzIgJiYgbzEgPj0gbzIgPT09IG8yID49IG8zIHx8IEN1cnZlLmlzU3RyYWlnaHQodikpIHtcbiAgICAgICAgICBjdXJ2ZXMucHVzaCh2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYSA9IDMgKiAobzEgLSBvMikgLSBvMCArIG8zLFxuICAgICAgICAgICAgICBiID0gMiAqIChvMCArIG8yKSAtIDQgKiBvMSxcbiAgICAgICAgICAgICAgYyA9IG8xIC0gbzAsXG4gICAgICAgICAgICAgIHRNaW4gPSAxZS04LFxuICAgICAgICAgICAgICB0TWF4ID0gMSAtIHRNaW4sXG4gICAgICAgICAgICAgIHJvb3RzID0gW10sXG4gICAgICAgICAgICAgIG4gPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgcm9vdHMsIHRNaW4sIHRNYXgpO1xuXG4gICAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgICBjdXJ2ZXMucHVzaCh2KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9vdHMuc29ydCgpO1xuICAgICAgICAgICAgdmFyIHQgPSByb290c1swXSxcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2LCB0KTtcbiAgICAgICAgICAgIGN1cnZlcy5wdXNoKHBhcnRzWzBdKTtcblxuICAgICAgICAgICAgaWYgKG4gPiAxKSB7XG4gICAgICAgICAgICAgIHQgPSAocm9vdHNbMV0gLSB0KSAvICgxIC0gdCk7XG4gICAgICAgICAgICAgIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHBhcnRzWzFdLCB0KTtcbiAgICAgICAgICAgICAgY3VydmVzLnB1c2gocGFydHNbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJ2ZXMucHVzaChwYXJ0c1sxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnZlcztcbiAgICAgIH0sXG4gICAgICBzb2x2ZUN1YmljOiBmdW5jdGlvbiAodiwgY29vcmQsIHZhbCwgcm9vdHMsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciB2MCA9IHZbY29vcmRdLFxuICAgICAgICAgICAgdjEgPSB2W2Nvb3JkICsgMl0sXG4gICAgICAgICAgICB2MiA9IHZbY29vcmQgKyA0XSxcbiAgICAgICAgICAgIHYzID0gdltjb29yZCArIDZdLFxuICAgICAgICAgICAgcmVzID0gMDtcblxuICAgICAgICBpZiAoISh2MCA8IHZhbCAmJiB2MyA8IHZhbCAmJiB2MSA8IHZhbCAmJiB2MiA8IHZhbCB8fCB2MCA+IHZhbCAmJiB2MyA+IHZhbCAmJiB2MSA+IHZhbCAmJiB2MiA+IHZhbCkpIHtcbiAgICAgICAgICB2YXIgYyA9IDMgKiAodjEgLSB2MCksXG4gICAgICAgICAgICAgIGIgPSAzICogKHYyIC0gdjEpIC0gYyxcbiAgICAgICAgICAgICAgYSA9IHYzIC0gdjAgLSBjIC0gYjtcbiAgICAgICAgICByZXMgPSBOdW1lcmljYWwuc29sdmVDdWJpYyhhLCBiLCBjLCB2MCAtIHZhbCwgcm9vdHMsIG1pbiwgbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9LFxuICAgICAgZ2V0VGltZU9mOiBmdW5jdGlvbiAodiwgcG9pbnQpIHtcbiAgICAgICAgdmFyIHAwID0gbmV3IFBvaW50KHZbMF0sIHZbMV0pLFxuICAgICAgICAgICAgcDMgPSBuZXcgUG9pbnQodls2XSwgdls3XSksXG4gICAgICAgICAgICBlcHNpbG9uID0gMWUtMTIsXG4gICAgICAgICAgICBnZW9tRXBzaWxvbiA9IDFlLTcsXG4gICAgICAgICAgICB0ID0gcG9pbnQuaXNDbG9zZShwMCwgZXBzaWxvbikgPyAwIDogcG9pbnQuaXNDbG9zZShwMywgZXBzaWxvbikgPyAxIDogbnVsbDtcblxuICAgICAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciBjb29yZHMgPSBbcG9pbnQueCwgcG9pbnQueV0sXG4gICAgICAgICAgICAgIHJvb3RzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDI7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gQ3VydmUuc29sdmVDdWJpYyh2LCBjLCBjb29yZHNbY10sIHJvb3RzLCAwLCAxKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciB1ID0gcm9vdHNbaV07XG4gICAgICAgICAgICAgIGlmIChwb2ludC5pc0Nsb3NlKEN1cnZlLmdldFBvaW50KHYsIHUpLCBnZW9tRXBzaWxvbikpIHJldHVybiB1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2ludC5pc0Nsb3NlKHAwLCBnZW9tRXBzaWxvbikgPyAwIDogcG9pbnQuaXNDbG9zZShwMywgZ2VvbUVwc2lsb24pID8gMSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgZ2V0TmVhcmVzdFRpbWU6IGZ1bmN0aW9uICh2LCBwb2ludCkge1xuICAgICAgICBpZiAoQ3VydmUuaXNTdHJhaWdodCh2KSkge1xuICAgICAgICAgIHZhciB4MCA9IHZbMF0sXG4gICAgICAgICAgICAgIHkwID0gdlsxXSxcbiAgICAgICAgICAgICAgeDMgPSB2WzZdLFxuICAgICAgICAgICAgICB5MyA9IHZbN10sXG4gICAgICAgICAgICAgIHZ4ID0geDMgLSB4MCxcbiAgICAgICAgICAgICAgdnkgPSB5MyAtIHkwLFxuICAgICAgICAgICAgICBkZXQgPSB2eCAqIHZ4ICsgdnkgKiB2eTtcbiAgICAgICAgICBpZiAoZGV0ID09PSAwKSByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgdSA9ICgocG9pbnQueCAtIHgwKSAqIHZ4ICsgKHBvaW50LnkgLSB5MCkgKiB2eSkgLyBkZXQ7XG4gICAgICAgICAgcmV0dXJuIHUgPCAxZS0xMiA/IDAgOiB1ID4gMC45OTk5OTk5OTk5OTkgPyAxIDogQ3VydmUuZ2V0VGltZU9mKHYsIG5ldyBQb2ludCh4MCArIHUgKiB2eCwgeTAgKyB1ICogdnkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb3VudCA9IDEwMCxcbiAgICAgICAgICAgIG1pbkRpc3QgPSBJbmZpbml0eSxcbiAgICAgICAgICAgIG1pblQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlZmluZSh0KSB7XG4gICAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gcG9pbnQuZ2V0RGlzdGFuY2UoQ3VydmUuZ2V0UG9pbnQodiwgdCksIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgIG1pblQgPSB0O1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudDsgaSsrKSByZWZpbmUoaSAvIGNvdW50KTtcblxuICAgICAgICB2YXIgc3RlcCA9IDEgLyAoY291bnQgKiAyKTtcblxuICAgICAgICB3aGlsZSAoc3RlcCA+IDFlLTgpIHtcbiAgICAgICAgICBpZiAoIXJlZmluZShtaW5UIC0gc3RlcCkgJiYgIXJlZmluZShtaW5UICsgc3RlcCkpIHN0ZXAgLz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW5UO1xuICAgICAgfSxcbiAgICAgIGdldFBhcnQ6IGZ1bmN0aW9uICh2LCBmcm9tLCB0bykge1xuICAgICAgICB2YXIgZmxpcCA9IGZyb20gPiB0bztcblxuICAgICAgICBpZiAoZmxpcCkge1xuICAgICAgICAgIHZhciB0bXAgPSBmcm9tO1xuICAgICAgICAgIGZyb20gPSB0bztcbiAgICAgICAgICB0byA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tID4gMCkgdiA9IEN1cnZlLnN1YmRpdmlkZSh2LCBmcm9tKVsxXTtcbiAgICAgICAgaWYgKHRvIDwgMSkgdiA9IEN1cnZlLnN1YmRpdmlkZSh2LCAodG8gLSBmcm9tKSAvICgxIC0gZnJvbSkpWzBdO1xuICAgICAgICByZXR1cm4gZmxpcCA/IFt2WzZdLCB2WzddLCB2WzRdLCB2WzVdLCB2WzJdLCB2WzNdLCB2WzBdLCB2WzFdXSA6IHY7XG4gICAgICB9LFxuICAgICAgaXNGbGF0RW5vdWdoOiBmdW5jdGlvbiAodiwgZmxhdG5lc3MpIHtcbiAgICAgICAgdmFyIHgwID0gdlswXSxcbiAgICAgICAgICAgIHkwID0gdlsxXSxcbiAgICAgICAgICAgIHgxID0gdlsyXSxcbiAgICAgICAgICAgIHkxID0gdlszXSxcbiAgICAgICAgICAgIHgyID0gdls0XSxcbiAgICAgICAgICAgIHkyID0gdls1XSxcbiAgICAgICAgICAgIHgzID0gdls2XSxcbiAgICAgICAgICAgIHkzID0gdls3XSxcbiAgICAgICAgICAgIHV4ID0gMyAqIHgxIC0gMiAqIHgwIC0geDMsXG4gICAgICAgICAgICB1eSA9IDMgKiB5MSAtIDIgKiB5MCAtIHkzLFxuICAgICAgICAgICAgdnggPSAzICogeDIgLSAyICogeDMgLSB4MCxcbiAgICAgICAgICAgIHZ5ID0gMyAqIHkyIC0gMiAqIHkzIC0geTA7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh1eCAqIHV4LCB2eCAqIHZ4KSArIE1hdGgubWF4KHV5ICogdXksIHZ5ICogdnkpIDw9IDE2ICogZmxhdG5lc3MgKiBmbGF0bmVzcztcbiAgICAgIH0sXG4gICAgICBnZXRBcmVhOiBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgeDAgPSB2WzBdLFxuICAgICAgICAgICAgeTAgPSB2WzFdLFxuICAgICAgICAgICAgeDEgPSB2WzJdLFxuICAgICAgICAgICAgeTEgPSB2WzNdLFxuICAgICAgICAgICAgeDIgPSB2WzRdLFxuICAgICAgICAgICAgeTIgPSB2WzVdLFxuICAgICAgICAgICAgeDMgPSB2WzZdLFxuICAgICAgICAgICAgeTMgPSB2WzddO1xuICAgICAgICByZXR1cm4gMyAqICgoeTMgLSB5MCkgKiAoeDEgKyB4MikgLSAoeDMgLSB4MCkgKiAoeTEgKyB5MikgKyB5MSAqICh4MCAtIHgyKSAtIHgxICogKHkwIC0geTIpICsgeTMgKiAoeDIgKyB4MCAvIDMpIC0geDMgKiAoeTIgKyB5MCAvIDMpKSAvIDIwO1xuICAgICAgfSxcbiAgICAgIGdldEJvdW5kczogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG1pbiA9IHYuc2xpY2UoMCwgMiksXG4gICAgICAgICAgICBtYXggPSBtaW4uc2xpY2UoKSxcbiAgICAgICAgICAgIHJvb3RzID0gWzAsIDBdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSBDdXJ2ZS5fYWRkQm91bmRzKHZbaV0sIHZbaSArIDJdLCB2W2kgKyA0XSwgdltpICsgNl0sIGksIDAsIG1pbiwgbWF4LCByb290cyk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcbiAgICAgIH0sXG4gICAgICBfYWRkQm91bmRzOiBmdW5jdGlvbiAodjAsIHYxLCB2MiwgdjMsIGNvb3JkLCBwYWRkaW5nLCBtaW4sIG1heCwgcm9vdHMpIHtcbiAgICAgICAgZnVuY3Rpb24gYWRkKHZhbHVlLCBwYWRkaW5nKSB7XG4gICAgICAgICAgdmFyIGxlZnQgPSB2YWx1ZSAtIHBhZGRpbmcsXG4gICAgICAgICAgICAgIHJpZ2h0ID0gdmFsdWUgKyBwYWRkaW5nO1xuICAgICAgICAgIGlmIChsZWZ0IDwgbWluW2Nvb3JkXSkgbWluW2Nvb3JkXSA9IGxlZnQ7XG4gICAgICAgICAgaWYgKHJpZ2h0ID4gbWF4W2Nvb3JkXSkgbWF4W2Nvb3JkXSA9IHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcGFkZGluZyAvPSAyO1xuICAgICAgICB2YXIgbWluUGFkID0gbWluW2Nvb3JkXSArIHBhZGRpbmcsXG4gICAgICAgICAgICBtYXhQYWQgPSBtYXhbY29vcmRdIC0gcGFkZGluZztcblxuICAgICAgICBpZiAodjAgPCBtaW5QYWQgfHwgdjEgPCBtaW5QYWQgfHwgdjIgPCBtaW5QYWQgfHwgdjMgPCBtaW5QYWQgfHwgdjAgPiBtYXhQYWQgfHwgdjEgPiBtYXhQYWQgfHwgdjIgPiBtYXhQYWQgfHwgdjMgPiBtYXhQYWQpIHtcbiAgICAgICAgICBpZiAodjEgPCB2MCAhPSB2MSA8IHYzICYmIHYyIDwgdjAgIT0gdjIgPCB2Mykge1xuICAgICAgICAgICAgYWRkKHYwLCAwKTtcbiAgICAgICAgICAgIGFkZCh2MywgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhID0gMyAqICh2MSAtIHYyKSAtIHYwICsgdjMsXG4gICAgICAgICAgICAgICAgYiA9IDIgKiAodjAgKyB2MikgLSA0ICogdjEsXG4gICAgICAgICAgICAgICAgYyA9IHYxIC0gdjAsXG4gICAgICAgICAgICAgICAgY291bnQgPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgcm9vdHMpLFxuICAgICAgICAgICAgICAgIHRNaW4gPSAxZS04LFxuICAgICAgICAgICAgICAgIHRNYXggPSAxIC0gdE1pbjtcbiAgICAgICAgICAgIGFkZCh2MywgMCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgdCA9IHJvb3RzW2ldLFxuICAgICAgICAgICAgICAgICAgdSA9IDEgLSB0O1xuICAgICAgICAgICAgICBpZiAodE1pbiA8PSB0ICYmIHQgPD0gdE1heCkgYWRkKHUgKiB1ICogdSAqIHYwICsgMyAqIHUgKiB1ICogdCAqIHYxICsgMyAqIHUgKiB0ICogdCAqIHYyICsgdCAqIHQgKiB0ICogdjMsIHBhZGRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgQmFzZS5lYWNoKFsnZ2V0Qm91bmRzJywgJ2dldFN0cm9rZUJvdW5kcycsICdnZXRIYW5kbGVCb3VuZHMnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9ib3VuZHMpIHRoaXMuX2JvdW5kcyA9IHt9O1xuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kc1tuYW1lXTtcblxuICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgYm91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdID0gUGF0aFtuYW1lXShbdGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyXSwgZmFsc2UsIHRoaXMuX3BhdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm91bmRzLmNsb25lKCk7XG4gICAgfTtcbiAgfSwge30pLCBCYXNlLmVhY2goe1xuICAgIGlzU3RyYWlnaHQ6IGZ1bmN0aW9uIChwMSwgaDEsIGgyLCBwMikge1xuICAgICAgaWYgKGgxLmlzWmVybygpICYmIGgyLmlzWmVybygpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHYgPSBwMi5zdWJ0cmFjdChwMSk7XG5cbiAgICAgICAgaWYgKHYuaXNaZXJvKCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodi5pc0NvbGxpbmVhcihoMSkgJiYgdi5pc0NvbGxpbmVhcihoMikpIHtcbiAgICAgICAgICB2YXIgbCA9IG5ldyBMaW5lKHAxLCBwMiksXG4gICAgICAgICAgICAgIGVwc2lsb24gPSAxZS03O1xuXG4gICAgICAgICAgaWYgKGwuZ2V0RGlzdGFuY2UocDEuYWRkKGgxKSkgPCBlcHNpbG9uICYmIGwuZ2V0RGlzdGFuY2UocDIuYWRkKGgyKSkgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICB2YXIgZGl2ID0gdi5kb3QodiksXG4gICAgICAgICAgICAgICAgczEgPSB2LmRvdChoMSkgLyBkaXYsXG4gICAgICAgICAgICAgICAgczIgPSB2LmRvdChoMikgLyBkaXY7XG4gICAgICAgICAgICByZXR1cm4gczEgPj0gMCAmJiBzMSA8PSAxICYmIHMyIDw9IDAgJiYgczIgPj0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGlzTGluZWFyOiBmdW5jdGlvbiAocDEsIGgxLCBoMiwgcDIpIHtcbiAgICAgIHZhciB0aGlyZCA9IHAyLnN1YnRyYWN0KHAxKS5kaXZpZGUoMyk7XG4gICAgICByZXR1cm4gaDEuZXF1YWxzKHRoaXJkKSAmJiBoMi5uZWdhdGUoKS5lcXVhbHModGhpcmQpO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKHRlc3QsIG5hbWUpIHtcbiAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKGVwc2lsb24pIHtcbiAgICAgIHZhciBzZWcxID0gdGhpcy5fc2VnbWVudDEsXG4gICAgICAgICAgc2VnMiA9IHRoaXMuX3NlZ21lbnQyO1xuICAgICAgcmV0dXJuIHRlc3Qoc2VnMS5fcG9pbnQsIHNlZzEuX2hhbmRsZU91dCwgc2VnMi5faGFuZGxlSW4sIHNlZzIuX3BvaW50LCBlcHNpbG9uKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdGF0aWNzW25hbWVdID0gZnVuY3Rpb24gKHYsIGVwc2lsb24pIHtcbiAgICAgIHZhciB4MCA9IHZbMF0sXG4gICAgICAgICAgeTAgPSB2WzFdLFxuICAgICAgICAgIHgzID0gdls2XSxcbiAgICAgICAgICB5MyA9IHZbN107XG4gICAgICByZXR1cm4gdGVzdChuZXcgUG9pbnQoeDAsIHkwKSwgbmV3IFBvaW50KHZbMl0gLSB4MCwgdlszXSAtIHkwKSwgbmV3IFBvaW50KHZbNF0gLSB4Mywgdls1XSAtIHkzKSwgbmV3IFBvaW50KHgzLCB5MyksIGVwc2lsb24pO1xuICAgIH07XG4gIH0sIHtcbiAgICBzdGF0aWNzOiB7fSxcbiAgICBoYXNIYW5kbGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKCkgfHwgIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKTtcbiAgICB9LFxuICAgIGhhc0xlbmd0aDogZnVuY3Rpb24gKGVwc2lsb24pIHtcbiAgICAgIHJldHVybiAoIXRoaXMuZ2V0UG9pbnQxKCkuZXF1YWxzKHRoaXMuZ2V0UG9pbnQyKCkpIHx8IHRoaXMuaGFzSGFuZGxlcygpKSAmJiB0aGlzLmdldExlbmd0aCgpID4gKGVwc2lsb24gfHwgMCk7XG4gICAgfSxcbiAgICBpc0NvbGxpbmVhcjogZnVuY3Rpb24gKGN1cnZlKSB7XG4gICAgICByZXR1cm4gY3VydmUgJiYgdGhpcy5pc1N0cmFpZ2h0KCkgJiYgY3VydmUuaXNTdHJhaWdodCgpICYmIHRoaXMuZ2V0TGluZSgpLmlzQ29sbGluZWFyKGN1cnZlLmdldExpbmUoKSk7XG4gICAgfSxcbiAgICBpc0hvcml6b250YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBNYXRoLmFicyh0aGlzLmdldFRhbmdlbnRBdFRpbWUoMC41KS55KSA8IDFlLTg7XG4gICAgfSxcbiAgICBpc1ZlcnRpY2FsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1N0cmFpZ2h0KCkgJiYgTWF0aC5hYnModGhpcy5nZXRUYW5nZW50QXRUaW1lKDAuNSkueCkgPCAxZS04O1xuICAgIH1cbiAgfSksIHtcbiAgICBiZWFuczogZmFsc2UsXG4gICAgZ2V0TG9jYXRpb25BdDogZnVuY3Rpb24gKG9mZnNldCwgX2lzVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9jYXRpb25BdFRpbWUoX2lzVGltZSA/IG9mZnNldCA6IHRoaXMuZ2V0VGltZUF0KG9mZnNldCkpO1xuICAgIH0sXG4gICAgZ2V0TG9jYXRpb25BdFRpbWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCAhPSBudWxsICYmIHQgPj0gMCAmJiB0IDw9IDEgPyBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCB0KSA6IG51bGw7XG4gICAgfSxcbiAgICBnZXRUaW1lQXQ6IGZ1bmN0aW9uIChvZmZzZXQsIHN0YXJ0KSB7XG4gICAgICByZXR1cm4gQ3VydmUuZ2V0VGltZUF0KHRoaXMuZ2V0VmFsdWVzKCksIG9mZnNldCwgc3RhcnQpO1xuICAgIH0sXG4gICAgZ2V0UGFyYW1ldGVyQXQ6ICcjZ2V0VGltZUF0JyxcbiAgICBnZXRUaW1lc1dpdGhUYW5nZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGFuZ2VudCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0YW5nZW50LmlzWmVybygpID8gW10gOiBDdXJ2ZS5nZXRUaW1lc1dpdGhUYW5nZW50KHRoaXMuZ2V0VmFsdWVzKCksIHRhbmdlbnQpO1xuICAgIH0sXG4gICAgZ2V0T2Zmc2V0QXRUaW1lOiBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFydExlbmd0aCgwLCB0KTtcbiAgICB9LFxuICAgIGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExvY2F0aW9uQXRUaW1lKHRoaXMuZ2V0VGltZU9mKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuICAgIH0sXG4gICAgZ2V0T2Zmc2V0T2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uT2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuICAgIH0sXG4gICAgZ2V0VGltZU9mOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gQ3VydmUuZ2V0VGltZU9mKHRoaXMuZ2V0VmFsdWVzKCksIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBnZXRQYXJhbWV0ZXJPZjogJyNnZXRUaW1lT2YnLFxuICAgIGdldE5lYXJlc3RMb2NhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG4gICAgICAgICAgdCA9IEN1cnZlLmdldE5lYXJlc3RUaW1lKHZhbHVlcywgcG9pbnQpLFxuICAgICAgICAgIHB0ID0gQ3VydmUuZ2V0UG9pbnQodmFsdWVzLCB0KTtcbiAgICAgIHJldHVybiBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCB0LCBwdCwgbnVsbCwgcG9pbnQuZ2V0RGlzdGFuY2UocHQpKTtcbiAgICB9LFxuICAgIGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbG9jID8gbG9jLmdldFBvaW50KCkgOiBsb2M7XG4gICAgfVxuICB9LCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZXRob2RzID0gWydnZXRQb2ludCcsICdnZXRUYW5nZW50JywgJ2dldE5vcm1hbCcsICdnZXRXZWlnaHRlZFRhbmdlbnQnLCAnZ2V0V2VpZ2h0ZWROb3JtYWwnLCAnZ2V0Q3VydmF0dXJlJ107XG4gICAgcmV0dXJuIEJhc2UuZWFjaChtZXRob2RzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbiAobG9jYXRpb24sIF9pc1RpbWUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHJldHVybiBDdXJ2ZVtuYW1lXSh2YWx1ZXMsIF9pc1RpbWUgPyBsb2NhdGlvbiA6IEN1cnZlLmdldFRpbWVBdCh2YWx1ZXMsIGxvY2F0aW9uKSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzW25hbWUgKyAnQXRUaW1lJ10gPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICByZXR1cm4gQ3VydmVbbmFtZV0odGhpcy5nZXRWYWx1ZXMoKSwgdGltZSk7XG4gICAgICB9O1xuICAgIH0sIHtcbiAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgX2V2YWx1YXRlTWV0aG9kczogbWV0aG9kc1xuICAgICAgfVxuICAgIH0pO1xuICB9KCksIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpIHtcbiAgICAgIHZhciB4MCA9IHZbMF0sXG4gICAgICAgICAgeTAgPSB2WzFdLFxuICAgICAgICAgIHgxID0gdlsyXSxcbiAgICAgICAgICB5MSA9IHZbM10sXG4gICAgICAgICAgeDIgPSB2WzRdLFxuICAgICAgICAgIHkyID0gdls1XSxcbiAgICAgICAgICB4MyA9IHZbNl0sXG4gICAgICAgICAgeTMgPSB2WzddLFxuICAgICAgICAgIGF4ID0gOSAqICh4MSAtIHgyKSArIDMgKiAoeDMgLSB4MCksXG4gICAgICAgICAgYnggPSA2ICogKHgwICsgeDIpIC0gMTIgKiB4MSxcbiAgICAgICAgICBjeCA9IDMgKiAoeDEgLSB4MCksXG4gICAgICAgICAgYXkgPSA5ICogKHkxIC0geTIpICsgMyAqICh5MyAtIHkwKSxcbiAgICAgICAgICBieSA9IDYgKiAoeTAgKyB5MikgLSAxMiAqIHkxLFxuICAgICAgICAgIGN5ID0gMyAqICh5MSAtIHkwKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZHggPSAoYXggKiB0ICsgYngpICogdCArIGN4LFxuICAgICAgICAgICAgZHkgPSAoYXkgKiB0ICsgYnkpICogdCArIGN5O1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0aW9ucyhhLCBiKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMiwgTWF0aC5taW4oMTYsIE1hdGguY2VpbChNYXRoLmFicyhiIC0gYSkgKiAzMikpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBldmFsdWF0ZSh2LCB0LCB0eXBlLCBub3JtYWxpemVkKSB7XG4gICAgICBpZiAodCA9PSBudWxsIHx8IHQgPCAwIHx8IHQgPiAxKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB4MCA9IHZbMF0sXG4gICAgICAgICAgeTAgPSB2WzFdLFxuICAgICAgICAgIHgxID0gdlsyXSxcbiAgICAgICAgICB5MSA9IHZbM10sXG4gICAgICAgICAgeDIgPSB2WzRdLFxuICAgICAgICAgIHkyID0gdls1XSxcbiAgICAgICAgICB4MyA9IHZbNl0sXG4gICAgICAgICAgeTMgPSB2WzddLFxuICAgICAgICAgIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cbiAgICAgIGlmIChpc1plcm8oeDEgLSB4MCkgJiYgaXNaZXJvKHkxIC0geTApKSB7XG4gICAgICAgIHgxID0geDA7XG4gICAgICAgIHkxID0geTA7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1plcm8oeDIgLSB4MykgJiYgaXNaZXJvKHkyIC0geTMpKSB7XG4gICAgICAgIHgyID0geDM7XG4gICAgICAgIHkyID0geTM7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeCA9IDMgKiAoeDEgLSB4MCksXG4gICAgICAgICAgYnggPSAzICogKHgyIC0geDEpIC0gY3gsXG4gICAgICAgICAgYXggPSB4MyAtIHgwIC0gY3ggLSBieCxcbiAgICAgICAgICBjeSA9IDMgKiAoeTEgLSB5MCksXG4gICAgICAgICAgYnkgPSAzICogKHkyIC0geTEpIC0gY3ksXG4gICAgICAgICAgYXkgPSB5MyAtIHkwIC0gY3kgLSBieSxcbiAgICAgICAgICB4LFxuICAgICAgICAgIHk7XG5cbiAgICAgIGlmICh0eXBlID09PSAwKSB7XG4gICAgICAgIHggPSB0ID09PSAwID8geDAgOiB0ID09PSAxID8geDMgOiAoKGF4ICogdCArIGJ4KSAqIHQgKyBjeCkgKiB0ICsgeDA7XG4gICAgICAgIHkgPSB0ID09PSAwID8geTAgOiB0ID09PSAxID8geTMgOiAoKGF5ICogdCArIGJ5KSAqIHQgKyBjeSkgKiB0ICsgeTA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdE1pbiA9IDFlLTgsXG4gICAgICAgICAgICB0TWF4ID0gMSAtIHRNaW47XG5cbiAgICAgICAgaWYgKHQgPCB0TWluKSB7XG4gICAgICAgICAgeCA9IGN4O1xuICAgICAgICAgIHkgPSBjeTtcbiAgICAgICAgfSBlbHNlIGlmICh0ID4gdE1heCkge1xuICAgICAgICAgIHggPSAzICogKHgzIC0geDIpO1xuICAgICAgICAgIHkgPSAzICogKHkzIC0geTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSAoMyAqIGF4ICogdCArIDIgKiBieCkgKiB0ICsgY3g7XG4gICAgICAgICAgeSA9ICgzICogYXkgKiB0ICsgMiAqIGJ5KSAqIHQgKyBjeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgICAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCAmJiAodCA8IHRNaW4gfHwgdCA+IHRNYXgpKSB7XG4gICAgICAgICAgICB4ID0geDIgLSB4MTtcbiAgICAgICAgICAgIHkgPSB5MiAtIHkxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cbiAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICB4IC89IGxlbjtcbiAgICAgICAgICAgIHkgLz0gbGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAzKSB7XG4gICAgICAgICAgdmFyIHgyID0gNiAqIGF4ICogdCArIDIgKiBieCxcbiAgICAgICAgICAgICAgeTIgPSA2ICogYXkgKiB0ICsgMiAqIGJ5LFxuICAgICAgICAgICAgICBkID0gTWF0aC5wb3coeCAqIHggKyB5ICogeSwgMyAvIDIpO1xuICAgICAgICAgIHggPSBkICE9PSAwID8gKHggKiB5MiAtIHkgKiB4MikgLyBkIDogMDtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZSA9PT0gMiA/IG5ldyBQb2ludCh5LCAteCkgOiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgY2xhc3NpZnk6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgdmFyIHgwID0gdlswXSxcbiAgICAgICAgICAgICAgeTAgPSB2WzFdLFxuICAgICAgICAgICAgICB4MSA9IHZbMl0sXG4gICAgICAgICAgICAgIHkxID0gdlszXSxcbiAgICAgICAgICAgICAgeDIgPSB2WzRdLFxuICAgICAgICAgICAgICB5MiA9IHZbNV0sXG4gICAgICAgICAgICAgIHgzID0gdls2XSxcbiAgICAgICAgICAgICAgeTMgPSB2WzddLFxuICAgICAgICAgICAgICBhMSA9IHgwICogKHkzIC0geTIpICsgeTAgKiAoeDIgLSB4MykgKyB4MyAqIHkyIC0geTMgKiB4MixcbiAgICAgICAgICAgICAgYTIgPSB4MSAqICh5MCAtIHkzKSArIHkxICogKHgzIC0geDApICsgeDAgKiB5MyAtIHkwICogeDMsXG4gICAgICAgICAgICAgIGEzID0geDIgKiAoeTEgLSB5MCkgKyB5MiAqICh4MCAtIHgxKSArIHgxICogeTAgLSB5MSAqIHgwLFxuICAgICAgICAgICAgICBkMyA9IDMgKiBhMyxcbiAgICAgICAgICAgICAgZDIgPSBkMyAtIGEyLFxuICAgICAgICAgICAgICBkMSA9IGQyIC0gYTIgKyBhMSxcbiAgICAgICAgICAgICAgbCA9IE1hdGguc3FydChkMSAqIGQxICsgZDIgKiBkMiArIGQzICogZDMpLFxuICAgICAgICAgICAgICBzID0gbCAhPT0gMCA/IDEgLyBsIDogMCxcbiAgICAgICAgICAgICAgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybyxcbiAgICAgICAgICAgICAgc2VycGVudGluZSA9ICdzZXJwZW50aW5lJztcbiAgICAgICAgICBkMSAqPSBzO1xuICAgICAgICAgIGQyICo9IHM7XG4gICAgICAgICAgZDMgKj0gcztcblxuICAgICAgICAgIGZ1bmN0aW9uIHR5cGUodHlwZSwgdDEsIHQyKSB7XG4gICAgICAgICAgICB2YXIgaGFzUm9vdHMgPSB0MSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHQxT2sgPSBoYXNSb290cyAmJiB0MSA+IDAgJiYgdDEgPCAxLFxuICAgICAgICAgICAgICAgIHQyT2sgPSBoYXNSb290cyAmJiB0MiA+IDAgJiYgdDIgPCAxO1xuXG4gICAgICAgICAgICBpZiAoaGFzUm9vdHMgJiYgKCEodDFPayB8fCB0Mk9rKSB8fCB0eXBlID09PSAnbG9vcCcgJiYgISh0MU9rICYmIHQyT2spKSkge1xuICAgICAgICAgICAgICB0eXBlID0gJ2FyY2gnO1xuICAgICAgICAgICAgICB0MU9rID0gdDJPayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICByb290czogdDFPayB8fCB0Mk9rID8gdDFPayAmJiB0Mk9rID8gdDEgPCB0MiA/IFt0MSwgdDJdIDogW3QyLCB0MV0gOiBbdDFPayA/IHQxIDogdDJdIDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNaZXJvKGQxKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzWmVybyhkMikgPyB0eXBlKGlzWmVybyhkMykgPyAnbGluZScgOiAncXVhZHJhdGljJykgOiB0eXBlKHNlcnBlbnRpbmUsIGQzIC8gKDMgKiBkMikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkID0gMyAqIGQyICogZDIgLSA0ICogZDEgKiBkMztcblxuICAgICAgICAgIGlmIChpc1plcm8oZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlKCdjdXNwJywgZDIgLyAoMiAqIGQxKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGYxID0gZCA+IDAgPyBNYXRoLnNxcnQoZCAvIDMpIDogTWF0aC5zcXJ0KC1kKSxcbiAgICAgICAgICAgICAgZjIgPSAyICogZDE7XG4gICAgICAgICAgcmV0dXJuIHR5cGUoZCA+IDAgPyBzZXJwZW50aW5lIDogJ2xvb3AnLCAoZDIgKyBmMSkgLyBmMiwgKGQyIC0gZjEpIC8gZjIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICh2LCBhLCBiLCBkcykge1xuICAgICAgICAgIGlmIChhID09PSB1bmRlZmluZWQpIGEgPSAwO1xuICAgICAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIGIgPSAxO1xuXG4gICAgICAgICAgaWYgKEN1cnZlLmlzU3RyYWlnaHQodikpIHtcbiAgICAgICAgICAgIHZhciBjID0gdjtcblxuICAgICAgICAgICAgaWYgKGIgPCAxKSB7XG4gICAgICAgICAgICAgIGMgPSBDdXJ2ZS5zdWJkaXZpZGUoYywgYilbMF07XG4gICAgICAgICAgICAgIGEgLz0gYjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGEgPiAwKSB7XG4gICAgICAgICAgICAgIGMgPSBDdXJ2ZS5zdWJkaXZpZGUoYywgYSlbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkeCA9IGNbNl0gLSBjWzBdLFxuICAgICAgICAgICAgICAgIGR5ID0gY1s3XSAtIGNbMV07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gTnVtZXJpY2FsLmludGVncmF0ZShkcyB8fCBnZXRMZW5ndGhJbnRlZ3JhbmQodiksIGEsIGIsIGdldEl0ZXJhdGlvbnMoYSwgYikpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRUaW1lQXQ6IGZ1bmN0aW9uICh2LCBvZmZzZXQsIHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHN0YXJ0ID0gb2Zmc2V0IDwgMCA/IDEgOiAwO1xuICAgICAgICAgIGlmIChvZmZzZXQgPT09IDApIHJldHVybiBzdGFydDtcbiAgICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgICAgIGVwc2lsb24gPSAxZS0xMixcbiAgICAgICAgICAgICAgZm9yd2FyZCA9IG9mZnNldCA+IDAsXG4gICAgICAgICAgICAgIGEgPSBmb3J3YXJkID8gc3RhcnQgOiAwLFxuICAgICAgICAgICAgICBiID0gZm9yd2FyZCA/IDEgOiBzdGFydCxcbiAgICAgICAgICAgICAgZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodiksXG4gICAgICAgICAgICAgIHJhbmdlTGVuZ3RoID0gQ3VydmUuZ2V0TGVuZ3RoKHYsIGEsIGIsIGRzKSxcbiAgICAgICAgICAgICAgZGlmZiA9IGFicyhvZmZzZXQpIC0gcmFuZ2VMZW5ndGg7XG5cbiAgICAgICAgICBpZiAoYWJzKGRpZmYpIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcndhcmQgPyBiIDogYTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZ3Vlc3MgPSBvZmZzZXQgLyByYW5nZUxlbmd0aCxcbiAgICAgICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGYodCkge1xuICAgICAgICAgICAgbGVuZ3RoICs9IE51bWVyaWNhbC5pbnRlZ3JhdGUoZHMsIHN0YXJ0LCB0LCBnZXRJdGVyYXRpb25zKHN0YXJ0LCB0KSk7XG4gICAgICAgICAgICBzdGFydCA9IHQ7XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBOdW1lcmljYWwuZmluZFJvb3QoZiwgZHMsIHN0YXJ0ICsgZ3Vlc3MsIGEsIGIsIDMyLCAxZS0xMik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBvaW50OiBmdW5jdGlvbiAodiwgdCkge1xuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSh2LCB0LCAwLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRhbmdlbnQ6IGZ1bmN0aW9uICh2LCB0KSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKHYsIHQsIDEsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXZWlnaHRlZFRhbmdlbnQ6IGZ1bmN0aW9uICh2LCB0KSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKHYsIHQsIDEsIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Tm9ybWFsOiBmdW5jdGlvbiAodiwgdCkge1xuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSh2LCB0LCAyLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2VpZ2h0ZWROb3JtYWw6IGZ1bmN0aW9uICh2LCB0KSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKHYsIHQsIDIsIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q3VydmF0dXJlOiBmdW5jdGlvbiAodiwgdCkge1xuICAgICAgICAgIHJldHVybiBldmFsdWF0ZSh2LCB0LCAzLCBmYWxzZSkueDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UGVha3M6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgdmFyIHgwID0gdlswXSxcbiAgICAgICAgICAgICAgeTAgPSB2WzFdLFxuICAgICAgICAgICAgICB4MSA9IHZbMl0sXG4gICAgICAgICAgICAgIHkxID0gdlszXSxcbiAgICAgICAgICAgICAgeDIgPSB2WzRdLFxuICAgICAgICAgICAgICB5MiA9IHZbNV0sXG4gICAgICAgICAgICAgIHgzID0gdls2XSxcbiAgICAgICAgICAgICAgeTMgPSB2WzddLFxuICAgICAgICAgICAgICBheCA9IC14MCArIDMgKiB4MSAtIDMgKiB4MiArIHgzLFxuICAgICAgICAgICAgICBieCA9IDMgKiB4MCAtIDYgKiB4MSArIDMgKiB4MixcbiAgICAgICAgICAgICAgY3ggPSAtMyAqIHgwICsgMyAqIHgxLFxuICAgICAgICAgICAgICBheSA9IC15MCArIDMgKiB5MSAtIDMgKiB5MiArIHkzLFxuICAgICAgICAgICAgICBieSA9IDMgKiB5MCAtIDYgKiB5MSArIDMgKiB5MixcbiAgICAgICAgICAgICAgY3kgPSAtMyAqIHkwICsgMyAqIHkxLFxuICAgICAgICAgICAgICB0TWluID0gMWUtOCxcbiAgICAgICAgICAgICAgdE1heCA9IDEgLSB0TWluLFxuICAgICAgICAgICAgICByb290cyA9IFtdO1xuICAgICAgICAgIE51bWVyaWNhbC5zb2x2ZUN1YmljKDkgKiAoYXggKiBheCArIGF5ICogYXkpLCA5ICogKGF4ICogYnggKyBieSAqIGF5KSwgMiAqIChieCAqIGJ4ICsgYnkgKiBieSkgKyAzICogKGN4ICogYXggKyBjeSAqIGF5KSwgY3ggKiBieCArIGJ5ICogY3ksIHJvb3RzLCB0TWluLCB0TWF4KTtcbiAgICAgICAgICByZXR1cm4gcm9vdHMuc29ydCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSgpLCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgYzEsIHQxLCBjMiwgdDIsIG92ZXJsYXApIHtcbiAgICAgIHZhciBleGNsdWRlU3RhcnQgPSAhb3ZlcmxhcCAmJiBjMS5nZXRQcmV2aW91cygpID09PSBjMixcbiAgICAgICAgICBleGNsdWRlRW5kID0gIW92ZXJsYXAgJiYgYzEgIT09IGMyICYmIGMxLmdldE5leHQoKSA9PT0gYzIsXG4gICAgICAgICAgdE1pbiA9IDFlLTgsXG4gICAgICAgICAgdE1heCA9IDEgLSB0TWluO1xuXG4gICAgICBpZiAodDEgIT09IG51bGwgJiYgdDEgPj0gKGV4Y2x1ZGVTdGFydCA/IHRNaW4gOiAwKSAmJiB0MSA8PSAoZXhjbHVkZUVuZCA/IHRNYXggOiAxKSkge1xuICAgICAgICBpZiAodDIgIT09IG51bGwgJiYgdDIgPj0gKGV4Y2x1ZGVFbmQgPyB0TWluIDogMCkgJiYgdDIgPD0gKGV4Y2x1ZGVTdGFydCA/IHRNYXggOiAxKSkge1xuICAgICAgICAgIHZhciBsb2MxID0gbmV3IEN1cnZlTG9jYXRpb24oYzEsIHQxLCBudWxsLCBvdmVybGFwKSxcbiAgICAgICAgICAgICAgbG9jMiA9IG5ldyBDdXJ2ZUxvY2F0aW9uKGMyLCB0MiwgbnVsbCwgb3ZlcmxhcCk7XG4gICAgICAgICAgbG9jMS5faW50ZXJzZWN0aW9uID0gbG9jMjtcbiAgICAgICAgICBsb2MyLl9pbnRlcnNlY3Rpb24gPSBsb2MxO1xuXG4gICAgICAgICAgaWYgKCFpbmNsdWRlIHx8IGluY2x1ZGUobG9jMSkpIHtcbiAgICAgICAgICAgIEN1cnZlTG9jYXRpb24uaW5zZXJ0KGxvY2F0aW9ucywgbG9jMSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUsIGZsaXAsIHJlY3Vyc2lvbiwgY2FsbHMsIHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgpIHtcbiAgICAgIGlmICgrK2NhbGxzID49IDQwOTYgfHwgKytyZWN1cnNpb24gPj0gNDApIHJldHVybiBjYWxscztcbiAgICAgIHZhciBmYXRMaW5lRXBzaWxvbiA9IDFlLTksXG4gICAgICAgICAgcTB4ID0gdjJbMF0sXG4gICAgICAgICAgcTB5ID0gdjJbMV0sXG4gICAgICAgICAgcTN4ID0gdjJbNl0sXG4gICAgICAgICAgcTN5ID0gdjJbN10sXG4gICAgICAgICAgZ2V0U2lnbmVkRGlzdGFuY2UgPSBMaW5lLmdldFNpZ25lZERpc3RhbmNlLFxuICAgICAgICAgIGQxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MlsyXSwgdjJbM10pLFxuICAgICAgICAgIGQyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2Mls0XSwgdjJbNV0pLFxuICAgICAgICAgIGZhY3RvciA9IGQxICogZDIgPiAwID8gMyAvIDQgOiA0IC8gOSxcbiAgICAgICAgICBkTWluID0gZmFjdG9yICogTWF0aC5taW4oMCwgZDEsIGQyKSxcbiAgICAgICAgICBkTWF4ID0gZmFjdG9yICogTWF0aC5tYXgoMCwgZDEsIGQyKSxcbiAgICAgICAgICBkcDAgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzBdLCB2MVsxXSksXG4gICAgICAgICAgZHAxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVsyXSwgdjFbM10pLFxuICAgICAgICAgIGRwMiA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbNF0sIHYxWzVdKSxcbiAgICAgICAgICBkcDMgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzZdLCB2MVs3XSksXG4gICAgICAgICAgaHVsbCA9IGdldENvbnZleEh1bGwoZHAwLCBkcDEsIGRwMiwgZHAzKSxcbiAgICAgICAgICB0b3AgPSBodWxsWzBdLFxuICAgICAgICAgIGJvdHRvbSA9IGh1bGxbMV0sXG4gICAgICAgICAgdE1pbkNsaXAsXG4gICAgICAgICAgdE1heENsaXA7XG4gICAgICBpZiAoZDEgPT09IDAgJiYgZDIgPT09IDAgJiYgZHAwID09PSAwICYmIGRwMSA9PT0gMCAmJiBkcDIgPT09IDAgJiYgZHAzID09PSAwIHx8ICh0TWluQ2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcCwgYm90dG9tLCBkTWluLCBkTWF4KSkgPT0gbnVsbCB8fCAodE1heENsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AucmV2ZXJzZSgpLCBib3R0b20ucmV2ZXJzZSgpLCBkTWluLCBkTWF4KSkgPT0gbnVsbCkgcmV0dXJuIGNhbGxzO1xuICAgICAgdmFyIHRNaW5OZXcgPSB0TWluICsgKHRNYXggLSB0TWluKSAqIHRNaW5DbGlwLFxuICAgICAgICAgIHRNYXhOZXcgPSB0TWluICsgKHRNYXggLSB0TWluKSAqIHRNYXhDbGlwO1xuXG4gICAgICBpZiAoTWF0aC5tYXgodU1heCAtIHVNaW4sIHRNYXhOZXcgLSB0TWluTmV3KSA8IGZhdExpbmVFcHNpbG9uKSB7XG4gICAgICAgIHZhciB0ID0gKHRNaW5OZXcgKyB0TWF4TmV3KSAvIDIsXG4gICAgICAgICAgICB1ID0gKHVNaW4gKyB1TWF4KSAvIDI7XG4gICAgICAgIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCA/IGMyIDogYzEsIGZsaXAgPyB1IDogdCwgZmxpcCA/IGMxIDogYzIsIGZsaXAgPyB0IDogdSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2MSA9IEN1cnZlLmdldFBhcnQodjEsIHRNaW5DbGlwLCB0TWF4Q2xpcCk7XG4gICAgICAgIHZhciB1RGlmZiA9IHVNYXggLSB1TWluO1xuXG4gICAgICAgIGlmICh0TWF4Q2xpcCAtIHRNaW5DbGlwID4gMC44KSB7XG4gICAgICAgICAgaWYgKHRNYXhOZXcgLSB0TWluTmV3ID4gdURpZmYpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MSwgMC41KSxcbiAgICAgICAgICAgICAgICB0ID0gKHRNaW5OZXcgKyB0TWF4TmV3KSAvIDI7XG4gICAgICAgICAgICBjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MiwgcGFydHNbMF0sIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCwgcmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdU1heCwgdE1pbk5ldywgdCk7XG4gICAgICAgICAgICBjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MiwgcGFydHNbMV0sIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCwgcmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdU1heCwgdCwgdE1heE5ldyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MiwgMC41KSxcbiAgICAgICAgICAgICAgICB1ID0gKHVNaW4gKyB1TWF4KSAvIDI7XG4gICAgICAgICAgICBjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhwYXJ0c1swXSwgdjEsIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCwgcmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdSwgdE1pbk5ldywgdE1heE5ldyk7XG4gICAgICAgICAgICBjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhwYXJ0c1sxXSwgdjEsIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCwgcmVjdXJzaW9uLCBjYWxscywgdSwgdU1heCwgdE1pbk5ldywgdE1heE5ldyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh1RGlmZiA9PT0gMCB8fCB1RGlmZiA+PSBmYXRMaW5lRXBzaWxvbikge1xuICAgICAgICAgICAgY2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjIsIHYxLCBjMiwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSwgIWZsaXAsIHJlY3Vyc2lvbiwgY2FsbHMsIHVNaW4sIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlLCBmbGlwLCByZWN1cnNpb24sIGNhbGxzLCB0TWluTmV3LCB0TWF4TmV3LCB1TWluLCB1TWF4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbnZleEh1bGwoZHEwLCBkcTEsIGRxMiwgZHEzKSB7XG4gICAgICB2YXIgcDAgPSBbMCwgZHEwXSxcbiAgICAgICAgICBwMSA9IFsxIC8gMywgZHExXSxcbiAgICAgICAgICBwMiA9IFsyIC8gMywgZHEyXSxcbiAgICAgICAgICBwMyA9IFsxLCBkcTNdLFxuICAgICAgICAgIGRpc3QxID0gZHExIC0gKDIgKiBkcTAgKyBkcTMpIC8gMyxcbiAgICAgICAgICBkaXN0MiA9IGRxMiAtIChkcTAgKyAyICogZHEzKSAvIDMsXG4gICAgICAgICAgaHVsbDtcblxuICAgICAgaWYgKGRpc3QxICogZGlzdDIgPCAwKSB7XG4gICAgICAgIGh1bGwgPSBbW3AwLCBwMSwgcDNdLCBbcDAsIHAyLCBwM11dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpc3RSYXRpbyA9IGRpc3QxIC8gZGlzdDI7XG4gICAgICAgIGh1bGwgPSBbZGlzdFJhdGlvID49IDIgPyBbcDAsIHAxLCBwM10gOiBkaXN0UmF0aW8gPD0gMC41ID8gW3AwLCBwMiwgcDNdIDogW3AwLCBwMSwgcDIsIHAzXSwgW3AwLCBwM11dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKGRpc3QxIHx8IGRpc3QyKSA8IDAgPyBodWxsLnJldmVyc2UoKSA6IGh1bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpcENvbnZleEh1bGwoaHVsbFRvcCwgaHVsbEJvdHRvbSwgZE1pbiwgZE1heCkge1xuICAgICAgaWYgKGh1bGxUb3BbMF1bMV0gPCBkTWluKSB7XG4gICAgICAgIHJldHVybiBjbGlwQ29udmV4SHVsbFBhcnQoaHVsbFRvcCwgdHJ1ZSwgZE1pbik7XG4gICAgICB9IGVsc2UgaWYgKGh1bGxCb3R0b21bMF1bMV0gPiBkTWF4KSB7XG4gICAgICAgIHJldHVybiBjbGlwQ29udmV4SHVsbFBhcnQoaHVsbEJvdHRvbSwgZmFsc2UsIGRNYXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGh1bGxUb3BbMF1bMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpcENvbnZleEh1bGxQYXJ0KHBhcnQsIHRvcCwgdGhyZXNob2xkKSB7XG4gICAgICB2YXIgcHggPSBwYXJ0WzBdWzBdLFxuICAgICAgICAgIHB5ID0gcGFydFswXVsxXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBwYXJ0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcXggPSBwYXJ0W2ldWzBdLFxuICAgICAgICAgICAgcXkgPSBwYXJ0W2ldWzFdO1xuXG4gICAgICAgIGlmICh0b3AgPyBxeSA+PSB0aHJlc2hvbGQgOiBxeSA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICByZXR1cm4gcXkgPT09IHRocmVzaG9sZCA/IHF4IDogcHggKyAodGhyZXNob2xkIC0gcHkpICogKHF4IC0gcHgpIC8gKHF5IC0gcHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHggPSBxeDtcbiAgICAgICAgcHkgPSBxeTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q3VydmVMaW5lSW50ZXJzZWN0aW9ucyh2LCBweCwgcHksIHZ4LCB2eSkge1xuICAgICAgdmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cbiAgICAgIGlmIChpc1plcm8odngpICYmIGlzWmVybyh2eSkpIHtcbiAgICAgICAgdmFyIHQgPSBDdXJ2ZS5nZXRUaW1lT2YodiwgbmV3IFBvaW50KHB4LCBweSkpO1xuICAgICAgICByZXR1cm4gdCA9PT0gbnVsbCA/IFtdIDogW3RdO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKC12eSwgdngpLFxuICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgcnYgPSBbXSxcbiAgICAgICAgICByb290cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkgKz0gMikge1xuICAgICAgICB2YXIgeCA9IHZbaV0gLSBweCxcbiAgICAgICAgICAgIHkgPSB2W2kgKyAxXSAtIHB5O1xuICAgICAgICBydi5wdXNoKHggKiBjb3MgLSB5ICogc2luLCB4ICogc2luICsgeSAqIGNvcyk7XG4gICAgICB9XG5cbiAgICAgIEN1cnZlLnNvbHZlQ3ViaWMocnYsIDEsIDAsIHJvb3RzLCAwLCAxKTtcbiAgICAgIHJldHVybiByb290cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUsIGZsaXApIHtcbiAgICAgIHZhciB4MSA9IHYyWzBdLFxuICAgICAgICAgIHkxID0gdjJbMV0sXG4gICAgICAgICAgeDIgPSB2Mls2XSxcbiAgICAgICAgICB5MiA9IHYyWzddLFxuICAgICAgICAgIHJvb3RzID0gZ2V0Q3VydmVMaW5lSW50ZXJzZWN0aW9ucyh2MSwgeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHQxID0gcm9vdHNbaV0sXG4gICAgICAgICAgICBwMSA9IEN1cnZlLmdldFBvaW50KHYxLCB0MSksXG4gICAgICAgICAgICB0MiA9IEN1cnZlLmdldFRpbWVPZih2MiwgcDEpO1xuXG4gICAgICAgIGlmICh0MiAhPT0gbnVsbCkge1xuICAgICAgICAgIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCA/IGMyIDogYzEsIGZsaXAgPyB0MiA6IHQxLCBmbGlwID8gYzEgOiBjMiwgZmxpcCA/IHQxIDogdDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGluZUludGVyc2VjdGlvbih2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG4gICAgICB2YXIgcHQgPSBMaW5lLmludGVyc2VjdCh2MVswXSwgdjFbMV0sIHYxWzZdLCB2MVs3XSwgdjJbMF0sIHYyWzFdLCB2Mls2XSwgdjJbN10pO1xuXG4gICAgICBpZiAocHQpIHtcbiAgICAgICAgYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgQ3VydmUuZ2V0VGltZU9mKHYxLCBwdCksIGMyLCBDdXJ2ZS5nZXRUaW1lT2YodjIsIHB0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcbiAgICAgIHZhciBlcHNpbG9uID0gMWUtMTIsXG4gICAgICAgICAgbWluID0gTWF0aC5taW4sXG4gICAgICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgICAgIGlmIChtYXgodjFbMF0sIHYxWzJdLCB2MVs0XSwgdjFbNl0pICsgZXBzaWxvbiA+IG1pbih2MlswXSwgdjJbMl0sIHYyWzRdLCB2Mls2XSkgJiYgbWluKHYxWzBdLCB2MVsyXSwgdjFbNF0sIHYxWzZdKSAtIGVwc2lsb24gPCBtYXgodjJbMF0sIHYyWzJdLCB2Mls0XSwgdjJbNl0pICYmIG1heCh2MVsxXSwgdjFbM10sIHYxWzVdLCB2MVs3XSkgKyBlcHNpbG9uID4gbWluKHYyWzFdLCB2MlszXSwgdjJbNV0sIHYyWzddKSAmJiBtaW4odjFbMV0sIHYxWzNdLCB2MVs1XSwgdjFbN10pIC0gZXBzaWxvbiA8IG1heCh2MlsxXSwgdjJbM10sIHYyWzVdLCB2Mls3XSkpIHtcbiAgICAgICAgdmFyIG92ZXJsYXBzID0gZ2V0T3ZlcmxhcHModjEsIHYyKTtcblxuICAgICAgICBpZiAob3ZlcmxhcHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSBvdmVybGFwc1tpXTtcbiAgICAgICAgICAgIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgYzEsIG92ZXJsYXBbMF0sIGMyLCBvdmVybGFwWzFdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0cmFpZ2h0MSA9IEN1cnZlLmlzU3RyYWlnaHQodjEpLFxuICAgICAgICAgICAgICBzdHJhaWdodDIgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYyKSxcbiAgICAgICAgICAgICAgc3RyYWlnaHQgPSBzdHJhaWdodDEgJiYgc3RyYWlnaHQyLFxuICAgICAgICAgICAgICBmbGlwID0gc3RyYWlnaHQxICYmICFzdHJhaWdodDIsXG4gICAgICAgICAgICAgIGJlZm9yZSA9IGxvY2F0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgKHN0cmFpZ2h0ID8gYWRkTGluZUludGVyc2VjdGlvbiA6IHN0cmFpZ2h0MSB8fCBzdHJhaWdodDIgPyBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zIDogYWRkQ3VydmVJbnRlcnNlY3Rpb25zKShmbGlwID8gdjIgOiB2MSwgZmxpcCA/IHYxIDogdjIsIGZsaXAgPyBjMiA6IGMxLCBmbGlwID8gYzEgOiBjMiwgbG9jYXRpb25zLCBpbmNsdWRlLCBmbGlwLCAwLCAwLCAwLCAxLCAwLCAxKTtcblxuICAgICAgICAgIGlmICghc3RyYWlnaHQgfHwgbG9jYXRpb25zLmxlbmd0aCA9PT0gYmVmb3JlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgdDEgPSBpID4+IDEsXG4gICAgICAgICAgICAgICAgICB0MiA9IGkgJiAxLFxuICAgICAgICAgICAgICAgICAgaTEgPSB0MSAqIDYsXG4gICAgICAgICAgICAgICAgICBpMiA9IHQyICogNixcbiAgICAgICAgICAgICAgICAgIHAxID0gbmV3IFBvaW50KHYxW2kxXSwgdjFbaTEgKyAxXSksXG4gICAgICAgICAgICAgICAgICBwMiA9IG5ldyBQb2ludCh2MltpMl0sIHYyW2kyICsgMV0pO1xuXG4gICAgICAgICAgICAgIGlmIChwMS5pc0Nsb3NlKHAyLCBlcHNpbG9uKSkge1xuICAgICAgICAgICAgICAgIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgYzEsIHQxLCBjMiwgdDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhdGlvbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2VsZkludGVyc2VjdGlvbih2MSwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuICAgICAgdmFyIGluZm8gPSBDdXJ2ZS5jbGFzc2lmeSh2MSk7XG5cbiAgICAgIGlmIChpbmZvLnR5cGUgPT09ICdsb29wJykge1xuICAgICAgICB2YXIgcm9vdHMgPSBpbmZvLnJvb3RzO1xuICAgICAgICBhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGMxLCByb290c1swXSwgYzEsIHJvb3RzWzFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvY2F0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25zKGN1cnZlczEsIGN1cnZlczIsIGluY2x1ZGUsIG1hdHJpeDEsIG1hdHJpeDIsIF9yZXR1cm5GaXJzdCkge1xuICAgICAgdmFyIGVwc2lsb24gPSAxZS03LFxuICAgICAgICAgIHNlbGYgPSAhY3VydmVzMjtcbiAgICAgIGlmIChzZWxmKSBjdXJ2ZXMyID0gY3VydmVzMTtcbiAgICAgIHZhciBsZW5ndGgxID0gY3VydmVzMS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoMiA9IGN1cnZlczIubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlczEgPSBuZXcgQXJyYXkobGVuZ3RoMSksXG4gICAgICAgICAgdmFsdWVzMiA9IHNlbGYgPyB2YWx1ZXMxIDogbmV3IEFycmF5KGxlbmd0aDIpLFxuICAgICAgICAgIGxvY2F0aW9ucyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICB2YWx1ZXMxW2ldID0gY3VydmVzMVtpXS5nZXRWYWx1ZXMobWF0cml4MSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgIHZhbHVlczJbaV0gPSBjdXJ2ZXMyW2ldLmdldFZhbHVlcyhtYXRyaXgyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRzQ29sbGlzaW9ucyA9IENvbGxpc2lvbkRldGVjdGlvbi5maW5kQ3VydmVCb3VuZHNDb2xsaXNpb25zKHZhbHVlczEsIHZhbHVlczIsIGVwc2lsb24pO1xuXG4gICAgICBmb3IgKHZhciBpbmRleDEgPSAwOyBpbmRleDEgPCBsZW5ndGgxOyBpbmRleDErKykge1xuICAgICAgICB2YXIgY3VydmUxID0gY3VydmVzMVtpbmRleDFdLFxuICAgICAgICAgICAgdjEgPSB2YWx1ZXMxW2luZGV4MV07XG5cbiAgICAgICAgaWYgKHNlbGYpIHtcbiAgICAgICAgICBnZXRTZWxmSW50ZXJzZWN0aW9uKHYxLCBjdXJ2ZTEsIGxvY2F0aW9ucywgaW5jbHVkZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sbGlzaW9uczEgPSBib3VuZHNDb2xsaXNpb25zW2luZGV4MV07XG5cbiAgICAgICAgaWYgKGNvbGxpc2lvbnMxKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2xsaXNpb25zMS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKF9yZXR1cm5GaXJzdCAmJiBsb2NhdGlvbnMubGVuZ3RoKSByZXR1cm4gbG9jYXRpb25zO1xuICAgICAgICAgICAgdmFyIGluZGV4MiA9IGNvbGxpc2lvbnMxW2pdO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYgfHwgaW5kZXgyID4gaW5kZXgxKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJ2ZTIgPSBjdXJ2ZXMyW2luZGV4Ml0sXG4gICAgICAgICAgICAgICAgICB2MiA9IHZhbHVlczJbaW5kZXgyXTtcbiAgICAgICAgICAgICAgZ2V0Q3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhdGlvbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0T3ZlcmxhcHModjEsIHYyKSB7XG4gICAgICBmdW5jdGlvbiBnZXRTcXVhcmVkTGluZUxlbmd0aCh2KSB7XG4gICAgICAgIHZhciB4ID0gdls2XSAtIHZbMF0sXG4gICAgICAgICAgICB5ID0gdls3XSAtIHZbMV07XG4gICAgICAgIHJldHVybiB4ICogeCArIHkgKiB5O1xuICAgICAgfVxuXG4gICAgICB2YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgZ2V0RGlzdGFuY2UgPSBMaW5lLmdldERpc3RhbmNlLFxuICAgICAgICAgIHRpbWVFcHNpbG9uID0gMWUtOCxcbiAgICAgICAgICBnZW9tRXBzaWxvbiA9IDFlLTcsXG4gICAgICAgICAgc3RyYWlnaHQxID0gQ3VydmUuaXNTdHJhaWdodCh2MSksXG4gICAgICAgICAgc3RyYWlnaHQyID0gQ3VydmUuaXNTdHJhaWdodCh2MiksXG4gICAgICAgICAgc3RyYWlnaHRCb3RoID0gc3RyYWlnaHQxICYmIHN0cmFpZ2h0MixcbiAgICAgICAgICBmbGlwID0gZ2V0U3F1YXJlZExpbmVMZW5ndGgodjEpIDwgZ2V0U3F1YXJlZExpbmVMZW5ndGgodjIpLFxuICAgICAgICAgIGwxID0gZmxpcCA/IHYyIDogdjEsXG4gICAgICAgICAgbDIgPSBmbGlwID8gdjEgOiB2MixcbiAgICAgICAgICBweCA9IGwxWzBdLFxuICAgICAgICAgIHB5ID0gbDFbMV0sXG4gICAgICAgICAgdnggPSBsMVs2XSAtIHB4LFxuICAgICAgICAgIHZ5ID0gbDFbN10gLSBweTtcblxuICAgICAgaWYgKGdldERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCBsMlswXSwgbDJbMV0sIHRydWUpIDwgZ2VvbUVwc2lsb24gJiYgZ2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzZdLCBsMls3XSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbikge1xuICAgICAgICBpZiAoIXN0cmFpZ2h0Qm90aCAmJiBnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDFbMl0sIGwxWzNdLCB0cnVlKSA8IGdlb21FcHNpbG9uICYmIGdldERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCBsMVs0XSwgbDFbNV0sIHRydWUpIDwgZ2VvbUVwc2lsb24gJiYgZ2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzJdLCBsMlszXSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbiAmJiBnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDJbNF0sIGwyWzVdLCB0cnVlKSA8IGdlb21FcHNpbG9uKSB7XG4gICAgICAgICAgc3RyYWlnaHQxID0gc3RyYWlnaHQyID0gc3RyYWlnaHRCb3RoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJhaWdodEJvdGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJhaWdodDEgXiBzdHJhaWdodDIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB2ID0gW3YxLCB2Ml0sXG4gICAgICAgICAgcGFpcnMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0ICYmIHBhaXJzLmxlbmd0aCA8IDI7IGkrKykge1xuICAgICAgICB2YXIgaTEgPSBpICYgMSxcbiAgICAgICAgICAgIGkyID0gaTEgXiAxLFxuICAgICAgICAgICAgdDEgPSBpID4+IDEsXG4gICAgICAgICAgICB0MiA9IEN1cnZlLmdldFRpbWVPZih2W2kxXSwgbmV3IFBvaW50KHZbaTJdW3QxID8gNiA6IDBdLCB2W2kyXVt0MSA/IDcgOiAxXSkpO1xuXG4gICAgICAgIGlmICh0MiAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBpMSA/IFt0MSwgdDJdIDogW3QyLCB0MV07XG5cbiAgICAgICAgICBpZiAoIXBhaXJzLmxlbmd0aCB8fCBhYnMocGFpclswXSAtIHBhaXJzWzBdWzBdKSA+IHRpbWVFcHNpbG9uICYmIGFicyhwYWlyWzFdIC0gcGFpcnNbMF1bMV0pID4gdGltZUVwc2lsb24pIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2gocGFpcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPiAyICYmICFwYWlycy5sZW5ndGgpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFpcnMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHBhaXJzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmFpZ2h0Qm90aCkge1xuICAgICAgICB2YXIgbzEgPSBDdXJ2ZS5nZXRQYXJ0KHYxLCBwYWlyc1swXVswXSwgcGFpcnNbMV1bMF0pLFxuICAgICAgICAgICAgbzIgPSBDdXJ2ZS5nZXRQYXJ0KHYyLCBwYWlyc1swXVsxXSwgcGFpcnNbMV1bMV0pO1xuICAgICAgICBpZiAoYWJzKG8yWzJdIC0gbzFbMl0pID4gZ2VvbUVwc2lsb24gfHwgYWJzKG8yWzNdIC0gbzFbM10pID4gZ2VvbUVwc2lsb24gfHwgYWJzKG8yWzRdIC0gbzFbNF0pID4gZ2VvbUVwc2lsb24gfHwgYWJzKG8yWzVdIC0gbzFbNV0pID4gZ2VvbUVwc2lsb24pIHBhaXJzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRpbWVzV2l0aFRhbmdlbnQodiwgdGFuZ2VudCkge1xuICAgICAgdmFyIHgwID0gdlswXSxcbiAgICAgICAgICB5MCA9IHZbMV0sXG4gICAgICAgICAgeDEgPSB2WzJdLFxuICAgICAgICAgIHkxID0gdlszXSxcbiAgICAgICAgICB4MiA9IHZbNF0sXG4gICAgICAgICAgeTIgPSB2WzVdLFxuICAgICAgICAgIHgzID0gdls2XSxcbiAgICAgICAgICB5MyA9IHZbN10sXG4gICAgICAgICAgbm9ybWFsaXplZCA9IHRhbmdlbnQubm9ybWFsaXplKCksXG4gICAgICAgICAgdHggPSBub3JtYWxpemVkLngsXG4gICAgICAgICAgdHkgPSBub3JtYWxpemVkLnksXG4gICAgICAgICAgYXggPSAzICogeDMgLSA5ICogeDIgKyA5ICogeDEgLSAzICogeDAsXG4gICAgICAgICAgYXkgPSAzICogeTMgLSA5ICogeTIgKyA5ICogeTEgLSAzICogeTAsXG4gICAgICAgICAgYnggPSA2ICogeDIgLSAxMiAqIHgxICsgNiAqIHgwLFxuICAgICAgICAgIGJ5ID0gNiAqIHkyIC0gMTIgKiB5MSArIDYgKiB5MCxcbiAgICAgICAgICBjeCA9IDMgKiB4MSAtIDMgKiB4MCxcbiAgICAgICAgICBjeSA9IDMgKiB5MSAtIDMgKiB5MCxcbiAgICAgICAgICBkZW4gPSAyICogYXggKiB0eSAtIDIgKiBheSAqIHR4LFxuICAgICAgICAgIHRpbWVzID0gW107XG5cbiAgICAgIGlmIChNYXRoLmFicyhkZW4pIDwgTnVtZXJpY2FsLkNVUlZFVElNRV9FUFNJTE9OKSB7XG4gICAgICAgIHZhciBudW0gPSBheCAqIGN5IC0gYXkgKiBjeCxcbiAgICAgICAgICAgIGRlbiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuXG4gICAgICAgIGlmIChkZW4gIT0gMCkge1xuICAgICAgICAgIHZhciB0ID0gLW51bSAvIGRlbjtcbiAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkgdGltZXMucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlbHRhID0gKGJ4ICogYnggLSA0ICogYXggKiBjeCkgKiB0eSAqIHR5ICsgKC0yICogYnggKiBieSArIDQgKiBheSAqIGN4ICsgNCAqIGF4ICogY3kpICogdHggKiB0eSArIChieSAqIGJ5IC0gNCAqIGF5ICogY3kpICogdHggKiB0eCxcbiAgICAgICAgICAgIGsgPSBieCAqIHR5IC0gYnkgKiB0eDtcblxuICAgICAgICBpZiAoZGVsdGEgPj0gMCAmJiBkZW4gIT0gMCkge1xuICAgICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KGRlbHRhKSxcbiAgICAgICAgICAgICAgdDAgPSAtKGsgKyBkKSAvIGRlbixcbiAgICAgICAgICAgICAgdDEgPSAoLWsgKyBkKSAvIGRlbjtcbiAgICAgICAgICBpZiAodDAgPj0gMCAmJiB0MCA8PSAxKSB0aW1lcy5wdXNoKHQwKTtcbiAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB0aW1lcy5wdXNoKHQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGltZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uIChjdXJ2ZSkge1xuICAgICAgICB2YXIgdjEgPSB0aGlzLmdldFZhbHVlcygpLFxuICAgICAgICAgICAgdjIgPSBjdXJ2ZSAmJiBjdXJ2ZSAhPT0gdGhpcyAmJiBjdXJ2ZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgcmV0dXJuIHYyID8gZ2V0Q3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgdGhpcywgY3VydmUsIFtdKSA6IGdldFNlbGZJbnRlcnNlY3Rpb24odjEsIHRoaXMsIFtdKTtcbiAgICAgIH0sXG4gICAgICBzdGF0aWNzOiB7XG4gICAgICAgIGdldE92ZXJsYXBzOiBnZXRPdmVybGFwcyxcbiAgICAgICAgZ2V0SW50ZXJzZWN0aW9uczogZ2V0SW50ZXJzZWN0aW9ucyxcbiAgICAgICAgZ2V0Q3VydmVMaW5lSW50ZXJzZWN0aW9uczogZ2V0Q3VydmVMaW5lSW50ZXJzZWN0aW9ucyxcbiAgICAgICAgZ2V0VGltZXNXaXRoVGFuZ2VudDogZ2V0VGltZXNXaXRoVGFuZ2VudFxuICAgICAgfVxuICAgIH07XG4gIH0oKSk7XG4gIHZhciBDdXJ2ZUxvY2F0aW9uID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0N1cnZlTG9jYXRpb24nLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlTG9jYXRpb24oY3VydmUsIHRpbWUsIHBvaW50LCBfb3ZlcmxhcCwgX2Rpc3RhbmNlKSB7XG4gICAgICBpZiAodGltZSA+PSAwLjk5OTk5OTk5KSB7XG4gICAgICAgIHZhciBuZXh0ID0gY3VydmUuZ2V0TmV4dCgpO1xuXG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgdGltZSA9IDA7XG4gICAgICAgICAgY3VydmUgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldEN1cnZlKGN1cnZlKTtcblxuICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgICB0aGlzLl9wb2ludCA9IHBvaW50IHx8IGN1cnZlLmdldFBvaW50QXRUaW1lKHRpbWUpO1xuICAgICAgdGhpcy5fb3ZlcmxhcCA9IF9vdmVybGFwO1xuICAgICAgdGhpcy5fZGlzdGFuY2UgPSBfZGlzdGFuY2U7XG4gICAgICB0aGlzLl9pbnRlcnNlY3Rpb24gPSB0aGlzLl9uZXh0ID0gdGhpcy5fcHJldmlvdXMgPSBudWxsO1xuICAgIH0sXG4gICAgX3NldFBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgIHRoaXMuX3ZlcnNpb24gPSBwYXRoID8gcGF0aC5fdmVyc2lvbiA6IDA7XG4gICAgfSxcbiAgICBfc2V0Q3VydmU6IGZ1bmN0aW9uIChjdXJ2ZSkge1xuICAgICAgdGhpcy5fc2V0UGF0aChjdXJ2ZS5fcGF0aCk7XG5cbiAgICAgIHRoaXMuX2N1cnZlID0gY3VydmU7XG4gICAgICB0aGlzLl9zZWdtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3NlZ21lbnQxID0gY3VydmUuX3NlZ21lbnQxO1xuICAgICAgdGhpcy5fc2VnbWVudDIgPSBjdXJ2ZS5fc2VnbWVudDI7XG4gICAgfSxcbiAgICBfc2V0U2VnbWVudDogZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IHNlZ21lbnQuZ2V0Q3VydmUoKTtcblxuICAgICAgaWYgKGN1cnZlKSB7XG4gICAgICAgIHRoaXMuX3NldEN1cnZlKGN1cnZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldFBhdGgoc2VnbWVudC5fcGF0aCk7XG5cbiAgICAgICAgdGhpcy5fc2VnbWVudDEgPSBzZWdtZW50O1xuICAgICAgICB0aGlzLl9zZWdtZW50MiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgdGhpcy5fdGltZSA9IHNlZ21lbnQgPT09IHRoaXMuX3NlZ21lbnQxID8gMCA6IDE7XG4gICAgICB0aGlzLl9wb2ludCA9IHNlZ21lbnQuX3BvaW50LmNsb25lKCk7XG4gICAgfSxcbiAgICBnZXRTZWdtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnQ7XG5cbiAgICAgIGlmICghc2VnbWVudCkge1xuICAgICAgICB2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG4gICAgICAgICAgICB0aW1lID0gdGhpcy5nZXRUaW1lKCk7XG5cbiAgICAgICAgaWYgKHRpbWUgPT09IDApIHtcbiAgICAgICAgICBzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQxO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWUgPT09IDEpIHtcbiAgICAgICAgICBzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWUgIT0gbnVsbCkge1xuICAgICAgICAgIHNlZ21lbnQgPSBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHRpbWUpIDwgY3VydmUuZ2V0UGFydExlbmd0aCh0aW1lLCAxKSA/IGN1cnZlLl9zZWdtZW50MSA6IGN1cnZlLl9zZWdtZW50MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICB9LFxuICAgIGdldEN1cnZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgIGlmIChwYXRoICYmIHBhdGguX3ZlcnNpb24gIT09IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuX29mZnNldCA9IHRoaXMuX2N1cnZlT2Zmc2V0ID0gdGhpcy5fY3VydmUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0cnlTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgICAgdmFyIGN1cnZlID0gc2VnbWVudCAmJiBzZWdtZW50LmdldEN1cnZlKCk7XG5cbiAgICAgICAgaWYgKGN1cnZlICYmICh0aGF0Ll90aW1lID0gY3VydmUuZ2V0VGltZU9mKHRoYXQuX3BvaW50KSkgIT0gbnVsbCkge1xuICAgICAgICAgIHRoYXQuX3NldEN1cnZlKGN1cnZlKTtcblxuICAgICAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY3VydmUgfHwgdHJ5U2VnbWVudCh0aGlzLl9zZWdtZW50KSB8fCB0cnlTZWdtZW50KHRoaXMuX3NlZ21lbnQxKSB8fCB0cnlTZWdtZW50KHRoaXMuX3NlZ21lbnQyLmdldFByZXZpb3VzKCkpO1xuICAgIH0sXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuICAgICAgcmV0dXJuIGN1cnZlICYmIGN1cnZlLl9wYXRoO1xuICAgIH0sXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcbiAgICAgIHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5nZXRJbmRleCgpO1xuICAgIH0sXG4gICAgZ2V0VGltZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgIHRpbWUgPSB0aGlzLl90aW1lO1xuICAgICAgcmV0dXJuIGN1cnZlICYmIHRpbWUgPT0gbnVsbCA/IHRoaXMuX3RpbWUgPSBjdXJ2ZS5nZXRUaW1lT2YodGhpcy5fcG9pbnQpIDogdGltZTtcbiAgICB9LFxuICAgIGdldFBhcmFtZXRlcjogJyNnZXRUaW1lJyxcbiAgICBnZXRQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BvaW50O1xuICAgIH0sXG4gICAgZ2V0T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuXG4gICAgICBpZiAob2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLmdldFBhdGgoKSxcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXG4gICAgICAgIGlmIChwYXRoICYmIGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgY3VydmVzID0gcGF0aC5nZXRDdXJ2ZXMoKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykgb2Zmc2V0ICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldCArPSB0aGlzLmdldEN1cnZlT2Zmc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSxcbiAgICBnZXRDdXJ2ZU9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2N1cnZlT2Zmc2V0O1xuXG4gICAgICBpZiAob2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgICAgdGltZSA9IHRoaXMuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLl9jdXJ2ZU9mZnNldCA9IG9mZnNldCA9IHRpbWUgIT0gbnVsbCAmJiBjdXJ2ZSAmJiBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHRpbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH0sXG4gICAgZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZTtcbiAgICB9LFxuICAgIGRpdmlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgIHJlcyA9IGN1cnZlICYmIGN1cnZlLmRpdmlkZUF0VGltZSh0aGlzLmdldFRpbWUoKSk7XG5cbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgdGhpcy5fc2V0U2VnbWVudChyZXMuX3NlZ21lbnQxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIHNwbGl0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG4gICAgICAgICAgcGF0aCA9IGN1cnZlLl9wYXRoLFxuICAgICAgICAgIHJlcyA9IGN1cnZlICYmIGN1cnZlLnNwbGl0QXRUaW1lKHRoaXMuZ2V0VGltZSgpKTtcblxuICAgICAgaWYgKHJlcykge1xuICAgICAgICB0aGlzLl9zZXRTZWdtZW50KHBhdGguZ2V0TGFzdFNlZ21lbnQoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChsb2MsIF9pZ25vcmVPdGhlcikge1xuICAgICAgdmFyIHJlcyA9IHRoaXMgPT09IGxvYztcblxuICAgICAgaWYgKCFyZXMgJiYgbG9jIGluc3RhbmNlb2YgQ3VydmVMb2NhdGlvbikge1xuICAgICAgICB2YXIgYzEgPSB0aGlzLmdldEN1cnZlKCksXG4gICAgICAgICAgICBjMiA9IGxvYy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgICAgcDEgPSBjMS5fcGF0aCxcbiAgICAgICAgICAgIHAyID0gYzIuX3BhdGg7XG5cbiAgICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICAgICAgZXBzaWxvbiA9IDFlLTcsXG4gICAgICAgICAgICAgIGRpZmYgPSBhYnModGhpcy5nZXRPZmZzZXQoKSAtIGxvYy5nZXRPZmZzZXQoKSksXG4gICAgICAgICAgICAgIGkxID0gIV9pZ25vcmVPdGhlciAmJiB0aGlzLl9pbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICAgIGkyID0gIV9pZ25vcmVPdGhlciAmJiBsb2MuX2ludGVyc2VjdGlvbjtcbiAgICAgICAgICByZXMgPSAoZGlmZiA8IGVwc2lsb24gfHwgcDEgJiYgYWJzKHAxLmdldExlbmd0aCgpIC0gZGlmZikgPCBlcHNpbG9uKSAmJiAoIWkxICYmICFpMiB8fCBpMSAmJiBpMiAmJiBpMS5lcXVhbHMoaTIsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdLFxuICAgICAgICAgIHBvaW50ID0gdGhpcy5nZXRQb2ludCgpLFxuICAgICAgICAgIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG4gICAgICBpZiAocG9pbnQpIHBhcnRzLnB1c2goJ3BvaW50OiAnICsgcG9pbnQpO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHBhcnRzLnB1c2goJ2luZGV4OiAnICsgaW5kZXgpO1xuICAgICAgdmFyIHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcbiAgICAgIGlmICh0aW1lICE9IG51bGwpIHBhcnRzLnB1c2goJ3RpbWU6ICcgKyBmLm51bWJlcih0aW1lKSk7XG4gICAgICBpZiAodGhpcy5fZGlzdGFuY2UgIT0gbnVsbCkgcGFydHMucHVzaCgnZGlzdGFuY2U6ICcgKyBmLm51bWJlcih0aGlzLl9kaXN0YW5jZSkpO1xuICAgICAgcmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9JztcbiAgICB9LFxuICAgIGlzVG91Y2hpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnRlciA9IHRoaXMuX2ludGVyc2VjdGlvbjtcblxuICAgICAgaWYgKGludGVyICYmIHRoaXMuZ2V0VGFuZ2VudCgpLmlzQ29sbGluZWFyKGludGVyLmdldFRhbmdlbnQoKSkpIHtcbiAgICAgICAgdmFyIGN1cnZlMSA9IHRoaXMuZ2V0Q3VydmUoKSxcbiAgICAgICAgICAgIGN1cnZlMiA9IGludGVyLmdldEN1cnZlKCk7XG4gICAgICAgIHJldHVybiAhKGN1cnZlMS5pc1N0cmFpZ2h0KCkgJiYgY3VydmUyLmlzU3RyYWlnaHQoKSAmJiBjdXJ2ZTEuZ2V0TGluZSgpLmludGVyc2VjdChjdXJ2ZTIuZ2V0TGluZSgpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGlzQ3Jvc3Npbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnRlciA9IHRoaXMuX2ludGVyc2VjdGlvbjtcbiAgICAgIGlmICghaW50ZXIpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciB0MSA9IHRoaXMuZ2V0VGltZSgpLFxuICAgICAgICAgIHQyID0gaW50ZXIuZ2V0VGltZSgpLFxuICAgICAgICAgIHRNaW4gPSAxZS04LFxuICAgICAgICAgIHRNYXggPSAxIC0gdE1pbixcbiAgICAgICAgICB0MUluc2lkZSA9IHQxID49IHRNaW4gJiYgdDEgPD0gdE1heCxcbiAgICAgICAgICB0Mkluc2lkZSA9IHQyID49IHRNaW4gJiYgdDIgPD0gdE1heDtcbiAgICAgIGlmICh0MUluc2lkZSAmJiB0Mkluc2lkZSkgcmV0dXJuICF0aGlzLmlzVG91Y2hpbmcoKTtcbiAgICAgIHZhciBjMiA9IHRoaXMuZ2V0Q3VydmUoKSxcbiAgICAgICAgICBjMSA9IGMyICYmIHQxIDwgdE1pbiA/IGMyLmdldFByZXZpb3VzKCkgOiBjMixcbiAgICAgICAgICBjNCA9IGludGVyLmdldEN1cnZlKCksXG4gICAgICAgICAgYzMgPSBjNCAmJiB0MiA8IHRNaW4gPyBjNC5nZXRQcmV2aW91cygpIDogYzQ7XG4gICAgICBpZiAodDEgPiB0TWF4KSBjMiA9IGMyLmdldE5leHQoKTtcbiAgICAgIGlmICh0MiA+IHRNYXgpIGM0ID0gYzQuZ2V0TmV4dCgpO1xuICAgICAgaWYgKCFjMSB8fCAhYzIgfHwgIWMzIHx8ICFjNCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIG9mZnNldHMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gYWRkT2Zmc2V0cyhjdXJ2ZSwgZW5kKSB7XG4gICAgICAgIHZhciB2ID0gY3VydmUuZ2V0VmFsdWVzKCksXG4gICAgICAgICAgICByb290cyA9IEN1cnZlLmNsYXNzaWZ5KHYpLnJvb3RzIHx8IEN1cnZlLmdldFBlYWtzKHYpLFxuICAgICAgICAgICAgY291bnQgPSByb290cy5sZW5ndGgsXG4gICAgICAgICAgICBvZmZzZXQgPSBDdXJ2ZS5nZXRMZW5ndGgodiwgZW5kICYmIGNvdW50ID8gcm9vdHNbY291bnQgLSAxXSA6IDAsICFlbmQgJiYgY291bnQgPyByb290c1swXSA6IDEpO1xuICAgICAgICBvZmZzZXRzLnB1c2goY291bnQgPyBvZmZzZXQgOiBvZmZzZXQgLyAzMik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSW5SYW5nZShhbmdsZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG1pbiA8IG1heCA/IGFuZ2xlID4gbWluICYmIGFuZ2xlIDwgbWF4IDogYW5nbGUgPiBtaW4gfHwgYW5nbGUgPCBtYXg7XG4gICAgICB9XG5cbiAgICAgIGlmICghdDFJbnNpZGUpIHtcbiAgICAgICAgYWRkT2Zmc2V0cyhjMSwgdHJ1ZSk7XG4gICAgICAgIGFkZE9mZnNldHMoYzIsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0Mkluc2lkZSkge1xuICAgICAgICBhZGRPZmZzZXRzKGMzLCB0cnVlKTtcbiAgICAgICAgYWRkT2Zmc2V0cyhjNCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHQgPSB0aGlzLmdldFBvaW50KCksXG4gICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2Zmc2V0cyksXG4gICAgICAgICAgdjIgPSB0MUluc2lkZSA/IGMyLmdldFRhbmdlbnRBdFRpbWUodDEpIDogYzIuZ2V0UG9pbnRBdChvZmZzZXQpLnN1YnRyYWN0KHB0KSxcbiAgICAgICAgICB2MSA9IHQxSW5zaWRlID8gdjIubmVnYXRlKCkgOiBjMS5nZXRQb2ludEF0KC1vZmZzZXQpLnN1YnRyYWN0KHB0KSxcbiAgICAgICAgICB2NCA9IHQySW5zaWRlID8gYzQuZ2V0VGFuZ2VudEF0VGltZSh0MikgOiBjNC5nZXRQb2ludEF0KG9mZnNldCkuc3VidHJhY3QocHQpLFxuICAgICAgICAgIHYzID0gdDJJbnNpZGUgPyB2NC5uZWdhdGUoKSA6IGMzLmdldFBvaW50QXQoLW9mZnNldCkuc3VidHJhY3QocHQpLFxuICAgICAgICAgIGExID0gdjEuZ2V0QW5nbGUoKSxcbiAgICAgICAgICBhMiA9IHYyLmdldEFuZ2xlKCksXG4gICAgICAgICAgYTMgPSB2My5nZXRBbmdsZSgpLFxuICAgICAgICAgIGE0ID0gdjQuZ2V0QW5nbGUoKTtcbiAgICAgIHJldHVybiAhISh0MUluc2lkZSA/IGlzSW5SYW5nZShhMSwgYTMsIGE0KSBeIGlzSW5SYW5nZShhMiwgYTMsIGE0KSAmJiBpc0luUmFuZ2UoYTEsIGE0LCBhMykgXiBpc0luUmFuZ2UoYTIsIGE0LCBhMykgOiBpc0luUmFuZ2UoYTMsIGExLCBhMikgXiBpc0luUmFuZ2UoYTQsIGExLCBhMikgJiYgaXNJblJhbmdlKGEzLCBhMiwgYTEpIF4gaXNJblJhbmdlKGE0LCBhMiwgYTEpKTtcbiAgICB9LFxuICAgIGhhc092ZXJsYXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX292ZXJsYXA7XG4gICAgfVxuICB9LCBCYXNlLmVhY2goQ3VydmUuX2V2YWx1YXRlTWV0aG9kcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZ2V0ID0gbmFtZSArICdBdCc7XG5cbiAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgIHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiB0aW1lICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmVbZ2V0XSh0aW1lLCB0cnVlKTtcbiAgICB9O1xuICB9LCB7XG4gICAgcHJlc2VydmU6IHRydWVcbiAgfSksIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaW5zZXJ0KGxvY2F0aW9ucywgbG9jLCBtZXJnZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGxvY2F0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgbCA9IDAsXG4gICAgICAgICAgciA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIGZ1bmN0aW9uIHNlYXJjaChpbmRleCwgZGlyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIGRpcjsgaSA+PSAtMSAmJiBpIDw9IGxlbmd0aDsgaSArPSBkaXIpIHtcbiAgICAgICAgICB2YXIgbG9jMiA9IGxvY2F0aW9uc1soaSAlIGxlbmd0aCArIGxlbmd0aCkgJSBsZW5ndGhdO1xuICAgICAgICAgIGlmICghbG9jLmdldFBvaW50KCkuaXNDbG9zZShsb2MyLmdldFBvaW50KCksIDFlLTcpKSBicmVhaztcbiAgICAgICAgICBpZiAobG9jLmVxdWFscyhsb2MyKSkgcmV0dXJuIGxvYzI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGwgPD0gcikge1xuICAgICAgICB2YXIgbSA9IGwgKyByID4+PiAxLFxuICAgICAgICAgICAgbG9jMiA9IGxvY2F0aW9uc1ttXSxcbiAgICAgICAgICAgIGZvdW5kO1xuXG4gICAgICAgIGlmIChtZXJnZSAmJiAoZm91bmQgPSBsb2MuZXF1YWxzKGxvYzIpID8gbG9jMiA6IHNlYXJjaChtLCAtMSkgfHwgc2VhcmNoKG0sIDEpKSkge1xuICAgICAgICAgIGlmIChsb2MuX292ZXJsYXApIHtcbiAgICAgICAgICAgIGZvdW5kLl9vdmVybGFwID0gZm91bmQuX2ludGVyc2VjdGlvbi5fb3ZlcmxhcCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGgxID0gbG9jLmdldFBhdGgoKSxcbiAgICAgICAgICAgIHBhdGgyID0gbG9jMi5nZXRQYXRoKCksXG4gICAgICAgICAgICBkaWZmID0gcGF0aDEgIT09IHBhdGgyID8gcGF0aDEuX2lkIC0gcGF0aDIuX2lkIDogbG9jLmdldEluZGV4KCkgKyBsb2MuZ2V0VGltZSgpIC0gKGxvYzIuZ2V0SW5kZXgoKSArIGxvYzIuZ2V0VGltZSgpKTtcblxuICAgICAgICBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICByID0gbSAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbCA9IG0gKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxvY2F0aW9ucy5zcGxpY2UobCwgMCwgbG9jKTtcbiAgICAgIHJldHVybiBsb2M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgaW5zZXJ0OiBpbnNlcnQsXG4gICAgICAgIGV4cGFuZDogZnVuY3Rpb24gKGxvY2F0aW9ucykge1xuICAgICAgICAgIHZhciBleHBhbmRlZCA9IGxvY2F0aW9ucy5zbGljZSgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IGxvY2F0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaW5zZXJ0KGV4cGFuZGVkLCBsb2NhdGlvbnNbaV0uX2ludGVyc2VjdGlvbiwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0oKSk7XG4gIHZhciBQYXRoSXRlbSA9IEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdQYXRoSXRlbScsXG4gICAgX3NlbGVjdEJvdW5kczogZmFsc2UsXG4gICAgX2NhblNjYWxlU3Ryb2tlOiB0cnVlLFxuICAgIGJlYW5zOiB0cnVlLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGhJdGVtKCkge30sXG4gICAgc3RhdGljczoge1xuICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBkYXRhLCBzZWdtZW50cywgY29tcG91bmQ7XG5cbiAgICAgICAgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKSB7XG4gICAgICAgICAgc2VnbWVudHMgPSBhcmcuc2VnbWVudHM7XG4gICAgICAgICAgZGF0YSA9IGFyZy5wYXRoRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICBzZWdtZW50cyA9IGFyZztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGRhdGEgPSBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgICB2YXIgZmlyc3QgPSBzZWdtZW50c1swXTtcbiAgICAgICAgICBjb21wb3VuZCA9IGZpcnN0ICYmIEFycmF5LmlzQXJyYXkoZmlyc3RbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgICAgICBjb21wb3VuZCA9IChkYXRhLm1hdGNoKC9tL2dpKSB8fCBbXSkubGVuZ3RoID4gMSB8fCAvelxccypcXFMrL2kudGVzdChkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdG9yID0gY29tcG91bmQgPyBDb21wb3VuZFBhdGggOiBQYXRoO1xuICAgICAgICByZXR1cm4gbmV3IGN0b3IoYXJnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9hc1BhdGhJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGlzQ2xvY2t3aXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBcmVhKCkgPj0gMDtcbiAgICB9LFxuICAgIHNldENsb2Nrd2lzZTogZnVuY3Rpb24gKGNsb2Nrd2lzZSkge1xuICAgICAgaWYgKHRoaXMuaXNDbG9ja3dpc2UoKSAhPSAoY2xvY2t3aXNlID0gISFjbG9ja3dpc2UpKSB0aGlzLnJldmVyc2UoKTtcbiAgICB9LFxuICAgIHNldFBhdGhEYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIHBhcnRzID0gZGF0YSAmJiBkYXRhLm1hdGNoKC9bbWxodmNzcXRhel1bXm1saHZjc3F0YXpdKi9pZyksXG4gICAgICAgICAgY29vcmRzLFxuICAgICAgICAgIHJlbGF0aXZlID0gZmFsc2UsXG4gICAgICAgICAgcHJldmlvdXMsXG4gICAgICAgICAgY29udHJvbCxcbiAgICAgICAgICBjdXJyZW50ID0gbmV3IFBvaW50KCksXG4gICAgICAgICAgc3RhcnQgPSBuZXcgUG9pbnQoKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0Q29vcmQoaW5kZXgsIGNvb3JkKSB7XG4gICAgICAgIHZhciB2YWwgPSArY29vcmRzW2luZGV4XTtcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB2YWwgKz0gY3VycmVudFtjb29yZF07XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBvaW50KGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoZ2V0Q29vcmQoaW5kZXgsICd4JyksIGdldENvb3JkKGluZGV4ICsgMSwgJ3knKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXSxcbiAgICAgICAgICAgIGNvbW1hbmQgPSBwYXJ0WzBdLFxuICAgICAgICAgICAgbG93ZXIgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvb3JkcyA9IHBhcnQubWF0Y2goL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY29vcmRzICYmIGNvb3Jkcy5sZW5ndGg7XG4gICAgICAgIHJlbGF0aXZlID0gY29tbWFuZCA9PT0gbG93ZXI7XG4gICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ3onICYmICEvW216XS8udGVzdChsb3dlcikpIHRoaXMubW92ZVRvKGN1cnJlbnQpO1xuXG4gICAgICAgIHN3aXRjaCAobG93ZXIpIHtcbiAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgIHZhciBtb3ZlID0gbG93ZXIgPT09ICdtJztcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICB0aGlzW21vdmUgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuXG4gICAgICAgICAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIG1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250cm9sID0gY3VycmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICB2YXIgY29vcmQgPSBsb3dlciA9PT0gJ2gnID8gJ3gnIDogJ3knO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2xvbmUoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBjdXJyZW50W2Nvb3JkXSA9IGdldENvb3JkKGosIGNvb3JkKTtcbiAgICAgICAgICAgICAgdGhpcy5saW5lVG8oY3VycmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRyb2wgPSBjdXJyZW50O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDYpIHtcbiAgICAgICAgICAgICAgdGhpcy5jdWJpY0N1cnZlVG8oZ2V0UG9pbnQoaiksIGNvbnRyb2wgPSBnZXRQb2ludChqICsgMiksIGN1cnJlbnQgPSBnZXRQb2ludChqICsgNCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuICAgICAgICAgICAgICB0aGlzLmN1YmljQ3VydmVUbygvW2NzXS8udGVzdChwcmV2aW91cykgPyBjdXJyZW50Lm11bHRpcGx5KDIpLnN1YnRyYWN0KGNvbnRyb2wpIDogY3VycmVudCwgY29udHJvbCA9IGdldFBvaW50KGopLCBjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcbiAgICAgICAgICAgICAgcHJldmlvdXMgPSBsb3dlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcbiAgICAgICAgICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2wgPSBnZXRQb2ludChqKSwgY3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgIHRoaXMucXVhZHJhdGljQ3VydmVUbyhjb250cm9sID0gL1txdF0vLnRlc3QocHJldmlvdXMpID8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKSA6IGN1cnJlbnQsIGN1cnJlbnQgPSBnZXRQb2ludChqKSk7XG4gICAgICAgICAgICAgIHByZXZpb3VzID0gbG93ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA3KSB7XG4gICAgICAgICAgICAgIHRoaXMuYXJjVG8oY3VycmVudCA9IGdldFBvaW50KGogKyA1KSwgbmV3IFNpemUoK2Nvb3Jkc1tqXSwgK2Nvb3Jkc1tqICsgMV0pLCArY29vcmRzW2ogKyAyXSwgK2Nvb3Jkc1tqICsgNF0sICtjb29yZHNbaiArIDNdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQYXRoKDFlLTEyKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBzdGFydDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXMgPSBsb3dlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkpO1xuICAgIH0sXG4gICAgX2NvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHZhciB3aW5kaW5nID0gcG9pbnQuaXNJbnNpZGUodGhpcy5nZXRCb3VuZHMoe1xuICAgICAgICBpbnRlcm5hbDogdHJ1ZSxcbiAgICAgICAgaGFuZGxlOiB0cnVlXG4gICAgICB9KSkgPyB0aGlzLl9nZXRXaW5kaW5nKHBvaW50KSA6IHt9O1xuICAgICAgcmV0dXJuIHdpbmRpbmcub25QYXRoIHx8ICEhKHRoaXMuZ2V0RmlsbFJ1bGUoKSA9PT0gJ2V2ZW5vZGQnID8gd2luZGluZy53aW5kaW5nTCAmIDEgfHwgd2luZGluZy53aW5kaW5nUiAmIDEgOiB3aW5kaW5nLndpbmRpbmcpO1xuICAgIH0sXG4gICAgZ2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24gKHBhdGgsIGluY2x1ZGUsIF9tYXRyaXgsIF9yZXR1cm5GaXJzdCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzID09PSBwYXRoIHx8ICFwYXRoLFxuICAgICAgICAgIG1hdHJpeDEgPSB0aGlzLl9tYXRyaXguX29yTnVsbElmSWRlbnRpdHkoKSxcbiAgICAgICAgICBtYXRyaXgyID0gc2VsZiA/IG1hdHJpeDEgOiAoX21hdHJpeCB8fCBwYXRoLl9tYXRyaXgpLl9vck51bGxJZklkZW50aXR5KCk7XG5cbiAgICAgIHJldHVybiBzZWxmIHx8IHRoaXMuZ2V0Qm91bmRzKG1hdHJpeDEpLmludGVyc2VjdHMocGF0aC5nZXRCb3VuZHMobWF0cml4MiksIDFlLTEyKSA/IEN1cnZlLmdldEludGVyc2VjdGlvbnModGhpcy5nZXRDdXJ2ZXMoKSwgIXNlbGYgJiYgcGF0aC5nZXRDdXJ2ZXMoKSwgaW5jbHVkZSwgbWF0cml4MSwgbWF0cml4MiwgX3JldHVybkZpcnN0KSA6IFtdO1xuICAgIH0sXG4gICAgZ2V0Q3Jvc3NpbmdzOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJzZWN0aW9ucyhwYXRoLCBmdW5jdGlvbiAoaW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIGludGVyLmlzQ3Jvc3NpbmcoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcbiAgICAgICAgICBtaW5EaXN0ID0gSW5maW5pdHksXG4gICAgICAgICAgbWluTG9jID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblxuICAgICAgICBpZiAobG9jLl9kaXN0YW5jZSA8IG1pbkRpc3QpIHtcbiAgICAgICAgICBtaW5EaXN0ID0gbG9jLl9kaXN0YW5jZTtcbiAgICAgICAgICBtaW5Mb2MgPSBsb2M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pbkxvYztcbiAgICB9LFxuICAgIGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbG9jID8gbG9jLmdldFBvaW50KCkgOiBsb2M7XG4gICAgfSxcbiAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICAgIHZhciBpc1BhdGggPSAhdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgbmFtZSA9IGlzUGF0aCA/ICdfc2VnbWVudHMnIDogJ19jaGlsZHJlbicsXG4gICAgICAgICAgaXRlbXNGcm9tID0gZnJvbVtuYW1lXSxcbiAgICAgICAgICBpdGVtc1RvID0gdG9bbmFtZV0sXG4gICAgICAgICAgaXRlbXMgPSB0aGlzW25hbWVdO1xuXG4gICAgICBpZiAoIWl0ZW1zRnJvbSB8fCAhaXRlbXNUbyB8fCBpdGVtc0Zyb20ubGVuZ3RoICE9PSBpdGVtc1RvLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BlcmFuZHMgaW4gaW50ZXJwb2xhdGUoKSBjYWxsOiAnICsgZnJvbSArICcsICcgKyB0byk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50ID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGl0ZW1zVG8ubGVuZ3RoO1xuXG4gICAgICBpZiAoY3VycmVudCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgY3RvciA9IGlzUGF0aCA/IFNlZ21lbnQgOiBQYXRoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBjdXJyZW50OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmFkZChuZXcgY3RvcigpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50ID4gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbaXNQYXRoID8gJ3JlbW92ZVNlZ21lbnRzJyA6ICdyZW1vdmVDaGlsZHJlbiddKGxlbmd0aCwgY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbXNbaV0uaW50ZXJwb2xhdGUoaXRlbXNGcm9tW2ldLCBpdGVtc1RvW2ldLCBmYWN0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQYXRoKSB7XG4gICAgICAgIHRoaXMuc2V0Q2xvc2VkKGZyb20uX2Nsb3NlZCk7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCg5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB2YXIgb2sgPSBmYWxzZTtcblxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIHBhdGhzMSA9IHRoaXMuX2NoaWxkcmVuIHx8IFt0aGlzXSxcbiAgICAgICAgICAgIHBhdGhzMiA9IHBhdGguX2NoaWxkcmVuID8gcGF0aC5fY2hpbGRyZW4uc2xpY2UoKSA6IFtwYXRoXSxcbiAgICAgICAgICAgIGxlbmd0aDEgPSBwYXRoczEubGVuZ3RoLFxuICAgICAgICAgICAgbGVuZ3RoMiA9IHBhdGhzMi5sZW5ndGgsXG4gICAgICAgICAgICBtYXRjaGVkID0gW10sXG4gICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgdmFyIGJvdW5kc092ZXJsYXBzID0gQ29sbGlzaW9uRGV0ZWN0aW9uLmZpbmRJdGVtQm91bmRzQ29sbGlzaW9ucyhwYXRoczEsIHBhdGhzMiwgTnVtZXJpY2FsLkdFT01FVFJJQ19FUFNJTE9OKTtcblxuICAgICAgICBmb3IgKHZhciBpMSA9IGxlbmd0aDEgLSAxOyBpMSA+PSAwICYmIG9rOyBpMS0tKSB7XG4gICAgICAgICAgdmFyIHBhdGgxID0gcGF0aHMxW2kxXTtcbiAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgIHZhciBwYXRoQm91bmRzT3ZlcmxhcHMgPSBib3VuZHNPdmVybGFwc1tpMV07XG5cbiAgICAgICAgICBpZiAocGF0aEJvdW5kc092ZXJsYXBzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpMiA9IHBhdGhCb3VuZHNPdmVybGFwcy5sZW5ndGggLSAxOyBpMiA+PSAwICYmICFvazsgaTItLSkge1xuICAgICAgICAgICAgICBpZiAocGF0aDEuY29tcGFyZShwYXRoczJbcGF0aEJvdW5kc092ZXJsYXBzW2kyXV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkW3BhdGhCb3VuZHNPdmVybGFwc1tpMl1dKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVkW3BhdGhCb3VuZHNPdmVybGFwc1tpMl1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2sgPSBvayAmJiBjb3VudCA9PT0gbGVuZ3RoMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9rO1xuICAgIH1cbiAgfSk7XG4gIHZhciBQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdQYXRoJyxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICBzZWdtZW50czogW10sXG4gICAgICBjbG9zZWQ6IGZhbHNlXG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoKGFyZykge1xuICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLl9zZWdtZW50cyA9IFtdO1xuICAgICAgdGhpcy5fdmVyc2lvbiA9IDA7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBzZWdtZW50cyA9IEFycmF5LmlzQXJyYXkoYXJnKSA/IHR5cGVvZiBhcmdbMF0gPT09ICdvYmplY3QnID8gYXJnIDogYXJncyA6IGFyZyAmJiBhcmcuc2l6ZSA9PT0gdW5kZWZpbmVkICYmIChhcmcueCAhPT0gdW5kZWZpbmVkIHx8IGFyZy5wb2ludCAhPT0gdW5kZWZpbmVkKSA/IGFyZ3MgOiBudWxsO1xuXG4gICAgICBpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2N1cnZlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2VnbWVudFNlbGVjdGlvbiA9IDA7XG5cbiAgICAgICAgaWYgKCFzZWdtZW50cyAmJiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcbiAgICAgICAgICBhcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXRpYWxpemUoIXNlZ21lbnRzICYmIGFyZyk7XG4gICAgfSxcbiAgICBfZXF1YWxzOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZCA9PT0gaXRlbS5fY2xvc2VkICYmIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG4gICAgfSxcbiAgICBjb3B5Q29udGVudDogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgdGhpcy5zZXRTZWdtZW50cyhzb3VyY2UuX3NlZ21lbnRzKTtcbiAgICAgIHRoaXMuX2Nsb3NlZCA9IHNvdXJjZS5fY2xvc2VkO1xuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG4gICAgICBfY2hhbmdlZC5iYXNlLmNhbGwodGhpcywgZmxhZ3MpO1xuXG4gICAgICBpZiAoZmxhZ3MgJiA4KSB7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHRoaXMuX2FyZWEgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgMzIpIHtcbiAgICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3VydmVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB0aGlzLl9jdXJ2ZXNbaV0uX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmbGFncyAmIDY0KSB7XG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFN0eWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgcmV0dXJuIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGggPyBwYXJlbnQgOiB0aGlzKS5fc3R5bGU7XG4gICAgfSxcbiAgICBnZXRTZWdtZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzO1xuICAgIH0sXG4gICAgc2V0U2VnbWVudHM6IGZ1bmN0aW9uIChzZWdtZW50cykge1xuICAgICAgdmFyIGZ1bGx5U2VsZWN0ZWQgPSB0aGlzLmlzRnVsbHlTZWxlY3RlZCgpLFxuICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9zZWdtZW50U2VsZWN0aW9uID0gMDtcbiAgICAgIHRoaXMuX2N1cnZlcyA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgbGFzdCA9IHNlZ21lbnRzW2xlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGFzdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhpcy5zZXRDbG9zZWQobGFzdCk7XG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hZGQoU2VnbWVudC5yZWFkTGlzdChzZWdtZW50cywgMCwge30sIGxlbmd0aCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnVsbHlTZWxlY3RlZCkgdGhpcy5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuICAgIH0sXG4gICAgZ2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VnbWVudHNbMF07XG4gICAgfSxcbiAgICBnZXRMYXN0U2VnbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzW3RoaXMuX3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH0sXG4gICAgZ2V0Q3VydmVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuICAgICAgICAgIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cbiAgICAgIGlmICghY3VydmVzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9jb3VudEN1cnZlcygpO1xuXG4gICAgICAgIGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGN1cnZlc1tpXSA9IG5ldyBDdXJ2ZSh0aGlzLCBzZWdtZW50c1tpXSwgc2VnbWVudHNbaSArIDFdIHx8IHNlZ21lbnRzWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnZlcztcbiAgICB9LFxuICAgIGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEN1cnZlcygpWzBdO1xuICAgIH0sXG4gICAgZ2V0TGFzdEN1cnZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcbiAgICAgIHJldHVybiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdO1xuICAgIH0sXG4gICAgaXNDbG9zZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgfSxcbiAgICBzZXRDbG9zZWQ6IGZ1bmN0aW9uIChjbG9zZWQpIHtcbiAgICAgIGlmICh0aGlzLl9jbG9zZWQgIT0gKGNsb3NlZCA9ICEhY2xvc2VkKSkge1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSBjbG9zZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2N1cnZlcykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9jdXJ2ZXMubGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblxuICAgICAgICAgIGlmIChjbG9zZWQpIHRoaXMuX2N1cnZlc1tsZW5ndGggLSAxXSA9IG5ldyBDdXJ2ZSh0aGlzLCB0aGlzLl9zZWdtZW50c1tsZW5ndGggLSAxXSwgdGhpcy5fc2VnbWVudHNbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCg0MSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgYmVhbnM6IHRydWUsXG4gICAgZ2V0UGF0aERhdGE6IGZ1bmN0aW9uIChfbWF0cml4LCBfcHJlY2lzaW9uKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgZiA9IG5ldyBGb3JtYXR0ZXIoX3ByZWNpc2lvbiksXG4gICAgICAgICAgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuICAgICAgICAgIGZpcnN0ID0gdHJ1ZSxcbiAgICAgICAgICBjdXJYLFxuICAgICAgICAgIGN1clksXG4gICAgICAgICAgcHJldlgsXG4gICAgICAgICAgcHJldlksXG4gICAgICAgICAgaW5YLFxuICAgICAgICAgIGluWSxcbiAgICAgICAgICBvdXRYLFxuICAgICAgICAgIG91dFksXG4gICAgICAgICAgcGFydHMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50LCBza2lwTGluZSkge1xuICAgICAgICBzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhfbWF0cml4LCBjb29yZHMpO1xuXG4gICAgICAgIGN1clggPSBjb29yZHNbMF07XG4gICAgICAgIGN1clkgPSBjb29yZHNbMV07XG5cbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgcGFydHMucHVzaCgnTScgKyBmLnBhaXIoY3VyWCwgY3VyWSkpO1xuICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5YID0gY29vcmRzWzJdO1xuICAgICAgICAgIGluWSA9IGNvb3Jkc1szXTtcblxuICAgICAgICAgIGlmIChpblggPT09IGN1clggJiYgaW5ZID09PSBjdXJZICYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG4gICAgICAgICAgICBpZiAoIXNraXBMaW5lKSB7XG4gICAgICAgICAgICAgIHZhciBkeCA9IGN1clggLSBwcmV2WCxcbiAgICAgICAgICAgICAgICAgIGR5ID0gY3VyWSAtIHByZXZZO1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGR4ID09PSAwID8gJ3YnICsgZi5udW1iZXIoZHkpIDogZHkgPT09IDAgPyAnaCcgKyBmLm51bWJlcihkeCkgOiAnbCcgKyBmLnBhaXIoZHgsIGR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJ2MnICsgZi5wYWlyKG91dFggLSBwcmV2WCwgb3V0WSAtIHByZXZZKSArICcgJyArIGYucGFpcihpblggLSBwcmV2WCwgaW5ZIC0gcHJldlkpICsgJyAnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJldlggPSBjdXJYO1xuICAgICAgICBwcmV2WSA9IGN1clk7XG4gICAgICAgIG91dFggPSBjb29yZHNbNF07XG4gICAgICAgIG91dFkgPSBjb29yZHNbNV07XG4gICAgICB9XG5cbiAgICAgIGlmICghbGVuZ3RoKSByZXR1cm4gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGFkZFNlZ21lbnQoc2VnbWVudHNbaV0pO1xuXG4gICAgICBpZiAodGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDApIHtcbiAgICAgICAgYWRkU2VnbWVudChzZWdtZW50c1swXSwgdHJ1ZSk7XG4gICAgICAgIHBhcnRzLnB1c2goJ3onKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG4gICAgfSxcbiAgICBfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgY29vcmRzID0gbmV3IEFycmF5KDYpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykgc2VnbWVudHNbaV0uX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBfYWRkOiBmdW5jdGlvbiAoc2VncywgaW5kZXgpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgIGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcbiAgICAgICAgICBhbW91bnQgPSBzZWdzLmxlbmd0aCxcbiAgICAgICAgICBhcHBlbmQgPSBpbmRleCA9PSBudWxsLFxuICAgICAgICAgIGluZGV4ID0gYXBwZW5kID8gc2VnbWVudHMubGVuZ3RoIDogaW5kZXg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdzW2ldO1xuICAgICAgICBpZiAoc2VnbWVudC5fcGF0aCkgc2VnbWVudCA9IHNlZ3NbaV0gPSBzZWdtZW50LmNsb25lKCk7XG4gICAgICAgIHNlZ21lbnQuX3BhdGggPSB0aGlzO1xuICAgICAgICBzZWdtZW50Ll9pbmRleCA9IGluZGV4ICsgaTtcbiAgICAgICAgaWYgKHNlZ21lbnQuX3NlbGVjdGlvbikgdGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIDAsIHNlZ21lbnQuX3NlbGVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcHBlbmQpIHtcbiAgICAgICAgQmFzZS5wdXNoKHNlZ21lbnRzLCBzZWdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZ21lbnRzLnNwbGljZS5hcHBseShzZWdtZW50cywgW2luZGV4LCAwXS5jb25jYXQoc2VncykpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykgc2VnbWVudHNbaV0uX2luZGV4ID0gaTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnZlcykge1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLl9jb3VudEN1cnZlcygpLFxuICAgICAgICAgICAgc3RhcnQgPSBpbmRleCA+IDAgJiYgaW5kZXggKyBhbW91bnQgLSAxID09PSB0b3RhbCA/IGluZGV4IC0gMSA6IGluZGV4LFxuICAgICAgICAgICAgaW5zZXJ0ID0gc3RhcnQsXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihzdGFydCArIGFtb3VudCwgdG90YWwpO1xuXG4gICAgICAgIGlmIChzZWdzLl9jdXJ2ZXMpIHtcbiAgICAgICAgICBjdXJ2ZXMuc3BsaWNlLmFwcGx5KGN1cnZlcywgW3N0YXJ0LCAwXS5jb25jYXQoc2Vncy5fY3VydmVzKSk7XG4gICAgICAgICAgaW5zZXJ0ICs9IHNlZ3MuX2N1cnZlcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gaW5zZXJ0OyBpIDwgZW5kOyBpKyspIGN1cnZlcy5zcGxpY2UoaSwgMCwgbmV3IEN1cnZlKHRoaXMsIG51bGwsIG51bGwpKTtcblxuICAgICAgICB0aGlzLl9hZGp1c3RDdXJ2ZXMoc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoNDEpO1xuXG4gICAgICByZXR1cm4gc2VncztcbiAgICB9LFxuICAgIF9hZGp1c3RDdXJ2ZXM6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG4gICAgICAgICAgY3VydmU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGN1cnZlID0gY3VydmVzW2ldO1xuICAgICAgICBjdXJ2ZS5fcGF0aCA9IHRoaXM7XG4gICAgICAgIGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW2ldO1xuICAgICAgICBjdXJ2ZS5fc2VnbWVudDIgPSBzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF07XG5cbiAgICAgICAgY3VydmUuX2NoYW5nZWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnZlID0gY3VydmVzW3RoaXMuX2Nsb3NlZCAmJiAhc3RhcnQgPyBzZWdtZW50cy5sZW5ndGggLSAxIDogc3RhcnQgLSAxXSkge1xuICAgICAgICBjdXJ2ZS5fc2VnbWVudDIgPSBzZWdtZW50c1tzdGFydF0gfHwgc2VnbWVudHNbMF07XG5cbiAgICAgICAgY3VydmUuX2NoYW5nZWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnZlID0gY3VydmVzW2VuZF0pIHtcbiAgICAgICAgY3VydmUuX3NlZ21lbnQxID0gc2VnbWVudHNbZW5kXTtcblxuICAgICAgICBjdXJ2ZS5fY2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NvdW50Q3VydmVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuICAgICAgcmV0dXJuICF0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCA/IGxlbmd0aCAtIDEgOiBsZW5ndGg7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIChzZWdtZW50MSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPiAxICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcicgPyB0aGlzLl9hZGQoU2VnbWVudC5yZWFkTGlzdChhcmdzKSkgOiB0aGlzLl9hZGQoW1NlZ21lbnQucmVhZChhcmdzKV0pWzBdO1xuICAgIH0sXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaW5kZXgsIHNlZ21lbnQxKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA+IDIgJiYgdHlwZW9mIHNlZ21lbnQxICE9PSAnbnVtYmVyJyA/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KGFyZ3MsIDEpLCBpbmRleCkgOiB0aGlzLl9hZGQoW1NlZ21lbnQucmVhZChhcmdzLCAxKV0sIGluZGV4KVswXTtcbiAgICB9LFxuICAgIGFkZFNlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoW1NlZ21lbnQucmVhZChhcmd1bWVudHMpXSlbMF07XG4gICAgfSxcbiAgICBpbnNlcnRTZWdtZW50OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoW1NlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpXSwgaW5kZXgpWzBdO1xuICAgIH0sXG4gICAgYWRkU2VnbWVudHM6IGZ1bmN0aW9uIChzZWdtZW50cykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KHNlZ21lbnRzKSk7XG4gICAgfSxcbiAgICBpbnNlcnRTZWdtZW50czogZnVuY3Rpb24gKGluZGV4LCBzZWdtZW50cykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KHNlZ21lbnRzKSwgaW5kZXgpO1xuICAgIH0sXG4gICAgcmVtb3ZlU2VnbWVudDogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgaW5kZXggKyAxKVswXSB8fCBudWxsO1xuICAgIH0sXG4gICAgcmVtb3ZlU2VnbWVudHM6IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBfaW5jbHVkZUN1cnZlcykge1xuICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgZW5kID0gQmFzZS5waWNrKGVuZCwgdGhpcy5fc2VnbWVudHMubGVuZ3RoKTtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgIGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcbiAgICAgICAgICBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICByZW1vdmVkID0gc2VnbWVudHMuc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCksXG4gICAgICAgICAgYW1vdW50ID0gcmVtb3ZlZC5sZW5ndGg7XG4gICAgICBpZiAoIWFtb3VudCkgcmV0dXJuIHJlbW92ZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSByZW1vdmVkW2ldO1xuICAgICAgICBpZiAoc2VnbWVudC5fc2VsZWN0aW9uKSB0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgc2VnbWVudC5fc2VsZWN0aW9uLCAwKTtcbiAgICAgICAgc2VnbWVudC5faW5kZXggPSBzZWdtZW50Ll9wYXRoID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSBzZWdtZW50c1tpXS5faW5kZXggPSBpO1xuXG4gICAgICBpZiAoY3VydmVzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHN0YXJ0ID4gMCAmJiBlbmQgPT09IGNvdW50ICsgKHRoaXMuX2Nsb3NlZCA/IDEgOiAwKSA/IHN0YXJ0IC0gMSA6IHN0YXJ0LFxuICAgICAgICAgICAgY3VydmVzID0gY3VydmVzLnNwbGljZShpbmRleCwgYW1vdW50KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjdXJ2ZXNbaV0uX3BhdGggPSBudWxsO1xuXG4gICAgICAgIGlmIChfaW5jbHVkZUN1cnZlcykgcmVtb3ZlZC5fY3VydmVzID0gY3VydmVzLnNsaWNlKDEpO1xuXG4gICAgICAgIHRoaXMuX2FkanVzdEN1cnZlcyhpbmRleCwgaW5kZXgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGFuZ2VkKDQxKTtcblxuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcbiAgICBjbGVhcjogJyNyZW1vdmVTZWdtZW50cycsXG4gICAgaGFzSGFuZGxlczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWdtZW50c1tpXS5oYXNIYW5kbGVzKCkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBjbGVhckhhbmRsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykgc2VnbWVudHNbaV0uY2xlYXJIYW5kbGVzKCk7XG4gICAgfSxcbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuICAgICAgICB2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSBsZW5ndGggKz0gY3VydmVzW2ldLmdldExlbmd0aCgpO1xuXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9LFxuICAgIGdldEFyZWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmVhID0gdGhpcy5fYXJlYTtcblxuICAgICAgaWYgKGFyZWEgPT0gbnVsbCkge1xuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICAgIGNsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcbiAgICAgICAgYXJlYSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IGkgKyAxID09PSBsO1xuICAgICAgICAgIGFyZWEgKz0gQ3VydmUuZ2V0QXJlYShDdXJ2ZS5nZXRWYWx1ZXMoc2VnbWVudHNbaV0sIHNlZ21lbnRzW2xhc3QgPyAwIDogaSArIDFdLCBudWxsLCBsYXN0ICYmICFjbG9zZWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FyZWEgPSBhcmVhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9LFxuICAgIGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcbiAgICAgIHJldHVybiB0aGlzLmlzU2VsZWN0ZWQoKSAmJiBsZW5ndGggPiAwICYmIHRoaXMuX3NlZ21lbnRTZWxlY3Rpb24gPT09IGxlbmd0aCAqIDc7XG4gICAgfSxcbiAgICBzZXRGdWxseVNlbGVjdGVkOiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIGlmIChzZWxlY3RlZCkgdGhpcy5fc2VsZWN0U2VnbWVudHModHJ1ZSk7XG4gICAgICB0aGlzLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgaWYgKCEoc2VsZWN0aW9uICYgMSkpIHRoaXMuX3NlbGVjdFNlZ21lbnRzKGZhbHNlKTtcbiAgICAgIHNldFNlbGVjdGlvbi5iYXNlLmNhbGwodGhpcywgc2VsZWN0aW9uKTtcbiAgICB9LFxuICAgIF9zZWxlY3RTZWdtZW50czogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0ZWQgPyA3IDogMDtcbiAgICAgIHRoaXMuX3NlZ21lbnRTZWxlY3Rpb24gPSBzZWxlY3Rpb24gKiBsZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHNlZ21lbnRzW2ldLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgfSxcbiAgICBfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbiAoc2VnbWVudCwgb2xkU2VsZWN0aW9uLCBuZXdTZWxlY3Rpb24pIHtcbiAgICAgIHNlZ21lbnQuX3NlbGVjdGlvbiA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLl9zZWdtZW50U2VsZWN0aW9uICs9IG5ld1NlbGVjdGlvbiAtIG9sZFNlbGVjdGlvbjtcbiAgICAgIGlmIChzZWxlY3Rpb24gPiAwKSB0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuICAgIH0sXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChsb2NhdGlvbiksXG4gICAgICAgICAgY3VydmU7XG4gICAgICByZXR1cm4gbG9jICYmIChjdXJ2ZSA9IGxvYy5nZXRDdXJ2ZSgpLmRpdmlkZUF0KGxvYy5nZXRDdXJ2ZU9mZnNldCgpKSkgPyBjdXJ2ZS5fc2VnbWVudDEgOiBudWxsO1xuICAgIH0sXG4gICAgc3BsaXRBdDogZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KGxvY2F0aW9uKSxcbiAgICAgICAgICBpbmRleCA9IGxvYyAmJiBsb2MuaW5kZXgsXG4gICAgICAgICAgdGltZSA9IGxvYyAmJiBsb2MudGltZSxcbiAgICAgICAgICB0TWluID0gMWUtOCxcbiAgICAgICAgICB0TWF4ID0gMSAtIHRNaW47XG5cbiAgICAgIGlmICh0aW1lID4gdE1heCkge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICB0aW1lID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgY3VydmVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodGltZSA+PSB0TWluKSB7XG4gICAgICAgICAgY3VydmVzW2luZGV4KytdLmRpdmlkZUF0VGltZSh0aW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgdGhpcy5fc2VnbWVudHMubGVuZ3RoLCB0cnVlKSxcbiAgICAgICAgICAgIHBhdGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgIHRoaXMuc2V0Q2xvc2VkKGZhbHNlKTtcbiAgICAgICAgICBwYXRoID0gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuICAgICAgICAgIHBhdGguaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICAgICAgcGF0aC5jb3B5QXR0cmlidXRlcyh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGguX2FkZChzZWdzLCAwKTtcblxuICAgICAgICB0aGlzLmFkZFNlZ21lbnQoc2Vnc1swXSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNwbGl0OiBmdW5jdGlvbiAoaW5kZXgsIHRpbWUpIHtcbiAgICAgIHZhciBjdXJ2ZSxcbiAgICAgICAgICBsb2NhdGlvbiA9IHRpbWUgPT09IHVuZGVmaW5lZCA/IGluZGV4IDogKGN1cnZlID0gdGhpcy5nZXRDdXJ2ZXMoKVtpbmRleF0pICYmIGN1cnZlLmdldExvY2F0aW9uQXRUaW1lKHRpbWUpO1xuICAgICAgcmV0dXJuIGxvY2F0aW9uICE9IG51bGwgPyB0aGlzLnNwbGl0QXQobG9jYXRpb24pIDogbnVsbDtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIChwYXRoLCB0b2xlcmFuY2UpIHtcbiAgICAgIHZhciBlcHNpbG9uID0gdG9sZXJhbmNlIHx8IDA7XG5cbiAgICAgIGlmIChwYXRoICYmIHBhdGggIT09IHRoaXMpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG4gICAgICAgICAgICBsYXN0MSA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKSxcbiAgICAgICAgICAgIGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuICAgICAgICBpZiAoIWxhc3QyKSByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKGxhc3QxICYmIGxhc3QxLl9wb2ludC5pc0Nsb3NlKGxhc3QyLl9wb2ludCwgZXBzaWxvbikpIHBhdGgucmV2ZXJzZSgpO1xuICAgICAgICB2YXIgZmlyc3QyID0gcGF0aC5nZXRGaXJzdFNlZ21lbnQoKTtcblxuICAgICAgICBpZiAobGFzdDEgJiYgbGFzdDEuX3BvaW50LmlzQ2xvc2UoZmlyc3QyLl9wb2ludCwgZXBzaWxvbikpIHtcbiAgICAgICAgICBsYXN0MS5zZXRIYW5kbGVPdXQoZmlyc3QyLl9oYW5kbGVPdXQpO1xuXG4gICAgICAgICAgdGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmlyc3QxID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKTtcbiAgICAgICAgICBpZiAoZmlyc3QxICYmIGZpcnN0MS5fcG9pbnQuaXNDbG9zZShmaXJzdDIuX3BvaW50LCBlcHNpbG9uKSkgcGF0aC5yZXZlcnNlKCk7XG4gICAgICAgICAgbGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG5cbiAgICAgICAgICBpZiAoZmlyc3QxICYmIGZpcnN0MS5fcG9pbnQuaXNDbG9zZShsYXN0Mi5fcG9pbnQsIGVwc2lsb24pKSB7XG4gICAgICAgICAgICBmaXJzdDEuc2V0SGFuZGxlSW4obGFzdDIuX2hhbmRsZUluKTtcblxuICAgICAgICAgICAgdGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpLCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoLl9jbG9zZWQpIHRoaXMuX2FkZChbc2VnbWVudHNbMF1dKTtcbiAgICAgICAgcGF0aC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKSxcbiAgICAgICAgICBsYXN0ID0gdGhpcy5nZXRMYXN0U2VnbWVudCgpO1xuXG4gICAgICBpZiAoZmlyc3QgIT09IGxhc3QgJiYgZmlyc3QuX3BvaW50LmlzQ2xvc2UobGFzdC5fcG9pbnQsIGVwc2lsb24pKSB7XG4gICAgICAgIGZpcnN0LnNldEhhbmRsZUluKGxhc3QuX2hhbmRsZUluKTtcbiAgICAgICAgbGFzdC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG4gICAgICAgICAgc2ltcGxpZnkgPSBvcHRpb25zICYmIG9wdGlvbnMuc2ltcGxpZnksXG4gICAgICAgICAgdG9sZXJhbmNlID0gc2ltcGxpZnkgPyAxZS03IDogMDtcblxuICAgICAgZm9yICh2YXIgaSA9IGN1cnZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY3VydmUgPSBjdXJ2ZXNbaV07XG4gICAgICAgIGlmICghY3VydmUuaGFzSGFuZGxlcygpICYmICghY3VydmUuaGFzTGVuZ3RoKHRvbGVyYW5jZSkgfHwgc2ltcGxpZnkgJiYgY3VydmUuaXNDb2xsaW5lYXIoY3VydmUuZ2V0TmV4dCgpKSkpIGN1cnZlLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3NlZ21lbnRzLnJldmVyc2UoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1tpXTtcbiAgICAgICAgdmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW47XG4gICAgICAgIHNlZ21lbnQuX2hhbmRsZUluID0gc2VnbWVudC5faGFuZGxlT3V0O1xuICAgICAgICBzZWdtZW50Ll9oYW5kbGVPdXQgPSBoYW5kbGVJbjtcbiAgICAgICAgc2VnbWVudC5faW5kZXggPSBpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jdXJ2ZXMgPSBudWxsO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKDkpO1xuICAgIH0sXG4gICAgZmxhdHRlbjogZnVuY3Rpb24gKGZsYXRuZXNzKSB7XG4gICAgICB2YXIgZmxhdHRlbmVyID0gbmV3IFBhdGhGbGF0dGVuZXIodGhpcywgZmxhdG5lc3MgfHwgMC4yNSwgMjU2LCB0cnVlKSxcbiAgICAgICAgICBwYXJ0cyA9IGZsYXR0ZW5lci5wYXJ0cyxcbiAgICAgICAgICBsZW5ndGggPSBwYXJ0cy5sZW5ndGgsXG4gICAgICAgICAgc2VnbWVudHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHBhcnRzW2ldLmN1cnZlLnNsaWNlKDAsIDIpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChuZXcgU2VnbWVudChwYXJ0c1tsZW5ndGggLSAxXS5jdXJ2ZS5zbGljZSg2KSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcbiAgICB9LFxuICAgIHNpbXBsaWZ5OiBmdW5jdGlvbiAodG9sZXJhbmNlKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSBuZXcgUGF0aEZpdHRlcih0aGlzKS5maXQodG9sZXJhbmNlIHx8IDIuNSk7XG4gICAgICBpZiAoc2VnbWVudHMpIHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuICAgICAgcmV0dXJuICEhc2VnbWVudHM7XG4gICAgfSxcbiAgICBzbW9vdGg6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgb3B0cyA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgICAgdHlwZSA9IG9wdHMudHlwZSB8fCAnYXN5bW1ldHJpYycsXG4gICAgICAgICAgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgY2xvc2VkID0gdGhpcy5fY2xvc2VkO1xuXG4gICAgICBmdW5jdGlvbiBnZXRJbmRleCh2YWx1ZSwgX2RlZmF1bHQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdmFsdWUgJiYgdmFsdWUuaW5kZXg7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IHZhbHVlLnBhdGg7XG4gICAgICAgICAgaWYgKHBhdGggJiYgcGF0aCAhPT0gdGhhdCkgdGhyb3cgbmV3IEVycm9yKHZhbHVlLl9jbGFzcyArICcgJyArIGluZGV4ICsgJyBvZiAnICsgcGF0aCArICcgaXMgbm90IHBhcnQgb2YgJyArIHRoYXQpO1xuICAgICAgICAgIGlmIChfZGVmYXVsdCAmJiB2YWx1ZSBpbnN0YW5jZW9mIEN1cnZlKSBpbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogX2RlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5taW4oaW5kZXggPCAwICYmIGNsb3NlZCA/IGluZGV4ICUgbGVuZ3RoIDogaW5kZXggPCAwID8gaW5kZXggKyBsZW5ndGggOiBpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb29wID0gY2xvc2VkICYmIG9wdHMuZnJvbSA9PT0gdW5kZWZpbmVkICYmIG9wdHMudG8gPT09IHVuZGVmaW5lZCxcbiAgICAgICAgICBmcm9tID0gZ2V0SW5kZXgob3B0cy5mcm9tLCAwKSxcbiAgICAgICAgICB0byA9IGdldEluZGV4KG9wdHMudG8sIGxlbmd0aCAtIDEpO1xuXG4gICAgICBpZiAoZnJvbSA+IHRvKSB7XG4gICAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICBmcm9tIC09IGxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdG1wID0gZnJvbTtcbiAgICAgICAgICBmcm9tID0gdG87XG4gICAgICAgICAgdG8gPSB0bXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKC9eKD86YXN5bW1ldHJpY3xjb250aW51b3VzKSQvLnRlc3QodHlwZSkpIHtcbiAgICAgICAgdmFyIGFzeW1tZXRyaWMgPSB0eXBlID09PSAnYXN5bW1ldHJpYycsXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgICAgIGFtb3VudCA9IHRvIC0gZnJvbSArIDEsXG4gICAgICAgICAgICBuID0gYW1vdW50IC0gMSxcbiAgICAgICAgICAgIHBhZGRpbmcgPSBsb29wID8gbWluKGFtb3VudCwgNCkgOiAxLFxuICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSBwYWRkaW5nLFxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gcGFkZGluZyxcbiAgICAgICAgICAgIGtub3RzID0gW107XG5cbiAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IG1pbigxLCBmcm9tKTtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBtaW4oMSwgbGVuZ3RoIC0gdG8gLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG4gKz0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQ7XG4gICAgICAgIGlmIChuIDw9IDEpIHJldHVybjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGZyb20gLSBwYWRkaW5nTGVmdDsgaSA8PSBuOyBpKyssIGorKykge1xuICAgICAgICAgIGtub3RzW2ldID0gc2VnbWVudHNbKGogPCAwID8gaiArIGxlbmd0aCA6IGopICUgbGVuZ3RoXS5fcG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IGtub3RzWzBdLl94ICsgMiAqIGtub3RzWzFdLl94LFxuICAgICAgICAgICAgeSA9IGtub3RzWzBdLl95ICsgMiAqIGtub3RzWzFdLl95LFxuICAgICAgICAgICAgZiA9IDIsXG4gICAgICAgICAgICBuXzEgPSBuIC0gMSxcbiAgICAgICAgICAgIHJ4ID0gW3hdLFxuICAgICAgICAgICAgcnkgPSBbeV0sXG4gICAgICAgICAgICByZiA9IFtmXSxcbiAgICAgICAgICAgIHB4ID0gW10sXG4gICAgICAgICAgICBweSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGludGVybmFsID0gaSA8IG5fMSxcbiAgICAgICAgICAgICAgYSA9IGludGVybmFsID8gMSA6IGFzeW1tZXRyaWMgPyAxIDogMixcbiAgICAgICAgICAgICAgYiA9IGludGVybmFsID8gNCA6IGFzeW1tZXRyaWMgPyAyIDogNyxcbiAgICAgICAgICAgICAgdSA9IGludGVybmFsID8gNCA6IGFzeW1tZXRyaWMgPyAzIDogOCxcbiAgICAgICAgICAgICAgdiA9IGludGVybmFsID8gMiA6IGFzeW1tZXRyaWMgPyAwIDogMSxcbiAgICAgICAgICAgICAgbSA9IGEgLyBmO1xuICAgICAgICAgIGYgPSByZltpXSA9IGIgLSBtO1xuICAgICAgICAgIHggPSByeFtpXSA9IHUgKiBrbm90c1tpXS5feCArIHYgKiBrbm90c1tpICsgMV0uX3ggLSBtICogeDtcbiAgICAgICAgICB5ID0gcnlbaV0gPSB1ICoga25vdHNbaV0uX3kgKyB2ICoga25vdHNbaSArIDFdLl95IC0gbSAqIHk7XG4gICAgICAgIH1cblxuICAgICAgICBweFtuXzFdID0gcnhbbl8xXSAvIHJmW25fMV07XG4gICAgICAgIHB5W25fMV0gPSByeVtuXzFdIC8gcmZbbl8xXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gbiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgcHhbaV0gPSAocnhbaV0gLSBweFtpICsgMV0pIC8gcmZbaV07XG4gICAgICAgICAgcHlbaV0gPSAocnlbaV0gLSBweVtpICsgMV0pIC8gcmZbaV07XG4gICAgICAgIH1cblxuICAgICAgICBweFtuXSA9ICgzICoga25vdHNbbl0uX3ggLSBweFtuXzFdKSAvIDI7XG4gICAgICAgIHB5W25dID0gKDMgKiBrbm90c1tuXS5feSAtIHB5W25fMV0pIC8gMjtcblxuICAgICAgICBmb3IgKHZhciBpID0gcGFkZGluZ0xlZnQsIG1heCA9IG4gLSBwYWRkaW5nUmlnaHQsIGogPSBmcm9tOyBpIDw9IG1heDsgaSsrLCBqKyspIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ogPCAwID8gaiArIGxlbmd0aCA6IGpdLFxuICAgICAgICAgICAgICBwdCA9IHNlZ21lbnQuX3BvaW50LFxuICAgICAgICAgICAgICBoeCA9IHB4W2ldIC0gcHQuX3gsXG4gICAgICAgICAgICAgIGh5ID0gcHlbaV0gLSBwdC5feTtcbiAgICAgICAgICBpZiAobG9vcCB8fCBpIDwgbWF4KSBzZWdtZW50LnNldEhhbmRsZU91dChoeCwgaHkpO1xuICAgICAgICAgIGlmIChsb29wIHx8IGkgPiBwYWRkaW5nTGVmdCkgc2VnbWVudC5zZXRIYW5kbGVJbigtaHgsIC1oeSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDw9IHRvOyBpKyspIHtcbiAgICAgICAgICBzZWdtZW50c1tpIDwgMCA/IGkgKyBsZW5ndGggOiBpXS5zbW9vdGgob3B0cywgIWxvb3AgJiYgaSA9PT0gZnJvbSwgIWxvb3AgJiYgaSA9PT0gdG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB0b1NoYXBlOiBmdW5jdGlvbiAoaW5zZXJ0KSB7XG4gICAgICBpZiAoIXRoaXMuX2Nsb3NlZCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgcmFkaXVzLFxuICAgICAgICAgIHRvcENlbnRlcjtcblxuICAgICAgZnVuY3Rpb24gaXNDb2xsaW5lYXIoaSwgaikge1xuICAgICAgICB2YXIgc2VnMSA9IHNlZ21lbnRzW2ldLFxuICAgICAgICAgICAgc2VnMiA9IHNlZzEuZ2V0TmV4dCgpLFxuICAgICAgICAgICAgc2VnMyA9IHNlZ21lbnRzW2pdLFxuICAgICAgICAgICAgc2VnNCA9IHNlZzMuZ2V0TmV4dCgpO1xuICAgICAgICByZXR1cm4gc2VnMS5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzIuX2hhbmRsZUluLmlzWmVybygpICYmIHNlZzMuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWc0Ll9oYW5kbGVJbi5pc1plcm8oKSAmJiBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCkuaXNDb2xsaW5lYXIoc2VnNC5fcG9pbnQuc3VidHJhY3Qoc2VnMy5fcG9pbnQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNPcnRob2dvbmFsKGkpIHtcbiAgICAgICAgdmFyIHNlZzIgPSBzZWdtZW50c1tpXSxcbiAgICAgICAgICAgIHNlZzEgPSBzZWcyLmdldFByZXZpb3VzKCksXG4gICAgICAgICAgICBzZWczID0gc2VnMi5nZXROZXh0KCk7XG4gICAgICAgIHJldHVybiBzZWcxLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMi5faGFuZGxlSW4uaXNaZXJvKCkgJiYgc2VnMi5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzMuX2hhbmRsZUluLmlzWmVybygpICYmIHNlZzIuX3BvaW50LnN1YnRyYWN0KHNlZzEuX3BvaW50KS5pc09ydGhvZ29uYWwoc2VnMy5fcG9pbnQuc3VidHJhY3Qoc2VnMi5fcG9pbnQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNBcmMoaSkge1xuICAgICAgICB2YXIgc2VnMSA9IHNlZ21lbnRzW2ldLFxuICAgICAgICAgICAgc2VnMiA9IHNlZzEuZ2V0TmV4dCgpLFxuICAgICAgICAgICAgaGFuZGxlMSA9IHNlZzEuX2hhbmRsZU91dCxcbiAgICAgICAgICAgIGhhbmRsZTIgPSBzZWcyLl9oYW5kbGVJbixcbiAgICAgICAgICAgIGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2O1xuXG4gICAgICAgIGlmIChoYW5kbGUxLmlzT3J0aG9nb25hbChoYW5kbGUyKSkge1xuICAgICAgICAgIHZhciBwdDEgPSBzZWcxLl9wb2ludCxcbiAgICAgICAgICAgICAgcHQyID0gc2VnMi5fcG9pbnQsXG4gICAgICAgICAgICAgIGNvcm5lciA9IG5ldyBMaW5lKHB0MSwgaGFuZGxlMSwgdHJ1ZSkuaW50ZXJzZWN0KG5ldyBMaW5lKHB0MiwgaGFuZGxlMiwgdHJ1ZSksIHRydWUpO1xuICAgICAgICAgIHJldHVybiBjb3JuZXIgJiYgTnVtZXJpY2FsLmlzWmVybyhoYW5kbGUxLmdldExlbmd0aCgpIC8gY29ybmVyLnN1YnRyYWN0KHB0MSkuZ2V0TGVuZ3RoKCkgLSBrYXBwYSkgJiYgTnVtZXJpY2FsLmlzWmVybyhoYW5kbGUyLmdldExlbmd0aCgpIC8gY29ybmVyLnN1YnRyYWN0KHB0MikuZ2V0TGVuZ3RoKCkgLSBrYXBwYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldERpc3RhbmNlKGksIGopIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzW2ldLl9wb2ludC5nZXREaXN0YW5jZShzZWdtZW50c1tqXS5fcG9pbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGFzSGFuZGxlcygpICYmIHNlZ21lbnRzLmxlbmd0aCA9PT0gNCAmJiBpc0NvbGxpbmVhcigwLCAyKSAmJiBpc0NvbGxpbmVhcigxLCAzKSAmJiBpc09ydGhvZ29uYWwoMSkpIHtcbiAgICAgICAgdHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcbiAgICAgICAgc2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDMpLCBnZXREaXN0YW5jZSgwLCAxKSk7XG4gICAgICAgIHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludC5hZGQoc2VnbWVudHNbMl0uX3BvaW50KS5kaXZpZGUoMik7XG4gICAgICB9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gOCAmJiBpc0FyYygwKSAmJiBpc0FyYygyKSAmJiBpc0FyYyg0KSAmJiBpc0FyYyg2KSAmJiBpc0NvbGxpbmVhcigxLCA1KSAmJiBpc0NvbGxpbmVhcigzLCA3KSkge1xuICAgICAgICB0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuICAgICAgICBzaXplID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMSwgNiksIGdldERpc3RhbmNlKDAsIDMpKTtcbiAgICAgICAgcmFkaXVzID0gc2l6ZS5zdWJ0cmFjdChuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCA3KSwgZ2V0RGlzdGFuY2UoMSwgMikpKS5kaXZpZGUoMik7XG4gICAgICAgIHRvcENlbnRlciA9IHNlZ21lbnRzWzNdLl9wb2ludC5hZGQoc2VnbWVudHNbNF0uX3BvaW50KS5kaXZpZGUoMik7XG4gICAgICB9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gNCAmJiBpc0FyYygwKSAmJiBpc0FyYygxKSAmJiBpc0FyYygyKSAmJiBpc0FyYygzKSkge1xuICAgICAgICBpZiAoTnVtZXJpY2FsLmlzWmVybyhnZXREaXN0YW5jZSgwLCAyKSAtIGdldERpc3RhbmNlKDEsIDMpKSkge1xuICAgICAgICAgIHR5cGUgPSBTaGFwZS5DaXJjbGU7XG4gICAgICAgICAgcmFkaXVzID0gZ2V0RGlzdGFuY2UoMCwgMikgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSBTaGFwZS5FbGxpcHNlO1xuICAgICAgICAgIHJhZGl1cyA9IG5ldyBTaXplKGdldERpc3RhbmNlKDIsIDApIC8gMiwgZ2V0RGlzdGFuY2UoMywgMSkgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksXG4gICAgICAgICAgICBzaGFwZSA9IG5ldyB0eXBlKHtcbiAgICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgIGluc2VydDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHNoYXBlLmNvcHlBdHRyaWJ1dGVzKHRoaXMsIHRydWUpO1xuXG4gICAgICAgIHNoYXBlLl9tYXRyaXgucHJlcGVuZCh0aGlzLl9tYXRyaXgpO1xuXG4gICAgICAgIHNoYXBlLnJvdGF0ZSh0b3BDZW50ZXIuc3VidHJhY3QoY2VudGVyKS5nZXRBbmdsZSgpICsgOTApO1xuICAgICAgICBpZiAoaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgaW5zZXJ0KSBzaGFwZS5pbnNlcnRBYm92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHRvUGF0aDogJyNjbG9uZScsXG4gICAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShwYXRoKSB7XG4gICAgICBpZiAoIXBhdGggfHwgcGF0aCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkgcmV0dXJuIGNvbXBhcmUuYmFzZS5jYWxsKHRoaXMsIHBhdGgpO1xuICAgICAgdmFyIGN1cnZlczEgPSB0aGlzLmdldEN1cnZlcygpLFxuICAgICAgICAgIGN1cnZlczIgPSBwYXRoLmdldEN1cnZlcygpLFxuICAgICAgICAgIGxlbmd0aDEgPSBjdXJ2ZXMxLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGgyID0gY3VydmVzMi5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoMSB8fCAhbGVuZ3RoMikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoMSA9PSBsZW5ndGgyO1xuICAgICAgfVxuXG4gICAgICB2YXIgdjEgPSBjdXJ2ZXMxWzBdLmdldFZhbHVlcygpLFxuICAgICAgICAgIHZhbHVlczIgPSBbXSxcbiAgICAgICAgICBwb3MxID0gMCxcbiAgICAgICAgICBwb3MyLFxuICAgICAgICAgIGVuZDEgPSAwLFxuICAgICAgICAgIGVuZDI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIHZhciB2MiA9IGN1cnZlczJbaV0uZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhbHVlczIucHVzaCh2Mik7XG4gICAgICAgIHZhciBvdmVybGFwcyA9IEN1cnZlLmdldE92ZXJsYXBzKHYxLCB2Mik7XG5cbiAgICAgICAgaWYgKG92ZXJsYXBzKSB7XG4gICAgICAgICAgcG9zMiA9ICFpICYmIG92ZXJsYXBzWzBdWzBdID4gMCA/IGxlbmd0aDIgLSAxIDogaTtcbiAgICAgICAgICBlbmQyID0gb3ZlcmxhcHNbMF1bMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgIGVwc2lsb24gPSAxZS04LFxuICAgICAgICAgIHYyID0gdmFsdWVzMltwb3MyXSxcbiAgICAgICAgICBzdGFydDI7XG5cbiAgICAgIHdoaWxlICh2MSAmJiB2Mikge1xuICAgICAgICB2YXIgb3ZlcmxhcHMgPSBDdXJ2ZS5nZXRPdmVybGFwcyh2MSwgdjIpO1xuXG4gICAgICAgIGlmIChvdmVybGFwcykge1xuICAgICAgICAgIHZhciB0MSA9IG92ZXJsYXBzWzBdWzBdO1xuXG4gICAgICAgICAgaWYgKGFicyh0MSAtIGVuZDEpIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgZW5kMSA9IG92ZXJsYXBzWzFdWzBdO1xuXG4gICAgICAgICAgICBpZiAoZW5kMSA9PT0gMSkge1xuICAgICAgICAgICAgICB2MSA9ICsrcG9zMSA8IGxlbmd0aDEgPyBjdXJ2ZXMxW3BvczFdLmdldFZhbHVlcygpIDogbnVsbDtcbiAgICAgICAgICAgICAgZW5kMSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0MiA9IG92ZXJsYXBzWzBdWzFdO1xuXG4gICAgICAgICAgICBpZiAoYWJzKHQyIC0gZW5kMikgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgIGlmICghc3RhcnQyKSBzdGFydDIgPSBbcG9zMiwgdDJdO1xuICAgICAgICAgICAgICBlbmQyID0gb3ZlcmxhcHNbMV1bMV07XG5cbiAgICAgICAgICAgICAgaWYgKGVuZDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytwb3MyID49IGxlbmd0aDIpIHBvczIgPSAwO1xuICAgICAgICAgICAgICAgIHYyID0gdmFsdWVzMltwb3MyXSB8fCBjdXJ2ZXMyW3BvczJdLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgICAgIGVuZDIgPSAwO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCF2MSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydDJbMF0gPT09IHBvczIgJiYgc3RhcnQyWzFdID09PSBlbmQyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIF9oaXRUZXN0U2VsZjogZnVuY3Rpb24gKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcbiAgICAgICAgICBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoLFxuICAgICAgICAgIGNsb3NlZCA9IHRoaXMuX2Nsb3NlZCxcbiAgICAgICAgICB0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyxcbiAgICAgICAgICBzdHJva2VQYWRkaW5nID0gdG9sZXJhbmNlUGFkZGluZyxcbiAgICAgICAgICBqb2luLFxuICAgICAgICAgIGNhcCxcbiAgICAgICAgICBtaXRlckxpbWl0LFxuICAgICAgICAgIGFyZWEsXG4gICAgICAgICAgbG9jLFxuICAgICAgICAgIHJlcyxcbiAgICAgICAgICBoaXRTdHJva2UgPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSxcbiAgICAgICAgICBoaXRGaWxsID0gb3B0aW9ucy5maWxsICYmIHN0eWxlLmhhc0ZpbGwoKSxcbiAgICAgICAgICBoaXRDdXJ2ZXMgPSBvcHRpb25zLmN1cnZlcyxcbiAgICAgICAgICBzdHJva2VSYWRpdXMgPSBoaXRTdHJva2UgPyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMiA6IGhpdEZpbGwgJiYgb3B0aW9ucy50b2xlcmFuY2UgPiAwIHx8IGhpdEN1cnZlcyA/IDAgOiBudWxsO1xuXG4gICAgICBpZiAoc3Ryb2tlUmFkaXVzICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdHJva2VSYWRpdXMgPiAwKSB7XG4gICAgICAgICAgam9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKTtcbiAgICAgICAgICBjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKTtcbiAgICAgICAgICBtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgICAgIHN0cm9rZVBhZGRpbmcgPSBzdHJva2VQYWRkaW5nLmFkZChQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVJhZGl1cywgc3Ryb2tlTWF0cml4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgam9pbiA9IGNhcCA9ICdyb3VuZCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNDbG9zZUVub3VnaChwdCwgcGFkZGluZykge1xuICAgICAgICByZXR1cm4gcG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZShwYWRkaW5nKS5sZW5ndGggPD0gMTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBwdCwgbmFtZSkge1xuICAgICAgICBpZiAoIW9wdGlvbnMuc2VsZWN0ZWQgfHwgcHQuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgdmFyIGFuY2hvciA9IHNlZy5fcG9pbnQ7XG4gICAgICAgICAgaWYgKHB0ICE9PSBhbmNob3IpIHB0ID0gcHQuYWRkKGFuY2hvcik7XG5cbiAgICAgICAgICBpZiAoaXNDbG9zZUVub3VnaChwdCwgc3Ryb2tlUGFkZGluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGl0UmVzdWx0KG5hbWUsIHRoYXQsIHtcbiAgICAgICAgICAgICAgc2VnbWVudDogc2VnLFxuICAgICAgICAgICAgICBwb2ludDogcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludHMoc2VnLCBlbmRzKSB7XG4gICAgICAgIHJldHVybiAoZW5kcyB8fCBvcHRpb25zLnNlZ21lbnRzKSAmJiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5fcG9pbnQsICdzZWdtZW50JykgfHwgIWVuZHMgJiYgb3B0aW9ucy5oYW5kbGVzICYmIChjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlSW4sICdoYW5kbGUtaW4nKSB8fCBjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlT3V0LCAnaGFuZGxlLW91dCcpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkVG9BcmVhKHBvaW50KSB7XG4gICAgICAgIGFyZWEuYWRkKHBvaW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpIHtcbiAgICAgICAgdmFyIGlzSm9pbiA9IGNsb3NlZCB8fCBzZWdtZW50Ll9pbmRleCA+IDAgJiYgc2VnbWVudC5faW5kZXggPCBudW1TZWdtZW50cyAtIDE7XG5cbiAgICAgICAgaWYgKChpc0pvaW4gPyBqb2luIDogY2FwKSA9PT0gJ3JvdW5kJykge1xuICAgICAgICAgIHJldHVybiBpc0Nsb3NlRW5vdWdoKHNlZ21lbnQuX3BvaW50LCBzdHJva2VQYWRkaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmVhID0gbmV3IFBhdGgoe1xuICAgICAgICAgICAgaW50ZXJuYWw6IHRydWUsXG4gICAgICAgICAgICBjbG9zZWQ6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChpc0pvaW4pIHtcbiAgICAgICAgICAgIGlmICghc2VnbWVudC5pc1Ntb290aCgpKSB7XG4gICAgICAgICAgICAgIFBhdGguX2FkZEJldmVsSm9pbihzZWdtZW50LCBqb2luLCBzdHJva2VSYWRpdXMsIG1pdGVyTGltaXQsIG51bGwsIHN0cm9rZU1hdHJpeCwgYWRkVG9BcmVhLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGNhcCA9PT0gJ3NxdWFyZScpIHtcbiAgICAgICAgICAgIFBhdGguX2FkZFNxdWFyZUNhcChzZWdtZW50LCBjYXAsIHN0cm9rZVJhZGl1cywgbnVsbCwgc3Ryb2tlTWF0cml4LCBhZGRUb0FyZWEsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYXJlYS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBsb2M7XG4gICAgICAgICAgICByZXR1cm4gYXJlYS5jb250YWlucyhwb2ludCkgfHwgKGxvYyA9IGFyZWEuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KSkgJiYgaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgdG9sZXJhbmNlUGFkZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmVuZHMgJiYgIW9wdGlvbnMuc2VnbWVudHMgJiYgIWNsb3NlZCkge1xuICAgICAgICBpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzWzBdLCB0cnVlKSB8fCBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbbnVtU2VnbWVudHMgLSAxXSwgdHJ1ZSkpIHJldHVybiByZXM7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VnbWVudHMgfHwgb3B0aW9ucy5oYW5kbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykgaWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tpXSkpIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJva2VSYWRpdXMgIT09IG51bGwpIHtcbiAgICAgICAgbG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXG4gICAgICAgIGlmIChsb2MpIHtcbiAgICAgICAgICB2YXIgdGltZSA9IGxvYy5nZXRUaW1lKCk7XG5cbiAgICAgICAgICBpZiAodGltZSA9PT0gMCB8fCB0aW1lID09PSAxICYmIG51bVNlZ21lbnRzID4gMSkge1xuICAgICAgICAgICAgaWYgKCFjaGVja1NlZ21lbnRTdHJva2UobG9jLmdldFNlZ21lbnQoKSkpIGxvYyA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmICghaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgc3Ryb2tlUGFkZGluZykpIHtcbiAgICAgICAgICAgIGxvYyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsb2MgJiYgam9pbiA9PT0gJ21pdGVyJyAmJiBudW1TZWdtZW50cyA+IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cbiAgICAgICAgICAgIGlmIChwb2ludC5nZXREaXN0YW5jZShzZWdtZW50Ll9wb2ludCkgPD0gbWl0ZXJMaW1pdCAqIHN0cm9rZVJhZGl1cyAmJiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgbG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFsb2MgJiYgaGl0RmlsbCAmJiB0aGlzLl9jb250YWlucyhwb2ludCkgfHwgbG9jICYmICFoaXRTdHJva2UgJiYgIWhpdEN1cnZlcyA/IG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKSA6IGxvYyA/IG5ldyBIaXRSZXN1bHQoaGl0U3Ryb2tlID8gJ3N0cm9rZScgOiAnY3VydmUnLCB0aGlzLCB7XG4gICAgICAgIGxvY2F0aW9uOiBsb2MsXG4gICAgICAgIHBvaW50OiBsb2MuZ2V0UG9pbnQoKVxuICAgICAgfSkgOiBudWxsO1xuICAgIH1cbiAgfSwgQmFzZS5lYWNoKEN1cnZlLl9ldmFsdWF0ZU1ldGhvZHMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KG9mZnNldCk7XG4gICAgICByZXR1cm4gbG9jICYmIGxvY1tuYW1lXSgpO1xuICAgIH07XG4gIH0sIHtcbiAgICBiZWFuczogZmFsc2UsXG4gICAgZ2V0TG9jYXRpb25PZjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbG9jID0gY3VydmVzW2ldLmdldExvY2F0aW9uT2YocG9pbnQpO1xuICAgICAgICBpZiAobG9jKSByZXR1cm4gbG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldE9mZnNldE9mOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbG9jID8gbG9jLmdldE9mZnNldCgpIDogbnVsbDtcbiAgICB9LFxuICAgIGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICBjdXJ2ZSA9IGN1cnZlc1tpXTtcbiAgICAgICAgICBsZW5ndGggKz0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VydmUuZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBzdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnZlcy5sZW5ndGggPiAwICYmIG9mZnNldCA8PSB0aGlzLmdldExlbmd0aCgpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0sIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCAmJiBvZmZzZXQuZ2V0UGF0aCAmJiBvZmZzZXQuZ2V0UGF0aCgpID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0T2Zmc2V0c1dpdGhUYW5nZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGFuZ2VudCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHRhbmdlbnQuaXNaZXJvKCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgICAgdmFyIGN1cnZlU3RhcnQgPSAwO1xuICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY3VydmUgPSBjdXJ2ZXNbaV07XG4gICAgICAgIHZhciBjdXJ2ZVRpbWVzID0gY3VydmUuZ2V0VGltZXNXaXRoVGFuZ2VudCh0YW5nZW50KTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IGN1cnZlVGltZXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IGN1cnZlU3RhcnQgKyBjdXJ2ZS5nZXRPZmZzZXRBdFRpbWUoY3VydmVUaW1lc1tqXSk7XG5cbiAgICAgICAgICBpZiAob2Zmc2V0cy5pbmRleE9mKG9mZnNldCkgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJ2ZVN0YXJ0ICs9IGN1cnZlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldHM7XG4gICAgfVxuICB9KSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBkcmF3SGFuZGxlcyhjdHgsIHNlZ21lbnRzLCBtYXRyaXgsIHNpemUpIHtcbiAgICAgIGlmIChzaXplIDw9IDApIHJldHVybjtcbiAgICAgIHZhciBoYWxmID0gc2l6ZSAvIDIsXG4gICAgICAgICAgbWluaVNpemUgPSBzaXplIC0gMixcbiAgICAgICAgICBtaW5pSGFsZiA9IGhhbGYgLSAxLFxuICAgICAgICAgIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcbiAgICAgICAgICBwWCxcbiAgICAgICAgICBwWTtcblxuICAgICAgZnVuY3Rpb24gZHJhd0hhbmRsZShpbmRleCkge1xuICAgICAgICB2YXIgaFggPSBjb29yZHNbaW5kZXhdLFxuICAgICAgICAgICAgaFkgPSBjb29yZHNbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAocFggIT0gaFggfHwgcFkgIT0gaFkpIHtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhwWCwgcFkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oaFgsIGhZKTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5hcmMoaFgsIGhZLCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldLFxuICAgICAgICAgICAgc2VsZWN0aW9uID0gc2VnbWVudC5fc2VsZWN0aW9uO1xuXG4gICAgICAgIHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblxuICAgICAgICBwWCA9IGNvb3Jkc1swXTtcbiAgICAgICAgcFkgPSBjb29yZHNbMV07XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiAyKSBkcmF3SGFuZGxlKDIpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYgNCkgZHJhd0hhbmRsZSg0KTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHBYIC0gaGFsZiwgcFkgLSBoYWxmLCBzaXplLCBzaXplKTtcblxuICAgICAgICBpZiAobWluaVNpemUgPiAwICYmICEoc2VsZWN0aW9uICYgMSkpIHtcbiAgICAgICAgICB2YXIgZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuICAgICAgICAgIGN0eC5maWxsUmVjdChwWCAtIG1pbmlIYWxmLCBwWSAtIG1pbmlIYWxmLCBtaW5pU2l6ZSwgbWluaVNpemUpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3U2VnbWVudHMoY3R4LCBwYXRoLCBtYXRyaXgpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG4gICAgICAgICAgZmlyc3QgPSB0cnVlLFxuICAgICAgICAgIGN1clgsXG4gICAgICAgICAgY3VyWSxcbiAgICAgICAgICBwcmV2WCxcbiAgICAgICAgICBwcmV2WSxcbiAgICAgICAgICBpblgsXG4gICAgICAgICAgaW5ZLFxuICAgICAgICAgIG91dFgsXG4gICAgICAgICAgb3V0WTtcblxuICAgICAgZnVuY3Rpb24gZHJhd1NlZ21lbnQoc2VnbWVudCkge1xuICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgc2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMpO1xuXG4gICAgICAgICAgY3VyWCA9IGNvb3Jkc1swXTtcbiAgICAgICAgICBjdXJZID0gY29vcmRzWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50O1xuICAgICAgICAgIGN1clggPSBwb2ludC5feDtcbiAgICAgICAgICBjdXJZID0gcG9pbnQuX3k7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICBjdHgubW92ZVRvKGN1clgsIGN1clkpO1xuICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgaW5YID0gY29vcmRzWzJdO1xuICAgICAgICAgICAgaW5ZID0gY29vcmRzWzNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlSW47XG4gICAgICAgICAgICBpblggPSBjdXJYICsgaGFuZGxlLl94O1xuICAgICAgICAgICAgaW5ZID0gY3VyWSArIGhhbmRsZS5feTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5YID09PSBjdXJYICYmIGluWSA9PT0gY3VyWSAmJiBvdXRYID09PSBwcmV2WCAmJiBvdXRZID09PSBwcmV2WSkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjdXJYLCBjdXJZKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8ob3V0WCwgb3V0WSwgaW5YLCBpblksIGN1clgsIGN1clkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZYID0gY3VyWDtcbiAgICAgICAgcHJldlkgPSBjdXJZO1xuXG4gICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICBvdXRYID0gY29vcmRzWzRdO1xuICAgICAgICAgIG91dFkgPSBjb29yZHNbNV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGhhbmRsZSA9IHNlZ21lbnQuX2hhbmRsZU91dDtcbiAgICAgICAgICBvdXRYID0gcHJldlggKyBoYW5kbGUuX3g7XG4gICAgICAgICAgb3V0WSA9IHByZXZZICsgaGFuZGxlLl95O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGRyYXdTZWdtZW50KHNlZ21lbnRzW2ldKTtcblxuICAgICAgaWYgKHBhdGguX2Nsb3NlZCAmJiBsZW5ndGggPiAwKSBkcmF3U2VnbWVudChzZWdtZW50c1swXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIF9kcmF3OiBmdW5jdGlvbiAoY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG4gICAgICAgIHZhciBkb250U3RhcnQgPSBwYXJhbS5kb250U3RhcnQsXG4gICAgICAgICAgICBkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG4gICAgICAgICAgICBzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcbiAgICAgICAgICAgIGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG4gICAgICAgICAgICBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcbiAgICAgICAgICAgIGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuICAgICAgICAgICAgZGFzaExlbmd0aCA9ICFwYXBlci5zdXBwb3J0Lm5hdGl2ZURhc2ggJiYgaGFzU3Ryb2tlICYmIGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoO1xuICAgICAgICBpZiAoIWRvbnRTdGFydCkgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSAmJiAhZGFzaExlbmd0aCB8fCBkb250UGFpbnQpIHtcbiAgICAgICAgICBkcmF3U2VnbWVudHMoY3R4LCB0aGlzLCBzdHJva2VNYXRyaXgpO1xuICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldE9mZnNldChpKSB7XG4gICAgICAgICAgcmV0dXJuIGRhc2hBcnJheVsoaSAlIGRhc2hMZW5ndGggKyBkYXNoTGVuZ3RoKSAlIGRhc2hMZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuICAgICAgICAgIHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblxuICAgICAgICAgIGlmIChoYXNGaWxsKSB7XG4gICAgICAgICAgICBjdHguZmlsbChzdHlsZS5nZXRGaWxsUnVsZSgpKTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzU3Ryb2tlKSB7XG4gICAgICAgICAgICBpZiAoZGFzaExlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoIWRvbnRTdGFydCkgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICB2YXIgZmxhdHRlbmVyID0gbmV3IFBhdGhGbGF0dGVuZXIodGhpcywgMC4yNSwgMzIsIGZhbHNlLCBzdHJva2VNYXRyaXgpLFxuICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gZmxhdHRlbmVyLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAtc3R5bGUuZ2V0RGFzaE9mZnNldCgpLFxuICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgICB3aGlsZSAoZnJvbSA+IDApIHtcbiAgICAgICAgICAgICAgICBmcm9tIC09IGdldE9mZnNldChpLS0pICsgZ2V0T2Zmc2V0KGktLSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB3aGlsZSAoZnJvbSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRvID0gZnJvbSArIGdldE9mZnNldChpKyspO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gMCB8fCB0byA+IDApIGZsYXR0ZW5lci5kcmF3UGFydChjdHgsIE1hdGgubWF4KGZyb20sIDApLCBNYXRoLm1heCh0bywgMCkpO1xuICAgICAgICAgICAgICAgIGZyb20gPSB0byArIGdldE9mZnNldChpKyspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbiAoY3R4LCBtYXRyaXgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBkcmF3U2VnbWVudHMoY3R4LCB0aGlzLCBtYXRyaXgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGRyYXdIYW5kbGVzKGN0eCwgdGhpcy5fc2VnbWVudHMsIG1hdHJpeCwgcGFwZXIuc2V0dGluZ3MuaGFuZGxlU2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpLCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRTZWdtZW50KHRoYXQpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoYXQuX3NlZ21lbnRzO1xuICAgICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuICAgICAgcmV0dXJuIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtb3ZlVG86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDEpIHRoaXMucmVtb3ZlU2VnbWVudCgwKTtcbiAgICAgICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHRoaXMuX2FkZChbbmV3IFNlZ21lbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKV0pO1xuICAgICAgfSxcbiAgICAgIG1vdmVCeTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vdmVCeSgpIGlzIHVuc3VwcG9ydGVkIG9uIFBhdGggaXRlbXMuJyk7XG4gICAgICB9LFxuICAgICAgbGluZVRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FkZChbbmV3IFNlZ21lbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKV0pO1xuICAgICAgfSxcbiAgICAgIGN1YmljQ3VydmVUbzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgaGFuZGxlMiA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyk7XG4gICAgICAgIGN1cnJlbnQuc2V0SGFuZGxlT3V0KGhhbmRsZTEuc3VidHJhY3QoY3VycmVudC5fcG9pbnQpKTtcblxuICAgICAgICB0aGlzLl9hZGQoW25ldyBTZWdtZW50KHRvLCBoYW5kbGUyLnN1YnRyYWN0KHRvKSldKTtcbiAgICAgIH0sXG4gICAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaGFuZGxlID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHRvID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cbiAgICAgICAgdGhpcy5jdWJpY0N1cnZlVG8oaGFuZGxlLmFkZChjdXJyZW50LnN1YnRyYWN0KGhhbmRsZSkubXVsdGlwbHkoMSAvIDMpKSwgaGFuZGxlLmFkZCh0by5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksIHRvKTtcbiAgICAgIH0sXG4gICAgICBjdXJ2ZVRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICB0ID0gQmFzZS5waWNrKEJhc2UucmVhZChhcmdzKSwgMC41KSxcbiAgICAgICAgICAgIHQxID0gMSAtIHQsXG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50LFxuICAgICAgICAgICAgaGFuZGxlID0gdGhyb3VnaC5zdWJ0cmFjdChjdXJyZW50Lm11bHRpcGx5KHQxICogdDEpKS5zdWJ0cmFjdCh0by5tdWx0aXBseSh0ICogdCkpLmRpdmlkZSgyICogdCAqIHQxKTtcblxuICAgICAgICBpZiAoaGFuZGxlLmlzTmFOKCkpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHB1dCBhIGN1cnZlIHRocm91Z2ggcG9pbnRzIHdpdGggcGFyYW1ldGVyID0gJyArIHQpO1xuICAgICAgICB0aGlzLnF1YWRyYXRpY0N1cnZlVG8oaGFuZGxlLCB0byk7XG4gICAgICB9LFxuICAgICAgYXJjVG86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICAgIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyksXG4gICAgICAgICAgICBmcm9tID0gY3VycmVudC5fcG9pbnQsXG4gICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICB0aHJvdWdoLFxuICAgICAgICAgICAgcGVlayA9IEJhc2UucGVlayhhcmdzKSxcbiAgICAgICAgICAgIGNsb2Nrd2lzZSA9IEJhc2UucGljayhwZWVrLCB0cnVlKSxcbiAgICAgICAgICAgIGNlbnRlcixcbiAgICAgICAgICAgIGV4dGVudCxcbiAgICAgICAgICAgIHZlY3RvcixcbiAgICAgICAgICAgIG1hdHJpeDtcblxuICAgICAgICBpZiAodHlwZW9mIGNsb2Nrd2lzZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdmFyIG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG4gICAgICAgICAgICAgIHRocm91Z2ggPSBtaWRkbGUuYWRkKG1pZGRsZS5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoY2xvY2t3aXNlID8gLTkwIDogOTApKTtcbiAgICAgICAgfSBlbHNlIGlmIChCYXNlLnJlbWFpbihhcmdzKSA8PSAyKSB7XG4gICAgICAgICAgdGhyb3VnaCA9IHRvO1xuICAgICAgICAgIHRvID0gUG9pbnQucmVhZChhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmICghZnJvbS5lcXVhbHModG8pKSB7XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IFNpemUucmVhZChhcmdzKSxcbiAgICAgICAgICAgICAgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcbiAgICAgICAgICBpZiAoaXNaZXJvKHJhZGl1cy53aWR0aCkgfHwgaXNaZXJvKHJhZGl1cy5oZWlnaHQpKSByZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuICAgICAgICAgIHZhciByb3RhdGlvbiA9IEJhc2UucmVhZChhcmdzKSxcbiAgICAgICAgICAgICAgY2xvY2t3aXNlID0gISFCYXNlLnJlYWQoYXJncyksXG4gICAgICAgICAgICAgIGxhcmdlID0gISFCYXNlLnJlYWQoYXJncyksXG4gICAgICAgICAgICAgIG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG4gICAgICAgICAgICAgIHB0ID0gZnJvbS5zdWJ0cmFjdChtaWRkbGUpLnJvdGF0ZSgtcm90YXRpb24pLFxuICAgICAgICAgICAgICB4ID0gcHQueCxcbiAgICAgICAgICAgICAgeSA9IHB0LnksXG4gICAgICAgICAgICAgIHJ4ID0gYWJzKHJhZGl1cy53aWR0aCksXG4gICAgICAgICAgICAgIHJ5ID0gYWJzKHJhZGl1cy5oZWlnaHQpLFxuICAgICAgICAgICAgICByeFNxID0gcnggKiByeCxcbiAgICAgICAgICAgICAgcnlTcSA9IHJ5ICogcnksXG4gICAgICAgICAgICAgIHhTcSA9IHggKiB4LFxuICAgICAgICAgICAgICB5U3EgPSB5ICogeTtcbiAgICAgICAgICB2YXIgZmFjdG9yID0gc3FydCh4U3EgLyByeFNxICsgeVNxIC8gcnlTcSk7XG5cbiAgICAgICAgICBpZiAoZmFjdG9yID4gMSkge1xuICAgICAgICAgICAgcnggKj0gZmFjdG9yO1xuICAgICAgICAgICAgcnkgKj0gZmFjdG9yO1xuICAgICAgICAgICAgcnhTcSA9IHJ4ICogcng7XG4gICAgICAgICAgICByeVNxID0gcnkgKiByeTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmYWN0b3IgPSAocnhTcSAqIHJ5U3EgLSByeFNxICogeVNxIC0gcnlTcSAqIHhTcSkgLyAocnhTcSAqIHlTcSArIHJ5U3EgKiB4U3EpO1xuICAgICAgICAgIGlmIChhYnMoZmFjdG9yKSA8IDFlLTEyKSBmYWN0b3IgPSAwO1xuICAgICAgICAgIGlmIChmYWN0b3IgPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuICAgICAgICAgIGNlbnRlciA9IG5ldyBQb2ludChyeCAqIHkgLyByeSwgLXJ5ICogeCAvIHJ4KS5tdWx0aXBseSgobGFyZ2UgPT09IGNsb2Nrd2lzZSA/IC0xIDogMSkgKiBzcXJ0KGZhY3RvcikpLnJvdGF0ZShyb3RhdGlvbikuYWRkKG1pZGRsZSk7XG4gICAgICAgICAgbWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpLnJvdGF0ZShyb3RhdGlvbikuc2NhbGUocngsIHJ5KTtcbiAgICAgICAgICB2ZWN0b3IgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oZnJvbSk7XG4gICAgICAgICAgZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUobWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRvKSk7XG4gICAgICAgICAgaWYgKCFjbG9ja3dpc2UgJiYgZXh0ZW50ID4gMCkgZXh0ZW50IC09IDM2MDtlbHNlIGlmIChjbG9ja3dpc2UgJiYgZXh0ZW50IDwgMCkgZXh0ZW50ICs9IDM2MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aHJvdWdoKSB7XG4gICAgICAgICAgdmFyIGwxID0gbmV3IExpbmUoZnJvbS5hZGQodGhyb3VnaCkuZGl2aWRlKDIpLCB0aHJvdWdoLnN1YnRyYWN0KGZyb20pLnJvdGF0ZSg5MCksIHRydWUpLFxuICAgICAgICAgICAgICBsMiA9IG5ldyBMaW5lKHRocm91Z2guYWRkKHRvKS5kaXZpZGUoMiksIHRvLnN1YnRyYWN0KHRocm91Z2gpLnJvdGF0ZSg5MCksIHRydWUpLFxuICAgICAgICAgICAgICBsaW5lID0gbmV3IExpbmUoZnJvbSwgdG8pLFxuICAgICAgICAgICAgICB0aHJvdWdoU2lkZSA9IGxpbmUuZ2V0U2lkZSh0aHJvdWdoKTtcbiAgICAgICAgICBjZW50ZXIgPSBsMS5pbnRlcnNlY3QobDIsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKCFjZW50ZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhyb3VnaFNpZGUpIHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZlY3RvciA9IGZyb20uc3VidHJhY3QoY2VudGVyKTtcbiAgICAgICAgICBleHRlbnQgPSB2ZWN0b3IuZ2V0RGlyZWN0ZWRBbmdsZSh0by5zdWJ0cmFjdChjZW50ZXIpKTtcbiAgICAgICAgICB2YXIgY2VudGVyU2lkZSA9IGxpbmUuZ2V0U2lkZShjZW50ZXIsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKGNlbnRlclNpZGUgPT09IDApIHtcbiAgICAgICAgICAgIGV4dGVudCA9IHRocm91Z2hTaWRlICogYWJzKGV4dGVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aHJvdWdoU2lkZSA9PT0gY2VudGVyU2lkZSkge1xuICAgICAgICAgICAgZXh0ZW50ICs9IGV4dGVudCA8IDAgPyAzNjAgOiAtMzYwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgICB2YXIgZXBzaWxvbiA9IDFlLTcsXG4gICAgICAgICAgICAgIGV4dCA9IGFicyhleHRlbnQpLFxuICAgICAgICAgICAgICBjb3VudCA9IGV4dCA+PSAzNjAgPyA0IDogTWF0aC5jZWlsKChleHQgLSBlcHNpbG9uKSAvIDkwKSxcbiAgICAgICAgICAgICAgaW5jID0gZXh0ZW50IC8gY291bnQsXG4gICAgICAgICAgICAgIGhhbGYgPSBpbmMgKiBNYXRoLlBJIC8gMzYwLFxuICAgICAgICAgICAgICB6ID0gNCAvIDMgKiBNYXRoLnNpbihoYWxmKSAvICgxICsgTWF0aC5jb3MoaGFsZikpLFxuICAgICAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHB0ID0gdG8sXG4gICAgICAgICAgICAgICAgb3V0ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICBvdXQgPSB2ZWN0b3Iucm90YXRlKDkwKS5tdWx0aXBseSh6KTtcblxuICAgICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgcHQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvcik7XG4gICAgICAgICAgICAgICAgb3V0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKG91dCkpLnN1YnRyYWN0KHB0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdCA9IGNlbnRlci5hZGQodmVjdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgY3VycmVudC5zZXRIYW5kbGVPdXQob3V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfaW4gPSB2ZWN0b3Iucm90YXRlKC05MCkubXVsdGlwbHkoeik7XG5cbiAgICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgICAgIF9pbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChfaW4pKS5zdWJ0cmFjdChwdCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHB0LCBfaW4sIG91dCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZWN0b3IgPSB2ZWN0b3Iucm90YXRlKGluYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fYWRkKHNlZ21lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxpbmVCeTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXG4gICAgICAgIHRoaXMubGluZVRvKGN1cnJlbnQuYWRkKHRvKSk7XG4gICAgICB9LFxuICAgICAgY3VydmVCeTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIHRocm91Z2ggPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgcGFyYW1ldGVyID0gQmFzZS5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblxuICAgICAgICB0aGlzLmN1cnZlVG8oY3VycmVudC5hZGQodGhyb3VnaCksIGN1cnJlbnQuYWRkKHRvKSwgcGFyYW1ldGVyKTtcbiAgICAgIH0sXG4gICAgICBjdWJpY0N1cnZlQnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBoYW5kbGUxID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblxuICAgICAgICB0aGlzLmN1YmljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUxKSwgY3VycmVudC5hZGQoaGFuZGxlMiksIGN1cnJlbnQuYWRkKHRvKSk7XG4gICAgICB9LFxuICAgICAgcXVhZHJhdGljQ3VydmVCeTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGhhbmRsZSA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXG4gICAgICAgIHRoaXMucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUpLCBjdXJyZW50LmFkZCh0bykpO1xuICAgICAgfSxcbiAgICAgIGFyY0J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcbiAgICAgICAgICAgIHBvaW50ID0gY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmdzKSksXG4gICAgICAgICAgICBjbG9ja3dpc2UgPSBCYXNlLnBpY2soQmFzZS5wZWVrKGFyZ3MpLCB0cnVlKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNsb2Nrd2lzZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhpcy5hcmNUbyhwb2ludCwgY2xvY2t3aXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFyY1RvKHBvaW50LCBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3MpKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uICh0b2xlcmFuY2UpIHtcbiAgICAgICAgdGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG4gICAgICAgIHRoaXMuam9pbih0aGlzLCB0b2xlcmFuY2UpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKSwge1xuICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uIChtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBtZXRob2QgPSBvcHRpb25zLmhhbmRsZSA/ICdnZXRIYW5kbGVCb3VuZHMnIDogb3B0aW9ucy5zdHJva2UgPyAnZ2V0U3Ryb2tlQm91bmRzJyA6ICdnZXRCb3VuZHMnO1xuICAgICAgcmV0dXJuIFBhdGhbbWV0aG9kXSh0aGlzLl9zZWdtZW50cywgdGhpcy5fY2xvc2VkLCB0aGlzLCBtYXRyaXgsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgc3RhdGljczoge1xuICAgICAgZ2V0Qm91bmRzOiBmdW5jdGlvbiAoc2VnbWVudHMsIGNsb3NlZCwgcGF0aCwgbWF0cml4LCBvcHRpb25zLCBzdHJva2VQYWRkaW5nKSB7XG4gICAgICAgIHZhciBmaXJzdCA9IHNlZ21lbnRzWzBdO1xuICAgICAgICBpZiAoIWZpcnN0KSByZXR1cm4gbmV3IFJlY3RhbmdsZSgpO1xuXG4gICAgICAgIHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG4gICAgICAgICAgICBwcmV2Q29vcmRzID0gZmlyc3QuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgbmV3IEFycmF5KDYpKSxcbiAgICAgICAgICAgIG1pbiA9IHByZXZDb29yZHMuc2xpY2UoMCwgMiksXG4gICAgICAgICAgICBtYXggPSBtaW4uc2xpY2UoKSxcbiAgICAgICAgICAgIHJvb3RzID0gbmV3IEFycmF5KDIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgICAgICBzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3Jkcyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgQ3VydmUuX2FkZEJvdW5kcyhwcmV2Q29vcmRzW2ldLCBwcmV2Q29vcmRzW2kgKyA0XSwgY29vcmRzW2kgKyAyXSwgY29vcmRzW2ldLCBpLCBzdHJva2VQYWRkaW5nID8gc3Ryb2tlUGFkZGluZ1tpXSA6IDAsIG1pbiwgbWF4LCByb290cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRtcCA9IHByZXZDb29yZHM7XG4gICAgICAgICAgcHJldkNvb3JkcyA9IGNvb3JkcztcbiAgICAgICAgICBjb29yZHMgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykgcHJvY2Vzc1NlZ21lbnQoc2VnbWVudHNbaV0pO1xuXG4gICAgICAgIGlmIChjbG9zZWQpIHByb2Nlc3NTZWdtZW50KGZpcnN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcbiAgICAgIH0sXG4gICAgICBnZXRTdHJva2VCb3VuZHM6IGZ1bmN0aW9uIChzZWdtZW50cywgY2xvc2VkLCBwYXRoLCBtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gcGF0aC5nZXRTdHlsZSgpLFxuICAgICAgICAgICAgc3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCksXG4gICAgICAgICAgICBzdHJva2VNYXRyaXggPSBzdHJva2UgJiYgcGF0aC5fZ2V0U3Ryb2tlTWF0cml4KG1hdHJpeCwgb3B0aW9ucyksXG4gICAgICAgICAgICBzdHJva2VQYWRkaW5nID0gc3Ryb2tlICYmIFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlV2lkdGgsIHN0cm9rZU1hdHJpeCksXG4gICAgICAgICAgICBib3VuZHMgPSBQYXRoLmdldEJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBwYXRoLCBtYXRyaXgsIG9wdGlvbnMsIHN0cm9rZVBhZGRpbmcpO1xuXG4gICAgICAgIGlmICghc3Ryb2tlKSByZXR1cm4gYm91bmRzO1xuICAgICAgICB2YXIgc3Ryb2tlUmFkaXVzID0gc3Ryb2tlV2lkdGggLyAyLFxuICAgICAgICAgICAgam9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcbiAgICAgICAgICAgIGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuICAgICAgICAgICAgbWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKSxcbiAgICAgICAgICAgIGpvaW5Cb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBTaXplKHN0cm9rZVBhZGRpbmcpKTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRQb2ludChwb2ludCkge1xuICAgICAgICAgIGJvdW5kcyA9IGJvdW5kcy5pbmNsdWRlKHBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFJvdW5kKHNlZ21lbnQpIHtcbiAgICAgICAgICBib3VuZHMgPSBib3VuZHMudW5pdGUoam9pbkJvdW5kcy5zZXRDZW50ZXIoc2VnbWVudC5fcG9pbnQudHJhbnNmb3JtKG1hdHJpeCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEpvaW4oc2VnbWVudCwgam9pbikge1xuICAgICAgICAgIGlmIChqb2luID09PSAncm91bmQnIHx8IHNlZ21lbnQuaXNTbW9vdGgoKSkge1xuICAgICAgICAgICAgYWRkUm91bmQoc2VnbWVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFBhdGguX2FkZEJldmVsSm9pbihzZWdtZW50LCBqb2luLCBzdHJva2VSYWRpdXMsIG1pdGVyTGltaXQsIG1hdHJpeCwgc3Ryb2tlTWF0cml4LCBhZGRQb2ludCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkQ2FwKHNlZ21lbnQsIGNhcCkge1xuICAgICAgICAgIGlmIChjYXAgPT09ICdyb3VuZCcpIHtcbiAgICAgICAgICAgIGFkZFJvdW5kKHNlZ21lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCBzdHJva2VSYWRpdXMsIG1hdHJpeCwgc3Ryb2tlTWF0cml4LCBhZGRQb2ludCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCAtIChjbG9zZWQgPyAwIDogMSk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhZGRKb2luKHNlZ21lbnRzW2ldLCBqb2luKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICBhZGRKb2luKHNlZ21lbnRzWzBdLCBqb2luKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkQ2FwKHNlZ21lbnRzWzBdLCBjYXApO1xuICAgICAgICAgICAgYWRkQ2FwKHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLCBjYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9LFxuICAgICAgX2dldFN0cm9rZVBhZGRpbmc6IGZ1bmN0aW9uIChyYWRpdXMsIG1hdHJpeCkge1xuICAgICAgICBpZiAoIW1hdHJpeCkgcmV0dXJuIFtyYWRpdXMsIHJhZGl1c107XG4gICAgICAgIHZhciBob3IgPSBuZXcgUG9pbnQocmFkaXVzLCAwKS50cmFuc2Zvcm0obWF0cml4KSxcbiAgICAgICAgICAgIHZlciA9IG5ldyBQb2ludCgwLCByYWRpdXMpLnRyYW5zZm9ybShtYXRyaXgpLFxuICAgICAgICAgICAgcGhpID0gaG9yLmdldEFuZ2xlSW5SYWRpYW5zKCksXG4gICAgICAgICAgICBhID0gaG9yLmdldExlbmd0aCgpLFxuICAgICAgICAgICAgYiA9IHZlci5nZXRMZW5ndGgoKTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHBoaSksXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhwaGkpLFxuICAgICAgICAgICAgdGFuID0gTWF0aC50YW4ocGhpKSxcbiAgICAgICAgICAgIHR4ID0gTWF0aC5hdGFuMihiICogdGFuLCBhKSxcbiAgICAgICAgICAgIHR5ID0gTWF0aC5hdGFuMihiLCB0YW4gKiBhKTtcbiAgICAgICAgcmV0dXJuIFtNYXRoLmFicyhhICogTWF0aC5jb3ModHgpICogY29zICsgYiAqIE1hdGguc2luKHR4KSAqIHNpbiksIE1hdGguYWJzKGIgKiBNYXRoLnNpbih0eSkgKiBjb3MgKyBhICogTWF0aC5jb3ModHkpICogc2luKV07XG4gICAgICB9LFxuICAgICAgX2FkZEJldmVsSm9pbjogZnVuY3Rpb24gKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgbWF0cml4LCBzdHJva2VNYXRyaXgsIGFkZFBvaW50LCBpc0FyZWEpIHtcbiAgICAgICAgdmFyIGN1cnZlMiA9IHNlZ21lbnQuZ2V0Q3VydmUoKSxcbiAgICAgICAgICAgIGN1cnZlMSA9IGN1cnZlMi5nZXRQcmV2aW91cygpLFxuICAgICAgICAgICAgcG9pbnQgPSBjdXJ2ZTIuZ2V0UG9pbnQxKCkudHJhbnNmb3JtKG1hdHJpeCksXG4gICAgICAgICAgICBub3JtYWwxID0gY3VydmUxLmdldE5vcm1hbEF0VGltZSgxKS5tdWx0aXBseShyYWRpdXMpLnRyYW5zZm9ybShzdHJva2VNYXRyaXgpLFxuICAgICAgICAgICAgbm9ybWFsMiA9IGN1cnZlMi5nZXROb3JtYWxBdFRpbWUoMCkubXVsdGlwbHkocmFkaXVzKS50cmFuc2Zvcm0oc3Ryb2tlTWF0cml4KSxcbiAgICAgICAgICAgIGFuZ2xlID0gbm9ybWFsMS5nZXREaXJlY3RlZEFuZ2xlKG5vcm1hbDIpO1xuXG4gICAgICAgIGlmIChhbmdsZSA8IDAgfHwgYW5nbGUgPj0gMTgwKSB7XG4gICAgICAgICAgbm9ybWFsMSA9IG5vcm1hbDEubmVnYXRlKCk7XG4gICAgICAgICAgbm9ybWFsMiA9IG5vcm1hbDIubmVnYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcmVhKSBhZGRQb2ludChwb2ludCk7XG4gICAgICAgIGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG5cbiAgICAgICAgaWYgKGpvaW4gPT09ICdtaXRlcicpIHtcbiAgICAgICAgICB2YXIgY29ybmVyID0gbmV3IExpbmUocG9pbnQuYWRkKG5vcm1hbDEpLCBuZXcgUG9pbnQoLW5vcm1hbDEueSwgbm9ybWFsMS54KSwgdHJ1ZSkuaW50ZXJzZWN0KG5ldyBMaW5lKHBvaW50LmFkZChub3JtYWwyKSwgbmV3IFBvaW50KC1ub3JtYWwyLnksIG5vcm1hbDIueCksIHRydWUpLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChjb3JuZXIgJiYgcG9pbnQuZ2V0RGlzdGFuY2UoY29ybmVyKSA8PSBtaXRlckxpbWl0ICogcmFkaXVzKSB7XG4gICAgICAgICAgICBhZGRQb2ludChjb3JuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwyKSk7XG4gICAgICB9LFxuICAgICAgX2FkZFNxdWFyZUNhcDogZnVuY3Rpb24gKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBtYXRyaXgsIHN0cm9rZU1hdHJpeCwgYWRkUG9pbnQsIGlzQXJlYSkge1xuICAgICAgICB2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludC50cmFuc2Zvcm0obWF0cml4KSxcbiAgICAgICAgICAgIGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKSxcbiAgICAgICAgICAgIG5vcm1hbCA9IGxvYy5nZXROb3JtYWwoKS5tdWx0aXBseShsb2MuZ2V0VGltZSgpID09PSAwID8gcmFkaXVzIDogLXJhZGl1cykudHJhbnNmb3JtKHN0cm9rZU1hdHJpeCk7XG5cbiAgICAgICAgaWYgKGNhcCA9PT0gJ3NxdWFyZScpIHtcbiAgICAgICAgICBpZiAoaXNBcmVhKSB7XG4gICAgICAgICAgICBhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcbiAgICAgICAgICAgIGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb2ludCA9IHBvaW50LmFkZChub3JtYWwucm90YXRlKC05MCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuICAgICAgICBhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcbiAgICAgIH0sXG4gICAgICBnZXRIYW5kbGVCb3VuZHM6IGZ1bmN0aW9uIChzZWdtZW50cywgY2xvc2VkLCBwYXRoLCBtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gcGF0aC5nZXRTdHlsZSgpLFxuICAgICAgICAgICAgc3Ryb2tlID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKCksXG4gICAgICAgICAgICBzdHJva2VQYWRkaW5nLFxuICAgICAgICAgICAgam9pblBhZGRpbmc7XG5cbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgIHZhciBzdHJva2VNYXRyaXggPSBwYXRoLl9nZXRTdHJva2VNYXRyaXgobWF0cml4LCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgc3Ryb2tlUmFkaXVzID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIsXG4gICAgICAgICAgICAgIGpvaW5SYWRpdXMgPSBzdHJva2VSYWRpdXM7XG5cbiAgICAgICAgICBpZiAoc3R5bGUuZ2V0U3Ryb2tlSm9pbigpID09PSAnbWl0ZXInKSBqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgICAgIGlmIChzdHlsZS5nZXRTdHJva2VDYXAoKSA9PT0gJ3NxdWFyZScpIGpvaW5SYWRpdXMgPSBNYXRoLm1heChqb2luUmFkaXVzLCBzdHJva2VSYWRpdXMgKiBNYXRoLlNRUlQyKTtcbiAgICAgICAgICBzdHJva2VQYWRkaW5nID0gUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VSYWRpdXMsIHN0cm9rZU1hdHJpeCk7XG4gICAgICAgICAgam9pblBhZGRpbmcgPSBQYXRoLl9nZXRTdHJva2VQYWRkaW5nKGpvaW5SYWRpdXMsIHN0cm9rZU1hdHJpeCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuICAgICAgICAgICAgeDEgPSBJbmZpbml0eSxcbiAgICAgICAgICAgIHgyID0gLXgxLFxuICAgICAgICAgICAgeTEgPSB4MSxcbiAgICAgICAgICAgIHkyID0geDI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXG4gICAgICAgICAgc2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA2OyBqICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gIWogPyBqb2luUGFkZGluZyA6IHN0cm9rZVBhZGRpbmcsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1ggPSBwYWRkaW5nID8gcGFkZGluZ1swXSA6IDAsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1kgPSBwYWRkaW5nID8gcGFkZGluZ1sxXSA6IDAsXG4gICAgICAgICAgICAgICAgeCA9IGNvb3Jkc1tqXSxcbiAgICAgICAgICAgICAgICB5ID0gY29vcmRzW2ogKyAxXSxcbiAgICAgICAgICAgICAgICB4biA9IHggLSBwYWRkaW5nWCxcbiAgICAgICAgICAgICAgICB4eCA9IHggKyBwYWRkaW5nWCxcbiAgICAgICAgICAgICAgICB5biA9IHkgLSBwYWRkaW5nWSxcbiAgICAgICAgICAgICAgICB5eCA9IHkgKyBwYWRkaW5nWTtcbiAgICAgICAgICAgIGlmICh4biA8IHgxKSB4MSA9IHhuO1xuICAgICAgICAgICAgaWYgKHh4ID4geDIpIHgyID0geHg7XG4gICAgICAgICAgICBpZiAoeW4gPCB5MSkgeTEgPSB5bjtcbiAgICAgICAgICAgIGlmICh5eCA+IHkyKSB5MiA9IHl4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUGF0aC5pbmplY3Qoe1xuICAgIHN0YXRpY3M6IG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzYsXG4gICAgICAgICAgZWxsaXBzZVNlZ21lbnRzID0gW25ldyBTZWdtZW50KFstMSwgMF0sIFswLCBrYXBwYV0sIFswLCAta2FwcGFdKSwgbmV3IFNlZ21lbnQoWzAsIC0xXSwgWy1rYXBwYSwgMF0sIFtrYXBwYSwgMF0pLCBuZXcgU2VnbWVudChbMSwgMF0sIFswLCAta2FwcGFdLCBbMCwga2FwcGFdKSwgbmV3IFNlZ21lbnQoWzAsIDFdLCBba2FwcGEsIDBdLCBbLWthcHBhLCAwXSldO1xuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKHNlZ21lbnRzLCBjbG9zZWQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHByb3BzID0gQmFzZS5nZXROYW1lZChhcmdzKSxcbiAgICAgICAgICAgIHBhdGggPSBuZXcgUGF0aChwcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT0gZmFsc2UgJiYgSXRlbS5OT19JTlNFUlQpO1xuXG4gICAgICAgIHBhdGguX2FkZChzZWdtZW50cyk7XG5cbiAgICAgICAgcGF0aC5fY2xvc2VkID0gY2xvc2VkO1xuICAgICAgICByZXR1cm4gcGF0aC5zZXQocHJvcHMsIHtcbiAgICAgICAgICBpbnNlcnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCByYWRpdXMsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gbmV3IEFycmF5KDQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbGxpcHNlU2VnbWVudHNbaV07XG4gICAgICAgICAgc2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChzZWdtZW50Ll9wb2ludC5tdWx0aXBseShyYWRpdXMpLmFkZChjZW50ZXIpLCBzZWdtZW50Ll9oYW5kbGVJbi5tdWx0aXBseShyYWRpdXMpLCBzZWdtZW50Ll9oYW5kbGVPdXQubXVsdGlwbHkocmFkaXVzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIExpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aChbbmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdmcm9tJykpLCBuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJncywgJ3RvJykpXSwgZmFsc2UsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBDaXJjbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdjZW50ZXInKSxcbiAgICAgICAgICAgICAgcmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVFbGxpcHNlKGNlbnRlciwgbmV3IFNpemUocmFkaXVzKSwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJlY3RhbmdsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyksXG4gICAgICAgICAgICAgIHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnLCAwLCB7XG4gICAgICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBibCA9IHJlY3QuZ2V0Qm90dG9tTGVmdCh0cnVlKSxcbiAgICAgICAgICAgICAgdGwgPSByZWN0LmdldFRvcExlZnQodHJ1ZSksXG4gICAgICAgICAgICAgIHRyID0gcmVjdC5nZXRUb3BSaWdodCh0cnVlKSxcbiAgICAgICAgICAgICAgYnIgPSByZWN0LmdldEJvdHRvbVJpZ2h0KHRydWUpLFxuICAgICAgICAgICAgICBzZWdtZW50cztcblxuICAgICAgICAgIGlmICghcmFkaXVzIHx8IHJhZGl1cy5pc1plcm8oKSkge1xuICAgICAgICAgICAgc2VnbWVudHMgPSBbbmV3IFNlZ21lbnQoYmwpLCBuZXcgU2VnbWVudCh0bCksIG5ldyBTZWdtZW50KHRyKSwgbmV3IFNlZ21lbnQoYnIpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFkaXVzID0gU2l6ZS5taW4ocmFkaXVzLCByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpKTtcbiAgICAgICAgICAgIHZhciByeCA9IHJhZGl1cy53aWR0aCxcbiAgICAgICAgICAgICAgICByeSA9IHJhZGl1cy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgaHggPSByeCAqIGthcHBhLFxuICAgICAgICAgICAgICAgIGh5ID0gcnkgKiBrYXBwYTtcbiAgICAgICAgICAgIHNlZ21lbnRzID0gW25ldyBTZWdtZW50KGJsLmFkZChyeCwgMCksIG51bGwsIFstaHgsIDBdKSwgbmV3IFNlZ21lbnQoYmwuc3VidHJhY3QoMCwgcnkpLCBbMCwgaHldKSwgbmV3IFNlZ21lbnQodGwuYWRkKDAsIHJ5KSwgbnVsbCwgWzAsIC1oeV0pLCBuZXcgU2VnbWVudCh0bC5hZGQocngsIDApLCBbLWh4LCAwXSwgbnVsbCksIG5ldyBTZWdtZW50KHRyLnN1YnRyYWN0KHJ4LCAwKSwgbnVsbCwgW2h4LCAwXSksIG5ldyBTZWdtZW50KHRyLmFkZCgwLCByeSksIFswLCAtaHldLCBudWxsKSwgbmV3IFNlZ21lbnQoYnIuc3VidHJhY3QoMCwgcnkpLCBudWxsLCBbMCwgaHldKSwgbmV3IFNlZ21lbnQoYnIuc3VidHJhY3QocngsIDApLCBbaHgsIDBdKV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBSb3VuZFJlY3RhbmdsZTogJyNSZWN0YW5nbGUnLFxuICAgICAgICBFbGxpcHNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJncyk7XG5cbiAgICAgICAgICByZXR1cm4gY3JlYXRlRWxsaXBzZShlbGxpcHNlLmNlbnRlciwgZWxsaXBzZS5yYWRpdXMsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBPdmFsOiAnI0VsbGlwc2UnLFxuICAgICAgICBBcmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgZnJvbSA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnZnJvbScpLFxuICAgICAgICAgICAgICB0aHJvdWdoID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICd0aHJvdWdoJyksXG4gICAgICAgICAgICAgIHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICd0bycpLFxuICAgICAgICAgICAgICBwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJncyksXG4gICAgICAgICAgICAgIHBhdGggPSBuZXcgUGF0aChwcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT0gZmFsc2UgJiYgSXRlbS5OT19JTlNFUlQpO1xuICAgICAgICAgIHBhdGgubW92ZVRvKGZyb20pO1xuICAgICAgICAgIHBhdGguYXJjVG8odGhyb3VnaCwgdG8pO1xuICAgICAgICAgIHJldHVybiBwYXRoLnNldChwcm9wcyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJlZ3VsYXJQb2x5Z29uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyksXG4gICAgICAgICAgICAgIHNpZGVzID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3NpZGVzJyksXG4gICAgICAgICAgICAgIHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKSxcbiAgICAgICAgICAgICAgc3RlcCA9IDM2MCAvIHNpZGVzLFxuICAgICAgICAgICAgICB0aHJlZSA9IHNpZGVzICUgMyA9PT0gMCxcbiAgICAgICAgICAgICAgdmVjdG9yID0gbmV3IFBvaW50KDAsIHRocmVlID8gLXJhZGl1cyA6IHJhZGl1cyksXG4gICAgICAgICAgICAgIG9mZnNldCA9IHRocmVlID8gLTEgOiAwLjUsXG4gICAgICAgICAgICAgIHNlZ21lbnRzID0gbmV3IEFycmF5KHNpZGVzKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykgc2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChjZW50ZXIuYWRkKHZlY3Rvci5yb3RhdGUoKGkgKyBvZmZzZXQpICogc3RlcCkpKTtcblxuICAgICAgICAgIHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgU3RhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpLFxuICAgICAgICAgICAgICBwb2ludHMgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncG9pbnRzJykgKiAyLFxuICAgICAgICAgICAgICByYWRpdXMxID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1czEnKSxcbiAgICAgICAgICAgICAgcmFkaXVzMiA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMyJyksXG4gICAgICAgICAgICAgIHN0ZXAgPSAzNjAgLyBwb2ludHMsXG4gICAgICAgICAgICAgIHZlY3RvciA9IG5ldyBQb2ludCgwLCAtMSksXG4gICAgICAgICAgICAgIHNlZ21lbnRzID0gbmV3IEFycmF5KHBvaW50cyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czsgaSsrKSBzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQodmVjdG9yLnJvdGF0ZShzdGVwICogaSkubXVsdGlwbHkoaSAlIDIgPyByYWRpdXMyIDogcmFkaXVzMSkpKTtcblxuICAgICAgICAgIHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KClcbiAgfSk7XG4gIHZhciBDb21wb3VuZFBhdGggPSBQYXRoSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0NvbXBvdW5kUGF0aCcsXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSxcbiAgICBiZWFuczogdHJ1ZSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBDb21wb3VuZFBhdGgoYXJnKSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXG4gICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24gaW5zZXJ0Q2hpbGRyZW4oaW5kZXgsIGl0ZW1zKSB7XG4gICAgICB2YXIgbGlzdCA9IGl0ZW1zLFxuICAgICAgICAgIGZpcnN0ID0gbGlzdFswXTtcbiAgICAgIGlmIChmaXJzdCAmJiB0eXBlb2YgZmlyc3RbMF0gPT09ICdudW1iZXInKSBsaXN0ID0gW2xpc3RdO1xuXG4gICAgICBmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBpZiAobGlzdCA9PT0gaXRlbXMgJiYgIShpdGVtIGluc3RhbmNlb2YgUGF0aCkpIGxpc3QgPSBCYXNlLnNsaWNlKGxpc3QpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgbGlzdFtpXSA9IG5ldyBQYXRoKHtcbiAgICAgICAgICAgIHNlZ21lbnRzOiBpdGVtLFxuICAgICAgICAgICAgaW5zZXJ0OiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpIHtcbiAgICAgICAgICBsaXN0LnNwbGljZS5hcHBseShsaXN0LCBbaSwgMV0uY29uY2F0KGl0ZW0ucmVtb3ZlQ2hpbGRyZW4oKSkpO1xuICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc2VydENoaWxkcmVuLmJhc2UuY2FsbCh0aGlzLCBpbmRleCwgbGlzdCk7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShvcHRpb25zKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBwYXRoID0gY2hpbGRyZW5baV0ucmVkdWNlKG9wdGlvbnMpO1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHBhdGgucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuICAgICAgICBwYXRoLmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuICAgICAgICBwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZHVjZS5iYXNlLmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBpc0Nsb3NlZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghY2hpbGRyZW5baV0uX2Nsb3NlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHNldENsb3NlZDogZnVuY3Rpb24gKGNsb3NlZCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLnNldENsb3NlZChjbG9zZWQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdFNlZ21lbnQoKTtcbiAgICB9LFxuICAgIGdldExhc3RTZWdtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG4gICAgICByZXR1cm4gbGFzdCAmJiBsYXN0LmdldExhc3RTZWdtZW50KCk7XG4gICAgfSxcbiAgICBnZXRDdXJ2ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgIGN1cnZlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBCYXNlLnB1c2goY3VydmVzLCBjaGlsZHJlbltpXS5nZXRDdXJ2ZXMoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJ2ZXM7XG4gICAgfSxcbiAgICBnZXRGaXJzdEN1cnZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdEN1cnZlKCk7XG4gICAgfSxcbiAgICBnZXRMYXN0Q3VydmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgIHJldHVybiBsYXN0ICYmIGxhc3QuZ2V0TGFzdEN1cnZlKCk7XG4gICAgfSxcbiAgICBnZXRBcmVhOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICBhcmVhID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGFyZWEgKz0gY2hpbGRyZW5baV0uZ2V0QXJlYSgpO1xuXG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9LFxuICAgIGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGxlbmd0aCArPSBjaGlsZHJlbltpXS5nZXRMZW5ndGgoKTtcblxuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuICAgIGdldFBhdGhEYXRhOiBmdW5jdGlvbiAoX21hdHJpeCwgX3ByZWNpc2lvbikge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgcGF0aHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBteCA9IGNoaWxkLl9tYXRyaXg7XG4gICAgICAgIHBhdGhzLnB1c2goY2hpbGQuZ2V0UGF0aERhdGEoX21hdHJpeCAmJiAhbXguaXNJZGVudGl0eSgpID8gX21hdHJpeC5hcHBlbmRlZChteCkgOiBfbWF0cml4LCBfcHJlY2lzaW9uKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRocy5qb2luKCcnKTtcbiAgICB9LFxuICAgIF9oaXRUZXN0Q2hpbGRyZW46IGZ1bmN0aW9uIF9oaXRUZXN0Q2hpbGRyZW4ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpIHtcbiAgICAgIHJldHVybiBfaGl0VGVzdENoaWxkcmVuLmJhc2UuY2FsbCh0aGlzLCBwb2ludCwgb3B0aW9ucy5jbGFzcyA9PT0gUGF0aCB8fCBvcHRpb25zLnR5cGUgPT09ICdwYXRoJyA/IG9wdGlvbnMgOiBCYXNlLnNldCh7fSwgb3B0aW9ucywge1xuICAgICAgICBmaWxsOiBmYWxzZVxuICAgICAgfSksIHZpZXdNYXRyaXgpO1xuICAgIH0sXG4gICAgX2RyYXc6IGZ1bmN0aW9uIChjdHgsIHBhcmFtLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHJldHVybjtcbiAgICAgIHBhcmFtID0gcGFyYW0uZXh0ZW5kKHtcbiAgICAgICAgZG9udFN0YXJ0OiB0cnVlLFxuICAgICAgICBkb250RmluaXNoOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGNoaWxkcmVuW2ldLmRyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcblxuICAgICAgaWYgKCFwYXJhbS5jbGlwKSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblxuICAgICAgICBpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgY3R4LmZpbGwoc3R5bGUuZ2V0RmlsbFJ1bGUoKSk7XG4gICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKSBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbiAoY3R4LCBtYXRyaXgsIHNlbGVjdGlvbkl0ZW1zKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBteCA9IGNoaWxkLl9tYXRyaXg7XG5cbiAgICAgICAgaWYgKCFzZWxlY3Rpb25JdGVtc1tjaGlsZC5faWRdKSB7XG4gICAgICAgICAgY2hpbGQuX2RyYXdTZWxlY3RlZChjdHgsIG14LmlzSWRlbnRpdHkoKSA/IG1hdHJpeCA6IG1hdHJpeC5hcHBlbmRlZChteCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRQYXRoKHRoYXQsIGNoZWNrKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGF0Ll9jaGlsZHJlbjtcbiAgICAgIGlmIChjaGVjayAmJiAhY2hpbGRyZW4ubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIG1vdmVUbygpIGNvbW1hbmQgZmlyc3QnKTtcbiAgICAgIHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gQmFzZS5lYWNoKFsnbGluZVRvJywgJ2N1YmljQ3VydmVUbycsICdxdWFkcmF0aWNDdXJ2ZVRvJywgJ2N1cnZlVG8nLCAnYXJjVG8nLCAnbGluZUJ5JywgJ2N1YmljQ3VydmVCeScsICdxdWFkcmF0aWNDdXJ2ZUJ5JywgJ2N1cnZlQnknLCAnYXJjQnknXSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgdGhpc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0aCA9IGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpO1xuICAgICAgICBwYXRoW2tleV0uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSwge1xuICAgICAgbW92ZVRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcyksXG4gICAgICAgICAgICBwYXRoID0gY3VycmVudCAmJiBjdXJyZW50LmlzRW1wdHkoKSA/IGN1cnJlbnQgOiBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG4gICAgICAgIGlmIChwYXRoICE9PSBjdXJyZW50KSB0aGlzLmFkZENoaWxkKHBhdGgpO1xuICAgICAgICBwYXRoLm1vdmVUby5hcHBseShwYXRoLCBhcmd1bWVudHMpO1xuICAgICAgfSxcbiAgICAgIG1vdmVCeTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLFxuICAgICAgICAgICAgbGFzdCA9IGN1cnJlbnQgJiYgY3VycmVudC5nZXRMYXN0U2VnbWVudCgpLFxuICAgICAgICAgICAgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW92ZVRvKGxhc3QgPyBwb2ludC5hZGQobGFzdC5fcG9pbnQpIDogcG9pbnQpO1xuICAgICAgfSxcbiAgICAgIGNsb3NlUGF0aDogZnVuY3Rpb24gKHRvbGVyYW5jZSkge1xuICAgICAgICBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKS5jbG9zZVBhdGgodG9sZXJhbmNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSgpLCBCYXNlLmVhY2goWydyZXZlcnNlJywgJ2ZsYXR0ZW4nLCAnc2ltcGxpZnknLCAnc21vb3RoJ10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0aGlzW2tleV0gPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgIHJlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmVzID0gY2hpbGRyZW5baV1ba2V5XShwYXJhbSkgfHwgcmVzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gIH0sIHt9KSk7XG4gIFBhdGhJdGVtLmluamVjdChuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgICBvcGVyYXRvcnMgPSB7XG4gICAgICB1bml0ZToge1xuICAgICAgICAnMSc6IHRydWUsXG4gICAgICAgICcyJzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGludGVyc2VjdDoge1xuICAgICAgICAnMic6IHRydWVcbiAgICAgIH0sXG4gICAgICBzdWJ0cmFjdDoge1xuICAgICAgICAnMSc6IHRydWVcbiAgICAgIH0sXG4gICAgICBleGNsdWRlOiB7XG4gICAgICAgICcxJzogdHJ1ZSxcbiAgICAgICAgJy0xJzogdHJ1ZVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRQYXRocyhwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5fY2hpbGRyZW4gfHwgW3BhdGhdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVQYXRoKHBhdGgsIHJlc29sdmUpIHtcbiAgICAgIHZhciByZXMgPSBwYXRoLmNsb25lKGZhbHNlKS5yZWR1Y2Uoe1xuICAgICAgICBzaW1wbGlmeTogdHJ1ZVxuICAgICAgfSkudHJhbnNmb3JtKG51bGwsIHRydWUsIHRydWUpO1xuXG4gICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICB2YXIgcGF0aHMgPSBnZXRQYXRocyhyZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpXTtcblxuICAgICAgICAgIGlmICghcGF0aC5fY2xvc2VkICYmICFwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoMWUtMTIpO1xuICAgICAgICAgICAgcGF0aC5nZXRGaXJzdFNlZ21lbnQoKS5zZXRIYW5kbGVJbigwLCAwKTtcbiAgICAgICAgICAgIHBhdGguZ2V0TGFzdFNlZ21lbnQoKS5zZXRIYW5kbGVPdXQoMCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzID0gcmVzLnJlc29sdmVDcm9zc2luZ3MoKS5yZW9yaWVudChyZXMuZ2V0RmlsbFJ1bGUoKSA9PT0gJ25vbnplcm8nLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXN1bHQocGF0aHMsIHNpbXBsaWZ5LCBwYXRoMSwgcGF0aDIsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQ29tcG91bmRQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcbiAgICAgIHJlc3VsdC5hZGRDaGlsZHJlbihwYXRocywgdHJ1ZSk7XG4gICAgICByZXN1bHQgPSByZXN1bHQucmVkdWNlKHtcbiAgICAgICAgc2ltcGxpZnk6IHNpbXBsaWZ5XG4gICAgICB9KTtcblxuICAgICAgaWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLmluc2VydCA9PSBmYWxzZSkpIHtcbiAgICAgICAgcmVzdWx0Lmluc2VydEFib3ZlKHBhdGgyICYmIHBhdGgxLmlzU2libGluZyhwYXRoMikgJiYgcGF0aDEuZ2V0SW5kZXgoKSA8IHBhdGgyLmdldEluZGV4KCkgPyBwYXRoMiA6IHBhdGgxKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LmNvcHlBdHRyaWJ1dGVzKHBhdGgxLCB0cnVlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVySW50ZXJzZWN0aW9uKGludGVyKSB7XG4gICAgICByZXR1cm4gaW50ZXIuaGFzT3ZlcmxhcCgpIHx8IGludGVyLmlzQ3Jvc3NpbmcoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFjZUJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLnRyYWNlID09IGZhbHNlIHx8IG9wdGlvbnMuc3Ryb2tlKSAmJiAvXihzdWJ0cmFjdHxpbnRlcnNlY3QpJC8udGVzdChvcGVyYXRpb24pKSByZXR1cm4gc3BsaXRCb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0aW9uKTtcblxuICAgICAgdmFyIF9wYXRoMSA9IHByZXBhcmVQYXRoKHBhdGgxLCB0cnVlKSxcbiAgICAgICAgICBfcGF0aDIgPSBwYXRoMiAmJiBwYXRoMSAhPT0gcGF0aDIgJiYgcHJlcGFyZVBhdGgocGF0aDIsIHRydWUpLFxuICAgICAgICAgIG9wZXJhdG9yID0gb3BlcmF0b3JzW29wZXJhdGlvbl07XG5cbiAgICAgIG9wZXJhdG9yW29wZXJhdGlvbl0gPSB0cnVlO1xuICAgICAgaWYgKF9wYXRoMiAmJiAob3BlcmF0b3Iuc3VidHJhY3QgfHwgb3BlcmF0b3IuZXhjbHVkZSkgXiAoX3BhdGgyLmlzQ2xvY2t3aXNlKCkgXiBfcGF0aDEuaXNDbG9ja3dpc2UoKSkpIF9wYXRoMi5yZXZlcnNlKCk7XG5cbiAgICAgIHZhciBjcm9zc2luZ3MgPSBkaXZpZGVMb2NhdGlvbnMoQ3VydmVMb2NhdGlvbi5leHBhbmQoX3BhdGgxLmdldEludGVyc2VjdGlvbnMoX3BhdGgyLCBmaWx0ZXJJbnRlcnNlY3Rpb24pKSksXG4gICAgICAgICAgcGF0aHMxID0gZ2V0UGF0aHMoX3BhdGgxKSxcbiAgICAgICAgICBwYXRoczIgPSBfcGF0aDIgJiYgZ2V0UGF0aHMoX3BhdGgyKSxcbiAgICAgICAgICBzZWdtZW50cyA9IFtdLFxuICAgICAgICAgIGN1cnZlcyA9IFtdLFxuICAgICAgICAgIHBhdGhzO1xuXG4gICAgICBmdW5jdGlvbiBjb2xsZWN0UGF0aHMocGF0aHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICAgIEJhc2UucHVzaChzZWdtZW50cywgcGF0aC5fc2VnbWVudHMpO1xuICAgICAgICAgIEJhc2UucHVzaChjdXJ2ZXMsIHBhdGguZ2V0Q3VydmVzKCkpO1xuICAgICAgICAgIHBhdGguX292ZXJsYXBzT25seSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Q3VydmVzKGluZGljZXMpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGljZXMgJiYgaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsaXN0LnB1c2goY3VydmVzW2luZGljZXNbaV1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Jvc3NpbmdzLmxlbmd0aCkge1xuICAgICAgICBjb2xsZWN0UGF0aHMocGF0aHMxKTtcbiAgICAgICAgaWYgKHBhdGhzMikgY29sbGVjdFBhdGhzKHBhdGhzMik7XG4gICAgICAgIHZhciBjdXJ2ZXNWYWx1ZXMgPSBuZXcgQXJyYXkoY3VydmVzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY3VydmVzVmFsdWVzW2ldID0gY3VydmVzW2ldLmdldFZhbHVlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnZlQ29sbGlzaW9ucyA9IENvbGxpc2lvbkRldGVjdGlvbi5maW5kQ3VydmVCb3VuZHNDb2xsaXNpb25zKGN1cnZlc1ZhbHVlcywgY3VydmVzVmFsdWVzLCAwLCB0cnVlKTtcbiAgICAgICAgdmFyIGN1cnZlQ29sbGlzaW9uc01hcCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1cnZlID0gY3VydmVzW2ldLFxuICAgICAgICAgICAgICBpZCA9IGN1cnZlLl9wYXRoLl9pZCxcbiAgICAgICAgICAgICAgbWFwID0gY3VydmVDb2xsaXNpb25zTWFwW2lkXSA9IGN1cnZlQ29sbGlzaW9uc01hcFtpZF0gfHwge307XG4gICAgICAgICAgbWFwW2N1cnZlLmdldEluZGV4KCldID0ge1xuICAgICAgICAgICAgaG9yOiBnZXRDdXJ2ZXMoY3VydmVDb2xsaXNpb25zW2ldLmhvciksXG4gICAgICAgICAgICB2ZXI6IGdldEN1cnZlcyhjdXJ2ZUNvbGxpc2lvbnNbaV0udmVyKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNyb3NzaW5ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBwcm9wYWdhdGVXaW5kaW5nKGNyb3NzaW5nc1tpXS5fc2VnbWVudCwgX3BhdGgxLCBfcGF0aDIsIGN1cnZlQ29sbGlzaW9uc01hcCwgb3BlcmF0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldLFxuICAgICAgICAgICAgICBpbnRlciA9IHNlZ21lbnQuX2ludGVyc2VjdGlvbjtcblxuICAgICAgICAgIGlmICghc2VnbWVudC5fd2luZGluZykge1xuICAgICAgICAgICAgcHJvcGFnYXRlV2luZGluZyhzZWdtZW50LCBfcGF0aDEsIF9wYXRoMiwgY3VydmVDb2xsaXNpb25zTWFwLCBvcGVyYXRvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEoaW50ZXIgJiYgaW50ZXIuX292ZXJsYXApKSBzZWdtZW50Ll9wYXRoLl9vdmVybGFwc09ubHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGhzID0gdHJhY2VQYXRocyhzZWdtZW50cywgb3BlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aHMgPSByZW9yaWVudFBhdGhzKHBhdGhzMiA/IHBhdGhzMS5jb25jYXQocGF0aHMyKSA6IHBhdGhzMS5zbGljZSgpLCBmdW5jdGlvbiAodykge1xuICAgICAgICAgIHJldHVybiAhIW9wZXJhdG9yW3ddO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZVJlc3VsdChwYXRocywgdHJ1ZSwgcGF0aDEsIHBhdGgyLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxpdEJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pIHtcbiAgICAgIHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSksXG4gICAgICAgICAgX3BhdGgyID0gcHJlcGFyZVBhdGgocGF0aDIpLFxuICAgICAgICAgIGNyb3NzaW5ncyA9IF9wYXRoMS5nZXRJbnRlcnNlY3Rpb25zKF9wYXRoMiwgZmlsdGVySW50ZXJzZWN0aW9uKSxcbiAgICAgICAgICBzdWJ0cmFjdCA9IG9wZXJhdGlvbiA9PT0gJ3N1YnRyYWN0JyxcbiAgICAgICAgICBkaXZpZGUgPSBvcGVyYXRpb24gPT09ICdkaXZpZGUnLFxuICAgICAgICAgIGFkZGVkID0ge30sXG4gICAgICAgICAgcGF0aHMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gYWRkUGF0aChwYXRoKSB7XG4gICAgICAgIGlmICghYWRkZWRbcGF0aC5faWRdICYmIChkaXZpZGUgfHwgX3BhdGgyLmNvbnRhaW5zKHBhdGguZ2V0UG9pbnRBdChwYXRoLmdldExlbmd0aCgpIC8gMikpIF4gc3VidHJhY3QpKSB7XG4gICAgICAgICAgcGF0aHMudW5zaGlmdChwYXRoKTtcbiAgICAgICAgICByZXR1cm4gYWRkZWRbcGF0aC5faWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gY3Jvc3NpbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBwYXRoID0gY3Jvc3NpbmdzW2ldLnNwbGl0KCk7XG5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICBpZiAoYWRkUGF0aChwYXRoKSkgcGF0aC5nZXRGaXJzdFNlZ21lbnQoKS5zZXRIYW5kbGVJbigwLCAwKTtcblxuICAgICAgICAgIF9wYXRoMS5nZXRMYXN0U2VnbWVudCgpLnNldEhhbmRsZU91dCgwLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZGRQYXRoKF9wYXRoMSk7XG4gICAgICByZXR1cm4gY3JlYXRlUmVzdWx0KHBhdGhzLCBmYWxzZSwgcGF0aDEsIHBhdGgyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5rSW50ZXJzZWN0aW9ucyhmcm9tLCB0bykge1xuICAgICAgdmFyIHByZXYgPSBmcm9tO1xuXG4gICAgICB3aGlsZSAocHJldikge1xuICAgICAgICBpZiAocHJldiA9PT0gdG8pIHJldHVybjtcbiAgICAgICAgcHJldiA9IHByZXYuX3ByZXZpb3VzO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoZnJvbS5fbmV4dCAmJiBmcm9tLl9uZXh0ICE9PSB0bykgZnJvbSA9IGZyb20uX25leHQ7XG5cbiAgICAgIGlmICghZnJvbS5fbmV4dCkge1xuICAgICAgICB3aGlsZSAodG8uX3ByZXZpb3VzKSB0byA9IHRvLl9wcmV2aW91cztcblxuICAgICAgICBmcm9tLl9uZXh0ID0gdG87XG4gICAgICAgIHRvLl9wcmV2aW91cyA9IGZyb207XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJDdXJ2ZUhhbmRsZXMoY3VydmVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjdXJ2ZXNbaV0uY2xlYXJIYW5kbGVzKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVvcmllbnRQYXRocyhwYXRocywgaXNJbnNpZGUsIGNsb2Nrd2lzZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzICYmIHBhdGhzLmxlbmd0aDtcblxuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgbG9va3VwID0gQmFzZS5lYWNoKHBhdGhzLCBmdW5jdGlvbiAocGF0aCwgaSkge1xuICAgICAgICAgIHRoaXNbcGF0aC5faWRdID0ge1xuICAgICAgICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgICAgICAgd2luZGluZzogcGF0aC5pc0Nsb2Nrd2lzZSgpID8gMSA6IC0xLFxuICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB7fSksXG4gICAgICAgICAgICBzb3J0ZWQgPSBwYXRocy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYWJzKGIuZ2V0QXJlYSgpKSAtIGFicyhhLmdldEFyZWEoKSk7XG4gICAgICAgIH0pLFxuICAgICAgICAgICAgZmlyc3QgPSBzb3J0ZWRbMF07XG4gICAgICAgIHZhciBjb2xsaXNpb25zID0gQ29sbGlzaW9uRGV0ZWN0aW9uLmZpbmRJdGVtQm91bmRzQ29sbGlzaW9ucyhzb3J0ZWQsIG51bGwsIE51bWVyaWNhbC5HRU9NRVRSSUNfRVBTSUxPTik7XG4gICAgICAgIGlmIChjbG9ja3dpc2UgPT0gbnVsbCkgY2xvY2t3aXNlID0gZmlyc3QuaXNDbG9ja3dpc2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhdGgxID0gc29ydGVkW2ldLFxuICAgICAgICAgICAgICBlbnRyeTEgPSBsb29rdXBbcGF0aDEuX2lkXSxcbiAgICAgICAgICAgICAgY29udGFpbmVyV2luZGluZyA9IDAsXG4gICAgICAgICAgICAgIGluZGljZXMgPSBjb2xsaXNpb25zW2ldO1xuXG4gICAgICAgICAgaWYgKGluZGljZXMpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IG51bGw7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpbmRpY2VzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgIGlmIChpbmRpY2VzW2pdIDwgaSkge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnQgfHwgcGF0aDEuZ2V0SW50ZXJpb3JQb2ludCgpO1xuICAgICAgICAgICAgICAgIHZhciBwYXRoMiA9IHNvcnRlZFtpbmRpY2VzW2pdXTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXRoMi5jb250YWlucyhwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlbnRyeTIgPSBsb29rdXBbcGF0aDIuX2lkXTtcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpbmRpbmcgPSBlbnRyeTIud2luZGluZztcbiAgICAgICAgICAgICAgICAgIGVudHJ5MS53aW5kaW5nICs9IGNvbnRhaW5lcldpbmRpbmc7XG4gICAgICAgICAgICAgICAgICBlbnRyeTEuY29udGFpbmVyID0gZW50cnkyLmV4Y2x1ZGUgPyBlbnRyeTIuY29udGFpbmVyIDogcGF0aDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNJbnNpZGUoZW50cnkxLndpbmRpbmcpID09PSBpc0luc2lkZShjb250YWluZXJXaW5kaW5nKSkge1xuICAgICAgICAgICAgZW50cnkxLmV4Y2x1ZGUgPSB0cnVlO1xuICAgICAgICAgICAgcGF0aHNbZW50cnkxLmluZGV4XSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBlbnRyeTEuY29udGFpbmVyO1xuICAgICAgICAgICAgcGF0aDEuc2V0Q2xvY2t3aXNlKGNvbnRhaW5lciA/ICFjb250YWluZXIuaXNDbG9ja3dpc2UoKSA6IGNsb2Nrd2lzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRocztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXZpZGVMb2NhdGlvbnMobG9jYXRpb25zLCBpbmNsdWRlLCBjbGVhckxhdGVyKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IGluY2x1ZGUgJiYgW10sXG4gICAgICAgICAgdE1pbiA9IDFlLTgsXG4gICAgICAgICAgdE1heCA9IDEgLSB0TWluLFxuICAgICAgICAgIGNsZWFySGFuZGxlcyA9IGZhbHNlLFxuICAgICAgICAgIGNsZWFyQ3VydmVzID0gY2xlYXJMYXRlciB8fCBbXSxcbiAgICAgICAgICBjbGVhckxvb2t1cCA9IGNsZWFyTGF0ZXIgJiYge30sXG4gICAgICAgICAgcmVub3JtYWxpemVMb2NzLFxuICAgICAgICAgIHByZXZDdXJ2ZSxcbiAgICAgICAgICBwcmV2VGltZTtcblxuICAgICAgZnVuY3Rpb24gZ2V0SWQoY3VydmUpIHtcbiAgICAgICAgcmV0dXJuIGN1cnZlLl9wYXRoLl9pZCArICcuJyArIGN1cnZlLl9zZWdtZW50MS5faW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAoY2xlYXJMYXRlciAmJiBjbGVhckxhdGVyLmxlbmd0aCkgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY3VydmUgPSBjbGVhckxhdGVyW2ldO1xuICAgICAgICBpZiAoY3VydmUuX3BhdGgpIGNsZWFyTG9va3VwW2dldElkKGN1cnZlKV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gbG9jYXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBsb2MgPSBsb2NhdGlvbnNbaV0sXG4gICAgICAgICAgICB0aW1lID0gbG9jLl90aW1lLFxuICAgICAgICAgICAgb3JpZ1RpbWUgPSB0aW1lLFxuICAgICAgICAgICAgZXhjbHVkZSA9IGluY2x1ZGUgJiYgIWluY2x1ZGUobG9jKSxcbiAgICAgICAgICAgIGN1cnZlID0gbG9jLl9jdXJ2ZSxcbiAgICAgICAgICAgIHNlZ21lbnQ7XG5cbiAgICAgICAgaWYgKGN1cnZlKSB7XG4gICAgICAgICAgaWYgKGN1cnZlICE9PSBwcmV2Q3VydmUpIHtcbiAgICAgICAgICAgIGNsZWFySGFuZGxlcyA9ICFjdXJ2ZS5oYXNIYW5kbGVzKCkgfHwgY2xlYXJMb29rdXAgJiYgY2xlYXJMb29rdXBbZ2V0SWQoY3VydmUpXTtcbiAgICAgICAgICAgIHJlbm9ybWFsaXplTG9jcyA9IFtdO1xuICAgICAgICAgICAgcHJldlRpbWUgPSBudWxsO1xuICAgICAgICAgICAgcHJldkN1cnZlID0gY3VydmU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2VGltZSA+PSB0TWluKSB7XG4gICAgICAgICAgICB0aW1lIC89IHByZXZUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGNsdWRlKSB7XG4gICAgICAgICAgaWYgKHJlbm9ybWFsaXplTG9jcykgcmVub3JtYWxpemVMb2NzLnB1c2gobG9jKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmNsdWRlKSB7XG4gICAgICAgICAgcmVzdWx0cy51bnNoaWZ0KGxvYyk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2VGltZSA9IG9yaWdUaW1lO1xuXG4gICAgICAgIGlmICh0aW1lIDwgdE1pbikge1xuICAgICAgICAgIHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZSA+IHRNYXgpIHtcbiAgICAgICAgICBzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdDdXJ2ZSA9IGN1cnZlLmRpdmlkZUF0VGltZSh0aW1lLCB0cnVlKTtcbiAgICAgICAgICBpZiAoY2xlYXJIYW5kbGVzKSBjbGVhckN1cnZlcy5wdXNoKGN1cnZlLCBuZXdDdXJ2ZSk7XG4gICAgICAgICAgc2VnbWVudCA9IG5ld0N1cnZlLl9zZWdtZW50MTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSByZW5vcm1hbGl6ZUxvY3MubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIHZhciBsID0gcmVub3JtYWxpemVMb2NzW2pdO1xuICAgICAgICAgICAgbC5fdGltZSA9IChsLl90aW1lIC0gdGltZSkgLyAoMSAtIHRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvYy5fc2V0U2VnbWVudChzZWdtZW50KTtcblxuICAgICAgICB2YXIgaW50ZXIgPSBzZWdtZW50Ll9pbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICBkZXN0ID0gbG9jLl9pbnRlcnNlY3Rpb247XG5cbiAgICAgICAgaWYgKGludGVyKSB7XG4gICAgICAgICAgbGlua0ludGVyc2VjdGlvbnMoaW50ZXIsIGRlc3QpO1xuICAgICAgICAgIHZhciBvdGhlciA9IGludGVyO1xuXG4gICAgICAgICAgd2hpbGUgKG90aGVyKSB7XG4gICAgICAgICAgICBsaW5rSW50ZXJzZWN0aW9ucyhvdGhlci5faW50ZXJzZWN0aW9uLCBpbnRlcik7XG4gICAgICAgICAgICBvdGhlciA9IG90aGVyLl9uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50Ll9pbnRlcnNlY3Rpb24gPSBkZXN0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY2xlYXJMYXRlcikgY2xlYXJDdXJ2ZUhhbmRsZXMoY2xlYXJDdXJ2ZXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdHMgfHwgbG9jYXRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpbmRpbmcocG9pbnQsIGN1cnZlcywgZGlyLCBjbG9zZWQsIGRvbnRGbGlwKSB7XG4gICAgICB2YXIgY3VydmVzTGlzdCA9IEFycmF5LmlzQXJyYXkoY3VydmVzKSA/IGN1cnZlcyA6IGN1cnZlc1tkaXIgPyAnaG9yJyA6ICd2ZXInXTtcbiAgICAgIHZhciBpYSA9IGRpciA/IDEgOiAwLFxuICAgICAgICAgIGlvID0gaWEgXiAxLFxuICAgICAgICAgIHB2ID0gW3BvaW50LngsIHBvaW50LnldLFxuICAgICAgICAgIHBhID0gcHZbaWFdLFxuICAgICAgICAgIHBvID0gcHZbaW9dLFxuICAgICAgICAgIHdpbmRpbmdFcHNpbG9uID0gMWUtOSxcbiAgICAgICAgICBxdWFsaXR5RXBzaWxvbiA9IDFlLTYsXG4gICAgICAgICAgcGFMID0gcGEgLSB3aW5kaW5nRXBzaWxvbixcbiAgICAgICAgICBwYVIgPSBwYSArIHdpbmRpbmdFcHNpbG9uLFxuICAgICAgICAgIHdpbmRpbmdMID0gMCxcbiAgICAgICAgICB3aW5kaW5nUiA9IDAsXG4gICAgICAgICAgcGF0aFdpbmRpbmdMID0gMCxcbiAgICAgICAgICBwYXRoV2luZGluZ1IgPSAwLFxuICAgICAgICAgIG9uUGF0aCA9IGZhbHNlLFxuICAgICAgICAgIG9uQW55UGF0aCA9IGZhbHNlLFxuICAgICAgICAgIHF1YWxpdHkgPSAxLFxuICAgICAgICAgIHJvb3RzID0gW10sXG4gICAgICAgICAgdlByZXYsXG4gICAgICAgICAgdkNsb3NlO1xuXG4gICAgICBmdW5jdGlvbiBhZGRXaW5kaW5nKHYpIHtcbiAgICAgICAgdmFyIG8wID0gdltpbyArIDBdLFxuICAgICAgICAgICAgbzMgPSB2W2lvICsgNl07XG5cbiAgICAgICAgaWYgKHBvIDwgbWluKG8wLCBvMykgfHwgcG8gPiBtYXgobzAsIG8zKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhMCA9IHZbaWEgKyAwXSxcbiAgICAgICAgICAgIGExID0gdltpYSArIDJdLFxuICAgICAgICAgICAgYTIgPSB2W2lhICsgNF0sXG4gICAgICAgICAgICBhMyA9IHZbaWEgKyA2XTtcblxuICAgICAgICBpZiAobzAgPT09IG8zKSB7XG4gICAgICAgICAgaWYgKGEwIDwgcGFSICYmIGEzID4gcGFMIHx8IGEzIDwgcGFSICYmIGEwID4gcGFMKSB7XG4gICAgICAgICAgICBvblBhdGggPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gcG8gPT09IG8wID8gMCA6IHBvID09PSBvMyA/IDEgOiBwYUwgPiBtYXgoYTAsIGExLCBhMiwgYTMpIHx8IHBhUiA8IG1pbihhMCwgYTEsIGEyLCBhMykgPyAxIDogQ3VydmUuc29sdmVDdWJpYyh2LCBpbywgcG8sIHJvb3RzLCAwLCAxKSA+IDAgPyByb290c1swXSA6IDEsXG4gICAgICAgICAgICBhID0gdCA9PT0gMCA/IGEwIDogdCA9PT0gMSA/IGEzIDogQ3VydmUuZ2V0UG9pbnQodiwgdClbZGlyID8gJ3knIDogJ3gnXSxcbiAgICAgICAgICAgIHdpbmRpbmcgPSBvMCA+IG8zID8gMSA6IC0xLFxuICAgICAgICAgICAgd2luZGluZ1ByZXYgPSB2UHJldltpb10gPiB2UHJldltpbyArIDZdID8gMSA6IC0xLFxuICAgICAgICAgICAgYTNQcmV2ID0gdlByZXZbaWEgKyA2XTtcblxuICAgICAgICBpZiAocG8gIT09IG8wKSB7XG4gICAgICAgICAgaWYgKGEgPCBwYUwpIHtcbiAgICAgICAgICAgIHBhdGhXaW5kaW5nTCArPSB3aW5kaW5nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYSA+IHBhUikge1xuICAgICAgICAgICAgcGF0aFdpbmRpbmdSICs9IHdpbmRpbmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uUGF0aCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGEgPiBwYSAtIHF1YWxpdHlFcHNpbG9uICYmIGEgPCBwYSArIHF1YWxpdHlFcHNpbG9uKSBxdWFsaXR5IC89IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHdpbmRpbmcgIT09IHdpbmRpbmdQcmV2KSB7XG4gICAgICAgICAgICBpZiAoYTAgPCBwYUwpIHtcbiAgICAgICAgICAgICAgcGF0aFdpbmRpbmdMICs9IHdpbmRpbmc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEwID4gcGFSKSB7XG4gICAgICAgICAgICAgIHBhdGhXaW5kaW5nUiArPSB3aW5kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYTAgIT0gYTNQcmV2KSB7XG4gICAgICAgICAgICBpZiAoYTNQcmV2IDwgcGFSICYmIGEgPiBwYVIpIHtcbiAgICAgICAgICAgICAgcGF0aFdpbmRpbmdSICs9IHdpbmRpbmc7XG4gICAgICAgICAgICAgIG9uUGF0aCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEzUHJldiA+IHBhTCAmJiBhIDwgcGFMKSB7XG4gICAgICAgICAgICAgIHBhdGhXaW5kaW5nTCArPSB3aW5kaW5nO1xuICAgICAgICAgICAgICBvblBhdGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHF1YWxpdHkgLz0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZQcmV2ID0gdjtcbiAgICAgICAgcmV0dXJuICFkb250RmxpcCAmJiBhID4gcGFMICYmIGEgPCBwYVIgJiYgQ3VydmUuZ2V0VGFuZ2VudCh2LCB0KVtkaXIgPyAneCcgOiAneSddID09PSAwICYmIGdldFdpbmRpbmcocG9pbnQsIGN1cnZlcywgIWRpciwgY2xvc2VkLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlQ3VydmUodikge1xuICAgICAgICB2YXIgbzAgPSB2W2lvICsgMF0sXG4gICAgICAgICAgICBvMSA9IHZbaW8gKyAyXSxcbiAgICAgICAgICAgIG8yID0gdltpbyArIDRdLFxuICAgICAgICAgICAgbzMgPSB2W2lvICsgNl07XG5cbiAgICAgICAgaWYgKHBvIDw9IG1heChvMCwgbzEsIG8yLCBvMykgJiYgcG8gPj0gbWluKG8wLCBvMSwgbzIsIG8zKSkge1xuICAgICAgICAgIHZhciBhMCA9IHZbaWEgKyAwXSxcbiAgICAgICAgICAgICAgYTEgPSB2W2lhICsgMl0sXG4gICAgICAgICAgICAgIGEyID0gdltpYSArIDRdLFxuICAgICAgICAgICAgICBhMyA9IHZbaWEgKyA2XSxcbiAgICAgICAgICAgICAgbW9ub0N1cnZlcyA9IHBhTCA+IG1heChhMCwgYTEsIGEyLCBhMykgfHwgcGFSIDwgbWluKGEwLCBhMSwgYTIsIGEzKSA/IFt2XSA6IEN1cnZlLmdldE1vbm9DdXJ2ZXModiwgZGlyKSxcbiAgICAgICAgICAgICAgcmVzO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBtb25vQ3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlcyA9IGFkZFdpbmRpbmcobW9ub0N1cnZlc1tpXSkpIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnZlID0gY3VydmVzTGlzdFtpXSxcbiAgICAgICAgICAgIHBhdGggPSBjdXJ2ZS5fcGF0aCxcbiAgICAgICAgICAgIHYgPSBjdXJ2ZS5nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAgIHJlcztcblxuICAgICAgICBpZiAoIWkgfHwgY3VydmVzTGlzdFtpIC0gMV0uX3BhdGggIT09IHBhdGgpIHtcbiAgICAgICAgICB2UHJldiA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoIXBhdGguX2Nsb3NlZCkge1xuICAgICAgICAgICAgdkNsb3NlID0gQ3VydmUuZ2V0VmFsdWVzKHBhdGguZ2V0TGFzdEN1cnZlKCkuZ2V0U2VnbWVudDIoKSwgY3VydmUuZ2V0U2VnbWVudDEoKSwgbnVsbCwgIWNsb3NlZCk7XG5cbiAgICAgICAgICAgIGlmICh2Q2xvc2VbaW9dICE9PSB2Q2xvc2VbaW8gKyA2XSkge1xuICAgICAgICAgICAgICB2UHJldiA9IHZDbG9zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXZQcmV2KSB7XG4gICAgICAgICAgICB2UHJldiA9IHY7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHBhdGguZ2V0TGFzdEN1cnZlKCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIHByZXYgIT09IGN1cnZlKSB7XG4gICAgICAgICAgICAgIHZhciB2MiA9IHByZXYuZ2V0VmFsdWVzKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHYyW2lvXSAhPT0gdjJbaW8gKyA2XSkge1xuICAgICAgICAgICAgICAgIHZQcmV2ID0gdjI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwcmV2ID0gcHJldi5nZXRQcmV2aW91cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXMgPSBoYW5kbGVDdXJ2ZSh2KSkgcmV0dXJuIHJlcztcblxuICAgICAgICBpZiAoaSArIDEgPT09IGwgfHwgY3VydmVzTGlzdFtpICsgMV0uX3BhdGggIT09IHBhdGgpIHtcbiAgICAgICAgICBpZiAodkNsb3NlICYmIChyZXMgPSBoYW5kbGVDdXJ2ZSh2Q2xvc2UpKSkgcmV0dXJuIHJlcztcblxuICAgICAgICAgIGlmIChvblBhdGggJiYgIXBhdGhXaW5kaW5nTCAmJiAhcGF0aFdpbmRpbmdSKSB7XG4gICAgICAgICAgICBwYXRoV2luZGluZ0wgPSBwYXRoV2luZGluZ1IgPSBwYXRoLmlzQ2xvY2t3aXNlKGNsb3NlZCkgXiBkaXIgPyAxIDogLTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2luZGluZ0wgKz0gcGF0aFdpbmRpbmdMO1xuICAgICAgICAgIHdpbmRpbmdSICs9IHBhdGhXaW5kaW5nUjtcbiAgICAgICAgICBwYXRoV2luZGluZ0wgPSBwYXRoV2luZGluZ1IgPSAwO1xuXG4gICAgICAgICAgaWYgKG9uUGF0aCkge1xuICAgICAgICAgICAgb25BbnlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uUGF0aCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZDbG9zZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2luZGluZ0wgPSBhYnMod2luZGluZ0wpO1xuICAgICAgd2luZGluZ1IgPSBhYnMod2luZGluZ1IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2luZGluZzogbWF4KHdpbmRpbmdMLCB3aW5kaW5nUiksXG4gICAgICAgIHdpbmRpbmdMOiB3aW5kaW5nTCxcbiAgICAgICAgd2luZGluZ1I6IHdpbmRpbmdSLFxuICAgICAgICBxdWFsaXR5OiBxdWFsaXR5LFxuICAgICAgICBvblBhdGg6IG9uQW55UGF0aFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVXaW5kaW5nKHNlZ21lbnQsIHBhdGgxLCBwYXRoMiwgY3VydmVDb2xsaXNpb25zTWFwLCBvcGVyYXRvcikge1xuICAgICAgdmFyIGNoYWluID0gW10sXG4gICAgICAgICAgc3RhcnQgPSBzZWdtZW50LFxuICAgICAgICAgIHRvdGFsTGVuZ3RoID0gMCxcbiAgICAgICAgICB3aW5kaW5nO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IHNlZ21lbnQuZ2V0Q3VydmUoKTtcblxuICAgICAgICBpZiAoY3VydmUpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gY3VydmUuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgY2hhaW4ucHVzaCh7XG4gICAgICAgICAgICBzZWdtZW50OiBzZWdtZW50LFxuICAgICAgICAgICAgY3VydmU6IGN1cnZlLFxuICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0b3RhbExlbmd0aCArPSBsZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBzZWdtZW50ID0gc2VnbWVudC5nZXROZXh0KCk7XG4gICAgICB9IHdoaWxlIChzZWdtZW50ICYmICFzZWdtZW50Ll9pbnRlcnNlY3Rpb24gJiYgc2VnbWVudCAhPT0gc3RhcnQpO1xuXG4gICAgICB2YXIgb2Zmc2V0cyA9IFswLjUsIDAuMjUsIDAuNzVdLFxuICAgICAgICAgIHdpbmRpbmcgPSB7XG4gICAgICAgIHdpbmRpbmc6IDAsXG4gICAgICAgIHF1YWxpdHk6IC0xXG4gICAgICB9LFxuICAgICAgICAgIHRNaW4gPSAxZS0zLFxuICAgICAgICAgIHRNYXggPSAxIC0gdE1pbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aCAmJiB3aW5kaW5nLnF1YWxpdHkgPCAwLjU7IGkrKykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdG90YWxMZW5ndGggKiBvZmZzZXRzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gY2hhaW4ubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gY2hhaW5bal0sXG4gICAgICAgICAgICAgIGN1cnZlTGVuZ3RoID0gZW50cnkubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aCA8PSBjdXJ2ZUxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGN1cnZlID0gZW50cnkuY3VydmUsXG4gICAgICAgICAgICAgICAgcGF0aCA9IGN1cnZlLl9wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGguX3BhcmVudCxcbiAgICAgICAgICAgICAgICBvcGVyYW5kID0gcGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoID8gcGFyZW50IDogcGF0aCxcbiAgICAgICAgICAgICAgICB0ID0gTnVtZXJpY2FsLmNsYW1wKGN1cnZlLmdldFRpbWVBdChsZW5ndGgpLCB0TWluLCB0TWF4KSxcbiAgICAgICAgICAgICAgICBwdCA9IGN1cnZlLmdldFBvaW50QXRUaW1lKHQpLFxuICAgICAgICAgICAgICAgIGRpciA9IGFicyhjdXJ2ZS5nZXRUYW5nZW50QXRUaW1lKHQpLnkpIDwgTWF0aC5TUVJUMV8yO1xuICAgICAgICAgICAgdmFyIHdpbmQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAob3BlcmF0b3Iuc3VidHJhY3QgJiYgcGF0aDIpIHtcbiAgICAgICAgICAgICAgdmFyIG90aGVyUGF0aCA9IG9wZXJhbmQgPT09IHBhdGgxID8gcGF0aDIgOiBwYXRoMSxcbiAgICAgICAgICAgICAgICAgIHBhdGhXaW5kaW5nID0gb3RoZXJQYXRoLl9nZXRXaW5kaW5nKHB0LCBkaXIsIHRydWUpO1xuXG4gICAgICAgICAgICAgIGlmIChvcGVyYW5kID09PSBwYXRoMSAmJiBwYXRoV2luZGluZy53aW5kaW5nIHx8IG9wZXJhbmQgPT09IHBhdGgyICYmICFwYXRoV2luZGluZy53aW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhXaW5kaW5nLnF1YWxpdHkgPCAxKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgd2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgcXVhbGl0eTogMVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2luZCA9IHdpbmQgfHwgZ2V0V2luZGluZyhwdCwgY3VydmVDb2xsaXNpb25zTWFwW3BhdGguX2lkXVtjdXJ2ZS5nZXRJbmRleCgpXSwgZGlyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICh3aW5kLnF1YWxpdHkgPiB3aW5kaW5nLnF1YWxpdHkpIHdpbmRpbmcgPSB3aW5kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVuZ3RoIC09IGN1cnZlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSBjaGFpbi5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBjaGFpbltqXS5zZWdtZW50Ll93aW5kaW5nID0gd2luZGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFjZVBhdGhzKHNlZ21lbnRzLCBvcGVyYXRvcikge1xuICAgICAgdmFyIHBhdGhzID0gW10sXG4gICAgICAgICAgc3RhcnRzO1xuXG4gICAgICBmdW5jdGlvbiBpc1ZhbGlkKHNlZykge1xuICAgICAgICB2YXIgd2luZGluZztcbiAgICAgICAgcmV0dXJuICEhKHNlZyAmJiAhc2VnLl92aXNpdGVkICYmICghb3BlcmF0b3IgfHwgb3BlcmF0b3JbKHdpbmRpbmcgPSBzZWcuX3dpbmRpbmcgfHwge30pLndpbmRpbmddICYmICEob3BlcmF0b3IudW5pdGUgJiYgd2luZGluZy53aW5kaW5nID09PSAyICYmIHdpbmRpbmcud2luZGluZ0wgJiYgd2luZGluZy53aW5kaW5nUikpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNTdGFydChzZWcpIHtcbiAgICAgICAgaWYgKHNlZykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNlZyA9PT0gc3RhcnRzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZpc2l0UGF0aChwYXRoKSB7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgc2VnbWVudHNbaV0uX3Zpc2l0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldENyb3NzaW5nU2VnbWVudHMoc2VnbWVudCwgY29sbGVjdFN0YXJ0cykge1xuICAgICAgICB2YXIgaW50ZXIgPSBzZWdtZW50Ll9pbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICBzdGFydCA9IGludGVyLFxuICAgICAgICAgICAgY3Jvc3NpbmdzID0gW107XG4gICAgICAgIGlmIChjb2xsZWN0U3RhcnRzKSBzdGFydHMgPSBbc2VnbWVudF07XG5cbiAgICAgICAgZnVuY3Rpb24gY29sbGVjdChpbnRlciwgZW5kKSB7XG4gICAgICAgICAgd2hpbGUgKGludGVyICYmIGludGVyICE9PSBlbmQpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGludGVyLl9zZWdtZW50LFxuICAgICAgICAgICAgICAgIHBhdGggPSBvdGhlciAmJiBvdGhlci5fcGF0aDtcblxuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgdmFyIG5leHQgPSBvdGhlci5nZXROZXh0KCkgfHwgcGF0aC5nZXRGaXJzdFNlZ21lbnQoKSxcbiAgICAgICAgICAgICAgICAgIG5leHRJbnRlciA9IG5leHQuX2ludGVyc2VjdGlvbjtcblxuICAgICAgICAgICAgICBpZiAob3RoZXIgIT09IHNlZ21lbnQgJiYgKGlzU3RhcnQob3RoZXIpIHx8IGlzU3RhcnQobmV4dCkgfHwgbmV4dCAmJiBpc1ZhbGlkKG90aGVyKSAmJiAoaXNWYWxpZChuZXh0KSB8fCBuZXh0SW50ZXIgJiYgaXNWYWxpZChuZXh0SW50ZXIuX3NlZ21lbnQpKSkpIHtcbiAgICAgICAgICAgICAgICBjcm9zc2luZ3MucHVzaChvdGhlcik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29sbGVjdFN0YXJ0cykgc3RhcnRzLnB1c2gob3RoZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnRlciA9IGludGVyLl9uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnRlcikge1xuICAgICAgICAgIGNvbGxlY3QoaW50ZXIpO1xuXG4gICAgICAgICAgd2hpbGUgKGludGVyICYmIGludGVyLl9wcmV2aW91cykgaW50ZXIgPSBpbnRlci5fcHJldmlvdXM7XG5cbiAgICAgICAgICBjb2xsZWN0KGludGVyLCBzdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3Jvc3NpbmdzO1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50cy5zb3J0KGZ1bmN0aW9uIChzZWcxLCBzZWcyKSB7XG4gICAgICAgIHZhciBpbnRlcjEgPSBzZWcxLl9pbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICBpbnRlcjIgPSBzZWcyLl9pbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICBvdmVyMSA9ICEhKGludGVyMSAmJiBpbnRlcjEuX292ZXJsYXApLFxuICAgICAgICAgICAgb3ZlcjIgPSAhIShpbnRlcjIgJiYgaW50ZXIyLl9vdmVybGFwKSxcbiAgICAgICAgICAgIHBhdGgxID0gc2VnMS5fcGF0aCxcbiAgICAgICAgICAgIHBhdGgyID0gc2VnMi5fcGF0aDtcbiAgICAgICAgcmV0dXJuIG92ZXIxIF4gb3ZlcjIgPyBvdmVyMSA/IDEgOiAtMSA6ICFpbnRlcjEgXiAhaW50ZXIyID8gaW50ZXIxID8gMSA6IC0xIDogcGF0aDEgIT09IHBhdGgyID8gcGF0aDEuX2lkIC0gcGF0aDIuX2lkIDogc2VnMS5faW5kZXggLSBzZWcyLl9pbmRleDtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgc2VnID0gc2VnbWVudHNbaV0sXG4gICAgICAgICAgICB2YWxpZCA9IGlzVmFsaWQoc2VnKSxcbiAgICAgICAgICAgIHBhdGggPSBudWxsLFxuICAgICAgICAgICAgZmluaXNoZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGNsb3NlZCA9IHRydWUsXG4gICAgICAgICAgICBicmFuY2hlcyA9IFtdLFxuICAgICAgICAgICAgYnJhbmNoLFxuICAgICAgICAgICAgdmlzaXRlZCxcbiAgICAgICAgICAgIGhhbmRsZUluO1xuXG4gICAgICAgIGlmICh2YWxpZCAmJiBzZWcuX3BhdGguX292ZXJsYXBzT25seSkge1xuICAgICAgICAgIHZhciBwYXRoMSA9IHNlZy5fcGF0aCxcbiAgICAgICAgICAgICAgcGF0aDIgPSBzZWcuX2ludGVyc2VjdGlvbi5fc2VnbWVudC5fcGF0aDtcblxuICAgICAgICAgIGlmIChwYXRoMS5jb21wYXJlKHBhdGgyKSkge1xuICAgICAgICAgICAgaWYgKHBhdGgxLmdldEFyZWEoKSkgcGF0aHMucHVzaChwYXRoMS5jbG9uZShmYWxzZSkpO1xuICAgICAgICAgICAgdmlzaXRQYXRoKHBhdGgxKTtcbiAgICAgICAgICAgIHZpc2l0UGF0aChwYXRoMik7XG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh2YWxpZCkge1xuICAgICAgICAgIHZhciBmaXJzdCA9ICFwYXRoLFxuICAgICAgICAgICAgICBjcm9zc2luZ3MgPSBnZXRDcm9zc2luZ1NlZ21lbnRzKHNlZywgZmlyc3QpLFxuICAgICAgICAgICAgICBvdGhlciA9IGNyb3NzaW5ncy5zaGlmdCgpLFxuICAgICAgICAgICAgICBmaW5pc2hlZCA9ICFmaXJzdCAmJiAoaXNTdGFydChzZWcpIHx8IGlzU3RhcnQob3RoZXIpKSxcbiAgICAgICAgICAgICAgY3Jvc3MgPSAhZmluaXNoZWQgJiYgb3RoZXI7XG5cbiAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG4gICAgICAgICAgICBicmFuY2ggPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgaWYgKHNlZy5pc0ZpcnN0KCkgfHwgc2VnLmlzTGFzdCgpKSBjbG9zZWQgPSBzZWcuX3BhdGguX2Nsb3NlZDtcbiAgICAgICAgICAgIHNlZy5fdmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3Jvc3MgJiYgYnJhbmNoKSB7XG4gICAgICAgICAgICBicmFuY2hlcy5wdXNoKGJyYW5jaCk7XG4gICAgICAgICAgICBicmFuY2ggPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYnJhbmNoKSB7XG4gICAgICAgICAgICBpZiAoY3Jvc3MpIGNyb3NzaW5ncy5wdXNoKHNlZyk7XG4gICAgICAgICAgICBicmFuY2ggPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwYXRoLl9zZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgIGNyb3NzaW5nczogY3Jvc3NpbmdzLFxuICAgICAgICAgICAgICB2aXNpdGVkOiB2aXNpdGVkID0gW10sXG4gICAgICAgICAgICAgIGhhbmRsZUluOiBoYW5kbGVJblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3Jvc3MpIHNlZyA9IG90aGVyO1xuXG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKHNlZykpIHtcbiAgICAgICAgICAgIHBhdGgucmVtb3ZlU2VnbWVudHMoYnJhbmNoLnN0YXJ0KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSB2aXNpdGVkLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICB2aXNpdGVkW2pdLl92aXNpdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZpc2l0ZWQubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzZWcgPSBicmFuY2ggJiYgYnJhbmNoLmNyb3NzaW5ncy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgIGlmICghc2VnIHx8ICFzZWcuX3BhdGgpIHtcbiAgICAgICAgICAgICAgICBzZWcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyYW5jaCA9IGJyYW5jaGVzLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaCkge1xuICAgICAgICAgICAgICAgICAgdmlzaXRlZCA9IGJyYW5jaC52aXNpdGVkO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlSW4gPSBicmFuY2guaGFuZGxlSW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChicmFuY2ggJiYgIWlzVmFsaWQoc2VnKSk7XG5cbiAgICAgICAgICAgIGlmICghc2VnKSBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV4dCA9IHNlZy5nZXROZXh0KCk7XG4gICAgICAgICAgcGF0aC5hZGQobmV3IFNlZ21lbnQoc2VnLl9wb2ludCwgaGFuZGxlSW4sIG5leHQgJiYgc2VnLl9oYW5kbGVPdXQpKTtcbiAgICAgICAgICBzZWcuX3Zpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgIHZpc2l0ZWQucHVzaChzZWcpO1xuICAgICAgICAgIHNlZyA9IG5leHQgfHwgc2VnLl9wYXRoLmdldEZpcnN0U2VnbWVudCgpO1xuICAgICAgICAgIGhhbmRsZUluID0gbmV4dCAmJiBuZXh0Ll9oYW5kbGVJbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICAgIHBhdGguZ2V0Rmlyc3RTZWdtZW50KCkuc2V0SGFuZGxlSW4oaGFuZGxlSW4pO1xuICAgICAgICAgICAgcGF0aC5zZXRDbG9zZWQoY2xvc2VkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aC5nZXRBcmVhKCkgIT09IDApIHtcbiAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRocztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgX2dldFdpbmRpbmc6IGZ1bmN0aW9uIChwb2ludCwgZGlyLCBjbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuIGdldFdpbmRpbmcocG9pbnQsIHRoaXMuZ2V0Q3VydmVzKCksIGRpciwgY2xvc2VkKTtcbiAgICAgIH0sXG4gICAgICB1bml0ZTogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlQm9vbGVhbih0aGlzLCBwYXRoLCAndW5pdGUnLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0cmFjZUJvb2xlYW4odGhpcywgcGF0aCwgJ2ludGVyc2VjdCcsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHJhY2VCb29sZWFuKHRoaXMsIHBhdGgsICdzdWJ0cmFjdCcsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0cmFjZUJvb2xlYW4odGhpcywgcGF0aCwgJ2V4Y2x1ZGUnLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBkaXZpZGU6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zICYmIChvcHRpb25zLnRyYWNlID09IGZhbHNlIHx8IG9wdGlvbnMuc3Ryb2tlKSA/IHNwbGl0Qm9vbGVhbih0aGlzLCBwYXRoLCAnZGl2aWRlJykgOiBjcmVhdGVSZXN1bHQoW3RoaXMuc3VidHJhY3QocGF0aCwgb3B0aW9ucyksIHRoaXMuaW50ZXJzZWN0KHBhdGgsIG9wdGlvbnMpXSwgdHJ1ZSwgdGhpcywgcGF0aCwgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgcmVzb2x2ZUNyb3NzaW5nczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICAgIHBhdGhzID0gY2hpbGRyZW4gfHwgW3RoaXNdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhc092ZXJsYXAoc2VnLCBwYXRoKSB7XG4gICAgICAgICAgdmFyIGludGVyID0gc2VnICYmIHNlZy5faW50ZXJzZWN0aW9uO1xuICAgICAgICAgIHJldHVybiBpbnRlciAmJiBpbnRlci5fb3ZlcmxhcCAmJiBpbnRlci5fcGF0aCA9PT0gcGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNPdmVybGFwcyA9IGZhbHNlLFxuICAgICAgICAgICAgaGFzQ3Jvc3NpbmdzID0gZmFsc2UsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zID0gdGhpcy5nZXRJbnRlcnNlY3Rpb25zKG51bGwsIGZ1bmN0aW9uIChpbnRlcikge1xuICAgICAgICAgIHJldHVybiBpbnRlci5oYXNPdmVybGFwKCkgJiYgKGhhc092ZXJsYXBzID0gdHJ1ZSkgfHwgaW50ZXIuaXNDcm9zc2luZygpICYmIChoYXNDcm9zc2luZ3MgPSB0cnVlKTtcbiAgICAgICAgfSksXG4gICAgICAgICAgICBjbGVhckN1cnZlcyA9IGhhc092ZXJsYXBzICYmIGhhc0Nyb3NzaW5ncyAmJiBbXTtcbiAgICAgICAgaW50ZXJzZWN0aW9ucyA9IEN1cnZlTG9jYXRpb24uZXhwYW5kKGludGVyc2VjdGlvbnMpO1xuXG4gICAgICAgIGlmIChoYXNPdmVybGFwcykge1xuICAgICAgICAgIHZhciBvdmVybGFwcyA9IGRpdmlkZUxvY2F0aW9ucyhpbnRlcnNlY3Rpb25zLCBmdW5jdGlvbiAoaW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlci5oYXNPdmVybGFwKCk7XG4gICAgICAgICAgfSwgY2xlYXJDdXJ2ZXMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcCA9IG92ZXJsYXBzW2ldLFxuICAgICAgICAgICAgICAgIHBhdGggPSBvdmVybGFwLl9wYXRoLFxuICAgICAgICAgICAgICAgIHNlZyA9IG92ZXJsYXAuX3NlZ21lbnQsXG4gICAgICAgICAgICAgICAgcHJldiA9IHNlZy5nZXRQcmV2aW91cygpLFxuICAgICAgICAgICAgICAgIG5leHQgPSBzZWcuZ2V0TmV4dCgpO1xuXG4gICAgICAgICAgICBpZiAoaGFzT3ZlcmxhcChwcmV2LCBwYXRoKSAmJiBoYXNPdmVybGFwKG5leHQsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHNlZy5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICBwcmV2Ll9oYW5kbGVPdXQuX3NldCgwLCAwKTtcblxuICAgICAgICAgICAgICBuZXh0Ll9oYW5kbGVJbi5fc2V0KDAsIDApO1xuXG4gICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBzZWcgJiYgIXByZXYuZ2V0Q3VydmUoKS5oYXNMZW5ndGgoKSkge1xuICAgICAgICAgICAgICAgIG5leHQuX2hhbmRsZUluLnNldChwcmV2Ll9oYW5kbGVJbik7XG5cbiAgICAgICAgICAgICAgICBwcmV2LnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0Nyb3NzaW5ncykge1xuICAgICAgICAgIGRpdmlkZUxvY2F0aW9ucyhpbnRlcnNlY3Rpb25zLCBoYXNPdmVybGFwcyAmJiBmdW5jdGlvbiAoaW50ZXIpIHtcbiAgICAgICAgICAgIHZhciBjdXJ2ZTEgPSBpbnRlci5nZXRDdXJ2ZSgpLFxuICAgICAgICAgICAgICAgIHNlZzEgPSBpbnRlci5nZXRTZWdtZW50KCksXG4gICAgICAgICAgICAgICAgb3RoZXIgPSBpbnRlci5faW50ZXJzZWN0aW9uLFxuICAgICAgICAgICAgICAgIGN1cnZlMiA9IG90aGVyLl9jdXJ2ZSxcbiAgICAgICAgICAgICAgICBzZWcyID0gb3RoZXIuX3NlZ21lbnQ7XG4gICAgICAgICAgICBpZiAoY3VydmUxICYmIGN1cnZlMiAmJiBjdXJ2ZTEuX3BhdGggJiYgY3VydmUyLl9wYXRoKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzZWcxKSBzZWcxLl9pbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNlZzIpIHNlZzIuX2ludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgICAgfSwgY2xlYXJDdXJ2ZXMpO1xuICAgICAgICAgIGlmIChjbGVhckN1cnZlcykgY2xlYXJDdXJ2ZUhhbmRsZXMoY2xlYXJDdXJ2ZXMpO1xuICAgICAgICAgIHBhdGhzID0gdHJhY2VQYXRocyhCYXNlLmVhY2gocGF0aHMsIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICBCYXNlLnB1c2godGhpcywgcGF0aC5fc2VnbWVudHMpO1xuICAgICAgICAgIH0sIFtdKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICBpZiAobGVuZ3RoID4gMSAmJiBjaGlsZHJlbikge1xuICAgICAgICAgIGlmIChwYXRocyAhPT0gY2hpbGRyZW4pIHRoaXMuc2V0Q2hpbGRyZW4ocGF0aHMpO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gMSAmJiAhY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAocGF0aHNbMF0gIT09IHRoaXMpIHRoaXMuc2V0U2VnbWVudHMocGF0aHNbMF0ucmVtb3ZlU2VnbWVudHMoKSk7XG4gICAgICAgICAgaXRlbSA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICBpdGVtID0gbmV3IENvbXBvdW5kUGF0aChJdGVtLk5PX0lOU0VSVCk7XG4gICAgICAgICAgaXRlbS5hZGRDaGlsZHJlbihwYXRocyk7XG4gICAgICAgICAgaXRlbSA9IGl0ZW0ucmVkdWNlKCk7XG4gICAgICAgICAgaXRlbS5jb3B5QXR0cmlidXRlcyh0aGlzKTtcbiAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9LFxuICAgICAgcmVvcmllbnQ6IGZ1bmN0aW9uIChub25aZXJvLCBjbG9ja3dpc2UpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuc2V0Q2hpbGRyZW4ocmVvcmllbnRQYXRocyh0aGlzLnJlbW92ZUNoaWxkcmVuKCksIGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICByZXR1cm4gISEobm9uWmVybyA/IHcgOiB3ICYgMSk7XG4gICAgICAgICAgfSwgY2xvY2t3aXNlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnNldENsb2Nrd2lzZShjbG9ja3dpc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZ2V0SW50ZXJpb3JQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcbiAgICAgICAgICAgIHBvaW50ID0gYm91bmRzLmdldENlbnRlcih0cnVlKTtcblxuICAgICAgICBpZiAoIXRoaXMuY29udGFpbnMocG9pbnQpKSB7XG4gICAgICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG4gICAgICAgICAgICAgIHkgPSBwb2ludC55LFxuICAgICAgICAgICAgICBpbnRlcmNlcHRzID0gW10sXG4gICAgICAgICAgICAgIHJvb3RzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ID0gY3VydmVzW2ldLmdldFZhbHVlcygpLFxuICAgICAgICAgICAgICAgIG8wID0gdlsxXSxcbiAgICAgICAgICAgICAgICBvMSA9IHZbM10sXG4gICAgICAgICAgICAgICAgbzIgPSB2WzVdLFxuICAgICAgICAgICAgICAgIG8zID0gdls3XTtcblxuICAgICAgICAgICAgaWYgKHkgPj0gbWluKG8wLCBvMSwgbzIsIG8zKSAmJiB5IDw9IG1heChvMCwgbzEsIG8yLCBvMykpIHtcbiAgICAgICAgICAgICAgdmFyIG1vbm9DdXJ2ZXMgPSBDdXJ2ZS5nZXRNb25vQ3VydmVzKHYpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBtID0gbW9ub0N1cnZlcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbXYgPSBtb25vQ3VydmVzW2pdLFxuICAgICAgICAgICAgICAgICAgICBtbzAgPSBtdlsxXSxcbiAgICAgICAgICAgICAgICAgICAgbW8zID0gbXZbN107XG5cbiAgICAgICAgICAgICAgICBpZiAobW8wICE9PSBtbzMgJiYgKHkgPj0gbW8wICYmIHkgPD0gbW8zIHx8IHkgPj0gbW8zICYmIHkgPD0gbW8wKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHggPSB5ID09PSBtbzAgPyBtdlswXSA6IHkgPT09IG1vMyA/IG12WzZdIDogQ3VydmUuc29sdmVDdWJpYyhtdiwgMSwgeSwgcm9vdHMsIDAsIDEpID09PSAxID8gQ3VydmUuZ2V0UG9pbnQobXYsIHJvb3RzWzBdKS54IDogKG12WzBdICsgbXZbNl0pIC8gMjtcbiAgICAgICAgICAgICAgICAgIGludGVyY2VwdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW50ZXJjZXB0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpbnRlcmNlcHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb2ludC54ID0gKGludGVyY2VwdHNbMF0gKyBpbnRlcmNlcHRzWzFdKSAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuICAgIH07XG4gIH0oKSk7XG4gIHZhciBQYXRoRmxhdHRlbmVyID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1BhdGhGbGF0dGVuZXInLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChwYXRoLCBmbGF0bmVzcywgbWF4UmVjdXJzaW9uLCBpZ25vcmVTdHJhaWdodCwgbWF0cml4KSB7XG4gICAgICB2YXIgY3VydmVzID0gW10sXG4gICAgICAgICAgcGFydHMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICAgIG1pblNwYW4gPSAxIC8gKG1heFJlY3Vyc2lvbiB8fCAzMiksXG4gICAgICAgICAgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcbiAgICAgICAgICBzZWdtZW50MSA9IHNlZ21lbnRzWzBdLFxuICAgICAgICAgIHNlZ21lbnQyO1xuXG4gICAgICBmdW5jdGlvbiBhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpIHtcbiAgICAgICAgdmFyIGN1cnZlID0gQ3VydmUuZ2V0VmFsdWVzKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KTtcbiAgICAgICAgY3VydmVzLnB1c2goY3VydmUpO1xuICAgICAgICBjb21wdXRlUGFydHMoY3VydmUsIHNlZ21lbnQxLl9pbmRleCwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgaW5kZXgsIHQxLCB0Mikge1xuICAgICAgICBpZiAodDIgLSB0MSA+IG1pblNwYW4gJiYgIShpZ25vcmVTdHJhaWdodCAmJiBDdXJ2ZS5pc1N0cmFpZ2h0KGN1cnZlKSkgJiYgIUN1cnZlLmlzRmxhdEVub3VnaChjdXJ2ZSwgZmxhdG5lc3MgfHwgMC4yNSkpIHtcbiAgICAgICAgICB2YXIgaGFsdmVzID0gQ3VydmUuc3ViZGl2aWRlKGN1cnZlLCAwLjUpLFxuICAgICAgICAgICAgICB0TWlkID0gKHQxICsgdDIpIC8gMjtcbiAgICAgICAgICBjb21wdXRlUGFydHMoaGFsdmVzWzBdLCBpbmRleCwgdDEsIHRNaWQpO1xuICAgICAgICAgIGNvbXB1dGVQYXJ0cyhoYWx2ZXNbMV0sIGluZGV4LCB0TWlkLCB0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGR4ID0gY3VydmVbNl0gLSBjdXJ2ZVswXSxcbiAgICAgICAgICAgICAgZHkgPSBjdXJ2ZVs3XSAtIGN1cnZlWzFdLFxuICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgIGlmIChkaXN0ID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoICs9IGRpc3Q7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgb2Zmc2V0OiBsZW5ndGgsXG4gICAgICAgICAgICAgIGN1cnZlOiBjdXJ2ZSxcbiAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICB0aW1lOiB0MlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHNlZ21lbnQyID0gc2VnbWVudHNbaV07XG4gICAgICAgIGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mik7XG4gICAgICAgIHNlZ21lbnQxID0gc2VnbWVudDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoLl9jbG9zZWQpIGFkZEN1cnZlKHNlZ21lbnQyIHx8IHNlZ21lbnQxLCBzZWdtZW50c1swXSk7XG4gICAgICB0aGlzLmN1cnZlcyA9IGN1cnZlcztcbiAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfSxcbiAgICBfZ2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICB2YXIgcGFydHMgPSB0aGlzLnBhcnRzLFxuICAgICAgICAgIGxlbmd0aCA9IHBhcnRzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGogPSB0aGlzLmluZGV4O1xuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGkgPSBqO1xuICAgICAgICBpZiAoIWogfHwgcGFydHNbLS1qXS5vZmZzZXQgPCBvZmZzZXQpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgaWYgKHBhcnQub2Zmc2V0ID49IG9mZnNldCkge1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpO1xuICAgICAgICAgIHZhciBwcmV2ID0gcGFydHNbaSAtIDFdLFxuICAgICAgICAgICAgICBwcmV2VGltZSA9IHByZXYgJiYgcHJldi5pbmRleCA9PT0gcGFydC5pbmRleCA/IHByZXYudGltZSA6IDAsXG4gICAgICAgICAgICAgIHByZXZPZmZzZXQgPSBwcmV2ID8gcHJldi5vZmZzZXQgOiAwO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRleDogcGFydC5pbmRleCxcbiAgICAgICAgICAgIHRpbWU6IHByZXZUaW1lICsgKHBhcnQudGltZSAtIHByZXZUaW1lKSAqIChvZmZzZXQgLSBwcmV2T2Zmc2V0KSAvIChwYXJ0Lm9mZnNldCAtIHByZXZPZmZzZXQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogcGFydHNbbGVuZ3RoIC0gMV0uaW5kZXgsXG4gICAgICAgIHRpbWU6IDFcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3UGFydDogZnVuY3Rpb24gKGN0eCwgZnJvbSwgdG8pIHtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuX2dldChmcm9tKSxcbiAgICAgICAgICBlbmQgPSB0aGlzLl9nZXQodG8pO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQuaW5kZXgsIGwgPSBlbmQuaW5kZXg7IGkgPD0gbDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IEN1cnZlLmdldFBhcnQodGhpcy5jdXJ2ZXNbaV0sIGkgPT09IHN0YXJ0LmluZGV4ID8gc3RhcnQudGltZSA6IDAsIGkgPT09IGVuZC5pbmRleCA/IGVuZC50aW1lIDogMSk7XG4gICAgICAgIGlmIChpID09PSBzdGFydC5pbmRleCkgY3R4Lm1vdmVUbyhjdXJ2ZVswXSwgY3VydmVbMV0pO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUby5hcHBseShjdHgsIGN1cnZlLnNsaWNlKDIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIEJhc2UuZWFjaChDdXJ2ZS5fZXZhbHVhdGVNZXRob2RzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgdmFyIHBhcmFtID0gdGhpcy5fZ2V0KG9mZnNldCk7XG5cbiAgICAgIHJldHVybiBDdXJ2ZVtuYW1lXSh0aGlzLmN1cnZlc1twYXJhbS5pbmRleF0sIHBhcmFtLnRpbWUpO1xuICAgIH07XG4gIH0sIHt9KSk7XG4gIHZhciBQYXRoRml0dGVyID0gQmFzZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMgPSBbXSxcbiAgICAgICAgICBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuICAgICAgICAgIGNsb3NlZCA9IHBhdGguX2Nsb3NlZDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByZXYsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBvaW50ID0gc2VnbWVudHNbaV0ucG9pbnQ7XG5cbiAgICAgICAgaWYgKCFwcmV2IHx8ICFwcmV2LmVxdWFscyhwb2ludCkpIHtcbiAgICAgICAgICBwb2ludHMucHVzaChwcmV2ID0gcG9pbnQuY2xvbmUoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBwb2ludHMudW5zaGlmdChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRzWzFdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbG9zZWQgPSBjbG9zZWQ7XG4gICAgfSxcbiAgICBmaXQ6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgc2VnbWVudHMgPSBudWxsO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICBzZWdtZW50cyA9IFtuZXcgU2VnbWVudChwb2ludHNbMF0pXTtcblxuICAgICAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuZml0Q3ViaWMoc2VnbWVudHMsIGVycm9yLCAwLCBsZW5ndGggLSAxLCBwb2ludHNbMV0uc3VidHJhY3QocG9pbnRzWzBdKSwgcG9pbnRzW2xlbmd0aCAtIDJdLnN1YnRyYWN0KHBvaW50c1tsZW5ndGggLSAxXSkpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICBzZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgc2VnbWVudHMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWdtZW50cztcbiAgICB9LFxuICAgIGZpdEN1YmljOiBmdW5jdGlvbiAoc2VnbWVudHMsIGVycm9yLCBmaXJzdCwgbGFzdCwgdGFuMSwgdGFuMikge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXG4gICAgICBpZiAobGFzdCAtIGZpcnN0ID09PSAxKSB7XG4gICAgICAgIHZhciBwdDEgPSBwb2ludHNbZmlyc3RdLFxuICAgICAgICAgICAgcHQyID0gcG9pbnRzW2xhc3RdLFxuICAgICAgICAgICAgZGlzdCA9IHB0MS5nZXREaXN0YW5jZShwdDIpIC8gMztcbiAgICAgICAgdGhpcy5hZGRDdXJ2ZShzZWdtZW50cywgW3B0MSwgcHQxLmFkZCh0YW4xLm5vcm1hbGl6ZShkaXN0KSksIHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoZGlzdCkpLCBwdDJdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdVByaW1lID0gdGhpcy5jaG9yZExlbmd0aFBhcmFtZXRlcml6ZShmaXJzdCwgbGFzdCksXG4gICAgICAgICAgbWF4RXJyb3IgPSBNYXRoLm1heChlcnJvciwgZXJyb3IgKiBlcnJvciksXG4gICAgICAgICAgc3BsaXQsXG4gICAgICAgICAgcGFyYW1ldGVyc0luT3JkZXIgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSA0OyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZW5lcmF0ZUJlemllcihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKTtcbiAgICAgICAgdmFyIG1heCA9IHRoaXMuZmluZE1heEVycm9yKGZpcnN0LCBsYXN0LCBjdXJ2ZSwgdVByaW1lKTtcblxuICAgICAgICBpZiAobWF4LmVycm9yIDwgZXJyb3IgJiYgcGFyYW1ldGVyc0luT3JkZXIpIHtcbiAgICAgICAgICB0aGlzLmFkZEN1cnZlKHNlZ21lbnRzLCBjdXJ2ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3BsaXQgPSBtYXguaW5kZXg7XG4gICAgICAgIGlmIChtYXguZXJyb3IgPj0gbWF4RXJyb3IpIGJyZWFrO1xuICAgICAgICBwYXJhbWV0ZXJzSW5PcmRlciA9IHRoaXMucmVwYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QsIHVQcmltZSwgY3VydmUpO1xuICAgICAgICBtYXhFcnJvciA9IG1heC5lcnJvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhbkNlbnRlciA9IHBvaW50c1tzcGxpdCAtIDFdLnN1YnRyYWN0KHBvaW50c1tzcGxpdCArIDFdKTtcbiAgICAgIHRoaXMuZml0Q3ViaWMoc2VnbWVudHMsIGVycm9yLCBmaXJzdCwgc3BsaXQsIHRhbjEsIHRhbkNlbnRlcik7XG4gICAgICB0aGlzLmZpdEN1YmljKHNlZ21lbnRzLCBlcnJvciwgc3BsaXQsIGxhc3QsIHRhbkNlbnRlci5uZWdhdGUoKSwgdGFuMik7XG4gICAgfSxcbiAgICBhZGRDdXJ2ZTogZnVuY3Rpb24gKHNlZ21lbnRzLCBjdXJ2ZSkge1xuICAgICAgdmFyIHByZXYgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHByZXYuc2V0SGFuZGxlT3V0KGN1cnZlWzFdLnN1YnRyYWN0KGN1cnZlWzBdKSk7XG4gICAgICBzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KGN1cnZlWzNdLCBjdXJ2ZVsyXS5zdWJ0cmFjdChjdXJ2ZVszXSkpKTtcbiAgICB9LFxuICAgIGdlbmVyYXRlQmV6aWVyOiBmdW5jdGlvbiAoZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMikge1xuICAgICAgdmFyIGVwc2lsb24gPSAxZS0xMixcbiAgICAgICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICBwb2ludHMgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICBwdDEgPSBwb2ludHNbZmlyc3RdLFxuICAgICAgICAgIHB0MiA9IHBvaW50c1tsYXN0XSxcbiAgICAgICAgICBDID0gW1swLCAwXSwgWzAsIDBdXSxcbiAgICAgICAgICBYID0gWzAsIDBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxhc3QgLSBmaXJzdCArIDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHUgPSB1UHJpbWVbaV0sXG4gICAgICAgICAgICB0ID0gMSAtIHUsXG4gICAgICAgICAgICBiID0gMyAqIHUgKiB0LFxuICAgICAgICAgICAgYjAgPSB0ICogdCAqIHQsXG4gICAgICAgICAgICBiMSA9IGIgKiB0LFxuICAgICAgICAgICAgYjIgPSBiICogdSxcbiAgICAgICAgICAgIGIzID0gdSAqIHUgKiB1LFxuICAgICAgICAgICAgYTEgPSB0YW4xLm5vcm1hbGl6ZShiMSksXG4gICAgICAgICAgICBhMiA9IHRhbjIubm9ybWFsaXplKGIyKSxcbiAgICAgICAgICAgIHRtcCA9IHBvaW50c1tmaXJzdCArIGldLnN1YnRyYWN0KHB0MS5tdWx0aXBseShiMCArIGIxKSkuc3VidHJhY3QocHQyLm11bHRpcGx5KGIyICsgYjMpKTtcbiAgICAgICAgQ1swXVswXSArPSBhMS5kb3QoYTEpO1xuICAgICAgICBDWzBdWzFdICs9IGExLmRvdChhMik7XG4gICAgICAgIENbMV1bMF0gPSBDWzBdWzFdO1xuICAgICAgICBDWzFdWzFdICs9IGEyLmRvdChhMik7XG4gICAgICAgIFhbMF0gKz0gYTEuZG90KHRtcCk7XG4gICAgICAgIFhbMV0gKz0gYTIuZG90KHRtcCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXRDMEMxID0gQ1swXVswXSAqIENbMV1bMV0gLSBDWzFdWzBdICogQ1swXVsxXSxcbiAgICAgICAgICBhbHBoYTEsXG4gICAgICAgICAgYWxwaGEyO1xuXG4gICAgICBpZiAoYWJzKGRldEMwQzEpID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgZGV0QzBYID0gQ1swXVswXSAqIFhbMV0gLSBDWzFdWzBdICogWFswXSxcbiAgICAgICAgICAgIGRldFhDMSA9IFhbMF0gKiBDWzFdWzFdIC0gWFsxXSAqIENbMF1bMV07XG4gICAgICAgIGFscGhhMSA9IGRldFhDMSAvIGRldEMwQzE7XG4gICAgICAgIGFscGhhMiA9IGRldEMwWCAvIGRldEMwQzE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYzAgPSBDWzBdWzBdICsgQ1swXVsxXSxcbiAgICAgICAgICAgIGMxID0gQ1sxXVswXSArIENbMV1bMV07XG4gICAgICAgIGFscGhhMSA9IGFscGhhMiA9IGFicyhjMCkgPiBlcHNpbG9uID8gWFswXSAvIGMwIDogYWJzKGMxKSA+IGVwc2lsb24gPyBYWzFdIC8gYzEgOiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VnTGVuZ3RoID0gcHQyLmdldERpc3RhbmNlKHB0MSksXG4gICAgICAgICAgZXBzID0gZXBzaWxvbiAqIHNlZ0xlbmd0aCxcbiAgICAgICAgICBoYW5kbGUxLFxuICAgICAgICAgIGhhbmRsZTI7XG5cbiAgICAgIGlmIChhbHBoYTEgPCBlcHMgfHwgYWxwaGEyIDwgZXBzKSB7XG4gICAgICAgIGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGluZSA9IHB0Mi5zdWJ0cmFjdChwdDEpO1xuICAgICAgICBoYW5kbGUxID0gdGFuMS5ub3JtYWxpemUoYWxwaGExKTtcbiAgICAgICAgaGFuZGxlMiA9IHRhbjIubm9ybWFsaXplKGFscGhhMik7XG5cbiAgICAgICAgaWYgKGhhbmRsZTEuZG90KGxpbmUpIC0gaGFuZGxlMi5kb3QobGluZSkgPiBzZWdMZW5ndGggKiBzZWdMZW5ndGgpIHtcbiAgICAgICAgICBhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuICAgICAgICAgIGhhbmRsZTEgPSBoYW5kbGUyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3B0MSwgcHQxLmFkZChoYW5kbGUxIHx8IHRhbjEubm9ybWFsaXplKGFscGhhMSkpLCBwdDIuYWRkKGhhbmRsZTIgfHwgdGFuMi5ub3JtYWxpemUoYWxwaGEyKSksIHB0Ml07XG4gICAgfSxcbiAgICByZXBhcmFtZXRlcml6ZTogZnVuY3Rpb24gKGZpcnN0LCBsYXN0LCB1LCBjdXJ2ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICB1W2kgLSBmaXJzdF0gPSB0aGlzLmZpbmRSb290KGN1cnZlLCB0aGlzLnBvaW50c1tpXSwgdVtpIC0gZmlyc3RdKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSB1Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAodVtpXSA8PSB1W2kgLSAxXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGZpbmRSb290OiBmdW5jdGlvbiAoY3VydmUsIHBvaW50LCB1KSB7XG4gICAgICB2YXIgY3VydmUxID0gW10sXG4gICAgICAgICAgY3VydmUyID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDI7IGkrKykge1xuICAgICAgICBjdXJ2ZTFbaV0gPSBjdXJ2ZVtpICsgMV0uc3VidHJhY3QoY3VydmVbaV0pLm11bHRpcGx5KDMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgY3VydmUyW2ldID0gY3VydmUxW2kgKyAxXS5zdWJ0cmFjdChjdXJ2ZTFbaV0pLm11bHRpcGx5KDIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHQgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1KSxcbiAgICAgICAgICBwdDEgPSB0aGlzLmV2YWx1YXRlKDIsIGN1cnZlMSwgdSksXG4gICAgICAgICAgcHQyID0gdGhpcy5ldmFsdWF0ZSgxLCBjdXJ2ZTIsIHUpLFxuICAgICAgICAgIGRpZmYgPSBwdC5zdWJ0cmFjdChwb2ludCksXG4gICAgICAgICAgZGYgPSBwdDEuZG90KHB0MSkgKyBkaWZmLmRvdChwdDIpO1xuICAgICAgcmV0dXJuIE51bWVyaWNhbC5pc01hY2hpbmVaZXJvKGRmKSA/IHUgOiB1IC0gZGlmZi5kb3QocHQxKSAvIGRmO1xuICAgIH0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChkZWdyZWUsIGN1cnZlLCB0KSB7XG4gICAgICB2YXIgdG1wID0gY3VydmUuc2xpY2UoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZGVncmVlOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gZGVncmVlIC0gaTsgaisrKSB7XG4gICAgICAgICAgdG1wW2pdID0gdG1wW2pdLm11bHRpcGx5KDEgLSB0KS5hZGQodG1wW2ogKyAxXS5tdWx0aXBseSh0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRtcFswXTtcbiAgICB9LFxuICAgIGNob3JkTGVuZ3RoUGFyYW1ldGVyaXplOiBmdW5jdGlvbiAoZmlyc3QsIGxhc3QpIHtcbiAgICAgIHZhciB1ID0gWzBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICB1W2kgLSBmaXJzdF0gPSB1W2kgLSBmaXJzdCAtIDFdICsgdGhpcy5wb2ludHNbaV0uZ2V0RGlzdGFuY2UodGhpcy5wb2ludHNbaSAtIDFdKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDEsIG0gPSBsYXN0IC0gZmlyc3Q7IGkgPD0gbTsgaSsrKSB7XG4gICAgICAgIHVbaV0gLz0gdVttXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHU7XG4gICAgfSxcbiAgICBmaW5kTWF4RXJyb3I6IGZ1bmN0aW9uIChmaXJzdCwgbGFzdCwgY3VydmUsIHUpIHtcbiAgICAgIHZhciBpbmRleCA9IE1hdGguZmxvb3IoKGxhc3QgLSBmaXJzdCArIDEpIC8gMiksXG4gICAgICAgICAgbWF4RGlzdCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgdmFyIFAgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1W2kgLSBmaXJzdF0pO1xuICAgICAgICB2YXIgdiA9IFAuc3VidHJhY3QodGhpcy5wb2ludHNbaV0pO1xuICAgICAgICB2YXIgZGlzdCA9IHYueCAqIHYueCArIHYueSAqIHYueTtcblxuICAgICAgICBpZiAoZGlzdCA+PSBtYXhEaXN0KSB7XG4gICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBtYXhEaXN0LFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgdmFyIFRleHRJdGVtID0gSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1RleHRJdGVtJyxcbiAgICBfYXBwbHlNYXRyaXg6IGZhbHNlLFxuICAgIF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgY29udGVudDogbnVsbFxuICAgIH0sXG4gICAgX2JvdW5kc09wdGlvbnM6IHtcbiAgICAgIHN0cm9rZTogZmFsc2UsXG4gICAgICBoYW5kbGU6IGZhbHNlXG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBUZXh0SXRlbShhcmcpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQgPSAnJztcbiAgICAgIHRoaXMuX2xpbmVzID0gW107XG4gICAgICB2YXIgaGFzUHJvcHMgPSBhcmcgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZykgJiYgYXJnLnggPT09IHVuZGVmaW5lZCAmJiBhcmcueSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLl9pbml0aWFsaXplKGhhc1Byb3BzICYmIGFyZywgIWhhc1Byb3BzICYmIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBfZXF1YWxzOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQgPT09IGl0ZW0uX2NvbnRlbnQ7XG4gICAgfSxcbiAgICBjb3B5Q29udGVudDogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgdGhpcy5zZXRDb250ZW50KHNvdXJjZS5fY29udGVudCk7XG4gICAgfSxcbiAgICBnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9LFxuICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50ID0gJycgKyBjb250ZW50O1xuICAgICAgdGhpcy5fbGluZXMgPSB0aGlzLl9jb250ZW50LnNwbGl0KC9cXHJcXG58XFxufFxcci9tZyk7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoNTIxKTtcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5fY29udGVudDtcbiAgICB9LFxuICAgIGdldENoYXJhY3RlclN0eWxlOiAnI2dldFN0eWxlJyxcbiAgICBzZXRDaGFyYWN0ZXJTdHlsZTogJyNzZXRTdHlsZScsXG4gICAgZ2V0UGFyYWdyYXBoU3R5bGU6ICcjZ2V0U3R5bGUnLFxuICAgIHNldFBhcmFncmFwaFN0eWxlOiAnI3NldFN0eWxlJ1xuICB9KTtcbiAgdmFyIFBvaW50VGV4dCA9IFRleHRJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUG9pbnRUZXh0JyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludFRleHQoKSB7XG4gICAgICBUZXh0SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuXG4gICAgICByZXR1cm4gbmV3IExpbmtlZFBvaW50KHBvaW50LngsIHBvaW50LnksIHRoaXMsICdzZXRQb2ludCcpO1xuICAgIH0sXG4gICAgc2V0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudHJhbnNsYXRlKHBvaW50LnN1YnRyYWN0KHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpKSk7XG4gICAgfSxcbiAgICBfZHJhdzogZnVuY3Rpb24gKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpIHtcbiAgICAgIGlmICghdGhpcy5fY29udGVudCkgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9zZXRTdHlsZXMoY3R4LCBwYXJhbSwgdmlld01hdHJpeCk7XG5cbiAgICAgIHZhciBsaW5lcyA9IHRoaXMuX2xpbmVzLFxuICAgICAgICAgIHN0eWxlID0gdGhpcy5fc3R5bGUsXG4gICAgICAgICAgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcbiAgICAgICAgICBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcbiAgICAgICAgICBsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuICAgICAgICAgIHNoYWRvd0NvbG9yID0gY3R4LnNoYWRvd0NvbG9yO1xuICAgICAgY3R4LmZvbnQgPSBzdHlsZS5nZXRGb250U3R5bGUoKTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yO1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgIGlmIChoYXNGaWxsKSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIDAsIDApO1xuICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTdHJva2UpIGN0eC5zdHJva2VUZXh0KGxpbmUsIDAsIDApO1xuICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGxlYWRpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24gKG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG4gICAgICAgICAgbGluZXMgPSB0aGlzLl9saW5lcyxcbiAgICAgICAgICBudW1MaW5lcyA9IGxpbmVzLmxlbmd0aCxcbiAgICAgICAgICBqdXN0aWZpY2F0aW9uID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpLFxuICAgICAgICAgIGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG4gICAgICAgICAgd2lkdGggPSB0aGlzLmdldFZpZXcoKS5nZXRUZXh0V2lkdGgoc3R5bGUuZ2V0Rm9udFN0eWxlKCksIGxpbmVzKSxcbiAgICAgICAgICB4ID0gMDtcbiAgICAgIGlmIChqdXN0aWZpY2F0aW9uICE9PSAnbGVmdCcpIHggLT0gd2lkdGggLyAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicgPyAyIDogMSk7XG4gICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUoeCwgbnVtTGluZXMgPyAtMC43NSAqIGxlYWRpbmcgOiAwLCB3aWR0aCwgbnVtTGluZXMgKiBsZWFkaW5nKTtcbiAgICAgIHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0LCByZWN0KSA6IHJlY3Q7XG4gICAgfVxuICB9KTtcbiAgdmFyIENvbG9yID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZXMgPSB7XG4gICAgICBncmF5OiBbJ2dyYXknXSxcbiAgICAgIHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuICAgICAgaHNiOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2JyaWdodG5lc3MnXSxcbiAgICAgIGhzbDogWydodWUnLCAnc2F0dXJhdGlvbicsICdsaWdodG5lc3MnXSxcbiAgICAgIGdyYWRpZW50OiBbJ2dyYWRpZW50JywgJ29yaWdpbicsICdkZXN0aW5hdGlvbicsICdoaWdobGlnaHQnXVxuICAgIH07XG4gICAgdmFyIGNvbXBvbmVudFBhcnNlcnMgPSB7fSxcbiAgICAgICAgbmFtZWRDb2xvcnMgPSB7XG4gICAgICB0cmFuc3BhcmVudDogWzAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICAgICAgY29sb3JDdHg7XG5cbiAgICBmdW5jdGlvbiBmcm9tQ1NTKHN0cmluZykge1xuICAgICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eIyhbXFxkYS1mXXsyfSkoW1xcZGEtZl17Mn0pKFtcXGRhLWZdezJ9KShbXFxkYS1mXXsyfSk/JC9pKSB8fCBzdHJpbmcubWF0Y2goL14jKFtcXGRhLWZdKShbXFxkYS1mXSkoW1xcZGEtZl0pKFtcXGRhLWZdKT8kL2kpLFxuICAgICAgICAgIHR5cGUgPSAncmdiJyxcbiAgICAgICAgICBjb21wb25lbnRzO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGFtb3VudCA9IG1hdGNoWzRdID8gNCA6IDM7XG4gICAgICAgIGNvbXBvbmVudHMgPSBuZXcgQXJyYXkoYW1vdW50KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuICAgICAgICAgIGNvbXBvbmVudHNbaV0gPSBwYXJzZUludCh2YWx1ZS5sZW5ndGggPT0gMSA/IHZhbHVlICsgdmFsdWUgOiB2YWx1ZSwgMTYpIC8gMjU1O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eKHJnYnxoc2wpYT9cXCgoLiopXFwpJC8pKSB7XG4gICAgICAgIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgY29tcG9uZW50cyA9IG1hdGNoWzJdLnRyaW0oKS5zcGxpdCgvWyxcXHNdKy9nKTtcbiAgICAgICAgdmFyIGlzSFNMID0gdHlwZSA9PT0gJ2hzbCc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBNYXRoLm1pbihjb21wb25lbnRzLmxlbmd0aCwgNCk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KGNvbXBvbmVudCk7XG5cbiAgICAgICAgICBpZiAoaXNIU0wpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhciB1bml0ID0gY29tcG9uZW50Lm1hdGNoKC8oW2Etel0qKSQvKVsxXTtcbiAgICAgICAgICAgICAgdmFsdWUgKj0ge1xuICAgICAgICAgICAgICAgIHR1cm46IDM2MCxcbiAgICAgICAgICAgICAgICByYWQ6IDE4MCAvIE1hdGguUEksXG4gICAgICAgICAgICAgICAgZ3JhZDogMC45XG4gICAgICAgICAgICAgIH1bdW5pdF0gfHwgMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDMpIHtcbiAgICAgICAgICAgICAgdmFsdWUgLz0gMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDMpIHtcbiAgICAgICAgICAgIHZhbHVlIC89IC8lJC8udGVzdChjb21wb25lbnQpID8gMTAwIDogMjU1O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbmFtZWRDb2xvcnNbc3RyaW5nXTtcblxuICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgaWYgKHdpbmRvdykge1xuICAgICAgICAgICAgaWYgKCFjb2xvckN0eCkge1xuICAgICAgICAgICAgICBjb2xvckN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG4gICAgICAgICAgICAgIGNvbG9yQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sb3JDdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICAgICAgY29sb3JDdHguZmlsbFN0eWxlID0gc3RyaW5nO1xuICAgICAgICAgICAgY29sb3JDdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGNvbG9yQ3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuICAgICAgICAgICAgY29sb3IgPSBuYW1lZENvbG9yc1tzdHJpbmddID0gW2RhdGFbMF0gLyAyNTUsIGRhdGFbMV0gLyAyNTUsIGRhdGFbMl0gLyAyNTVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xvciA9IFswLCAwLCAwXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRzID0gY29sb3Iuc2xpY2UoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt0eXBlLCBjb21wb25lbnRzXTtcbiAgICB9XG5cbiAgICB2YXIgaHNiSW5kaWNlcyA9IFtbMCwgMywgMV0sIFsyLCAwLCAxXSwgWzEsIDAsIDNdLCBbMSwgMiwgMF0sIFszLCAxLCAwXSwgWzAsIDEsIDJdXTtcbiAgICB2YXIgY29udmVydGVycyA9IHtcbiAgICAgICdyZ2ItaHNiJzogZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICAgICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgICAgICAgIGggPSBkZWx0YSA9PT0gMCA/IDAgOiAobWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMCkgOiBtYXggPT0gZyA/IChiIC0gcikgLyBkZWx0YSArIDIgOiAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwO1xuICAgICAgICByZXR1cm4gW2gsIG1heCA9PT0gMCA/IDAgOiBkZWx0YSAvIG1heCwgbWF4XTtcbiAgICAgIH0sXG4gICAgICAnaHNiLXJnYic6IGZ1bmN0aW9uIChoLCBzLCBiKSB7XG4gICAgICAgIGggPSAoaCAvIDYwICUgNiArIDYpICUgNjtcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGgpLFxuICAgICAgICAgICAgZiA9IGggLSBpLFxuICAgICAgICAgICAgaSA9IGhzYkluZGljZXNbaV0sXG4gICAgICAgICAgICB2ID0gW2IsIGIgKiAoMSAtIHMpLCBiICogKDEgLSBzICogZiksIGIgKiAoMSAtIHMgKiAoMSAtIGYpKV07XG4gICAgICAgIHJldHVybiBbdltpWzBdXSwgdltpWzFdXSwgdltpWzJdXV07XG4gICAgICB9LFxuICAgICAgJ3JnYi1oc2wnOiBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgICAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgICAgICAgYWNocm9tYXRpYyA9IGRlbHRhID09PSAwLFxuICAgICAgICAgICAgaCA9IGFjaHJvbWF0aWMgPyAwIDogKG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApIDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyIDogKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MCxcbiAgICAgICAgICAgIGwgPSAobWF4ICsgbWluKSAvIDIsXG4gICAgICAgICAgICBzID0gYWNocm9tYXRpYyA/IDAgOiBsIDwgMC41ID8gZGVsdGEgLyAobWF4ICsgbWluKSA6IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgICByZXR1cm4gW2gsIHMsIGxdO1xuICAgICAgfSxcbiAgICAgICdoc2wtcmdiJzogZnVuY3Rpb24gKGgsIHMsIGwpIHtcbiAgICAgICAgaCA9IChoIC8gMzYwICUgMSArIDEpICUgMTtcbiAgICAgICAgaWYgKHMgPT09IDApIHJldHVybiBbbCwgbCwgbF07XG4gICAgICAgIHZhciB0M3MgPSBbaCArIDEgLyAzLCBoLCBoIC0gMSAvIDNdLFxuICAgICAgICAgICAgdDIgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzLFxuICAgICAgICAgICAgdDEgPSAyICogbCAtIHQyLFxuICAgICAgICAgICAgYyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgdmFyIHQzID0gdDNzW2ldO1xuICAgICAgICAgIGlmICh0MyA8IDApIHQzICs9IDE7XG4gICAgICAgICAgaWYgKHQzID4gMSkgdDMgLT0gMTtcbiAgICAgICAgICBjW2ldID0gNiAqIHQzIDwgMSA/IHQxICsgKHQyIC0gdDEpICogNiAqIHQzIDogMiAqIHQzIDwgMSA/IHQyIDogMyAqIHQzIDwgMiA/IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNiA6IHQxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9LFxuICAgICAgJ3JnYi1ncmF5JzogZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuIFtyICogMC4yOTg5ICsgZyAqIDAuNTg3ICsgYiAqIDAuMTE0XTtcbiAgICAgIH0sXG4gICAgICAnZ3JheS1yZ2InOiBmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gW2csIGcsIGddO1xuICAgICAgfSxcbiAgICAgICdncmF5LWhzYic6IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgZ107XG4gICAgICB9LFxuICAgICAgJ2dyYXktaHNsJzogZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgcmV0dXJuIFswLCAwLCBnXTtcbiAgICAgIH0sXG4gICAgICAnZ3JhZGllbnQtcmdiJzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9LFxuICAgICAgJ3JnYi1ncmFkaWVudCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJhc2UuZWFjaCh0eXBlcywgZnVuY3Rpb24gKHByb3BlcnRpZXMsIHR5cGUpIHtcbiAgICAgIGNvbXBvbmVudFBhcnNlcnNbdHlwZV0gPSBbXTtcbiAgICAgIEJhc2UuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbiAobmFtZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG4gICAgICAgICAgICBoYXNPdmVybGFwID0gL14oaHVlfHNhdHVyYXRpb24pJC8udGVzdChuYW1lKSxcbiAgICAgICAgICAgIHBhcnNlciA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV1baW5kZXhdID0gdHlwZSA9PT0gJ2dyYWRpZW50JyA/IG5hbWUgPT09ICdncmFkaWVudCcgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2NvbXBvbmVudHNbMF07XG4gICAgICAgICAgdmFsdWUgPSBHcmFkaWVudC5yZWFkKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBhcmd1bWVudHMsIDAsIHtcbiAgICAgICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSBjdXJyZW50Ll9yZW1vdmVPd25lcih0aGlzKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgdmFsdWUuX2FkZE93bmVyKHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHtcbiAgICAgICAgICAgIHJlYWROdWxsOiBuYW1lID09PSAnaGlnaGxpZ2h0JyxcbiAgICAgICAgICAgIGNsb25lOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgPyAwIDogK3ZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZSB8fCBoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKSA/IHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdIDogdGhpcy5fY29udmVydCh0eXBlKVtpbmRleF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3R5cGUgIT09IHR5cGUgJiYgIShoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cbiAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH07XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LCB7XG4gICAgICBfY2xhc3M6ICdDb2xvcicsXG4gICAgICBfcmVhZEluZGV4OiB0cnVlLFxuICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29sb3IoYXJnKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgcmVhZGluZyA9IHRoaXMuX19yZWFkLFxuICAgICAgICAgICAgcmVhZCA9IDAsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY29tcG9uZW50cyxcbiAgICAgICAgICAgIGFscGhhLFxuICAgICAgICAgICAgdmFsdWVzO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICBhcmdzID0gYXJnO1xuICAgICAgICAgIGFyZyA9IGFyZ3NbMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJnVHlwZSA9IGFyZyAhPSBudWxsICYmIHR5cGVvZiBhcmc7XG5cbiAgICAgICAgaWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnICYmIGFyZyBpbiB0eXBlcykge1xuICAgICAgICAgIHR5cGUgPSBhcmc7XG4gICAgICAgICAgYXJnID0gYXJnc1sxXTtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBhcmc7XG4gICAgICAgICAgICBhbHBoYSA9IGFyZ3NbMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZWFkaW5nKSByZWFkID0gMTtcbiAgICAgICAgICAgIGFyZ3MgPSBCYXNlLnNsaWNlKGFyZ3MsIDEpO1xuICAgICAgICAgICAgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgICAgdmFsdWVzID0gYXJnVHlwZSA9PT0gJ251bWJlcicgPyBhcmdzIDogYXJnVHlwZSA9PT0gJ29iamVjdCcgJiYgYXJnLmxlbmd0aCAhPSBudWxsID8gYXJnIDogbnVsbDtcblxuICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICghdHlwZSkgdHlwZSA9IHZhbHVlcy5sZW5ndGggPj0gMyA/ICdyZ2InIDogJ2dyYXknO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHR5cGVzW3R5cGVdLmxlbmd0aDtcbiAgICAgICAgICAgIGFscGhhID0gdmFsdWVzW2xlbmd0aF07XG5cbiAgICAgICAgICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICAgICAgICAgIHJlYWQgKz0gdmFsdWVzID09PSBhcmd1bWVudHMgPyBsZW5ndGggKyAoYWxwaGEgIT0gbnVsbCA/IDEgOiAwKSA6IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gbGVuZ3RoKSB2YWx1ZXMgPSBCYXNlLnNsaWNlKHZhbHVlcywgMCwgbGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgY29udmVydGVkID0gZnJvbUNTUyhhcmcpO1xuICAgICAgICAgICAgdHlwZSA9IGNvbnZlcnRlZFswXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBjb252ZXJ0ZWRbMV07XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICBhbHBoYSA9IGNvbXBvbmVudHNbM107XG4gICAgICAgICAgICAgIGNvbXBvbmVudHMubGVuZ3RoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcbiAgICAgICAgICAgICAgdHlwZSA9IGFyZy5fdHlwZTtcbiAgICAgICAgICAgICAgY29tcG9uZW50cyA9IGFyZy5fY29tcG9uZW50cy5zbGljZSgpO1xuICAgICAgICAgICAgICBhbHBoYSA9IGFyZy5fYWxwaGE7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdncmFkaWVudCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKHBvaW50KSBjb21wb25lbnRzW2ldID0gcG9pbnQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBHcmFkaWVudCkge1xuICAgICAgICAgICAgICB0eXBlID0gJ2dyYWRpZW50JztcbiAgICAgICAgICAgICAgdmFsdWVzID0gYXJncztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHR5cGUgPSAnaHVlJyBpbiBhcmcgPyAnbGlnaHRuZXNzJyBpbiBhcmcgPyAnaHNsJyA6ICdoc2InIDogJ2dyYWRpZW50JyBpbiBhcmcgfHwgJ3N0b3BzJyBpbiBhcmcgfHwgJ3JhZGlhbCcgaW4gYXJnID8gJ2dyYWRpZW50JyA6ICdncmF5JyBpbiBhcmcgPyAnZ3JheScgOiAncmdiJztcbiAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0eXBlc1t0eXBlXSxcbiAgICAgICAgICAgICAgICAgIHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdO1xuICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcmdbcHJvcGVydGllc1tpXV07XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhaSAmJiB0eXBlID09PSAnZ3JhZGllbnQnICYmICdzdG9wcycgaW4gYXJnKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHM6IGFyZy5zdG9wcyxcbiAgICAgICAgICAgICAgICAgICAgcmFkaWFsOiBhcmcucmFkaWFsXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Vyc1tpXS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkgY29tcG9uZW50c1tpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYWxwaGEgPSBhcmcuYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlYWRpbmcgJiYgdHlwZSkgcmVhZCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90eXBlID0gdHlwZSB8fCAncmdiJztcblxuICAgICAgICBpZiAoIWNvbXBvbmVudHMpIHtcbiAgICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgIHZhciBwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0aGlzLl90eXBlXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2Vycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZXMgJiYgdmFsdWVzW2ldKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSBjb21wb25lbnRzW2ldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0aGlzLl90eXBlXTtcbiAgICAgICAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbiAgICAgICAgaWYgKHJlYWRpbmcpIHRoaXMuX19yZWFkID0gcmVhZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgc2V0OiAnI2luaXRpYWxpemUnLFxuICAgICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLmdldENvbXBvbmVudHMoKTtcbiAgICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKC9eKGdyYXl8cmdiKSQvLnRlc3QodGhpcy5fdHlwZSkgPyBjb21wb25lbnRzIDogW3RoaXMuX3R5cGVdLmNvbmNhdChjb21wb25lbnRzKSwgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG4gICAgICB9LFxuICAgICAgX2NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzU3R5bGUgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLl9vd25lcikge1xuICAgICAgICAgIGlmICh0aGlzLl9zZXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX293bmVyLl9jaGFuZ2VkKDEyOSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2NvbnZlcnQ6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBjb252ZXJ0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlID8gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpIDogKGNvbnZlcnRlciA9IGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctJyArIHR5cGVdKSA/IGNvbnZlcnRlci5hcHBseSh0aGlzLCB0aGlzLl9jb21wb25lbnRzKSA6IGNvbnZlcnRlcnNbJ3JnYi0nICsgdHlwZV0uYXBwbHkodGhpcywgY29udmVydGVyc1t0aGlzLl90eXBlICsgJy1yZ2InXS5hcHBseSh0aGlzLCB0aGlzLl9jb21wb25lbnRzKSk7XG4gICAgICB9LFxuICAgICAgY29udmVydDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0eXBlLCB0aGlzLl9jb252ZXJ0KHR5cGUpLCB0aGlzLl9hbHBoYSk7XG4gICAgICB9LFxuICAgICAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICAgIH0sXG4gICAgICBzZXRUeXBlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAgIH0sXG4gICAgICBnZXRDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKSBjb21wb25lbnRzLnB1c2godGhpcy5fYWxwaGEpO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICAgIH0sXG4gICAgICBnZXRBbHBoYTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGEgIT0gbnVsbCA/IHRoaXMuX2FscGhhIDogMTtcbiAgICAgIH0sXG4gICAgICBzZXRBbHBoYTogZnVuY3Rpb24gKGFscGhhKSB7XG4gICAgICAgIHRoaXMuX2FscGhhID0gYWxwaGEgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1pbihNYXRoLm1heChhbHBoYSwgMCksIDEpO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgIH0sXG4gICAgICBoYXNBbHBoYTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGEgIT0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBlcXVhbHM6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgY29sID0gQmFzZS5pc1BsYWluVmFsdWUoY29sb3IsIHRydWUpID8gQ29sb3IucmVhZChhcmd1bWVudHMpIDogY29sb3I7XG4gICAgICAgIHJldHVybiBjb2wgPT09IHRoaXMgfHwgY29sICYmIHRoaXMuX2NsYXNzID09PSBjb2wuX2NsYXNzICYmIHRoaXMuX3R5cGUgPT09IGNvbC5fdHlwZSAmJiB0aGlzLmdldEFscGhhKCkgPT09IGNvbC5nZXRBbHBoYSgpICYmIEJhc2UuZXF1YWxzKHRoaXMuX2NvbXBvbmVudHMsIGNvbC5fY29tcG9uZW50cykgfHwgZmFsc2U7XG4gICAgICB9LFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgcGFydHMgPSBbXSxcbiAgICAgICAgICAgIGlzR3JhZGllbnQgPSB0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnLFxuICAgICAgICAgICAgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fY29tcG9uZW50c1tpXTtcbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkgcGFydHMucHVzaChwcm9wZXJ0aWVzW2ldICsgJzogJyArIChpc0dyYWRpZW50ID8gdmFsdWUgOiBmLm51bWJlcih2YWx1ZSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKSBwYXJ0cy5wdXNoKCdhbHBoYTogJyArIGYubnVtYmVyKHRoaXMuX2FscGhhKSk7XG4gICAgICAgIHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG4gICAgICB9LFxuICAgICAgdG9DU1M6IGZ1bmN0aW9uIChoZXgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KCdyZ2InKSxcbiAgICAgICAgICAgIGFscGhhID0gaGV4IHx8IHRoaXMuX2FscGhhID09IG51bGwgPyAxIDogdGhpcy5fYWxwaGE7XG5cbiAgICAgICAgZnVuY3Rpb24gY29udmVydCh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgodmFsIDwgMCA/IDAgOiB2YWwgPiAxID8gMSA6IHZhbCkgKiAyNTUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50cyA9IFtjb252ZXJ0KGNvbXBvbmVudHNbMF0pLCBjb252ZXJ0KGNvbXBvbmVudHNbMV0pLCBjb252ZXJ0KGNvbXBvbmVudHNbMl0pXTtcbiAgICAgICAgaWYgKGFscGhhIDwgMSkgY29tcG9uZW50cy5wdXNoKGFscGhhIDwgMCA/IDAgOiBhbHBoYSk7XG4gICAgICAgIHJldHVybiBoZXggPyAnIycgKyAoKDEgPDwgMjQpICsgKGNvbXBvbmVudHNbMF0gPDwgMTYpICsgKGNvbXBvbmVudHNbMV0gPDwgOCkgKyBjb21wb25lbnRzWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSkgOiAoY29tcG9uZW50cy5sZW5ndGggPT0gNCA/ICdyZ2JhKCcgOiAncmdiKCcpICsgY29tcG9uZW50cy5qb2luKCcsJykgKyAnKSc7XG4gICAgICB9LFxuICAgICAgdG9DYW52YXNTdHlsZTogZnVuY3Rpb24gKGN0eCwgbWF0cml4KSB7XG4gICAgICAgIGlmICh0aGlzLl9jYW52YXNTdHlsZSkgcmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlO1xuICAgICAgICBpZiAodGhpcy5fdHlwZSAhPT0gJ2dyYWRpZW50JykgcmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gdGhpcy50b0NTUygpO1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMsXG4gICAgICAgICAgICBncmFkaWVudCA9IGNvbXBvbmVudHNbMF0sXG4gICAgICAgICAgICBzdG9wcyA9IGdyYWRpZW50Ll9zdG9wcyxcbiAgICAgICAgICAgIG9yaWdpbiA9IGNvbXBvbmVudHNbMV0sXG4gICAgICAgICAgICBkZXN0aW5hdGlvbiA9IGNvbXBvbmVudHNbMl0sXG4gICAgICAgICAgICBoaWdobGlnaHQgPSBjb21wb25lbnRzWzNdLFxuICAgICAgICAgICAgaW52ZXJzZSA9IG1hdHJpeCAmJiBtYXRyaXguaW52ZXJ0ZWQoKSxcbiAgICAgICAgICAgIGNhbnZhc0dyYWRpZW50O1xuXG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgb3JpZ2luID0gaW52ZXJzZS5fdHJhbnNmb3JtUG9pbnQob3JpZ2luKTtcbiAgICAgICAgICBkZXN0aW5hdGlvbiA9IGludmVyc2UuX3RyYW5zZm9ybVBvaW50KGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0KSBoaWdobGlnaHQgPSBpbnZlcnNlLl90cmFuc2Zvcm1Qb2ludChoaWdobGlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyYWRpZW50Ll9yYWRpYWwpIHtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gZGVzdGluYXRpb24uZ2V0RGlzdGFuY2Uob3JpZ2luKTtcblxuICAgICAgICAgIGlmIChoaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBoaWdobGlnaHQuc3VidHJhY3Qob3JpZ2luKTtcbiAgICAgICAgICAgIGlmICh2ZWN0b3IuZ2V0TGVuZ3RoKCkgPiByYWRpdXMpIGhpZ2hsaWdodCA9IG9yaWdpbi5hZGQodmVjdG9yLm5vcm1hbGl6ZShyYWRpdXMgLSAwLjEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBoaWdobGlnaHQgfHwgb3JpZ2luO1xuICAgICAgICAgIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIDAsIG9yaWdpbi54LCBvcmlnaW4ueSwgcmFkaXVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChvcmlnaW4ueCwgb3JpZ2luLnksIGRlc3RpbmF0aW9uLngsIGRlc3RpbmF0aW9uLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW2ldLFxuICAgICAgICAgICAgICBvZmZzZXQgPSBzdG9wLl9vZmZzZXQ7XG4gICAgICAgICAgY2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKG9mZnNldCA9PSBudWxsID8gaSAvIChsIC0gMSkgOiBvZmZzZXQsIHN0b3AuX2NvbG9yLnRvQ2FudmFzU3R5bGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSBjYW52YXNHcmFkaWVudDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09ICdncmFkaWVudCcpIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHM7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXG4gICAgICAgICAgICBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvaW50LCBwb2ludCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RhdGljczoge1xuICAgICAgICBfdHlwZXM6IHR5cGVzLFxuICAgICAgICByYW5kb206IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmFuZG9tID0gTWF0aC5yYW5kb207XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyYW5kb20oKSwgcmFuZG9tKCksIHJhbmRvbSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldE93bmVyOiBmdW5jdGlvbiAoY29sb3IsIG93bmVyLCBzZXR0ZXIpIHtcbiAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIGlmIChjb2xvci5fb3duZXIgJiYgb3duZXIgJiYgY29sb3IuX293bmVyICE9PSBvd25lcikge1xuICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY29sb3IuX293bmVyIF4gIW93bmVyKSB7XG4gICAgICAgICAgICAgIGNvbG9yLl9vd25lciA9IG93bmVyIHx8IG51bGw7XG4gICAgICAgICAgICAgIGNvbG9yLl9zZXR0ZXIgPSBzZXR0ZXIgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSgpLCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcGVyYXRvcnMgPSB7XG4gICAgICBhZGQ6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgIH0sXG4gICAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfSxcbiAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgICB9LFxuICAgICAgZGl2aWRlOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAvIGI7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZS5lYWNoKG9wZXJhdG9ycywgZnVuY3Rpb24gKG9wZXJhdG9yLCBuYW1lKSB7XG4gICAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpO1xuXG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudHMxID0gdGhpcy5fY29tcG9uZW50cyxcbiAgICAgICAgICAgIGNvbXBvbmVudHMyID0gY29sb3IuX2NvbnZlcnQodHlwZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb21wb25lbnRzMS5sZW5ndGg7IGkgPCBsOyBpKyspIGNvbXBvbmVudHMyW2ldID0gb3BlcmF0b3IoY29tcG9uZW50czFbaV0sIGNvbXBvbmVudHMyW2ldKTtcblxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKHR5cGUsIGNvbXBvbmVudHMyLCB0aGlzLl9hbHBoYSAhPSBudWxsID8gb3BlcmF0b3IodGhpcy5fYWxwaGEsIGNvbG9yLmdldEFscGhhKCkpIDogbnVsbCk7XG4gICAgICB9O1xuICAgIH0sIHt9KTtcbiAgfSgpKTtcbiAgdmFyIEdyYWRpZW50ID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0dyYWRpZW50JyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudChzdG9wcywgcmFkaWFsKSB7XG4gICAgICB0aGlzLl9pZCA9IFVJRC5nZXQoKTtcblxuICAgICAgaWYgKHN0b3BzICYmIEJhc2UuaXNQbGFpbk9iamVjdChzdG9wcykpIHtcbiAgICAgICAgdGhpcy5zZXQoc3RvcHMpO1xuICAgICAgICBzdG9wcyA9IHJhZGlhbCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zdG9wcyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0U3RvcHMoc3RvcHMgfHwgWyd3aGl0ZScsICdibGFjayddKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JhZGlhbCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaWFsKHR5cGVvZiByYWRpYWwgPT09ICdzdHJpbmcnICYmIHJhZGlhbCA9PT0gJ3JhZGlhbCcgfHwgcmFkaWFsIHx8IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICByZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX3N0b3BzLCB0aGlzLl9yYWRpYWxdLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fb3duZXJzICYmIHRoaXMuX293bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb3duZXJzW2ldLl9jaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfYWRkT3duZXI6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgaWYgKCF0aGlzLl9vd25lcnMpIHRoaXMuX293bmVycyA9IFtdO1xuXG4gICAgICB0aGlzLl9vd25lcnMucHVzaChjb2xvcik7XG4gICAgfSxcbiAgICBfcmVtb3ZlT3duZXI6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fb3duZXJzID8gdGhpcy5fb3duZXJzLmluZGV4T2YoY29sb3IpIDogLTE7XG5cbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICB0aGlzLl9vd25lcnMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICBpZiAoIXRoaXMuX293bmVycy5sZW5ndGgpIHRoaXMuX293bmVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RvcHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc3RvcHNbaV0gPSB0aGlzLl9zdG9wc1tpXS5jbG9uZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEdyYWRpZW50KHN0b3BzLCB0aGlzLl9yYWRpYWwpO1xuICAgIH0sXG4gICAgZ2V0U3RvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wcztcbiAgICB9LFxuICAgIHNldFN0b3BzOiBmdW5jdGlvbiAoc3RvcHMpIHtcbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR3JhZGllbnQgc3RvcCBsaXN0IG5lZWRzIHRvIGNvbnRhaW4gYXQgbGVhc3QgdHdvIHN0b3BzLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3N0b3BzID0gdGhpcy5fc3RvcHM7XG5cbiAgICAgIGlmIChfc3RvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSBfc3RvcHNbaV0uX293bmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBfc3RvcHMgPSB0aGlzLl9zdG9wcyA9IEdyYWRpZW50U3RvcC5yZWFkTGlzdChzdG9wcywgMCwge1xuICAgICAgICBjbG9uZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykgX3N0b3BzW2ldLl9vd25lciA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9LFxuICAgIGdldFJhZGlhbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JhZGlhbDtcbiAgICB9LFxuICAgIHNldFJhZGlhbDogZnVuY3Rpb24gKHJhZGlhbCkge1xuICAgICAgdGhpcy5fcmFkaWFsID0gcmFkaWFsO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChncmFkaWVudCkge1xuICAgICAgaWYgKGdyYWRpZW50ID09PSB0aGlzKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgaWYgKGdyYWRpZW50ICYmIHRoaXMuX2NsYXNzID09PSBncmFkaWVudC5fY2xhc3MpIHtcbiAgICAgICAgdmFyIHN0b3BzMSA9IHRoaXMuX3N0b3BzLFxuICAgICAgICAgICAgc3RvcHMyID0gZ3JhZGllbnQuX3N0b3BzLFxuICAgICAgICAgICAgbGVuZ3RoID0gc3RvcHMxLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuZ3RoID09PSBzdG9wczIubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFzdG9wczFbaV0uZXF1YWxzKHN0b3BzMltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgdmFyIEdyYWRpZW50U3RvcCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdHcmFkaWVudFN0b3AnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50U3RvcChhcmcwLCBhcmcxKSB7XG4gICAgICB2YXIgY29sb3IgPSBhcmcwLFxuICAgICAgICAgIG9mZnNldCA9IGFyZzE7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ29iamVjdCcgJiYgYXJnMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApICYmIHR5cGVvZiBhcmcwWzBdICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvbG9yID0gYXJnMFswXTtcbiAgICAgICAgICBvZmZzZXQgPSBhcmcwWzFdO1xuICAgICAgICB9IGVsc2UgaWYgKCdjb2xvcicgaW4gYXJnMCB8fCAnb2Zmc2V0JyBpbiBhcmcwIHx8ICdyYW1wUG9pbnQnIGluIGFyZzApIHtcbiAgICAgICAgICBjb2xvciA9IGFyZzAuY29sb3I7XG4gICAgICAgICAgb2Zmc2V0ID0gYXJnMC5vZmZzZXQgfHwgYXJnMC5yYW1wUG9pbnQgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldENvbG9yKGNvbG9yKTtcbiAgICAgIHRoaXMuc2V0T2Zmc2V0KG9mZnNldCk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBHcmFkaWVudFN0b3AodGhpcy5fY29sb3IuY2xvbmUoKSwgdGhpcy5fb2Zmc2V0KTtcbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLl9jb2xvcixcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUob2Zmc2V0ID09IG51bGwgPyBbY29sb3JdIDogW2NvbG9yLCBvZmZzZXRdLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fb3duZXIpIHRoaXMuX293bmVyLl9jaGFuZ2VkKDEyOSk7XG4gICAgfSxcbiAgICBnZXRPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gICAgfSxcbiAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH0sXG4gICAgZ2V0UmFtcFBvaW50OiAnI2dldE9mZnNldCcsXG4gICAgc2V0UmFtcFBvaW50OiAnI3NldE9mZnNldCcsXG4gICAgZ2V0Q29sb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgICB9LFxuICAgIHNldENvbG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICBDb2xvci5fc2V0T3duZXIodGhpcy5fY29sb3IsIG51bGwpO1xuXG4gICAgICB0aGlzLl9jb2xvciA9IENvbG9yLl9zZXRPd25lcihDb2xvci5yZWFkKGFyZ3VtZW50cywgMCksIHRoaXMsICdzZXRDb2xvcicpO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICByZXR1cm4gc3RvcCA9PT0gdGhpcyB8fCBzdG9wICYmIHRoaXMuX2NsYXNzID09PSBzdG9wLl9jbGFzcyAmJiB0aGlzLl9jb2xvci5lcXVhbHMoc3RvcC5fY29sb3IpICYmIHRoaXMuX29mZnNldCA9PSBzdG9wLl9vZmZzZXQgfHwgZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgdmFyIFN0eWxlID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXRlbURlZmF1bHRzID0ge1xuICAgICAgZmlsbENvbG9yOiBudWxsLFxuICAgICAgZmlsbFJ1bGU6ICdub256ZXJvJyxcbiAgICAgIHN0cm9rZUNvbG9yOiBudWxsLFxuICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICBzdHJva2VDYXA6ICdidXR0JyxcbiAgICAgIHN0cm9rZUpvaW46ICdtaXRlcicsXG4gICAgICBzdHJva2VTY2FsaW5nOiB0cnVlLFxuICAgICAgbWl0ZXJMaW1pdDogMTAsXG4gICAgICBkYXNoT2Zmc2V0OiAwLFxuICAgICAgZGFzaEFycmF5OiBbXSxcbiAgICAgIHNoYWRvd0NvbG9yOiBudWxsLFxuICAgICAgc2hhZG93Qmx1cjogMCxcbiAgICAgIHNoYWRvd09mZnNldDogbmV3IFBvaW50KCksXG4gICAgICBzZWxlY3RlZENvbG9yOiBudWxsXG4gICAgfSxcbiAgICAgICAgZ3JvdXBEZWZhdWx0cyA9IEJhc2Uuc2V0KHt9LCBpdGVtRGVmYXVsdHMsIHtcbiAgICAgIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcbiAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgbGVhZGluZzogbnVsbCxcbiAgICAgIGp1c3RpZmljYXRpb246ICdsZWZ0J1xuICAgIH0pLFxuICAgICAgICB0ZXh0RGVmYXVsdHMgPSBCYXNlLnNldCh7fSwgZ3JvdXBEZWZhdWx0cywge1xuICAgICAgZmlsbENvbG9yOiBuZXcgQ29sb3IoKVxuICAgIH0pLFxuICAgICAgICBmbGFncyA9IHtcbiAgICAgIHN0cm9rZVdpZHRoOiAxOTMsXG4gICAgICBzdHJva2VDYXA6IDE5MyxcbiAgICAgIHN0cm9rZUpvaW46IDE5MyxcbiAgICAgIHN0cm9rZVNjYWxpbmc6IDIwMSxcbiAgICAgIG1pdGVyTGltaXQ6IDE5MyxcbiAgICAgIGZvbnRGYW1pbHk6IDksXG4gICAgICBmb250V2VpZ2h0OiA5LFxuICAgICAgZm9udFNpemU6IDksXG4gICAgICBmb250OiA5LFxuICAgICAgbGVhZGluZzogOSxcbiAgICAgIGp1c3RpZmljYXRpb246IDlcbiAgICB9LFxuICAgICAgICBpdGVtID0ge1xuICAgICAgYmVhbnM6IHRydWVcbiAgICB9LFxuICAgICAgICBmaWVsZHMgPSB7XG4gICAgICBfY2xhc3M6ICdTdHlsZScsXG4gICAgICBiZWFuczogdHJ1ZSxcbiAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFN0eWxlKHN0eWxlLCBfb3duZXIsIF9wcm9qZWN0KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9vd25lciA9IF9vd25lcjtcbiAgICAgICAgdGhpcy5fcHJvamVjdCA9IF9vd25lciAmJiBfb3duZXIuX3Byb2plY3QgfHwgX3Byb2plY3QgfHwgcGFwZXIucHJvamVjdDtcbiAgICAgICAgdGhpcy5fZGVmYXVsdHMgPSAhX293bmVyIHx8IF9vd25lciBpbnN0YW5jZW9mIEdyb3VwID8gZ3JvdXBEZWZhdWx0cyA6IF9vd25lciBpbnN0YW5jZW9mIFRleHRJdGVtID8gdGV4dERlZmF1bHRzIDogaXRlbURlZmF1bHRzO1xuICAgICAgICBpZiAoc3R5bGUpIHRoaXMuc2V0KHN0eWxlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEJhc2UuZWFjaChncm91cERlZmF1bHRzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFyIGlzQ29sb3IgPSAvQ29sb3IkLy50ZXN0KGtleSksXG4gICAgICAgICAgaXNQb2ludCA9IGtleSA9PT0gJ3NoYWRvd09mZnNldCcsXG4gICAgICAgICAgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuICAgICAgICAgIGZsYWcgPSBmbGFnc1trZXldLFxuICAgICAgICAgIHNldCA9ICdzZXQnICsgcGFydCxcbiAgICAgICAgICBnZXQgPSAnZ2V0JyArIHBhcnQ7XG5cbiAgICAgIGZpZWxkc1tzZXRdID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBvd25lciA9IHRoaXMuX293bmVyLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW4sXG4gICAgICAgICAgICBhcHBseVRvQ2hpbGRyZW4gPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiAwICYmICEob3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpO1xuXG4gICAgICAgIGlmIChhcHBseVRvQ2hpbGRyZW4pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgY2hpbGRyZW5baV0uX3N0eWxlW3NldF0odmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChrZXkgPT09ICdzZWxlY3RlZENvbG9yJyB8fCAhYXBwbHlUb0NoaWxkcmVuKSAmJiBrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcbiAgICAgICAgICB2YXIgb2xkID0gdGhpcy5fdmFsdWVzW2tleV07XG5cbiAgICAgICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzQ29sb3IpIHtcbiAgICAgICAgICAgICAgaWYgKG9sZCkge1xuICAgICAgICAgICAgICAgIENvbG9yLl9zZXRPd25lcihvbGQsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgb2xkLl9jYW52YXNTdHlsZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBDb2xvci5fc2V0T3duZXIodmFsdWUsIG93bmVyLCBhcHBseVRvQ2hpbGRyZW4gJiYgc2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG93bmVyKSBvd25lci5fY2hhbmdlZChmbGFnIHx8IDEyOSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWVsZHNbZ2V0XSA9IGZ1bmN0aW9uIChfZG9udE1lcmdlKSB7XG4gICAgICAgIHZhciBvd25lciA9IHRoaXMuX293bmVyLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW4sXG4gICAgICAgICAgICBhcHBseVRvQ2hpbGRyZW4gPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiAwICYmICEob3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpLFxuICAgICAgICAgICAgdmFsdWU7XG5cbiAgICAgICAgaWYgKGFwcGx5VG9DaGlsZHJlbiAmJiAhX2RvbnRNZXJnZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRWYWx1ZSA9IGNoaWxkcmVuW2ldLl9zdHlsZVtnZXRdKCk7XG5cbiAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGNoaWxkVmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwgY2hpbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWVzW2tleV07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9kZWZhdWx0c1trZXldO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY2xvbmUpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY3RvciA9IGlzQ29sb3IgPyBDb2xvciA6IGlzUG9pbnQgPyBQb2ludCA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChjdG9yICYmICEodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IGN0b3IpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUgPSBjdG9yLnJlYWQoW3ZhbHVlXSwgMCwge1xuICAgICAgICAgICAgICAgIHJlYWROdWxsOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNsb25lOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBpc0NvbG9yKSB7XG4gICAgICAgICAgdmFsdWUgPSBDb2xvci5fc2V0T3duZXIodmFsdWUsIG93bmVyLCBhcHBseVRvQ2hpbGRyZW4gJiYgc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIGl0ZW1bZ2V0XSA9IGZ1bmN0aW9uIChfZG9udE1lcmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZVtnZXRdKF9kb250TWVyZ2UpO1xuICAgICAgfTtcblxuICAgICAgaXRlbVtzZXRdID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3N0eWxlW3NldF0odmFsdWUpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBCYXNlLmVhY2goe1xuICAgICAgRm9udDogJ0ZvbnRGYW1pbHknLFxuICAgICAgV2luZGluZ1J1bGU6ICdGaWxsUnVsZSdcbiAgICB9LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFyIGdldCA9ICdnZXQnICsga2V5LFxuICAgICAgICAgIHNldCA9ICdzZXQnICsga2V5O1xuICAgICAgZmllbGRzW2dldF0gPSBpdGVtW2dldF0gPSAnI2dldCcgKyB2YWx1ZTtcbiAgICAgIGZpZWxkc1tzZXRdID0gaXRlbVtzZXRdID0gJyNzZXQnICsgdmFsdWU7XG4gICAgfSk7XG4gICAgSXRlbS5pbmplY3QoaXRlbSk7XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfSgpLCB7XG4gICAgc2V0OiBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIHZhciBpc1N0eWxlID0gc3R5bGUgaW5zdGFuY2VvZiBTdHlsZSxcbiAgICAgICAgICB2YWx1ZXMgPSBpc1N0eWxlID8gc3R5bGUuX3ZhbHVlcyA6IHN0eWxlO1xuXG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlICYmIGlzU3R5bGUgJiYgdmFsdWUuY2xvbmUgPyB2YWx1ZS5jbG9uZSgpIDogdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgZnVuY3Rpb24gY29tcGFyZShzdHlsZTEsIHN0eWxlMiwgc2Vjb25kYXJ5KSB7XG4gICAgICAgIHZhciB2YWx1ZXMxID0gc3R5bGUxLl92YWx1ZXMsXG4gICAgICAgICAgICB2YWx1ZXMyID0gc3R5bGUyLl92YWx1ZXMsXG4gICAgICAgICAgICBkZWZhdWx0czIgPSBzdHlsZTIuX2RlZmF1bHRzO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMxKSB7XG4gICAgICAgICAgdmFyIHZhbHVlMSA9IHZhbHVlczFba2V5XSxcbiAgICAgICAgICAgICAgdmFsdWUyID0gdmFsdWVzMltrZXldO1xuICAgICAgICAgIGlmICghKHNlY29uZGFyeSAmJiBrZXkgaW4gdmFsdWVzMikgJiYgIUJhc2UuZXF1YWxzKHZhbHVlMSwgdmFsdWUyID09PSB1bmRlZmluZWQgPyBkZWZhdWx0czJba2V5XSA6IHZhbHVlMikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3R5bGUgPT09IHRoaXMgfHwgc3R5bGUgJiYgdGhpcy5fY2xhc3MgPT09IHN0eWxlLl9jbGFzcyAmJiBjb21wYXJlKHRoaXMsIHN0eWxlKSAmJiBjb21wYXJlKHN0eWxlLCB0aGlzLCB0cnVlKSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIF9kaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29sb3I7XG4gICAgICBjb2xvciA9IHRoaXMuZ2V0RmlsbENvbG9yKCk7XG4gICAgICBpZiAoY29sb3IpIGNvbG9yLl9jYW52YXNTdHlsZSA9IG51bGw7XG4gICAgICBjb2xvciA9IHRoaXMuZ2V0U3Ryb2tlQ29sb3IoKTtcbiAgICAgIGlmIChjb2xvcikgY29sb3IuX2NhbnZhc1N0eWxlID0gbnVsbDtcbiAgICAgIGNvbG9yID0gdGhpcy5nZXRTaGFkb3dDb2xvcigpO1xuICAgICAgaWYgKGNvbG9yKSBjb2xvci5fY2FudmFzU3R5bGUgPSBudWxsO1xuICAgIH0sXG4gICAgaGFzRmlsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5nZXRGaWxsQ29sb3IoKTtcbiAgICAgIHJldHVybiAhIWNvbG9yICYmIGNvbG9yLmFscGhhID4gMDtcbiAgICB9LFxuICAgIGhhc1N0cm9rZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5nZXRTdHJva2VDb2xvcigpO1xuICAgICAgcmV0dXJuICEhY29sb3IgJiYgY29sb3IuYWxwaGEgPiAwICYmIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSA+IDA7XG4gICAgfSxcbiAgICBoYXNTaGFkb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0U2hhZG93Q29sb3IoKTtcbiAgICAgIHJldHVybiAhIWNvbG9yICYmIGNvbG9yLmFscGhhID4gMCAmJiAodGhpcy5nZXRTaGFkb3dCbHVyKCkgPiAwIHx8ICF0aGlzLmdldFNoYWRvd09mZnNldCgpLmlzWmVybygpKTtcbiAgICB9LFxuICAgIGdldFZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0Ll92aWV3O1xuICAgIH0sXG4gICAgZ2V0Rm9udFN0eWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGb250V2VpZ2h0KCkgKyAnICcgKyBmb250U2l6ZSArICgvW2Etel0vaS50ZXN0KGZvbnRTaXplICsgJycpID8gJyAnIDogJ3B4ICcpICsgdGhpcy5nZXRGb250RmFtaWx5KCk7XG4gICAgfSxcbiAgICBnZXRGb250OiAnI2dldEZvbnRGYW1pbHknLFxuICAgIHNldEZvbnQ6ICcjc2V0Rm9udEZhbWlseScsXG4gICAgZ2V0TGVhZGluZzogZnVuY3Rpb24gZ2V0TGVhZGluZygpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gZ2V0TGVhZGluZy5iYXNlLmNhbGwodGhpcyksXG4gICAgICAgICAgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICBpZiAoL3B0fGVtfCV8cHgvLnRlc3QoZm9udFNpemUpKSBmb250U2l6ZSA9IHRoaXMuZ2V0VmlldygpLmdldFBpeGVsU2l6ZShmb250U2l6ZSk7XG4gICAgICByZXR1cm4gbGVhZGluZyAhPSBudWxsID8gbGVhZGluZyA6IGZvbnRTaXplICogMS4yO1xuICAgIH1cbiAgfSk7XG4gIHZhciBEb21FbGVtZW50ID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHNldCwgdmFsdWUpIHtcbiAgICAgIHZhciBwcmVmaXhlcyA9IFsnJywgJ3dlYmtpdCcsICdtb3onLCAnTW96JywgJ21zJywgJ28nXSxcbiAgICAgICAgICBzdWZmaXggPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldLFxuICAgICAgICAgICAga2V5ID0gcHJlZml4ID8gcHJlZml4ICsgc3VmZml4IDogbmFtZTtcblxuICAgICAgICBpZiAoa2V5IGluIGVsKSB7XG4gICAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgICAgZWxba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZWxba2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRTdHlsZXM6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgZG9jID0gZWwgJiYgZWwubm9kZVR5cGUgIT09IDkgPyBlbC5vd25lckRvY3VtZW50IDogZWwsXG4gICAgICAgICAgICB2aWV3ID0gZG9jICYmIGRvYy5kZWZhdWx0VmlldztcbiAgICAgICAgcmV0dXJuIHZpZXcgJiYgdmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG4gICAgICB9LFxuICAgICAgZ2V0Qm91bmRzOiBmdW5jdGlvbiAoZWwsIHZpZXdwb3J0KSB7XG4gICAgICAgIHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgYm9keSA9IGRvYy5ib2R5LFxuICAgICAgICAgICAgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICByZWN0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHJlY3QubGVmdCAtIChodG1sLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDApLFxuICAgICAgICAgICAgeSA9IHJlY3QudG9wIC0gKGh0bWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDApO1xuXG4gICAgICAgIGlmICghdmlld3BvcnQpIHtcbiAgICAgICAgICB2YXIgdmlldyA9IGRvYy5kZWZhdWx0VmlldztcbiAgICAgICAgICB4ICs9IHZpZXcucGFnZVhPZmZzZXQgfHwgaHRtbC5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgICB5ICs9IHZpZXcucGFnZVlPZmZzZXQgfHwgaHRtbC5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3A7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB5LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICB9LFxuICAgICAgZ2V0Vmlld3BvcnRCb3VuZHM6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIHZpZXcgPSBkb2MuZGVmYXVsdFZpZXcsXG4gICAgICAgICAgICBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCwgdmlldy5pbm5lcldpZHRoIHx8IGh0bWwuY2xpZW50V2lkdGgsIHZpZXcuaW5uZXJIZWlnaHQgfHwgaHRtbC5jbGllbnRIZWlnaHQpO1xuICAgICAgfSxcbiAgICAgIGdldE9mZnNldDogZnVuY3Rpb24gKGVsLCB2aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHZpZXdwb3J0KS5nZXRQb2ludCgpO1xuICAgICAgfSxcbiAgICAgIGdldFNpemU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHRydWUpLmdldFNpemUoKTtcbiAgICAgIH0sXG4gICAgICBpc0ludmlzaWJsZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBEb21FbGVtZW50LmdldFNpemUoZWwpLmVxdWFscyhuZXcgU2l6ZSgwLCAwKSk7XG4gICAgICB9LFxuICAgICAgaXNJblZpZXc6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gIURvbUVsZW1lbnQuaXNJbnZpc2libGUoZWwpICYmIERvbUVsZW1lbnQuZ2V0Vmlld3BvcnRCb3VuZHMoZWwpLmludGVyc2VjdHMoRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHRydWUpKTtcbiAgICAgIH0sXG4gICAgICBpc0luc2VydGVkOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpO1xuICAgICAgfSxcbiAgICAgIGdldFByZWZpeGVkOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVsICYmIGhhbmRsZVByZWZpeChlbCwgbmFtZSk7XG4gICAgICB9LFxuICAgICAgc2V0UHJlZml4ZWQ6IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSBoYW5kbGVQcmVmaXgoZWwsIGtleSwgdHJ1ZSwgbmFtZVtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHRydWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0oKTtcbiAgdmFyIERvbUV2ZW50ID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKGVsLCBldmVudHMpIHtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuICAgICAgICAgIHZhciBmdW5jID0gZXZlbnRzW3R5cGVdLFxuICAgICAgICAgICAgICBwYXJ0cyA9IHR5cGUuc3BsaXQoL1tcXHMsXSsvZyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gZWwgPT09IGRvY3VtZW50ICYmIChuYW1lID09PSAndG91Y2hzdGFydCcgfHwgbmFtZSA9PT0gJ3RvdWNobW92ZScpID8ge1xuICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgICAgfSA6IGZhbHNlO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsLCBldmVudHMpIHtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuICAgICAgICAgIHZhciBmdW5jID0gZXZlbnRzW3R5cGVdLFxuICAgICAgICAgICAgICBwYXJ0cyA9IHR5cGUuc3BsaXQoL1tcXHMsXSsvZyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihwYXJ0c1tpXSwgZnVuYywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQb2ludDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgcG9zID0gZXZlbnQudGFyZ2V0VG91Y2hlcyA/IGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoID8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXSA6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQ7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHBvcy5wYWdlWCB8fCBwb3MuY2xpZW50WCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LCBwb3MucGFnZVkgfHwgcG9zLmNsaWVudFkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICB9LFxuICAgIGdldFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgfSxcbiAgICBnZXRSZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnRvRWxlbWVudDtcbiAgICB9LFxuICAgIGdldE9mZnNldDogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBEb21FdmVudC5nZXRQb2ludChldmVudCkuc3VidHJhY3QoRG9tRWxlbWVudC5nZXRPZmZzZXQodGFyZ2V0IHx8IERvbUV2ZW50LmdldFRhcmdldChldmVudCkpKTtcbiAgICB9XG4gIH07XG4gIERvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5hdGl2ZVJlcXVlc3QgPSBEb21FbGVtZW50LmdldFByZWZpeGVkKHdpbmRvdywgJ3JlcXVlc3RBbmltYXRpb25GcmFtZScpLFxuICAgICAgICByZXF1ZXN0ZWQgPSBmYWxzZSxcbiAgICAgICAgY2FsbGJhY2tzID0gW10sXG4gICAgICAgIHRpbWVyO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2FsbGJhY2tzKCkge1xuICAgICAgdmFyIGZ1bmN0aW9ucyA9IGNhbGxiYWNrcztcbiAgICAgIGNhbGxiYWNrcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZ1bmN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIGZ1bmN0aW9uc1tpXSgpO1xuXG4gICAgICByZXF1ZXN0ZWQgPSBuYXRpdmVSZXF1ZXN0ICYmIGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICBpZiAocmVxdWVzdGVkKSBuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXG4gICAgICBpZiAobmF0aXZlUmVxdWVzdCkge1xuICAgICAgICBpZiAoIXJlcXVlc3RlZCkge1xuICAgICAgICAgIG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcbiAgICAgICAgICByZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lcikge1xuICAgICAgICB0aW1lciA9IHNldEludGVydmFsKGhhbmRsZUNhbGxiYWNrcywgMTAwMCAvIDYwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG4gIHZhciBWaWV3ID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuICAgIF9jbGFzczogJ1ZpZXcnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFZpZXcocHJvamVjdCwgZWxlbWVudCkge1xuICAgICAgZnVuY3Rpb24gZ2V0U2l6ZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50W25hbWVdIHx8IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldENhbnZhc1NpemUoKSB7XG4gICAgICAgIHZhciBzaXplID0gRG9tRWxlbWVudC5nZXRTaXplKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gc2l6ZS5pc05hTigpIHx8IHNpemUuaXNaZXJvKCkgPyBuZXcgU2l6ZShnZXRTaXplKCd3aWR0aCcpLCBnZXRTaXplKCdoZWlnaHQnKSkgOiBzaXplO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2l6ZTtcblxuICAgICAgaWYgKHdpbmRvdyAmJiBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgIGlmICh0aGlzLl9pZCA9PSBudWxsKSBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLl9pZCA9ICdwYXBlci12aWV3LScgKyBWaWV3Ll9pZCsrKTtcbiAgICAgICAgRG9tRXZlbnQuYWRkKGVsZW1lbnQsIHRoaXMuX3ZpZXdFdmVudHMpO1xuICAgICAgICB2YXIgbm9uZSA9ICdub25lJztcbiAgICAgICAgRG9tRWxlbWVudC5zZXRQcmVmaXhlZChlbGVtZW50LnN0eWxlLCB7XG4gICAgICAgICAgdXNlckRyYWc6IG5vbmUsXG4gICAgICAgICAgdXNlclNlbGVjdDogbm9uZSxcbiAgICAgICAgICB0b3VjaENhbGxvdXQ6IG5vbmUsXG4gICAgICAgICAgY29udGVudFpvb21pbmc6IG5vbmUsXG4gICAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3Jlc2l6ZScpKSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgIERvbUV2ZW50LmFkZCh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyA9IHtcbiAgICAgICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aGF0LnNldFZpZXdTaXplKGdldENhbnZhc1NpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzaXplID0gZ2V0Q2FudmFzU2l6ZSgpO1xuXG4gICAgICAgIGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAnc3RhdHMnKSAmJiB0eXBlb2YgU3RhdHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy5fc3RhdHMgPSBuZXcgU3RhdHMoKTtcbiAgICAgICAgICB2YXIgc3RhdHMgPSB0aGlzLl9zdGF0cy5kb21FbGVtZW50LFxuICAgICAgICAgICAgICBzdHlsZSA9IHN0YXRzLnN0eWxlLFxuICAgICAgICAgICAgICBvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50KTtcbiAgICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IG9mZnNldC54ICsgJ3B4JztcbiAgICAgICAgICBzdHlsZS50b3AgPSBvZmZzZXQueSArICdweCc7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuZXcgU2l6ZShlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuICAgICAgdGhpcy5fc2NvcGUgPSBwcm9qZWN0Ll9zY29wZTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgaWYgKCF0aGlzLl9waXhlbFJhdGlvKSB0aGlzLl9waXhlbFJhdGlvID0gd2luZG93ICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAgIHRoaXMuX3NldEVsZW1lbnRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblxuICAgICAgdGhpcy5fdmlld1NpemUgPSBzaXplO1xuXG4gICAgICBWaWV3Ll92aWV3cy5wdXNoKHRoaXMpO1xuXG4gICAgICBWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdID0gdGhpcztcbiAgICAgICh0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCkpLl9vd25lciA9IHRoaXM7XG4gICAgICBpZiAoIVZpZXcuX2ZvY3VzZWQpIFZpZXcuX2ZvY3VzZWQgPSB0aGlzO1xuICAgICAgdGhpcy5fZnJhbWVJdGVtcyA9IHt9O1xuICAgICAgdGhpcy5fZnJhbWVJdGVtQ291bnQgPSAwO1xuICAgICAgdGhpcy5faXRlbUV2ZW50cyA9IHtcbiAgICAgICAgbmF0aXZlOiB7fSxcbiAgICAgICAgdmlydHVhbDoge31cbiAgICAgIH07XG4gICAgICB0aGlzLl9hdXRvVXBkYXRlID0gIXBhcGVyLmFnZW50Lm5vZGU7XG4gICAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX3Byb2plY3QpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChWaWV3Ll9mb2N1c2VkID09PSB0aGlzKSBWaWV3Ll9mb2N1c2VkID0gbnVsbDtcblxuICAgICAgVmlldy5fdmlld3Muc3BsaWNlKFZpZXcuX3ZpZXdzLmluZGV4T2YodGhpcyksIDEpO1xuXG4gICAgICBkZWxldGUgVmlldy5fdmlld3NCeUlkW3RoaXMuX2lkXTtcbiAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcbiAgICAgIGlmIChwcm9qZWN0Ll92aWV3ID09PSB0aGlzKSBwcm9qZWN0Ll92aWV3ID0gbnVsbDtcbiAgICAgIERvbUV2ZW50LnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcbiAgICAgIERvbUV2ZW50LnJlbW92ZSh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fcHJvamVjdCA9IG51bGw7XG4gICAgICB0aGlzLm9mZignZnJhbWUnKTtcbiAgICAgIHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgX2V2ZW50czogQmFzZS5lYWNoKEl0ZW0uX2l0ZW1IYW5kbGVycy5jb25jYXQoWydvblJlc2l6ZScsICdvbktleURvd24nLCAnb25LZXlVcCddKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRoaXNbbmFtZV0gPSB7fTtcbiAgICB9LCB7XG4gICAgICBvbkZyYW1lOiB7XG4gICAgICAgIGluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgX2FuaW1hdGU6IGZhbHNlLFxuICAgIF90aW1lOiAwLFxuICAgIF9jb3VudDogMCxcbiAgICBnZXRBdXRvVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcbiAgICB9LFxuICAgIHNldEF1dG9VcGRhdGU6IGZ1bmN0aW9uIChhdXRvVXBkYXRlKSB7XG4gICAgICB0aGlzLl9hdXRvVXBkYXRlID0gYXV0b1VwZGF0ZTtcbiAgICAgIGlmIChhdXRvVXBkYXRlKSB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgZHJhdzogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuICAgIHJlcXVlc3RVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fcmVxdWVzdGVkKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgRG9tRXZlbnQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0Ll9yZXF1ZXN0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICh0aGF0Ll9hbmltYXRlKSB7XG4gICAgICAgICAgICB0aGF0LnJlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhhdC5fZWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKCghRG9tRWxlbWVudC5nZXRQcmVmaXhlZChkb2N1bWVudCwgJ2hpZGRlbicpIHx8IFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdrZWVwYWxpdmUnKSA9PT0gJ3RydWUnKSAmJiBEb21FbGVtZW50LmlzSW5WaWV3KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgIHRoYXQuX2hhbmRsZUZyYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoYXQuX2F1dG9VcGRhdGUpIHRoYXQudXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYW5pbWF0ZSA9IHRydWU7XG4gICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hbmltYXRlID0gZmFsc2U7XG4gICAgfSxcbiAgICBfaGFuZGxlRnJhbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHBhcGVyID0gdGhpcy5fc2NvcGU7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDAsXG4gICAgICAgICAgZGVsdGEgPSB0aGlzLl9sYXN0ID8gbm93IC0gdGhpcy5fbGFzdCA6IDA7XG4gICAgICB0aGlzLl9sYXN0ID0gbm93O1xuICAgICAgdGhpcy5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKHtcbiAgICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgICB0aW1lOiB0aGlzLl90aW1lICs9IGRlbHRhLFxuICAgICAgICBjb3VudDogdGhpcy5fY291bnQrK1xuICAgICAgfSkpO1xuICAgICAgaWYgKHRoaXMuX3N0YXRzKSB0aGlzLl9zdGF0cy51cGRhdGUoKTtcbiAgICB9LFxuICAgIF9hbmltYXRlSXRlbTogZnVuY3Rpb24gKGl0ZW0sIGFuaW1hdGUpIHtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuX2ZyYW1lSXRlbXM7XG5cbiAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgIGl0ZW1zW2l0ZW0uX2lkXSA9IHtcbiAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgY291bnQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCsrdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDEpIHRoaXMub24oJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgaXRlbXNbaXRlbS5faWRdO1xuXG4gICAgICAgIGlmICgtLXRoaXMuX2ZyYW1lSXRlbUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5vZmYoJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9oYW5kbGVGcmFtZUl0ZW1zOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fZnJhbWVJdGVtcykge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9mcmFtZUl0ZW1zW2ldO1xuICAgICAgICBlbnRyeS5pdGVtLmVtaXQoJ2ZyYW1lJywgbmV3IEJhc2UoZXZlbnQsIHtcbiAgICAgICAgICB0aW1lOiBlbnRyeS50aW1lICs9IGV2ZW50LmRlbHRhLFxuICAgICAgICAgIGNvdW50OiBlbnRyeS5jb3VudCsrXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9wcm9qZWN0Ll9jaGFuZ2VkKDQwOTcpO1xuXG4gICAgICB0aGlzLl9ib3VuZHMgPSB0aGlzLl9kZWNvbXBvc2VkID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgfSxcbiAgICBnZXRQaXhlbFJhdGlvOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbztcbiAgICB9LFxuICAgIGdldFJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9waXhlbFJhdGlvICogNzI7XG4gICAgfSxcbiAgICBnZXRWaWV3U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcbiAgICAgIHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFZpZXdTaXplJyk7XG4gICAgfSxcbiAgICBzZXRWaWV3U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICBkZWx0YSA9IHNpemUuc3VidHJhY3QodGhpcy5fdmlld1NpemUpO1xuICAgICAgaWYgKGRlbHRhLmlzWmVybygpKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX3NldEVsZW1lbnRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblxuICAgICAgdGhpcy5fdmlld1NpemUuc2V0KHNpemUpO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG5cbiAgICAgIHRoaXMuZW1pdCgncmVzaXplJywge1xuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBkZWx0YTogZGVsdGFcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5fYXV0b1VwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX3NldEVsZW1lbnRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC53aWR0aCAhPT0gd2lkdGgpIGVsZW1lbnQud2lkdGggPSB3aWR0aDtcbiAgICAgICAgaWYgKGVsZW1lbnQuaGVpZ2h0ICE9PSBoZWlnaHQpIGVsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2JvdW5kcykgdGhpcy5fYm91bmRzID0gdGhpcy5fbWF0cml4LmludmVydGVkKCkuX3RyYW5zZm9ybUJvdW5kcyhuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLCB0aGlzLl92aWV3U2l6ZSkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgICB9LFxuICAgIGdldFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldFNpemUoKTtcbiAgICB9LFxuICAgIGlzVmlzaWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIERvbUVsZW1lbnQuaXNJblZpZXcodGhpcy5fZWxlbWVudCk7XG4gICAgfSxcbiAgICBpc0luc2VydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRG9tRWxlbWVudC5pc0luc2VydGVkKHRoaXMuX2VsZW1lbnQpO1xuICAgIH0sXG4gICAgZ2V0UGl4ZWxTaXplOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIHBpeGVscztcblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGVtcC5zdHlsZS5mb250U2l6ZSA9IHNpemU7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0ZW1wKTtcbiAgICAgICAgcGl4ZWxzID0gcGFyc2VGbG9hdChEb21FbGVtZW50LmdldFN0eWxlcyh0ZW1wKS5mb250U2l6ZSk7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0ZW1wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpeGVscyA9IHBhcnNlRmxvYXQocGl4ZWxzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBpeGVscztcbiAgICB9LFxuICAgIGdldFRleHRXaWR0aDogZnVuY3Rpb24gKGZvbnQsIGxpbmVzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIEJhc2UuZWFjaChbJ3JvdGF0ZScsICdzY2FsZScsICdzaGVhcicsICdza2V3J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcm90YXRlID0ga2V5ID09PSAncm90YXRlJztcblxuICAgIHRoaXNba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHZhbHVlID0gKHJvdGF0ZSA/IEJhc2UgOiBQb2ludCkucmVhZChhcmdzKSxcbiAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3MsIDAsIHtcbiAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKVtrZXldKHZhbHVlLCBjZW50ZXIgfHwgdGhpcy5nZXRDZW50ZXIodHJ1ZSkpKTtcbiAgICB9O1xuICB9LCB7XG4gICAgX2RlY29tcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlY29tcG9zZWQgfHwgKHRoaXMuX2RlY29tcG9zZWQgPSB0aGlzLl9tYXRyaXguZGVjb21wb3NlKCkpO1xuICAgIH0sXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbXggPSBuZXcgTWF0cml4KCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obXgudHJhbnNsYXRlLmFwcGx5KG14LCBhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XG4gICAgfSxcbiAgICBzZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSh0aGlzLmdldENlbnRlcigpLnN1YnRyYWN0KGNlbnRlcikpO1xuICAgIH0sXG4gICAgZ2V0Wm9vbTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNjYWxpbmcgPSB0aGlzLl9kZWNvbXBvc2UoKS5zY2FsaW5nO1xuXG4gICAgICByZXR1cm4gKHNjYWxpbmcueCArIHNjYWxpbmcueSkgLyAyO1xuICAgIH0sXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5zY2FsZSh6b29tIC8gdGhpcy5nZXRab29tKCksIHRoaXMuZ2V0Q2VudGVyKCkpKTtcbiAgICB9LFxuICAgIGdldFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVjb21wb3NlKCkucm90YXRpb247XG4gICAgfSxcbiAgICBzZXRSb3RhdGlvbjogZnVuY3Rpb24gKHJvdGF0aW9uKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0Um90YXRpb24oKTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiByb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucm90YXRlKHJvdGF0aW9uIC0gY3VycmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRTY2FsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2NhbGluZyA9IHRoaXMuX2RlY29tcG9zZSgpLnNjYWxpbmc7XG5cbiAgICAgIHJldHVybiBuZXcgTGlua2VkUG9pbnQoc2NhbGluZy54LCBzY2FsaW5nLnksIHRoaXMsICdzZXRTY2FsaW5nJyk7XG4gICAgfSxcbiAgICBzZXRTY2FsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpLFxuICAgICAgICAgIHNjYWxpbmcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwge1xuICAgICAgICBjbG9uZTogdHJ1ZSxcbiAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY3VycmVudCAmJiBzY2FsaW5nKSB7XG4gICAgICAgIHRoaXMuc2NhbGUoc2NhbGluZy54IC8gY3VycmVudC54LCBzY2FsaW5nLnkgLyBjdXJyZW50LnkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TWF0cml4OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF0cml4O1xuICAgIH0sXG4gICAgc2V0TWF0cml4OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuICAgICAgbWF0cml4LnNldC5hcHBseShtYXRyaXgsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgIHRoaXMuX21hdHJpeC5hcHBlbmQobWF0cml4KTtcbiAgICB9LFxuICAgIHNjcm9sbEJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykubmVnYXRlKCkpO1xuICAgIH1cbiAgfSksIHtcbiAgICBwcm9qZWN0VG9WaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgdmlld1RvUHJvamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZ2V0RXZlbnRQb2ludDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3VG9Qcm9qZWN0KERvbUV2ZW50LmdldE9mZnNldChldmVudCwgdGhpcy5fZWxlbWVudCkpO1xuICAgIH1cbiAgfSwge1xuICAgIHN0YXRpY3M6IHtcbiAgICAgIF92aWV3czogW10sXG4gICAgICBfdmlld3NCeUlkOiB7fSxcbiAgICAgIF9pZDogMCxcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKHByb2plY3QsIGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50ICYmIHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuICAgICAgICB2YXIgY3RvciA9IHdpbmRvdyA/IENhbnZhc1ZpZXcgOiBWaWV3O1xuICAgICAgICByZXR1cm4gbmV3IGN0b3IocHJvamVjdCwgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIGlmICghd2luZG93KSByZXR1cm47XG4gICAgdmFyIHByZXZGb2N1cyxcbiAgICAgICAgdGVtcEZvY3VzLFxuICAgICAgICBkcmFnZ2luZyA9IGZhbHNlLFxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGdldFZpZXcoZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgcmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgVmlldy5fdmlld3NCeUlkW3RhcmdldC5nZXRBdHRyaWJ1dGUoJ2lkJyldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZvY3VzKCkge1xuICAgICAgdmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuXG4gICAgICBpZiAoIXZpZXcgfHwgIXZpZXcuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBWaWV3Ll92aWV3cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoKHZpZXcgPSBWaWV3Ll92aWV3c1tpXSkuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIFZpZXcuX2ZvY3VzZWQgPSB0ZW1wRm9jdXMgPSB2aWV3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50LCBwb2ludCkge1xuICAgICAgdmlldy5faGFuZGxlTW91c2VFdmVudCgnbW91c2Vtb3ZlJywgZXZlbnQsIHBvaW50KTtcbiAgICB9XG5cbiAgICB2YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcixcbiAgICAgICAgbW91c2Vkb3duLFxuICAgICAgICBtb3VzZW1vdmUsXG4gICAgICAgIG1vdXNldXA7XG5cbiAgICBpZiAobmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICBtb3VzZWRvd24gPSAncG9pbnRlcmRvd24gTVNQb2ludGVyRG93bic7XG4gICAgICBtb3VzZW1vdmUgPSAncG9pbnRlcm1vdmUgTVNQb2ludGVyTW92ZSc7XG4gICAgICBtb3VzZXVwID0gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdXNlZG93biA9ICd0b3VjaHN0YXJ0JztcbiAgICAgIG1vdXNlbW92ZSA9ICd0b3VjaG1vdmUnO1xuICAgICAgbW91c2V1cCA9ICd0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbiAgICAgIGlmICghKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWR8c2lsay9pKSkpIHtcbiAgICAgICAgbW91c2Vkb3duICs9ICcgbW91c2Vkb3duJztcbiAgICAgICAgbW91c2Vtb3ZlICs9ICcgbW91c2Vtb3ZlJztcbiAgICAgICAgbW91c2V1cCArPSAnIG1vdXNldXAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2aWV3RXZlbnRzID0ge30sXG4gICAgICAgIGRvY0V2ZW50cyA9IHtcbiAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkLFxuICAgICAgICAgICAgdGFyZ2V0ID0gRG9tRXZlbnQuZ2V0UmVsYXRlZFRhcmdldChldmVudCk7XG5cbiAgICAgICAgaWYgKHZpZXcgJiYgKCF0YXJnZXQgfHwgdGFyZ2V0Lm5vZGVOYW1lID09PSAnSFRNTCcpKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IERvbUV2ZW50LmdldE9mZnNldChldmVudCwgdmlldy5fZWxlbWVudCksXG4gICAgICAgICAgICAgIHggPSBvZmZzZXQueCxcbiAgICAgICAgICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgICAgIGF4ID0gYWJzKHgpLFxuICAgICAgICAgICAgICBtYXggPSAxIDw8IDI1LFxuICAgICAgICAgICAgICBkaWZmID0gYXggLSBtYXg7XG4gICAgICAgICAgb2Zmc2V0LnggPSBhYnMoZGlmZikgPCBheCA/IGRpZmYgKiAoeCA8IDAgPyAtMSA6IDEpIDogeDtcbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQsIHZpZXcudmlld1RvUHJvamVjdChvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNjcm9sbDogdXBkYXRlRm9jdXNcbiAgICB9O1xuXG4gICAgdmlld0V2ZW50c1ttb3VzZWRvd25dID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBnZXRWaWV3KGV2ZW50KTtcblxuICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICBkcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgdmlldy5faGFuZGxlTW91c2VFdmVudCgnbW91c2Vkb3duJywgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2NFdmVudHNbbW91c2Vtb3ZlXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuXG4gICAgICBpZiAoIW1vdXNlRG93bikge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0VmlldyhldmVudCk7XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIGlmICh2aWV3ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh2aWV3KSBoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFwcmV2Rm9jdXMpIHByZXZGb2N1cyA9IHZpZXc7XG4gICAgICAgICAgICB2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHRhcmdldDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGVtcEZvY3VzICYmIHRlbXBGb2N1cyA9PT0gdmlldykge1xuICAgICAgICAgIGlmIChwcmV2Rm9jdXMgJiYgIXByZXZGb2N1cy5pc0luc2VydGVkKCkpIHByZXZGb2N1cyA9IG51bGw7XG4gICAgICAgICAgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBwcmV2Rm9jdXM7XG4gICAgICAgICAgcHJldkZvY3VzID0gbnVsbDtcbiAgICAgICAgICB1cGRhdGVGb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2aWV3KSBoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQpO1xuICAgIH07XG5cbiAgICBkb2NFdmVudHNbbW91c2Vkb3duXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgfTtcblxuICAgIGRvY0V2ZW50c1ttb3VzZXVwXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuICAgICAgaWYgKHZpZXcgJiYgZHJhZ2dpbmcpIHZpZXcuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdXNldXAnLCBldmVudCk7XG4gICAgICBtb3VzZURvd24gPSBkcmFnZ2luZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBEb21FdmVudC5hZGQoZG9jdW1lbnQsIGRvY0V2ZW50cyk7XG4gICAgRG9tRXZlbnQuYWRkKHdpbmRvdywge1xuICAgICAgbG9hZDogdXBkYXRlRm9jdXNcbiAgICB9KTtcbiAgICB2YXIgY2FsbGVkID0gZmFsc2UsXG4gICAgICAgIHByZXZlbnRlZCA9IGZhbHNlLFxuICAgICAgICBmYWxsYmFja3MgPSB7XG4gICAgICBkb3VibGVjbGljazogJ2NsaWNrJyxcbiAgICAgIG1vdXNlZHJhZzogJ21vdXNlbW92ZSdcbiAgICB9LFxuICAgICAgICB3YXNJblZpZXcgPSBmYWxzZSxcbiAgICAgICAgb3ZlclZpZXcsXG4gICAgICAgIGRvd25Qb2ludCxcbiAgICAgICAgbGFzdFBvaW50LFxuICAgICAgICBkb3duSXRlbSxcbiAgICAgICAgb3Zlckl0ZW0sXG4gICAgICAgIGRyYWdJdGVtLFxuICAgICAgICBjbGlja0l0ZW0sXG4gICAgICAgIGNsaWNrVGltZSxcbiAgICAgICAgZGJsQ2xpY2s7XG5cbiAgICBmdW5jdGlvbiBlbWl0TW91c2VFdmVudChvYmosIHRhcmdldCwgdHlwZSwgZXZlbnQsIHBvaW50LCBwcmV2UG9pbnQsIHN0b3BJdGVtKSB7XG4gICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlLFxuICAgICAgICAgIG1vdXNlRXZlbnQ7XG5cbiAgICAgIGZ1bmN0aW9uIGVtaXQob2JqLCB0eXBlKSB7XG4gICAgICAgIGlmIChvYmoucmVzcG9uZHModHlwZSkpIHtcbiAgICAgICAgICBpZiAoIW1vdXNlRXZlbnQpIHtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCB8fCBvYmosIHByZXZQb2ludCA/IHBvaW50LnN1YnRyYWN0KHByZXZQb2ludCkgOiBudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob2JqLmVtaXQodHlwZSwgbW91c2VFdmVudCkpIHtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAobW91c2VFdmVudC5wcmV2ZW50ZWQpIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAobW91c2VFdmVudC5zdG9wcGVkKSByZXR1cm4gc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmYWxsYmFjayA9IGZhbGxiYWNrc1t0eXBlXTtcbiAgICAgICAgICBpZiAoZmFsbGJhY2spIHJldHVybiBlbWl0KG9iaiwgZmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChvYmogJiYgb2JqICE9PSBzdG9wSXRlbSkge1xuICAgICAgICBpZiAoZW1pdChvYmosIHR5cGUpKSBicmVhaztcbiAgICAgICAgb2JqID0gb2JqLl9wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9wcGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRNb3VzZUV2ZW50cyh2aWV3LCBoaXRJdGVtLCB0eXBlLCBldmVudCwgcG9pbnQsIHByZXZQb2ludCkge1xuICAgICAgdmlldy5fcHJvamVjdC5yZW1vdmVPbih0eXBlKTtcblxuICAgICAgcHJldmVudGVkID0gY2FsbGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gZHJhZ0l0ZW0gJiYgZW1pdE1vdXNlRXZlbnQoZHJhZ0l0ZW0sIG51bGwsIHR5cGUsIGV2ZW50LCBwb2ludCwgcHJldlBvaW50KSB8fCBoaXRJdGVtICYmIGhpdEl0ZW0gIT09IGRyYWdJdGVtICYmICFoaXRJdGVtLmlzRGVzY2VuZGFudChkcmFnSXRlbSkgJiYgZW1pdE1vdXNlRXZlbnQoaGl0SXRlbSwgbnVsbCwgdHlwZSA9PT0gJ21vdXNlZHJhZycgPyAnbW91c2Vtb3ZlJyA6IHR5cGUsIGV2ZW50LCBwb2ludCwgcHJldlBvaW50LCBkcmFnSXRlbSkgfHwgZW1pdE1vdXNlRXZlbnQodmlldywgZHJhZ0l0ZW0gfHwgaGl0SXRlbSB8fCB2aWV3LCB0eXBlLCBldmVudCwgcG9pbnQsIHByZXZQb2ludCk7XG4gICAgfVxuXG4gICAgdmFyIGl0ZW1FdmVudHNNYXAgPSB7XG4gICAgICBtb3VzZWRvd246IHtcbiAgICAgICAgbW91c2Vkb3duOiAxLFxuICAgICAgICBtb3VzZWRyYWc6IDEsXG4gICAgICAgIGNsaWNrOiAxLFxuICAgICAgICBkb3VibGVjbGljazogMVxuICAgICAgfSxcbiAgICAgIG1vdXNldXA6IHtcbiAgICAgICAgbW91c2V1cDogMSxcbiAgICAgICAgbW91c2VkcmFnOiAxLFxuICAgICAgICBjbGljazogMSxcbiAgICAgICAgZG91YmxlY2xpY2s6IDFcbiAgICAgIH0sXG4gICAgICBtb3VzZW1vdmU6IHtcbiAgICAgICAgbW91c2VkcmFnOiAxLFxuICAgICAgICBtb3VzZW1vdmU6IDEsXG4gICAgICAgIG1vdXNlZW50ZXI6IDEsXG4gICAgICAgIG1vdXNlbGVhdmU6IDFcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBfdmlld0V2ZW50czogdmlld0V2ZW50cyxcbiAgICAgIF9oYW5kbGVNb3VzZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZXZlbnQsIHBvaW50KSB7XG4gICAgICAgIHZhciBpdGVtRXZlbnRzID0gdGhpcy5faXRlbUV2ZW50cyxcbiAgICAgICAgICAgIGhpdEl0ZW1zID0gaXRlbUV2ZW50cy5uYXRpdmVbdHlwZV0sXG4gICAgICAgICAgICBuYXRpdmVNb3ZlID0gdHlwZSA9PT0gJ21vdXNlbW92ZScsXG4gICAgICAgICAgICB0b29sID0gdGhpcy5fc2NvcGUudG9vbCxcbiAgICAgICAgICAgIHZpZXcgPSB0aGlzO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlc3BvbmRzKHR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbUV2ZW50cy52aXJ0dWFsW3R5cGVdIHx8IHZpZXcucmVzcG9uZHModHlwZSkgfHwgdG9vbCAmJiB0b29sLnJlc3BvbmRzKHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hdGl2ZU1vdmUgJiYgZHJhZ2dpbmcgJiYgcmVzcG9uZHMoJ21vdXNlZHJhZycpKSB0eXBlID0gJ21vdXNlZHJhZyc7XG4gICAgICAgIGlmICghcG9pbnQpIHBvaW50ID0gdGhpcy5nZXRFdmVudFBvaW50KGV2ZW50KTtcblxuICAgICAgICB2YXIgaW5WaWV3ID0gdGhpcy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludCksXG4gICAgICAgICAgICBoaXQgPSBoaXRJdGVtcyAmJiBpblZpZXcgJiYgdmlldy5fcHJvamVjdC5oaXRUZXN0KHBvaW50LCB7XG4gICAgICAgICAgdG9sZXJhbmNlOiAwLFxuICAgICAgICAgIGZpbGw6IHRydWUsXG4gICAgICAgICAgc3Ryb2tlOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgaGl0SXRlbSA9IGhpdCAmJiBoaXQuaXRlbSB8fCBudWxsLFxuICAgICAgICAgICAgaGFuZGxlID0gZmFsc2UsXG4gICAgICAgICAgICBtb3VzZSA9IHt9O1xuXG4gICAgICAgIG1vdXNlW3R5cGUuc3Vic3RyKDUpXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGhpdEl0ZW1zICYmIGhpdEl0ZW0gIT09IG92ZXJJdGVtKSB7XG4gICAgICAgICAgaWYgKG92ZXJJdGVtKSB7XG4gICAgICAgICAgICBlbWl0TW91c2VFdmVudChvdmVySXRlbSwgbnVsbCwgJ21vdXNlbGVhdmUnLCBldmVudCwgcG9pbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoaXRJdGVtKSB7XG4gICAgICAgICAgICBlbWl0TW91c2VFdmVudChoaXRJdGVtLCBudWxsLCAnbW91c2VlbnRlcicsIGV2ZW50LCBwb2ludCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3Zlckl0ZW0gPSBoaXRJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdhc0luVmlldyBeIGluVmlldykge1xuICAgICAgICAgIGVtaXRNb3VzZUV2ZW50KHRoaXMsIG51bGwsIGluVmlldyA/ICdtb3VzZWVudGVyJyA6ICdtb3VzZWxlYXZlJywgZXZlbnQsIHBvaW50KTtcbiAgICAgICAgICBvdmVyVmlldyA9IGluVmlldyA/IHRoaXMgOiBudWxsO1xuICAgICAgICAgIGhhbmRsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGluVmlldyB8fCBtb3VzZS5kcmFnKSAmJiAhcG9pbnQuZXF1YWxzKGxhc3RQb2ludCkpIHtcbiAgICAgICAgICBlbWl0TW91c2VFdmVudHModGhpcywgaGl0SXRlbSwgbmF0aXZlTW92ZSA/IHR5cGUgOiAnbW91c2Vtb3ZlJywgZXZlbnQsIHBvaW50LCBsYXN0UG9pbnQpO1xuICAgICAgICAgIGhhbmRsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB3YXNJblZpZXcgPSBpblZpZXc7XG5cbiAgICAgICAgaWYgKG1vdXNlLmRvd24gJiYgaW5WaWV3IHx8IG1vdXNlLnVwICYmIGRvd25Qb2ludCkge1xuICAgICAgICAgIGVtaXRNb3VzZUV2ZW50cyh0aGlzLCBoaXRJdGVtLCB0eXBlLCBldmVudCwgcG9pbnQsIGRvd25Qb2ludCk7XG5cbiAgICAgICAgICBpZiAobW91c2UuZG93bikge1xuICAgICAgICAgICAgZGJsQ2xpY2sgPSBoaXRJdGVtID09PSBjbGlja0l0ZW0gJiYgRGF0ZS5ub3coKSAtIGNsaWNrVGltZSA8IDMwMDtcbiAgICAgICAgICAgIGRvd25JdGVtID0gY2xpY2tJdGVtID0gaGl0SXRlbTtcblxuICAgICAgICAgICAgaWYgKCFwcmV2ZW50ZWQgJiYgaGl0SXRlbSkge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IGhpdEl0ZW07XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGl0ZW0gJiYgIWl0ZW0ucmVzcG9uZHMoJ21vdXNlZHJhZycpKSBpdGVtID0gaXRlbS5fcGFyZW50O1xuXG4gICAgICAgICAgICAgIGlmIChpdGVtKSBkcmFnSXRlbSA9IGhpdEl0ZW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvd25Qb2ludCA9IHBvaW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAobW91c2UudXApIHtcbiAgICAgICAgICAgIGlmICghcHJldmVudGVkICYmIGhpdEl0ZW0gPT09IGRvd25JdGVtKSB7XG4gICAgICAgICAgICAgIGNsaWNrVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgIGVtaXRNb3VzZUV2ZW50cyh0aGlzLCBoaXRJdGVtLCBkYmxDbGljayA/ICdkb3VibGVjbGljaycgOiAnY2xpY2snLCBldmVudCwgcG9pbnQsIGRvd25Qb2ludCk7XG4gICAgICAgICAgICAgIGRibENsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvd25JdGVtID0gZHJhZ0l0ZW0gPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdhc0luVmlldyA9IGZhbHNlO1xuICAgICAgICAgIGhhbmRsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UG9pbnQgPSBwb2ludDtcblxuICAgICAgICBpZiAoaGFuZGxlICYmIHRvb2wpIHtcbiAgICAgICAgICBjYWxsZWQgPSB0b29sLl9oYW5kbGVNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgbW91c2UpIHx8IGNhbGxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlICE9PSBmYWxzZSAmJiAoY2FsbGVkICYmICFtb3VzZS5tb3ZlIHx8IG1vdXNlLmRvd24gJiYgcmVzcG9uZHMoJ21vdXNldXAnKSkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2hhbmRsZUtleUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZXZlbnQsIGtleSwgY2hhcmFjdGVyKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMuX3Njb3BlLFxuICAgICAgICAgICAgdG9vbCA9IHNjb3BlLnRvb2wsXG4gICAgICAgICAgICBrZXlFdmVudDtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KG9iaikge1xuICAgICAgICAgIGlmIChvYmoucmVzcG9uZHModHlwZSkpIHtcbiAgICAgICAgICAgIHBhcGVyID0gc2NvcGU7XG4gICAgICAgICAgICBvYmouZW1pdCh0eXBlLCBrZXlFdmVudCA9IGtleUV2ZW50IHx8IG5ldyBLZXlFdmVudCh0eXBlLCBldmVudCwga2V5LCBjaGFyYWN0ZXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgIGVtaXQodGhpcyk7XG4gICAgICAgICAgaWYgKHRvb2wgJiYgdG9vbC5yZXNwb25kcyh0eXBlKSkgZW1pdCh0b29sKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jb3VudEl0ZW1FdmVudDogZnVuY3Rpb24gKHR5cGUsIHNpZ24pIHtcbiAgICAgICAgdmFyIGl0ZW1FdmVudHMgPSB0aGlzLl9pdGVtRXZlbnRzLFxuICAgICAgICAgICAgbmF0aXZlID0gaXRlbUV2ZW50cy5uYXRpdmUsXG4gICAgICAgICAgICB2aXJ0dWFsID0gaXRlbUV2ZW50cy52aXJ0dWFsO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBpdGVtRXZlbnRzTWFwKSB7XG4gICAgICAgICAgbmF0aXZlW2tleV0gPSAobmF0aXZlW2tleV0gfHwgMCkgKyAoaXRlbUV2ZW50c01hcFtrZXldW3R5cGVdIHx8IDApICogc2lnbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpcnR1YWxbdHlwZV0gPSAodmlydHVhbFt0eXBlXSB8fCAwKSArIHNpZ247XG4gICAgICB9LFxuICAgICAgc3RhdGljczoge1xuICAgICAgICB1cGRhdGVGb2N1czogdXBkYXRlRm9jdXMsXG4gICAgICAgIF9yZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZHJhZ2dpbmcgPSBtb3VzZURvd24gPSBjYWxsZWQgPSB3YXNJblZpZXcgPSBmYWxzZTtcbiAgICAgICAgICBwcmV2Rm9jdXMgPSB0ZW1wRm9jdXMgPSBvdmVyVmlldyA9IGRvd25Qb2ludCA9IGxhc3RQb2ludCA9IGRvd25JdGVtID0gb3Zlckl0ZW0gPSBkcmFnSXRlbSA9IGNsaWNrSXRlbSA9IGNsaWNrVGltZSA9IGRibENsaWNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0oKSk7XG4gIHZhciBDYW52YXNWaWV3ID0gVmlldy5leHRlbmQoe1xuICAgIF9jbGFzczogJ0NhbnZhc1ZpZXcnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIENhbnZhc1ZpZXcocHJvamVjdCwgY2FudmFzKSB7XG4gICAgICBpZiAoIShjYW52YXMgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQpKSB7XG4gICAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGlmIChzaXplLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgQ2FudmFzVmlldyB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudDogJyArIEJhc2Uuc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IHRoaXMuX2NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9waXhlbFJhdGlvID0gMTtcblxuICAgICAgaWYgKCEvXm9mZnxmYWxzZSQvLnRlc3QoUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoY2FudmFzLCAnaGlkcGknKSkpIHtcbiAgICAgICAgdmFyIGRldmljZVJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgICAgIGJhY2tpbmdTdG9yZVJhdGlvID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZChjdHgsICdiYWNraW5nU3RvcmVQaXhlbFJhdGlvJykgfHwgMTtcbiAgICAgICAgdGhpcy5fcGl4ZWxSYXRpbyA9IGRldmljZVJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICB9XG5cbiAgICAgIFZpZXcuY2FsbCh0aGlzLCBwcm9qZWN0LCBjYW52YXMpO1xuICAgICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgcmV0dXJuIHJlbW92ZS5iYXNlLmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBfc2V0RWxlbWVudFNpemU6IGZ1bmN0aW9uIF9zZXRFbGVtZW50U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMuX3BpeGVsUmF0aW87XG5cbiAgICAgIF9zZXRFbGVtZW50U2l6ZS5iYXNlLmNhbGwodGhpcywgd2lkdGggKiBwaXhlbFJhdGlvLCBoZWlnaHQgKiBwaXhlbFJhdGlvKTtcblxuICAgICAgaWYgKHBpeGVsUmF0aW8gIT09IDEpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fY29udGV4dDtcblxuICAgICAgICBpZiAoIVBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdyZXNpemUnKSkge1xuICAgICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICAgIH0sXG4gICAgZ2V0UGl4ZWxTaXplOiBmdW5jdGlvbiBnZXRQaXhlbFNpemUoc2l6ZSkge1xuICAgICAgdmFyIGFnZW50ID0gcGFwZXIuYWdlbnQsXG4gICAgICAgICAgcGl4ZWxzO1xuXG4gICAgICBpZiAoYWdlbnQgJiYgYWdlbnQuZmlyZWZveCkge1xuICAgICAgICBwaXhlbHMgPSBnZXRQaXhlbFNpemUuYmFzZS5jYWxsKHRoaXMsIHNpemUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG4gICAgICAgICAgICBwcmV2Rm9udCA9IGN0eC5mb250O1xuICAgICAgICBjdHguZm9udCA9IHNpemUgKyAnIHNlcmlmJztcbiAgICAgICAgcGl4ZWxzID0gcGFyc2VGbG9hdChjdHguZm9udCk7XG4gICAgICAgIGN0eC5mb250ID0gcHJldkZvbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwaXhlbHM7XG4gICAgfSxcbiAgICBnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uIChmb250LCBsaW5lcykge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG4gICAgICAgICAgcHJldkZvbnQgPSBjdHguZm9udCxcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICBjdHguZm9udCA9IGZvbnQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoKTtcblxuICAgICAgY3R4LmZvbnQgPSBwcmV2Rm9udDtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9uZWVkc1VwZGF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuICAgICAgICAgIGN0eCA9IHRoaXMuX2NvbnRleHQsXG4gICAgICAgICAgc2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoICsgMSwgc2l6ZS5oZWlnaHQgKyAxKTtcbiAgICAgIGlmIChwcm9qZWN0KSBwcm9qZWN0LmRyYXcoY3R4LCB0aGlzLl9tYXRyaXgsIHRoaXMuX3BpeGVsUmF0aW8pO1xuICAgICAgdGhpcy5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBFdmVudCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdFdmVudCcsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gRXZlbnQoZXZlbnQpIHtcbiAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgIHRoaXMudHlwZSA9IGV2ZW50ICYmIGV2ZW50LnR5cGU7XG4gICAgfSxcbiAgICBwcmV2ZW50ZWQ6IGZhbHNlLFxuICAgIHN0b3BwZWQ6IGZhbHNlLFxuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICB0aGlzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICB0aGlzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHRoaXMucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuICAgIGdldFRpbWVTdGFtcDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnQudGltZVN0YW1wO1xuICAgIH0sXG4gICAgZ2V0TW9kaWZpZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gS2V5Lm1vZGlmaWVycztcbiAgICB9XG4gIH0pO1xuICB2YXIgS2V5RXZlbnQgPSBFdmVudC5leHRlbmQoe1xuICAgIF9jbGFzczogJ0tleUV2ZW50JyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBLZXlFdmVudCh0eXBlLCBldmVudCwga2V5LCBjaGFyYWN0ZXIpIHtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlICsgXCInLCBrZXk6ICdcIiArIHRoaXMua2V5ICsgXCInLCBjaGFyYWN0ZXI6ICdcIiArIHRoaXMuY2hhcmFjdGVyICsgXCInLCBtb2RpZmllcnM6IFwiICsgdGhpcy5nZXRNb2RpZmllcnMoKSArIFwiIH1cIjtcbiAgICB9XG4gIH0pO1xuICB2YXIgS2V5ID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIga2V5TG9va3VwID0ge1xuICAgICAgJ1xcdCc6ICd0YWInLFxuICAgICAgJyAnOiAnc3BhY2UnLFxuICAgICAgJ1xcYic6ICdiYWNrc3BhY2UnLFxuICAgICAgJ1xceDdmJzogJ2RlbGV0ZScsXG4gICAgICAnU3BhY2ViYXInOiAnc3BhY2UnLFxuICAgICAgJ0RlbCc6ICdkZWxldGUnLFxuICAgICAgJ1dpbic6ICdtZXRhJyxcbiAgICAgICdFc2MnOiAnZXNjYXBlJ1xuICAgIH0sXG4gICAgICAgIGNoYXJMb29rdXAgPSB7XG4gICAgICAndGFiJzogJ1xcdCcsXG4gICAgICAnc3BhY2UnOiAnICcsXG4gICAgICAnZW50ZXInOiAnXFxyJ1xuICAgIH0sXG4gICAgICAgIGtleU1hcCA9IHt9LFxuICAgICAgICBjaGFyTWFwID0ge30sXG4gICAgICAgIG1ldGFGaXhNYXAsXG4gICAgICAgIGRvd25LZXksXG4gICAgICAgIG1vZGlmaWVycyA9IG5ldyBCYXNlKHtcbiAgICAgIHNoaWZ0OiBmYWxzZSxcbiAgICAgIGNvbnRyb2w6IGZhbHNlLFxuICAgICAgYWx0OiBmYWxzZSxcbiAgICAgIG1ldGE6IGZhbHNlLFxuICAgICAgY2Fwc0xvY2s6IGZhbHNlLFxuICAgICAgc3BhY2U6IGZhbHNlXG4gICAgfSkuaW5qZWN0KHtcbiAgICAgIG9wdGlvbjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hbHQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb21tYW5kOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhZ2VudCA9IHBhcGVyICYmIHBhcGVyLmFnZW50O1xuICAgICAgICAgIHJldHVybiBhZ2VudCAmJiBhZ2VudC5tYWMgPyB0aGlzLm1ldGEgOiB0aGlzLmNvbnRyb2w7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdldEtleShldmVudCkge1xuICAgICAgdmFyIGtleSA9IGV2ZW50LmtleSB8fCBldmVudC5rZXlJZGVudGlmaWVyO1xuICAgICAga2V5ID0gL15VXFwrLy50ZXN0KGtleSkgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGtleS5zdWJzdHIoMiksIDE2KSkgOiAvXkFycm93W0EtWl0vLnRlc3Qoa2V5KSA/IGtleS5zdWJzdHIoNSkgOiBrZXkgPT09ICdVbmlkZW50aWZpZWQnIHx8IGtleSA9PT0gdW5kZWZpbmVkID8gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5rZXlDb2RlKSA6IGtleTtcbiAgICAgIHJldHVybiBrZXlMb29rdXBba2V5XSB8fCAoa2V5Lmxlbmd0aCA+IDEgPyBCYXNlLmh5cGhlbmF0ZShrZXkpIDoga2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUtleShkb3duLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpIHtcbiAgICAgIHZhciB0eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCcsXG4gICAgICAgICAgdmlldyA9IFZpZXcuX2ZvY3VzZWQsXG4gICAgICAgICAgbmFtZTtcbiAgICAgIGtleU1hcFtrZXldID0gZG93bjtcblxuICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgY2hhck1hcFtrZXldID0gY2hhcmFjdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGNoYXJNYXBba2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleS5sZW5ndGggPiAxICYmIChuYW1lID0gQmFzZS5jYW1lbGl6ZShrZXkpKSBpbiBtb2RpZmllcnMpIHtcbiAgICAgICAgbW9kaWZpZXJzW25hbWVdID0gZG93bjtcbiAgICAgICAgdmFyIGFnZW50ID0gcGFwZXIgJiYgcGFwZXIuYWdlbnQ7XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdtZXRhJyAmJiBhZ2VudCAmJiBhZ2VudC5tYWMpIHtcbiAgICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgICAgbWV0YUZpeE1hcCA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG1ldGFGaXhNYXApIHtcbiAgICAgICAgICAgICAgaWYgKGsgaW4gY2hhck1hcCkgaGFuZGxlS2V5KGZhbHNlLCBrLCBtZXRhRml4TWFwW2tdLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1ldGFGaXhNYXAgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkb3duICYmIG1ldGFGaXhNYXApIHtcbiAgICAgICAgbWV0YUZpeE1hcFtrZXldID0gY2hhcmFjdGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlldykge1xuICAgICAgICB2aWV3Ll9oYW5kbGVLZXlFdmVudChkb3duID8gJ2tleWRvd24nIDogJ2tleXVwJywgZXZlbnQsIGtleSwgY2hhcmFjdGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBEb21FdmVudC5hZGQoZG9jdW1lbnQsIHtcbiAgICAgIGtleWRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIga2V5ID0gZ2V0S2V5KGV2ZW50KSxcbiAgICAgICAgICAgIGFnZW50ID0gcGFwZXIgJiYgcGFwZXIuYWdlbnQ7XG5cbiAgICAgICAgaWYgKGtleS5sZW5ndGggPiAxIHx8IGFnZW50ICYmIGFnZW50LmNocm9tZSAmJiAoZXZlbnQuYWx0S2V5IHx8IGFnZW50Lm1hYyAmJiBldmVudC5tZXRhS2V5IHx8ICFhZ2VudC5tYWMgJiYgZXZlbnQuY3RybEtleSkpIHtcbiAgICAgICAgICBoYW5kbGVLZXkodHJ1ZSwga2V5LCBjaGFyTG9va3VwW2tleV0gfHwgKGtleS5sZW5ndGggPiAxID8gJycgOiBrZXkpLCBldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG93bktleSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGtleXByZXNzOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGRvd25LZXkpIHtcbiAgICAgICAgICB2YXIga2V5ID0gZ2V0S2V5KGV2ZW50KSxcbiAgICAgICAgICAgICAgY29kZSA9IGV2ZW50LmNoYXJDb2RlLFxuICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSBjb2RlID49IDMyID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IGtleS5sZW5ndGggPiAxID8gJycgOiBrZXk7XG5cbiAgICAgICAgICBpZiAoa2V5ICE9PSBkb3duS2V5KSB7XG4gICAgICAgICAgICBrZXkgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVLZXkodHJ1ZSwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KTtcbiAgICAgICAgICBkb3duS2V5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGtleXVwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IGdldEtleShldmVudCk7XG4gICAgICAgIGlmIChrZXkgaW4gY2hhck1hcCkgaGFuZGxlS2V5KGZhbHNlLCBrZXksIGNoYXJNYXBba2V5XSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIERvbUV2ZW50LmFkZCh3aW5kb3csIHtcbiAgICAgIGJsdXI6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2hhck1hcCkgaGFuZGxlS2V5KGZhbHNlLCBrZXksIGNoYXJNYXBba2V5XSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllcnM6IG1vZGlmaWVycyxcbiAgICAgIGlzRG93bjogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gISFrZXlNYXBba2V5XTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG4gIHZhciBNb3VzZUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdNb3VzZUV2ZW50JyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBkZWx0YSkge1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlICsgXCInLCBwb2ludDogXCIgKyB0aGlzLnBvaW50ICsgJywgdGFyZ2V0OiAnICsgdGhpcy50YXJnZXQgKyAodGhpcy5kZWx0YSA/ICcsIGRlbHRhOiAnICsgdGhpcy5kZWx0YSA6ICcnKSArICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKCkgKyAnIH0nO1xuICAgIH1cbiAgfSk7XG4gIHZhciBUb29sRXZlbnQgPSBFdmVudC5leHRlbmQoe1xuICAgIF9jbGFzczogJ1Rvb2xFdmVudCcsXG4gICAgX2l0ZW06IG51bGwsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gVG9vbEV2ZW50KHRvb2wsIHR5cGUsIGV2ZW50KSB7XG4gICAgICB0aGlzLnRvb2wgPSB0b29sO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICB9LFxuICAgIF9jaG9vc2VQb2ludDogZnVuY3Rpb24gKHBvaW50LCB0b29sUG9pbnQpIHtcbiAgICAgIHJldHVybiBwb2ludCA/IHBvaW50IDogdG9vbFBvaW50ID8gdG9vbFBvaW50LmNsb25lKCkgOiBudWxsO1xuICAgIH0sXG4gICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9wb2ludCwgdGhpcy50b29sLl9wb2ludCk7XG4gICAgfSxcbiAgICBzZXRQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB0aGlzLl9wb2ludCA9IHBvaW50O1xuICAgIH0sXG4gICAgZ2V0TGFzdFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fbGFzdFBvaW50LCB0aGlzLnRvb2wuX2xhc3RQb2ludCk7XG4gICAgfSxcbiAgICBzZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uIChsYXN0UG9pbnQpIHtcbiAgICAgIHRoaXMuX2xhc3RQb2ludCA9IGxhc3RQb2ludDtcbiAgICB9LFxuICAgIGdldERvd25Qb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2Rvd25Qb2ludCwgdGhpcy50b29sLl9kb3duUG9pbnQpO1xuICAgIH0sXG4gICAgc2V0RG93blBvaW50OiBmdW5jdGlvbiAoZG93blBvaW50KSB7XG4gICAgICB0aGlzLl9kb3duUG9pbnQgPSBkb3duUG9pbnQ7XG4gICAgfSxcbiAgICBnZXRNaWRkbGVQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9taWRkbGVQb2ludCAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b29sLl9wb2ludC5hZGQodGhpcy50b29sLl9sYXN0UG9pbnQpLmRpdmlkZSgyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX21pZGRsZVBvaW50O1xuICAgIH0sXG4gICAgc2V0TWlkZGxlUG9pbnQ6IGZ1bmN0aW9uIChtaWRkbGVQb2ludCkge1xuICAgICAgdGhpcy5fbWlkZGxlUG9pbnQgPSBtaWRkbGVQb2ludDtcbiAgICB9LFxuICAgIGdldERlbHRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2RlbHRhICYmIHRoaXMudG9vbC5fbGFzdFBvaW50ID8gdGhpcy50b29sLl9wb2ludC5zdWJ0cmFjdCh0aGlzLnRvb2wuX2xhc3RQb2ludCkgOiB0aGlzLl9kZWx0YTtcbiAgICB9LFxuICAgIHNldERlbHRhOiBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgIHRoaXMuX2RlbHRhID0gZGVsdGE7XG4gICAgfSxcbiAgICBnZXRDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9vbFsvXm1vdXNlKGRvd258dXApJC8udGVzdCh0aGlzLnR5cGUpID8gJ19kb3duQ291bnQnIDogJ19tb3ZlQ291bnQnXTtcbiAgICB9LFxuICAgIHNldENvdW50OiBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgIHRoaXMudG9vbFsvXm1vdXNlKGRvd258dXApJC8udGVzdCh0aGlzLnR5cGUpID8gJ2Rvd25Db3VudCcgOiAnY291bnQnXSA9IGNvdW50O1xuICAgIH0sXG4gICAgZ2V0SXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9pdGVtKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnRvb2wuX3Njb3BlLnByb2plY3QuaGl0VGVzdCh0aGlzLmdldFBvaW50KCkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHJlc3VsdC5pdGVtLFxuICAgICAgICAgICAgICBwYXJlbnQgPSBpdGVtLl9wYXJlbnQ7XG5cbiAgICAgICAgICB3aGlsZSAoL14oR3JvdXB8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcykpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBwYXJlbnQ7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9pdGVtID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5faXRlbTtcbiAgICB9LFxuICAgIHNldEl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB0aGlzLl9pdGVtID0gaXRlbTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ3sgdHlwZTogJyArIHRoaXMudHlwZSArICcsIHBvaW50OiAnICsgdGhpcy5nZXRQb2ludCgpICsgJywgY291bnQ6ICcgKyB0aGlzLmdldENvdW50KCkgKyAnLCBtb2RpZmllcnM6ICcgKyB0aGlzLmdldE1vZGlmaWVycygpICsgJyB9JztcbiAgICB9XG4gIH0pO1xuICB2YXIgVG9vbCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnVG9vbCcsXG4gICAgX2xpc3Q6ICd0b29scycsXG4gICAgX3JlZmVyZW5jZTogJ3Rvb2wnLFxuICAgIF9ldmVudHM6IFsnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uTW91c2VNb3ZlJywgJ29uQWN0aXZhdGUnLCAnb25EZWFjdGl2YXRlJywgJ29uRWRpdE9wdGlvbnMnLCAnb25LZXlEb3duJywgJ29uS2V5VXAnXSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBUb29sKHByb3BzKSB7XG4gICAgICBQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5fbW92ZUNvdW50ID0gLTE7XG4gICAgICB0aGlzLl9kb3duQ291bnQgPSAtMTtcbiAgICAgIHRoaXMuc2V0KHByb3BzKTtcbiAgICB9LFxuICAgIGdldE1pbkRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWluRGlzdGFuY2U7XG4gICAgfSxcbiAgICBzZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24gKG1pbkRpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9taW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuXG4gICAgICBpZiAobWluRGlzdGFuY2UgIT0gbnVsbCAmJiB0aGlzLl9tYXhEaXN0YW5jZSAhPSBudWxsICYmIG1pbkRpc3RhbmNlID4gdGhpcy5fbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fbWF4RGlzdGFuY2UgPSBtaW5EaXN0YW5jZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldE1heERpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF4RGlzdGFuY2U7XG4gICAgfSxcbiAgICBzZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24gKG1heERpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXG4gICAgICBpZiAodGhpcy5fbWluRGlzdGFuY2UgIT0gbnVsbCAmJiBtYXhEaXN0YW5jZSAhPSBudWxsICYmIG1heERpc3RhbmNlIDwgdGhpcy5fbWluRGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fbWluRGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taW5EaXN0YW5jZSA9PSB0aGlzLl9tYXhEaXN0YW5jZSA/IHRoaXMuX21pbkRpc3RhbmNlIDogbnVsbDtcbiAgICB9LFxuICAgIHNldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgICAgdGhpcy5fbWluRGlzdGFuY2UgPSB0aGlzLl9tYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0sXG4gICAgX2hhbmRsZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBldmVudCwgcG9pbnQsIG1vdXNlKSB7XG4gICAgICBwYXBlciA9IHRoaXMuX3Njb3BlO1xuICAgICAgaWYgKG1vdXNlLmRyYWcgJiYgIXRoaXMucmVzcG9uZHModHlwZSkpIHR5cGUgPSAnbW91c2Vtb3ZlJztcbiAgICAgIHZhciBtb3ZlID0gbW91c2UubW92ZSB8fCBtb3VzZS5kcmFnLFxuICAgICAgICAgIHJlc3BvbmRzID0gdGhpcy5yZXNwb25kcyh0eXBlKSxcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IHRoaXMubWluRGlzdGFuY2UsXG4gICAgICAgICAgbWF4RGlzdGFuY2UgPSB0aGlzLm1heERpc3RhbmNlLFxuICAgICAgICAgIGNhbGxlZCA9IGZhbHNlLFxuICAgICAgICAgIHRvb2wgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUobWluRGlzdGFuY2UsIG1heERpc3RhbmNlKSB7XG4gICAgICAgIHZhciBwdCA9IHBvaW50LFxuICAgICAgICAgICAgdG9vbFBvaW50ID0gbW92ZSA/IHRvb2wuX3BvaW50IDogdG9vbC5fZG93blBvaW50IHx8IHB0O1xuXG4gICAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgICAgaWYgKHRvb2wuX21vdmVDb3VudCA+PSAwICYmIHB0LmVxdWFscyh0b29sUG9pbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRvb2xQb2ludCAmJiAobWluRGlzdGFuY2UgIT0gbnVsbCB8fCBtYXhEaXN0YW5jZSAhPSBudWxsKSkge1xuICAgICAgICAgICAgdmFyIHZlY3RvciA9IHB0LnN1YnRyYWN0KHRvb2xQb2ludCksXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSB2ZWN0b3IuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAobWluRGlzdGFuY2UgfHwgMCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKG1heERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIHB0ID0gdG9vbFBvaW50LmFkZCh2ZWN0b3Iubm9ybWFsaXplKE1hdGgubWluKGRpc3RhbmNlLCBtYXhEaXN0YW5jZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b29sLl9tb3ZlQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRvb2wuX3BvaW50ID0gcHQ7XG4gICAgICAgIHRvb2wuX2xhc3RQb2ludCA9IHRvb2xQb2ludCB8fCBwdDtcblxuICAgICAgICBpZiAobW91c2UuZG93bikge1xuICAgICAgICAgIHRvb2wuX21vdmVDb3VudCA9IC0xO1xuICAgICAgICAgIHRvb2wuX2Rvd25Qb2ludCA9IHB0O1xuICAgICAgICAgIHRvb2wuX2Rvd25Db3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVtaXQoKSB7XG4gICAgICAgIGlmIChyZXNwb25kcykge1xuICAgICAgICAgIGNhbGxlZCA9IHRvb2wuZW1pdCh0eXBlLCBuZXcgVG9vbEV2ZW50KHRvb2wsIHR5cGUsIGV2ZW50KSkgfHwgY2FsbGVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtb3VzZS5kb3duKSB7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICBlbWl0KCk7XG4gICAgICB9IGVsc2UgaWYgKG1vdXNlLnVwKSB7XG4gICAgICAgIHVwZGF0ZShudWxsLCBtYXhEaXN0YW5jZSk7XG4gICAgICAgIGVtaXQoKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uZHMpIHtcbiAgICAgICAgd2hpbGUgKHVwZGF0ZShtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UpKSBlbWl0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsZWQ7XG4gICAgfVxuICB9KTtcbiAgdmFyIFR3ZWVuID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuICAgIF9jbGFzczogJ1R3ZWVuJyxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBlYXNpbmdzOiB7XG4gICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluUXVhZDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCAqIHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0ICogKDIgLSB0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgMiAqICgyIC0gdCkgKiB0O1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCAqIHQgKiB0O1xuICAgICAgICB9LFxuICAgICAgICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgPCAwLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5RdWFydDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAxIC0gLS10ICogdCAqIHQgKiB0O1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCA8IDAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAtLXQgKiB0ICogdCAqIHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJblF1aW50OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZU91dFF1aW50OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAxICsgLS10ICogdCAqIHQgKiB0ICogdDtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgPCAwLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogLS10ICogdCAqIHQgKiB0ICogdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gVHdlZW4ob2JqZWN0LCBmcm9tLCB0bywgZHVyYXRpb24sIGVhc2luZywgc3RhcnQpIHtcbiAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZWFzaW5nO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgICAgdGhpcy50eXBlID0gaXNGdW5jdGlvbiA/IHR5cGUgOiB0eXBlID09PSAnc3RyaW5nJyA/IGVhc2luZyA6ICdsaW5lYXInO1xuICAgICAgdGhpcy5lYXNpbmcgPSBpc0Z1bmN0aW9uID8gZWFzaW5nIDogVHdlZW4uZWFzaW5nc1t0aGlzLnR5cGVdO1xuICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl90aGVuID0gbnVsbDtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG4gICAgICB2YXIgc3RhdGUgPSBmcm9tIHx8IHRvO1xuICAgICAgdGhpcy5fa2V5cyA9IHN0YXRlID8gT2JqZWN0LmtleXMoc3RhdGUpIDogW107XG4gICAgICB0aGlzLl9wYXJzZWRLZXlzID0gdGhpcy5fcGFyc2VLZXlzKHRoaXMuX2tleXMpO1xuICAgICAgdGhpcy5fZnJvbSA9IHN0YXRlICYmIHRoaXMuX2dldFN0YXRlKGZyb20pO1xuICAgICAgdGhpcy5fdG8gPSBzdGF0ZSAmJiB0aGlzLl9nZXRTdGF0ZSh0byk7XG5cbiAgICAgIGlmIChzdGFydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGhlbjogZnVuY3Rpb24gKHRoZW4pIHtcbiAgICAgIHRoaXMuX3RoZW4gPSB0aGVuO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gMSkge1xuICAgICAgICAgIHByb2dyZXNzID0gMTtcbiAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmYWN0b3IgPSB0aGlzLmVhc2luZyhwcm9ncmVzcyksXG4gICAgICAgICAgICBrZXlzID0gdGhpcy5fa2V5cyxcbiAgICAgICAgICAgIGdldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKGZhY3RvciwgcHJvZ3Jlc3MpIDogdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzICYmIGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICAgIGZyb20gPSBnZXRWYWx1ZSh0aGlzLl9mcm9tW2tleV0pLFxuICAgICAgICAgICAgICB0byA9IGdldFZhbHVlKHRoaXMuX3RvW2tleV0pLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGZyb20gJiYgdG8gJiYgZnJvbS5fX2FkZCAmJiB0by5fX2FkZCA/IHRvLl9fc3VidHJhY3QoZnJvbSkuX19tdWx0aXBseShmYWN0b3IpLl9fYWRkKGZyb20pIDogKHRvIC0gZnJvbSkgKiBmYWN0b3IgKyBmcm9tO1xuXG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkodGhpcy5fcGFyc2VkS2V5c1trZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yZXNwb25kcygndXBkYXRlJykpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIG5ldyBCYXNlKHtcbiAgICAgICAgICAgIHByb2dyZXNzOiBwcm9ncmVzcyxcbiAgICAgICAgICAgIGZhY3RvcjogZmFjdG9yXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcgJiYgdGhpcy5fdGhlbikge1xuICAgICAgICAgIHRoaXMuX3RoZW4odGhpcy5vYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX2V2ZW50czoge1xuICAgICAgb25VcGRhdGU6IHt9XG4gICAgfSxcbiAgICBfaGFuZGxlRnJhbWU6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lLFxuICAgICAgICAgIHByb2dyZXNzID0gc3RhcnRUaW1lID8gKHRpbWUgLSBzdGFydFRpbWUpIC8gdGhpcy5kdXJhdGlvbiA6IDA7XG5cbiAgICAgIGlmICghc3RhcnRUaW1lKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlKHByb2dyZXNzKTtcbiAgICB9LFxuICAgIF9nZXRTdGF0ZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuX2tleXMsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICBwYXRoID0gdGhpcy5fcGFyc2VkS2V5c1trZXldLFxuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuX2dldFByb3BlcnR5KHBhdGgpLFxuICAgICAgICAgICAgdmFsdWU7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIHJlc29sdmVkID0gdGhpcy5fcmVzb2x2ZVZhbHVlKGN1cnJlbnQsIHN0YXRlW2tleV0pO1xuXG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocGF0aCwgcmVzb2x2ZWQpO1xuXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9nZXRQcm9wZXJ0eShwYXRoKTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLmNsb25lID8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocGF0aCwgY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBjdXJyZW50ICYmIGN1cnJlbnQuY2xvbmUgPyBjdXJyZW50LmNsb25lKCkgOiBjdXJyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIF9yZXNvbHZlVmFsdWU6IGZ1bmN0aW9uIChjdXJyZW50LCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB2YWx1ZVswXTtcbiAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgJiYgb3BlcmF0b3IubWF0Y2ggJiYgb3BlcmF0b3IubWF0Y2goL15bK1xcLVxcKlxcL109LykgPyB0aGlzLl9jYWxjdWxhdGUoY3VycmVudCwgb3BlcmF0b3JbMF0sIHZhbHVlWzFdKSA6IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXlsrXFwtKi9dPSguKikvKTtcblxuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UobWF0Y2hbMV0ucmVwbGFjZSgvKFsnXCJdKT8oW2EtekEtWjAtOV9dKykoWydcIl0pPzovZywgJ1wiJDJcIjogJykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZShjdXJyZW50LCB2YWx1ZVswXSwgcGFyc2VkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgX2NhbGN1bGF0ZTogZnVuY3Rpb24gKGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuICAgICAgcmV0dXJuIHBhcGVyLlBhcGVyU2NyaXB0LmNhbGN1bGF0ZUJpbmFyeShsZWZ0LCBvcGVyYXRvciwgcmlnaHQpO1xuICAgIH0sXG4gICAgX3BhcnNlS2V5czogZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgIHBhdGggPSBrZXkucmVwbGFjZSgvXFwuKFteLl0qKS9nLCAnLyQxJykucmVwbGFjZSgvXFxbWydcIl0/KFteJ1wiXFxdXSopWydcIl0/XFxdL2csICcvJDEnKTtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSxcbiAgICBfZ2V0UHJvcGVydHk6IGZ1bmN0aW9uIChwYXRoLCBvZmZzZXQpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLm9iamVjdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aCAtIChvZmZzZXQgfHwgMCk7IGkgPCBsICYmIG9iajsgaSsrKSB7XG4gICAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIF9zZXRQcm9wZXJ0eTogZnVuY3Rpb24gKHBhdGgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGVzdCA9IHRoaXMuX2dldFByb3BlcnR5KHBhdGgsIDEpO1xuXG4gICAgICBpZiAoZGVzdCkge1xuICAgICAgICBkZXN0W3BhdGhbcGF0aC5sZW5ndGggLSAxXV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgSHR0cCA9IHtcbiAgICByZXF1ZXN0OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIHhociA9IG5ldyBzZWxmLlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3Blbigob3B0aW9ucy5tZXRob2QgfHwgJ2dldCcpLnRvVXBwZXJDYXNlKCksIG9wdGlvbnMudXJsLCBCYXNlLnBpY2sob3B0aW9ucy5hc3luYywgdHJ1ZSkpO1xuICAgICAgaWYgKG9wdGlvbnMubWltZVR5cGUpIHhoci5vdmVycmlkZU1pbWVUeXBlKG9wdGlvbnMubWltZVR5cGUpO1xuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1cztcblxuICAgICAgICBpZiAoc3RhdHVzID09PSAwIHx8IHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub25Mb2FkKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uTG9hZC5jYWxsKHhociwgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5vbmVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1cyxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnQ291bGQgbm90IGxvYWQgXCInICsgb3B0aW9ucy51cmwgKyAnXCIgKFN0YXR1czogJyArIHN0YXR1cyArICcpJztcblxuICAgICAgICBpZiAob3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICAgICAgb3B0aW9ucy5vbkVycm9yKG1lc3NhZ2UsIHN0YXR1cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4geGhyLnNlbmQobnVsbCk7XG4gICAgfVxuICB9O1xuICB2YXIgQ2FudmFzUHJvdmlkZXIgPSBCYXNlLmV4cG9ydHMuQ2FudmFzUHJvdmlkZXIgPSB7XG4gICAgY2FudmFzZXM6IFtdLFxuICAgIGdldENhbnZhczogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICghd2luZG93KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBjYW52YXMsXG4gICAgICAgICAgY2xlYXIgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuICAgICAgICBoZWlnaHQgPSB3aWR0aC5oZWlnaHQ7XG4gICAgICAgIHdpZHRoID0gd2lkdGgud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhc2VzLmxlbmd0aCkge1xuICAgICAgICBjYW52YXMgPSB0aGlzLmNhbnZhc2VzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNsZWFyID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgJyArIGNhbnZhcyArICcgaXMgdW5hYmxlIHRvIHByb3ZpZGUgYSAyRCBjb250ZXh0LicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FudmFzLndpZHRoID09PSB3aWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgICAgaWYgKGNsZWFyKSBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoICsgMSwgaGVpZ2h0ICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSxcbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcmV0dXJuIGNhbnZhcyA/IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIDogbnVsbDtcbiAgICB9LFxuICAgIHJlbGVhc2U6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBjYW52YXMgPSBvYmogJiYgb2JqLmNhbnZhcyA/IG9iai5jYW52YXMgOiBvYmo7XG5cbiAgICAgIGlmIChjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQpIHtcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykucmVzdG9yZSgpO1xuICAgICAgICB0aGlzLmNhbnZhc2VzLnB1c2goY2FudmFzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBCbGVuZE1vZGUgPSBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgICBzcixcbiAgICAgICAgc2csXG4gICAgICAgIHNiLFxuICAgICAgICBzYSxcbiAgICAgICAgYnIsXG4gICAgICAgIGJnLFxuICAgICAgICBiYixcbiAgICAgICAgYmEsXG4gICAgICAgIGRyLFxuICAgICAgICBkZyxcbiAgICAgICAgZGI7XG5cbiAgICBmdW5jdGlvbiBnZXRMdW0ociwgZywgYikge1xuICAgICAgcmV0dXJuIDAuMjk4OSAqIHIgKyAwLjU4NyAqIGcgKyAwLjExNCAqIGI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0THVtKHIsIGcsIGIsIGwpIHtcbiAgICAgIHZhciBkID0gbCAtIGdldEx1bShyLCBnLCBiKTtcbiAgICAgIGRyID0gciArIGQ7XG4gICAgICBkZyA9IGcgKyBkO1xuICAgICAgZGIgPSBiICsgZDtcbiAgICAgIHZhciBsID0gZ2V0THVtKGRyLCBkZywgZGIpLFxuICAgICAgICAgIG1uID0gbWluKGRyLCBkZywgZGIpLFxuICAgICAgICAgIG14ID0gbWF4KGRyLCBkZywgZGIpO1xuXG4gICAgICBpZiAobW4gPCAwKSB7XG4gICAgICAgIHZhciBsbW4gPSBsIC0gbW47XG4gICAgICAgIGRyID0gbCArIChkciAtIGwpICogbCAvIGxtbjtcbiAgICAgICAgZGcgPSBsICsgKGRnIC0gbCkgKiBsIC8gbG1uO1xuICAgICAgICBkYiA9IGwgKyAoZGIgLSBsKSAqIGwgLyBsbW47XG4gICAgICB9XG5cbiAgICAgIGlmIChteCA+IDI1NSkge1xuICAgICAgICB2YXIgbG4gPSAyNTUgLSBsLFxuICAgICAgICAgICAgbXhsID0gbXggLSBsO1xuICAgICAgICBkciA9IGwgKyAoZHIgLSBsKSAqIGxuIC8gbXhsO1xuICAgICAgICBkZyA9IGwgKyAoZGcgLSBsKSAqIGxuIC8gbXhsO1xuICAgICAgICBkYiA9IGwgKyAoZGIgLSBsKSAqIGxuIC8gbXhsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNhdChyLCBnLCBiKSB7XG4gICAgICByZXR1cm4gbWF4KHIsIGcsIGIpIC0gbWluKHIsIGcsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFNhdChyLCBnLCBiLCBzKSB7XG4gICAgICB2YXIgY29sID0gW3IsIGcsIGJdLFxuICAgICAgICAgIG14ID0gbWF4KHIsIGcsIGIpLFxuICAgICAgICAgIG1uID0gbWluKHIsIGcsIGIpLFxuICAgICAgICAgIG1kO1xuICAgICAgbW4gPSBtbiA9PT0gciA/IDAgOiBtbiA9PT0gZyA/IDEgOiAyO1xuICAgICAgbXggPSBteCA9PT0gciA/IDAgOiBteCA9PT0gZyA/IDEgOiAyO1xuICAgICAgbWQgPSBtaW4obW4sIG14KSA9PT0gMCA/IG1heChtbiwgbXgpID09PSAxID8gMiA6IDEgOiAwO1xuXG4gICAgICBpZiAoY29sW214XSA+IGNvbFttbl0pIHtcbiAgICAgICAgY29sW21kXSA9IChjb2xbbWRdIC0gY29sW21uXSkgKiBzIC8gKGNvbFtteF0gLSBjb2xbbW5dKTtcbiAgICAgICAgY29sW214XSA9IHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xbbWRdID0gY29sW214XSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbFttbl0gPSAwO1xuICAgICAgZHIgPSBjb2xbMF07XG4gICAgICBkZyA9IGNvbFsxXTtcbiAgICAgIGRiID0gY29sWzJdO1xuICAgIH1cblxuICAgIHZhciBtb2RlcyA9IHtcbiAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gYnIgKiBzciAvIDI1NTtcbiAgICAgICAgZGcgPSBiZyAqIHNnIC8gMjU1O1xuICAgICAgICBkYiA9IGJiICogc2IgLyAyNTU7XG4gICAgICB9LFxuICAgICAgc2NyZWVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gYnIgKyBzciAtIGJyICogc3IgLyAyNTU7XG4gICAgICAgIGRnID0gYmcgKyBzZyAtIGJnICogc2cgLyAyNTU7XG4gICAgICAgIGRiID0gYmIgKyBzYiAtIGJiICogc2IgLyAyNTU7XG4gICAgICB9LFxuICAgICAgb3ZlcmxheTogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IGJyIDwgMTI4ID8gMiAqIGJyICogc3IgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJyKSAqICgyNTUgLSBzcikgLyAyNTU7XG4gICAgICAgIGRnID0gYmcgPCAxMjggPyAyICogYmcgKiBzZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NTtcbiAgICAgICAgZGIgPSBiYiA8IDEyOCA/IDIgKiBiYiAqIHNiIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1O1xuICAgICAgfSxcbiAgICAgICdzb2Z0LWxpZ2h0JzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdCA9IHNyICogYnIgLyAyNTU7XG4gICAgICAgIGRyID0gdCArIGJyICogKDI1NSAtICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1IC0gdCkgLyAyNTU7XG4gICAgICAgIHQgPSBzZyAqIGJnIC8gMjU1O1xuICAgICAgICBkZyA9IHQgKyBiZyAqICgyNTUgLSAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NSAtIHQpIC8gMjU1O1xuICAgICAgICB0ID0gc2IgKiBiYiAvIDI1NTtcbiAgICAgICAgZGIgPSB0ICsgYmIgKiAoMjU1IC0gKDI1NSAtIGJiKSAqICgyNTUgLSBzYikgLyAyNTUgLSB0KSAvIDI1NTtcbiAgICAgIH0sXG4gICAgICAnaGFyZC1saWdodCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBzciA8IDEyOCA/IDIgKiBzciAqIGJyIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzcikgKiAoMjU1IC0gYnIpIC8gMjU1O1xuICAgICAgICBkZyA9IHNnIDwgMTI4ID8gMiAqIHNnICogYmcgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNnKSAqICgyNTUgLSBiZykgLyAyNTU7XG4gICAgICAgIGRiID0gc2IgPCAxMjggPyAyICogc2IgKiBiYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc2IpICogKDI1NSAtIGJiKSAvIDI1NTtcbiAgICAgIH0sXG4gICAgICAnY29sb3ItZG9kZ2UnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gYnIgPT09IDAgPyAwIDogc3IgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJyIC8gKDI1NSAtIHNyKSk7XG4gICAgICAgIGRnID0gYmcgPT09IDAgPyAwIDogc2cgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJnIC8gKDI1NSAtIHNnKSk7XG4gICAgICAgIGRiID0gYmIgPT09IDAgPyAwIDogc2IgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJiIC8gKDI1NSAtIHNiKSk7XG4gICAgICB9LFxuICAgICAgJ2NvbG9yLWJ1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gYnIgPT09IDI1NSA/IDI1NSA6IHNyID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYnIpICogMjU1IC8gc3IpO1xuICAgICAgICBkZyA9IGJnID09PSAyNTUgPyAyNTUgOiBzZyA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJnKSAqIDI1NSAvIHNnKTtcbiAgICAgICAgZGIgPSBiYiA9PT0gMjU1ID8gMjU1IDogc2IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBiYikgKiAyNTUgLyBzYik7XG4gICAgICB9LFxuICAgICAgZGFya2VuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gYnIgPCBzciA/IGJyIDogc3I7XG4gICAgICAgIGRnID0gYmcgPCBzZyA/IGJnIDogc2c7XG4gICAgICAgIGRiID0gYmIgPCBzYiA/IGJiIDogc2I7XG4gICAgICB9LFxuICAgICAgbGlnaHRlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IGJyID4gc3IgPyBiciA6IHNyO1xuICAgICAgICBkZyA9IGJnID4gc2cgPyBiZyA6IHNnO1xuICAgICAgICBkYiA9IGJiID4gc2IgPyBiYiA6IHNiO1xuICAgICAgfSxcbiAgICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBiciAtIHNyO1xuICAgICAgICBpZiAoZHIgPCAwKSBkciA9IC1kcjtcbiAgICAgICAgZGcgPSBiZyAtIHNnO1xuICAgICAgICBpZiAoZGcgPCAwKSBkZyA9IC1kZztcbiAgICAgICAgZGIgPSBiYiAtIHNiO1xuICAgICAgICBpZiAoZGIgPCAwKSBkYiA9IC1kYjtcbiAgICAgIH0sXG4gICAgICBleGNsdXNpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBiciArIHNyICogKDI1NSAtIGJyIC0gYnIpIC8gMjU1O1xuICAgICAgICBkZyA9IGJnICsgc2cgKiAoMjU1IC0gYmcgLSBiZykgLyAyNTU7XG4gICAgICAgIGRiID0gYmIgKyBzYiAqICgyNTUgLSBiYiAtIGJiKSAvIDI1NTtcbiAgICAgIH0sXG4gICAgICBodWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2F0KHNyLCBzZywgc2IsIGdldFNhdChiciwgYmcsIGJiKSk7XG4gICAgICAgIHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuICAgICAgfSxcbiAgICAgIHNhdHVyYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2F0KGJyLCBiZywgYmIsIGdldFNhdChzciwgc2csIHNiKSk7XG4gICAgICAgIHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuICAgICAgfSxcbiAgICAgIGx1bWlub3NpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0THVtKGJyLCBiZywgYmIsIGdldEx1bShzciwgc2csIHNiKSk7XG4gICAgICB9LFxuICAgICAgY29sb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0THVtKHNyLCBzZywgc2IsIGdldEx1bShiciwgYmcsIGJiKSk7XG4gICAgICB9LFxuICAgICAgYWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gbWluKGJyICsgc3IsIDI1NSk7XG4gICAgICAgIGRnID0gbWluKGJnICsgc2csIDI1NSk7XG4gICAgICAgIGRiID0gbWluKGJiICsgc2IsIDI1NSk7XG4gICAgICB9LFxuICAgICAgc3VidHJhY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBtYXgoYnIgLSBzciwgMCk7XG4gICAgICAgIGRnID0gbWF4KGJnIC0gc2csIDApO1xuICAgICAgICBkYiA9IG1heChiYiAtIHNiLCAwKTtcbiAgICAgIH0sXG4gICAgICBhdmVyYWdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gKGJyICsgc3IpIC8gMjtcbiAgICAgICAgZGcgPSAoYmcgKyBzZykgLyAyO1xuICAgICAgICBkYiA9IChiYiArIHNiKSAvIDI7XG4gICAgICB9LFxuICAgICAgbmVnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSAyNTUgLSBhYnMoMjU1IC0gc3IgLSBicik7XG4gICAgICAgIGRnID0gMjU1IC0gYWJzKDI1NSAtIHNnIC0gYmcpO1xuICAgICAgICBkYiA9IDI1NSAtIGFicygyNTUgLSBzYiAtIGJiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBuYXRpdmVNb2RlcyA9IHRoaXMubmF0aXZlTW9kZXMgPSBCYXNlLmVhY2goWydzb3VyY2Utb3ZlcicsICdzb3VyY2UtaW4nLCAnc291cmNlLW91dCcsICdzb3VyY2UtYXRvcCcsICdkZXN0aW5hdGlvbi1vdmVyJywgJ2Rlc3RpbmF0aW9uLWluJywgJ2Rlc3RpbmF0aW9uLW91dCcsICdkZXN0aW5hdGlvbi1hdG9wJywgJ2xpZ2h0ZXInLCAnZGFya2VyJywgJ2NvcHknLCAneG9yJ10sIGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICB0aGlzW21vZGVdID0gdHJ1ZTtcbiAgICB9LCB7fSk7XG4gICAgdmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBCYXNlLmVhY2gobW9kZXMsIGZ1bmN0aW9uIChmdW5jLCBtb2RlKSB7XG4gICAgICAgIHZhciBkYXJrZW4gPSBtb2RlID09PSAnZGFya2VuJyxcbiAgICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyMzMDAnIDogJyNhMDAnO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblxuICAgICAgICAgIGlmIChjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID09PSBtb2RlKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyNhMDAnIDogJyMzMDAnO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgICAgICAgICAgb2sgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGFbMF0gIT09IGRhcmtlbiA/IDE3MCA6IDUxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBuYXRpdmVNb2Rlc1ttb2RlXSA9IG9rO1xuICAgICAgfSk7XG4gICAgICBDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9jZXNzID0gZnVuY3Rpb24gKG1vZGUsIHNyY0NvbnRleHQsIGRzdENvbnRleHQsIGFscGhhLCBvZmZzZXQpIHtcbiAgICAgIHZhciBzcmNDYW52YXMgPSBzcmNDb250ZXh0LmNhbnZhcyxcbiAgICAgICAgICBub3JtYWwgPSBtb2RlID09PSAnbm9ybWFsJztcblxuICAgICAgaWYgKG5vcm1hbCB8fCBuYXRpdmVNb2Rlc1ttb2RlXSkge1xuICAgICAgICBkc3RDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgZHN0Q29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGRzdENvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgaWYgKCFub3JtYWwpIGRzdENvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcbiAgICAgICAgZHN0Q29udGV4dC5kcmF3SW1hZ2Uoc3JjQ2FudmFzLCBvZmZzZXQueCwgb2Zmc2V0LnkpO1xuICAgICAgICBkc3RDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9jZXNzID0gbW9kZXNbbW9kZV07XG4gICAgICAgIGlmICghcHJvY2VzcykgcmV0dXJuO1xuICAgICAgICB2YXIgZHN0RGF0YSA9IGRzdENvbnRleHQuZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSwgc3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KSxcbiAgICAgICAgICAgIGRzdCA9IGRzdERhdGEuZGF0YSxcbiAgICAgICAgICAgIHNyYyA9IHNyY0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCkuZGF0YTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGRzdC5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgICAgICBzciA9IHNyY1tpXTtcbiAgICAgICAgICBiciA9IGRzdFtpXTtcbiAgICAgICAgICBzZyA9IHNyY1tpICsgMV07XG4gICAgICAgICAgYmcgPSBkc3RbaSArIDFdO1xuICAgICAgICAgIHNiID0gc3JjW2kgKyAyXTtcbiAgICAgICAgICBiYiA9IGRzdFtpICsgMl07XG4gICAgICAgICAgc2EgPSBzcmNbaSArIDNdO1xuICAgICAgICAgIGJhID0gZHN0W2kgKyAzXTtcbiAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgdmFyIGExID0gc2EgKiBhbHBoYSAvIDI1NSxcbiAgICAgICAgICAgICAgYTIgPSAxIC0gYTE7XG4gICAgICAgICAgZHN0W2ldID0gYTEgKiBkciArIGEyICogYnI7XG4gICAgICAgICAgZHN0W2kgKyAxXSA9IGExICogZGcgKyBhMiAqIGJnO1xuICAgICAgICAgIGRzdFtpICsgMl0gPSBhMSAqIGRiICsgYTIgKiBiYjtcbiAgICAgICAgICBkc3RbaSArIDNdID0gc2EgKiBhbHBoYSArIGEyICogYmE7XG4gICAgICAgIH1cblxuICAgICAgICBkc3RDb250ZXh0LnB1dEltYWdlRGF0YShkc3REYXRhLCBvZmZzZXQueCwgb2Zmc2V0LnkpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKTtcbiAgdmFyIFN2Z0VsZW1lbnQgPSBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdmcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICB4bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zJyxcbiAgICAgICAgeGxpbmsgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZSA9IHtcbiAgICAgIGhyZWY6IHhsaW5rLFxuICAgICAgeGxpbms6IHhtbG5zLFxuICAgICAgeG1sbnM6IHhtbG5zICsgJy8nLFxuICAgICAgJ3htbG5zOnhsaW5rJzogeG1sbnMgKyAnLydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRhZywgYXR0cmlidXRlcywgZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gc2V0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmcsIHRhZyksIGF0dHJpYnV0ZXMsIGZvcm1hdHRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0KG5vZGUsIG5hbWUpIHtcbiAgICAgIHZhciBuYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2VbbmFtZV0sXG4gICAgICAgICAgdmFsdWUgPSBuYW1lc3BhY2UgPyBub2RlLmdldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSkgOiBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gJ251bGwnID8gbnVsbCA6IHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldChub2RlLCBhdHRyaWJ1dGVzLCBmb3JtYXR0ZXIpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdLFxuICAgICAgICAgICAgbmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlW25hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBmb3JtYXR0ZXIpIHZhbHVlID0gZm9ybWF0dGVyLm51bWJlcih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdmc6IHN2ZyxcbiAgICAgIHhtbG5zOiB4bWxucyxcbiAgICAgIHhsaW5rOiB4bGluayxcbiAgICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgICAgZ2V0OiBnZXQsXG4gICAgICBzZXQ6IHNldFxuICAgIH07XG4gIH0oKTtcbiAgdmFyIFN2Z1N0eWxlcyA9IEJhc2UuZWFjaCh7XG4gICAgZmlsbENvbG9yOiBbJ2ZpbGwnLCAnY29sb3InXSxcbiAgICBmaWxsUnVsZTogWydmaWxsLXJ1bGUnLCAnc3RyaW5nJ10sXG4gICAgc3Ryb2tlQ29sb3I6IFsnc3Ryb2tlJywgJ2NvbG9yJ10sXG4gICAgc3Ryb2tlV2lkdGg6IFsnc3Ryb2tlLXdpZHRoJywgJ251bWJlciddLFxuICAgIHN0cm9rZUNhcDogWydzdHJva2UtbGluZWNhcCcsICdzdHJpbmcnXSxcbiAgICBzdHJva2VKb2luOiBbJ3N0cm9rZS1saW5lam9pbicsICdzdHJpbmcnXSxcbiAgICBzdHJva2VTY2FsaW5nOiBbJ3ZlY3Rvci1lZmZlY3QnLCAnbG9va3VwJywge1xuICAgICAgdHJ1ZTogJ25vbmUnLFxuICAgICAgZmFsc2U6ICdub24tc2NhbGluZy1zdHJva2UnXG4gICAgfSwgZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG4gICAgICByZXR1cm4gIXZhbHVlICYmIChpdGVtIGluc3RhbmNlb2YgUGF0aEl0ZW0gfHwgaXRlbSBpbnN0YW5jZW9mIFNoYXBlIHx8IGl0ZW0gaW5zdGFuY2VvZiBUZXh0SXRlbSk7XG4gICAgfV0sXG4gICAgbWl0ZXJMaW1pdDogWydzdHJva2UtbWl0ZXJsaW1pdCcsICdudW1iZXInXSxcbiAgICBkYXNoQXJyYXk6IFsnc3Ryb2tlLWRhc2hhcnJheScsICdhcnJheSddLFxuICAgIGRhc2hPZmZzZXQ6IFsnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnbnVtYmVyJ10sXG4gICAgZm9udEZhbWlseTogWydmb250LWZhbWlseScsICdzdHJpbmcnXSxcbiAgICBmb250V2VpZ2h0OiBbJ2ZvbnQtd2VpZ2h0JywgJ3N0cmluZyddLFxuICAgIGZvbnRTaXplOiBbJ2ZvbnQtc2l6ZScsICdudW1iZXInXSxcbiAgICBqdXN0aWZpY2F0aW9uOiBbJ3RleHQtYW5jaG9yJywgJ2xvb2t1cCcsIHtcbiAgICAgIGxlZnQ6ICdzdGFydCcsXG4gICAgICBjZW50ZXI6ICdtaWRkbGUnLFxuICAgICAgcmlnaHQ6ICdlbmQnXG4gICAgfV0sXG4gICAgb3BhY2l0eTogWydvcGFjaXR5JywgJ251bWJlciddLFxuICAgIGJsZW5kTW9kZTogWydtaXgtYmxlbmQtbW9kZScsICdzdHlsZSddXG4gIH0sIGZ1bmN0aW9uIChlbnRyeSwga2V5KSB7XG4gICAgdmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcbiAgICAgICAgbG9va3VwID0gZW50cnlbMl07XG4gICAgdGhpc1trZXldID0ge1xuICAgICAgdHlwZTogZW50cnlbMV0sXG4gICAgICBwcm9wZXJ0eToga2V5LFxuICAgICAgYXR0cmlidXRlOiBlbnRyeVswXSxcbiAgICAgIHRvU1ZHOiBsb29rdXAsXG4gICAgICBmcm9tU1ZHOiBsb29rdXAgJiYgQmFzZS5lYWNoKGxvb2t1cCwgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXNbdmFsdWVdID0gbmFtZTtcbiAgICAgIH0sIHt9KSxcbiAgICAgIGV4cG9ydEZpbHRlcjogZW50cnlbM10sXG4gICAgICBnZXQ6ICdnZXQnICsgcGFydCxcbiAgICAgIHNldDogJ3NldCcgKyBwYXJ0XG4gICAgfTtcbiAgfSwge30pO1xuICBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb3JtYXR0ZXI7XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0obWF0cml4LCBjb29yZGluYXRlcywgY2VudGVyKSB7XG4gICAgICB2YXIgYXR0cnMgPSBuZXcgQmFzZSgpLFxuICAgICAgICAgIHRyYW5zID0gbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cbiAgICAgIGlmIChjb29yZGluYXRlcykge1xuICAgICAgICB2YXIgcG9pbnQ7XG5cbiAgICAgICAgaWYgKG1hdHJpeC5pc0ludmVydGlibGUoKSkge1xuICAgICAgICAgIG1hdHJpeCA9IG1hdHJpeC5fc2hpZnRsZXNzKCk7XG4gICAgICAgICAgcG9pbnQgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0odHJhbnMpO1xuICAgICAgICAgIHRyYW5zID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludCA9IG5ldyBQb2ludCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cnNbY2VudGVyID8gJ2N4JyA6ICd4J10gPSBwb2ludC54O1xuICAgICAgICBhdHRyc1tjZW50ZXIgPyAnY3knIDogJ3knXSA9IHBvaW50Lnk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWF0cml4LmlzSWRlbnRpdHkoKSkge1xuICAgICAgICB2YXIgZGVjb21wb3NlZCA9IG1hdHJpeC5kZWNvbXBvc2UoKTtcblxuICAgICAgICBpZiAoZGVjb21wb3NlZCkge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IFtdLFxuICAgICAgICAgICAgICBhbmdsZSA9IGRlY29tcG9zZWQucm90YXRpb24sXG4gICAgICAgICAgICAgIHNjYWxlID0gZGVjb21wb3NlZC5zY2FsaW5nLFxuICAgICAgICAgICAgICBza2V3ID0gZGVjb21wb3NlZC5za2V3aW5nO1xuICAgICAgICAgIGlmICh0cmFucyAmJiAhdHJhbnMuaXNaZXJvKCkpIHBhcnRzLnB1c2goJ3RyYW5zbGF0ZSgnICsgZm9ybWF0dGVyLnBvaW50KHRyYW5zKSArICcpJyk7XG4gICAgICAgICAgaWYgKGFuZ2xlKSBwYXJ0cy5wdXNoKCdyb3RhdGUoJyArIGZvcm1hdHRlci5udW1iZXIoYW5nbGUpICsgJyknKTtcbiAgICAgICAgICBpZiAoIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueCAtIDEpIHx8ICFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnkgLSAxKSkgcGFydHMucHVzaCgnc2NhbGUoJyArIGZvcm1hdHRlci5wb2ludChzY2FsZSkgKyAnKScpO1xuICAgICAgICAgIGlmIChza2V3LngpIHBhcnRzLnB1c2goJ3NrZXdYKCcgKyBmb3JtYXR0ZXIubnVtYmVyKHNrZXcueCkgKyAnKScpO1xuICAgICAgICAgIGlmIChza2V3LnkpIHBhcnRzLnB1c2goJ3NrZXdZKCcgKyBmb3JtYXR0ZXIubnVtYmVyKHNrZXcueSkgKyAnKScpO1xuICAgICAgICAgIGF0dHJzLnRyYW5zZm9ybSA9IHBhcnRzLmpvaW4oJyAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRycy50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyBtYXRyaXguZ2V0VmFsdWVzKCkuam9pbignLCcpICsgJyknO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRHcm91cChpdGVtLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KSxcbiAgICAgICAgICBjaGlsZHJlbiA9IGl0ZW0uX2NoaWxkcmVuO1xuICAgICAgdmFyIG5vZGUgPSBTdmdFbGVtZW50LmNyZWF0ZSgnZycsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGV4cG9ydFNWRyhjaGlsZCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgIGlmIChjaGlsZC5pc0NsaXBNYXNrKCkpIHtcbiAgICAgICAgICAgIHZhciBjbGlwID0gU3ZnRWxlbWVudC5jcmVhdGUoJ2NsaXBQYXRoJyk7XG4gICAgICAgICAgICBjbGlwLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICBzZXREZWZpbml0aW9uKGNoaWxkLCBjbGlwLCAnY2xpcCcpO1xuICAgICAgICAgICAgU3ZnRWxlbWVudC5zZXQobm9kZSwge1xuICAgICAgICAgICAgICAnY2xpcC1wYXRoJzogJ3VybCgjJyArIGNsaXAuaWQgKyAnKSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydFJhc3RlcihpdGVtLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcbiAgICAgICAgICBzaXplID0gaXRlbS5nZXRTaXplKCksXG4gICAgICAgICAgaW1hZ2UgPSBpdGVtLmdldEltYWdlKCk7XG4gICAgICBhdHRycy54IC09IHNpemUud2lkdGggLyAyO1xuICAgICAgYXR0cnMueSAtPSBzaXplLmhlaWdodCAvIDI7XG4gICAgICBhdHRycy53aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICBhdHRycy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgIGF0dHJzLmhyZWYgPSBvcHRpb25zLmVtYmVkSW1hZ2VzID09IGZhbHNlICYmIGltYWdlICYmIGltYWdlLnNyYyB8fCBpdGVtLnRvRGF0YVVSTCgpO1xuICAgICAgcmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKCdpbWFnZScsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydFBhdGgoaXRlbSwgb3B0aW9ucykge1xuICAgICAgdmFyIG1hdGNoU2hhcGVzID0gb3B0aW9ucy5tYXRjaFNoYXBlcztcblxuICAgICAgaWYgKG1hdGNoU2hhcGVzKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IGl0ZW0udG9TaGFwZShmYWxzZSk7XG4gICAgICAgIGlmIChzaGFwZSkgcmV0dXJuIGV4cG9ydFNoYXBlKHNoYXBlLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ21lbnRzID0gaXRlbS5fc2VnbWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblxuICAgICAgaWYgKG1hdGNoU2hhcGVzICYmIGxlbmd0aCA+PSAyICYmICFpdGVtLmhhc0hhbmRsZXMoKSkge1xuICAgICAgICBpZiAobGVuZ3RoID4gMikge1xuICAgICAgICAgIHR5cGUgPSBpdGVtLl9jbG9zZWQgPyAncG9seWdvbicgOiAncG9seWxpbmUnO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFydHMucHVzaChmb3JtYXR0ZXIucG9pbnQoc2VnbWVudHNbaV0uX3BvaW50KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0cnMucG9pbnRzID0gcGFydHMuam9pbignICcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSAnbGluZSc7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gc2VnbWVudHNbMF0uX3BvaW50LFxuICAgICAgICAgICAgICBlbmQgPSBzZWdtZW50c1sxXS5fcG9pbnQ7XG4gICAgICAgICAgYXR0cnMuc2V0KHtcbiAgICAgICAgICAgIHgxOiBzdGFydC54LFxuICAgICAgICAgICAgeTE6IHN0YXJ0LnksXG4gICAgICAgICAgICB4MjogZW5kLngsXG4gICAgICAgICAgICB5MjogZW5kLnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9ICdwYXRoJztcbiAgICAgICAgYXR0cnMuZCA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3ZnRWxlbWVudC5jcmVhdGUodHlwZSwgYXR0cnMsIGZvcm1hdHRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0U2hhcGUoaXRlbSkge1xuICAgICAgdmFyIHR5cGUgPSBpdGVtLl90eXBlLFxuICAgICAgICAgIHJhZGl1cyA9IGl0ZW0uX3JhZGl1cyxcbiAgICAgICAgICBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUsIHR5cGUgIT09ICdyZWN0YW5nbGUnKTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG4gICAgICAgIHR5cGUgPSAncmVjdCc7XG4gICAgICAgIHZhciBzaXplID0gaXRlbS5fc2l6ZSxcbiAgICAgICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICBhdHRycy54IC09IHdpZHRoIC8gMjtcbiAgICAgICAgYXR0cnMueSAtPSBoZWlnaHQgLyAyO1xuICAgICAgICBhdHRycy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBhdHRycy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmIChyYWRpdXMuaXNaZXJvKCkpIHJhZGl1cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChyYWRpdXMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgYXR0cnMuciA9IHJhZGl1cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRycy5yeCA9IHJhZGl1cy53aWR0aDtcbiAgICAgICAgICBhdHRycy5yeSA9IHJhZGl1cy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKHR5cGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydENvbXBvdW5kUGF0aChpdGVtLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcbiAgICAgIHZhciBkYXRhID0gaXRlbS5nZXRQYXRoRGF0YShudWxsLCBvcHRpb25zLnByZWNpc2lvbik7XG4gICAgICBpZiAoZGF0YSkgYXR0cnMuZCA9IGRhdGE7XG4gICAgICByZXR1cm4gU3ZnRWxlbWVudC5jcmVhdGUoJ3BhdGgnLCBhdHRycywgZm9ybWF0dGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRTeW1ib2xJdGVtKGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpLFxuICAgICAgICAgIGRlZmluaXRpb24gPSBpdGVtLl9kZWZpbml0aW9uLFxuICAgICAgICAgIG5vZGUgPSBnZXREZWZpbml0aW9uKGRlZmluaXRpb24sICdzeW1ib2wnKSxcbiAgICAgICAgICBkZWZpbml0aW9uSXRlbSA9IGRlZmluaXRpb24uX2l0ZW0sXG4gICAgICAgICAgYm91bmRzID0gZGVmaW5pdGlvbkl0ZW0uZ2V0U3Ryb2tlQm91bmRzKCk7XG5cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3N5bWJvbCcsIHtcbiAgICAgICAgICB2aWV3Qm94OiBmb3JtYXR0ZXIucmVjdGFuZ2xlKGJvdW5kcylcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGRlZmluaXRpb25JdGVtLCBvcHRpb25zKSk7XG4gICAgICAgIHNldERlZmluaXRpb24oZGVmaW5pdGlvbiwgbm9kZSwgJ3N5bWJvbCcpO1xuICAgICAgfVxuXG4gICAgICBhdHRycy5ocmVmID0gJyMnICsgbm9kZS5pZDtcbiAgICAgIGF0dHJzLnggKz0gYm91bmRzLng7XG4gICAgICBhdHRycy55ICs9IGJvdW5kcy55O1xuICAgICAgYXR0cnMud2lkdGggPSBib3VuZHMud2lkdGg7XG4gICAgICBhdHRycy5oZWlnaHQgPSBib3VuZHMuaGVpZ2h0O1xuICAgICAgYXR0cnMub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG4gICAgICByZXR1cm4gU3ZnRWxlbWVudC5jcmVhdGUoJ3VzZScsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydEdyYWRpZW50KGNvbG9yKSB7XG4gICAgICB2YXIgZ3JhZGllbnROb2RlID0gZ2V0RGVmaW5pdGlvbihjb2xvciwgJ2NvbG9yJyk7XG5cbiAgICAgIGlmICghZ3JhZGllbnROb2RlKSB7XG4gICAgICAgIHZhciBncmFkaWVudCA9IGNvbG9yLmdldEdyYWRpZW50KCksXG4gICAgICAgICAgICByYWRpYWwgPSBncmFkaWVudC5fcmFkaWFsLFxuICAgICAgICAgICAgb3JpZ2luID0gY29sb3IuZ2V0T3JpZ2luKCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbiA9IGNvbG9yLmdldERlc3RpbmF0aW9uKCksXG4gICAgICAgICAgICBhdHRycztcblxuICAgICAgICBpZiAocmFkaWFsKSB7XG4gICAgICAgICAgYXR0cnMgPSB7XG4gICAgICAgICAgICBjeDogb3JpZ2luLngsXG4gICAgICAgICAgICBjeTogb3JpZ2luLnksXG4gICAgICAgICAgICByOiBvcmlnaW4uZ2V0RGlzdGFuY2UoZGVzdGluYXRpb24pXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gY29sb3IuZ2V0SGlnaGxpZ2h0KCk7XG5cbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICBhdHRycy5meCA9IGhpZ2hsaWdodC54O1xuICAgICAgICAgICAgYXR0cnMuZnkgPSBoaWdobGlnaHQueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0cnMgPSB7XG4gICAgICAgICAgICB4MTogb3JpZ2luLngsXG4gICAgICAgICAgICB5MTogb3JpZ2luLnksXG4gICAgICAgICAgICB4MjogZGVzdGluYXRpb24ueCxcbiAgICAgICAgICAgIHkyOiBkZXN0aW5hdGlvbi55XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJzLmdyYWRpZW50VW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xuICAgICAgICBncmFkaWVudE5vZGUgPSBTdmdFbGVtZW50LmNyZWF0ZSgocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJykgKyAnR3JhZGllbnQnLCBhdHRycywgZm9ybWF0dGVyKTtcbiAgICAgICAgdmFyIHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXSxcbiAgICAgICAgICAgICAgc3RvcENvbG9yID0gc3RvcC5fY29sb3IsXG4gICAgICAgICAgICAgIGFscGhhID0gc3RvcENvbG9yLmdldEFscGhhKCksXG4gICAgICAgICAgICAgIG9mZnNldCA9IHN0b3AuX29mZnNldDtcbiAgICAgICAgICBhdHRycyA9IHtcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0ID09IG51bGwgPyBpIC8gKGwgLSAxKSA6IG9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHN0b3BDb2xvcikgYXR0cnNbJ3N0b3AtY29sb3InXSA9IHN0b3BDb2xvci50b0NTUyh0cnVlKTtcbiAgICAgICAgICBpZiAoYWxwaGEgPCAxKSBhdHRyc1snc3RvcC1vcGFjaXR5J10gPSBhbHBoYTtcbiAgICAgICAgICBncmFkaWVudE5vZGUuYXBwZW5kQ2hpbGQoU3ZnRWxlbWVudC5jcmVhdGUoJ3N0b3AnLCBhdHRycywgZm9ybWF0dGVyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXREZWZpbml0aW9uKGNvbG9yLCBncmFkaWVudE5vZGUsICdjb2xvcicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ3VybCgjJyArIGdyYWRpZW50Tm9kZS5pZCArICcpJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRUZXh0KGl0ZW0pIHtcbiAgICAgIHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3RleHQnLCBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSwgZm9ybWF0dGVyKTtcbiAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBpdGVtLl9jb250ZW50O1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgdmFyIGV4cG9ydGVycyA9IHtcbiAgICAgIEdyb3VwOiBleHBvcnRHcm91cCxcbiAgICAgIExheWVyOiBleHBvcnRHcm91cCxcbiAgICAgIFJhc3RlcjogZXhwb3J0UmFzdGVyLFxuICAgICAgUGF0aDogZXhwb3J0UGF0aCxcbiAgICAgIFNoYXBlOiBleHBvcnRTaGFwZSxcbiAgICAgIENvbXBvdW5kUGF0aDogZXhwb3J0Q29tcG91bmRQYXRoLFxuICAgICAgU3ltYm9sSXRlbTogZXhwb3J0U3ltYm9sSXRlbSxcbiAgICAgIFBvaW50VGV4dDogZXhwb3J0VGV4dFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuICAgICAgdmFyIGF0dHJzID0ge30sXG4gICAgICAgICAgcGFyZW50ID0gIWlzUm9vdCAmJiBpdGVtLmdldFBhcmVudCgpLFxuICAgICAgICAgIHN0eWxlID0gW107XG4gICAgICBpZiAoaXRlbS5fbmFtZSAhPSBudWxsKSBhdHRycy5pZCA9IGl0ZW0uX25hbWU7XG4gICAgICBCYXNlLmVhY2goU3ZnU3R5bGVzLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgdmFyIGdldCA9IGVudHJ5LmdldCxcbiAgICAgICAgICAgIHR5cGUgPSBlbnRyeS50eXBlLFxuICAgICAgICAgICAgdmFsdWUgPSBpdGVtW2dldF0oKTtcblxuICAgICAgICBpZiAoZW50cnkuZXhwb3J0RmlsdGVyID8gZW50cnkuZXhwb3J0RmlsdGVyKGl0ZW0sIHZhbHVlKSA6ICFwYXJlbnQgfHwgIUJhc2UuZXF1YWxzKHBhcmVudFtnZXRdKCksIHZhbHVlKSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29sb3InICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IHZhbHVlLmdldEFscGhhKCk7XG4gICAgICAgICAgICBpZiAoYWxwaGEgPCAxKSBhdHRyc1tlbnRyeS5hdHRyaWJ1dGUgKyAnLW9wYWNpdHknXSA9IGFscGhhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBzdHlsZS5wdXNoKGVudHJ5LmF0dHJpYnV0ZSArICc6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJzW2VudHJ5LmF0dHJpYnV0ZV0gPSB2YWx1ZSA9PSBudWxsID8gJ25vbmUnIDogdHlwZSA9PT0gJ2NvbG9yJyA/IHZhbHVlLmdyYWRpZW50ID8gZXhwb3J0R3JhZGllbnQodmFsdWUsIGl0ZW0pIDogdmFsdWUudG9DU1ModHJ1ZSkgOiB0eXBlID09PSAnYXJyYXknID8gdmFsdWUuam9pbignLCcpIDogdHlwZSA9PT0gJ2xvb2t1cCcgPyBlbnRyeS50b1NWR1t2YWx1ZV0gOiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHN0eWxlLmxlbmd0aCkgYXR0cnMuc3R5bGUgPSBzdHlsZS5qb2luKCc7Jyk7XG4gICAgICBpZiAoYXR0cnMub3BhY2l0eSA9PT0gMSkgZGVsZXRlIGF0dHJzLm9wYWNpdHk7XG4gICAgICBpZiAoIWl0ZW0uX3Zpc2libGUpIGF0dHJzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIHJldHVybiBTdmdFbGVtZW50LnNldChub2RlLCBhdHRycywgZm9ybWF0dGVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmaW5pdGlvbnM7XG5cbiAgICBmdW5jdGlvbiBnZXREZWZpbml0aW9uKGl0ZW0sIHR5cGUpIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbnMpIGRlZmluaXRpb25zID0ge1xuICAgICAgICBpZHM6IHt9LFxuICAgICAgICBzdmdzOiB7fVxuICAgICAgfTtcbiAgICAgIHJldHVybiBpdGVtICYmIGRlZmluaXRpb25zLnN2Z3NbdHlwZSArICctJyArIChpdGVtLl9pZCB8fCBpdGVtLl9faWQgfHwgKGl0ZW0uX19pZCA9IFVJRC5nZXQoJ3N2ZycpKSldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldERlZmluaXRpb24oaXRlbSwgbm9kZSwgdHlwZSkge1xuICAgICAgaWYgKCFkZWZpbml0aW9ucykgZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgdmFyIHR5cGVJZCA9IGRlZmluaXRpb25zLmlkc1t0eXBlXSA9IChkZWZpbml0aW9ucy5pZHNbdHlwZV0gfHwgMCkgKyAxO1xuICAgICAgbm9kZS5pZCA9IHR5cGUgKyAnLScgKyB0eXBlSWQ7XG4gICAgICBkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyAoaXRlbS5faWQgfHwgaXRlbS5fX2lkKV0gPSBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdmcgPSBub2RlLFxuICAgICAgICAgIGRlZnMgPSBudWxsO1xuXG4gICAgICBpZiAoZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgc3ZnID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyAmJiBub2RlO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gZGVmaW5pdGlvbnMuc3Zncykge1xuICAgICAgICAgIGlmICghZGVmcykge1xuICAgICAgICAgICAgaWYgKCFzdmcpIHtcbiAgICAgICAgICAgICAgc3ZnID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3N2ZycpO1xuICAgICAgICAgICAgICBzdmcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZnMgPSBzdmcuaW5zZXJ0QmVmb3JlKFN2Z0VsZW1lbnQuY3JlYXRlKCdkZWZzJyksIHN2Zy5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGRlZmluaXRpb25zLnN2Z3NbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmaW5pdGlvbnMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucy5hc1N0cmluZyA/IG5ldyBzZWxmLlhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpIDogc3ZnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydFNWRyhpdGVtLCBvcHRpb25zLCBpc1Jvb3QpIHtcbiAgICAgIHZhciBleHBvcnRlciA9IGV4cG9ydGVyc1tpdGVtLl9jbGFzc10sXG4gICAgICAgICAgbm9kZSA9IGV4cG9ydGVyICYmIGV4cG9ydGVyKGl0ZW0sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICB2YXIgb25FeHBvcnQgPSBvcHRpb25zLm9uRXhwb3J0O1xuICAgICAgICBpZiAob25FeHBvcnQpIG5vZGUgPSBvbkV4cG9ydChpdGVtLCBub2RlLCBvcHRpb25zKSB8fCBub2RlO1xuICAgICAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uX2RhdGEpO1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhICE9PSAne30nICYmIGRhdGEgIT09ICdudWxsJykgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZSAmJiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgIGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgSXRlbS5pbmplY3Qoe1xuICAgICAgZXhwb3J0U1ZHOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydERlZmluaXRpb25zKGV4cG9ydFNWRyh0aGlzLCBvcHRpb25zLCB0cnVlKSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgUHJvamVjdC5pbmplY3Qoe1xuICAgICAgZXhwb3J0U1ZHOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgICB2aWV3ID0gdGhpcy5nZXRWaWV3KCksXG4gICAgICAgICAgICBib3VuZHMgPSBCYXNlLnBpY2sob3B0aW9ucy5ib3VuZHMsICd2aWV3JyksXG4gICAgICAgICAgICBteCA9IG9wdGlvbnMubWF0cml4IHx8IGJvdW5kcyA9PT0gJ3ZpZXcnICYmIHZpZXcuX21hdHJpeCxcbiAgICAgICAgICAgIG1hdHJpeCA9IG14ICYmIE1hdHJpeC5yZWFkKFtteF0pLFxuICAgICAgICAgICAgcmVjdCA9IGJvdW5kcyA9PT0gJ3ZpZXcnID8gbmV3IFJlY3RhbmdsZShbMCwgMF0sIHZpZXcuZ2V0Vmlld1NpemUoKSkgOiBib3VuZHMgPT09ICdjb250ZW50JyA/IEl0ZW0uX2dldEJvdW5kcyhjaGlsZHJlbiwgbWF0cml4LCB7XG4gICAgICAgICAgc3Ryb2tlOiB0cnVlXG4gICAgICAgIH0pLnJlY3QgOiBSZWN0YW5nbGUucmVhZChbYm91bmRzXSwgMCwge1xuICAgICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgYXR0cnMgPSB7XG4gICAgICAgICAgdmVyc2lvbjogJzEuMScsXG4gICAgICAgICAgeG1sbnM6IFN2Z0VsZW1lbnQuc3ZnLFxuICAgICAgICAgICd4bWxuczp4bGluayc6IFN2Z0VsZW1lbnQueGxpbmtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgIGF0dHJzLndpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICBhdHRycy5oZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICBpZiAocmVjdC54IHx8IHJlY3QueCA9PT0gMCB8fCByZWN0LnkgfHwgcmVjdC55ID09PSAwKSBhdHRycy52aWV3Qm94ID0gZm9ybWF0dGVyLnJlY3RhbmdsZShyZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3N2ZycsIGF0dHJzLCBmb3JtYXR0ZXIpLFxuICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcblxuICAgICAgICBpZiAobWF0cml4ICYmICFtYXRyaXguaXNJZGVudGl0eSgpKSB7XG4gICAgICAgICAgcGFyZW50ID0gbm9kZS5hcHBlbmRDaGlsZChTdmdFbGVtZW50LmNyZWF0ZSgnZycsIGdldFRyYW5zZm9ybShtYXRyaXgpLCBmb3JtYXR0ZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGV4cG9ydFNWRyhjaGlsZHJlbltpXSwgb3B0aW9ucywgdHJ1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KCk7XG4gIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlZmluaXRpb25zID0ge30sXG4gICAgICAgIHJvb3RTaXplO1xuXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWUobm9kZSwgbmFtZSwgaXNTdHJpbmcsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IFN2Z0VsZW1lbnQuZ2V0KG5vZGUsIG5hbWUpIHx8IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICByZXMgPSB2YWx1ZSA9PSBudWxsID8gYWxsb3dOdWxsID8gbnVsbCA6IGlzU3RyaW5nID8gJycgOiAwIDogaXNTdHJpbmcgPyB2YWx1ZSA6IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgcmV0dXJuIC8lXFxzKiQvLnRlc3QodmFsdWUpID8gcmVzIC8gMTAwICogKGFsbG93UGVyY2VudCA/IDEgOiByb290U2l6ZVsveHxed2lkdGgvLnRlc3QobmFtZSkgPyAnd2lkdGgnIDogJ2hlaWdodCddKSA6IHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQb2ludChub2RlLCB4LCB5LCBhbGxvd051bGwsIGFsbG93UGVyY2VudCwgZGVmYXVsdFgsIGRlZmF1bHRZKSB7XG4gICAgICB4ID0gZ2V0VmFsdWUobm9kZSwgeCB8fCAneCcsIGZhbHNlLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCwgZGVmYXVsdFgpO1xuICAgICAgeSA9IGdldFZhbHVlKG5vZGUsIHkgfHwgJ3knLCBmYWxzZSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQsIGRlZmF1bHRZKTtcbiAgICAgIHJldHVybiBhbGxvd051bGwgJiYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpID8gbnVsbCA6IG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTaXplKG5vZGUsIHcsIGgsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50KSB7XG4gICAgICB3ID0gZ2V0VmFsdWUobm9kZSwgdyB8fCAnd2lkdGgnLCBmYWxzZSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQpO1xuICAgICAgaCA9IGdldFZhbHVlKG5vZGUsIGggfHwgJ2hlaWdodCcsIGZhbHNlLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCk7XG4gICAgICByZXR1cm4gYWxsb3dOdWxsICYmICh3ID09IG51bGwgfHwgaCA9PSBudWxsKSA/IG51bGwgOiBuZXcgU2l6ZSh3LCBoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUsIHR5cGUsIGxvb2t1cCkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSAnbm9uZScgPyBudWxsIDogdHlwZSA9PT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHR5cGUgPT09ICdhcnJheScgPyB2YWx1ZSA/IHZhbHVlLnNwbGl0KC9bXFxzLF0rL2cpLm1hcChwYXJzZUZsb2F0KSA6IFtdIDogdHlwZSA9PT0gJ2NvbG9yJyA/IGdldERlZmluaXRpb24odmFsdWUpIHx8IHZhbHVlIDogdHlwZSA9PT0gJ2xvb2t1cCcgPyBsb29rdXBbdmFsdWVdIDogdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW1wb3J0R3JvdXAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG4gICAgICB2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsXG4gICAgICAgICAgaXNDbGlwID0gdHlwZSA9PT0gJ2NsaXBwYXRoJyxcbiAgICAgICAgICBpc0RlZnMgPSB0eXBlID09PSAnZGVmcycsXG4gICAgICAgICAgaXRlbSA9IG5ldyBHcm91cCgpLFxuICAgICAgICAgIHByb2plY3QgPSBpdGVtLl9wcm9qZWN0LFxuICAgICAgICAgIGN1cnJlbnRTdHlsZSA9IHByb2plY3QuX2N1cnJlbnRTdHlsZSxcbiAgICAgICAgICBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBpZiAoIWlzQ2xpcCAmJiAhaXNEZWZzKSB7XG4gICAgICAgIGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcbiAgICAgICAgcHJvamVjdC5fY3VycmVudFN0eWxlID0gaXRlbS5fc3R5bGUuY2xvbmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICB2YXIgZGVmcyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnZGVmcycpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGVmcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpbXBvcnROb2RlKGRlZnNbaV0sIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gbm9kZXNbaV0sXG4gICAgICAgICAgICBjaGlsZDtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiAhL15kZWZzJC9pLnRlc3QoY2hpbGROb2RlLm5vZGVOYW1lKSAmJiAoY2hpbGQgPSBpbXBvcnROb2RlKGNoaWxkTm9kZSwgb3B0aW9ucywgZmFsc2UpKSAmJiAhKGNoaWxkIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvbikpIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpdGVtLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICAgIGlmIChpc0NsaXApIGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbS5yZWR1Y2UoKSwgbm9kZSwgaXNSb290KTtcbiAgICAgIHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGN1cnJlbnRTdHlsZTtcblxuICAgICAgaWYgKGlzQ2xpcCB8fCBpc0RlZnMpIHtcbiAgICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICAgICAgaXRlbSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydFBvbHkobm9kZSwgdHlwZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdwb2ludHMnKS5tYXRjaCgvWystXT8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8vZyksXG4gICAgICAgICAgcG9pbnRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29vcmRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikgcG9pbnRzLnB1c2gobmV3IFBvaW50KHBhcnNlRmxvYXQoY29vcmRzW2ldKSwgcGFyc2VGbG9hdChjb29yZHNbaSArIDFdKSkpO1xuXG4gICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoKHBvaW50cyk7XG4gICAgICBpZiAodHlwZSA9PT0gJ3BvbHlnb24nKSBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW1wb3J0UGF0aChub2RlKSB7XG4gICAgICByZXR1cm4gUGF0aEl0ZW0uY3JlYXRlKG5vZGUuZ2V0QXR0cmlidXRlKCdkJykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydEdyYWRpZW50KG5vZGUsIHR5cGUpIHtcbiAgICAgIHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgcmFkaWFsID0gdHlwZSA9PT0gJ3JhZGlhbGdyYWRpZW50JyxcbiAgICAgICAgICBncmFkaWVudDtcblxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGdyYWRpZW50ID0gZGVmaW5pdGlvbnNbaWRdLmdldEdyYWRpZW50KCk7XG5cbiAgICAgICAgaWYgKGdyYWRpZW50Ll9yYWRpYWwgXiByYWRpYWwpIHtcbiAgICAgICAgICBncmFkaWVudCA9IGdyYWRpZW50LmNsb25lKCk7XG4gICAgICAgICAgZ3JhZGllbnQuX3JhZGlhbCA9IHJhZGlhbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICAgICAgc3RvcHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkgc3RvcHMucHVzaChhcHBseUF0dHJpYnV0ZXMobmV3IEdyYWRpZW50U3RvcCgpLCBjaGlsZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JhZGllbnQgPSBuZXcgR3JhZGllbnQoc3RvcHMsIHJhZGlhbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcmlnaW4sXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgaGlnaGxpZ2h0LFxuICAgICAgICAgIHNjYWxlVG9Cb3VuZHMgPSBnZXRWYWx1ZShub2RlLCAnZ3JhZGllbnRVbml0cycsIHRydWUpICE9PSAndXNlclNwYWNlT25Vc2UnO1xuXG4gICAgICBpZiAocmFkaWFsKSB7XG4gICAgICAgIG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScsIGZhbHNlLCBzY2FsZVRvQm91bmRzLCAnNTAlJywgJzUwJScpO1xuICAgICAgICBkZXN0aW5hdGlvbiA9IG9yaWdpbi5hZGQoZ2V0VmFsdWUobm9kZSwgJ3InLCBmYWxzZSwgZmFsc2UsIHNjYWxlVG9Cb3VuZHMsICc1MCUnKSwgMCk7XG4gICAgICAgIGhpZ2hsaWdodCA9IGdldFBvaW50KG5vZGUsICdmeCcsICdmeScsIHRydWUsIHNjYWxlVG9Cb3VuZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJywgZmFsc2UsIHNjYWxlVG9Cb3VuZHMsICcwJScsICcwJScpO1xuICAgICAgICBkZXN0aW5hdGlvbiA9IGdldFBvaW50KG5vZGUsICd4MicsICd5MicsIGZhbHNlLCBzY2FsZVRvQm91bmRzLCAnMTAwJScsICcwJScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3IgPSBhcHBseUF0dHJpYnV0ZXMobmV3IENvbG9yKGdyYWRpZW50LCBvcmlnaW4sIGRlc3RpbmF0aW9uLCBoaWdobGlnaHQpLCBub2RlKTtcbiAgICAgIGNvbG9yLl9zY2FsZVRvQm91bmRzID0gc2NhbGVUb0JvdW5kcztcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbXBvcnRlcnMgPSB7XG4gICAgICAnI2RvY3VtZW50JzogZnVuY3Rpb24gKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuICAgICAgICB2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBub2Rlc1tpXTtcbiAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHJldHVybiBpbXBvcnROb2RlKGNoaWxkLCBvcHRpb25zLCBpc1Jvb3QpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZzogaW1wb3J0R3JvdXAsXG4gICAgICBzdmc6IGltcG9ydEdyb3VwLFxuICAgICAgY2xpcHBhdGg6IGltcG9ydEdyb3VwLFxuICAgICAgcG9seWdvbjogaW1wb3J0UG9seSxcbiAgICAgIHBvbHlsaW5lOiBpbXBvcnRQb2x5LFxuICAgICAgcGF0aDogaW1wb3J0UGF0aCxcbiAgICAgIGxpbmVhcmdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcbiAgICAgIHJhZGlhbGdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcbiAgICAgIGltYWdlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgcmFzdGVyID0gbmV3IFJhc3RlcihnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpKTtcbiAgICAgICAgcmFzdGVyLm9uKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzaXplID0gZ2V0U2l6ZShub2RlKTtcbiAgICAgICAgICB0aGlzLnNldFNpemUoc2l6ZSk7XG4gICAgICAgICAgdmFyIGNlbnRlciA9IGdldFBvaW50KG5vZGUpLmFkZChzaXplLmRpdmlkZSgyKSk7XG5cbiAgICAgICAgICB0aGlzLl9tYXRyaXguYXBwZW5kKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoY2VudGVyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmFzdGVyO1xuICAgICAgfSxcbiAgICAgIHN5bWJvbDogZnVuY3Rpb24gKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuICAgICAgICByZXR1cm4gbmV3IFN5bWJvbERlZmluaXRpb24oaW1wb3J0R3JvdXAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZGVmczogaW1wb3J0R3JvdXAsXG4gICAgICB1c2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbaWRdLFxuICAgICAgICAgICAgcG9pbnQgPSBnZXRQb2ludChub2RlKTtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb24gPyBkZWZpbml0aW9uIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvbiA/IGRlZmluaXRpb24ucGxhY2UocG9pbnQpIDogZGVmaW5pdGlvbi5jbG9uZSgpLnRyYW5zbGF0ZShwb2ludCkgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGNpcmNsZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaGFwZS5DaXJjbGUoZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksIGdldFZhbHVlKG5vZGUsICdyJykpO1xuICAgICAgfSxcbiAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhcGUuRWxsaXBzZSh7XG4gICAgICAgICAgY2VudGVyOiBnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcbiAgICAgICAgICByYWRpdXM6IGdldFNpemUobm9kZSwgJ3J4JywgJ3J5JylcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVjdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaGFwZS5SZWN0YW5nbGUobmV3IFJlY3RhbmdsZShnZXRQb2ludChub2RlKSwgZ2V0U2l6ZShub2RlKSksIGdldFNpemUobm9kZSwgJ3J4JywgJ3J5JykpO1xuICAgICAgfSxcbiAgICAgIGxpbmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aC5MaW5lKGdldFBvaW50KG5vZGUsICd4MScsICd5MScpLCBnZXRQb2ludChub2RlLCAneDInLCAneTInKSk7XG4gICAgICB9LFxuICAgICAgdGV4dDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHRleHQgPSBuZXcgUG9pbnRUZXh0KGdldFBvaW50KG5vZGUpLmFkZChnZXRQb2ludChub2RlLCAnZHgnLCAnZHknKSkpO1xuICAgICAgICB0ZXh0LnNldENvbnRlbnQobm9kZS50ZXh0Q29udGVudC50cmltKCkgfHwgJycpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH0sXG4gICAgICBzd2l0Y2g6IGltcG9ydEdyb3VwXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlKSB7XG4gICAgICBpZiAoaXRlbS50cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybXMgPSAobm9kZS5nZXRBdHRyaWJ1dGUobmFtZSkgfHwgJycpLnNwbGl0KC9cXClcXHMqL2cpLFxuICAgICAgICAgICAgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHJhbnNmb3Jtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1tpXTtcbiAgICAgICAgICBpZiAoIXRyYW5zZm9ybSkgYnJlYWs7XG4gICAgICAgICAgdmFyIHBhcnRzID0gdHJhbnNmb3JtLnNwbGl0KC9cXChcXHMqLyksXG4gICAgICAgICAgICAgIGNvbW1hbmQgPSBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgdiA9IHBhcnRzWzFdLnNwbGl0KC9bXFxzLF0rL2cpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSB2Lmxlbmd0aDsgaiA8IG07IGorKykgdltqXSA9IHBhcnNlRmxvYXQodltqXSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgICAgICAgIG1hdHJpeC5hcHBlbmQobmV3IE1hdHJpeCh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgICBtYXRyaXgucm90YXRlKHZbMF0sIHZbMV0gfHwgMCwgdlsyXSB8fCAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG4gICAgICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUodlswXSwgdlsxXSB8fCAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICAgICAgbWF0cml4LnNjYWxlKHYpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc2tld1gnOlxuICAgICAgICAgICAgICBtYXRyaXguc2tldyh2WzBdLCAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgICAgICAgICAgbWF0cml4LnNrZXcoMCwgdlswXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0udHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlPcGFjaXR5KGl0ZW0sIHZhbHVlLCBuYW1lKSB7XG4gICAgICB2YXIga2V5ID0gbmFtZSA9PT0gJ2ZpbGwtb3BhY2l0eScgPyAnZ2V0RmlsbENvbG9yJyA6ICdnZXRTdHJva2VDb2xvcicsXG4gICAgICAgICAgY29sb3IgPSBpdGVtW2tleV0gJiYgaXRlbVtrZXldKCk7XG4gICAgICBpZiAoY29sb3IpIGNvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IEJhc2Uuc2V0KEJhc2UuZWFjaChTdmdTdHlsZXMsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgdGhpc1tlbnRyeS5hdHRyaWJ1dGVdID0gZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgIGlmIChpdGVtW2VudHJ5LnNldF0pIHtcbiAgICAgICAgICBpdGVtW2VudHJ5LnNldF0oY29udmVydFZhbHVlKHZhbHVlLCBlbnRyeS50eXBlLCBlbnRyeS5mcm9tU1ZHKSk7XG5cbiAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gaXRlbVtlbnRyeS5nZXRdKCk7XG5cbiAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICBpZiAoY29sb3IuX3NjYWxlVG9Cb3VuZHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gaXRlbS5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICBjb2xvci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShib3VuZHMuZ2V0UG9pbnQoKSkuc2NhbGUoYm91bmRzLmdldFNpemUoKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIHt9KSwge1xuICAgICAgaWQ6IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSkge1xuICAgICAgICBkZWZpbml0aW9uc1t2YWx1ZV0gPSBpdGVtO1xuICAgICAgICBpZiAoaXRlbS5zZXROYW1lKSBpdGVtLnNldE5hbWUodmFsdWUpO1xuICAgICAgfSxcbiAgICAgICdjbGlwLXBhdGgnOiBmdW5jdGlvbiAoaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNsaXAgPSBnZXREZWZpbml0aW9uKHZhbHVlKTtcblxuICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgIGNsaXAgPSBjbGlwLmNsb25lKCk7XG4gICAgICAgICAgY2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblxuICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgIGl0ZW0uaW5zZXJ0Q2hpbGQoMCwgY2xpcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3JvdXAoY2xpcCwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuICAgICAgdHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcbiAgICAgICdmaWxsLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG4gICAgICAnc3Ryb2tlLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG4gICAgICB2aXNpYmlsaXR5OiBmdW5jdGlvbiAoaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGl0ZW0uc2V0VmlzaWJsZSkgaXRlbS5zZXRWaXNpYmxlKHZhbHVlID09PSAndmlzaWJsZScpO1xuICAgICAgfSxcbiAgICAgIGRpc3BsYXk6IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXRlbS5zZXRWaXNpYmxlKSBpdGVtLnNldFZpc2libGUodmFsdWUgIT09IG51bGwpO1xuICAgICAgfSxcbiAgICAgICdzdG9wLWNvbG9yJzogZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgIGlmIChpdGVtLnNldENvbG9yKSBpdGVtLnNldENvbG9yKHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICAnc3RvcC1vcGFjaXR5JzogZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgIGlmIChpdGVtLl9jb2xvcikgaXRlbS5fY29sb3Iuc2V0QWxwaGEocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgfSxcbiAgICAgIG9mZnNldDogZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgIGlmIChpdGVtLnNldE9mZnNldCkge1xuICAgICAgICAgIHZhciBwZXJjZW50ID0gdmFsdWUubWF0Y2goLyguKiklJC8pO1xuICAgICAgICAgIGl0ZW0uc2V0T2Zmc2V0KHBlcmNlbnQgPyBwZXJjZW50WzFdIC8gMTAwIDogcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlld0JveDogZnVuY3Rpb24gKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgJ2FycmF5JykpLFxuICAgICAgICAgICAgc2l6ZSA9IGdldFNpemUobm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSksXG4gICAgICAgICAgICBncm91cCxcbiAgICAgICAgICAgIG1hdHJpeDtcblxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgdmFyIHNjYWxlID0gc2l6ZSA/IHNpemUuZGl2aWRlKHJlY3QuZ2V0U2l6ZSgpKSA6IDEsXG4gICAgICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZShzY2FsZSkudHJhbnNsYXRlKHJlY3QuZ2V0UG9pbnQoKS5uZWdhdGUoKSk7XG4gICAgICAgICAgZ3JvdXAgPSBpdGVtO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2xEZWZpbml0aW9uKSB7XG4gICAgICAgICAgaWYgKHNpemUpIHJlY3Quc2V0U2l6ZShzaXplKTtcbiAgICAgICAgICBncm91cCA9IGl0ZW0uX2l0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICBpZiAoZ2V0QXR0cmlidXRlKG5vZGUsICdvdmVyZmxvdycsIHN0eWxlcykgIT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgdmFyIGNsaXAgPSBuZXcgU2hhcGUuUmVjdGFuZ2xlKHJlY3QpO1xuICAgICAgICAgICAgY2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcbiAgICAgICAgICAgIGdyb3VwLmFkZENoaWxkKGNsaXApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRyaXgpIGdyb3VwLnRyYW5zZm9ybShtYXRyaXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKSB7XG4gICAgICB2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlc1tuYW1lXSxcbiAgICAgICAgICB2YWx1ZSA9IGF0dHIgJiYgYXR0ci52YWx1ZTtcblxuICAgICAgaWYgKCF2YWx1ZSAmJiBub2RlLnN0eWxlKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IEJhc2UuY2FtZWxpemUobmFtZSk7XG4gICAgICAgIHZhbHVlID0gbm9kZS5zdHlsZVtzdHlsZV07XG4gICAgICAgIGlmICghdmFsdWUgJiYgc3R5bGVzLm5vZGVbc3R5bGVdICE9PSBzdHlsZXMucGFyZW50W3N0eWxlXSkgdmFsdWUgPSBzdHlsZXMubm9kZVtzdHlsZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhdmFsdWUgPyB1bmRlZmluZWQgOiB2YWx1ZSA9PT0gJ25vbmUnID8gbnVsbCA6IHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgc3R5bGVzID0ge1xuICAgICAgICBub2RlOiBEb21FbGVtZW50LmdldFN0eWxlcyhub2RlKSB8fCB7fSxcbiAgICAgICAgcGFyZW50OiAhaXNSb290ICYmICEvXmRlZnMkL2kudGVzdChwYXJlbnQudGFnTmFtZSkgJiYgRG9tRWxlbWVudC5nZXRTdHlsZXMocGFyZW50KSB8fCB7fVxuICAgICAgfTtcbiAgICAgIEJhc2UuZWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXBwbHksIG5hbWUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcyk7XG4gICAgICAgIGl0ZW0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGFwcGx5KGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpIHx8IGl0ZW07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERlZmluaXRpb24odmFsdWUpIHtcbiAgICAgIHZhciBtYXRjaCA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9cXCgoPzpbXCInI10qKShbXlwiJyldKykvKSxcbiAgICAgICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV0sXG4gICAgICAgICAgcmVzID0gbmFtZSAmJiBkZWZpbml0aW9uc1t3aW5kb3cgPyBuYW1lLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVswXSArICcjJywgJycpIDogbmFtZV07XG5cbiAgICAgIGlmIChyZXMgJiYgcmVzLl9zY2FsZVRvQm91bmRzKSB7XG4gICAgICAgIHJlcyA9IHJlcy5jbG9uZSgpO1xuICAgICAgICByZXMuX3NjYWxlVG9Cb3VuZHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydE5vZGUobm9kZSwgb3B0aW9ucywgaXNSb290KSB7XG4gICAgICB2YXIgdHlwZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBpc0VsZW1lbnQgPSB0eXBlICE9PSAnI2RvY3VtZW50JyxcbiAgICAgICAgICBib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIG5leHQ7XG5cbiAgICAgIGlmIChpc1Jvb3QgJiYgaXNFbGVtZW50KSB7XG4gICAgICAgIHJvb3RTaXplID0gcGFwZXIuZ2V0VmlldygpLmdldFNpemUoKTtcbiAgICAgICAgcm9vdFNpemUgPSBnZXRTaXplKG5vZGUsIG51bGwsIG51bGwsIHRydWUpIHx8IHJvb3RTaXplO1xuICAgICAgICBjb250YWluZXIgPSBTdmdFbGVtZW50LmNyZWF0ZSgnc3ZnJywge1xuICAgICAgICAgIHN0eWxlOiAnc3Ryb2tlLXdpZHRoOiAxcHg7IHN0cm9rZS1taXRlcmxpbWl0OiAxMCdcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBwYXBlci5zZXR0aW5ncyxcbiAgICAgICAgICBhcHBseU1hdHJpeCA9IHNldHRpbmdzLmFwcGx5TWF0cml4LFxuICAgICAgICAgIGluc2VydEl0ZW1zID0gc2V0dGluZ3MuaW5zZXJ0SXRlbXM7XG4gICAgICBzZXR0aW5ncy5hcHBseU1hdHJpeCA9IGZhbHNlO1xuICAgICAgc2V0dGluZ3MuaW5zZXJ0SXRlbXMgPSBmYWxzZTtcbiAgICAgIHZhciBpbXBvcnRlciA9IGltcG9ydGVyc1t0eXBlXSxcbiAgICAgICAgICBpdGVtID0gaW1wb3J0ZXIgJiYgaW1wb3J0ZXIobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB8fCBudWxsO1xuICAgICAgc2V0dGluZ3MuaW5zZXJ0SXRlbXMgPSBpbnNlcnRJdGVtcztcbiAgICAgIHNldHRpbmdzLmFwcGx5TWF0cml4ID0gYXBwbHlNYXRyaXg7XG5cbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQgJiYgIShpdGVtIGluc3RhbmNlb2YgR3JvdXApKSBpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG4gICAgICAgIHZhciBvbkltcG9ydCA9IG9wdGlvbnMub25JbXBvcnQsXG4gICAgICAgICAgICBkYXRhID0gaXNFbGVtZW50ICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnKTtcbiAgICAgICAgaWYgKG9uSW1wb3J0KSBpdGVtID0gb25JbXBvcnQobm9kZSwgaXRlbSwgb3B0aW9ucykgfHwgaXRlbTtcblxuICAgICAgICBpZiAob3B0aW9ucy5leHBhbmRTaGFwZXMgJiYgaXRlbSBpbnN0YW5jZW9mIFNoYXBlKSB7XG4gICAgICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICAgICAgICBpdGVtID0gaXRlbS50b1BhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSBpdGVtLl9kYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgZGVmaW5pdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgQmFzZS5waWNrKG9wdGlvbnMuYXBwbHlNYXRyaXgsIGFwcGx5TWF0cml4KSkgaXRlbS5tYXRyaXguYXBwbHkodHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydFNWRyhzb3VyY2UsIG9wdGlvbnMsIG93bmVyKSB7XG4gICAgICBpZiAoIXNvdXJjZSkgcmV0dXJuIG51bGw7XG4gICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyB7XG4gICAgICAgIG9uTG9hZDogb3B0aW9uc1xuICAgICAgfSA6IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgc2NvcGUgPSBwYXBlcixcbiAgICAgICAgICBpdGVtID0gbnVsbDtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkKHN2Zykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBub2RlID0gdHlwZW9mIHN2ZyA9PT0gJ29iamVjdCcgPyBzdmcgOiBuZXcgc2VsZi5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc3ZnLnRyaW0oKSwgJ2ltYWdlL3N2Zyt4bWwnKTtcblxuICAgICAgICAgIGlmICghbm9kZS5ub2RlTmFtZSkge1xuICAgICAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFNWRyBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcGVyID0gc2NvcGU7XG4gICAgICAgICAgaXRlbSA9IGltcG9ydE5vZGUobm9kZSwgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5pbnNlcnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvd25lci5faW5zZXJ0SXRlbSh1bmRlZmluZWQsIGl0ZW0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvbkxvYWQgPSBvcHRpb25zLm9uTG9hZDtcbiAgICAgICAgICBpZiAob25Mb2FkKSBvbkxvYWQoaXRlbSwgc3ZnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihtZXNzYWdlLCBzdGF0dXMpIHtcbiAgICAgICAgdmFyIG9uRXJyb3IgPSBvcHRpb25zLm9uRXJyb3I7XG5cbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKG1lc3NhZ2UsIHN0YXR1cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiAhL15bXFxzXFxTXSo8Ly50ZXN0KHNvdXJjZSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzb3VyY2UpO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgb25Mb2FkKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICB1cmw6IHNvdXJjZSxcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgb25Mb2FkOiBvbkxvYWQsXG4gICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHNvdXJjZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvbkxvYWQocmVhZGVyLnJlc3VsdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb25FcnJvcihyZWFkZXIuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEFzVGV4dChzb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25Mb2FkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIEl0ZW0uaW5qZWN0KHtcbiAgICAgIGltcG9ydFNWRzogZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydFNWRyhub2RlLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBQcm9qZWN0LmluamVjdCh7XG4gICAgICBpbXBvcnRTVkc6IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgcmV0dXJuIGltcG9ydFNWRyhub2RlLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSgpO1xuXG4gIEJhc2UuZXhwb3J0cy5QYXBlclNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2xvYmFsID0gdGhpcyxcbiAgICAgICAgYWNvcm4gPSBnbG9iYWwuYWNvcm47XG5cbiAgICBpZiAoIWFjb3JuICYmIHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWNvcm4gPSByZXF1aXJlKCdhY29ybicpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICBpZiAoIWFjb3JuKSB7XG4gICAgICB2YXIgZXhwb3J0cywgbW9kdWxlO1xuICAgICAgYWNvcm4gPSBleHBvcnRzID0gbW9kdWxlID0ge307XG5cbiAgICAgIChmdW5jdGlvbiAocm9vdCwgbW9kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgcmV0dXJuIG1vZChleHBvcnRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHJldHVybiBkZWZpbmUoW1wiZXhwb3J0c1wiXSwgbW9kKTtcbiAgICAgICAgbW9kKHJvb3QuYWNvcm4gfHwgKHJvb3QuYWNvcm4gPSB7fSkpO1xuICAgICAgfSkodGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgZXhwb3J0cy52ZXJzaW9uID0gXCIwLjUuMFwiO1xuICAgICAgICB2YXIgb3B0aW9ucywgaW5wdXQsIGlucHV0TGVuLCBzb3VyY2VGaWxlO1xuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoaW5wdCwgb3B0cykge1xuICAgICAgICAgIGlucHV0ID0gU3RyaW5nKGlucHQpO1xuICAgICAgICAgIGlucHV0TGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgIHNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgICAgaW5pdFRva2VuU3RhdGUoKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VUb3BMZXZlbChvcHRpb25zLnByb2dyYW0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgZWNtYVZlcnNpb246IDUsXG4gICAgICAgICAgc3RyaWN0U2VtaWNvbG9uczogZmFsc2UsXG4gICAgICAgICAgYWxsb3dUcmFpbGluZ0NvbW1hczogdHJ1ZSxcbiAgICAgICAgICBmb3JiaWRSZXNlcnZlZDogZmFsc2UsXG4gICAgICAgICAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgICAgICAgIGxvY2F0aW9uczogZmFsc2UsXG4gICAgICAgICAgb25Db21tZW50OiBudWxsLFxuICAgICAgICAgIHJhbmdlczogZmFsc2UsXG4gICAgICAgICAgcHJvZ3JhbTogbnVsbCxcbiAgICAgICAgICBzb3VyY2VGaWxlOiBudWxsLFxuICAgICAgICAgIGRpcmVjdFNvdXJjZUZpbGU6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdHMpIHtcbiAgICAgICAgICBvcHRpb25zID0gb3B0cyB8fCB7fTtcblxuICAgICAgICAgIGZvciAodmFyIG9wdCBpbiBkZWZhdWx0T3B0aW9ucykgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgb3B0KSkgb3B0aW9uc1tvcHRdID0gZGVmYXVsdE9wdGlvbnNbb3B0XTtcblxuICAgICAgICAgIHNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGUgfHwgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnZXRMaW5lSW5mbyA9IGV4cG9ydHMuZ2V0TGluZUluZm8gPSBmdW5jdGlvbiAoaW5wdXQsIG9mZnNldCkge1xuICAgICAgICAgIGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICAgICAgICAgIGxpbmVCcmVhay5sYXN0SW5kZXggPSBjdXI7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA8IG9mZnNldCkge1xuICAgICAgICAgICAgICArK2xpbmU7XG4gICAgICAgICAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvZmZzZXQgLSBjdXJcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGV4cG9ydHMudG9rZW5pemUgPSBmdW5jdGlvbiAoaW5wdCwgb3B0cykge1xuICAgICAgICAgIGlucHV0ID0gU3RyaW5nKGlucHQpO1xuICAgICAgICAgIGlucHV0TGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgIHNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgICAgaW5pdFRva2VuU3RhdGUoKTtcbiAgICAgICAgICB2YXIgdCA9IHt9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VG9rZW4oZm9yY2VSZWdleHApIHtcbiAgICAgICAgICAgIGxhc3RFbmQgPSB0b2tFbmQ7XG4gICAgICAgICAgICByZWFkVG9rZW4oZm9yY2VSZWdleHApO1xuICAgICAgICAgICAgdC5zdGFydCA9IHRva1N0YXJ0O1xuICAgICAgICAgICAgdC5lbmQgPSB0b2tFbmQ7XG4gICAgICAgICAgICB0LnN0YXJ0TG9jID0gdG9rU3RhcnRMb2M7XG4gICAgICAgICAgICB0LmVuZExvYyA9IHRva0VuZExvYztcbiAgICAgICAgICAgIHQudHlwZSA9IHRva1R5cGU7XG4gICAgICAgICAgICB0LnZhbHVlID0gdG9rVmFsO1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0VG9rZW4uanVtcFRvID0gZnVuY3Rpb24gKHBvcywgcmVBbGxvd2VkKSB7XG4gICAgICAgICAgICB0b2tQb3MgPSBwb3M7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgICB0b2tDdXJMaW5lID0gMTtcbiAgICAgICAgICAgICAgdG9rTGluZVN0YXJ0ID0gbGluZUJyZWFrLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgIHZhciBtYXRjaDtcblxuICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrLmV4ZWMoaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHBvcykge1xuICAgICAgICAgICAgICAgICsrdG9rQ3VyTGluZTtcbiAgICAgICAgICAgICAgICB0b2tMaW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b2tSZWdleHBBbGxvd2VkID0gcmVBbGxvd2VkO1xuICAgICAgICAgICAgc2tpcFNwYWNlKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBnZXRUb2tlbjtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9rUG9zO1xuICAgICAgICB2YXIgdG9rU3RhcnQsIHRva0VuZDtcbiAgICAgICAgdmFyIHRva1N0YXJ0TG9jLCB0b2tFbmRMb2M7XG4gICAgICAgIHZhciB0b2tUeXBlLCB0b2tWYWw7XG4gICAgICAgIHZhciB0b2tSZWdleHBBbGxvd2VkO1xuICAgICAgICB2YXIgdG9rQ3VyTGluZSwgdG9rTGluZVN0YXJ0O1xuICAgICAgICB2YXIgbGFzdFN0YXJ0LCBsYXN0RW5kLCBsYXN0RW5kTG9jO1xuICAgICAgICB2YXIgaW5GdW5jdGlvbiwgbGFiZWxzLCBzdHJpY3Q7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFpc2UocG9zLCBtZXNzYWdlKSB7XG4gICAgICAgICAgdmFyIGxvYyA9IGdldExpbmVJbmZvKGlucHV0LCBwb3MpO1xuICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVyci5wb3MgPSBwb3M7XG4gICAgICAgICAgZXJyLmxvYyA9IGxvYztcbiAgICAgICAgICBlcnIucmFpc2VkQXQgPSB0b2tQb3M7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVtcHR5ID0gW107XG4gICAgICAgIHZhciBfbnVtID0ge1xuICAgICAgICAgIHR5cGU6IFwibnVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZWdleHAgPSB7XG4gICAgICAgICAgdHlwZTogXCJyZWdleHBcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX3N0cmluZyA9IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfbmFtZSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm5hbWVcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX2VvZiA9IHtcbiAgICAgICAgICB0eXBlOiBcImVvZlwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfYnJlYWsgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJicmVha1wiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfY2FzZSA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImNhc2VcIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfY2F0Y2ggPSB7XG4gICAgICAgICAga2V5d29yZDogXCJjYXRjaFwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfY29udGludWUgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJjb250aW51ZVwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfZGVidWdnZXIgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJkZWJ1Z2dlclwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfZGVmYXVsdCA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImRlZmF1bHRcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2RvID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiZG9cIixcbiAgICAgICAgICBpc0xvb3A6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9lbHNlID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiZWxzZVwiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9maW5hbGx5ID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiZmluYWxseVwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfZm9yID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiZm9yXCIsXG4gICAgICAgICAgaXNMb29wOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfZnVuY3Rpb24gPSB7XG4gICAgICAgICAga2V5d29yZDogXCJmdW5jdGlvblwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfaWYgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJpZlwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfcmV0dXJuID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwicmV0dXJuXCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX3N3aXRjaCA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcInN3aXRjaFwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfdGhyb3cgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJ0aHJvd1wiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF90cnkgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJ0cnlcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX3ZhciA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcInZhclwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfd2hpbGUgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJ3aGlsZVwiLFxuICAgICAgICAgIGlzTG9vcDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX3dpdGggPSB7XG4gICAgICAgICAga2V5d29yZDogXCJ3aXRoXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9uZXcgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJuZXdcIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfdGhpcyA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcInRoaXNcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgX251bGwgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJudWxsXCIsXG4gICAgICAgICAgYXRvbVZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfdHJ1ZSA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcInRydWVcIixcbiAgICAgICAgICBhdG9tVmFsdWU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9mYWxzZSA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImZhbHNlXCIsXG4gICAgICAgICAgYXRvbVZhbHVlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2luID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiaW5cIixcbiAgICAgICAgICBiaW5vcDogNyxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBrZXl3b3JkVHlwZXMgPSB7XG4gICAgICAgICAgXCJicmVha1wiOiBfYnJlYWssXG4gICAgICAgICAgXCJjYXNlXCI6IF9jYXNlLFxuICAgICAgICAgIFwiY2F0Y2hcIjogX2NhdGNoLFxuICAgICAgICAgIFwiY29udGludWVcIjogX2NvbnRpbnVlLFxuICAgICAgICAgIFwiZGVidWdnZXJcIjogX2RlYnVnZ2VyLFxuICAgICAgICAgIFwiZGVmYXVsdFwiOiBfZGVmYXVsdCxcbiAgICAgICAgICBcImRvXCI6IF9kbyxcbiAgICAgICAgICBcImVsc2VcIjogX2Vsc2UsXG4gICAgICAgICAgXCJmaW5hbGx5XCI6IF9maW5hbGx5LFxuICAgICAgICAgIFwiZm9yXCI6IF9mb3IsXG4gICAgICAgICAgXCJmdW5jdGlvblwiOiBfZnVuY3Rpb24sXG4gICAgICAgICAgXCJpZlwiOiBfaWYsXG4gICAgICAgICAgXCJyZXR1cm5cIjogX3JldHVybixcbiAgICAgICAgICBcInN3aXRjaFwiOiBfc3dpdGNoLFxuICAgICAgICAgIFwidGhyb3dcIjogX3Rocm93LFxuICAgICAgICAgIFwidHJ5XCI6IF90cnksXG4gICAgICAgICAgXCJ2YXJcIjogX3ZhcixcbiAgICAgICAgICBcIndoaWxlXCI6IF93aGlsZSxcbiAgICAgICAgICBcIndpdGhcIjogX3dpdGgsXG4gICAgICAgICAgXCJudWxsXCI6IF9udWxsLFxuICAgICAgICAgIFwidHJ1ZVwiOiBfdHJ1ZSxcbiAgICAgICAgICBcImZhbHNlXCI6IF9mYWxzZSxcbiAgICAgICAgICBcIm5ld1wiOiBfbmV3LFxuICAgICAgICAgIFwiaW5cIjogX2luLFxuICAgICAgICAgIFwiaW5zdGFuY2VvZlwiOiB7XG4gICAgICAgICAgICBrZXl3b3JkOiBcImluc3RhbmNlb2ZcIixcbiAgICAgICAgICAgIGJpbm9wOiA3LFxuICAgICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0aGlzXCI6IF90aGlzLFxuICAgICAgICAgIFwidHlwZW9mXCI6IHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwidHlwZW9mXCIsXG4gICAgICAgICAgICBwcmVmaXg6IHRydWUsXG4gICAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInZvaWRcIjoge1xuICAgICAgICAgICAga2V5d29yZDogXCJ2b2lkXCIsXG4gICAgICAgICAgICBwcmVmaXg6IHRydWUsXG4gICAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRlbGV0ZVwiOiB7XG4gICAgICAgICAgICBrZXl3b3JkOiBcImRlbGV0ZVwiLFxuICAgICAgICAgICAgcHJlZml4OiB0cnVlLFxuICAgICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9icmFja2V0TCA9IHtcbiAgICAgICAgICB0eXBlOiBcIltcIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfYnJhY2tldFIgPSB7XG4gICAgICAgICAgdHlwZTogXCJdXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9icmFjZUwgPSB7XG4gICAgICAgICAgdHlwZTogXCJ7XCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2JyYWNlUiA9IHtcbiAgICAgICAgICB0eXBlOiBcIn1cIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX3BhcmVuTCA9IHtcbiAgICAgICAgICB0eXBlOiBcIihcIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfcGFyZW5SID0ge1xuICAgICAgICAgIHR5cGU6IFwiKVwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfY29tbWEgPSB7XG4gICAgICAgICAgdHlwZTogXCIsXCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX3NlbWkgPSB7XG4gICAgICAgICAgdHlwZTogXCI7XCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2NvbG9uID0ge1xuICAgICAgICAgIHR5cGU6IFwiOlwiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9kb3QgPSB7XG4gICAgICAgICAgdHlwZTogXCIuXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9xdWVzdGlvbiA9IHtcbiAgICAgICAgICB0eXBlOiBcIj9cIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfc2xhc2ggPSB7XG4gICAgICAgICAgYmlub3A6IDEwLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9lcSA9IHtcbiAgICAgICAgICBpc0Fzc2lnbjogdHJ1ZSxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfYXNzaWduID0ge1xuICAgICAgICAgIGlzQXNzaWduOiB0cnVlLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9pbmNEZWMgPSB7XG4gICAgICAgICAgcG9zdGZpeDogdHJ1ZSxcbiAgICAgICAgICBwcmVmaXg6IHRydWUsXG4gICAgICAgICAgaXNVcGRhdGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9wcmVmaXggPSB7XG4gICAgICAgICAgcHJlZml4OiB0cnVlLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9sb2dpY2FsT1IgPSB7XG4gICAgICAgICAgYmlub3A6IDEsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2xvZ2ljYWxBTkQgPSB7XG4gICAgICAgICAgYmlub3A6IDIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2JpdHdpc2VPUiA9IHtcbiAgICAgICAgICBiaW5vcDogMyxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfYml0d2lzZVhPUiA9IHtcbiAgICAgICAgICBiaW5vcDogNCxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfYml0d2lzZUFORCA9IHtcbiAgICAgICAgICBiaW5vcDogNSxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfZXF1YWxpdHkgPSB7XG4gICAgICAgICAgYmlub3A6IDYsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3JlbGF0aW9uYWwgPSB7XG4gICAgICAgICAgYmlub3A6IDcsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2JpdFNoaWZ0ID0ge1xuICAgICAgICAgIGJpbm9wOiA4LFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9wbHVzTWluID0ge1xuICAgICAgICAgIGJpbm9wOiA5LFxuICAgICAgICAgIHByZWZpeDogdHJ1ZSxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfbXVsdGlwbHlNb2R1bG8gPSB7XG4gICAgICAgICAgYmlub3A6IDEwLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgZXhwb3J0cy50b2tUeXBlcyA9IHtcbiAgICAgICAgICBicmFja2V0TDogX2JyYWNrZXRMLFxuICAgICAgICAgIGJyYWNrZXRSOiBfYnJhY2tldFIsXG4gICAgICAgICAgYnJhY2VMOiBfYnJhY2VMLFxuICAgICAgICAgIGJyYWNlUjogX2JyYWNlUixcbiAgICAgICAgICBwYXJlbkw6IF9wYXJlbkwsXG4gICAgICAgICAgcGFyZW5SOiBfcGFyZW5SLFxuICAgICAgICAgIGNvbW1hOiBfY29tbWEsXG4gICAgICAgICAgc2VtaTogX3NlbWksXG4gICAgICAgICAgY29sb246IF9jb2xvbixcbiAgICAgICAgICBkb3Q6IF9kb3QsXG4gICAgICAgICAgcXVlc3Rpb246IF9xdWVzdGlvbixcbiAgICAgICAgICBzbGFzaDogX3NsYXNoLFxuICAgICAgICAgIGVxOiBfZXEsXG4gICAgICAgICAgbmFtZTogX25hbWUsXG4gICAgICAgICAgZW9mOiBfZW9mLFxuICAgICAgICAgIG51bTogX251bSxcbiAgICAgICAgICByZWdleHA6IF9yZWdleHAsXG4gICAgICAgICAgc3RyaW5nOiBfc3RyaW5nXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIga3cgaW4ga2V5d29yZFR5cGVzKSBleHBvcnRzLnRva1R5cGVzW1wiX1wiICsga3ddID0ga2V5d29yZFR5cGVzW2t3XTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlUHJlZGljYXRlKHdvcmRzKSB7XG4gICAgICAgICAgd29yZHMgPSB3b3Jkcy5zcGxpdChcIiBcIik7XG4gICAgICAgICAgdmFyIGYgPSBcIlwiLFxuICAgICAgICAgICAgICBjYXRzID0gW107XG5cbiAgICAgICAgICBvdXQ6IGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2F0cy5sZW5ndGg7ICsraikgaWYgKGNhdHNbal1bMF0ubGVuZ3RoID09IHdvcmRzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjYXRzW2pdLnB1c2god29yZHNbaV0pO1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhdHMucHVzaChbd29yZHNbaV1dKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjb21wYXJlVG8oYXJyKSB7XG4gICAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PSAxKSByZXR1cm4gZiArPSBcInJldHVybiBzdHIgPT09IFwiICsgSlNPTi5zdHJpbmdpZnkoYXJyWzBdKSArIFwiO1wiO1xuICAgICAgICAgICAgZiArPSBcInN3aXRjaChzdHIpe1wiO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgZiArPSBcImNhc2UgXCIgKyBKU09OLnN0cmluZ2lmeShhcnJbaV0pICsgXCI6XCI7XG5cbiAgICAgICAgICAgIGYgKz0gXCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNhdHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgY2F0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmICs9IFwic3dpdGNoKHN0ci5sZW5ndGgpe1wiO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGNhdCA9IGNhdHNbaV07XG4gICAgICAgICAgICAgIGYgKz0gXCJjYXNlIFwiICsgY2F0WzBdLmxlbmd0aCArIFwiOlwiO1xuICAgICAgICAgICAgICBjb21wYXJlVG8oY2F0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZiArPSBcIn1cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGFyZVRvKHdvcmRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwic3RyXCIsIGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzUmVzZXJ2ZWRXb3JkMyA9IG1ha2VQcmVkaWNhdGUoXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIpO1xuICAgICAgICB2YXIgaXNSZXNlcnZlZFdvcmQ1ID0gbWFrZVByZWRpY2F0ZShcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIpO1xuICAgICAgICB2YXIgaXNTdHJpY3RSZXNlcnZlZFdvcmQgPSBtYWtlUHJlZGljYXRlKFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiKTtcbiAgICAgICAgdmFyIGlzU3RyaWN0QmFkSWRXb3JkID0gbWFrZVByZWRpY2F0ZShcImV2YWwgYXJndW1lbnRzXCIpO1xuICAgICAgICB2YXIgaXNLZXl3b3JkID0gbWFrZVByZWRpY2F0ZShcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiKTtcbiAgICAgICAgdmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG4gICAgICAgIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xuICAgICAgICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2MjAtXFx1MDY0OVxcdTA2NzItXFx1MDZkM1xcdTA2ZTctXFx1MDZlOFxcdTA2ZmItXFx1MDZmY1xcdTA3MzAtXFx1MDc0YVxcdTA4MDAtXFx1MDgxNFxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NDAtXFx1MDg1N1xcdTA4ZTQtXFx1MDhmZVxcdTA5MDAtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5ZDdcXHUwOWRmLVxcdTA5ZTBcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWYtXFx1MGI2MFxcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyLVxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgyXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTItXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDJcXHUwZDAzXFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ1N1xcdTBkNjItXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGYyXFx1MGRmM1xcdTBlMzQtXFx1MGUzYVxcdTBlNDAtXFx1MGU0NVxcdTBlNTAtXFx1MGU1OVxcdTBlYjQtXFx1MGViOVxcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY0MS1cXHUwZjQ3XFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTAyOVxcdTEwNDAtXFx1MTA0OVxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTE3MGUtXFx1MTcxMFxcdTE3MjAtXFx1MTczMFxcdTE3NDAtXFx1MTc1MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN2IyXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NTEtXFx1MTk2ZFxcdTE5YjAtXFx1MTljMFxcdTE5YzgtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNVxcdTFhMjAtXFx1MWE1M1xcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFiNDYtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMDAtXFx1MWMyMlxcdTFjNDAtXFx1MWM0OVxcdTFjNWItXFx1MWM3ZFxcdTFjZDAtXFx1MWNkMlxcdTFkMDAtXFx1MWRiZVxcdTFlMDEtXFx1MWYxNVxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJkODEtXFx1MmQ5NlxcdTJkZTAtXFx1MmRmZlxcdTMwMjEtXFx1MzAyOFxcdTMwOTlcXHUzMDlhXFx1YTY0MC1cXHVhNjZkXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZlxcdWE2ZjAtXFx1YTZmMVxcdWE3ZjgtXFx1YTgwMFxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MC1cXHVhODgxXFx1YThiNC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThmMy1cXHVhOGY3XFx1YTkwMC1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTkzMC1cXHVhOTQ1XFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YWEwMC1cXHVhYTI3XFx1YWE0MC1cXHVhYTQxXFx1YWE0Yy1cXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3YlxcdWFhZTAtXFx1YWFlOVxcdWFhZjItXFx1YWFmM1xcdWFiYzAtXFx1YWJlMVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIyMC1cXHVmYjI4XFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG4gICAgICAgIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuICAgICAgICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcbiAgICAgICAgdmFyIG5ld2xpbmUgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XS87XG4gICAgICAgIHZhciBsaW5lQnJlYWsgPSAvXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vZztcblxuICAgICAgICB2YXIgaXNJZGVudGlmaWVyU3RhcnQgPSBleHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gICAgICAgICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgICAgICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGlzSWRlbnRpZmllckNoYXIgPSBleHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgICAgICAgICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgICAgICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxpbmVfbG9jX3QoKSB7XG4gICAgICAgICAgdGhpcy5saW5lID0gdG9rQ3VyTGluZTtcbiAgICAgICAgICB0aGlzLmNvbHVtbiA9IHRva1BvcyAtIHRva0xpbmVTdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRUb2tlblN0YXRlKCkge1xuICAgICAgICAgIHRva0N1ckxpbmUgPSAxO1xuICAgICAgICAgIHRva1BvcyA9IHRva0xpbmVTdGFydCA9IDA7XG4gICAgICAgICAgdG9rUmVnZXhwQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgc2tpcFNwYWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5pc2hUb2tlbih0eXBlLCB2YWwpIHtcbiAgICAgICAgICB0b2tFbmQgPSB0b2tQb3M7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB0b2tFbmRMb2MgPSBuZXcgbGluZV9sb2NfdCgpO1xuICAgICAgICAgIHRva1R5cGUgPSB0eXBlO1xuICAgICAgICAgIHNraXBTcGFjZSgpO1xuICAgICAgICAgIHRva1ZhbCA9IHZhbDtcbiAgICAgICAgICB0b2tSZWdleHBBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2tpcEJsb2NrQ29tbWVudCgpIHtcbiAgICAgICAgICB2YXIgc3RhcnRMb2MgPSBvcHRpb25zLm9uQ29tbWVudCAmJiBvcHRpb25zLmxvY2F0aW9ucyAmJiBuZXcgbGluZV9sb2NfdCgpO1xuICAgICAgICAgIHZhciBzdGFydCA9IHRva1BvcyxcbiAgICAgICAgICAgICAgZW5kID0gaW5wdXQuaW5kZXhPZihcIiovXCIsIHRva1BvcyArPSAyKTtcbiAgICAgICAgICBpZiAoZW5kID09PSAtMSkgcmFpc2UodG9rUG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTtcbiAgICAgICAgICB0b2tQb3MgPSBlbmQgKyAyO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICBsaW5lQnJlYWsubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICB2YXIgbWF0Y2g7XG5cbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdG9rUG9zKSB7XG4gICAgICAgICAgICAgICsrdG9rQ3VyTGluZTtcbiAgICAgICAgICAgICAgdG9rTGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMub25Db21tZW50KSBvcHRpb25zLm9uQ29tbWVudCh0cnVlLCBpbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0b2tQb3MsIHN0YXJ0TG9jLCBvcHRpb25zLmxvY2F0aW9ucyAmJiBuZXcgbGluZV9sb2NfdCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNraXBMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0b2tQb3M7XG4gICAgICAgICAgdmFyIHN0YXJ0TG9jID0gb3B0aW9ucy5vbkNvbW1lbnQgJiYgb3B0aW9ucy5sb2NhdGlvbnMgJiYgbmV3IGxpbmVfbG9jX3QoKTtcbiAgICAgICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArPSAyKTtcblxuICAgICAgICAgIHdoaWxlICh0b2tQb3MgPCBpbnB1dExlbiAmJiBjaCAhPT0gMTAgJiYgY2ggIT09IDEzICYmIGNoICE9PSA4MjMyICYmIGNoICE9PSA4MjMzKSB7XG4gICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLm9uQ29tbWVudCkgb3B0aW9ucy5vbkNvbW1lbnQoZmFsc2UsIGlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgdG9rUG9zKSwgc3RhcnQsIHRva1Bvcywgc3RhcnRMb2MsIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2tpcFNwYWNlKCkge1xuICAgICAgICAgIHdoaWxlICh0b2tQb3MgPCBpbnB1dExlbikge1xuICAgICAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09IDMyKSB7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXG4gICAgICAgICAgICAgIGlmIChuZXh0ID09PSAxMCkge1xuICAgICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgKyt0b2tDdXJMaW5lO1xuICAgICAgICAgICAgICAgIHRva0xpbmVTdGFydCA9IHRva1BvcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMTAgfHwgY2ggPT09IDgyMzIgfHwgY2ggPT09IDgyMzMpIHtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG5cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgKyt0b2tDdXJMaW5lO1xuICAgICAgICAgICAgICAgIHRva0xpbmVTdGFydCA9IHRva1BvcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA+IDggJiYgY2ggPCAxNCkge1xuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDQ3KSB7XG4gICAgICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblxuICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gNDIpIHtcbiAgICAgICAgICAgICAgICBza2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gNDcpIHtcbiAgICAgICAgICAgICAgICBza2lwTGluZUNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMTYwKSB7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUb2tlbl9kb3QoKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHJldHVybiByZWFkTnVtYmVyKHRydWUpO1xuICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfZG90KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUb2tlbl9zbGFzaCgpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cbiAgICAgICAgICBpZiAodG9rUmVnZXhwQWxsb3dlZCkge1xuICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICByZXR1cm4gcmVhZFJlZ2V4cCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hPcChfc2xhc2gsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFRva2VuX211bHRfbW9kdWxvKCkge1xuICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoT3AoX211bHRpcGx5TW9kdWxvLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUb2tlbl9waXBlX2FtcChjb2RlKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSBjb2RlKSByZXR1cm4gZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gX2xvZ2ljYWxPUiA6IF9sb2dpY2FsQU5ELCAyKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gX2JpdHdpc2VPUiA6IF9iaXR3aXNlQU5ELCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUb2tlbl9jYXJldCgpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE9wKF9iaXR3aXNlWE9SLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUb2tlbl9wbHVzX21pbihjb2RlKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXG4gICAgICAgICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgICAgICAgIGlmIChuZXh0ID09IDQ1ICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT0gNjIgJiYgbmV3bGluZS50ZXN0KGlucHV0LnNsaWNlKGxhc3RFbmQsIHRva1BvcykpKSB7XG4gICAgICAgICAgICAgIHRva1BvcyArPSAzO1xuICAgICAgICAgICAgICBza2lwTGluZUNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgc2tpcFNwYWNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW4oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE9wKF9pbmNEZWMsIDIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hPcChfcGx1c01pbiwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVG9rZW5fbHRfZ3QoY29kZSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IDE7XG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgICAgICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT09IDYyID8gMyA6IDI7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyBzaXplKSA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCBzaXplICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoT3AoX2JpdFNoaWZ0LCBzaXplKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV4dCA9PSAzMyAmJiBjb2RlID09IDYwICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT0gNDUgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAzKSA9PSA0NSkge1xuICAgICAgICAgICAgdG9rUG9zICs9IDQ7XG4gICAgICAgICAgICBza2lwTGluZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIHNraXBTcGFjZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0ID09PSA2MSkgc2l6ZSA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT09IDYxID8gMyA6IDI7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE9wKF9yZWxhdGlvbmFsLCBzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2VxdWFsaXR5LCBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09PSA2MSA/IDMgOiAyKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoT3AoY29kZSA9PT0gNjEgPyBfZXEgOiBfcHJlZml4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSA0NjpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbl9kb3QoKTtcblxuICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfcGFyZW5MKTtcblxuICAgICAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfcGFyZW5SKTtcblxuICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfc2VtaSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2NvbW1hKTtcblxuICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2tldEwpO1xuXG4gICAgICAgICAgICBjYXNlIDkzOlxuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFja2V0Uik7XG5cbiAgICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFjZUwpO1xuXG4gICAgICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2VSKTtcblxuICAgICAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfY29sb24pO1xuXG4gICAgICAgICAgICBjYXNlIDYzOlxuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9xdWVzdGlvbik7XG5cbiAgICAgICAgICAgIGNhc2UgNDg6XG4gICAgICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgcmV0dXJuIHJlYWRIZXhOdW1iZXIoKTtcblxuICAgICAgICAgICAgY2FzZSA0OTpcbiAgICAgICAgICAgIGNhc2UgNTA6XG4gICAgICAgICAgICBjYXNlIDUxOlxuICAgICAgICAgICAgY2FzZSA1MjpcbiAgICAgICAgICAgIGNhc2UgNTM6XG4gICAgICAgICAgICBjYXNlIDU0OlxuICAgICAgICAgICAgY2FzZSA1NTpcbiAgICAgICAgICAgIGNhc2UgNTY6XG4gICAgICAgICAgICBjYXNlIDU3OlxuICAgICAgICAgICAgICByZXR1cm4gcmVhZE51bWJlcihmYWxzZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICByZXR1cm4gcmVhZFN0cmluZyhjb2RlKTtcblxuICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbl9zbGFzaChjb2RlKTtcblxuICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5fbXVsdF9tb2R1bG8oKTtcblxuICAgICAgICAgICAgY2FzZSAxMjQ6XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpO1xuXG4gICAgICAgICAgICBjYXNlIDk0OlxuICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuX2NhcmV0KCk7XG5cbiAgICAgICAgICAgIGNhc2UgNDM6XG4gICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuX3BsdXNfbWluKGNvZGUpO1xuXG4gICAgICAgICAgICBjYXNlIDYwOlxuICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbl9sdF9ndChjb2RlKTtcblxuICAgICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5fZXFfZXhjbChjb2RlKTtcblxuICAgICAgICAgICAgY2FzZSAxMjY6XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hPcChfcHJlZml4LCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVG9rZW4oZm9yY2VSZWdleHApIHtcbiAgICAgICAgICBpZiAoIWZvcmNlUmVnZXhwKSB0b2tTdGFydCA9IHRva1BvcztlbHNlIHRva1BvcyA9IHRva1N0YXJ0ICsgMTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHRva1N0YXJ0TG9jID0gbmV3IGxpbmVfbG9jX3QoKTtcbiAgICAgICAgICBpZiAoZm9yY2VSZWdleHApIHJldHVybiByZWFkUmVnZXhwKCk7XG4gICAgICAgICAgaWYgKHRva1BvcyA+PSBpbnB1dExlbikgcmV0dXJuIGZpbmlzaFRva2VuKF9lb2YpO1xuICAgICAgICAgIHZhciBjb2RlID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlKSB8fCBjb2RlID09PSA5MikgcmV0dXJuIHJlYWRXb3JkKCk7XG4gICAgICAgICAgdmFyIHRvayA9IGdldFRva2VuRnJvbUNvZGUoY29kZSk7XG5cbiAgICAgICAgICBpZiAodG9rID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIgfHwgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChjaCkpIHJldHVybiByZWFkV29yZCgpO1xuICAgICAgICAgICAgcmFpc2UodG9rUG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNoICsgXCInXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5pc2hPcCh0eXBlLCBzaXplKSB7XG4gICAgICAgICAgdmFyIHN0ciA9IGlucHV0LnNsaWNlKHRva1BvcywgdG9rUG9zICsgc2l6ZSk7XG4gICAgICAgICAgdG9rUG9zICs9IHNpemU7XG4gICAgICAgICAgZmluaXNoVG9rZW4odHlwZSwgc3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRSZWdleHAoKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiLFxuICAgICAgICAgICAgICBlc2NhcGVkLFxuICAgICAgICAgICAgICBpbkNsYXNzLFxuICAgICAgICAgICAgICBzdGFydCA9IHRva1BvcztcblxuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0b2tQb3MgPj0gaW5wdXRMZW4pIHJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7XG4gICAgICAgICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQXQodG9rUG9zKTtcbiAgICAgICAgICAgIGlmIChuZXdsaW5lLnRlc3QoY2gpKSByYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO1xuXG4gICAgICAgICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSBcIltcIikgaW5DbGFzcyA9IHRydWU7ZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIGluQ2xhc3MgPSBmYWxzZTtlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIGJyZWFrO1xuICAgICAgICAgICAgICBlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuICAgICAgICAgICAgfSBlbHNlIGVzY2FwZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKTtcbiAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICB2YXIgbW9kcyA9IHJlYWRXb3JkMSgpO1xuICAgICAgICAgIGlmIChtb2RzICYmICEvXltnbXNpeV0qJC8udGVzdChtb2RzKSkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCByZWdleHAgZmxhZ1wiKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXcgUmVnRXhwKGNvbnRlbnQsIG1vZHMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHJhaXNlKHN0YXJ0LCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmFpc2UoZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9yZWdleHAsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRJbnQocmFkaXgsIGxlbikge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRva1BvcyxcbiAgICAgICAgICAgICAgdG90YWwgPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSxcbiAgICAgICAgICAgICAgICB2YWw7XG4gICAgICAgICAgICBpZiAoY29kZSA+PSA5NykgdmFsID0gY29kZSAtIDk3ICsgMTA7ZWxzZSBpZiAoY29kZSA+PSA2NSkgdmFsID0gY29kZSAtIDY1ICsgMTA7ZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB2YWwgPSBjb2RlIC0gNDg7ZWxzZSB2YWwgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGlmICh2YWwgPj0gcmFkaXgpIGJyZWFrO1xuICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRva1BvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdG9rUG9zIC0gc3RhcnQgIT09IGxlbikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZEhleE51bWJlcigpIHtcbiAgICAgICAgICB0b2tQb3MgKz0gMjtcbiAgICAgICAgICB2YXIgdmFsID0gcmVhZEludCgxNik7XG4gICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSByYWlzZSh0b2tTdGFydCArIDIsIFwiRXhwZWN0ZWQgaGV4YWRlY2ltYWwgbnVtYmVyXCIpO1xuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykpKSByYWlzZSh0b2tQb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9udW0sIHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkTnVtYmVyKHN0YXJ0c1dpdGhEb3QpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0b2tQb3MsXG4gICAgICAgICAgICAgIGlzRmxvYXQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgb2N0YWwgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDQ4O1xuICAgICAgICAgIGlmICghc3RhcnRzV2l0aERvdCAmJiByZWFkSW50KDEwKSA9PT0gbnVsbCkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG5cbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSA0Nikge1xuICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICByZWFkSW50KDEwKTtcbiAgICAgICAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXG4gICAgICAgICAgaWYgKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkge1xuICAgICAgICAgICAgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQoKyt0b2tQb3MpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSArK3Rva1BvcztcbiAgICAgICAgICAgIGlmIChyZWFkSW50KDEwKSA9PT0gbnVsbCkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG4gICAgICAgICAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpKSkgcmFpc2UodG9rUG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpO1xuICAgICAgICAgIHZhciBzdHIgPSBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKSxcbiAgICAgICAgICAgICAgdmFsO1xuICAgICAgICAgIGlmIChpc0Zsb2F0KSB2YWwgPSBwYXJzZUZsb2F0KHN0cik7ZWxzZSBpZiAoIW9jdGFsIHx8IHN0ci5sZW5ndGggPT09IDEpIHZhbCA9IHBhcnNlSW50KHN0ciwgMTApO2Vsc2UgaWYgKC9bODldLy50ZXN0KHN0cikgfHwgc3RyaWN0KSByYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtlbHNlIHZhbCA9IHBhcnNlSW50KHN0ciwgOCk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9udW0sIHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkU3RyaW5nKHF1b3RlKSB7XG4gICAgICAgICAgdG9rUG9zKys7XG4gICAgICAgICAgdmFyIG91dCA9IFwiXCI7XG5cbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodG9rUG9zID49IGlucHV0TGVuKSByYWlzZSh0b2tTdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX3N0cmluZywgb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAgICAgICBjaCA9IGlucHV0LmNoYXJDb2RlQXQoKyt0b2tQb3MpO1xuICAgICAgICAgICAgICB2YXIgb2N0YWwgPSAvXlswLTddKy8uZXhlYyhpbnB1dC5zbGljZSh0b2tQb3MsIHRva1BvcyArIDMpKTtcbiAgICAgICAgICAgICAgaWYgKG9jdGFsKSBvY3RhbCA9IG9jdGFsWzBdO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChvY3RhbCAmJiBwYXJzZUludChvY3RhbCwgOCkgPiAyNTUpIG9jdGFsID0gb2N0YWwuc2xpY2UoMCwgLTEpO1xuXG4gICAgICAgICAgICAgIGlmIChvY3RhbCA9PT0gXCIwXCIpIG9jdGFsID0gbnVsbDtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG5cbiAgICAgICAgICAgICAgaWYgKG9jdGFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCkgcmFpc2UodG9rUG9zIC0gMiwgXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG9jdGFsLCA4KSk7XG4gICAgICAgICAgICAgICAgdG9rUG9zICs9IG9jdGFsLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAxMTA6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIlxcclwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMjA6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlYWRIZXhDaGFyKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyZWFkSGV4Q2hhcig0KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDg1OlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyZWFkSGV4Q2hhcig4KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDExNjpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiXFx0XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCJcXGJcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE4OlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCJcXHUwMDBiXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiXFxmXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDQ4OlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCJcXDBcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDEwKSArK3Rva1BvcztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rTGluZVN0YXJ0ID0gdG9rUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICsrdG9rQ3VyTGluZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAxMyB8fCBjaCA9PT0gMTAgfHwgY2ggPT09IDgyMzIgfHwgY2ggPT09IDgyMzMpIHJhaXNlKHRva1N0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7XG4gICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZEhleENoYXIobGVuKSB7XG4gICAgICAgICAgdmFyIG4gPSByZWFkSW50KDE2LCBsZW4pO1xuICAgICAgICAgIGlmIChuID09PSBudWxsKSByYWlzZSh0b2tTdGFydCwgXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKTtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250YWluc0VzYztcblxuICAgICAgICBmdW5jdGlvbiByZWFkV29yZDEoKSB7XG4gICAgICAgICAgY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgd29yZCxcbiAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlLFxuICAgICAgICAgICAgICBzdGFydCA9IHRva1BvcztcblxuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblxuICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gpKSB7XG4gICAgICAgICAgICAgIGlmIChjb250YWluc0VzYykgd29yZCArPSBpbnB1dC5jaGFyQXQodG9rUG9zKTtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5zRXNjKSB3b3JkID0gaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1Bvcyk7XG4gICAgICAgICAgICAgIGNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoKyt0b2tQb3MpICE9IDExNykgcmFpc2UodG9rUG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICB2YXIgZXNjID0gcmVhZEhleENoYXIoNCk7XG4gICAgICAgICAgICAgIHZhciBlc2NTdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzYyk7XG4gICAgICAgICAgICAgIGlmICghZXNjU3RyKSByYWlzZSh0b2tQb3MgLSAxLCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7XG4gICAgICAgICAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQoZXNjKSA6IGlzSWRlbnRpZmllckNoYXIoZXNjKSkpIHJhaXNlKHRva1BvcyAtIDQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTtcbiAgICAgICAgICAgICAgd29yZCArPSBlc2NTdHI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGFpbnNFc2MgPyB3b3JkIDogaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1Bvcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkV29yZCgpIHtcbiAgICAgICAgICB2YXIgd29yZCA9IHJlYWRXb3JkMSgpO1xuICAgICAgICAgIHZhciB0eXBlID0gX25hbWU7XG4gICAgICAgICAgaWYgKCFjb250YWluc0VzYyAmJiBpc0tleXdvcmQod29yZCkpIHR5cGUgPSBrZXl3b3JkVHlwZXNbd29yZF07XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKHR5cGUsIHdvcmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICBsYXN0U3RhcnQgPSB0b2tTdGFydDtcbiAgICAgICAgICBsYXN0RW5kID0gdG9rRW5kO1xuICAgICAgICAgIGxhc3RFbmRMb2MgPSB0b2tFbmRMb2M7XG4gICAgICAgICAgcmVhZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRTdHJpY3Qoc3RyY3QpIHtcbiAgICAgICAgICBzdHJpY3QgPSBzdHJjdDtcbiAgICAgICAgICB0b2tQb3MgPSB0b2tTdGFydDtcblxuICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgd2hpbGUgKHRva1BvcyA8IHRva0xpbmVTdGFydCkge1xuICAgICAgICAgICAgICB0b2tMaW5lU3RhcnQgPSBpbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCB0b2tMaW5lU3RhcnQgLSAyKSArIDE7XG4gICAgICAgICAgICAgIC0tdG9rQ3VyTGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBza2lwU3BhY2UoKTtcbiAgICAgICAgICByZWFkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5vZGVfdCgpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgICAgICAgIHRoaXMuc3RhcnQgPSB0b2tTdGFydDtcbiAgICAgICAgICB0aGlzLmVuZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBub2RlX2xvY190KCkge1xuICAgICAgICAgIHRoaXMuc3RhcnQgPSB0b2tTdGFydExvYztcbiAgICAgICAgICB0aGlzLmVuZCA9IG51bGw7XG4gICAgICAgICAgaWYgKHNvdXJjZUZpbGUgIT09IG51bGwpIHRoaXMuc291cmNlID0gc291cmNlRmlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0Tm9kZSgpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBub2RlX3QoKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIG5vZGUubG9jID0gbmV3IG5vZGVfbG9jX3QoKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKSBub2RlLnNvdXJjZUZpbGUgPSBvcHRpb25zLmRpcmVjdFNvdXJjZUZpbGU7XG4gICAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKSBub2RlLnJhbmdlID0gW3Rva1N0YXJ0LCAwXTtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0Tm9kZUZyb20ob3RoZXIpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBub2RlX3QoKTtcbiAgICAgICAgICBub2RlLnN0YXJ0ID0gb3RoZXIuc3RhcnQ7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgIG5vZGUubG9jID0gbmV3IG5vZGVfbG9jX3QoKTtcbiAgICAgICAgICAgIG5vZGUubG9jLnN0YXJ0ID0gb3RoZXIubG9jLnN0YXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmdlcykgbm9kZS5yYW5nZSA9IFtvdGhlci5yYW5nZVswXSwgMF07XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5pc2hOb2RlKG5vZGUsIHR5cGUpIHtcbiAgICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIG5vZGUuZW5kID0gbGFzdEVuZDtcbiAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIG5vZGUubG9jLmVuZCA9IGxhc3RFbmRMb2M7XG4gICAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKSBub2RlLnJhbmdlWzFdID0gbGFzdEVuZDtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzVXNlU3RyaWN0KHN0bXQpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIHN0bXQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlYXQodHlwZSkge1xuICAgICAgICAgIGlmICh0b2tUeXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjYW5JbnNlcnRTZW1pY29sb24oKSB7XG4gICAgICAgICAgcmV0dXJuICFvcHRpb25zLnN0cmljdFNlbWljb2xvbnMgJiYgKHRva1R5cGUgPT09IF9lb2YgfHwgdG9rVHlwZSA9PT0gX2JyYWNlUiB8fCBuZXdsaW5lLnRlc3QoaW5wdXQuc2xpY2UobGFzdEVuZCwgdG9rU3RhcnQpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZW1pY29sb24oKSB7XG4gICAgICAgICAgaWYgKCFlYXQoX3NlbWkpICYmICFjYW5JbnNlcnRTZW1pY29sb24oKSkgdW5leHBlY3RlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXhwZWN0KHR5cGUpIHtcbiAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gdHlwZSkgbmV4dCgpO2Vsc2UgdW5leHBlY3RlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdW5leHBlY3RlZCgpIHtcbiAgICAgICAgICByYWlzZSh0b2tTdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMVmFsKGV4cHIpIHtcbiAgICAgICAgICBpZiAoZXhwci50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiBleHByLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSByYWlzZShleHByLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIik7XG4gICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGlzU3RyaWN0QmFkSWRXb3JkKGV4cHIubmFtZSkpIHJhaXNlKGV4cHIuc3RhcnQsIFwiQXNzaWduaW5nIHRvIFwiICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVRvcExldmVsKHByb2dyYW0pIHtcbiAgICAgICAgICBsYXN0U3RhcnQgPSBsYXN0RW5kID0gdG9rUG9zO1xuICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgbGFzdEVuZExvYyA9IG5ldyBsaW5lX2xvY190KCk7XG4gICAgICAgICAgaW5GdW5jdGlvbiA9IHN0cmljdCA9IG51bGw7XG4gICAgICAgICAgbGFiZWxzID0gW107XG4gICAgICAgICAgcmVhZFRva2VuKCk7XG4gICAgICAgICAgdmFyIG5vZGUgPSBwcm9ncmFtIHx8IHN0YXJ0Tm9kZSgpLFxuICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFwcm9ncmFtKSBub2RlLmJvZHkgPSBbXTtcblxuICAgICAgICAgIHdoaWxlICh0b2tUeXBlICE9PSBfZW9mKSB7XG4gICAgICAgICAgICB2YXIgc3RtdCA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICAgICAgICAgIGlmIChmaXJzdCAmJiBpc1VzZVN0cmljdChzdG10KSkgc2V0U3RyaWN0KHRydWUpO1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlByb2dyYW1cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9vcExhYmVsID0ge1xuICAgICAgICAgIGtpbmQ6IFwibG9vcFwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBzd2l0Y2hMYWJlbCA9IHtcbiAgICAgICAgICBraW5kOiBcInN3aXRjaFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoKSB7XG4gICAgICAgICAgaWYgKHRva1R5cGUgPT09IF9zbGFzaCB8fCB0b2tUeXBlID09PSBfYXNzaWduICYmIHRva1ZhbCA9PSBcIi89XCIpIHJlYWRUb2tlbih0cnVlKTtcbiAgICAgICAgICB2YXIgc3RhcnR0eXBlID0gdG9rVHlwZSxcbiAgICAgICAgICAgICAgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXG4gICAgICAgICAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgX2JyZWFrOlxuICAgICAgICAgICAgY2FzZSBfY29udGludWU6XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgdmFyIGlzQnJlYWsgPSBzdGFydHR5cGUgPT09IF9icmVhaztcbiAgICAgICAgICAgICAgaWYgKGVhdChfc2VtaSkgfHwgY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIG5vZGUubGFiZWwgPSBudWxsO2Vsc2UgaWYgKHRva1R5cGUgIT09IF9uYW1lKSB1bmV4cGVjdGVkKCk7ZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sYWJlbCA9IHBhcnNlSWRlbnQoKTtcbiAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYiA9IGxhYmVsc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaSA9PT0gbGFiZWxzLmxlbmd0aCkgcmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIHN0YXJ0dHlwZS5rZXl3b3JkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX2RlYnVnZ2VyOlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBjYXNlIF9kbzpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBsYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgICAgICAgICAgICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICBsYWJlbHMucG9wKCk7XG4gICAgICAgICAgICAgIGV4cGVjdChfd2hpbGUpO1xuICAgICAgICAgICAgICBub2RlLnRlc3QgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBjYXNlIF9mb3I6XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICAgICAgICAgICAgZXhwZWN0KF9wYXJlbkwpO1xuICAgICAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gX3NlbWkpIHJldHVybiBwYXJzZUZvcihub2RlLCBudWxsKTtcblxuICAgICAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gX3Zhcikge1xuICAgICAgICAgICAgICAgIHZhciBpbml0ID0gc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHBhcnNlVmFyKGluaXQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGZpbmlzaE5vZGUoaW5pdCwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChpbml0LmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZWF0KF9pbikpIHJldHVybiBwYXJzZUZvckluKG5vZGUsIGluaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZvcihub2RlLCBpbml0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBpbml0ID0gcGFyc2VFeHByZXNzaW9uKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgICAgICBpZiAoZWF0KF9pbikpIHtcbiAgICAgICAgICAgICAgICBjaGVja0xWYWwoaW5pdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRm9ySW4obm9kZSwgaW5pdCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGb3Iobm9kZSwgaW5pdCk7XG5cbiAgICAgICAgICAgIGNhc2UgX2Z1bmN0aW9uOlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uKG5vZGUsIHRydWUpO1xuXG4gICAgICAgICAgICBjYXNlIF9pZjpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBub2RlLnRlc3QgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICBub2RlLmNvbnNlcXVlbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICBub2RlLmFsdGVybmF0ZSA9IGVhdChfZWxzZSkgPyBwYXJzZVN0YXRlbWVudCgpIDogbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfcmV0dXJuOlxuICAgICAgICAgICAgICBpZiAoIWluRnVuY3Rpb24gJiYgIW9wdGlvbnMuYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24pIHJhaXNlKHRva1N0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgaWYgKGVhdChfc2VtaSkgfHwgY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIG5vZGUuYXJndW1lbnQgPSBudWxsO2Vsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfc3dpdGNoOlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIG5vZGUuZGlzY3JpbWluYW50ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgbm9kZS5jYXNlcyA9IFtdO1xuICAgICAgICAgICAgICBleHBlY3QoX2JyYWNlTCk7XG4gICAgICAgICAgICAgIGxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBjdXIsIHNhd0RlZmF1bHQ7IHRva1R5cGUgIT0gX2JyYWNlUjspIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gX2Nhc2UgfHwgdG9rVHlwZSA9PT0gX2RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc0Nhc2UgPSB0b2tUeXBlID09PSBfY2FzZTtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXIpIGZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgICAgICAgICAgICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gc3RhcnROb2RlKCkpO1xuICAgICAgICAgICAgICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0Nhc2UpIGN1ci50ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYXdEZWZhdWx0KSByYWlzZShsYXN0U3RhcnQsIFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpO1xuICAgICAgICAgICAgICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZXhwZWN0KF9jb2xvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmICghY3VyKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHBhcnNlU3RhdGVtZW50KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjdXIpIGZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbGFiZWxzLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfdGhyb3c6XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgaWYgKG5ld2xpbmUudGVzdChpbnB1dC5zbGljZShsYXN0RW5kLCB0b2tTdGFydCkpKSByYWlzZShsYXN0RW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTtcbiAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfdHJ5OlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIG5vZGUuYmxvY2sgPSBwYXJzZUJsb2NrKCk7XG4gICAgICAgICAgICAgIG5vZGUuaGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgaWYgKHRva1R5cGUgPT09IF9jYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhciBjbGF1c2UgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KF9wYXJlbkwpO1xuICAgICAgICAgICAgICAgIGNsYXVzZS5wYXJhbSA9IHBhcnNlSWRlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0QmFkSWRXb3JkKGNsYXVzZS5wYXJhbS5uYW1lKSkgcmFpc2UoY2xhdXNlLnBhcmFtLnN0YXJ0LCBcIkJpbmRpbmcgXCIgKyBjbGF1c2UucGFyYW0ubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICAgICAgICAgICAgICBjbGF1c2UuZ3VhcmQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNsYXVzZS5ib2R5ID0gcGFyc2VCbG9jaygpO1xuICAgICAgICAgICAgICAgIG5vZGUuaGFuZGxlciA9IGZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbm9kZS5ndWFyZGVkSGFuZGxlcnMgPSBlbXB0eTtcbiAgICAgICAgICAgICAgbm9kZS5maW5hbGl6ZXIgPSBlYXQoX2ZpbmFsbHkpID8gcGFyc2VCbG9jaygpIDogbnVsbDtcbiAgICAgICAgICAgICAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKSByYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBjYXNlIF92YXI6XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgcGFyc2VWYXIobm9kZSk7XG4gICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG5cbiAgICAgICAgICAgIGNhc2UgX3doaWxlOlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIG5vZGUudGVzdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgIGxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgICAgICAgICAgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgIGxhYmVscy5wb3AoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfd2l0aDpcbiAgICAgICAgICAgICAgaWYgKHN0cmljdCkgcmFpc2UodG9rU3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIG5vZGUub2JqZWN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBjYXNlIF9icmFjZUw6XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUJsb2NrKCk7XG5cbiAgICAgICAgICAgIGNhc2UgX3NlbWk6XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdmFyIG1heWJlTmFtZSA9IHRva1ZhbCxcbiAgICAgICAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhcnR0eXBlID09PSBfbmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGVhdChfY29sb24pKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIGlmIChsYWJlbHNbaV0ubmFtZSA9PT0gbWF5YmVOYW1lKSByYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSB0b2tUeXBlLmlzTG9vcCA/IFwibG9vcFwiIDogdG9rVHlwZSA9PT0gX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IG1heWJlTmFtZSxcbiAgICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIGxhYmVscy5wb3AoKTtcbiAgICAgICAgICAgICAgICBub2RlLmxhYmVsID0gZXhwcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlUGFyZW5FeHByZXNzaW9uKCkge1xuICAgICAgICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICAgICAgICB2YXIgdmFsID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZXhwZWN0KF9wYXJlblIpO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUJsb2NrKGFsbG93U3RyaWN0KSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKSxcbiAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlLFxuICAgICAgICAgICAgICBzdHJpY3QgPSBmYWxzZSxcbiAgICAgICAgICAgICAgb2xkU3RyaWN0O1xuICAgICAgICAgIG5vZGUuYm9keSA9IFtdO1xuICAgICAgICAgIGV4cGVjdChfYnJhY2VMKTtcblxuICAgICAgICAgIHdoaWxlICghZWF0KF9icmFjZVIpKSB7XG4gICAgICAgICAgICB2YXIgc3RtdCA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcblxuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIGFsbG93U3RyaWN0ICYmIGlzVXNlU3RyaWN0KHN0bXQpKSB7XG4gICAgICAgICAgICAgIG9sZFN0cmljdCA9IHN0cmljdDtcbiAgICAgICAgICAgICAgc2V0U3RyaWN0KHN0cmljdCA9IHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdHJpY3QgJiYgIW9sZFN0cmljdCkgc2V0U3RyaWN0KGZhbHNlKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VGb3Iobm9kZSwgaW5pdCkge1xuICAgICAgICAgIG5vZGUuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgZXhwZWN0KF9zZW1pKTtcbiAgICAgICAgICBub2RlLnRlc3QgPSB0b2tUeXBlID09PSBfc2VtaSA/IG51bGwgOiBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICBleHBlY3QoX3NlbWkpO1xuICAgICAgICAgIG5vZGUudXBkYXRlID0gdG9rVHlwZSA9PT0gX3BhcmVuUiA/IG51bGwgOiBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICBleHBlY3QoX3BhcmVuUik7XG4gICAgICAgICAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICBsYWJlbHMucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUZvckluKG5vZGUsIGluaXQpIHtcbiAgICAgICAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgICAgICAgIG5vZGUucmlnaHQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICBleHBlY3QoX3BhcmVuUik7XG4gICAgICAgICAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICBsYWJlbHMucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJGb3JJblN0YXRlbWVudFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlVmFyKG5vZGUsIG5vSW4pIHtcbiAgICAgICAgICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICAgICAgICAgIG5vZGUua2luZCA9IFwidmFyXCI7XG5cbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB2YXIgZGVjbCA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgZGVjbC5pZCA9IHBhcnNlSWRlbnQoKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RCYWRJZFdvcmQoZGVjbC5pZC5uYW1lKSkgcmFpc2UoZGVjbC5pZC5zdGFydCwgXCJCaW5kaW5nIFwiICsgZGVjbC5pZC5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICBkZWNsLmluaXQgPSBlYXQoX2VxKSA/IHBhcnNlRXhwcmVzc2lvbih0cnVlLCBub0luKSA6IG51bGw7XG4gICAgICAgICAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKGZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgICAgICAgICAgaWYgKCFlYXQoX2NvbW1hKSkgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24obm9Db21tYSwgbm9Jbikge1xuICAgICAgICAgIHZhciBleHByID0gcGFyc2VNYXliZUFzc2lnbihub0luKTtcblxuICAgICAgICAgIGlmICghbm9Db21tYSAmJiB0b2tUeXBlID09PSBfY29tbWEpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShleHByKTtcbiAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG5cbiAgICAgICAgICAgIHdoaWxlIChlYXQoX2NvbW1hKSkgbm9kZS5leHByZXNzaW9ucy5wdXNoKHBhcnNlTWF5YmVBc3NpZ24obm9JbikpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTWF5YmVBc3NpZ24obm9Jbikge1xuICAgICAgICAgIHZhciBsZWZ0ID0gcGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4pO1xuXG4gICAgICAgICAgaWYgKHRva1R5cGUuaXNBc3NpZ24pIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShsZWZ0KTtcbiAgICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG4gICAgICAgICAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgbm9kZS5yaWdodCA9IHBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgICAgICAgICBjaGVja0xWYWwobGVmdCk7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4pIHtcbiAgICAgICAgICB2YXIgZXhwciA9IHBhcnNlRXhwck9wcyhub0luKTtcblxuICAgICAgICAgIGlmIChlYXQoX3F1ZXN0aW9uKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGV4cHIpO1xuICAgICAgICAgICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICAgICAgICAgIG5vZGUuY29uc2VxdWVudCA9IHBhcnNlRXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChfY29sb24pO1xuICAgICAgICAgICAgbm9kZS5hbHRlcm5hdGUgPSBwYXJzZUV4cHJlc3Npb24odHJ1ZSwgbm9Jbik7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRXhwck9wcyhub0luKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRXhwck9wKHBhcnNlTWF5YmVVbmFyeSgpLCAtMSwgbm9Jbik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUV4cHJPcChsZWZ0LCBtaW5QcmVjLCBub0luKSB7XG4gICAgICAgICAgdmFyIHByZWMgPSB0b2tUeXBlLmJpbm9wO1xuXG4gICAgICAgICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdG9rVHlwZSAhPT0gX2luKSkge1xuICAgICAgICAgICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShsZWZ0KTtcbiAgICAgICAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcbiAgICAgICAgICAgICAgdmFyIG9wID0gdG9rVHlwZTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gcGFyc2VFeHByT3AocGFyc2VNYXliZVVuYXJ5KCksIHByZWMsIG5vSW4pO1xuICAgICAgICAgICAgICB2YXIgZXhwck5vZGUgPSBmaW5pc2hOb2RlKG5vZGUsIG9wID09PSBfbG9naWNhbE9SIHx8IG9wID09PSBfbG9naWNhbEFORCA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwck9wKGV4cHJOb2RlLCBtaW5QcmVjLCBub0luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTWF5YmVVbmFyeSgpIHtcbiAgICAgICAgICBpZiAodG9rVHlwZS5wcmVmaXgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCksXG4gICAgICAgICAgICAgICAgdXBkYXRlID0gdG9rVHlwZS5pc1VwZGF0ZTtcbiAgICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG4gICAgICAgICAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgICAgICAgICB0b2tSZWdleHBBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIG5vZGUuYXJndW1lbnQgPSBwYXJzZU1heWJlVW5hcnkoKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUpIGNoZWNrTFZhbChub2RlLmFyZ3VtZW50KTtlbHNlIGlmIChzdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJiBub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSByYWlzZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZXhwciA9IHBhcnNlRXhwclN1YnNjcmlwdHMoKTtcblxuICAgICAgICAgIHdoaWxlICh0b2tUeXBlLnBvc3RmaXggJiYgIWNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oZXhwcik7XG4gICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gdG9rVmFsO1xuICAgICAgICAgICAgbm9kZS5wcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICAgIG5vZGUuYXJndW1lbnQgPSBleHByO1xuICAgICAgICAgICAgY2hlY2tMVmFsKGV4cHIpO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgZXhwciA9IGZpbmlzaE5vZGUobm9kZSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VFeHByU3Vic2NyaXB0cygpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKHBhcnNlRXhwckF0b20oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVN1YnNjcmlwdHMoYmFzZSwgbm9DYWxscykge1xuICAgICAgICAgIGlmIChlYXQoX2RvdCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShiYXNlKTtcbiAgICAgICAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgICAgICAgIG5vZGUucHJvcGVydHkgPSBwYXJzZUlkZW50KHRydWUpO1xuICAgICAgICAgICAgbm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhmaW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKSwgbm9DYWxscyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlYXQoX2JyYWNrZXRMKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGJhc2UpO1xuICAgICAgICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgbm9kZS5jb21wdXRlZCA9IHRydWU7XG4gICAgICAgICAgICBleHBlY3QoX2JyYWNrZXRSKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVN1YnNjcmlwdHMoZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIiksIG5vQ2FsbHMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgZWF0KF9wYXJlbkwpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oYmFzZSk7XG4gICAgICAgICAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHBhcnNlRXhwckxpc3QoX3BhcmVuUiwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhmaW5pc2hOb2RlKG5vZGUsIFwiQ2FsbEV4cHJlc3Npb25cIiksIG5vQ2FsbHMpO1xuICAgICAgICAgIH0gZWxzZSByZXR1cm4gYmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRXhwckF0b20oKSB7XG4gICAgICAgICAgc3dpdGNoICh0b2tUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIF90aGlzOlxuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIik7XG5cbiAgICAgICAgICAgIGNhc2UgX25hbWU6XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUlkZW50KCk7XG5cbiAgICAgICAgICAgIGNhc2UgX251bTpcbiAgICAgICAgICAgIGNhc2UgX3N0cmluZzpcbiAgICAgICAgICAgIGNhc2UgX3JlZ2V4cDpcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHRva1ZhbDtcbiAgICAgICAgICAgICAgbm9kZS5yYXcgPSBpbnB1dC5zbGljZSh0b2tTdGFydCwgdG9rRW5kKTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX251bGw6XG4gICAgICAgICAgICBjYXNlIF90cnVlOlxuICAgICAgICAgICAgY2FzZSBfZmFsc2U6XG4gICAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIG5vZGUudmFsdWUgPSB0b2tUeXBlLmF0b21WYWx1ZTtcbiAgICAgICAgICAgICAgbm9kZS5yYXcgPSB0b2tUeXBlLmtleXdvcmQ7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpO1xuXG4gICAgICAgICAgICBjYXNlIF9wYXJlbkw6XG4gICAgICAgICAgICAgIHZhciB0b2tTdGFydExvYzEgPSB0b2tTdGFydExvYyxcbiAgICAgICAgICAgICAgICAgIHRva1N0YXJ0MSA9IHRva1N0YXJ0O1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgdmFsLnN0YXJ0ID0gdG9rU3RhcnQxO1xuICAgICAgICAgICAgICB2YWwuZW5kID0gdG9rRW5kO1xuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhbC5sb2Muc3RhcnQgPSB0b2tTdGFydExvYzE7XG4gICAgICAgICAgICAgICAgdmFsLmxvYy5lbmQgPSB0b2tFbmRMb2M7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yYW5nZXMpIHZhbC5yYW5nZSA9IFt0b2tTdGFydDEsIHRva0VuZF07XG4gICAgICAgICAgICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcblxuICAgICAgICAgICAgY2FzZSBfYnJhY2tldEw6XG4gICAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbm9kZS5lbGVtZW50cyA9IHBhcnNlRXhwckxpc3QoX2JyYWNrZXRSLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIik7XG5cbiAgICAgICAgICAgIGNhc2UgX2JyYWNlTDpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlT2JqKCk7XG5cbiAgICAgICAgICAgIGNhc2UgX2Z1bmN0aW9uOlxuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uKG5vZGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgY2FzZSBfbmV3OlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VOZXcoKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTmV3KCkge1xuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIG5vZGUuY2FsbGVlID0gcGFyc2VTdWJzY3JpcHRzKHBhcnNlRXhwckF0b20oKSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKGVhdChfcGFyZW5MKSkgbm9kZS5hcmd1bWVudHMgPSBwYXJzZUV4cHJMaXN0KF9wYXJlblIsIGZhbHNlKTtlbHNlIG5vZGUuYXJndW1lbnRzID0gZW1wdHk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VPYmooKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKSxcbiAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlLFxuICAgICAgICAgICAgICBzYXdHZXRTZXQgPSBmYWxzZTtcbiAgICAgICAgICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgICB3aGlsZSAoIWVhdChfYnJhY2VSKSkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICBleHBlY3QoX2NvbW1hKTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hcyAmJiBlYXQoX2JyYWNlUikpIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBwcm9wID0ge1xuICAgICAgICAgICAgICBrZXk6IHBhcnNlUHJvcGVydHlOYW1lKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNHZXRTZXQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBraW5kO1xuXG4gICAgICAgICAgICBpZiAoZWF0KF9jb2xvbikpIHtcbiAgICAgICAgICAgICAgcHJvcC52YWx1ZSA9IHBhcnNlRXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgICAgICAga2luZCA9IHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikpIHtcbiAgICAgICAgICAgICAgaXNHZXRTZXQgPSBzYXdHZXRTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICBraW5kID0gcHJvcC5raW5kID0gcHJvcC5rZXkubmFtZTtcbiAgICAgICAgICAgICAgcHJvcC5rZXkgPSBwYXJzZVByb3BlcnR5TmFtZSgpO1xuICAgICAgICAgICAgICBpZiAodG9rVHlwZSAhPT0gX3BhcmVuTCkgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICBwcm9wLnZhbHVlID0gcGFyc2VGdW5jdGlvbihzdGFydE5vZGUoKSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHVuZXhwZWN0ZWQoKTtcblxuICAgICAgICAgICAgaWYgKHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChzdHJpY3QgfHwgc2F3R2V0U2V0KSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucHJvcGVydGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IG5vZGUucHJvcGVydGllc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChvdGhlci5rZXkubmFtZSA9PT0gcHJvcC5rZXkubmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbmZsaWN0ID0ga2luZCA9PSBvdGhlci5raW5kIHx8IGlzR2V0U2V0ICYmIG90aGVyLmtpbmQgPT09IFwiaW5pdFwiIHx8IGtpbmQgPT09IFwiaW5pdFwiICYmIChvdGhlci5raW5kID09PSBcImdldFwiIHx8IG90aGVyLmtpbmQgPT09IFwic2V0XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0ICYmICFzdHJpY3QgJiYga2luZCA9PT0gXCJpbml0XCIgJiYgb3RoZXIua2luZCA9PT0gXCJpbml0XCIpIGNvbmZsaWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBpZiAoY29uZmxpY3QpIHJhaXNlKHByb3Aua2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RFeHByZXNzaW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eU5hbWUoKSB7XG4gICAgICAgICAgaWYgKHRva1R5cGUgPT09IF9udW0gfHwgdG9rVHlwZSA9PT0gX3N0cmluZykgcmV0dXJuIHBhcnNlRXhwckF0b20oKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VJZGVudCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gX25hbWUpIG5vZGUuaWQgPSBwYXJzZUlkZW50KCk7ZWxzZSBpZiAoaXNTdGF0ZW1lbnQpIHVuZXhwZWN0ZWQoKTtlbHNlIG5vZGUuaWQgPSBudWxsO1xuICAgICAgICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICBleHBlY3QoX3BhcmVuTCk7XG5cbiAgICAgICAgICB3aGlsZSAoIWVhdChfcGFyZW5SKSkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdCkgZXhwZWN0KF9jb21tYSk7ZWxzZSBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZS5wYXJhbXMucHVzaChwYXJzZUlkZW50KCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvbGRJbkZ1bmMgPSBpbkZ1bmN0aW9uLFxuICAgICAgICAgICAgICBvbGRMYWJlbHMgPSBsYWJlbHM7XG4gICAgICAgICAgaW5GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgICAgbGFiZWxzID0gW107XG4gICAgICAgICAgbm9kZS5ib2R5ID0gcGFyc2VCbG9jayh0cnVlKTtcbiAgICAgICAgICBpbkZ1bmN0aW9uID0gb2xkSW5GdW5jO1xuICAgICAgICAgIGxhYmVscyA9IG9sZExhYmVscztcblxuICAgICAgICAgIGlmIChzdHJpY3QgfHwgbm9kZS5ib2R5LmJvZHkubGVuZ3RoICYmIGlzVXNlU3RyaWN0KG5vZGUuYm9keS5ib2R5WzBdKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG5vZGUuaWQgPyAtMSA6IDA7IGkgPCBub2RlLnBhcmFtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgaWQgPSBpIDwgMCA/IG5vZGUuaWQgOiBub2RlLnBhcmFtc1tpXTtcbiAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKGlkLm5hbWUpIHx8IGlzU3RyaWN0QmFkSWRXb3JkKGlkLm5hbWUpKSByYWlzZShpZC5zdGFydCwgXCJEZWZpbmluZyAnXCIgKyBpZC5uYW1lICsgXCInIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgICBpZiAoaSA+PSAwKSBmb3IgKHZhciBqID0gMDsgaiA8IGk7ICsraikgaWYgKGlkLm5hbWUgPT09IG5vZGUucGFyYW1zW2pdLm5hbWUpIHJhaXNlKGlkLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2ggaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VFeHByTGlzdChjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5KSB7XG4gICAgICAgICAgdmFyIGVsdHMgPSBbXSxcbiAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuXG4gICAgICAgICAgd2hpbGUgKCFlYXQoY2xvc2UpKSB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgIGV4cGVjdChfY29tbWEpO1xuICAgICAgICAgICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hcyAmJiBlYXQoY2xvc2UpKSBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0b2tUeXBlID09PSBfY29tbWEpIGVsdHMucHVzaChudWxsKTtlbHNlIGVsdHMucHVzaChwYXJzZUV4cHJlc3Npb24odHJ1ZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlbHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VJZGVudChsaWJlcmFsKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgICBpZiAobGliZXJhbCAmJiBvcHRpb25zLmZvcmJpZFJlc2VydmVkID09IFwiZXZlcnl3aGVyZVwiKSBsaWJlcmFsID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gX25hbWUpIHtcbiAgICAgICAgICAgIGlmICghbGliZXJhbCAmJiAob3B0aW9ucy5mb3JiaWRSZXNlcnZlZCAmJiAob3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gMyA/IGlzUmVzZXJ2ZWRXb3JkMyA6IGlzUmVzZXJ2ZWRXb3JkNSkodG9rVmFsKSB8fCBzdHJpY3QgJiYgaXNTdHJpY3RSZXNlcnZlZFdvcmQodG9rVmFsKSkgJiYgaW5wdXQuc2xpY2UodG9rU3RhcnQsIHRva0VuZCkuaW5kZXhPZihcIlxcXFxcIikgPT0gLTEpIHJhaXNlKHRva1N0YXJ0LCBcIlRoZSBrZXl3b3JkICdcIiArIHRva1ZhbCArIFwiJyBpcyByZXNlcnZlZFwiKTtcbiAgICAgICAgICAgIG5vZGUubmFtZSA9IHRva1ZhbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpYmVyYWwgJiYgdG9rVHlwZS5rZXl3b3JkKSB7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSB0b2tUeXBlLmtleXdvcmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tSZWdleHBBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghYWNvcm4udmVyc2lvbikgYWNvcm4gPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAoZ2xvYmFsLmFjb3JuIHx8IGFjb3JuKS5wYXJzZShjb2RlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgYmluYXJ5T3BlcmF0b3JzID0ge1xuICAgICAgJysnOiAnX19hZGQnLFxuICAgICAgJy0nOiAnX19zdWJ0cmFjdCcsXG4gICAgICAnKic6ICdfX211bHRpcGx5JyxcbiAgICAgICcvJzogJ19fZGl2aWRlJyxcbiAgICAgICclJzogJ19fbW9kdWxvJyxcbiAgICAgICc9PSc6ICdfX2VxdWFscycsXG4gICAgICAnIT0nOiAnX19lcXVhbHMnXG4gICAgfTtcbiAgICB2YXIgdW5hcnlPcGVyYXRvcnMgPSB7XG4gICAgICAnLSc6ICdfX25lZ2F0ZScsXG4gICAgICAnKyc6ICdfX3NlbGYnXG4gICAgfTtcbiAgICB2YXIgZmllbGRzID0gQmFzZS5lYWNoKFsnYWRkJywgJ3N1YnRyYWN0JywgJ211bHRpcGx5JywgJ2RpdmlkZScsICdtb2R1bG8nLCAnZXF1YWxzJywgJ25lZ2F0ZSddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdGhpc1snX18nICsgbmFtZV0gPSAnIycgKyBuYW1lO1xuICAgIH0sIHtcbiAgICAgIF9fc2VsZjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBQb2ludC5pbmplY3QoZmllbGRzKTtcbiAgICBTaXplLmluamVjdChmaWVsZHMpO1xuICAgIENvbG9yLmluamVjdChmaWVsZHMpO1xuXG4gICAgZnVuY3Rpb24gX18kX18obGVmdCwgb3BlcmF0b3IsIHJpZ2h0KSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGJpbmFyeU9wZXJhdG9yc1tvcGVyYXRvcl07XG5cbiAgICAgIGlmIChsZWZ0ICYmIGxlZnRbaGFuZGxlcl0pIHtcbiAgICAgICAgdmFyIHJlcyA9IGxlZnRbaGFuZGxlcl0ocmlnaHQpO1xuICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09ICchPScgPyAhcmVzIDogcmVzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG5cbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcblxuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICByZXR1cm4gbGVmdCAqIHJpZ2h0O1xuXG4gICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgIHJldHVybiBsZWZ0IC8gcmlnaHQ7XG5cbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgcmV0dXJuIGxlZnQgJSByaWdodDtcblxuICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgcmV0dXJuIGxlZnQgPT0gcmlnaHQ7XG5cbiAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgIHJldHVybiBsZWZ0ICE9IHJpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICRfXyhvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gdW5hcnlPcGVyYXRvcnNbb3BlcmF0b3JdO1xuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlW2hhbmRsZXJdKSByZXR1cm4gdmFsdWVbaGFuZGxlcl0oKTtcblxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICByZXR1cm4gK3ZhbHVlO1xuXG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiAtdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGlsZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWNvZGUpIHJldHVybiAnJztcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIGluc2VydGlvbnMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gZ2V0T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluc2VydGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGluc2VydGlvbiA9IGluc2VydGlvbnNbaV07XG4gICAgICAgICAgaWYgKGluc2VydGlvblswXSA+PSBvZmZzZXQpIGJyZWFrO1xuICAgICAgICAgIG9mZnNldCArPSBpbnNlcnRpb25bMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRDb2RlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvZGUuc3Vic3RyaW5nKGdldE9mZnNldChub2RlLnJhbmdlWzBdKSwgZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMV0pKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0QmV0d2VlbihsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gY29kZS5zdWJzdHJpbmcoZ2V0T2Zmc2V0KGxlZnQucmFuZ2VbMV0pLCBnZXRPZmZzZXQocmlnaHQucmFuZ2VbMF0pKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVwbGFjZUNvZGUobm9kZSwgc3RyKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGdldE9mZnNldChub2RlLnJhbmdlWzBdKSxcbiAgICAgICAgICAgIGVuZCA9IGdldE9mZnNldChub2RlLnJhbmdlWzFdKSxcbiAgICAgICAgICAgIGluc2VydCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGluc2VydGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoc3RhcnQgPiBpbnNlcnRpb25zW2ldWzBdKSB7XG4gICAgICAgICAgICBpbnNlcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGluc2VydGlvbnMuc3BsaWNlKGluc2VydCwgMCwgW3N0YXJ0LCBzdHIubGVuZ3RoIC0gZW5kICsgc3RhcnRdKTtcbiAgICAgICAgY29kZSA9IGNvZGUuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHN0ciArIGNvZGUuc3Vic3RyaW5nKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU92ZXJsb2FkaW5nKG5vZGUsIHBhcmVudCkge1xuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBpZiAobm9kZS5vcGVyYXRvciBpbiB1bmFyeU9wZXJhdG9ycyAmJiBub2RlLmFyZ3VtZW50LnR5cGUgIT09ICdMaXRlcmFsJykge1xuICAgICAgICAgICAgICB2YXIgYXJnID0gZ2V0Q29kZShub2RlLmFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgcmVwbGFjZUNvZGUobm9kZSwgJyRfXyhcIicgKyBub2RlLm9wZXJhdG9yICsgJ1wiLCAnICsgYXJnICsgJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGlmIChub2RlLm9wZXJhdG9yIGluIGJpbmFyeU9wZXJhdG9ycyAmJiBub2RlLmxlZnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgIHZhciBsZWZ0ID0gZ2V0Q29kZShub2RlLmxlZnQpLFxuICAgICAgICAgICAgICAgICAgcmlnaHQgPSBnZXRDb2RlKG5vZGUucmlnaHQpLFxuICAgICAgICAgICAgICAgICAgYmV0d2VlbiA9IGdldEJldHdlZW4obm9kZS5sZWZ0LCBub2RlLnJpZ2h0KSxcbiAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgICAgICAgcmVwbGFjZUNvZGUobm9kZSwgJ19fJF9fKCcgKyBsZWZ0ICsgJywnICsgYmV0d2Vlbi5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwnICsgb3BlcmF0b3IpLCAnXCInICsgb3BlcmF0b3IgKyAnXCInKSArICcsICcgKyByaWdodCArICcpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSBwYXJlbnQgJiYgcGFyZW50LnR5cGU7XG5cbiAgICAgICAgICAgIGlmICghKHBhcmVudFR5cGUgPT09ICdGb3JTdGF0ZW1lbnQnIHx8IHBhcmVudFR5cGUgPT09ICdCaW5hcnlFeHByZXNzaW9uJyAmJiAvXls9ITw+XS8udGVzdChwYXJlbnQub3BlcmF0b3IpIHx8IHBhcmVudFR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJiBwYXJlbnQuY29tcHV0ZWQpKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdVcGRhdGVFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBleHAgPSAnX18kX18oJyArIGFyZyArICcsIFwiJyArIG5vZGUub3BlcmF0b3JbMF0gKyAnXCIsIDEpJyxcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gYXJnICsgJyA9ICcgKyBleHA7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICcoJyArIHN0ciArICcpJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudFR5cGUgPT09ICdBc3NpZ25tZW50RXhwcmVzc2lvbicgfHwgcGFyZW50VHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRvcicgfHwgcGFyZW50VHlwZSA9PT0gJ0JpbmFyeUV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZ2V0Q29kZShwYXJlbnQubGVmdCB8fCBwYXJlbnQuaWQpID09PSBhcmcpIHN0ciA9IGV4cDtcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZyArICc7ICcgKyBzdHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvZGUobm9kZSwgc3RyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoL14uPSQvLnRlc3Qobm9kZS5vcGVyYXRvcikgJiYgbm9kZS5sZWZ0LnR5cGUgIT09ICdMaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG4gICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBnZXRDb2RlKG5vZGUucmlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAgIGV4cCA9IGxlZnQgKyAnID0gX18kX18oJyArIGxlZnQgKyAnLCBcIicgKyBub2RlLm9wZXJhdG9yWzBdICsgJ1wiLCAnICsgcmlnaHQgKyAnKSc7XG4gICAgICAgICAgICAgICAgICByZXBsYWNlQ29kZShub2RlLCAvXlxcKC4qXFwpJC8udGVzdChnZXRDb2RlKG5vZGUpKSA/ICcoJyArIGV4cCArICcpJyA6IGV4cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUV4cG9ydHMobm9kZSkge1xuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbic6XG4gICAgICAgICAgICByZXBsYWNlQ29kZSh7XG4gICAgICAgICAgICAgIHJhbmdlOiBbbm9kZS5zdGFydCwgbm9kZS5kZWNsYXJhdGlvbi5zdGFydF1cbiAgICAgICAgICAgIH0sICdtb2R1bGUuZXhwb3J0cyA9ICcpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJzpcbiAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IG5vZGUuZGVjbGFyYXRpb247XG4gICAgICAgICAgICB2YXIgc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycztcblxuICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnM7XG5cbiAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWMpIHtcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb2RlKGRlYywgJ21vZHVsZS5leHBvcnRzLicgKyBnZXRDb2RlKGRlYykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VDb2RlKHtcbiAgICAgICAgICAgICAgICAgIHJhbmdlOiBbbm9kZS5zdGFydCwgZGVjbGFyYXRpb24uc3RhcnQgKyBkZWNsYXJhdGlvbi5raW5kLmxlbmd0aF1cbiAgICAgICAgICAgICAgICB9LCAnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lmaWVycykge1xuICAgICAgICAgICAgICB2YXIgZXhwb3J0cyA9IHNwZWNpZmllcnMubWFwKGZ1bmN0aW9uIChzcGVjaWZpZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGdldENvZGUoc3BlY2lmaWVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vZHVsZS5leHBvcnRzLicgKyBuYW1lICsgJyA9ICcgKyBuYW1lICsgJzsgJztcbiAgICAgICAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgICAgICAgaWYgKGV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29kZShub2RlLCBleHBvcnRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3YWxrQVNUKG5vZGUsIHBhcmVudCwgcGFwZXJGZWF0dXJlcykge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBub2RlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAncmFuZ2UnICYmIGtleSAhPT0gJ2xvYycpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZVtrZXldO1xuXG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB3YWxrQVNUKHZhbHVlW2ldLCBub2RlLCBwYXBlckZlYXR1cmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHdhbGtBU1QodmFsdWUsIG5vZGUsIHBhcGVyRmVhdHVyZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcGVyRmVhdHVyZXMub3BlcmF0b3JPdmVybG9hZGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhhbmRsZU92ZXJsb2FkaW5nKG5vZGUsIHBhcmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcGVyRmVhdHVyZXMubW9kdWxlRXhwb3J0cyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhhbmRsZUV4cG9ydHMobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVuY29kZVZMUSh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzID0gJycsXG4gICAgICAgICAgICBiYXNlNjQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgICAgIHZhbHVlID0gKE1hdGguYWJzKHZhbHVlKSA8PCAxKSArICh2YWx1ZSA8IDAgPyAxIDogMCk7XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlIHx8ICFyZXMpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IHZhbHVlICYgMzIgLSAxO1xuICAgICAgICAgIHZhbHVlID4+PSA1O1xuICAgICAgICAgIGlmICh2YWx1ZSkgbmV4dCB8PSAzMjtcbiAgICAgICAgICByZXMgKz0gYmFzZTY0W25leHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgdmFyIHVybCA9IG9wdGlvbnMudXJsIHx8ICcnLFxuICAgICAgICAgIHNvdXJjZU1hcHMgPSBvcHRpb25zLnNvdXJjZU1hcHMsXG4gICAgICAgICAgcGFwZXJGZWF0dXJlcyA9IG9wdGlvbnMucGFwZXJGZWF0dXJlcyB8fCB7fSxcbiAgICAgICAgICBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZSB8fCBjb2RlLFxuICAgICAgICAgIG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDAsXG4gICAgICAgICAgYWdlbnQgPSBwYXBlci5hZ2VudCxcbiAgICAgICAgICB2ZXJzaW9uID0gYWdlbnQudmVyc2lvbk51bWJlcixcbiAgICAgICAgICBvZmZzZXRDb2RlID0gZmFsc2UsXG4gICAgICAgICAgbGluZUJyZWFrcyA9IC9cXHJcXG58XFxufFxcci9tZyxcbiAgICAgICAgICBtYXA7XG5cbiAgICAgIGlmIChzb3VyY2VNYXBzICYmIChhZ2VudC5jaHJvbWUgJiYgdmVyc2lvbiA+PSAzMCB8fCBhZ2VudC53ZWJraXQgJiYgdmVyc2lvbiA+PSA1MzcuNzYgfHwgYWdlbnQuZmlyZWZveCAmJiB2ZXJzaW9uID49IDIzIHx8IGFnZW50Lm5vZGUpKSB7XG4gICAgICAgIGlmIChhZ2VudC5ub2RlKSB7XG4gICAgICAgICAgb2Zmc2V0IC09IDI7XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93ICYmIHVybCAmJiAhd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZih1cmwpKSB7XG4gICAgICAgICAgdmFyIGh0bWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHRtbCcpWzBdLmlubmVySFRNTDtcbiAgICAgICAgICBvZmZzZXQgPSBodG1sLnN1YnN0cigwLCBodG1sLmluZGV4T2YoY29kZSkgKyAxKS5tYXRjaChsaW5lQnJlYWtzKS5sZW5ndGggKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0Q29kZSA9IG9mZnNldCA+IDAgJiYgIShhZ2VudC5jaHJvbWUgJiYgdmVyc2lvbiA+PSAzNiB8fCBhZ2VudC5zYWZhcmkgJiYgdmVyc2lvbiA+PSA2MDAgfHwgYWdlbnQuZmlyZWZveCAmJiB2ZXJzaW9uID49IDQwIHx8IGFnZW50Lm5vZGUpO1xuICAgICAgICB2YXIgbWFwcGluZ3MgPSBbJ0FBJyArIGVuY29kZVZMUShvZmZzZXRDb2RlID8gMCA6IG9mZnNldCkgKyAnQSddO1xuICAgICAgICBtYXBwaW5ncy5sZW5ndGggPSAoY29kZS5tYXRjaChsaW5lQnJlYWtzKSB8fCBbXSkubGVuZ3RoICsgMSArIChvZmZzZXRDb2RlID8gb2Zmc2V0IDogMCk7XG4gICAgICAgIG1hcCA9IHtcbiAgICAgICAgICB2ZXJzaW9uOiAzLFxuICAgICAgICAgIGZpbGU6IHVybCxcbiAgICAgICAgICBuYW1lczogW10sXG4gICAgICAgICAgbWFwcGluZ3M6IG1hcHBpbmdzLmpvaW4oJztBQUNBJyksXG4gICAgICAgICAgc291cmNlUm9vdDogJycsXG4gICAgICAgICAgc291cmNlczogW3VybF0sXG4gICAgICAgICAgc291cmNlc0NvbnRlbnQ6IFtzb3VyY2VdXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXBlckZlYXR1cmVzLm9wZXJhdG9yT3ZlcmxvYWRpbmcgIT09IGZhbHNlIHx8IHBhcGVyRmVhdHVyZXMubW9kdWxlRXhwb3J0cyAhPT0gZmFsc2UpIHtcbiAgICAgICAgd2Fsa0FTVChwYXJzZShjb2RlLCB7XG4gICAgICAgICAgcmFuZ2VzOiB0cnVlLFxuICAgICAgICAgIHByZXNlcnZlUGFyZW5zOiB0cnVlLFxuICAgICAgICAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnXG4gICAgICAgIH0pLCBudWxsLCBwYXBlckZlYXR1cmVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcCkge1xuICAgICAgICBpZiAob2Zmc2V0Q29kZSkge1xuICAgICAgICAgIGNvZGUgPSBuZXcgQXJyYXkob2Zmc2V0ICsgMSkuam9pbignXFxuJykgKyBjb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9eKGlubGluZXxib3RoKSQvLnRlc3Qoc291cmNlTWFwcykpIHtcbiAgICAgICAgICBjb2RlICs9IFwiXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIHNlbGYuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkobWFwKSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgKz0gXCJcXG4vLyMgc291cmNlVVJMPVwiICsgKHVybCB8fCAncGFwZXJzY3JpcHQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICBtYXA6IG1hcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGVjdXRlKGNvZGUsIHNjb3BlLCBvcHRpb25zKSB7XG4gICAgICBwYXBlciA9IHNjb3BlO1xuICAgICAgdmFyIHZpZXcgPSBzY29wZS5nZXRWaWV3KCksXG4gICAgICAgICAgdG9vbCA9IC9cXGJ0b29sXFwuXFx3K3xcXHMrb24oPzpLZXl8TW91c2UpKD86VXB8RG93bnxNb3ZlfERyYWcpXFxiLy50ZXN0KGNvZGUpICYmICEvXFxibmV3XFxzK1Rvb2xcXGIvLnRlc3QoY29kZSkgPyBuZXcgVG9vbCgpIDogbnVsbCxcbiAgICAgICAgICB0b29sSGFuZGxlcnMgPSB0b29sID8gdG9vbC5fZXZlbnRzIDogW10sXG4gICAgICAgICAgaGFuZGxlcnMgPSBbJ29uRnJhbWUnLCAnb25SZXNpemUnXS5jb25jYXQodG9vbEhhbmRsZXJzKSxcbiAgICAgICAgICBwYXJhbXMgPSBbXSxcbiAgICAgICAgICBhcmdzID0gW10sXG4gICAgICAgICAgZnVuYyxcbiAgICAgICAgICBjb21waWxlZCA9IHR5cGVvZiBjb2RlID09PSAnb2JqZWN0JyA/IGNvZGUgOiBjb21waWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgY29kZSA9IGNvbXBpbGVkLmNvZGU7XG5cbiAgICAgIGZ1bmN0aW9uIGV4cG9zZShzY29wZSwgaGlkZGVuKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzY29wZSkge1xuICAgICAgICAgIGlmICgoaGlkZGVuIHx8ICEvXl8vLnRlc3Qoa2V5KSkgJiYgbmV3IFJlZ0V4cCgnKFtcXFxcYlxcXFxzXFxcXFddfF4pJyArIGtleS5yZXBsYWNlKC9cXCQvZywgJ1xcXFwkJykgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChrZXkpO1xuICAgICAgICAgICAgYXJncy5wdXNoKHNjb3BlW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBvc2Uoe1xuICAgICAgICBfXyRfXzogX18kX18sXG4gICAgICAgICRfXzogJF9fLFxuICAgICAgICBwYXBlcjogc2NvcGUsXG4gICAgICAgIHRvb2w6IHRvb2xcbiAgICAgIH0sIHRydWUpO1xuICAgICAgZXhwb3NlKHNjb3BlKTtcbiAgICAgIGNvZGUgPSAndmFyIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfTsgJyArIGNvZGU7XG4gICAgICB2YXIgZXhwb3J0cyA9IEJhc2UuZWFjaChoYW5kbGVycywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXHMrJyArIGtleSArICdcXFxcYicpLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICBwYXJhbXMucHVzaChrZXkpO1xuICAgICAgICAgIHRoaXMucHVzaCgnbW9kdWxlLmV4cG9ydHMuJyArIGtleSArICcgPSAnICsga2V5ICsgJzsnKTtcbiAgICAgICAgfVxuICAgICAgfSwgW10pLmpvaW4oJ1xcbicpO1xuXG4gICAgICBpZiAoZXhwb3J0cykge1xuICAgICAgICBjb2RlICs9ICdcXG4nICsgZXhwb3J0cztcbiAgICAgIH1cblxuICAgICAgY29kZSArPSAnXFxucmV0dXJuIG1vZHVsZS5leHBvcnRzOyc7XG4gICAgICB2YXIgYWdlbnQgPSBwYXBlci5hZ2VudDtcblxuICAgICAgaWYgKGRvY3VtZW50ICYmIChhZ2VudC5jaHJvbWUgfHwgYWdlbnQuZmlyZWZveCAmJiBhZ2VudC52ZXJzaW9uTnVtYmVyIDwgNDApKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcbiAgICAgICAgICAgIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgIGlmIChhZ2VudC5maXJlZm94KSBjb2RlID0gJ1xcbicgKyBjb2RlO1xuICAgICAgICBzY3JpcHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ2RvY3VtZW50Ll9fcGFwZXJzY3JpcHRfXyA9IGZ1bmN0aW9uKCcgKyBwYXJhbXMgKyAnKSB7JyArIGNvZGUgKyAnXFxufScpKTtcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICBmdW5jID0gZG9jdW1lbnQuX19wYXBlcnNjcmlwdF9fO1xuICAgICAgICBkZWxldGUgZG9jdW1lbnQuX19wYXBlcnNjcmlwdF9fO1xuICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jID0gRnVuY3Rpb24ocGFyYW1zLCBjb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4cG9ydHMgPSBmdW5jICYmIGZ1bmMuYXBwbHkoc2NvcGUsIGFyZ3MpO1xuICAgICAgdmFyIG9iaiA9IGV4cG9ydHMgfHwge307XG4gICAgICBCYXNlLmVhY2godG9vbEhhbmRsZXJzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAodmFsdWUpIHRvb2xba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgIGlmIChvYmoub25SZXNpemUpIHZpZXcuc2V0T25SZXNpemUob2JqLm9uUmVzaXplKTtcbiAgICAgICAgdmlldy5lbWl0KCdyZXNpemUnLCB7XG4gICAgICAgICAgc2l6ZTogdmlldy5zaXplLFxuICAgICAgICAgIGRlbHRhOiBuZXcgUG9pbnQoKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9iai5vbkZyYW1lKSB2aWV3LnNldE9uRnJhbWUob2JqLm9uRnJhbWUpO1xuICAgICAgICB2aWV3LnJlcXVlc3RVcGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZFNjcmlwdChzY3JpcHQpIHtcbiAgICAgIGlmICgvXnRleHRcXC8oPzp4LXwpcGFwZXJzY3JpcHQkLy50ZXN0KHNjcmlwdC50eXBlKSAmJiBQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShzY3JpcHQsICdpZ25vcmUnKSAhPT0gJ3RydWUnKSB7XG4gICAgICAgIHZhciBjYW52YXNJZCA9IFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKHNjcmlwdCwgJ2NhbnZhcycpLFxuICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzSWQpLFxuICAgICAgICAgICAgc3JjID0gc2NyaXB0LnNyYyB8fCBzY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpLFxuICAgICAgICAgICAgYXN5bmMgPSBQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShzY3JpcHQsICdhc3luYycpLFxuICAgICAgICAgICAgc2NvcGVBdHRyaWJ1dGUgPSAnZGF0YS1wYXBlci1zY29wZSc7XG4gICAgICAgIGlmICghY2FudmFzKSB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGNhbnZhcyB3aXRoIGlkIFwiJyArIGNhbnZhc0lkICsgJ1wiJyk7XG4gICAgICAgIHZhciBzY29wZSA9IFBhcGVyU2NvcGUuZ2V0KGNhbnZhcy5nZXRBdHRyaWJ1dGUoc2NvcGVBdHRyaWJ1dGUpKSB8fCBuZXcgUGFwZXJTY29wZSgpLnNldHVwKGNhbnZhcyk7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoc2NvcGVBdHRyaWJ1dGUsIHNjb3BlLl9pZCk7XG5cbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICB1cmw6IHNyYyxcbiAgICAgICAgICAgIGFzeW5jOiBhc3luYyxcbiAgICAgICAgICAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICAgICAgICBvbkxvYWQ6IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICAgIGV4ZWN1dGUoY29kZSwgc2NvcGUsIHNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhlY3V0ZShzY3JpcHQuaW5uZXJIVE1MLCBzY29wZSwgc2NyaXB0LmJhc2VVUkkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1pZ25vcmUnLCAndHJ1ZScpO1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEFsbCgpIHtcbiAgICAgIEJhc2UuZWFjaChkb2N1bWVudCAmJiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JyksIGxvYWRTY3JpcHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWQoc2NyaXB0KSB7XG4gICAgICByZXR1cm4gc2NyaXB0ID8gbG9hZFNjcmlwdChzY3JpcHQpIDogbG9hZEFsbCgpO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIHNldFRpbWVvdXQobG9hZEFsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBEb21FdmVudC5hZGQod2luZG93LCB7XG4gICAgICAgICAgbG9hZDogbG9hZEFsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGV4ZWN1dGU6IGV4ZWN1dGUsXG4gICAgICBsb2FkOiBsb2FkLFxuICAgICAgcGFyc2U6IHBhcnNlLFxuICAgICAgY2FsY3VsYXRlQmluYXJ5OiBfXyRfXyxcbiAgICAgIGNhbGN1bGF0ZVVuYXJ5OiAkX19cbiAgICB9O1xuICB9LmNhbGwodGhpcyk7XG5cbiAgdmFyIHBhcGVyID0gbmV3IChQYXBlclNjb3BlLmluamVjdChCYXNlLmV4cG9ydHMsIHtcbiAgICBCYXNlOiBCYXNlLFxuICAgIE51bWVyaWNhbDogTnVtZXJpY2FsLFxuICAgIEtleTogS2V5LFxuICAgIERvbUV2ZW50OiBEb21FdmVudCxcbiAgICBEb21FbGVtZW50OiBEb21FbGVtZW50LFxuICAgIGRvY3VtZW50OiBkb2N1bWVudCxcbiAgICB3aW5kb3c6IHdpbmRvdyxcbiAgICBTeW1ib2w6IFN5bWJvbERlZmluaXRpb24sXG4gICAgUGxhY2VkU3ltYm9sOiBTeW1ib2xJdGVtXG4gIH0pKSgpO1xuXG4gIGlmIChwYXBlci5hZ2VudC5ub2RlKSB7XG4gICAgcmVxdWlyZSgnLi9ub2RlL2V4dGVuZC5qcycpKHBhcGVyKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3BhcGVyJywgcGFwZXIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcGFwZXI7XG4gIH1cblxuICByZXR1cm4gcGFwZXI7XG59LmNhbGwodGhpcywgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnID8gc2VsZiA6IG51bGwpOyIsImltcG9ydCBcIi4vc3R5bGVzL2luZGV4LnNjc3NcIjtcclxuaW1wb3J0IHBhcGVyLCB7IFJlY3RhbmdsZSwgUGF0aCwgUG9pbnQsIFRvb2wsIFBvaW50VGV4dCB9IGZyb20gJ3BhcGVyJztcclxuaW1wb3J0IFNpZGViYXIgZnJvbSAnLi9zY3JpcHRzL3NpZGViYXIvc2lkZWJhcic7XHJcbmltcG9ydCBzaWRlYmFyRGF0YSBmcm9tICcuL3NjcmlwdHMvdXRpbC9zaWRlYmFyX2RhdGEnXHJcbmltcG9ydCBNeUNhbnZhcyBmcm9tIFwiLi9zY3JpcHRzL2NhbnZhcy9jYW52YXNcIjtcclxuaW1wb3J0IEluZm8gZnJvbSBcIi4vc2NyaXB0cy9pbnRyby9pbmZvXCI7XHJcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiLi9zY3JpcHRzL2ludHJvL21lc3NhZ2VcIjtcclxuXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBtYWluID0+e1xyXG4gICAgLy8gY2FudmFzXHJcbiAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215Q2FudmFzJyk7XHJcbiAgICBjb25zdCBteUNhbnZhcyA9IG5ldyBNeUNhbnZhcyhjYW52YXNFbGVtZW50KTtcclxuXHJcbiAgIFxyXG5cclxuICAgIC8vc2lkZWJhclxyXG4gICAgY29uc3Qgc2lkZWJhckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VjdGlvbi1jb250ZW50LXNpZGViYXInKTtcclxuICAgIGNvbnN0IHNpZGViYXIgPSBuZXcgU2lkZWJhcihcclxuICAgICAgICBzaWRlYmFyRGF0YVswXSwgXHJcbiAgICAgICAgc2lkZWJhckVsZW1lbnQsXHJcbiAgICAgICAgbXlDYW52YXMuZHJhd1NoYXBlcyk7XHJcblxyXG5cclxuICAgIC8vaW5mbyBzaWRlIGJhclxyXG4gICAgY29uc3QgaW5mb1NpZGViYXIgPSBuZXcgSW5mbyhcIlRpcHNcIiwgbWVzc2FnZSk7XHJcblxyXG4gICAgIFxyXG59KTtcclxuXHJcblxyXG4iLCJpbXBvcnQgeyBTSEFQRVMgfSBmcm9tIFwiLi4vdXRpbC9jb25zdGFudHNcIjtcclxuaW1wb3J0IHBhcGVyLCB7IFByb2plY3QsIFBhdGgsIEdyb3VwLCBQb2ludFRleHQsIHRvb2wsIFRvb2wsIFJlY3RhbmdsZSwgUG9pbnQsIFNpemUgfSBmcm9tICdwYXBlcic7XHJcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vbW9kYWwvbW9kYWxcIjtcclxuXHJcbmltcG9ydCB7Z2V0QW5nbGVEZWd9IGZyb20gJy4uL3V0aWwvdXRpbCc7XHJcblxyXG5jb25zdCBib3VuZHNJZGVudGlmaWVyT2JqID0ge1xyXG4gIDE6ICd0b3BMZWZ0JywgMjogJ3RvcFJpZ2h0JywgMzogJ2JvdHRvbVJpZ2h0JywgMDogJ2JvdHRvbUxlZnQnXHJcbn1cclxuXHJcbmNvbnN0IGJvdW5kc0NlbnRlcklkZW50aWZpZXJPYmogPSB7XHJcbiAgMTogJ3RvcENlbnRlcicsIDI6ICdyaWdodENlbnRlcicsIDM6ICdib3R0b21DZW50ZXInLCAwOiAnbGVmdENlbnRlcidcclxufVxyXG5jb25zdCBMSU5FID0gJ2xpbmUnOyBcclxuXHJcbmNsYXNzIE15Q2FudmFzIHtcclxuICBjb25zdHJ1Y3RvcihjYW52YXNFbGVtZW50KSB7XHJcbiAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSAgY2FudmFzRWxlbWVudDtcclxuICAgIHRoaXMuY2VudGVyUG9zaXRpb24gPSB0aGlzLmdldENlbnRlclBvc2l0aW9uKCk7XHJcbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gJ2JsYWNrJztcclxuICAgIHRoaXMuZmlsbENvbG9yID0gXCJ3aGl0ZVwiO1xyXG4gICAgdGhpcy5kZWZhdWx0U2l6ZSA9IFsxMDAsMTAwXTtcclxuICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0gPSBudWxsO1xyXG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDI7XHJcblxyXG4gICAgLy8gc2V0cyB1cCBwYXBlciBqcyBvbiBjYW52YXNcclxuICAgIHBhcGVyLnNldHVwKGNhbnZhc0VsZW1lbnQpO1xyXG5cclxuICAgIC8vY3JlYXRlcyBuZXcgcHJvamVjdCBpbiBwYXBlclxyXG4gICAgdGhpcy5wcm9qZWN0ID0gbmV3IFByb2plY3QoY2FudmFzRWxlbWVudClcclxuXHJcbiAgICAvL2NhbnZhcyBzY2FsZSB2YWx1ZVxyXG4gICAgdGhpcy5jYW52YXNTY2FsZVZhbHVlID0gMTtcclxuXHJcbiAgICAvL2NyZWF0aW5nIHRvb2xcclxuICAgIHRoaXMudG9vbCA9IG5ldyBUb29sKCk7XHJcbiAgICAvLyBoYXMgbW92ZWQgYXQgbGVhc3QgMTAgcG9pbnRzOlxyXG4gICAgdG9vbC5taW5EaXN0YW5jZSA9IDI7XHJcblxyXG4gICAgLy9iaW5kcyBtZXRob2RzXHJcbiAgICAvL3NoYXBlcyBtZXRob2QgYmluZGluZ1xyXG4gICAgdGhpcy5kcmF3U2hhcGVzID0gdGhpcy5kcmF3U2hhcGVzLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmRyYXdDbGFzc1NoYXBlID0gdGhpcy5kcmF3Q2xhc3NTaGFwZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5kcmF3TGluZVNoYXBlID0gdGhpcy5kcmF3TGluZVNoYXBlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmRyYXdPYmplY3RTaGFwZSA9IHRoaXMuZHJhd09iamVjdFNoYXBlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmRyYXdUZXh0U2hhcGUgPSB0aGlzLmRyYXdUZXh0U2hhcGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZHJhd1VzZXJDYXNlU2hhcGUgPSB0aGlzLmRyYXdVc2VDYXNlU2hhcGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZHJhd0NvbXBvbmVudFNoYXBlID0gdGhpcy5kcmF3Q29tcG9uZW50U2hhcGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZHJhd01vZHVsZVNoYXBlID0gdGhpcy5kcmF3TW9kdWxlU2hhcGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZHJhd0FjdGl2aXR5U2hhcGUgPSB0aGlzLmRyYXdBY3Rpdml0eVNoYXBlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmRyYXdEZWNpc2lvblNoYXBlID0gdGhpcy5kcmF3RGVjaXNpb25TaGFwZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5kcmF3QWN0b3JTaGFwZSA9IHRoaXMuZHJhd0FjdG9yU2hhcGUuYmluZCh0aGlzKTtcclxuXHJcbiAgICAvL2dlbmVyYWwgbWV0aG9kIGJpbmRpbmdcclxuICAgIHRoaXMuZ2V0Q2VudGVyUG9zaXRpb24gPSB0aGlzLmdldENlbnRlclBvc2l0aW9uLmJpbmQodGhpcyk7XHJcblxyXG4gICAgLy91c2VyIGludGVyYWN0aW9uIG1ldGhvZCBiaW5kaW5nXHJcbiAgICB0aGlzLm9uVG9vbERvdWJsZUNsaWNrID0gdGhpcy5vblRvb2xEb3VibGVDbGljay5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vblRvb2xNb3VzZURvd24gPSB0aGlzLm9uVG9vbE1vdXNlRG93bi5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5zZXRPbmVJdGVtU2VsZWN0ZWQgPSB0aGlzLnNldE9uZUl0ZW1TZWxlY3RlZC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vblRvb2xEcmFnID0gdGhpcy5vblRvb2xEcmFnLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uVG9vbEtleURvd24gPSB0aGlzLm9uVG9vbEtleURvd24uYmluZCh0aGlzKTtcclxuXHJcbiAgICAvL3Rvb2wgbGV2ZWwgY2xpY2tsaXN0ZW5lclxyXG4gICAgdGhpcy50b29sLm9uTW91c2VEb3duID0gdGhpcy5vblRvb2xNb3VzZURvd247XHJcbiAgICB0aGlzLnRvb2wub25Nb3VzZVVwID0gdGhpcy5vblRvb2xNb3VzZVVwO1xyXG4gICAgdGhpcy50b29sLm9uTW91c2VEcmFnID0gdGhpcy5vblRvb2xEcmFnO1xyXG4gICAgdGhpcy50b29sLm9uS2V5RG93biA9IHRoaXMub25Ub29sS2V5RG93bjtcclxuXHJcbiAgICAgLy9hZGQgZG91YmxlIGNsaWNrIGxpc3RlbmVyIG9uIGNhbnZhcyBiZWNhdXNlIHRvb2wgaGF2ZSBubyBkb3VibGUgY2xpY2sgbGlzdGVuZXJcclxuICAgIHRoaXMuY2FudmFzRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgdGhpcy5vblRvb2xEb3VibGVDbGljayk7XHJcblxyXG4gICAgLy9zZXQgcmlnaHQgbWVudSBsaXRlbmVyc1xyXG4gICAgdGhpcy5zZXRNZW51Q2xpY2tMaXN0ZW5lciA9IHRoaXMuc2V0TWVudUNsaWNrTGlzdGVuZXIuYmluZCh0aGlzKTtcclxuXHJcbiAgICAvL2xpbmUgYXR0YWNoZW1lbnQgZnVuY3Rpb24gYmluZGluZ1xyXG4gICAgdGhpcy5jaGVja0xpbmVBdHRhY2htZW50ID0gdGhpcy5jaGVja0xpbmVBdHRhY2htZW50LmJpbmQodGhpcyk7XHJcblxyXG4gICAgLy9saW5lIHJlbmRlciBmdW5jdGlvblxyXG4gICAgdGhpcy5yZVJlbmRlckxpbmUgPSB0aGlzLnJlUmVuZGVyTGluZS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuc2V0TWVudUNsaWNrTGlzdGVuZXIoKTtcclxuICB9XHJcblxyXG5cclxuICAvL3NldCByaWdodCBtZW51IGNsaWNrIGxpc3RlbmVyXHJcbiAgc2V0TWVudUNsaWNrTGlzdGVuZXIoKXtcclxuICAgIGNvbnN0IG9wZW5GaWxlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvcGVuLWZpbGUnKTtcclxuICAgIGNvbnN0IGRvd25sb2FkRmlsZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93bmxvYWQtZmlsZScpO1xyXG4gICAgY29uc3QgYnJpbmdUb0Zyb250RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdicmluZy10by1mcm9udCcpO1xyXG4gICAgY29uc3QgbW92ZVRvQmFja0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW92ZS10by1iYWNrJyk7XHJcblxyXG4gICAgb3BlbkZpbGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyx0aGlzLm9wZW5GaWxlLmJpbmQodGhpcykpO1xyXG4gICAgZG93bmxvYWRGaWxlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZG93bmxvYWRBc1NWRy5iaW5kKHRoaXMpKTtcclxuICAgIGJyaW5nVG9Gcm9udEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmJyaW5nVG9Gcm9udC5iaW5kKHRoaXMpKTtcclxuICAgIG1vdmVUb0JhY2tFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5tb3ZlVG9CYWNrLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbiAgLy9zZXQgaW5wdXQgdG8gb3BlbiBmaWxlIHBpY2tlciBkaWFsb2dcclxuICBvcGVuRmlsZSgpe1xyXG4gICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgIGlucHV0LnR5cGUgPSAnZmlsZSc7XHJcbiAgICBpbnB1dC5tdWx0aXBsZSA9IGZhbHNlO1xyXG4gICAgaW5wdXQuYWNjZXB0ID0gJ2ltYWdlL3N2Zyt4bWwnO1xyXG4gICAgaW5wdXQub25jaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvamVjdC5pbXBvcnRTVkcoVVJMLmNyZWF0ZU9iamVjdFVSTChpbnB1dC5maWxlc1swXSksKGdyb3VwLCBzdmcpPT57XHJcbiAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0LmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgd2hpbGUoZ3JvdXAuY2hpbGRyZW5bMV0uY2hpbGRyZW4ubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnByb2plY3QuYWN0aXZlTGF5ZXIuYWRkQ2hpbGQoZ3JvdXAuY2hpbGRyZW5bMV0uY2hpbGRyZW5bMF0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH07XHJcbiAgICBpbnB1dC5jbGljaygpO1xyXG4gICAgXHJcbiAgfVxyXG5cclxuICAvLyBzZXQgZG93bmxvYWQgcHJvamVjdCBhcyBzdmdcclxuICBkb3dubG9hZEFzU1ZHKCkge1xyXG4gICBcclxuICAgIGlmKHRoaXMucHJvamVjdC5hY3RpdmVMYXllci5jaGlsZHJlbi5sZW5ndGggPT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGZpbGVOYW1lID0gYHVtbGNoYXJ0XyR7RGF0ZS5ub3coKX0uc3ZnYDtcclxuIFxyXG4gICAgdmFyIHVybCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsXCIgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5wcm9qZWN0LmV4cG9ydFNWRyh7YXNTdHJpbmc6dHJ1ZX0pKTtcclxuICAgIFxyXG4gICAgdmFyIGRvd25sb2FkTGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgIGRvd25sb2FkTGlua0VsZW1lbnQuZG93bmxvYWQgPSBmaWxlTmFtZTtcclxuICAgIGRvd25sb2FkTGlua0VsZW1lbnQuaHJlZiA9IHVybDtcclxuICAgIGRvd25sb2FkTGlua0VsZW1lbnQuY2xpY2soKTtcclxuIH1cclxuXHJcblxyXG4gLy9zZXQgYnJpbmcgdG8gZnJvbnQgbGlzdGVuZXIgZm9yIGl0ZW1zXHJcbiBicmluZ1RvRnJvbnQoKXtcclxuICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmJyaW5nVG9Gcm9udCgpO1xyXG4gfVxyXG5cclxuIC8vc2V0IG1vdmUgdG8gYmFjayBsaXN0ZW5lciBmb3IgaXRlbXNcclxuIG1vdmVUb0JhY2soKXtcclxuICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLnNlbmRUb0JhY2soKTtcclxuIH1cclxuXHJcbiAgLy9zaGFwZSBkcmF3IGRpc3RyaWJ1dG9yXHJcbiAgZHJhd1NoYXBlcyhzaGFwZU5hbWUpe1xyXG5cclxuICAgIHN3aXRjaCAoc2hhcGVOYW1lKSB7XHJcbiAgICAgIGNhc2UgU0hBUEVTLkNMQVNTOlxyXG4gICAgICAgIHRoaXMuZHJhd0NsYXNzU2hhcGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuQUdHUkVHQVRJT046XHJcbiAgICAgIGNhc2UgU0hBUEVTLkNPTVBPU0lUSU9OOlxyXG4gICAgICBjYXNlIFNIQVBFUy5ESVZJREVSOiAgXHJcbiAgICAgIGNhc2UgU0hBUEVTLkFTU09DSUFUSU9OOiAgXHJcbiAgICAgICAgbGV0IHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LTUwLCB0aGlzLmNlbnRlclBvc2l0aW9uLnkpO1xyXG4gICAgICAgIGxldCBlbmRQb2ludCA9IG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngrNTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueSk7XHJcbiAgICAgICAgdGhpcy5kcmF3TGluZVNoYXBlKHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBzaGFwZU5hbWUpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFNIQVBFUy5TUVVBUkU6XHJcbiAgICAgIGNhc2UgU0hBUEVTLk9CSkVDVDpcclxuICAgICAgY2FzZSBTSEFQRVMuSU5URVJGQUNFOlxyXG4gICAgICAgICAgdGhpcy5kcmF3T2JqZWN0U2hhcGUoc2hhcGVOYW1lKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuVElUTEU6XHJcbiAgICAgICAgc3RhcnRQb2ludCA9IG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMjUsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yNSk7XHJcbiAgICAgICAgdGhpcy5kcmF3VGV4dFNoYXBlKHN0YXJ0UG9pbnQsIFwiQWRkIFRleHRcIik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU0hBUEVTLkNJUkNMRTpcclxuICAgICAgY2FzZSBTSEFQRVMuVVNFQ0FTRTpcclxuICAgICAgICB0aGlzLmRyYXdVc2VDYXNlU2hhcGUoc2hhcGVOYW1lKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuQ09NUE9ORU5UOlxyXG4gICAgICAgIHRoaXMuZHJhd0NvbXBvbmVudFNoYXBlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU0hBUEVTLk1PRFVMRTpcclxuICAgICAgICB0aGlzLmRyYXdNb2R1bGVTaGFwZSgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFNIQVBFUy5BQ1RJVklUWTpcclxuICAgICAgICB0aGlzLmRyYXdBY3Rpdml0eVNoYXBlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU0hBUEVTLkRFQ0lTSU9OOlxyXG4gICAgICAgIHRoaXMuZHJhd0RlY2lzaW9uU2hhcGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuQUNUT1I6XHJcbiAgICAgICAgdGhpcy5kcmF3QWN0b3JTaGFwZSgpO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlcyB0aHJlZSByZWN0YW5nbGUgdG8gbWFrZSBhIGNsYXNzIFVNTFxyXG4gIGRyYXdDbGFzc1NoYXBlKCl7XHJcbiAgICAvL2NyZWF0ZXMgZ3JvdXAgYW5kIGFkZCBzaGFwZXNcclxuXHJcbiAgICAvL2NyZWF0ZSBjbGFzcyByZWN0YW5nbGVcclxuICAgIGNvbnN0IGdyb3VwQ2xhc3MgPSBuZXcgR3JvdXAoKTtcclxuICAgIGNvbnN0IGZpcnN0UmVjdFggPSB0aGlzLmNlbnRlclBvc2l0aW9uLngtNTA7XHJcbiAgICBjb25zdCBmaXJzdFJlY3RZID0gdGhpcy5jZW50ZXJQb3NpdGlvbi55LTUwO1xyXG4gICAgY29uc3QgZmlyc3RSZWN0SGVpZ2h0ID0gMjA7XHJcbiAgICBjb25zdCBmcmlzdFJlY3RXaWR0aCA9IHRoaXMuZGVmYXVsdFNpemVbMV07XHJcbiAgICBjb25zdCBjbGFzc05hbWVSZWN0YW5nbGUgPSBuZXcgUGF0aC5SZWN0YW5nbGUoZmlyc3RSZWN0WCwgZmlyc3RSZWN0WSwgZnJpc3RSZWN0V2lkdGgsIGZpcnN0UmVjdEhlaWdodCk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoY2xhc3NOYW1lUmVjdGFuZ2xlKTtcclxuICAgIGdyb3VwQ2xhc3MuYWRkQ2hpbGQoY2xhc3NOYW1lUmVjdGFuZ2xlKTtcclxuXHJcbiAgICAvL2NyZWF0ZSB2YXJhaWJsZSByZWN0YW5nbGVcclxuICAgIGNvbnN0IHNlY1JlY3RYID0gZmlyc3RSZWN0WDtcclxuICAgIGNvbnN0IHNlY1JlY3RZID0gZmlyc3RSZWN0WSArIGZpcnN0UmVjdEhlaWdodDtcclxuICAgIGNvbnN0IHNlY1JlY3RIZWlnaHQgPSA1MDtcclxuICAgIGNvbnN0IHNlY1JlY3RXaWR0aCA9IHRoaXMuZGVmYXVsdFNpemVbMV07XHJcbiAgICBjb25zdCB2YXJpYWJsZU5hbWVSZWN0YW5nbGUgPSBuZXcgUGF0aC5SZWN0YW5nbGUoc2VjUmVjdFgsIHNlY1JlY3RZLCBzZWNSZWN0V2lkdGgsIHNlY1JlY3RIZWlnaHQpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHZhcmlhYmxlTmFtZVJlY3RhbmdsZSk7XHJcbiAgICBncm91cENsYXNzLmFkZENoaWxkKHZhcmlhYmxlTmFtZVJlY3RhbmdsZSk7XHJcblxyXG5cclxuICAgIC8vY3JlYXRlIG1ldGhvZCByZWN0YW5nbGVcclxuICAgIGNvbnN0IHRoaXJkUmVjdFggPSBmaXJzdFJlY3RYO1xyXG4gICAgY29uc3QgdGhpcmRSZWN0WSA9IHNlY1JlY3RZICsgc2VjUmVjdEhlaWdodDtcclxuICAgIGNvbnN0IHRoaXJkUmVjdEhlaWdodCA9IDMwO1xyXG4gICAgY29uc3QgdGhpcmRSZWN0V2lkdGggPSB0aGlzLmRlZmF1bHRTaXplWzFdO1xyXG4gICAgY29uc3QgbWV0aG9kTmFtZVJlY3RhbmdsZSA9IG5ldyBQYXRoLlJlY3RhbmdsZSh0aGlyZFJlY3RYLCB0aGlyZFJlY3RZLCB0aGlyZFJlY3RXaWR0aCwgdGhpcmRSZWN0SGVpZ2h0KTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChtZXRob2ROYW1lUmVjdGFuZ2xlKTtcclxuICAgIGdyb3VwQ2xhc3MuYWRkQ2hpbGQobWV0aG9kTmFtZVJlY3RhbmdsZSk7XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gYWRkcyB0ZXh0IHRvIHRoZSBjbGlja2VkIGFyZWFcclxuICBkcmF3VGV4dFNoYXBlKHBvc2l0aW9uLCB0ZXh0KXtcclxuICAgIC8vY3JlYXRlIHRleHQgc2hhcGVcclxuICAgIGxldCB0ZXh0U2hhcGUgPSBuZXcgUG9pbnRUZXh0KHBvc2l0aW9uKTtcclxuICAgIHRleHRTaGFwZS5maWxsQ29sb3IgPSB0aGlzLnN0cm9rZUNvbG9yO1xyXG4gICAgdGV4dFNoYXBlLmNvbnRlbnQgPSB0ZXh0O1xyXG5cclxuICAgIC8vYWRkcyBkb3VibGVjbGljayBsaXN0bmVyIHRvIHRleHRcclxuICAgIHRleHRTaGFwZS5vbkRvdWJsZUNsaWNrID0gKGUpPT57XHJcbiAgICAgIC8vc2hvdyBtb2RhbCB0byB1cGRhdGUgdGV4dFxyXG4gICAgICBpZih0ZXh0U2hhcGUuYm91bmRzLnNlbGVjdGVkKXtcclxuICAgICAgICBuZXcgTW9kYWwoKHVwZGF0ZWRUZXh0KT0+e1xyXG4gICAgICAgICAgdGV4dFNoYXBlLmNvbnRlbnQgPSB1cGRhdGVkVGV4dDtcclxuICAgICAgICB9KS5zaG93KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dFNoYXBlXHJcbiAgfVxyXG5cclxuICAvL2FkZCBEaXZpZGVyL0Fzc29jaWF0aW9uL0NvbXBvc2l0aW9pbi9BZ2dyZWdhdGlvbiB3aXRoIGhlYWQgc2hhcGUgYW5kIHRocmVlIGNpcmNsZXMgKHRvIGFpZCBtb3ZlbWVudCBhbmQgZHJhZylcclxuICBkcmF3TGluZVNoYXBlKHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBsaW5lVHlwZSl7XHJcbiAgICBcclxuXHJcbiAgICBsZXQgbWFpbkdyb3VwID0gbmV3IEdyb3VwKCk7XHJcbiAgICBsZXQgZ3JvdXAgPSAgbmV3IEdyb3VwKCk7XHJcbiAgICBcclxuICAgIC8vZHJhdyBsaW5lXHJcbiAgICBjb25zdCBsaW5lID0gbmV3IFBhdGguTGluZShzdGFydFBvaW50LCBlbmRQb2ludCk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwobGluZSk7XHJcblxyXG4gICAgLy8gZHJhdyBoZWFkIGNpcmNsZVxyXG4gICAgY29uc3QgaGVhZENpcmNsZSA9IG5ldyBQYXRoLkNpcmNsZShlbmRQb2ludCwgNSk7XHJcbiAgICBoZWFkQ2lyY2xlLmZpbGxDb2xvciA9ICdibGFjayc7XHJcbiAgICBoZWFkQ2lyY2xlLnN0cm9rZVdpZHRoID0gMTtcclxuXHJcbiAgICAvL2RyYXcgbWlkZGxlIGNpcmNsZVxyXG4gICAgY29uc3QgbWlkUG9pbnQgPSBuZXcgUG9pbnQoKHN0YXJ0UG9pbnQueCtlbmRQb2ludC54KS8yLCAoc3RhcnRQb2ludC55K2VuZFBvaW50LnkpLzIpXHJcbiAgICBjb25zdCBtaWRDaXJjbGUgPSBuZXcgUGF0aC5DaXJjbGUobWlkUG9pbnQsIDQpO1xyXG4gICAgbWlkQ2lyY2xlLmZpbGxDb2xvciA9ICdibGFjayc7XHJcbiAgICBtaWRDaXJjbGUuc3Ryb2tlV2lkdGggPSAxO1xyXG5cclxuXHJcbiAgICAvL2RyYXcgdGFpbCBjaXJjbGVcclxuICAgIGNvbnN0IHRhaWxDaXJjbGUgPSBuZXcgUGF0aC5DaXJjbGUoc3RhcnRQb2ludCwgNSk7XHJcbiAgICB0YWlsQ2lyY2xlLmZpbGxDb2xvciA9ICdibGFjayc7XHJcbiAgICB0YWlsQ2lyY2xlLnN0cm9rZVdpZHRoID0gMTtcclxuXHJcblxyXG4gICAgLy9hZGQgY2lyY2xlcyBhbmQgbGluZSB0byBncm91cFxyXG4gICAgZ3JvdXAuYWRkQ2hpbGQobGluZSk7XHJcbiAgICBncm91cC5hZGRDaGlsZCh0YWlsQ2lyY2xlKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKG1pZENpcmNsZSk7XHJcbiAgICBncm91cC5hZGRDaGlsZChoZWFkQ2lyY2xlKTtcclxuXHJcbiAgICAvL2RyYXcgYXJyb3cgc2hhcGVcclxuICAgIGNvbnN0IGhlYWRTaGFwZSA9IG5ldyBQYXRoKCk7XHJcbiAgICBoZWFkU2hhcGUuc3Ryb2tlQ29sb3I9IHRoaXMuc3Ryb2tlQ29sb3I7XHJcbiAgICBoZWFkU2hhcGUuc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xyXG5cclxuICAgIGxldCBhcnJvd0NlbnRlciA9IGVuZFBvaW50O1xyXG5cclxuICAgIC8vYmFzZWQgb24gbGluZSB0eXBlIGRyYXcgc2hhcGVcclxuICAgIGlmKGxpbmVUeXBlICE9PSBTSEFQRVMuRElWSURFUil7XHJcbiAgICAgIGNvbnN0IGxlZnRFZGdlID0gbmV3IFBvaW50KGFycm93Q2VudGVyLngtMTAsIGFycm93Q2VudGVyLnktMTApO1xyXG4gICAgICBjb25zdCByaWdodEVkZ2UgPSBuZXcgUG9pbnQoYXJyb3dDZW50ZXIueC0xMCwgYXJyb3dDZW50ZXIueSsxMCk7XHJcbiAgICAgIGhlYWRTaGFwZS5hZGQobGVmdEVkZ2UpO1xyXG4gICAgICBoZWFkU2hhcGUuYWRkKGFycm93Q2VudGVyKTtcclxuICAgICAgaGVhZFNoYXBlLmFkZChyaWdodEVkZ2UpO1xyXG5cclxuICAgICAgaWYobGluZVR5cGUgPT09IFNIQVBFUy5BR0dSRUdBVElPTiB8fCBsaW5lVHlwZSA9PT0gIFNIQVBFUy5DT01QT1NJVElPTil7XHJcbiAgICAgICAgY29uc3QgYm90dG9tUmlnaHRFZGdlID0gbmV3IFBvaW50KGFycm93Q2VudGVyLngtMjAsIGFycm93Q2VudGVyLnkpO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUxlZnRFZGdlID0gbGVmdEVkZ2U7XHJcbiAgICAgICAgaGVhZFNoYXBlLmFkZChib3R0b21SaWdodEVkZ2UpO1xyXG4gICAgICAgIGhlYWRTaGFwZS5hZGQoYm90dG9tTGVmdEVkZ2UpO1xyXG5cclxuICAgICAgICBpZihsaW5lVHlwZSA9PT0gU0hBUEVTLkFHR1JFR0FUSU9OKXtcclxuICAgICAgICAgIGhlYWRTaGFwZS5zdHJva2VDb2xvciA9ICd3aGl0ZSc7XHJcbiAgICAgICAgICBoZWFkU2hhcGUuZmlsbENvbG9yID0gJ3doaXRlJztcclxuICAgICAgICAgIGhlYWRTaGFwZS5zaGFkb3dDb2xvciA9ICdncmF5JztcclxuICAgICAgICAgIGhlYWRTaGFwZS5zaGFkb3dPZmZzZXQ9MTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGxpbmVUeXBlID09PSBTSEFQRVMuQ09NUE9TSVRJT04pe1xyXG4gICAgICAgICAgaGVhZFNoYXBlLmZpbGxDb2xvciA9ICdibGFjayc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgXHJcblxyXG4gICAgLy9yb3RhdGUgdGhlIGhlYWQgc2hhcGVcclxuICAgIGlmKGxpbmVUeXBlICE9PSBTSEFQRVMuRElWSURFUilcclxuICAgICAgaGVhZFNoYXBlLnJvdGF0ZShcclxuICAgICAgICBnZXRBbmdsZURlZyhlbmRQb2ludC54LCBlbmRQb2ludC55LHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55KSwgXHJcbiAgICAgICAgYXJyb3dDZW50ZXIpO1xyXG5cclxuICAgIFxyXG4gICAgLy9hZGQgZ3JvdXAgdG8gbWFpbiBncm91cFxyXG4gICAgbWFpbkdyb3VwLmFkZENoaWxkKGdyb3VwKTtcclxuICAgIGlmKGxpbmVUeXBlICE9PSBTSEFQRVMuRElWSURFUilcclxuICAgICAgbWFpbkdyb3VwLmFkZENoaWxkKGhlYWRTaGFwZSk7XHJcbiAgICBtYWluR3JvdXAuZGF0YS50eXBlID0gTElORTtcclxuICAgIG1haW5Hcm91cC5kYXRhLmxpbmVUeXBlID0gbGluZVR5cGU7XHJcbiAgICBtYWluR3JvdXAuZGF0YS5saW5lSWQgPSBEYXRlLm5vdygpO1xyXG4gICAgcmV0dXJuIG1haW5Hcm91cDtcclxuICB9XHJcblxyXG4gIC8vYWRkIE9iamVjdC9JbnRlcmZhY2Ugc2hhcGVcclxuICBkcmF3T2JqZWN0U2hhcGUodHlwZSl7XHJcbiAgICAvL2NyZWF0ZXMgb2JqZWN0IHJlY3RhbmdsZVxyXG4gICAgY29uc3Qgc3RhcnRQb2ludCA9IG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtNTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yNSlcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IG5ldyBQYXRoLlJlY3RhbmdsZShzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSwgdGhpcy5kZWZhdWx0U2l6ZVswXSwgdGhpcy5kZWZhdWx0U2l6ZVswXS8yKTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChyZWN0YW5nbGUpO1xyXG5cclxuXHJcblxyXG4gICAgLy9jcmVhdGUgdGV4dHNoYXBlXHJcbiAgICBpZih0eXBlICE9PSBTSEFQRVMuU1FVQVJFKXtcclxuICAgICAgY29uc3QgdGV4dFNoYXBlU3RhcnRQb2ludCA9IG5ldyBQb2ludChzdGFydFBvaW50LngrMzAsIHN0YXJ0UG9pbnQueSszMCk7XHJcbiAgICAgIGNvbnN0IHRleHRTaGFwZSA9IHRoaXMuZHJhd1RleHRTaGFwZSh0ZXh0U2hhcGVTdGFydFBvaW50LCB0eXBlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vYWRkIFVzZWNhc2UvQWN0aXZpdHkgc2hhcGVcclxuICBkcmF3VXNlQ2FzZVNoYXBlKHR5cGUpe1xyXG4gICAgLy9kcmF3IGNpcmNsZVxyXG4gICAgbGV0IGNpcmNsZVBhdGggPSBuZXcgUGF0aC5DaXJjbGUodGhpcy5jZW50ZXJQb3NpdGlvbiwgMjUpO1xyXG4gICAgY2lyY2xlUGF0aC5zY2FsZSgyLDEuMik7XHJcbiAgICBcclxuICAgIC8vc2NhbGUgdG8gbWFrZSBpdCBhbiBvdmFsXHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoY2lyY2xlUGF0aClcclxuXHJcbiAgICBpZih0eXBlID09PSBTSEFQRVMuVVNFQ0FTRSl7XHJcbiAgICAgIC8vYWRkIFRleHRcclxuICAgICAgY29uc3QgdGV4dFNoYXBlID0gdGhpcy5kcmF3VGV4dFNoYXBlKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMjUsIHRoaXMuY2VudGVyUG9zaXRpb24ueSs1KSwgdHlwZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvL2FkZCBDb21wb25lbnQgc2hhcGVcclxuICBkcmF3Q29tcG9uZW50U2hhcGUoKXtcclxuICAgIC8vZHJhdyBtYWluIHJlY3RhbmdsZVxyXG4gICAgY29uc3Qgc3RhcnRQb2ludCA9IG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtNTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yNSlcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IG5ldyBQYXRoLlJlY3RhbmdsZShzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSwgdGhpcy5kZWZhdWx0U2l6ZVswXSsyMCwgdGhpcy5kZWZhdWx0U2l6ZVswXS00NSk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwocmVjdGFuZ2xlKTtcclxuXHJcbiAgICAvLyBkcmF3IHN1YiBwYXJ0IG9mIHRoZSBzaGFwZVxyXG4gICAgY29uc3Qgc3ViUmVjdCA9IG5ldyBQYXRoLlJlY3RhbmdsZShyZWN0YW5nbGUuYm91bmRzLnRvcFJpZ2h0LngtMjUsIHN0YXJ0UG9pbnQueSs2LCAyMCwgMjUpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHN1YlJlY3QpO1xyXG4gICAgc3ViUmVjdC5zdHJva2VXaWR0aCA9IDIvdGhpcy5zdHJva2VXaWR0aDtcclxuXHJcbiAgICAvL2RyYXcgdHdvIHN1YiByZWNcclxuICAgIGNvbnN0IHN1YlJlY3QxID0gbmV3IFBhdGguUmVjdGFuZ2xlKHJlY3RhbmdsZS5ib3VuZHMudG9wUmlnaHQueC0yOCwgc3RhcnRQb2ludC55KzksIDcsIDcpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHN1YlJlY3QxKTtcclxuICAgIHN1YlJlY3QxLnN0cm9rZVdpZHRoID0gMi90aGlzLnN0cm9rZVdpZHRoO1xyXG5cclxuICAgIGNvbnN0IHN1YlJlY3QyID0gbmV3IFBhdGguUmVjdGFuZ2xlKHJlY3RhbmdsZS5ib3VuZHMudG9wUmlnaHQueC0yOCwgc3RhcnRQb2ludC55KzIwLCA3LCA3KTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChzdWJSZWN0Mik7XHJcbiAgICBzdWJSZWN0Mi5zdHJva2VXaWR0aCA9IDIvdGhpcy5zdHJva2VXaWR0aDtcclxuXHJcbiAgICAvL2NyZWF0ZSBncm91cCBhbmQgYWRkIHNoYXBlc1xyXG4gICAgbGV0IGdyb3VwID0gIG5ldyBHcm91cCgpO1xyXG5cclxuICAgIGdyb3VwLmFkZENoaWxkKHJlY3RhbmdsZSk7XHJcbiAgICBncm91cC5hZGRDaGlsZChzdWJSZWN0KTtcclxuICAgIGdyb3VwLmFkZENoaWxkKHN1YlJlY3QxKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKHN1YlJlY3QyKTtcclxuXHJcbiAgICAvL2FkZCB0ZXh0IHRvIHNoYXBlXHJcbiAgICBjb25zdCB0ZXh0U2hhcGUgPSB0aGlzLmRyYXdUZXh0U2hhcGUobmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueC0yNSwgdGhpcy5jZW50ZXJQb3NpdGlvbi55KzgpLCBTSEFQRVMuQ09NUE9ORU5UKTtcclxuICB9XHJcblxyXG4gIC8vYWRkIG1vZHVsZSBzaGFwZVxyXG4gIGRyYXdNb2R1bGVTaGFwZSgpe1xyXG4gICAgXHJcbiAgICAvLyBkcmF3IG1haW4gcmVjdFxyXG4gICAgY29uc3QgcmVjdGFuZ2xlID0gbmV3IFBhdGguUmVjdGFuZ2xlKHRoaXMuY2VudGVyUG9zaXRpb24ueC01MCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTUwLCB0aGlzLmRlZmF1bHRTaXplWzBdKzIwLCB0aGlzLmRlZmF1bHRTaXplWzBdLTQwKTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChyZWN0YW5nbGUpO1xyXG5cclxuICAgIC8vZHJhdyB0d28gc3ViIHJlY1xyXG4gICAgY29uc3Qgc3ViUmVjdDEgPSBuZXcgUGF0aC5SZWN0YW5nbGUocmVjdGFuZ2xlLmJvdW5kcy50b3BMZWZ0LngtNywgcmVjdGFuZ2xlLmJvdW5kcy50b3BMZWZ0LnkrMTIsIDE1LCAxMik7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoc3ViUmVjdDEpO1xyXG5cclxuICAgIGNvbnN0IHN1YlJlY3QyID0gbmV3IFBhdGguUmVjdGFuZ2xlKHJlY3RhbmdsZS5ib3VuZHMudG9wTGVmdC54LTcsIHJlY3RhbmdsZS5ib3VuZHMudG9wTGVmdC55KzM1LCAxNSwgMTIpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHN1YlJlY3QyKTtcclxuXHJcbiAgICAvL2NyZWF0ZSBncm91cCBhbmQgYWRkIHNoYXBlc1xyXG4gICAgbGV0IGdyb3VwID0gIG5ldyBHcm91cCgpO1xyXG5cclxuICAgIGdyb3VwLmFkZENoaWxkKHJlY3RhbmdsZSk7XHJcbiAgICBncm91cC5hZGRDaGlsZChzdWJSZWN0MSk7XHJcbiAgICBncm91cC5hZGRDaGlsZChzdWJSZWN0Mik7XHJcblxyXG4gICAgLy9hZGQgdGV4dCB0byBzaGFwZVxyXG4gICAgY29uc3QgdGV4dFNoYXBlID0gdGhpcy5kcmF3VGV4dFNoYXBlKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0xNSksIFNIQVBFUy5NT0RVTEUpO1xyXG4gIH1cclxuICBcclxuXHJcbiAgLy9hZGQgYWN0aXZpdHkgc2hhcGVcclxuICBkcmF3QWN0aXZpdHlTaGFwZSgpe1xyXG4gICAgLy9jcmVhdGUgcm91bmRlZCBzaGFwZSByZWN0YW5nbGVcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUodGhpcy5jZW50ZXJQb3NpdGlvbi5zdWJ0cmFjdCg1MCksIG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngrNzAsIHRoaXMuY2VudGVyUG9zaXRpb24ueSkpO1xyXG4gICAgY29uc3QgcmFkaXVzID0gbmV3IFNpemUoMzAsIDMwKTtcclxuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aC5SZWN0YW5nbGUocmVjdGFuZ2xlLCByYWRpdXMpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHBhdGgpO1xyXG5cclxuICAgIFxyXG4gICAgLy9hZGQgdGV4dCB0byBzaGFwZVxyXG4gICAgY29uc3QgdGV4dFNoYXBlID0gdGhpcy5kcmF3VGV4dFNoYXBlKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yMCksIFNIQVBFUy5BQ1RJVklUWSk7XHJcbiAgfVxyXG5cclxuICAvL2FkZCBkZWNpc2lvbiBzaGFwZVxyXG4gIGRyYXdEZWNpc2lvblNoYXBlKCl7XHJcbiAgICAvL2NyZWF0ZSByZWN0YW5nbGVcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IG5ldyBQYXRoLlJlY3RhbmdsZSh0aGlzLmNlbnRlclBvc2l0aW9uLngtMjAsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yMCwgdGhpcy5kZWZhdWx0U2l6ZVswXS8yLjUsIHRoaXMuZGVmYXVsdFNpemVbMF0vMi41KTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChyZWN0YW5nbGUpO1xyXG5cclxuICAgIC8vcm90YXRlXHJcbiAgICByZWN0YW5nbGUucm90YXRlKDQ1KTtcclxuICB9XHJcblxyXG4gIC8vb24gdG9vbCBjbGlja1xyXG4gIG9uVG9vbE1vdXNlRG93bihlKXtcclxuICAgIC8vdG9nZ2xlIGl0ZW0gc2VsZWN0ZWRcclxuICAgIHRoaXMuc2V0T25lSXRlbVNlbGVjdGVkKGUpO1xyXG5cclxuICAgIC8vcmV0dXJuIGlmIG5vIGN1cnJlbnRBY3RpdmVJdGVtXHJcbiAgICBpZighdGhpcy5jdXJyZW50QWN0aXZlSXRlbSkgcmV0dXJuO1xyXG5cclxuICAgIC8vY2xlYXJpbmcgY3VycmVudEFjdGl2ZUl0ZW0gZGF0YSB0byBmaXggdGhlIGlzc3VlIG9mIHVuaW50ZW5kZWQgbW92ZXNcclxuICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5zdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgaWYodGhpcy5jdXJyZW50QWN0aXZlSXRlbS5jb250YWlucyhlLnBvaW50KSl7XHJcbiAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5zdGF0ZSA9ICdtb3ZlJ1xyXG4gICAgfVxyXG4gICAgLy9zZXQgaXRlbXMgZGF0YSBiYXNlZCBvbiBpdGVtIG1vdXNlRG93biBwb2ludFxyXG4gICAgaWYodGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnR5cGUgIT09IExJTkUpe1xyXG4gICAgICBpZih0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmhpdFRlc3QoZS5wb2ludCwge2JvdW5kczogdHJ1ZSwgdG9sZXJhbmNlOiA1fSkpe1xyXG4gICAgICAgIC8vZ2V0IGJvdW5kcyBvZiB0aGUgc2hhcGVcclxuICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmJvdW5kcztcclxuXHJcblxyXG4gICAgICAgIC8vaXRyYXRpbmcgdG8gZmluZCB0aGUgZXhhY3QgYm91bmQgcG9pbnRcclxuICAgICAgICBmb3IobGV0W2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGJvdW5kc0lkZW50aWZpZXJPYmopKXtcclxuICAgICAgICAgIGlmKGJvdW5kc1t2YWx1ZV0uaXNDbG9zZShlLnBvaW50LCA1KSl7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wcG9zaXRlQm91bmQgPSBib3VuZHNbYm91bmRzSWRlbnRpZmllck9ialsocGFyc2VJbnQoa2V5KSArIDIpICUgNF1dO1xyXG4gICAgICAgICAgICAvL2dldCBvcHBvc2l0ZSBib3VuZCBwb2ludFxyXG4gICAgICAgICAgICBjb25zdCBvcHBvc2l0ZVBvaW50ID0gbmV3IFBvaW50KG9wcG9zaXRlQm91bmQueCxvcHBvc2l0ZUJvdW5kLnkpO1xyXG4gICAgICAgICAgICAvL2dldCBjdXJyZW50IGJvdW5kIHBvaW50XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlclBvaW50ID0gbmV3IFBvaW50KGJvdW5kc1t2YWx1ZV0ueCwgYm91bmRzW3ZhbHVlXS55KTtcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IHNoYXBlIGRhdGEgdG8gYmUgdXNlZCBmb3IgcmVzaXppbmcgbGF0ZXJcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnN0YXRlID0gJ3Jlc2l6ZSdcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLmZyb20gPSBvcHBvc2l0ZVBvaW50O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEudG8gPSBjZW50ZXJQb2ludDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvL29ubHkgZm9yIHNoYXBlcyB3aXRoIHR5cGUgTElORVxyXG4gICAgICBjb25zdCBoZWFkQ2lyY2xlSXRlbSA9IHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZmlyc3RDaGlsZC5jaGlsZHJlblszXTtcclxuICAgICAgaWYoaGVhZENpcmNsZUl0ZW0uY29udGFpbnMoZS5wb2ludCkpe1xyXG4gICAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5zdGF0ZSA9ICdyZXNpemUnXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vZHJhdyBhY3RvciBzaGFwZVxyXG4gIGRyYXdBY3RvclNoYXBlKCl7XHJcbiAgICAvL2RyYXcgYWN0b3IgaGVhZFxyXG4gICAgY29uc3QgaGVhZCA9IG5ldyBQYXRoLkNpcmNsZShuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LCB0aGlzLmNlbnRlclBvc2l0aW9uLnktNTApLCA3KTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChoZWFkKVxyXG5cclxuICAgIC8vZHJhdyBhY3RvciBib2R5XHJcbiAgICBjb25zdCBib2R5ID0gbmV3IFBhdGguTGluZShuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LCB0aGlzLmNlbnRlclBvc2l0aW9uLnktNDMpLCBuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LCB0aGlzLmNlbnRlclBvc2l0aW9uLnktMTApKTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChib2R5KVxyXG5cclxuICAgIC8vZHJhdyBhY3RvciBhcm1zXHJcbiAgICBjb25zdCBhcm1zID0gbmV3IFBhdGguTGluZShuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LTIwLCB0aGlzLmNlbnRlclBvc2l0aW9uLnktMzgpLCBuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54KzIwLCB0aGlzLmNlbnRlclBvc2l0aW9uLnktMzgpKTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChhcm1zKSBcclxuXHJcbiAgICAvL2RyYXcgZmVldFxyXG4gICAgY29uc3QgbGVmdEZlZXQgPSBuZXcgUGF0aC5MaW5lKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMjAsIHRoaXMuY2VudGVyUG9zaXRpb24ueSs1KSwgbmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTEwKSk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwobGVmdEZlZXQpIFxyXG5cclxuICAgIGNvbnN0IHJpZ2h0RmVldCA9IG5ldyBQYXRoLkxpbmUobmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTEwKSwgbmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueCsyMCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55KzUpKTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChyaWdodEZlZXQpIFxyXG5cclxuICAgIC8vYWRkIHNoYXBlcyB0byBncm91cCB0byBtYWtlIGZ1bGwgYWN0b3JcclxuICAgIGxldCBncm91cCA9ICBuZXcgR3JvdXAoKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKGhlYWQpO1xyXG4gICAgZ3JvdXAuYWRkQ2hpbGQoYm9keSk7XHJcbiAgICBncm91cC5hZGRDaGlsZChhcm1zKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKGxlZnRGZWV0KTtcclxuICAgIGdyb3VwLmFkZENoaWxkKHJpZ2h0RmVldCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy9pdGVtIGRyYWcgbGlzdGVuZXJcclxuICBvblRvb2xEcmFnKGUpe1xyXG4gICAgLy8gZGVidWdnZXJcclxuICAgIGlmKHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0gPT0gbnVsbCkgcmV0dXJuO1xyXG5cclxuICAgIGlmKHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5zdGF0ZSA9PT0gJ21vdmUnKXtcclxuICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5wb3NpdGlvbiA9IGUucG9pbnQ7ICBcclxuICAgICAgXHJcbiAgICAgIC8vY2hlY2sgaWYgdGhlIHNoYXBlIGhhcyBhbnkgYXR0YWNoZWQgbGluZXNcclxuICAgICAgaWYodGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLmxpbmVTaGFwZSl7XHJcbiAgICAgICAgY29uc3QgbGluZVNoYXBlT2JqZWN0ID0gdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLmxpbmVTaGFwZTtcclxuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobGluZVNoYXBlT2JqZWN0KSkge1xyXG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IHZhbHVlWzFdO1xyXG4gICAgICAgICAgY29uc3QgbGluZVN0YXJ0UG9pbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQuZmlyc3RDaGlsZC5zZWdtZW50c1swXS5wb2ludDtcclxuICAgICAgICAgIGNvbnN0IGxpbmVUeXBlID0gZWxlbWVudC5kYXRhLmxpbmVUeXBlO1xyXG4gICAgICAgICAgY29uc3QgbGluZUlkID0gZWxlbWVudC5kYXRhLmxpbmVJZDtcclxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmRyYXdMaW5lU2hhcGUobGluZVN0YXJ0UG9pbnQsIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uYm91bmRzW3ZhbHVlWzBdXSwgbGluZVR5cGUpO1xyXG4gICAgICAgICBlbGVtZW50LmRhdGEubGluZUlkID0gbGluZUlkOyBcclxuICAgICAgICAgbGluZVNoYXBlT2JqZWN0W2tleV0gPSBbdmFsdWVbMF0sIGVsZW1lbnRdXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2VcclxuICAgIGlmKHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5zdGF0ZSA9PT0gJ3Jlc2l6ZScpe1xyXG4gICAgICBpZih0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEudHlwZSA9PT0gTElORSl7XHJcbiAgICAgICAgLy9zaGFwZXMgd2l0aCB0eXBlIGxpbmUsIHJlLXJlbmRlcmluZyBsaW5lIG9uIGVhY2ggdXNlciBtb3ZlXHJcbiAgICAgICAgdGhpcy5yZVJlbmRlckxpbmUoZS5wb2ludCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jaGVja0xpbmVBdHRhY2htZW50KGUpO1xyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICAvL3NoYXBlcyBvdGhlciB0aGFuIGxpbmUsIHVwZGF0aW5nIHRoZSBib3VuZHNcclxuICAgICAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoXHJcbiAgICAgICAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEuZnJvbSxlLnBvaW50KTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmJvdW5kcy5zZWxlY3RlZCA9IHRydWVcclxuICAgIH0gXHJcbiAgfVxyXG5cclxuICByZVJlbmRlckxpbmUoaGVhZFBvc2l0aW9uKXtcclxuICAgIGNvbnN0IGxpbmVTdGFydFBvaW50ID0gdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5maXJzdENoaWxkLmZpcnN0Q2hpbGQuc2VnbWVudHNbMF0ucG9pbnQ7XHJcbiAgICBjb25zdCBsaW5lVHlwZSA9IHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5saW5lVHlwZTtcclxuICAgIGNvbnN0IGxpbmVJZCA9IHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5saW5lSWQ7XHJcbiAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLnJlbW92ZSgpO1xyXG4gICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbSA9ICB0aGlzLmRyYXdMaW5lU2hhcGUobGluZVN0YXJ0UG9pbnQsIGhlYWRQb3NpdGlvbiwgbGluZVR5cGUpO1xyXG4gICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnN0YXRlID0gJ3Jlc2l6ZSdcclxuICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5saW5lSWQgPSBsaW5lSWQ7XHJcbiAgfVxyXG5cclxuICAvLyBhdHRhY2ggbGluZSB0byBzaGFwZXNcclxuICBjaGVja0xpbmVBdHRhY2htZW50KGV2ZW50KSB7XHJcbiAgICAvL2l0ZXJhdGV0aG91Z2ggZWFjaCBlbGVtZW50IHRvIGZpbmQgdGhlIGludHJlc2VjdGluZyBzaGFwZVxyXG4gICAgdGhpcy5wcm9qZWN0LmFjdGl2ZUxheWVyLmNoaWxkcmVuLmZvckVhY2goY2hpbGQ9PntcclxuICAgICAgLy8gZmluZCB0aGUgc2hhcGVzIHRoYXQgbGluZSBpbnRlcnNlY3RlZCB3aXRoXHJcbiAgICAgIGlmKGNoaWxkICE9IHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0gJiYgY2hpbGQuaGl0VGVzdChldmVudC5wb2ludCwge2JvdW5kczogdHJ1ZSwgdG9sZXJhbmNlOiA1fSkpe1xyXG4gICAgICAgIC8vYWRkIGxpbmUgdG8gYXR0YWNoZWQgc2hhcGVzXHJcblxyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGNoaWxkLmJvdW5kcztcclxuICAgICAgICAvL2l0cmF0aW5nIHRvIGZpbmQgdGhlIGV4YWN0IGJvdW5kIHBvaW50XHJcbiAgICAgICAgZm9yKGxldFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhib3VuZHNDZW50ZXJJZGVudGlmaWVyT2JqKSl7XHJcbiAgICAgICAgICBpZihib3VuZHNbdmFsdWVdLmlzQ2xvc2UoZXZlbnQucG9pbnQsIDUpKXtcclxuICAgICAgICAgICAgLy9nZXQgY2VudGVyIGJvdW5kIHBvaW50IG9mIHRoZSBzaWRlIGxpbmUgdG91Y2hlc1xyXG4gICAgICAgICAgICBjb25zdCBjZW50ZXJQb2ludCA9IG5ldyBQb2ludChib3VuZHNbdmFsdWVdLngsIGJvdW5kc1t2YWx1ZV0ueSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVSZW5kZXJMaW5lKGNlbnRlclBvaW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IGRhdGEgdG8gc2hhcGUgdG8gYWxsb3cgc2hhcGUgdG8gbW92ZSBsaW5lIGhlYWQgd2l0aCBpdCBhcyBpdCBpcyBkcmFnZ2VkXHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbGluZVNoYXBlIGFscmVhZHkgZXhpc3RzXHJcbiAgICAgICAgICAgIGlmKCFjaGlsZC5kYXRhLmxpbmVTaGFwZSkge1xyXG4gICAgICAgICAgICAgIGNoaWxkLmRhdGEubGluZVNoYXBlID0ge31cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gYWRkIGxpbmUgY3VycmVudEFjdGl2ZSBMaW5lIFNoYXBlIGFuZCBhbHNvIHRoZSBzaWRlIGl0IGlzIGF0dGFjaGVkIHdpdGhcclxuICAgICAgICAgICAgY2hpbGQuZGF0YS5saW5lU2hhcGVbdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLmxpbmVJZF0gPSBbdmFsdWUsIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW1dO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9yZW1vdmUgbGluZSBhdHRhY2hlbWVudCB3aXRoIHNoYXBlc1xyXG4gICAgICAgIGlmKGNoaWxkLmRhdGEubGluZVNoYXBlKXtcclxuICAgICAgICAgIGRlbGV0ZSBjaGlsZC5kYXRhLmxpbmVTaGFwZVt0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEubGluZUlkXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICAvL29uIHRvb2wgZG91YmxlIGNsaWNrXHJcbiAgb25Ub29sRG91YmxlQ2xpY2soZSl7XHJcbiAgICBpZihlLmN0cmxLZXkpIHtcclxuICAgICAgdGhpcy5kcmF3VGV4dFNoYXBlKHt4OiBlLmxheWVyWCwgeTogZS5sYXllcll9LCBcIkFkZCBUZXh0XCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgXHJcblxyXG4gIC8vdG9nZ2xlIGl0ZW0gc2VsZWN0ZWlvbiBhbmQgc2F2aW5nIGN1cnJlbnRBY3RpdmVJdGVtXHJcbiAgc2V0T25lSXRlbVNlbGVjdGVkKGUpe1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSBlLnBvaW50O1xyXG4gICAgbGV0IGNsaWNrZWRJdGVtcyA9IFtdXHJcbiAgICB0aGlzLnByb2plY3QuYWN0aXZlTGF5ZXIuY2hpbGRyZW4uZm9yRWFjaChjaGlsZD0+e1xyXG4gICAgICBpZihjaGlsZC5jb250YWlucyhwb3NpdGlvbikpe1xyXG4gICAgICAgIGNsaWNrZWRJdGVtcy5wdXNoKGNoaWxkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGlsZC5ib3VuZHMuc2VsZWN0ZWQgPSAgZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICAvL3JldHVybiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkXHJcbiAgICBpZihjbGlja2VkSXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgLy9zZWxlY3QgdGhlIGNsaWNrZWQgaXRlbVxyXG4gICAgbGV0IGxhdGVzdEl0ZW0gPSBjbGlja2VkSXRlbXNbMF07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaWNrZWRJdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZihsYXRlc3RJdGVtLmlkIDwgY2xpY2tlZEl0ZW1zW2ldLmlkKXtcclxuICAgICAgICBsYXRlc3RJdGVtID0gY2xpY2tlZEl0ZW1zW2ldO1xyXG4gICAgICB9ZWxzZVxyXG4gICAgICB7XHJcbiAgICAgICAgY2xpY2tlZEl0ZW1zW2ldLmJvdW5kcy5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtID0gbGF0ZXN0SXRlbTtcclxuICAgIGxhdGVzdEl0ZW0uYm91bmRzLnNlbGVjdGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG5cclxuICAvLyBrZXlib2FyZCBpbnRyYWN0aW9uIHRvIG1vdmUgc2hhcGVzXHJcbiAgb25Ub29sS2V5RG93bihlKXtcclxuICAgIGlmKCF0aGlzLmN1cnJlbnRBY3RpdmVJdGVtKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLnBvc2l0aW9uO1xyXG4gICAgY29uc3Qgc3RlcCA9IDU7XHJcbiAgICBzd2l0Y2goZS5rZXkpe1xyXG4gICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICBwb3NpdGlvbi54IC09IHN0ZXA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICBwb3NpdGlvbi54ICs9IHN0ZXA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3VwJzpcclxuICAgICAgICBwb3NpdGlvbi55IC09IHN0ZXA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2Rvd24nOlxyXG4gICAgICAgIHBvc2l0aW9uLnkgKz0gc3RlcDtcclxuICAgICAgICBicmVhazsgXHJcbiAgICAgIGNhc2UgJ2RlbGV0ZSc6XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5yZW1vdmUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0ucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICB9XHJcblxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGdlbmVyYWwgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIHJldHVybiBjZW50ZXIgcG9zaXRpb24gb2YgY2FudmFzXHJcbiAgZ2V0Q2VudGVyUG9zaXRpb24oKXtcclxuICAgIHJldHVybiBuZXcgUG9pbnQoe3g6IHRoaXMuY2FudmFzRWxlbWVudC5jbGllbnRXaWR0aC8yLCB5OnRoaXMuY2FudmFzRWxlbWVudC5jbGllbnRIZWlnaHQvMn0pO1xyXG4gIH1cclxuXHJcbiAgLy8gaGVscGVyIHRvIHNldCBzdHJva2UgYW5kIGZpbGxcclxuICBzZXRTdHJva2VBbmRGaWxsKGl0ZW0pe1xyXG4gICAgaXRlbS5zdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XHJcbiAgICBpdGVtLnN0cm9rZUNvbG9yID0gdGhpcy5zdHJva2VDb2xvcjtcclxuICAgIGl0ZW0uZmlsbENvbG9yID0gdGhpcy5maWxsQ29sb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNeUNhbnZhcztcclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mb3tcclxuICAgIGNvbnN0cnVjdG9yKHRpdGxlLCB0ZXh0KXtcclxuICAgICAgICB0aGlzLnRpdGxlID0gIHRpdGxlO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcblxyXG4gICAgICAgIHRoaXMuc2hvdyA9IHRoaXMuc2hvdy5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLnNob3coKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc2hvdygpe1xyXG4gICAgICAgIC8vc2V0IHVwIGluZm8gdmlld1xyXG4gICAgICAgIGNvbnN0IGluZm9TZWN0aW9uQ29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbmZvLXNpZGViYXInKTtcclxuICAgICAgICBjb25zdCB0b3BCYXJDb25hdGluZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdG9wQmFyQ29uYXRpbmVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3RvcC1iYXItY29udGFpbmVyJyk7XHJcbiAgICAgICAgY29uc3QgdGl0bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcclxuICAgICAgICB0aXRsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdpbmZvLXRpdGxlJylcclxuICAgICAgICB0aXRsZUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy50aXRsZTtcclxuICAgICAgICBjb25zdCBjbG9zZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgY2xvc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnaW5mby1jbG9zZScpO1xyXG4gICAgICAgIGNsb3NlRWxlbWVudC5pbm5lckhUTUwgPSAnWCc7XHJcbiAgICAgICAgdG9wQmFyQ29uYXRpbmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aXRsZUVsZW1lbnQpO1xyXG4gICAgICAgIHRvcEJhckNvbmF0aW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoY2xvc2VFbGVtZW50KTtcclxuICAgICAgICBjb25zdCBib2R5RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGJvZHlFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnaW5mby1ib2R5Jyk7XHJcbiAgICAgICAgYm9keUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy50ZXh0O1xyXG4gICAgICAgIGluZm9TZWN0aW9uQ29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0b3BCYXJDb25hdGluZXJFbGVtZW50KTtcclxuICAgICAgICBpbmZvU2VjdGlvbkNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoYm9keUVsZW1lbnQpO1xyXG5cclxuXHJcbiAgICAgICAgLy9zZXQgdXAgbGlzdGVuZXJcclxuICAgICAgICBjbG9zZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGluZm9TZWN0aW9uQ29udGFpbmVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2hpZGRlbicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiZXhwb3J0IGNvbnN0IG1lc3NhZ2UgPSBcIjxwPiAtIENsaWNrIGFueSBzaGFwZSBmcm9tIHRoZSBVTUwgc2VjdGlvbiB0byBhZGQgaXQgdG8gdGhlIGNhbnZhcy48YnIvPiA8L3A+XCIrXHJcblwiPHA+IC0gVGhlbiBzZWxlY3QgYSBzaGFwZSBhbmQgZHJhZyBpdCBmb3JtIGFueSBjb3JuZXIgdG8gcmVzaXplLjxici8+IDwvcD5cIitcclxuXCI8cD4gLSBZb3UgY2FuIGFsc28gbW92ZSBhIHNoYXBlIHdpdGggYXJyb3cga2V5cyBmb3JtIHRoZSBrZXlib2FyZC48YnIvPiA8L3A+XCIrXHJcblwiPHA+IC0gU2VsZWN0IGFueSBsaW5lIHNoYXBlIGFuZCB1c2UgbWlkZGxlIGNpcmNsZSB0byBtb3ZlIHRoZSBsaW5lIGFyb3VuZCBhbmQgdGhlIGhlYWQgY2lyY2xlIHRvIHJvdGF0ZSBpdCBhdCBkaWZmZXJlbnQgYW5nbGVzLjxici8+IDwvcD5cIitcclxuXCI8cD4gLSBEcmFnIGxpbmUgaGVhZCB0byBtaWRkbGUgb2YgZWl0aGVyIHNpZGUgb2YgdGhlIHNoYXBlIHRvIGF0dGFjaCBpdCBhbmQgbW92ZSBpdCBhd2F5IHRvIGRldGFjaCBpdC48YnIvPiA8L3A+XCIrXHJcblwiPHA+IC0gU2VsZWN0IGEgc2hhcGUgYW5kIHByZXNzICdkZWxldGUnIGtleSB0byBkZWxldGUgdGhlIHNoYXBlLjxici8+IDwvcD5cIitcclxuXCI8cD4gLSBQcmVzcyAnQ3RybCArIE1vdXNlIERvdWJsZSBDbGljaycgdG8gYWRkIHRleHQuPGJyLz4gPC9wPlwiK1xyXG5cIjxwPiAtIFVzZSAnTW92ZS1Uby1Gcm9udCcgYW5kICdTZW5kLVRvLUJhY2snIGljb24gdG8gbW92ZSB0aGUgc2hhcGVzLjxici8+IDwvcD5cIitcclxuXCI8cD4gLSBGb3Igc2F2aW5nIGFuZCBvcGVuaW5nIGV4aXNpdGluZyBwcm9qZWN0IHV0aWxpemUgdGhlIG1lbnUgYmFyLjxici8+IDwvcD5cIjsiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0Q2FsbGJhY2spe1xyXG4gICAgICAgIHRoaXMudGV4dENhbGxiYWNrID0gdGV4dENhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuc2hvdyA9IHRoaXMuc2hvdy5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHNob3coKXtcclxuICAgICAgICBjb25zdCBib2R5RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib2R5Jyk7XHJcbiAgICAgICAgY29uc3QgbW9kYWxNYWluQ29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIG1vZGFsTWFpbkNvbnRhaW5lckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsJ21vZGFsLW1haW4tY29udGFpbmVyJylcclxuICAgICAgICBjb25zdCBtb2RhbENvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBtb2RhbENvbnRhaW5lckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsJ21vZGFsLWNvbnRhaW5lcicpXHJcbiAgICAgICAgY29uc3QgbW9kYWxUaXRsZUNvbmFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIG1vZGFsVGl0bGVDb25haW5lckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsJ21vZGFsLXRpdGxlLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIGNvbnN0IG1vZGFsVGl0bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcclxuICAgICAgICBtb2RhbFRpdGxlRWxlbWVudC5pbm5lckhUTUwgPSBcIkFkZCBUZXh0XCJcclxuICAgICAgICBtb2RhbFRpdGxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywnbW9kYWwtdGl0bGUnKTtcclxuICAgICAgICBjb25zdCBtb2RhbENsb3NlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICBtb2RhbENsb3NlRWxlbWVudC5pbm5lckhUTUwgPSBcIlhcIlxyXG4gICAgICAgIG1vZGFsQ2xvc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdtb2RhbC1jbG9zZScpO1xyXG4gICAgICAgIGNvbnN0IG1vZGFsSW5wdXRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgICAgICBtb2RhbElucHV0RWxlbWVudC5wbGFjZWhvbGRlciA9IFwiQWRkIHRleHQgaGVyZVwiXHJcbiAgICAgICAgbW9kYWxJbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsJ21vZGFsLWlucHV0Jyk7XHJcbiAgICAgICAgY29uc3QgbW9kYWxTdWJtaXRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICAgICAgbW9kYWxTdWJtaXRFbGVtZW50LmlubmVySFRNTCA9IFwiU3VibWl0XCJcclxuICAgICAgICBtb2RhbFN1Ym1pdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsJ21vZGFsLXN1Ym1pdCcpO1xyXG5cclxuICAgICAgICBtb2RhbFRpdGxlQ29uYWluZXJFbGVtZW50LmFwcGVuZENoaWxkKG1vZGFsVGl0bGVFbGVtZW50KTtcclxuICAgICAgICBtb2RhbFRpdGxlQ29uYWluZXJFbGVtZW50LmFwcGVuZENoaWxkKG1vZGFsQ2xvc2VFbGVtZW50KTtcclxuICAgICAgICBtb2RhbENvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQobW9kYWxUaXRsZUNvbmFpbmVyRWxlbWVudCk7XHJcbiAgICAgICAgbW9kYWxDb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKG1vZGFsSW5wdXRFbGVtZW50KTtcclxuICAgICAgICBtb2RhbENvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQobW9kYWxTdWJtaXRFbGVtZW50KTtcclxuICAgICAgICBtb2RhbE1haW5Db250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKG1vZGFsQ29udGFpbmVyRWxlbWVudCk7XHJcbiAgICAgICAgYm9keUVsZW1lbnQuYXBwZW5kQ2hpbGQobW9kYWxNYWluQ29udGFpbmVyRWxlbWVudCk7XHJcblxyXG4gICAgICAgIC8vYWRkcyBsaXN0ZW5lcnNcclxuXHJcbiAgICAgICAgLy9jbG9zZSBtb2RhbCBvbiBvdXRzaWRlIGNsaWNrXHJcbiAgICAgICAgbW9kYWxNYWluQ29udGFpbmVyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKT0+e1xyXG4gICAgICAgICAgICBtb2RhbE1haW5Db250YWluZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdoaWRkZGVuJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vc3RvcHMgbW9kYWwgZnJvbSBjbG9zaW5nIGlmIGNsaWNrZWQgaW5zaWRlIG1vZGFsXHJcbiAgICAgICAgbW9kYWxDb250YWluZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywoZSk9PntcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vY2xvc2VzIG1vZGFsIG9uIGNsaWNrXHJcbiAgICAgICAgbW9kYWxDbG9zZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSk9PntcclxuICAgICAgICAgICAgbW9kYWxNYWluQ29udGFpbmVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywnaGlkZGRlbicpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL2dldHMgdGV4dCBmb3JtIGlucHV0IG9uIHN1Ym1pdCBhbmQgc2VuZGluZyB0byBjYWxsYmFja1xyXG4gICAgICAgIG1vZGFsU3VibWl0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsKGUpPT57XHJcbiAgICAgICAgICAgIGNvbnN0IGlucHV0VGV4dCA9IG1vZGFsSW5wdXRFbGVtZW50LnZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRleHRDYWxsYmFjayhpbnB1dFRleHQpO1xyXG4gICAgICAgICAgICBtb2RhbE1haW5Db250YWluZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdoaWRkZGVuJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTaWRlYmFye1xyXG4gICAgY29uc3RydWN0b3IoY2F0ZWdvcnlPYmosIHNpZGViYXJFbGVtZW50LCBvblNoYXBlQ2xpY2tDYWxsYmFjayl7XHJcbiAgICAgICAgdGhpcy5jYXRlZ29yeVRpdGxlID0gY2F0ZWdvcnlPYmouY2F0ZWdvcnlOYW1lO1xyXG4gICAgICAgIHRoaXMuc2hhcGVzID0gY2F0ZWdvcnlPYmouc2hhcGVzO1xyXG4gICAgICAgIHRoaXMuc2lkZWJhckVsZW1lbnQgPSBzaWRlYmFyRWxlbWVudDtcclxuICAgICAgICB0aGlzLm9uU2hhcGVDbGlja0NhbGxiYWNrID0gb25TaGFwZUNsaWNrQ2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5kcmF3KCk7XHJcbiAgICAgICAgdGhpcy5zaGFwZUNsaWNrTGlzdGVuZXIgPSB0aGlzLnNoYXBlQ2xpY2tMaXN0ZW5lci5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHNoYXBlQ2xpY2tMaXN0ZW5lcihzaGFwZU5hbWUpe1xyXG4gICAgICAgIHJldHVybiBlPT57XHJcbiAgICAgICAgICAgIHRoaXMub25TaGFwZUNsaWNrQ2FsbGJhY2soc2hhcGVOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZHJhdygpe1xyXG4gICAgICAgIC8vYWRkcyBjYXRlZ29yeSB0aXRsZSBpbiBzaWRlYmFyXHJcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlUaXRsZUVsZW1lbnQgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcclxuICAgICAgICBjYXRlZ29yeVRpdGxlRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLmNhdGVnb3J5VGl0bGU7XHJcbiAgICAgICAgY2F0ZWdvcnlUaXRsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdzaWRlYmFyLWNhdGVnb3J5LXRpdGxlJyk7XHJcbiAgICAgICAgdGhpcy5zaWRlYmFyRWxlbWVudC5hcHBlbmRDaGlsZChjYXRlZ29yeVRpdGxlRWxlbWVudCk7XHJcblxyXG4gICAgICAgIC8vYWRkcyBjYXRlZ29yeSBzaGFwZXMgaW4gc2lkZWJhclxyXG4gICAgICAgIGNvbnN0IHNoYXBlc1VsRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XHJcbiAgICAgICAgc2hhcGVzVWxFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBcInNpZGViYXItY2F0ZWdvcnktc2hhcGVzLXVsXCIpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNoYXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBzaGFwZUxpRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XHJcbiAgICAgICAgICAgIHNoYXBlTGlFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBcInNpZGViYXItY2F0ZWdvcnktc2hhcGVzLWxpXCIpXHJcbiAgICAgICAgICAgIHNoYXBlTGlFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnNoYXBlQ2xpY2tMaXN0ZW5lcihzaGFwZS5uYW1lKSlcclxuICAgICAgICAgICAgY29uc3Qgc2hhcGVJbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICAgICAgICAgICAgc2hhcGVJbWFnZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsXCJzaWRlYmFyLWNhdGVnb3J5LWltYWdlc1wiKVxyXG4gICAgICAgICAgICBzaGFwZUltYWdlRWxlbWVudC5zcmMgPSBzaGFwZS51cmk7XHJcbiAgICAgICAgICAgIHNoYXBlTGlFbGVtZW50LmFwcGVuZENoaWxkKHNoYXBlSW1hZ2VFbGVtZW50KTtcclxuICAgICAgICAgICAgc2hhcGVzVWxFbGVtZW50LmFwcGVuZENoaWxkKHNoYXBlTGlFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zaWRlYmFyRWxlbWVudC5hcHBlbmRDaGlsZChzaGFwZXNVbEVsZW1lbnQpO1xyXG5cclxuICAgIH1cclxufSIsImV4cG9ydCBjb25zdCBTSEFQRVMgPSB7XHJcbiAgICBDTEFTUzogJ0NsYXNzJyxcclxuICAgIFNRVUFSRTogJ1NxdWFyZScsXHJcbiAgICBESVZJREVSOiAnRGl2aWRlcicsXHJcbiAgICBDSVJDTEU6ICdDaXJjbGUnLFxyXG4gICAgT0JKRUNUOiAnT2JqZWN0JyxcclxuICAgIElOVEVSRkFDRTogJ0ludGVyZmFjZScsXHJcbiAgICBBQ1RPUjogJ0FjdG9yJyxcclxuICAgIEFHR1JFR0FUSU9OOiAnQWdncmVnYXRpb24nLFxyXG4gICAgQ09NUE9TSVRJT046ICdDb21wb3NpdGlvbicsXHJcbiAgICBBU1NPQ0lBVElPTjogJ0Fzc29jaWF0aW9uJyxcclxuICAgIENPTVBPTkVOVDogJ0NvbXBvbmVudCcsXHJcbiAgICBNT0RVTEU6ICdNb2R1bGUnLFxyXG4gICAgVElUTEU6ICdUaXRsZScsXHJcbiAgICBBQ1RJVklUWTogJ0FjdGl2aXR5JyxcclxuICAgIFVTRUNBU0U6ICdVc2UgQ2FzZScsXHJcbiAgICBERUNJU0lPTjogJ0RlY2lzaW9uJ1xyXG59IiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XHJcblxyXG5jb25zdCBzaWRlYmFyRGF0YSA9ICBbXHJcbiB7XHJcbiAgICAgY2F0ZWdvcnlOYW1lOiBcIlVNTFwiLFxyXG4gICAgIHNoYXBlczpbXHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvb2JqZWN0LnN2ZydcclxuICAgICAgICAgfSxcclxuICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuSU5URVJGQUNFLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvaW50ZXJmYWNlLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLkNMQVNTLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvY2xhc3Muc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuRElWSURFUixcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2RpdmlkZXIuc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuVElUTEUsXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy90aXRsZS5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5DT01QT05FTlQsXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9jb21wb25lbnQuc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuTU9EVUxFLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvbW9kdWxlLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLkFDVE9SLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvYWN0b3Iuc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuVVNFQ0FTRSxcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL3VzZXJjYXNlLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLkFDVElWSVRZLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvYWN0aXZpdHkuc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuREVDSVNJT04sXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9kZWNpc2lvbi5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5BR0dSRUdBVElPTixcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2FnZ3JlZ2F0aW9uLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLkNPTVBPU0lUSU9OLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvY29tcG9zaXRpb24uc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuQVNTT0NJQVRJT04sXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9hc3NvY2lhdGlvbi5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5DSVJDTEUsXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9jaXJjbGUuc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuU1FVQVJFLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvc3F1YXJlLnN2ZydcclxuICAgICAgICB9XHJcbiAgICAgXVxyXG4gfSAgIFxyXG5dXHJcblxyXG5leHBvcnQgZGVmYXVsdCBzaWRlYmFyRGF0YTsiLCJleHBvcnQgZnVuY3Rpb24gZ2V0QW5nbGVEZWcoZXgsZXksY3gsY3kpIHtcclxuICB2YXIgZHkgPSBleSAtIGN5O1xyXG4gIHZhciBkeCA9IGV4IC0gY3g7XHJcbiAgdmFyIHRoZXRhID0gTWF0aC5hdGFuMihkeSwgZHgpO1xyXG4gIHRoZXRhICo9IDE4MCAvIE1hdGguUEk7IFxyXG4gIHJldHVybiB0aGV0YTtcclxufSIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=