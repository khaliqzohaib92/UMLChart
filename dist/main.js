/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/acorn/dist/acorn.mjs":
/*!*******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.mjs ***!
  \*******************************************/
/*! exports provided: Node, Parser, Position, SourceLocation, TokContext, Token, TokenType, defaultOptions, getLineInfo, isIdentifierChar, isIdentifierStart, isNewLine, keywordTypes, lineBreak, lineBreakG, nonASCIIwhitespace, parse, parseExpressionAt, tokContexts, tokTypes, tokenizer, version */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SourceLocation", function() { return SourceLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokContext", function() { return TokContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOptions", function() { return defaultOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineInfo", function() { return getLineInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierChar", function() { return isIdentifierChar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierStart", function() { return isIdentifierStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNewLine", function() { return isNewLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keywordTypes", function() { return keywords$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreak", function() { return lineBreak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreakG", function() { return lineBreakG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonASCIIwhitespace", function() { return nonASCIIwhitespace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseExpressionAt", function() { return parseExpressionAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokContexts", function() { return types$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokTypes", function() { return types; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenizer", function() { return tokenizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 9.
  ecmaVersion: 9,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
pp.strictDirective = function(start) {
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") { return true }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // '['
  if (context) { return false }

  if (nextCh === 123) { return true } // '{'
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (this.options.ecmaVersion > 10 && starttype === types._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40) // '('
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope, node) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (!this.eat(types.braceR)) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  } else if (init.type === "AssignmentPattern") {
    this.raise(init.start, "Invalid left-hand side in for-loop");
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      }
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  this.strict = oldStrict;
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassElement = function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
      key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    method.kind = "constructor";
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, "getter should have no params"); }
  if (method.kind === "set" && method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && method.value.params[0].type === "RestElement")
    { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, "MethodDefinition")
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
    this.expectContextual("from");
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseIdent(true);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    this.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types.comma); }
    if (allowEmpty && this.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (bindingType === BIND_LEXICAL && expr.name === "let")
      { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, "Argument name clash"); }
      checkClashes[expr.name] = true;
    }
    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    break

  case "MemberExpression":
    if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1)
      {
    var prop = list[i];

    this.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(noIn) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldShorthandAssign = refDestructuringErrors.shorthandAssign;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
    if (element === base || element.type === "ArrowFunctionExpression") { return element }
    base = element;
  }
};

pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
  if (computed || this.eat(types.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
    node.computed = !!computed;
    if (computed) { this.expect(types.bracketR); }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== "Import", false, refDestructuringErrors);
    if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (node$1.callee.type === "Import") {
      if (node$1.arguments.length !== 1) {
        this.raise(node$1.start, "import() requires exactly one argument");
      }

      var importArg = node$1.arguments[0];
      if (importArg && importArg.type === "SpreadElement") {
        this.raise(importArg.start, "... is not allowed in import()");
      }
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  case types._import:
    if (this.options.ecmaVersion > 10) {
      return this.parseDynamicImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
};

pp$3.parseDynamicImport = function() {
  var node = this.startNode();
  this.next();
  if (this.type !== types.parenL) {
    this.unexpected();
  }
  return this.finishNode(node, "Import")
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types.parenR) {
      first ? first = false : this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target" || containsEsc)
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
    if (!this.inNonArrowFunction())
      { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.options.ecmaVersion > 10 && node.callee.type === "Import") {
    this.raise(node.callee.start, "Cannot use new with import(...)");
  }
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== "Import", false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types.comma && this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();

  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types.comma)
      { elt = null; }
    else if (this.type === types.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$5.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$5.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$5.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$5.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$5.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$5.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$5.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues
};

var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
buildUnicodeData(9);
buildUnicodeData(10);
buildUnicodeData(11);

var pp$8 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i), next;
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current () {
  return this.at(this.pos)
};

RegExpValidationState.prototype.lookahead = function lookahead () {
  return this.at(this.nextIndex(this.pos))
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.current() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString(ch) {
  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$8.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$8.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$8.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$8.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$8.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$8.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$8.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$8.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
pp$8.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>
pp$8.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$8.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$8.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$8.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$8.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$8.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &&
      this.regexp_eatUnicodePropertyValueExpression(state) &&
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise("Invalid property value"); }
};
pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
    { state.raise("Invalid property name"); }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$8.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw "unterminated regular expression" error before.
    state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$8.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$8.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$8.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$8.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$8.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$8.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$9 = Parser.prototype;

// Move to the next token

pp$9.next = function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$9.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$9[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$9.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$9.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$9.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$9.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$9.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // '/'
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // '*'
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$9.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$9.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$9.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$9.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$9.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$9.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$9.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$9.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
};

pp$9.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$9.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$9.readInt = function(radix, len) {
  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);
    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

pp$9.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$9.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var str$1 = this.input.slice(start, this.pos);
    var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val$1)
  }
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$9.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString$1(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$9.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$9.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$9.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types.template, out)
    }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$9.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case "\\":
      ++this.pos;
      break

    case "$":
      if (this.input[this.pos + 1] !== "{") {
        break
      }
    // falls through

    case "`":
      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$9.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString$1(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$9.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$9.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString$1(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$9.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.

var version = "6.4.0";

Parser.acorn = {
  Parser: Parser,
  version: version,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types,
  keywordTypes: keywords$1,
  TokContext: TokContext,
  tokContexts: types$1,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  Token: Token,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
};

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return Parser.parse(input, options)
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}




/***/ }),

/***/ "./node_modules/paper/dist/paper-full.js":
/*!***********************************************!*\
  !*** ./node_modules/paper/dist/paper-full.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Paper.js v0.12.11 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jürg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Fri Jun 19 19:14:33 2020 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jürg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */
var paper = function (self, undefined) {
  self = self || __webpack_require__(/*! ./node/self.js */ 0);
  var window = self.window,
      document = self.document;
  var Base = new function () {
    var hidden = /^(statics|enumerable|beans|preserve)$/,
        array = [],
        slice = array.slice,
        create = Object.create,
        describe = Object.getOwnPropertyDescriptor,
        define = Object.defineProperty,
        forEach = array.forEach || function (iter, bind) {
      for (var i = 0, l = this.length; i < l; i++) {
        iter.call(bind, this[i], i, this);
      }
    },
        forIn = function (iter, bind) {
      for (var i in this) {
        if (this.hasOwnProperty(i)) iter.call(bind, this[i], i, this);
      }
    },
        set = Object.assign || function (dst) {
      for (var i = 1, l = arguments.length; i < l; i++) {
        var src = arguments[i];

        for (var key in src) {
          if (src.hasOwnProperty(key)) dst[key] = src[key];
        }
      }

      return dst;
    },
        each = function (obj, iter, bind) {
      if (obj) {
        var desc = describe(obj, 'length');
        (desc && typeof desc.value === 'number' ? forEach : forIn).call(obj, iter, bind = bind || obj);
      }

      return bind;
    };

    function inject(dest, src, enumerable, beans, preserve) {
      var beansNames = {};

      function field(name, val) {
        val = val || (val = describe(src, name)) && (val.get ? val : val.value);
        if (typeof val === 'string' && val[0] === '#') val = dest[val.substring(1)] || val;
        var isFunc = typeof val === 'function',
            res = val,
            prev = preserve || isFunc && !val.base ? val && val.get ? name in dest : dest[name] : null,
            bean;

        if (!preserve || !prev) {
          if (isFunc && prev) val.base = prev;
          if (isFunc && beans !== false && (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/))) beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];

          if (!res || isFunc || !res.get || typeof res.get !== 'function' || !Base.isPlainObject(res)) {
            res = {
              value: res,
              writable: true
            };
          }

          if ((describe(dest, name) || {
            configurable: true
          }).configurable) {
            res.configurable = true;
            res.enumerable = enumerable != null ? enumerable : !bean;
          }

          define(dest, name, res);
        }
      }

      if (src) {
        for (var name in src) {
          if (src.hasOwnProperty(name) && !hidden.test(name)) field(name);
        }

        for (var name in beansNames) {
          var part = beansNames[name],
              set = dest['set' + part],
              get = dest['get' + part] || set && dest['is' + part];
          if (get && (beans === true || get.length === 0)) field(name, {
            get: get,
            set: set
          });
        }
      }

      return dest;
    }

    function Base() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        var src = arguments[i];
        if (src) set(this, src);
      }

      return this;
    }

    return inject(Base, {
      inject: function (src) {
        if (src) {
          var statics = src.statics === true ? src : src.statics,
              beans = src.beans,
              preserve = src.preserve;
          if (statics !== src) inject(this.prototype, src, src.enumerable, beans, preserve);
          inject(this, statics, null, beans, preserve);
        }

        for (var i = 1, l = arguments.length; i < l; i++) this.inject(arguments[i]);

        return this;
      },
      extend: function () {
        var base = this,
            ctor,
            proto;

        for (var i = 0, obj, l = arguments.length; i < l && !(ctor && proto); i++) {
          obj = arguments[i];
          ctor = ctor || obj.initialize;
          proto = proto || obj.prototype;
        }

        ctor = ctor || function () {
          base.apply(this, arguments);
        };

        proto = ctor.prototype = proto || create(this.prototype);
        define(proto, 'constructor', {
          value: ctor,
          writable: true,
          configurable: true
        });
        inject(ctor, this);
        if (arguments.length) this.inject.apply(ctor, arguments);
        ctor.base = base;
        return ctor;
      }
    }).inject({
      enumerable: false,
      initialize: Base,
      set: Base,
      inject: function () {
        for (var i = 0, l = arguments.length; i < l; i++) {
          var src = arguments[i];

          if (src) {
            inject(this, src, src.enumerable, src.beans, src.preserve);
          }
        }

        return this;
      },
      extend: function () {
        var res = create(this);
        return res.inject.apply(res, arguments);
      },
      each: function (iter, bind) {
        return each(this, iter, bind);
      },
      clone: function () {
        return new this.constructor(this);
      },
      statics: {
        set: set,
        each: each,
        create: create,
        define: define,
        describe: describe,
        clone: function (obj) {
          return set(new obj.constructor(), obj);
        },
        isPlainObject: function (obj) {
          var ctor = obj != null && obj.constructor;
          return ctor && (ctor === Object || ctor === Base || ctor.name === 'Object');
        },
        pick: function (a, b) {
          return a !== undefined ? a : b;
        },
        slice: function (list, begin, end) {
          return slice.call(list, begin, end);
        }
      }
    });
  }();
  if (true) module.exports = Base;
  Base.inject({
    enumerable: false,
    toString: function () {
      return this._id != null ? (this._class || 'Object') + (this._name ? " '" + this._name + "'" : ' @' + this._id) : '{ ' + Base.each(this, function (value, key) {
        if (!/^_/.test(key)) {
          var type = typeof value;
          this.push(key + ': ' + (type === 'number' ? Formatter.instance.number(value) : type === 'string' ? "'" + value + "'" : value));
        }
      }, []).join(', ') + ' }';
    },
    getClassName: function () {
      return this._class || '';
    },
    importJSON: function (json) {
      return Base.importJSON(json, this);
    },
    exportJSON: function (options) {
      return Base.exportJSON(this, options);
    },
    toJSON: function () {
      return Base.serialize(this);
    },
    set: function (props, exclude) {
      if (props) Base.filter(this, props, exclude, this._prioritize);
      return this;
    }
  }, {
    beans: false,
    statics: {
      exports: {},
      extend: function extend() {
        var res = extend.base.apply(this, arguments),
            name = res.prototype._class;
        if (name && !Base.exports[name]) Base.exports[name] = res;
        return res;
      },
      equals: function (obj1, obj2) {
        if (obj1 === obj2) return true;
        if (obj1 && obj1.equals) return obj1.equals(obj2);
        if (obj2 && obj2.equals) return obj2.equals(obj1);

        if (obj1 && obj2 && typeof obj1 === 'object' && typeof obj2 === 'object') {
          if (Array.isArray(obj1) && Array.isArray(obj2)) {
            var length = obj1.length;
            if (length !== obj2.length) return false;

            while (length--) {
              if (!Base.equals(obj1[length], obj2[length])) return false;
            }
          } else {
            var keys = Object.keys(obj1),
                length = keys.length;
            if (length !== Object.keys(obj2).length) return false;

            while (length--) {
              var key = keys[length];
              if (!(obj2.hasOwnProperty(key) && Base.equals(obj1[key], obj2[key]))) return false;
            }
          }

          return true;
        }

        return false;
      },
      read: function (list, start, options, amount) {
        if (this === Base) {
          var value = this.peek(list, start);
          list.__index++;
          return value;
        }

        var proto = this.prototype,
            readIndex = proto._readIndex,
            begin = start || readIndex && list.__index || 0,
            length = list.length,
            obj = list[begin];
        amount = amount || length - begin;

        if (obj instanceof this || options && options.readNull && obj == null && amount <= 1) {
          if (readIndex) list.__index = begin + 1;
          return obj && options && options.clone ? obj.clone() : obj;
        }

        obj = Base.create(proto);
        if (readIndex) obj.__read = true;
        obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length ? Base.slice(list, begin, begin + amount) : list) || obj;

        if (readIndex) {
          list.__index = begin + obj.__read;
          var filtered = obj.__filtered;

          if (filtered) {
            list.__filtered = filtered;
            obj.__filtered = undefined;
          }

          obj.__read = undefined;
        }

        return obj;
      },
      peek: function (list, start) {
        return list[list.__index = start || list.__index || 0];
      },
      remain: function (list) {
        return list.length - (list.__index || 0);
      },
      readList: function (list, start, options, amount) {
        var res = [],
            entry,
            begin = start || 0,
            end = amount ? begin + amount : list.length;

        for (var i = begin; i < end; i++) {
          res.push(Array.isArray(entry = list[i]) ? this.read(entry, 0, options) : this.read(list, i, options, 1));
        }

        return res;
      },
      readNamed: function (list, name, start, options, amount) {
        var value = this.getNamed(list, name),
            hasValue = value !== undefined;

        if (hasValue) {
          var filtered = list.__filtered;

          if (!filtered) {
            var source = this.getSource(list);
            filtered = list.__filtered = Base.create(source);
            filtered.__unfiltered = source;
          }

          filtered[name] = undefined;
        }

        return this.read(hasValue ? [value] : list, start, options, amount);
      },
      readSupported: function (list, dest) {
        var source = this.getSource(list),
            that = this,
            read = false;

        if (source) {
          Object.keys(source).forEach(function (key) {
            if (key in dest) {
              var value = that.readNamed(list, key);

              if (value !== undefined) {
                dest[key] = value;
              }

              read = true;
            }
          });
        }

        return read;
      },
      getSource: function (list) {
        var source = list.__source;

        if (source === undefined) {
          var arg = list.length === 1 && list[0];
          source = list.__source = arg && Base.isPlainObject(arg) ? arg : null;
        }

        return source;
      },
      getNamed: function (list, name) {
        var source = this.getSource(list);

        if (source) {
          return name ? source[name] : list.__filtered || source;
        }
      },
      hasNamed: function (list, name) {
        return !!this.getNamed(list, name);
      },
      filter: function (dest, source, exclude, prioritize) {
        var processed;

        function handleKey(key) {
          if (!(exclude && key in exclude) && !(processed && key in processed)) {
            var value = source[key];
            if (value !== undefined) dest[key] = value;
          }
        }

        if (prioritize) {
          var keys = {};

          for (var i = 0, key, l = prioritize.length; i < l; i++) {
            if ((key = prioritize[i]) in source) {
              handleKey(key);
              keys[key] = true;
            }
          }

          processed = keys;
        }

        Object.keys(source.__unfiltered || source).forEach(handleKey);
        return dest;
      },
      isPlainValue: function (obj, asString) {
        return Base.isPlainObject(obj) || Array.isArray(obj) || asString && typeof obj === 'string';
      },
      serialize: function (obj, options, compact, dictionary) {
        options = options || {};
        var isRoot = !dictionary,
            res;

        if (isRoot) {
          options.formatter = new Formatter(options.precision);
          dictionary = {
            length: 0,
            definitions: {},
            references: {},
            add: function (item, create) {
              var id = '#' + item._id,
                  ref = this.references[id];

              if (!ref) {
                this.length++;
                var res = create.call(item),
                    name = item._class;
                if (name && res[0] !== name) res.unshift(name);
                this.definitions[id] = res;
                ref = this.references[id] = [id];
              }

              return ref;
            }
          };
        }

        if (obj && obj._serialize) {
          res = obj._serialize(options, dictionary);
          var name = obj._class;

          if (name && !obj._compactSerialize && (isRoot || !compact) && res[0] !== name) {
            res.unshift(name);
          }
        } else if (Array.isArray(obj)) {
          res = [];

          for (var i = 0, l = obj.length; i < l; i++) res[i] = Base.serialize(obj[i], options, compact, dictionary);
        } else if (Base.isPlainObject(obj)) {
          res = {};
          var keys = Object.keys(obj);

          for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            res[key] = Base.serialize(obj[key], options, compact, dictionary);
          }
        } else if (typeof obj === 'number') {
          res = options.formatter.number(obj, options.precision);
        } else {
          res = obj;
        }

        return isRoot && dictionary.length > 0 ? [['dictionary', dictionary.definitions], res] : res;
      },
      deserialize: function (json, create, _data, _setDictionary, _isRoot) {
        var res = json,
            isFirst = !_data,
            hasDictionary = isFirst && json && json.length && json[0][0] === 'dictionary';
        _data = _data || {};

        if (Array.isArray(json)) {
          var type = json[0],
              isDictionary = type === 'dictionary';

          if (json.length == 1 && /^#/.test(type)) {
            return _data.dictionary[type];
          }

          type = Base.exports[type];
          res = [];

          for (var i = type ? 1 : 0, l = json.length; i < l; i++) {
            res.push(Base.deserialize(json[i], create, _data, isDictionary, hasDictionary));
          }

          if (type) {
            var args = res;

            if (create) {
              res = create(type, args, isFirst || _isRoot);
            } else {
              res = new type(args);
            }
          }
        } else if (Base.isPlainObject(json)) {
          res = {};
          if (_setDictionary) _data.dictionary = res;

          for (var key in json) res[key] = Base.deserialize(json[key], create, _data);
        }

        return hasDictionary ? res[1] : res;
      },
      exportJSON: function (obj, options) {
        var json = Base.serialize(obj, options);
        return options && options.asString == false ? json : JSON.stringify(json);
      },
      importJSON: function (json, target) {
        return Base.deserialize(typeof json === 'string' ? JSON.parse(json) : json, function (ctor, args, isRoot) {
          var useTarget = isRoot && target && target.constructor === ctor,
              obj = useTarget ? target : Base.create(ctor.prototype);

          if (args.length === 1 && obj instanceof Item && (useTarget || !(obj instanceof Layer))) {
            var arg = args[0];

            if (Base.isPlainObject(arg)) {
              arg.insert = false;

              if (useTarget) {
                args = args.concat([{
                  insert: true
                }]);
              }
            }
          }

          (useTarget ? obj.set : ctor).apply(obj, args);
          if (useTarget) target = null;
          return obj;
        });
      },
      push: function (list, items) {
        var itemsLength = items.length;

        if (itemsLength < 4096) {
          list.push.apply(list, items);
        } else {
          var startLength = list.length;
          list.length += itemsLength;

          for (var i = 0; i < itemsLength; i++) {
            list[startLength + i] = items[i];
          }
        }

        return list;
      },
      splice: function (list, items, index, remove) {
        var amount = items && items.length,
            append = index === undefined;
        index = append ? list.length : index;
        if (index > list.length) index = list.length;

        for (var i = 0; i < amount; i++) items[i]._index = index + i;

        if (append) {
          Base.push(list, items);
          return [];
        } else {
          var args = [index, remove];
          if (items) Base.push(args, items);
          var removed = list.splice.apply(list, args);

          for (var i = 0, l = removed.length; i < l; i++) removed[i]._index = undefined;

          for (var i = index + amount, l = list.length; i < l; i++) list[i]._index = i;

          return removed;
        }
      },
      capitalize: function (str) {
        return str.replace(/\b[a-z]/g, function (match) {
          return match.toUpperCase();
        });
      },
      camelize: function (str) {
        return str.replace(/-(.)/g, function (match, chr) {
          return chr.toUpperCase();
        });
      },
      hyphenate: function (str) {
        return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
      }
    }
  });
  var Emitter = {
    on: function (type, func) {
      if (typeof type !== 'string') {
        Base.each(type, function (value, key) {
          this.on(key, value);
        }, this);
      } else {
        var types = this._eventTypes,
            entry = types && types[type],
            handlers = this._callbacks = this._callbacks || {};
        handlers = handlers[type] = handlers[type] || [];

        if (handlers.indexOf(func) === -1) {
          handlers.push(func);
          if (entry && entry.install && handlers.length === 1) entry.install.call(this, type);
        }
      }

      return this;
    },
    off: function (type, func) {
      if (typeof type !== 'string') {
        Base.each(type, function (value, key) {
          this.off(key, value);
        }, this);
        return;
      }

      var types = this._eventTypes,
          entry = types && types[type],
          handlers = this._callbacks && this._callbacks[type],
          index;

      if (handlers) {
        if (!func || (index = handlers.indexOf(func)) !== -1 && handlers.length === 1) {
          if (entry && entry.uninstall) entry.uninstall.call(this, type);
          delete this._callbacks[type];
        } else if (index !== -1) {
          handlers.splice(index, 1);
        }
      }

      return this;
    },
    once: function (type, func) {
      return this.on(type, function handler() {
        func.apply(this, arguments);
        this.off(type, handler);
      });
    },
    emit: function (type, event) {
      var handlers = this._callbacks && this._callbacks[type];
      if (!handlers) return false;
      var args = Base.slice(arguments, 1),
          setTarget = event && event.target && !event.currentTarget;
      handlers = handlers.slice();
      if (setTarget) event.currentTarget = this;

      for (var i = 0, l = handlers.length; i < l; i++) {
        if (handlers[i].apply(this, args) == false) {
          if (event && event.stop) event.stop();
          break;
        }
      }

      if (setTarget) delete event.currentTarget;
      return true;
    },
    responds: function (type) {
      return !!(this._callbacks && this._callbacks[type]);
    },
    attach: '#on',
    detach: '#off',
    fire: '#emit',
    _installEvents: function (install) {
      var types = this._eventTypes,
          handlers = this._callbacks,
          key = install ? 'install' : 'uninstall';

      if (types) {
        for (var type in handlers) {
          if (handlers[type].length > 0) {
            var entry = types[type],
                func = entry && entry[key];
            if (func) func.call(this, type);
          }
        }
      }
    },
    statics: {
      inject: function inject(src) {
        var events = src._events;

        if (events) {
          var types = {};
          Base.each(events, function (entry, key) {
            var isString = typeof entry === 'string',
                name = isString ? entry : key,
                part = Base.capitalize(name),
                type = name.substring(2).toLowerCase();
            types[type] = isString ? {} : entry;
            name = '_' + name;

            src['get' + part] = function () {
              return this[name];
            };

            src['set' + part] = function (func) {
              var prev = this[name];
              if (prev) this.off(type, prev);
              if (func) this.on(type, func);
              this[name] = func;
            };
          });
          src._eventTypes = types;
        }

        return inject.base.apply(this, arguments);
      }
    }
  };
  var PaperScope = Base.extend({
    _class: 'PaperScope',
    initialize: function PaperScope() {
      paper = this;
      this.settings = new Base({
        applyMatrix: true,
        insertItems: true,
        handleSize: 4,
        hitTolerance: 0
      });
      this.project = null;
      this.projects = [];
      this.tools = [];
      this._id = PaperScope._id++;
      PaperScope._scopes[this._id] = this;
      var proto = PaperScope.prototype;

      if (!this.support) {
        var ctx = CanvasProvider.getContext(1, 1) || {};
        proto.support = {
          nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
          nativeBlendModes: BlendMode.nativeModes
        };
        CanvasProvider.release(ctx);
      }

      if (!this.agent) {
        var user = self.navigator.userAgent.toLowerCase(),
            os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user) || [])[0],
            platform = os === 'darwin' ? 'mac' : os,
            agent = proto.agent = proto.browser = {
          platform: platform
        };
        if (platform) agent[platform] = true;
        user.replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g, function (match, n, v1, v2, rv) {
          if (!agent.chrome) {
            var v = n === 'opera' ? v2 : /^(node|trident)$/.test(n) ? rv : v1;
            agent.version = v;
            agent.versionNumber = parseFloat(v);
            n = {
              trident: 'msie',
              jsdom: 'node'
            }[n] || n;
            agent.name = n;
            agent[n] = true;
          }
        });
        if (agent.chrome) delete agent.webkit;
        if (agent.atom) delete agent.chrome;
      }
    },
    version: "0.12.11",
    getView: function () {
      var project = this.project;
      return project && project._view;
    },
    getPaper: function () {
      return this;
    },
    execute: function (code, options) {
      var exports = paper.PaperScript.execute(code, this, options);
      View.updateFocus();
      return exports;
    },
    install: function (scope) {
      var that = this;
      Base.each(['project', 'view', 'tool'], function (key) {
        Base.define(scope, key, {
          configurable: true,
          get: function () {
            return that[key];
          }
        });
      });

      for (var key in this) if (!/^_/.test(key) && this[key]) scope[key] = this[key];
    },
    setup: function (element) {
      paper = this;
      this.project = new Project(element);
      return this;
    },
    createCanvas: function (width, height) {
      return CanvasProvider.getCanvas(width, height);
    },
    activate: function () {
      paper = this;
    },
    clear: function () {
      var projects = this.projects,
          tools = this.tools;

      for (var i = projects.length - 1; i >= 0; i--) projects[i].remove();

      for (var i = tools.length - 1; i >= 0; i--) tools[i].remove();
    },
    remove: function () {
      this.clear();
      delete PaperScope._scopes[this._id];
    },
    statics: new function () {
      function handleAttribute(name) {
        name += 'Attribute';
        return function (el, attr) {
          return el[name](attr) || el[name]('data-paper-' + attr);
        };
      }

      return {
        _scopes: {},
        _id: 0,
        get: function (id) {
          return this._scopes[id] || null;
        },
        getAttribute: handleAttribute('get'),
        hasAttribute: handleAttribute('has')
      };
    }()
  });
  var PaperScopeItem = Base.extend(Emitter, {
    initialize: function (activate) {
      this._scope = paper;
      this._index = this._scope[this._list].push(this) - 1;
      if (activate || !this._scope[this._reference]) this.activate();
    },
    activate: function () {
      if (!this._scope) return false;
      var prev = this._scope[this._reference];
      if (prev && prev !== this) prev.emit('deactivate');
      this._scope[this._reference] = this;
      this.emit('activate', prev);
      return true;
    },
    isActive: function () {
      return this._scope[this._reference] === this;
    },
    remove: function () {
      if (this._index == null) return false;
      Base.splice(this._scope[this._list], null, this._index, 1);
      if (this._scope[this._reference] == this) this._scope[this._reference] = null;
      this._scope = null;
      return true;
    },
    getView: function () {
      return this._scope.getView();
    }
  });
  var CollisionDetection = {
    findItemBoundsCollisions: function (items1, items2, tolerance) {
      function getBounds(items) {
        var bounds = new Array(items.length);

        for (var i = 0; i < items.length; i++) {
          var rect = items[i].getBounds();
          bounds[i] = [rect.left, rect.top, rect.right, rect.bottom];
        }

        return bounds;
      }

      var bounds1 = getBounds(items1),
          bounds2 = !items2 || items2 === items1 ? bounds1 : getBounds(items2);
      return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
    },
    findCurveBoundsCollisions: function (curves1, curves2, tolerance, bothAxis) {
      function getBounds(curves) {
        var min = Math.min,
            max = Math.max,
            bounds = new Array(curves.length);

        for (var i = 0; i < curves.length; i++) {
          var v = curves[i];
          bounds[i] = [min(v[0], v[2], v[4], v[6]), min(v[1], v[3], v[5], v[7]), max(v[0], v[2], v[4], v[6]), max(v[1], v[3], v[5], v[7])];
        }

        return bounds;
      }

      var bounds1 = getBounds(curves1),
          bounds2 = !curves2 || curves2 === curves1 ? bounds1 : getBounds(curves2);

      if (bothAxis) {
        var hor = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, false, true),
            ver = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, true, true),
            list = [];

        for (var i = 0, l = hor.length; i < l; i++) {
          list[i] = {
            hor: hor[i],
            ver: ver[i]
          };
        }

        return list;
      }

      return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
    },
    findBoundsCollisions: function (boundsA, boundsB, tolerance, sweepVertical, onlySweepAxisCollisions) {
      var self = !boundsB || boundsA === boundsB,
          allBounds = self ? boundsA : boundsA.concat(boundsB),
          lengthA = boundsA.length,
          lengthAll = allBounds.length;

      function binarySearch(indices, coord, value) {
        var lo = 0,
            hi = indices.length;

        while (lo < hi) {
          var mid = hi + lo >>> 1;

          if (allBounds[indices[mid]][coord] < value) {
            lo = mid + 1;
          } else {
            hi = mid;
          }
        }

        return lo - 1;
      }

      var pri0 = sweepVertical ? 1 : 0,
          pri1 = pri0 + 2,
          sec0 = sweepVertical ? 0 : 1,
          sec1 = sec0 + 2;
      var allIndicesByPri0 = new Array(lengthAll);

      for (var i = 0; i < lengthAll; i++) {
        allIndicesByPri0[i] = i;
      }

      allIndicesByPri0.sort(function (i1, i2) {
        return allBounds[i1][pri0] - allBounds[i2][pri0];
      });
      var activeIndicesByPri1 = [],
          allCollisions = new Array(lengthA);

      for (var i = 0; i < lengthAll; i++) {
        var curIndex = allIndicesByPri0[i],
            curBounds = allBounds[curIndex],
            origIndex = self ? curIndex : curIndex - lengthA,
            isCurrentA = curIndex < lengthA,
            isCurrentB = self || !isCurrentA,
            curCollisions = isCurrentA ? [] : null;

        if (activeIndicesByPri1.length) {
          var pruneCount = binarySearch(activeIndicesByPri1, pri1, curBounds[pri0] - tolerance) + 1;
          activeIndicesByPri1.splice(0, pruneCount);

          if (self && onlySweepAxisCollisions) {
            curCollisions = curCollisions.concat(activeIndicesByPri1);

            for (var j = 0; j < activeIndicesByPri1.length; j++) {
              var activeIndex = activeIndicesByPri1[j];
              allCollisions[activeIndex].push(origIndex);
            }
          } else {
            var curSec1 = curBounds[sec1],
                curSec0 = curBounds[sec0];

            for (var j = 0; j < activeIndicesByPri1.length; j++) {
              var activeIndex = activeIndicesByPri1[j],
                  activeBounds = allBounds[activeIndex],
                  isActiveA = activeIndex < lengthA,
                  isActiveB = self || activeIndex >= lengthA;

              if (onlySweepAxisCollisions || (isCurrentA && isActiveB || isCurrentB && isActiveA) && curSec1 >= activeBounds[sec0] - tolerance && curSec0 <= activeBounds[sec1] + tolerance) {
                if (isCurrentA && isActiveB) {
                  curCollisions.push(self ? activeIndex : activeIndex - lengthA);
                }

                if (isCurrentB && isActiveA) {
                  allCollisions[activeIndex].push(origIndex);
                }
              }
            }
          }
        }

        if (isCurrentA) {
          if (boundsA === boundsB) {
            curCollisions.push(curIndex);
          }

          allCollisions[curIndex] = curCollisions;
        }

        if (activeIndicesByPri1.length) {
          var curPri1 = curBounds[pri1],
              index = binarySearch(activeIndicesByPri1, pri1, curPri1);
          activeIndicesByPri1.splice(index + 1, 0, curIndex);
        } else {
          activeIndicesByPri1.push(curIndex);
        }
      }

      for (var i = 0; i < allCollisions.length; i++) {
        var collisions = allCollisions[i];

        if (collisions) {
          collisions.sort(function (i1, i2) {
            return i1 - i2;
          });
        }
      }

      return allCollisions;
    }
  };
  var Formatter = Base.extend({
    initialize: function (precision) {
      this.precision = Base.pick(precision, 5);
      this.multiplier = Math.pow(10, this.precision);
    },
    number: function (val) {
      return this.precision < 16 ? Math.round(val * this.multiplier) / this.multiplier : val;
    },
    pair: function (val1, val2, separator) {
      return this.number(val1) + (separator || ',') + this.number(val2);
    },
    point: function (val, separator) {
      return this.number(val.x) + (separator || ',') + this.number(val.y);
    },
    size: function (val, separator) {
      return this.number(val.width) + (separator || ',') + this.number(val.height);
    },
    rectangle: function (val, separator) {
      return this.point(val, separator) + (separator || ',') + this.size(val, separator);
    }
  });
  Formatter.instance = new Formatter();
  var Numerical = new function () {
    var abscissas = [[0.5773502691896257645091488], [0, 0.7745966692414833770358531], [0.3399810435848562648026658, 0.8611363115940525752239465], [0, 0.5384693101056830910363144, 0.9061798459386639927976269], [0.2386191860831969086305017, 0.6612093864662645136613996, 0.9324695142031520278123016], [0, 0.4058451513773971669066064, 0.7415311855993944398638648, 0.9491079123427585245261897], [0.1834346424956498049394761, 0.5255324099163289858177390, 0.7966664774136267395915539, 0.9602898564975362316835609], [0, 0.3242534234038089290385380, 0.6133714327005903973087020, 0.8360311073266357942994298, 0.9681602395076260898355762], [0.1488743389816312108848260, 0.4333953941292471907992659, 0.6794095682990244062343274, 0.8650633666889845107320967, 0.9739065285171717200779640], [0, 0.2695431559523449723315320, 0.5190961292068118159257257, 0.7301520055740493240934163, 0.8870625997680952990751578, 0.9782286581460569928039380], [0.1252334085114689154724414, 0.3678314989981801937526915, 0.5873179542866174472967024, 0.7699026741943046870368938, 0.9041172563704748566784659, 0.9815606342467192506905491], [0, 0.2304583159551347940655281, 0.4484927510364468528779129, 0.6423493394403402206439846, 0.8015780907333099127942065, 0.9175983992229779652065478, 0.9841830547185881494728294], [0.1080549487073436620662447, 0.3191123689278897604356718, 0.5152486363581540919652907, 0.6872929048116854701480198, 0.8272013150697649931897947, 0.9284348836635735173363911, 0.9862838086968123388415973], [0, 0.2011940939974345223006283, 0.3941513470775633698972074, 0.5709721726085388475372267, 0.7244177313601700474161861, 0.8482065834104272162006483, 0.9372733924007059043077589, 0.9879925180204854284895657], [0.0950125098376374401853193, 0.2816035507792589132304605, 0.4580167776572273863424194, 0.6178762444026437484466718, 0.7554044083550030338951012, 0.8656312023878317438804679, 0.9445750230732325760779884, 0.9894009349916499325961542]];
    var weights = [[1], [0.8888888888888888888888889, 0.5555555555555555555555556], [0.6521451548625461426269361, 0.3478548451374538573730639], [0.5688888888888888888888889, 0.4786286704993664680412915, 0.2369268850561890875142640], [0.4679139345726910473898703, 0.3607615730481386075698335, 0.1713244923791703450402961], [0.4179591836734693877551020, 0.3818300505051189449503698, 0.2797053914892766679014678, 0.1294849661688696932706114], [0.3626837833783619829651504, 0.3137066458778872873379622, 0.2223810344533744705443560, 0.1012285362903762591525314], [0.3302393550012597631645251, 0.3123470770400028400686304, 0.2606106964029354623187429, 0.1806481606948574040584720, 0.0812743883615744119718922], [0.2955242247147528701738930, 0.2692667193099963550912269, 0.2190863625159820439955349, 0.1494513491505805931457763, 0.0666713443086881375935688], [0.2729250867779006307144835, 0.2628045445102466621806889, 0.2331937645919904799185237, 0.1862902109277342514260976, 0.1255803694649046246346943, 0.0556685671161736664827537], [0.2491470458134027850005624, 0.2334925365383548087608499, 0.2031674267230659217490645, 0.1600783285433462263346525, 0.1069393259953184309602547, 0.0471753363865118271946160], [0.2325515532308739101945895, 0.2262831802628972384120902, 0.2078160475368885023125232, 0.1781459807619457382800467, 0.1388735102197872384636018, 0.0921214998377284479144218, 0.0404840047653158795200216], [0.2152638534631577901958764, 0.2051984637212956039659241, 0.1855383974779378137417166, 0.1572031671581935345696019, 0.1215185706879031846894148, 0.0801580871597602098056333, 0.0351194603317518630318329], [0.2025782419255612728806202, 0.1984314853271115764561183, 0.1861610000155622110268006, 0.1662692058169939335532009, 0.1395706779261543144478048, 0.1071592204671719350118695, 0.0703660474881081247092674, 0.0307532419961172683546284], [0.1894506104550684962853967, 0.1826034150449235888667637, 0.1691565193950025381893121, 0.1495959888165767320815017, 0.1246289712555338720524763, 0.0951585116824927848099251, 0.0622535239386478928628438, 0.0271524594117540948517806]];

    var abs = Math.abs,
        sqrt = Math.sqrt,
        pow = Math.pow,
        log2 = Math.log2 || function (x) {
      return Math.log(x) * Math.LOG2E;
    },
        EPSILON = 1e-12,
        MACHINE_EPSILON = 1.12e-16;

    function clamp(value, min, max) {
      return value < min ? min : value > max ? max : value;
    }

    function getDiscriminant(a, b, c) {
      function split(v) {
        var x = v * 134217729,
            y = v - x,
            hi = y + x,
            lo = v - hi;
        return [hi, lo];
      }

      var D = b * b - a * c,
          E = b * b + a * c;

      if (abs(D) * 3 < E) {
        var ad = split(a),
            bd = split(b),
            cd = split(c),
            p = b * b,
            dp = bd[0] * bd[0] - p + 2 * bd[0] * bd[1] + bd[1] * bd[1],
            q = a * c,
            dq = ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0] + ad[1] * cd[1];
        D = p - q + (dp - dq);
      }

      return D;
    }

    function getNormalizationFactor() {
      var norm = Math.max.apply(Math, arguments);
      return norm && (norm < 1e-8 || norm > 1e8) ? pow(2, -Math.round(log2(norm))) : 0;
    }

    return {
      EPSILON: EPSILON,
      MACHINE_EPSILON: MACHINE_EPSILON,
      CURVETIME_EPSILON: 1e-8,
      GEOMETRIC_EPSILON: 1e-7,
      TRIGONOMETRIC_EPSILON: 1e-8,
      KAPPA: 4 * (sqrt(2) - 1) / 3,
      isZero: function (val) {
        return val >= -EPSILON && val <= EPSILON;
      },
      isMachineZero: function (val) {
        return val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;
      },
      clamp: clamp,
      integrate: function (f, a, b, n) {
        var x = abscissas[n - 2],
            w = weights[n - 2],
            A = (b - a) * 0.5,
            B = A + a,
            i = 0,
            m = n + 1 >> 1,
            sum = n & 1 ? w[i++] * f(B) : 0;

        while (i < m) {
          var Ax = A * x[i];
          sum += w[i++] * (f(B + Ax) + f(B - Ax));
        }

        return A * sum;
      },
      findRoot: function (f, df, x, a, b, n, tolerance) {
        for (var i = 0; i < n; i++) {
          var fx = f(x),
              dx = fx / df(x),
              nx = x - dx;

          if (abs(dx) < tolerance) {
            x = nx;
            break;
          }

          if (fx > 0) {
            b = x;
            x = nx <= a ? (a + b) * 0.5 : nx;
          } else {
            a = x;
            x = nx >= b ? (a + b) * 0.5 : nx;
          }
        }

        return clamp(x, a, b);
      },
      solveQuadratic: function (a, b, c, roots, min, max) {
        var x1,
            x2 = Infinity;

        if (abs(a) < EPSILON) {
          if (abs(b) < EPSILON) return abs(c) < EPSILON ? -1 : 0;
          x1 = -c / b;
        } else {
          b *= -0.5;
          var D = getDiscriminant(a, b, c);

          if (D && abs(D) < MACHINE_EPSILON) {
            var f = getNormalizationFactor(abs(a), abs(b), abs(c));

            if (f) {
              a *= f;
              b *= f;
              c *= f;
              D = getDiscriminant(a, b, c);
            }
          }

          if (D >= -MACHINE_EPSILON) {
            var Q = D < 0 ? 0 : sqrt(D),
                R = b + (b < 0 ? -Q : Q);

            if (R === 0) {
              x1 = c / a;
              x2 = -x1;
            } else {
              x1 = R / a;
              x2 = c / R;
            }
          }
        }

        var count = 0,
            boundless = min == null,
            minB = min - EPSILON,
            maxB = max + EPSILON;
        if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB)) roots[count++] = boundless ? x1 : clamp(x1, min, max);
        if (x2 !== x1 && isFinite(x2) && (boundless || x2 > minB && x2 < maxB)) roots[count++] = boundless ? x2 : clamp(x2, min, max);
        return count;
      },
      solveCubic: function (a, b, c, d, roots, min, max) {
        var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),
            x,
            b1,
            c2,
            qd,
            q;

        if (f) {
          a *= f;
          b *= f;
          c *= f;
          d *= f;
        }

        function evaluate(x0) {
          x = x0;
          var tmp = a * x;
          b1 = tmp + b;
          c2 = b1 * x + c;
          qd = (tmp + b1) * x + c2;
          q = c2 * x + d;
        }

        if (abs(a) < EPSILON) {
          a = b;
          b1 = c;
          c2 = d;
          x = Infinity;
        } else if (abs(d) < EPSILON) {
          b1 = b;
          c2 = c;
          x = 0;
        } else {
          evaluate(-(b / a) / 3);
          var t = q / a,
              r = pow(abs(t), 1 / 3),
              s = t < 0 ? -1 : 1,
              td = -qd / a,
              rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,
              x0 = x - s * rd;

          if (x0 !== x) {
            do {
              evaluate(x0);
              x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);
            } while (s * x0 > s * x);

            if (abs(a) * x * x > abs(d / x)) {
              c2 = -d / x;
              b1 = (c2 - c) / x;
            }
          }
        }

        var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),
            boundless = min == null;
        if (isFinite(x) && (count === 0 || count > 0 && x !== roots[0] && x !== roots[1]) && (boundless || x > min - EPSILON && x < max + EPSILON)) roots[count++] = boundless ? x : clamp(x, min, max);
        return count;
      }
    };
  }();
  var UID = {
    _id: 1,
    _pools: {},
    get: function (name) {
      if (name) {
        var pool = this._pools[name];
        if (!pool) pool = this._pools[name] = {
          _id: 1
        };
        return pool._id++;
      } else {
        return this._id++;
      }
    }
  };
  var Point = Base.extend({
    _class: 'Point',
    _readIndex: true,
    initialize: function Point(arg0, arg1) {
      var type = typeof arg0,
          reading = this.__read,
          read = 0;

      if (type === 'number') {
        var hasY = typeof arg1 === 'number';

        this._set(arg0, hasY ? arg1 : arg0);

        if (reading) read = hasY ? 2 : 1;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0);

        if (reading) read = arg0 === null ? 1 : 0;
      } else {
        var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
        read = 1;

        if (Array.isArray(obj)) {
          this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
        } else if ('x' in obj) {
          this._set(obj.x || 0, obj.y || 0);
        } else if ('width' in obj) {
          this._set(obj.width || 0, obj.height || 0);
        } else if ('angle' in obj) {
          this._set(obj.length || 0, 0);

          this.setAngle(obj.angle || 0);
        } else {
          this._set(0, 0);

          read = 0;
        }
      }

      if (reading) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function (x, y) {
      this.x = x;
      this.y = y;
      return this;
    },
    equals: function (point) {
      return this === point || point && (this.x === point.x && this.y === point.y || Array.isArray(point) && this.x === point[0] && this.y === point[1]) || false;
    },
    clone: function () {
      return new Point(this.x, this.y);
    },
    toString: function () {
      var f = Formatter.instance;
      return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
    },
    _serialize: function (options) {
      var f = options.formatter;
      return [f.number(this.x), f.number(this.y)];
    },
    getLength: function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    setLength: function (length) {
      if (this.isZero()) {
        var angle = this._angle || 0;

        this._set(Math.cos(angle) * length, Math.sin(angle) * length);
      } else {
        var scale = length / this.getLength();
        if (Numerical.isZero(scale)) this.getAngle();

        this._set(this.x * scale, this.y * scale);
      }
    },
    getAngle: function () {
      return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
    },
    setAngle: function (angle) {
      this.setAngleInRadians.call(this, angle * Math.PI / 180);
    },
    getAngleInDegrees: '#getAngle',
    setAngleInDegrees: '#setAngle',
    getAngleInRadians: function () {
      if (!arguments.length) {
        return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
      } else {
        var point = Point.read(arguments),
            div = this.getLength() * point.getLength();

        if (Numerical.isZero(div)) {
          return NaN;
        } else {
          var a = this.dot(point) / div;
          return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
        }
      }
    },
    setAngleInRadians: function (angle) {
      this._angle = angle;

      if (!this.isZero()) {
        var length = this.getLength();

        this._set(Math.cos(angle) * length, Math.sin(angle) * length);
      }
    },
    getQuadrant: function () {
      return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
    }
  }, {
    beans: false,
    getDirectedAngle: function () {
      var point = Point.read(arguments);
      return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
    },
    getDistance: function () {
      var args = arguments,
          point = Point.read(args),
          x = point.x - this.x,
          y = point.y - this.y,
          d = x * x + y * y,
          squared = Base.read(args);
      return squared ? d : Math.sqrt(d);
    },
    normalize: function (length) {
      if (length === undefined) length = 1;
      var current = this.getLength(),
          scale = current !== 0 ? length / current : 0,
          point = new Point(this.x * scale, this.y * scale);
      if (scale >= 0) point._angle = this._angle;
      return point;
    },
    rotate: function (angle, center) {
      if (angle === 0) return this.clone();
      angle = angle * Math.PI / 180;
      var point = center ? this.subtract(center) : this,
          sin = Math.sin(angle),
          cos = Math.cos(angle);
      point = new Point(point.x * cos - point.y * sin, point.x * sin + point.y * cos);
      return center ? point.add(center) : point;
    },
    transform: function (matrix) {
      return matrix ? matrix._transformPoint(this) : this;
    },
    add: function () {
      var point = Point.read(arguments);
      return new Point(this.x + point.x, this.y + point.y);
    },
    subtract: function () {
      var point = Point.read(arguments);
      return new Point(this.x - point.x, this.y - point.y);
    },
    multiply: function () {
      var point = Point.read(arguments);
      return new Point(this.x * point.x, this.y * point.y);
    },
    divide: function () {
      var point = Point.read(arguments);
      return new Point(this.x / point.x, this.y / point.y);
    },
    modulo: function () {
      var point = Point.read(arguments);
      return new Point(this.x % point.x, this.y % point.y);
    },
    negate: function () {
      return new Point(-this.x, -this.y);
    },
    isInside: function () {
      return Rectangle.read(arguments).contains(this);
    },
    isClose: function () {
      var args = arguments,
          point = Point.read(args),
          tolerance = Base.read(args);
      return this.getDistance(point) <= tolerance;
    },
    isCollinear: function () {
      var point = Point.read(arguments);
      return Point.isCollinear(this.x, this.y, point.x, point.y);
    },
    isColinear: '#isCollinear',
    isOrthogonal: function () {
      var point = Point.read(arguments);
      return Point.isOrthogonal(this.x, this.y, point.x, point.y);
    },
    isZero: function () {
      var isZero = Numerical.isZero;
      return isZero(this.x) && isZero(this.y);
    },
    isNaN: function () {
      return isNaN(this.x) || isNaN(this.y);
    },
    isInQuadrant: function (q) {
      return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0 && this.y * (q > 2 ? -1 : 1) >= 0;
    },
    dot: function () {
      var point = Point.read(arguments);
      return this.x * point.x + this.y * point.y;
    },
    cross: function () {
      var point = Point.read(arguments);
      return this.x * point.y - this.y * point.x;
    },
    project: function () {
      var point = Point.read(arguments),
          scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
      return new Point(point.x * scale, point.y * scale);
    },
    statics: {
      min: function () {
        var args = arguments,
            point1 = Point.read(args),
            point2 = Point.read(args);
        return new Point(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y));
      },
      max: function () {
        var args = arguments,
            point1 = Point.read(args),
            point2 = Point.read(args);
        return new Point(Math.max(point1.x, point2.x), Math.max(point1.y, point2.y));
      },
      random: function () {
        return new Point(Math.random(), Math.random());
      },
      isCollinear: function (x1, y1, x2, y2) {
        return Math.abs(x1 * y2 - y1 * x2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;
      },
      isOrthogonal: function (x1, y1, x2, y2) {
        return Math.abs(x1 * x2 + y1 * y2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;
      }
    }
  }, Base.each(['round', 'ceil', 'floor', 'abs'], function (key) {
    var op = Math[key];

    this[key] = function () {
      return new Point(op(this.x), op(this.y));
    };
  }, {}));
  var LinkedPoint = Point.extend({
    initialize: function Point(x, y, owner, setter) {
      this._x = x;
      this._y = y;
      this._owner = owner;
      this._setter = setter;
    },
    _set: function (x, y, _dontNotify) {
      this._x = x;
      this._y = y;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    },
    getX: function () {
      return this._x;
    },
    setX: function (x) {
      this._x = x;

      this._owner[this._setter](this);
    },
    getY: function () {
      return this._y;
    },
    setY: function (y) {
      this._y = y;

      this._owner[this._setter](this);
    },
    isSelected: function () {
      return !!(this._owner._selection & this._getSelection());
    },
    setSelected: function (selected) {
      this._owner._changeSelection(this._getSelection(), selected);
    },
    _getSelection: function () {
      return this._setter === 'setPosition' ? 4 : 0;
    }
  });
  var Size = Base.extend({
    _class: 'Size',
    _readIndex: true,
    initialize: function Size(arg0, arg1) {
      var type = typeof arg0,
          reading = this.__read,
          read = 0;

      if (type === 'number') {
        var hasHeight = typeof arg1 === 'number';

        this._set(arg0, hasHeight ? arg1 : arg0);

        if (reading) read = hasHeight ? 2 : 1;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0);

        if (reading) read = arg0 === null ? 1 : 0;
      } else {
        var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
        read = 1;

        if (Array.isArray(obj)) {
          this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
        } else if ('width' in obj) {
          this._set(obj.width || 0, obj.height || 0);
        } else if ('x' in obj) {
          this._set(obj.x || 0, obj.y || 0);
        } else {
          this._set(0, 0);

          read = 0;
        }
      }

      if (reading) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function (width, height) {
      this.width = width;
      this.height = height;
      return this;
    },
    equals: function (size) {
      return size === this || size && (this.width === size.width && this.height === size.height || Array.isArray(size) && this.width === size[0] && this.height === size[1]) || false;
    },
    clone: function () {
      return new Size(this.width, this.height);
    },
    toString: function () {
      var f = Formatter.instance;
      return '{ width: ' + f.number(this.width) + ', height: ' + f.number(this.height) + ' }';
    },
    _serialize: function (options) {
      var f = options.formatter;
      return [f.number(this.width), f.number(this.height)];
    },
    add: function () {
      var size = Size.read(arguments);
      return new Size(this.width + size.width, this.height + size.height);
    },
    subtract: function () {
      var size = Size.read(arguments);
      return new Size(this.width - size.width, this.height - size.height);
    },
    multiply: function () {
      var size = Size.read(arguments);
      return new Size(this.width * size.width, this.height * size.height);
    },
    divide: function () {
      var size = Size.read(arguments);
      return new Size(this.width / size.width, this.height / size.height);
    },
    modulo: function () {
      var size = Size.read(arguments);
      return new Size(this.width % size.width, this.height % size.height);
    },
    negate: function () {
      return new Size(-this.width, -this.height);
    },
    isZero: function () {
      var isZero = Numerical.isZero;
      return isZero(this.width) && isZero(this.height);
    },
    isNaN: function () {
      return isNaN(this.width) || isNaN(this.height);
    },
    statics: {
      min: function (size1, size2) {
        return new Size(Math.min(size1.width, size2.width), Math.min(size1.height, size2.height));
      },
      max: function (size1, size2) {
        return new Size(Math.max(size1.width, size2.width), Math.max(size1.height, size2.height));
      },
      random: function () {
        return new Size(Math.random(), Math.random());
      }
    }
  }, Base.each(['round', 'ceil', 'floor', 'abs'], function (key) {
    var op = Math[key];

    this[key] = function () {
      return new Size(op(this.width), op(this.height));
    };
  }, {}));
  var LinkedSize = Size.extend({
    initialize: function Size(width, height, owner, setter) {
      this._width = width;
      this._height = height;
      this._owner = owner;
      this._setter = setter;
    },
    _set: function (width, height, _dontNotify) {
      this._width = width;
      this._height = height;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    },
    getWidth: function () {
      return this._width;
    },
    setWidth: function (width) {
      this._width = width;

      this._owner[this._setter](this);
    },
    getHeight: function () {
      return this._height;
    },
    setHeight: function (height) {
      this._height = height;

      this._owner[this._setter](this);
    }
  });
  var Rectangle = Base.extend({
    _class: 'Rectangle',
    _readIndex: true,
    beans: true,
    initialize: function Rectangle(arg0, arg1, arg2, arg3) {
      var args = arguments,
          type = typeof arg0,
          read;

      if (type === 'number') {
        this._set(arg0, arg1, arg2, arg3);

        read = 4;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0, 0, 0);

        read = arg0 === null ? 1 : 0;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          this._set.apply(this, arg0);

          read = 1;
        } else if (arg0.x !== undefined || arg0.width !== undefined) {
          this._set(arg0.x || 0, arg0.y || 0, arg0.width || 0, arg0.height || 0);

          read = 1;
        } else if (arg0.from === undefined && arg0.to === undefined) {
          this._set(0, 0, 0, 0);

          if (Base.readSupported(args, this)) {
            read = 1;
          }
        }
      }

      if (read === undefined) {
        var frm = Point.readNamed(args, 'from'),
            next = Base.peek(args),
            x = frm.x,
            y = frm.y,
            width,
            height;

        if (next && next.x !== undefined || Base.hasNamed(args, 'to')) {
          var to = Point.readNamed(args, 'to');
          width = to.x - x;
          height = to.y - y;

          if (width < 0) {
            x = to.x;
            width = -width;
          }

          if (height < 0) {
            y = to.y;
            height = -height;
          }
        } else {
          var size = Size.read(args);
          width = size.width;
          height = size.height;
        }

        this._set(x, y, width, height);

        read = args.__index;
      }

      var filtered = args.__filtered;
      if (filtered) this.__filtered = filtered;
      if (this.__read) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function (x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      return this;
    },
    clone: function () {
      return new Rectangle(this.x, this.y, this.width, this.height);
    },
    equals: function (rect) {
      var rt = Base.isPlainValue(rect) ? Rectangle.read(arguments) : rect;
      return rt === this || rt && this.x === rt.x && this.y === rt.y && this.width === rt.width && this.height === rt.height || false;
    },
    toString: function () {
      var f = Formatter.instance;
      return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ', width: ' + f.number(this.width) + ', height: ' + f.number(this.height) + ' }';
    },
    _serialize: function (options) {
      var f = options.formatter;
      return [f.number(this.x), f.number(this.y), f.number(this.width), f.number(this.height)];
    },
    getPoint: function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this.x, this.y, this, 'setPoint');
    },
    setPoint: function () {
      var point = Point.read(arguments);
      this.x = point.x;
      this.y = point.y;
    },
    getSize: function (_dontLink) {
      var ctor = _dontLink ? Size : LinkedSize;
      return new ctor(this.width, this.height, this, 'setSize');
    },
    _fw: 1,
    _fh: 1,
    setSize: function () {
      var size = Size.read(arguments),
          sx = this._sx,
          sy = this._sy,
          w = size.width,
          h = size.height;

      if (sx) {
        this.x += (this.width - w) * sx;
      }

      if (sy) {
        this.y += (this.height - h) * sy;
      }

      this.width = w;
      this.height = h;
      this._fw = this._fh = 1;
    },
    getLeft: function () {
      return this.x;
    },
    setLeft: function (left) {
      if (!this._fw) {
        var amount = left - this.x;
        this.width -= this._sx === 0.5 ? amount * 2 : amount;
      }

      this.x = left;
      this._sx = this._fw = 0;
    },
    getTop: function () {
      return this.y;
    },
    setTop: function (top) {
      if (!this._fh) {
        var amount = top - this.y;
        this.height -= this._sy === 0.5 ? amount * 2 : amount;
      }

      this.y = top;
      this._sy = this._fh = 0;
    },
    getRight: function () {
      return this.x + this.width;
    },
    setRight: function (right) {
      if (!this._fw) {
        var amount = right - this.x;
        this.width = this._sx === 0.5 ? amount * 2 : amount;
      }

      this.x = right - this.width;
      this._sx = 1;
      this._fw = 0;
    },
    getBottom: function () {
      return this.y + this.height;
    },
    setBottom: function (bottom) {
      if (!this._fh) {
        var amount = bottom - this.y;
        this.height = this._sy === 0.5 ? amount * 2 : amount;
      }

      this.y = bottom - this.height;
      this._sy = 1;
      this._fh = 0;
    },
    getCenterX: function () {
      return this.x + this.width / 2;
    },
    setCenterX: function (x) {
      if (this._fw || this._sx === 0.5) {
        this.x = x - this.width / 2;
      } else {
        if (this._sx) {
          this.x += (x - this.x) * 2 * this._sx;
        }

        this.width = (x - this.x) * 2;
      }

      this._sx = 0.5;
      this._fw = 0;
    },
    getCenterY: function () {
      return this.y + this.height / 2;
    },
    setCenterY: function (y) {
      if (this._fh || this._sy === 0.5) {
        this.y = y - this.height / 2;
      } else {
        if (this._sy) {
          this.y += (y - this.y) * 2 * this._sy;
        }

        this.height = (y - this.y) * 2;
      }

      this._sy = 0.5;
      this._fh = 0;
    },
    getCenter: function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
    },
    setCenter: function () {
      var point = Point.read(arguments);
      this.setCenterX(point.x);
      this.setCenterY(point.y);
      return this;
    },
    getArea: function () {
      return this.width * this.height;
    },
    isEmpty: function () {
      return this.width === 0 || this.height === 0;
    },
    contains: function (arg) {
      return arg && arg.width !== undefined || (Array.isArray(arg) ? arg : arguments).length === 4 ? this._containsRectangle(Rectangle.read(arguments)) : this._containsPoint(Point.read(arguments));
    },
    _containsPoint: function (point) {
      var x = point.x,
          y = point.y;
      return x >= this.x && y >= this.y && x <= this.x + this.width && y <= this.y + this.height;
    },
    _containsRectangle: function (rect) {
      var x = rect.x,
          y = rect.y;
      return x >= this.x && y >= this.y && x + rect.width <= this.x + this.width && y + rect.height <= this.y + this.height;
    },
    intersects: function () {
      var rect = Rectangle.read(arguments),
          epsilon = Base.read(arguments) || 0;
      return rect.x + rect.width > this.x - epsilon && rect.y + rect.height > this.y - epsilon && rect.x < this.x + this.width + epsilon && rect.y < this.y + this.height + epsilon;
    },
    intersect: function () {
      var rect = Rectangle.read(arguments),
          x1 = Math.max(this.x, rect.x),
          y1 = Math.max(this.y, rect.y),
          x2 = Math.min(this.x + this.width, rect.x + rect.width),
          y2 = Math.min(this.y + this.height, rect.y + rect.height);
      return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    unite: function () {
      var rect = Rectangle.read(arguments),
          x1 = Math.min(this.x, rect.x),
          y1 = Math.min(this.y, rect.y),
          x2 = Math.max(this.x + this.width, rect.x + rect.width),
          y2 = Math.max(this.y + this.height, rect.y + rect.height);
      return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    include: function () {
      var point = Point.read(arguments);
      var x1 = Math.min(this.x, point.x),
          y1 = Math.min(this.y, point.y),
          x2 = Math.max(this.x + this.width, point.x),
          y2 = Math.max(this.y + this.height, point.y);
      return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    expand: function () {
      var amount = Size.read(arguments),
          hor = amount.width,
          ver = amount.height;
      return new Rectangle(this.x - hor / 2, this.y - ver / 2, this.width + hor, this.height + ver);
    },
    scale: function (hor, ver) {
      return this.expand(this.width * hor - this.width, this.height * (ver === undefined ? hor : ver) - this.height);
    }
  }, Base.each([['Top', 'Left'], ['Top', 'Right'], ['Bottom', 'Left'], ['Bottom', 'Right'], ['Left', 'Center'], ['Top', 'Center'], ['Right', 'Center'], ['Bottom', 'Center']], function (parts, index) {
    var part = parts.join(''),
        xFirst = /^[RL]/.test(part);
    if (index >= 4) parts[1] += xFirst ? 'Y' : 'X';
    var x = parts[xFirst ? 0 : 1],
        y = parts[xFirst ? 1 : 0],
        getX = 'get' + x,
        getY = 'get' + y,
        setX = 'set' + x,
        setY = 'set' + y,
        get = 'get' + part,
        set = 'set' + part;

    this[get] = function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this[getX](), this[getY](), this, set);
    };

    this[set] = function () {
      var point = Point.read(arguments);
      this[setX](point.x);
      this[setY](point.y);
    };
  }, {
    beans: true
  }));
  var LinkedRectangle = Rectangle.extend({
    initialize: function Rectangle(x, y, width, height, owner, setter) {
      this._set(x, y, width, height, true);

      this._owner = owner;
      this._setter = setter;
    },
    _set: function (x, y, width, height, _dontNotify) {
      this._x = x;
      this._y = y;
      this._width = width;
      this._height = height;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    }
  }, new function () {
    var proto = Rectangle.prototype;
    return Base.each(['x', 'y', 'width', 'height'], function (key) {
      var part = Base.capitalize(key),
          internal = '_' + key;

      this['get' + part] = function () {
        return this[internal];
      };

      this['set' + part] = function (value) {
        this[internal] = value;
        if (!this._dontNotify) this._owner[this._setter](this);
      };
    }, Base.each(['Point', 'Size', 'Center', 'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY', 'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'], function (key) {
      var name = 'set' + key;

      this[name] = function () {
        this._dontNotify = true;
        proto[name].apply(this, arguments);
        this._dontNotify = false;

        this._owner[this._setter](this);
      };
    }, {
      isSelected: function () {
        return !!(this._owner._selection & 2);
      },
      setSelected: function (selected) {
        var owner = this._owner;

        if (owner._changeSelection) {
          owner._changeSelection(2, selected);
        }
      }
    }));
  }());
  var Matrix = Base.extend({
    _class: 'Matrix',
    initialize: function Matrix(arg, _dontNotify) {
      var args = arguments,
          count = args.length,
          ok = true;

      if (count >= 6) {
        this._set.apply(this, args);
      } else if (count === 1 || count === 2) {
        if (arg instanceof Matrix) {
          this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty, _dontNotify);
        } else if (Array.isArray(arg)) {
          this._set.apply(this, _dontNotify ? arg.concat([_dontNotify]) : arg);
        } else {
          ok = false;
        }
      } else if (!count) {
        this.reset();
      } else {
        ok = false;
      }

      if (!ok) {
        throw new Error('Unsupported matrix parameters');
      }

      return this;
    },
    set: '#initialize',
    _set: function (a, b, c, d, tx, ty, _dontNotify) {
      this._a = a;
      this._b = b;
      this._c = c;
      this._d = d;
      this._tx = tx;
      this._ty = ty;
      if (!_dontNotify) this._changed();
      return this;
    },
    _serialize: function (options, dictionary) {
      return Base.serialize(this.getValues(), options, true, dictionary);
    },
    _changed: function () {
      var owner = this._owner;

      if (owner) {
        if (owner._applyMatrix) {
          owner.transform(null, true);
        } else {
          owner._changed(25);
        }
      }
    },
    clone: function () {
      return new Matrix(this._a, this._b, this._c, this._d, this._tx, this._ty);
    },
    equals: function (mx) {
      return mx === this || mx && this._a === mx._a && this._b === mx._b && this._c === mx._c && this._d === mx._d && this._tx === mx._tx && this._ty === mx._ty;
    },
    toString: function () {
      var f = Formatter.instance;
      return '[[' + [f.number(this._a), f.number(this._c), f.number(this._tx)].join(', ') + '], [' + [f.number(this._b), f.number(this._d), f.number(this._ty)].join(', ') + ']]';
    },
    reset: function (_dontNotify) {
      this._a = this._d = 1;
      this._b = this._c = this._tx = this._ty = 0;
      if (!_dontNotify) this._changed();
      return this;
    },
    apply: function (recursively, _setApplyMatrix) {
      var owner = this._owner;

      if (owner) {
        owner.transform(null, Base.pick(recursively, true), _setApplyMatrix);
        return this.isIdentity();
      }

      return false;
    },
    translate: function () {
      var point = Point.read(arguments),
          x = point.x,
          y = point.y;
      this._tx += x * this._a + y * this._c;
      this._ty += x * this._b + y * this._d;

      this._changed();

      return this;
    },
    scale: function () {
      var args = arguments,
          scale = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      if (center) this.translate(center);
      this._a *= scale.x;
      this._b *= scale.x;
      this._c *= scale.y;
      this._d *= scale.y;
      if (center) this.translate(center.negate());

      this._changed();

      return this;
    },
    rotate: function (angle) {
      angle *= Math.PI / 180;
      var center = Point.read(arguments, 1),
          x = center.x,
          y = center.y,
          cos = Math.cos(angle),
          sin = Math.sin(angle),
          tx = x - x * cos + y * sin,
          ty = y - x * sin - y * cos,
          a = this._a,
          b = this._b,
          c = this._c,
          d = this._d;
      this._a = cos * a + sin * c;
      this._b = cos * b + sin * d;
      this._c = -sin * a + cos * c;
      this._d = -sin * b + cos * d;
      this._tx += tx * a + ty * c;
      this._ty += tx * b + ty * d;

      this._changed();

      return this;
    },
    shear: function () {
      var args = arguments,
          shear = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      if (center) this.translate(center);
      var a = this._a,
          b = this._b;
      this._a += shear.y * this._c;
      this._b += shear.y * this._d;
      this._c += shear.x * a;
      this._d += shear.x * b;
      if (center) this.translate(center.negate());

      this._changed();

      return this;
    },
    skew: function () {
      var args = arguments,
          skew = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      }),
          toRadians = Math.PI / 180,
          shear = new Point(Math.tan(skew.x * toRadians), Math.tan(skew.y * toRadians));
      return this.shear(shear, center);
    },
    append: function (mx, _dontNotify) {
      if (mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            a2 = mx._a,
            b2 = mx._c,
            c2 = mx._b,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        this._a = a2 * a1 + c2 * c1;
        this._c = b2 * a1 + d2 * c1;
        this._b = a2 * b1 + c2 * d1;
        this._d = b2 * b1 + d2 * d1;
        this._tx += tx2 * a1 + ty2 * c1;
        this._ty += tx2 * b1 + ty2 * d1;
        if (!_dontNotify) this._changed();
      }

      return this;
    },
    prepend: function (mx, _dontNotify) {
      if (mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            tx1 = this._tx,
            ty1 = this._ty,
            a2 = mx._a,
            b2 = mx._c,
            c2 = mx._b,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        this._a = a2 * a1 + b2 * b1;
        this._c = a2 * c1 + b2 * d1;
        this._b = c2 * a1 + d2 * b1;
        this._d = c2 * c1 + d2 * d1;
        this._tx = a2 * tx1 + b2 * ty1 + tx2;
        this._ty = c2 * tx1 + d2 * ty1 + ty2;
        if (!_dontNotify) this._changed();
      }

      return this;
    },
    appended: function (mx) {
      return this.clone().append(mx);
    },
    prepended: function (mx) {
      return this.clone().prepend(mx);
    },
    invert: function () {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          tx = this._tx,
          ty = this._ty,
          det = a * d - b * c,
          res = null;

      if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
        this._a = d / det;
        this._b = -b / det;
        this._c = -c / det;
        this._d = a / det;
        this._tx = (c * ty - d * tx) / det;
        this._ty = (b * tx - a * ty) / det;
        res = this;
      }

      return res;
    },
    inverted: function () {
      return this.clone().invert();
    },
    concatenate: '#append',
    preConcatenate: '#prepend',
    chain: '#appended',
    _shiftless: function () {
      return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
    },
    _orNullIfIdentity: function () {
      return this.isIdentity() ? null : this;
    },
    isIdentity: function () {
      return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1 && this._tx === 0 && this._ty === 0;
    },
    isInvertible: function () {
      var det = this._a * this._d - this._c * this._b;
      return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
    },
    isSingular: function () {
      return !this.isInvertible();
    },
    transform: function (src, dst, count) {
      return arguments.length < 3 ? this._transformPoint(Point.read(arguments)) : this._transformCoordinates(src, dst, count);
    },
    _transformPoint: function (point, dest, _dontNotify) {
      var x = point.x,
          y = point.y;
      if (!dest) dest = new Point();
      return dest._set(x * this._a + y * this._c + this._tx, x * this._b + y * this._d + this._ty, _dontNotify);
    },
    _transformCoordinates: function (src, dst, count) {
      for (var i = 0, max = 2 * count; i < max; i += 2) {
        var x = src[i],
            y = src[i + 1];
        dst[i] = x * this._a + y * this._c + this._tx;
        dst[i + 1] = x * this._b + y * this._d + this._ty;
      }

      return dst;
    },
    _transformCorners: function (rect) {
      var x1 = rect.x,
          y1 = rect.y,
          x2 = x1 + rect.width,
          y2 = y1 + rect.height,
          coords = [x1, y1, x2, y1, x2, y2, x1, y2];
      return this._transformCoordinates(coords, coords, 4);
    },
    _transformBounds: function (bounds, dest, _dontNotify) {
      var coords = this._transformCorners(bounds),
          min = coords.slice(0, 2),
          max = min.slice();

      for (var i = 2; i < 8; i++) {
        var val = coords[i],
            j = i & 1;

        if (val < min[j]) {
          min[j] = val;
        } else if (val > max[j]) {
          max[j] = val;
        }
      }

      if (!dest) dest = new Rectangle();
      return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1], _dontNotify);
    },
    inverseTransform: function () {
      return this._inverseTransform(Point.read(arguments));
    },
    _inverseTransform: function (point, dest, _dontNotify) {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          tx = this._tx,
          ty = this._ty,
          det = a * d - b * c,
          res = null;

      if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
        var x = point.x - this._tx,
            y = point.y - this._ty;
        if (!dest) dest = new Point();
        res = dest._set((x * d - y * c) / det, (y * a - x * b) / det, _dontNotify);
      }

      return res;
    },
    decompose: function () {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          det = a * d - b * c,
          sqrt = Math.sqrt,
          atan2 = Math.atan2,
          degrees = 180 / Math.PI,
          rotate,
          scale,
          skew;

      if (a !== 0 || b !== 0) {
        var r = sqrt(a * a + b * b);
        rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);
        scale = [r, det / r];
        skew = [atan2(a * c + b * d, r * r), 0];
      } else if (c !== 0 || d !== 0) {
        var s = sqrt(c * c + d * d);
        rotate = Math.asin(c / s) * (d > 0 ? 1 : -1);
        scale = [det / s, s];
        skew = [0, atan2(a * c + b * d, s * s)];
      } else {
        rotate = 0;
        skew = scale = [0, 0];
      }

      return {
        translation: this.getTranslation(),
        rotation: rotate * degrees,
        scaling: new Point(scale),
        skewing: new Point(skew[0] * degrees, skew[1] * degrees)
      };
    },
    getValues: function () {
      return [this._a, this._b, this._c, this._d, this._tx, this._ty];
    },
    getTranslation: function () {
      return new Point(this._tx, this._ty);
    },
    getScaling: function () {
      return this.decompose().scaling;
    },
    getRotation: function () {
      return this.decompose().rotation;
    },
    applyToContext: function (ctx) {
      if (!this.isIdentity()) {
        ctx.transform(this._a, this._b, this._c, this._d, this._tx, this._ty);
      }
    }
  }, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function (key) {
    var part = Base.capitalize(key),
        prop = '_' + key;

    this['get' + part] = function () {
      return this[prop];
    };

    this['set' + part] = function (value) {
      this[prop] = value;

      this._changed();
    };
  }, {}));
  var Line = Base.extend({
    _class: 'Line',
    initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
      var asVector = false;

      if (arguments.length >= 4) {
        this._px = arg0;
        this._py = arg1;
        this._vx = arg2;
        this._vy = arg3;
        asVector = arg4;
      } else {
        this._px = arg0.x;
        this._py = arg0.y;
        this._vx = arg1.x;
        this._vy = arg1.y;
        asVector = arg2;
      }

      if (!asVector) {
        this._vx -= this._px;
        this._vy -= this._py;
      }
    },
    getPoint: function () {
      return new Point(this._px, this._py);
    },
    getVector: function () {
      return new Point(this._vx, this._vy);
    },
    getLength: function () {
      return this.getVector().getLength();
    },
    intersect: function (line, isInfinite) {
      return Line.intersect(this._px, this._py, this._vx, this._vy, line._px, line._py, line._vx, line._vy, true, isInfinite);
    },
    getSide: function (point, isInfinite) {
      return Line.getSide(this._px, this._py, this._vx, this._vy, point.x, point.y, true, isInfinite);
    },
    getDistance: function (point) {
      return Math.abs(this.getSignedDistance(point));
    },
    getSignedDistance: function (point) {
      return Line.getSignedDistance(this._px, this._py, this._vx, this._vy, point.x, point.y, true);
    },
    isCollinear: function (line) {
      return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
    },
    isOrthogonal: function (line) {
      return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
    },
    statics: {
      intersect: function (p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector, isInfinite) {
        if (!asVector) {
          v1x -= p1x;
          v1y -= p1y;
          v2x -= p2x;
          v2y -= p2y;
        }

        var cross = v1x * v2y - v1y * v2x;

        if (!Numerical.isMachineZero(cross)) {
          var dx = p1x - p2x,
              dy = p1y - p2y,
              u1 = (v2x * dy - v2y * dx) / cross,
              u2 = (v1x * dy - v1y * dx) / cross,
              epsilon = 1e-12,
              uMin = -epsilon,
              uMax = 1 + epsilon;

          if (isInfinite || uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
            if (!isInfinite) {
              u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
            }

            return new Point(p1x + u1 * v1x, p1y + u1 * v1y);
          }
        }
      },
      getSide: function (px, py, vx, vy, x, y, asVector, isInfinite) {
        if (!asVector) {
          vx -= px;
          vy -= py;
        }

        var v2x = x - px,
            v2y = y - py,
            ccw = v2x * vy - v2y * vx;

        if (!isInfinite && Numerical.isMachineZero(ccw)) {
          ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
          if (ccw >= 0 && ccw <= 1) ccw = 0;
        }

        return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
      },
      getSignedDistance: function (px, py, vx, vy, x, y, asVector) {
        if (!asVector) {
          vx -= px;
          vy -= py;
        }

        return vx === 0 ? vy > 0 ? x - px : px - x : vy === 0 ? vx < 0 ? y - py : py - y : ((x - px) * vy - (y - py) * vx) / (vy > vx ? vy * Math.sqrt(1 + vx * vx / (vy * vy)) : vx * Math.sqrt(1 + vy * vy / (vx * vx)));
      },
      getDistance: function (px, py, vx, vy, x, y, asVector) {
        return Math.abs(Line.getSignedDistance(px, py, vx, vy, x, y, asVector));
      }
    }
  });
  var Project = PaperScopeItem.extend({
    _class: 'Project',
    _list: 'projects',
    _reference: 'project',
    _compactSerialize: true,
    initialize: function Project(element) {
      PaperScopeItem.call(this, true);
      this._children = [];
      this._namedChildren = {};
      this._activeLayer = null;
      this._currentStyle = new Style(null, null, this);
      this._view = View.create(this, element || CanvasProvider.getCanvas(1, 1));
      this._selectionItems = {};
      this._selectionCount = 0;
      this._updateVersion = 0;
    },
    _serialize: function (options, dictionary) {
      return Base.serialize(this._children, options, true, dictionary);
    },
    _changed: function (flags, item) {
      if (flags & 1) {
        var view = this._view;

        if (view) {
          view._needsUpdate = true;
          if (!view._requested && view._autoUpdate) view.requestUpdate();
        }
      }

      var changes = this._changes;

      if (changes && item) {
        var changesById = this._changesById,
            id = item._id,
            entry = changesById[id];

        if (entry) {
          entry.flags |= flags;
        } else {
          changes.push(changesById[id] = {
            item: item,
            flags: flags
          });
        }
      }
    },
    clear: function () {
      var children = this._children;

      for (var i = children.length - 1; i >= 0; i--) children[i].remove();
    },
    isEmpty: function () {
      return !this._children.length;
    },
    remove: function remove() {
      if (!remove.base.call(this)) return false;
      if (this._view) this._view.remove();
      return true;
    },
    getView: function () {
      return this._view;
    },
    getCurrentStyle: function () {
      return this._currentStyle;
    },
    setCurrentStyle: function (style) {
      this._currentStyle.set(style);
    },
    getIndex: function () {
      return this._index;
    },
    getOptions: function () {
      return this._scope.settings;
    },
    getLayers: function () {
      return this._children;
    },
    getActiveLayer: function () {
      return this._activeLayer || new Layer({
        project: this,
        insert: true
      });
    },
    getSymbolDefinitions: function () {
      var definitions = [],
          ids = {};
      this.getItems({
        class: SymbolItem,
        match: function (item) {
          var definition = item._definition,
              id = definition._id;

          if (!ids[id]) {
            ids[id] = true;
            definitions.push(definition);
          }

          return false;
        }
      });
      return definitions;
    },
    getSymbols: 'getSymbolDefinitions',
    getSelectedItems: function () {
      var selectionItems = this._selectionItems,
          items = [];

      for (var id in selectionItems) {
        var item = selectionItems[id],
            selection = item._selection;

        if (selection & 1 && item.isInserted()) {
          items.push(item);
        } else if (!selection) {
          this._updateSelection(item);
        }
      }

      return items;
    },
    _updateSelection: function (item) {
      var id = item._id,
          selectionItems = this._selectionItems;

      if (item._selection) {
        if (selectionItems[id] !== item) {
          this._selectionCount++;
          selectionItems[id] = item;
        }
      } else if (selectionItems[id] === item) {
        this._selectionCount--;
        delete selectionItems[id];
      }
    },
    selectAll: function () {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) children[i].setFullySelected(true);
    },
    deselectAll: function () {
      var selectionItems = this._selectionItems;

      for (var i in selectionItems) selectionItems[i].setFullySelected(false);
    },
    addLayer: function (layer) {
      return this.insertLayer(undefined, layer);
    },
    insertLayer: function (index, layer) {
      if (layer instanceof Layer) {
        layer._remove(false, true);

        Base.splice(this._children, [layer], index, 0);

        layer._setProject(this, true);

        var name = layer._name;
        if (name) layer.setName(name);
        if (this._changes) layer._changed(5);
        if (!this._activeLayer) this._activeLayer = layer;
      } else {
        layer = null;
      }

      return layer;
    },
    _insertItem: function (index, item, _created) {
      item = this.insertLayer(index, item) || (this._activeLayer || this._insertItem(undefined, new Layer(Item.NO_INSERT), true)).insertChild(index, item);
      if (_created && item.activate) item.activate();
      return item;
    },
    getItems: function (options) {
      return Item._getItems(this, options);
    },
    getItem: function (options) {
      return Item._getItems(this, options, null, null, true)[0] || null;
    },
    importJSON: function (json) {
      this.activate();
      var layer = this._activeLayer;
      return Base.importJSON(json, layer && layer.isEmpty() && layer);
    },
    removeOn: function (type) {
      var sets = this._removeSets;

      if (sets) {
        if (type === 'mouseup') sets.mousedrag = null;
        var set = sets[type];

        if (set) {
          for (var id in set) {
            var item = set[id];

            for (var key in sets) {
              var other = sets[key];
              if (other && other != set) delete other[item._id];
            }

            item.remove();
          }

          sets[type] = null;
        }
      }
    },
    draw: function (ctx, matrix, pixelRatio) {
      this._updateVersion++;
      ctx.save();
      matrix.applyToContext(ctx);
      var children = this._children,
          param = new Base({
        offset: new Point(0, 0),
        pixelRatio: pixelRatio,
        viewMatrix: matrix.isIdentity() ? null : matrix,
        matrices: [new Matrix()],
        updateMatrix: true
      });

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].draw(ctx, param);
      }

      ctx.restore();

      if (this._selectionCount > 0) {
        ctx.save();
        ctx.strokeWidth = 1;
        var items = this._selectionItems,
            size = this._scope.settings.handleSize,
            version = this._updateVersion;

        for (var id in items) {
          items[id]._drawSelection(ctx, matrix, size, items, version);
        }

        ctx.restore();
      }
    }
  });
  var Item = Base.extend(Emitter, {
    statics: {
      extend: function extend(src) {
        if (src._serializeFields) src._serializeFields = Base.set({}, this.prototype._serializeFields, src._serializeFields);
        return extend.base.apply(this, arguments);
      },
      NO_INSERT: {
        insert: false
      }
    },
    _class: 'Item',
    _name: null,
    _applyMatrix: true,
    _canApplyMatrix: true,
    _canScaleStroke: false,
    _pivot: null,
    _visible: true,
    _blendMode: 'normal',
    _opacity: 1,
    _locked: false,
    _guide: false,
    _clipMask: false,
    _selection: 0,
    _selectBounds: true,
    _selectChildren: false,
    _serializeFields: {
      name: null,
      applyMatrix: null,
      matrix: new Matrix(),
      pivot: null,
      visible: true,
      blendMode: 'normal',
      opacity: 1,
      locked: false,
      guide: false,
      clipMask: false,
      selected: false,
      data: {}
    },
    _prioritize: ['applyMatrix']
  }, new function () {
    var handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick', 'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];
    return Base.each(handlers, function (name) {
      this._events[name] = {
        install: function (type) {
          this.getView()._countItemEvent(type, 1);
        },
        uninstall: function (type) {
          this.getView()._countItemEvent(type, -1);
        }
      };
    }, {
      _events: {
        onFrame: {
          install: function () {
            this.getView()._animateItem(this, true);
          },
          uninstall: function () {
            this.getView()._animateItem(this, false);
          }
        },
        onLoad: {},
        onError: {}
      },
      statics: {
        _itemHandlers: handlers
      }
    });
  }(), {
    initialize: function Item() {},
    _initialize: function (props, point) {
      var hasProps = props && Base.isPlainObject(props),
          internal = hasProps && props.internal === true,
          matrix = this._matrix = new Matrix(),
          project = hasProps && props.project || paper.project,
          settings = paper.settings;
      this._id = internal ? null : UID.get();
      this._parent = this._index = null;
      this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
      if (point) matrix.translate(point);
      matrix._owner = this;
      this._style = new Style(project._currentStyle, this, project);

      if (internal || hasProps && props.insert == false || !settings.insertItems && !(hasProps && props.insert === true)) {
        this._setProject(project);
      } else {
        (hasProps && props.parent || project)._insertItem(undefined, this, true);
      }

      if (hasProps && props !== Item.NO_INSERT) {
        this.set(props, {
          internal: true,
          insert: true,
          project: true,
          parent: true
        });
      }

      return hasProps;
    },
    _serialize: function (options, dictionary) {
      var props = {},
          that = this;

      function serialize(fields) {
        for (var key in fields) {
          var value = that[key];

          if (!Base.equals(value, key === 'leading' ? fields.fontSize * 1.2 : fields[key])) {
            props[key] = Base.serialize(value, options, key !== 'data', dictionary);
          }
        }
      }

      serialize(this._serializeFields);
      if (!(this instanceof Group)) serialize(this._style._defaults);
      return [this._class, props];
    },
    _changed: function (flags) {
      var symbol = this._symbol,
          cacheParent = this._parent || symbol,
          project = this._project;

      if (flags & 8) {
        this._bounds = this._position = this._decomposed = undefined;
      }

      if (flags & 16) {
        this._globalMatrix = undefined;
      }

      if (cacheParent && flags & 72) {
        Item._clearBoundsCache(cacheParent);
      }

      if (flags & 2) {
        Item._clearBoundsCache(this);
      }

      if (project) project._changed(flags, this);
      if (symbol) symbol._changed(flags);
    },
    getId: function () {
      return this._id;
    },
    getName: function () {
      return this._name;
    },
    setName: function (name) {
      if (this._name) this._removeNamed();
      if (name === +name + '') throw new Error('Names consisting only of numbers are not supported.');

      var owner = this._getOwner();

      if (name && owner) {
        var children = owner._children,
            namedChildren = owner._namedChildren;
        (namedChildren[name] = namedChildren[name] || []).push(this);
        if (!(name in children)) children[name] = this;
      }

      this._name = name || undefined;

      this._changed(256);
    },
    getStyle: function () {
      return this._style;
    },
    setStyle: function (style) {
      this.getStyle().set(style);
    }
  }, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'], function (name) {
    var part = Base.capitalize(name),
        key = '_' + name,
        flags = {
      locked: 256,
      visible: 265
    };

    this['get' + part] = function () {
      return this[key];
    };

    this['set' + part] = function (value) {
      if (value != this[key]) {
        this[key] = value;

        this._changed(flags[name] || 257);
      }
    };
  }, {}), {
    beans: true,
    getSelection: function () {
      return this._selection;
    },
    setSelection: function (selection) {
      if (selection !== this._selection) {
        this._selection = selection;
        var project = this._project;

        if (project) {
          project._updateSelection(this);

          this._changed(257);
        }
      }
    },
    _changeSelection: function (flag, selected) {
      var selection = this._selection;
      this.setSelection(selected ? selection | flag : selection & ~flag);
    },
    isSelected: function () {
      if (this._selectChildren) {
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) if (children[i].isSelected()) return true;
      }

      return !!(this._selection & 1);
    },
    setSelected: function (selected) {
      if (this._selectChildren) {
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) children[i].setSelected(selected);
      }

      this._changeSelection(1, selected);
    },
    isFullySelected: function () {
      var children = this._children,
          selected = !!(this._selection & 1);

      if (children && selected) {
        for (var i = 0, l = children.length; i < l; i++) if (!children[i].isFullySelected()) return false;

        return true;
      }

      return selected;
    },
    setFullySelected: function (selected) {
      var children = this._children;

      if (children) {
        for (var i = 0, l = children.length; i < l; i++) children[i].setFullySelected(selected);
      }

      this._changeSelection(1, selected);
    },
    isClipMask: function () {
      return this._clipMask;
    },
    setClipMask: function (clipMask) {
      if (this._clipMask != (clipMask = !!clipMask)) {
        this._clipMask = clipMask;

        if (clipMask) {
          this.setFillColor(null);
          this.setStrokeColor(null);
        }

        this._changed(257);

        if (this._parent) this._parent._changed(2048);
      }
    },
    getData: function () {
      if (!this._data) this._data = {};
      return this._data;
    },
    setData: function (data) {
      this._data = data;
    },
    getPosition: function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;

      var position = this._position || (this._position = this._getPositionFromBounds());

      return new ctor(position.x, position.y, this, 'setPosition');
    },
    setPosition: function () {
      this.translate(Point.read(arguments).subtract(this.getPosition(true)));
    },
    _getPositionFromBounds: function (bounds) {
      return this._pivot ? this._matrix._transformPoint(this._pivot) : (bounds || this.getBounds()).getCenter(true);
    },
    getPivot: function () {
      var pivot = this._pivot;
      return pivot ? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot') : null;
    },
    setPivot: function () {
      this._pivot = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });
      this._position = undefined;
    }
  }, Base.each({
    getStrokeBounds: {
      stroke: true
    },
    getHandleBounds: {
      handle: true
    },
    getInternalBounds: {
      internal: true
    }
  }, function (options, key) {
    this[key] = function (matrix) {
      return this.getBounds(matrix, options);
    };
  }, {
    beans: true,
    getBounds: function (matrix, options) {
      var hasMatrix = options || matrix instanceof Matrix,
          opts = Base.set({}, hasMatrix ? options : matrix, this._boundsOptions);
      if (!opts.stroke || this.getStrokeScaling()) opts.cacheItem = this;

      var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;

      return !arguments.length ? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height, this, 'setBounds') : rect;
    },
    setBounds: function () {
      var rect = Rectangle.read(arguments),
          bounds = this.getBounds(),
          _matrix = this._matrix,
          matrix = new Matrix(),
          center = rect.getCenter();
      matrix.translate(center);

      if (rect.width != bounds.width || rect.height != bounds.height) {
        if (!_matrix.isInvertible()) {
          _matrix.set(_matrix._backup || new Matrix().translate(_matrix.getTranslation()));

          bounds = this.getBounds();
        }

        matrix.scale(bounds.width !== 0 ? rect.width / bounds.width : 0, bounds.height !== 0 ? rect.height / bounds.height : 0);
      }

      center = bounds.getCenter();
      matrix.translate(-center.x, -center.y);
      this.transform(matrix);
    },
    _getBounds: function (matrix, options) {
      var children = this._children;
      if (!children || !children.length) return new Rectangle();

      Item._updateBoundsCache(this, options.cacheItem);

      return Item._getBounds(children, matrix, options);
    },
    _getBoundsCacheKey: function (options, internal) {
      return [options.stroke ? 1 : 0, options.handle ? 1 : 0, internal ? 1 : 0].join('');
    },
    _getCachedBounds: function (matrix, options, noInternal) {
      matrix = matrix && matrix._orNullIfIdentity();

      var internal = options.internal && !noInternal,
          cacheItem = options.cacheItem,
          _matrix = internal ? null : this._matrix._orNullIfIdentity(),
          cacheKey = cacheItem && (!matrix || matrix.equals(_matrix)) && this._getBoundsCacheKey(options, internal),
          bounds = this._bounds;

      Item._updateBoundsCache(this._parent || this._symbol, cacheItem);

      if (cacheKey && bounds && cacheKey in bounds) {
        var cached = bounds[cacheKey];
        return {
          rect: cached.rect.clone(),
          nonscaling: cached.nonscaling
        };
      }

      var res = this._getBounds(matrix || _matrix, options),
          rect = res.rect || res,
          style = this._style,
          nonscaling = res.nonscaling || style.hasStroke() && !style.getStrokeScaling();

      if (cacheKey) {
        if (!bounds) {
          this._bounds = bounds = {};
        }

        var cached = bounds[cacheKey] = {
          rect: rect.clone(),
          nonscaling: nonscaling,
          internal: internal
        };
      }

      return {
        rect: rect,
        nonscaling: nonscaling
      };
    },
    _getStrokeMatrix: function (matrix, options) {
      var parent = this.getStrokeScaling() ? null : options && options.internal ? this : this._parent || this._symbol && this._symbol._item,
          mx = parent ? parent.getViewMatrix().invert() : matrix;
      return mx && mx._shiftless();
    },
    statics: {
      _updateBoundsCache: function (parent, item) {
        if (parent && item) {
          var id = item._id,
              ref = parent._boundsCache = parent._boundsCache || {
            ids: {},
            list: []
          };

          if (!ref.ids[id]) {
            ref.list.push(item);
            ref.ids[id] = item;
          }
        }
      },
      _clearBoundsCache: function (item) {
        var cache = item._boundsCache;

        if (cache) {
          item._bounds = item._position = item._boundsCache = undefined;

          for (var i = 0, list = cache.list, l = list.length; i < l; i++) {
            var other = list[i];

            if (other !== item) {
              other._bounds = other._position = undefined;
              if (other._boundsCache) Item._clearBoundsCache(other);
            }
          }
        }
      },
      _getBounds: function (items, matrix, options) {
        var x1 = Infinity,
            x2 = -x1,
            y1 = x1,
            y2 = x2,
            nonscaling = false;
        options = options || {};

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i];

          if (item._visible && !item.isEmpty(true)) {
            var bounds = item._getCachedBounds(matrix && matrix.appended(item._matrix), options, true),
                rect = bounds.rect;

            x1 = Math.min(rect.x, x1);
            y1 = Math.min(rect.y, y1);
            x2 = Math.max(rect.x + rect.width, x2);
            y2 = Math.max(rect.y + rect.height, y2);
            if (bounds.nonscaling) nonscaling = true;
          }
        }

        return {
          rect: isFinite(x1) ? new Rectangle(x1, y1, x2 - x1, y2 - y1) : new Rectangle(),
          nonscaling: nonscaling
        };
      }
    }
  }), {
    beans: true,
    _decompose: function () {
      return this._applyMatrix ? null : this._decomposed || (this._decomposed = this._matrix.decompose());
    },
    getRotation: function () {
      var decomposed = this._decompose();

      return decomposed ? decomposed.rotation : 0;
    },
    setRotation: function (rotation) {
      var current = this.getRotation();

      if (current != null && rotation != null) {
        var decomposed = this._decomposed;
        this.rotate(rotation - current);

        if (decomposed) {
          decomposed.rotation = rotation;
          this._decomposed = decomposed;
        }
      }
    },
    getScaling: function () {
      var decomposed = this._decompose(),
          s = decomposed && decomposed.scaling;

      return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');
    },
    setScaling: function () {
      var current = this.getScaling(),
          scaling = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });

      if (current && scaling && !current.equals(scaling)) {
        var rotation = this.getRotation(),
            decomposed = this._decomposed,
            matrix = new Matrix(),
            isZero = Numerical.isZero;

        if (isZero(current.x) || isZero(current.y)) {
          matrix.translate(decomposed.translation);

          if (rotation) {
            matrix.rotate(rotation);
          }

          matrix.scale(scaling.x, scaling.y);

          this._matrix.set(matrix);
        } else {
          var center = this.getPosition(true);
          matrix.translate(center);
          if (rotation) matrix.rotate(rotation);
          matrix.scale(scaling.x / current.x, scaling.y / current.y);
          if (rotation) matrix.rotate(-rotation);
          matrix.translate(center.negate());
          this.transform(matrix);
        }

        if (decomposed) {
          decomposed.scaling = scaling;
          this._decomposed = decomposed;
        }
      }
    },
    getMatrix: function () {
      return this._matrix;
    },
    setMatrix: function () {
      var matrix = this._matrix;
      matrix.set.apply(matrix, arguments);
    },
    getGlobalMatrix: function (_dontClone) {
      var matrix = this._globalMatrix;

      if (matrix) {
        var parent = this._parent;
        var parents = [];

        while (parent) {
          if (!parent._globalMatrix) {
            matrix = null;

            for (var i = 0, l = parents.length; i < l; i++) {
              parents[i]._globalMatrix = null;
            }

            break;
          }

          parents.push(parent);
          parent = parent._parent;
        }
      }

      if (!matrix) {
        matrix = this._globalMatrix = this._matrix.clone();
        var parent = this._parent;
        if (parent) matrix.prepend(parent.getGlobalMatrix(true));
      }

      return _dontClone ? matrix : matrix.clone();
    },
    getViewMatrix: function () {
      return this.getGlobalMatrix().prepend(this.getView()._matrix);
    },
    getApplyMatrix: function () {
      return this._applyMatrix;
    },
    setApplyMatrix: function (apply) {
      if (this._applyMatrix = this._canApplyMatrix && !!apply) this.transform(null, true);
    },
    getTransformContent: '#getApplyMatrix',
    setTransformContent: '#setApplyMatrix'
  }, {
    getProject: function () {
      return this._project;
    },
    _setProject: function (project, installEvents) {
      if (this._project !== project) {
        if (this._project) this._installEvents(false);
        this._project = project;
        var children = this._children;

        for (var i = 0, l = children && children.length; i < l; i++) children[i]._setProject(project);

        installEvents = true;
      }

      if (installEvents) this._installEvents(true);
    },
    getView: function () {
      return this._project._view;
    },
    _installEvents: function _installEvents(install) {
      _installEvents.base.call(this, install);

      var children = this._children;

      for (var i = 0, l = children && children.length; i < l; i++) children[i]._installEvents(install);
    },
    getLayer: function () {
      var parent = this;

      while (parent = parent._parent) {
        if (parent instanceof Layer) return parent;
      }

      return null;
    },
    getParent: function () {
      return this._parent;
    },
    setParent: function (item) {
      return item.addChild(this);
    },
    _getOwner: '#getParent',
    getChildren: function () {
      return this._children;
    },
    setChildren: function (items) {
      this.removeChildren();
      this.addChildren(items);
    },
    getFirstChild: function () {
      return this._children && this._children[0] || null;
    },
    getLastChild: function () {
      return this._children && this._children[this._children.length - 1] || null;
    },
    getNextSibling: function () {
      var owner = this._getOwner();

      return owner && owner._children[this._index + 1] || null;
    },
    getPreviousSibling: function () {
      var owner = this._getOwner();

      return owner && owner._children[this._index - 1] || null;
    },
    getIndex: function () {
      return this._index;
    },
    equals: function (item) {
      return item === this || item && this._class === item._class && this._style.equals(item._style) && this._matrix.equals(item._matrix) && this._locked === item._locked && this._visible === item._visible && this._blendMode === item._blendMode && this._opacity === item._opacity && this._clipMask === item._clipMask && this._guide === item._guide && this._equals(item) || false;
    },
    _equals: function (item) {
      return Base.equals(this._children, item._children);
    },
    clone: function (options) {
      var copy = new this.constructor(Item.NO_INSERT),
          children = this._children,
          insert = Base.pick(options ? options.insert : undefined, options === undefined || options === true),
          deep = Base.pick(options ? options.deep : undefined, true);
      if (children) copy.copyAttributes(this);
      if (!children || deep) copy.copyContent(this);
      if (!children) copy.copyAttributes(this);
      if (insert) copy.insertAbove(this);
      var name = this._name,
          parent = this._parent;

      if (name && parent) {
        var children = parent._children,
            orig = name,
            i = 1;

        while (children[name]) name = orig + ' ' + i++;

        if (name !== orig) copy.setName(name);
      }

      return copy;
    },
    copyContent: function (source) {
      var children = source._children;

      for (var i = 0, l = children && children.length; i < l; i++) {
        this.addChild(children[i].clone(false), true);
      }
    },
    copyAttributes: function (source, excludeMatrix) {
      this.setStyle(source._style);
      var keys = ['_locked', '_visible', '_blendMode', '_opacity', '_clipMask', '_guide'];

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        if (source.hasOwnProperty(key)) this[key] = source[key];
      }

      if (!excludeMatrix) this._matrix.set(source._matrix, true);
      this.setApplyMatrix(source._applyMatrix);
      this.setPivot(source._pivot);
      this.setSelection(source._selection);
      var data = source._data,
          name = source._name;
      this._data = data ? Base.clone(data) : null;
      if (name) this.setName(name);
    },
    rasterize: function (resolution, insert) {
      var bounds = this.getStrokeBounds(),
          scale = (resolution || this.getView().getResolution()) / 72,
          topLeft = bounds.getTopLeft().floor(),
          bottomRight = bounds.getBottomRight().ceil(),
          size = new Size(bottomRight.subtract(topLeft)),
          raster = new Raster(Item.NO_INSERT);

      if (!size.isZero()) {
        var canvas = CanvasProvider.getCanvas(size.multiply(scale)),
            ctx = canvas.getContext('2d'),
            matrix = new Matrix().scale(scale).translate(topLeft.negate());
        ctx.save();
        matrix.applyToContext(ctx);
        this.draw(ctx, new Base({
          matrices: [matrix]
        }));
        ctx.restore();
        raster.setCanvas(canvas);
      }

      raster.transform(new Matrix().translate(topLeft.add(size.divide(2))).scale(1 / scale));
      if (insert === undefined || insert) raster.insertAbove(this);
      return raster;
    },
    contains: function () {
      var matrix = this._matrix;
      return matrix.isInvertible() && !!this._contains(matrix._inverseTransform(Point.read(arguments)));
    },
    _contains: function (point) {
      var children = this._children;

      if (children) {
        for (var i = children.length - 1; i >= 0; i--) {
          if (children[i].contains(point)) return true;
        }

        return false;
      }

      return point.isInside(this.getInternalBounds());
    },
    isInside: function () {
      return Rectangle.read(arguments).contains(this.getBounds());
    },
    _asPathItem: function () {
      return new Path.Rectangle({
        rectangle: this.getInternalBounds(),
        matrix: this._matrix,
        insert: false
      });
    },
    intersects: function (item, _matrix) {
      if (!(item instanceof Item)) return false;
      return this._asPathItem().getIntersections(item._asPathItem(), null, _matrix, true).length > 0;
    }
  }, new function () {
    function hitTest() {
      var args = arguments;
      return this._hitTest(Point.read(args), HitResult.getOptions(args));
    }

    function hitTestAll() {
      var args = arguments,
          point = Point.read(args),
          options = HitResult.getOptions(args),
          all = [];

      this._hitTest(point, new Base({
        all: all
      }, options));

      return all;
    }

    function hitTestChildren(point, options, viewMatrix, _exclude) {
      var children = this._children;

      if (children) {
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];

          var res = child !== _exclude && child._hitTest(point, options, viewMatrix);

          if (res && !options.all) return res;
        }
      }

      return null;
    }

    Project.inject({
      hitTest: hitTest,
      hitTestAll: hitTestAll,
      _hitTest: hitTestChildren
    });
    return {
      hitTest: hitTest,
      hitTestAll: hitTestAll,
      _hitTestChildren: hitTestChildren
    };
  }(), {
    _hitTest: function (point, options, parentViewMatrix) {
      if (this._locked || !this._visible || this._guide && !options.guides || this.isEmpty()) {
        return null;
      }

      var matrix = this._matrix,
          viewMatrix = parentViewMatrix ? parentViewMatrix.appended(matrix) : this.getGlobalMatrix().prepend(this.getView()._matrix),
          tolerance = Math.max(options.tolerance, 1e-12),
          tolerancePadding = options._tolerancePadding = new Size(Path._getStrokePadding(tolerance, matrix._shiftless().invert()));
      point = matrix._inverseTransform(point);

      if (!point || !this._children && !this.getBounds({
        internal: true,
        stroke: true,
        handle: true
      }).expand(tolerancePadding.multiply(2))._containsPoint(point)) {
        return null;
      }

      var checkSelf = !(options.guides && !this._guide || options.selected && !this.isSelected() || options.type && options.type !== Base.hyphenate(this._class) || options.class && !(this instanceof options.class)),
          match = options.match,
          that = this,
          bounds,
          res;

      function filter(hit) {
        if (hit && match && !match(hit)) hit = null;
        if (hit && options.all) options.all.push(hit);
        return hit;
      }

      function checkPoint(type, part) {
        var pt = part ? bounds['get' + part]() : that.getPosition();

        if (point.subtract(pt).divide(tolerancePadding).length <= 1) {
          return new HitResult(type, that, {
            name: part ? Base.hyphenate(part) : type,
            point: pt
          });
        }
      }

      var checkPosition = options.position,
          checkCenter = options.center,
          checkBounds = options.bounds;

      if (checkSelf && this._parent && (checkPosition || checkCenter || checkBounds)) {
        if (checkCenter || checkBounds) {
          bounds = this.getInternalBounds();
        }

        res = checkPosition && checkPoint('position') || checkCenter && checkPoint('center', 'Center');

        if (!res && checkBounds) {
          var points = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'];

          for (var i = 0; i < 8 && !res; i++) {
            res = checkPoint('bounds', points[i]);
          }
        }

        res = filter(res);
      }

      if (!res) {
        res = this._hitTestChildren(point, options, viewMatrix) || checkSelf && filter(this._hitTestSelf(point, options, viewMatrix, this.getStrokeScaling() ? null : viewMatrix._shiftless().invert())) || null;
      }

      if (res && res.point) {
        res.point = matrix.transform(res.point);
      }

      return res;
    },
    _hitTestSelf: function (point, options) {
      if (options.fill && this.hasFill() && this._contains(point)) return new HitResult('fill', this);
    },
    matches: function (name, compare) {
      function matchObject(obj1, obj2) {
        for (var i in obj1) {
          if (obj1.hasOwnProperty(i)) {
            var val1 = obj1[i],
                val2 = obj2[i];

            if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
              if (!matchObject(val1, val2)) return false;
            } else if (!Base.equals(val1, val2)) {
              return false;
            }
          }
        }

        return true;
      }

      var type = typeof name;

      if (type === 'object') {
        for (var key in name) {
          if (name.hasOwnProperty(key) && !this.matches(key, name[key])) return false;
        }

        return true;
      } else if (type === 'function') {
        return name(this);
      } else if (name === 'match') {
        return compare(this);
      } else {
        var value = /^(empty|editable)$/.test(name) ? this['is' + Base.capitalize(name)]() : name === 'type' ? Base.hyphenate(this._class) : this[name];

        if (name === 'class') {
          if (typeof compare === 'function') return this instanceof compare;
          value = this._class;
        }

        if (typeof compare === 'function') {
          return !!compare(value);
        } else if (compare) {
          if (compare.test) {
            return compare.test(value);
          } else if (Base.isPlainObject(compare)) {
            return matchObject(compare, value);
          }
        }

        return Base.equals(value, compare);
      }
    },
    getItems: function (options) {
      return Item._getItems(this, options, this._matrix);
    },
    getItem: function (options) {
      return Item._getItems(this, options, this._matrix, null, true)[0] || null;
    },
    statics: {
      _getItems: function _getItems(item, options, matrix, param, firstOnly) {
        if (!param) {
          var obj = typeof options === 'object' && options,
              overlapping = obj && obj.overlapping,
              inside = obj && obj.inside,
              bounds = overlapping || inside,
              rect = bounds && Rectangle.read([bounds]);
          param = {
            items: [],
            recursive: obj && obj.recursive !== false,
            inside: !!inside,
            overlapping: !!overlapping,
            rect: rect,
            path: overlapping && new Path.Rectangle({
              rectangle: rect,
              insert: false
            })
          };

          if (obj) {
            options = Base.filter({}, options, {
              recursive: true,
              inside: true,
              overlapping: true
            });
          }
        }

        var children = item._children,
            items = param.items,
            rect = param.rect;
        matrix = rect && (matrix || new Matrix());

        for (var i = 0, l = children && children.length; i < l; i++) {
          var child = children[i],
              childMatrix = matrix && matrix.appended(child._matrix),
              add = true;

          if (rect) {
            var bounds = child.getBounds(childMatrix);
            if (!rect.intersects(bounds)) continue;
            if (!(rect.contains(bounds) || param.overlapping && (bounds.contains(rect) || param.path.intersects(child, childMatrix)))) add = false;
          }

          if (add && child.matches(options)) {
            items.push(child);
            if (firstOnly) break;
          }

          if (param.recursive !== false) {
            _getItems(child, options, childMatrix, param, firstOnly);
          }

          if (firstOnly && items.length > 0) break;
        }

        return items;
      }
    }
  }, {
    importJSON: function (json) {
      var res = Base.importJSON(json, this);
      return res !== this ? this.addChild(res) : res;
    },
    addChild: function (item) {
      return this.insertChild(undefined, item);
    },
    insertChild: function (index, item) {
      var res = item ? this.insertChildren(index, [item]) : null;
      return res && res[0];
    },
    addChildren: function (items) {
      return this.insertChildren(this._children.length, items);
    },
    insertChildren: function (index, items) {
      var children = this._children;

      if (children && items && items.length > 0) {
        items = Base.slice(items);
        var inserted = {};

        for (var i = items.length - 1; i >= 0; i--) {
          var item = items[i],
              id = item && item._id;

          if (!item || inserted[id]) {
            items.splice(i, 1);
          } else {
            item._remove(false, true);

            inserted[id] = true;
          }
        }

        Base.splice(children, items, index, 0);
        var project = this._project,
            notifySelf = project._changes;

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i],
              name = item._name;
          item._parent = this;

          item._setProject(project, true);

          if (name) item.setName(name);
          if (notifySelf) item._changed(5);
        }

        this._changed(11);
      } else {
        items = null;
      }

      return items;
    },
    _insertItem: '#insertChild',
    _insertAt: function (item, offset) {
      var owner = item && item._getOwner(),
          res = item !== this && owner ? this : null;

      if (res) {
        res._remove(false, true);

        owner._insertItem(item._index + offset, res);
      }

      return res;
    },
    insertAbove: function (item) {
      return this._insertAt(item, 1);
    },
    insertBelow: function (item) {
      return this._insertAt(item, 0);
    },
    sendToBack: function () {
      var owner = this._getOwner();

      return owner ? owner._insertItem(0, this) : null;
    },
    bringToFront: function () {
      var owner = this._getOwner();

      return owner ? owner._insertItem(undefined, this) : null;
    },
    appendTop: '#addChild',
    appendBottom: function (item) {
      return this.insertChild(0, item);
    },
    moveAbove: '#insertAbove',
    moveBelow: '#insertBelow',
    addTo: function (owner) {
      return owner._insertItem(undefined, this);
    },
    copyTo: function (owner) {
      return this.clone(false).addTo(owner);
    },
    reduce: function (options) {
      var children = this._children;

      if (children && children.length === 1) {
        var child = children[0].reduce(options);

        if (this._parent) {
          child.insertAbove(this);
          this.remove();
        } else {
          child.remove();
        }

        return child;
      }

      return this;
    },
    _removeNamed: function () {
      var owner = this._getOwner();

      if (owner) {
        var children = owner._children,
            namedChildren = owner._namedChildren,
            name = this._name,
            namedArray = namedChildren[name],
            index = namedArray ? namedArray.indexOf(this) : -1;

        if (index !== -1) {
          if (children[name] == this) delete children[name];
          namedArray.splice(index, 1);

          if (namedArray.length) {
            children[name] = namedArray[0];
          } else {
            delete namedChildren[name];
          }
        }
      }
    },
    _remove: function (notifySelf, notifyParent) {
      var owner = this._getOwner(),
          project = this._project,
          index = this._index;

      if (this._style) this._style._dispose();

      if (owner) {
        if (this._name) this._removeNamed();

        if (index != null) {
          if (project._activeLayer === this) project._activeLayer = this.getNextSibling() || this.getPreviousSibling();
          Base.splice(owner._children, null, index, 1);
        }

        this._installEvents(false);

        if (notifySelf && project._changes) this._changed(5);
        if (notifyParent) owner._changed(11, this);
        this._parent = null;
        return true;
      }

      return false;
    },
    remove: function () {
      return this._remove(true, true);
    },
    replaceWith: function (item) {
      var ok = item && item.insertBelow(this);
      if (ok) this.remove();
      return ok;
    },
    removeChildren: function (start, end) {
      if (!this._children) return null;
      start = start || 0;
      end = Base.pick(end, this._children.length);
      var removed = Base.splice(this._children, null, start, end - start);

      for (var i = removed.length - 1; i >= 0; i--) {
        removed[i]._remove(true, false);
      }

      if (removed.length > 0) this._changed(11);
      return removed;
    },
    clear: '#removeChildren',
    reverseChildren: function () {
      if (this._children) {
        this._children.reverse();

        for (var i = 0, l = this._children.length; i < l; i++) this._children[i]._index = i;

        this._changed(11);
      }
    },
    isEmpty: function (recursively) {
      var children = this._children;
      var numChildren = children ? children.length : 0;

      if (recursively) {
        for (var i = 0; i < numChildren; i++) {
          if (!children[i].isEmpty(recursively)) {
            return false;
          }
        }

        return true;
      }

      return !numChildren;
    },
    isEditable: function () {
      var item = this;

      while (item) {
        if (!item._visible || item._locked) return false;
        item = item._parent;
      }

      return true;
    },
    hasFill: function () {
      return this.getStyle().hasFill();
    },
    hasStroke: function () {
      return this.getStyle().hasStroke();
    },
    hasShadow: function () {
      return this.getStyle().hasShadow();
    },
    _getOrder: function (item) {
      function getList(item) {
        var list = [];

        do {
          list.unshift(item);
        } while (item = item._parent);

        return list;
      }

      var list1 = getList(this),
          list2 = getList(item);

      for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
        if (list1[i] != list2[i]) {
          return list1[i]._index < list2[i]._index ? 1 : -1;
        }
      }

      return 0;
    },
    hasChildren: function () {
      return this._children && this._children.length > 0;
    },
    isInserted: function () {
      return this._parent ? this._parent.isInserted() : false;
    },
    isAbove: function (item) {
      return this._getOrder(item) === -1;
    },
    isBelow: function (item) {
      return this._getOrder(item) === 1;
    },
    isParent: function (item) {
      return this._parent === item;
    },
    isChild: function (item) {
      return item && item._parent === this;
    },
    isDescendant: function (item) {
      var parent = this;

      while (parent = parent._parent) {
        if (parent === item) return true;
      }

      return false;
    },
    isAncestor: function (item) {
      return item ? item.isDescendant(this) : false;
    },
    isSibling: function (item) {
      return this._parent === item._parent;
    },
    isGroupedWith: function (item) {
      var parent = this._parent;

      while (parent) {
        if (parent._parent && /^(Group|Layer|CompoundPath)$/.test(parent._class) && item.isDescendant(parent)) return true;
        parent = parent._parent;
      }

      return false;
    }
  }, Base.each(['rotate', 'scale', 'shear', 'skew'], function (key) {
    var rotate = key === 'rotate';

    this[key] = function () {
      var args = arguments,
          value = (rotate ? Base : Point).read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      return this.transform(new Matrix()[key](value, center || this.getPosition(true)));
    };
  }, {
    translate: function () {
      var mx = new Matrix();
      return this.transform(mx.translate.apply(mx, arguments));
    },
    transform: function (matrix, _applyRecursively, _setApplyMatrix) {
      var _matrix = this._matrix,
          transformMatrix = matrix && !matrix.isIdentity(),
          applyMatrix = _setApplyMatrix && this._canApplyMatrix || this._applyMatrix && (transformMatrix || !_matrix.isIdentity() || _applyRecursively && this._children);
      if (!transformMatrix && !applyMatrix) return this;

      if (transformMatrix) {
        if (!matrix.isInvertible() && _matrix.isInvertible()) _matrix._backup = _matrix.getValues();

        _matrix.prepend(matrix, true);

        var style = this._style,
            fillColor = style.getFillColor(true),
            strokeColor = style.getStrokeColor(true);
        if (fillColor) fillColor.transform(matrix);
        if (strokeColor) strokeColor.transform(matrix);
      }

      if (applyMatrix && (applyMatrix = this._transformContent(_matrix, _applyRecursively, _setApplyMatrix))) {
        var pivot = this._pivot;
        if (pivot) _matrix._transformPoint(pivot, pivot, true);

        _matrix.reset(true);

        if (_setApplyMatrix && this._canApplyMatrix) this._applyMatrix = true;
      }

      var bounds = this._bounds,
          position = this._position;

      if (transformMatrix || applyMatrix) {
        this._changed(25);
      }

      var decomp = transformMatrix && bounds && matrix.decompose();

      if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
        for (var key in bounds) {
          var cache = bounds[key];

          if (cache.nonscaling) {
            delete bounds[key];
          } else if (applyMatrix || !cache.internal) {
            var rect = cache.rect;

            matrix._transformBounds(rect, rect);
          }
        }

        this._bounds = bounds;

        var cached = bounds[this._getBoundsCacheKey(this._boundsOptions || {})];

        if (cached) {
          this._position = this._getPositionFromBounds(cached.rect);
        }
      } else if (transformMatrix && position && this._pivot) {
        this._position = matrix._transformPoint(position, position);
      }

      return this;
    },
    _transformContent: function (matrix, applyRecursively, setApplyMatrix) {
      var children = this._children;

      if (children) {
        for (var i = 0, l = children.length; i < l; i++) {
          children[i].transform(matrix, applyRecursively, setApplyMatrix);
        }

        return true;
      }
    },
    globalToLocal: function () {
      return this.getGlobalMatrix(true)._inverseTransform(Point.read(arguments));
    },
    localToGlobal: function () {
      return this.getGlobalMatrix(true)._transformPoint(Point.read(arguments));
    },
    parentToLocal: function () {
      return this._matrix._inverseTransform(Point.read(arguments));
    },
    localToParent: function () {
      return this._matrix._transformPoint(Point.read(arguments));
    },
    fitBounds: function (rectangle, fill) {
      rectangle = Rectangle.read(arguments);
      var bounds = this.getBounds(),
          itemRatio = bounds.height / bounds.width,
          rectRatio = rectangle.height / rectangle.width,
          scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio) ? rectangle.width / bounds.width : rectangle.height / bounds.height,
          newBounds = new Rectangle(new Point(), new Size(bounds.width * scale, bounds.height * scale));
      newBounds.setCenter(rectangle.getCenter());
      this.setBounds(newBounds);
    }
  }), {
    _setStyles: function (ctx, param, viewMatrix) {
      var style = this._style,
          matrix = this._matrix;

      if (style.hasFill()) {
        ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);
      }

      if (style.hasStroke()) {
        ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);
        ctx.lineWidth = style.getStrokeWidth();
        var strokeJoin = style.getStrokeJoin(),
            strokeCap = style.getStrokeCap(),
            miterLimit = style.getMiterLimit();
        if (strokeJoin) ctx.lineJoin = strokeJoin;
        if (strokeCap) ctx.lineCap = strokeCap;
        if (miterLimit) ctx.miterLimit = miterLimit;

        if (paper.support.nativeDash) {
          var dashArray = style.getDashArray(),
              dashOffset = style.getDashOffset();

          if (dashArray && dashArray.length) {
            if ('setLineDash' in ctx) {
              ctx.setLineDash(dashArray);
              ctx.lineDashOffset = dashOffset;
            } else {
              ctx.mozDash = dashArray;
              ctx.mozDashOffset = dashOffset;
            }
          }
        }
      }

      if (style.hasShadow()) {
        var pixelRatio = param.pixelRatio || 1,
            mx = viewMatrix._shiftless().prepend(new Matrix().scale(pixelRatio, pixelRatio)),
            blur = mx.transform(new Point(style.getShadowBlur(), 0)),
            offset = mx.transform(this.getShadowOffset());

        ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
        ctx.shadowBlur = blur.getLength();
        ctx.shadowOffsetX = offset.x;
        ctx.shadowOffsetY = offset.y;
      }
    },
    draw: function (ctx, param, parentStrokeMatrix) {
      var updateVersion = this._updateVersion = this._project._updateVersion;
      if (!this._visible || this._opacity === 0) return;
      var matrices = param.matrices,
          viewMatrix = param.viewMatrix,
          matrix = this._matrix,
          globalMatrix = matrices[matrices.length - 1].appended(matrix);
      if (!globalMatrix.isInvertible()) return;
      viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix) : globalMatrix;
      matrices.push(globalMatrix);

      if (param.updateMatrix) {
        this._globalMatrix = globalMatrix;
      }

      var blendMode = this._blendMode,
          opacity = Numerical.clamp(this._opacity, 0, 1),
          normalBlend = blendMode === 'normal',
          nativeBlend = BlendMode.nativeModes[blendMode],
          direct = normalBlend && opacity === 1 || param.dontStart || param.clip || (nativeBlend || normalBlend && opacity < 1) && this._canComposite(),
          pixelRatio = param.pixelRatio || 1,
          mainCtx,
          itemOffset,
          prevOffset;

      if (!direct) {
        var bounds = this.getStrokeBounds(viewMatrix);

        if (!bounds.width || !bounds.height) {
          matrices.pop();
          return;
        }

        prevOffset = param.offset;
        itemOffset = param.offset = bounds.getTopLeft().floor();
        mainCtx = ctx;
        ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1).multiply(pixelRatio));
        if (pixelRatio !== 1) ctx.scale(pixelRatio, pixelRatio);
      }

      ctx.save();
      var strokeMatrix = parentStrokeMatrix ? parentStrokeMatrix.appended(matrix) : this._canScaleStroke && !this.getStrokeScaling(true) && viewMatrix,
          clip = !direct && param.clipItem,
          transform = !strokeMatrix || clip;

      if (direct) {
        ctx.globalAlpha = opacity;
        if (nativeBlend) ctx.globalCompositeOperation = blendMode;
      } else if (transform) {
        ctx.translate(-itemOffset.x, -itemOffset.y);
      }

      if (transform) {
        (direct ? matrix : viewMatrix).applyToContext(ctx);
      }

      if (clip) {
        param.clipItem.draw(ctx, param.extend({
          clip: true
        }));
      }

      if (strokeMatrix) {
        ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        var offset = param.offset;
        if (offset) ctx.translate(-offset.x, -offset.y);
      }

      this._draw(ctx, param, viewMatrix, strokeMatrix);

      ctx.restore();
      matrices.pop();

      if (param.clip && !param.dontFinish) {
        ctx.clip(this.getFillRule());
      }

      if (!direct) {
        BlendMode.process(blendMode, ctx, mainCtx, opacity, itemOffset.subtract(prevOffset).multiply(pixelRatio));
        CanvasProvider.release(ctx);
        param.offset = prevOffset;
      }
    },
    _isUpdated: function (updateVersion) {
      var parent = this._parent;
      if (parent instanceof CompoundPath) return parent._isUpdated(updateVersion);
      var updated = this._updateVersion === updateVersion;

      if (!updated && parent && parent._visible && parent._isUpdated(updateVersion)) {
        this._updateVersion = updateVersion;
        updated = true;
      }

      return updated;
    },
    _drawSelection: function (ctx, matrix, size, selectionItems, updateVersion) {
      var selection = this._selection,
          itemSelected = selection & 1,
          boundsSelected = selection & 2 || itemSelected && this._selectBounds,
          positionSelected = selection & 4;
      if (!this._drawSelected) itemSelected = false;

      if ((itemSelected || boundsSelected || positionSelected) && this._isUpdated(updateVersion)) {
        var layer,
            color = this.getSelectedColor(true) || (layer = this.getLayer()) && layer.getSelectedColor(true),
            mx = matrix.appended(this.getGlobalMatrix(true)),
            half = size / 2;
        ctx.strokeStyle = ctx.fillStyle = color ? color.toCanvasStyle(ctx) : '#009dec';
        if (itemSelected) this._drawSelected(ctx, mx, selectionItems);

        if (positionSelected) {
          var pos = this.getPosition(true),
              parent = this._parent,
              point = parent ? parent.localToGlobal(pos) : pos,
              x = point.x,
              y = point.y;
          ctx.beginPath();
          ctx.arc(x, y, half, 0, Math.PI * 2, true);
          ctx.stroke();
          var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],
              start = half,
              end = size + 1;

          for (var i = 0; i < 4; i++) {
            var delta = deltas[i],
                dx = delta[0],
                dy = delta[1];
            ctx.moveTo(x + dx * start, y + dy * start);
            ctx.lineTo(x + dx * end, y + dy * end);
            ctx.stroke();
          }
        }

        if (boundsSelected) {
          var coords = mx._transformCorners(this.getInternalBounds());

          ctx.beginPath();

          for (var i = 0; i < 8; i++) {
            ctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
          }

          ctx.closePath();
          ctx.stroke();

          for (var i = 0; i < 8; i++) {
            ctx.fillRect(coords[i] - half, coords[++i] - half, size, size);
          }
        }
      }
    },
    _canComposite: function () {
      return false;
    }
  }, Base.each(['down', 'drag', 'up', 'move'], function (key) {
    this['removeOn' + Base.capitalize(key)] = function () {
      var hash = {};
      hash[key] = true;
      return this.removeOn(hash);
    };
  }, {
    removeOn: function (obj) {
      for (var name in obj) {
        if (obj[name]) {
          var key = 'mouse' + name,
              project = this._project,
              sets = project._removeSets = project._removeSets || {};
          sets[key] = sets[key] || {};
          sets[key][this._id] = this;
        }
      }

      return this;
    }
  }), {
    tween: function (from, to, options) {
      if (!options) {
        options = to;
        to = from;
        from = null;

        if (!options) {
          options = to;
          to = null;
        }
      }

      var easing = options && options.easing,
          start = options && options.start,
          duration = options != null && (typeof options === 'number' ? options : options.duration),
          tween = new Tween(this, from, to, duration, easing, start);

      function onFrame(event) {
        tween._handleFrame(event.time * 1000);

        if (!tween.running) {
          this.off('frame', onFrame);
        }
      }

      if (duration) {
        this.on('frame', onFrame);
      }

      return tween;
    },
    tweenTo: function (to, options) {
      return this.tween(null, to, options);
    },
    tweenFrom: function (from, options) {
      return this.tween(from, null, options);
    }
  });
  var Group = Item.extend({
    _class: 'Group',
    _selectBounds: false,
    _selectChildren: true,
    _serializeFields: {
      children: []
    },
    initialize: function Group(arg) {
      this._children = [];
      this._namedChildren = {};
      if (!this._initialize(arg)) this.addChildren(Array.isArray(arg) ? arg : arguments);
    },
    _changed: function _changed(flags) {
      _changed.base.call(this, flags);

      if (flags & 2050) {
        this._clipItem = undefined;
      }
    },
    _getClipItem: function () {
      var clipItem = this._clipItem;

      if (clipItem === undefined) {
        clipItem = null;
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) {
          if (children[i]._clipMask) {
            clipItem = children[i];
            break;
          }
        }

        this._clipItem = clipItem;
      }

      return clipItem;
    },
    isClipped: function () {
      return !!this._getClipItem();
    },
    setClipped: function (clipped) {
      var child = this.getFirstChild();
      if (child) child.setClipMask(clipped);
    },
    _getBounds: function _getBounds(matrix, options) {
      var clipItem = this._getClipItem();

      return clipItem ? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix), Base.set({}, options, {
        stroke: false
      })) : _getBounds.base.call(this, matrix, options);
    },
    _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
      var clipItem = this._getClipItem();

      return (!clipItem || clipItem.contains(point)) && _hitTestChildren.base.call(this, point, options, viewMatrix, clipItem);
    },
    _draw: function (ctx, param) {
      var clip = param.clip,
          clipItem = !clip && this._getClipItem();

      param = param.extend({
        clipItem: clipItem,
        clip: false
      });

      if (clip) {
        ctx.beginPath();
        param.dontStart = param.dontFinish = true;
      } else if (clipItem) {
        clipItem.draw(ctx, param.extend({
          clip: true
        }));
      }

      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        var item = children[i];
        if (item !== clipItem) item.draw(ctx, param);
      }
    }
  });
  var Layer = Group.extend({
    _class: 'Layer',
    initialize: function Layer() {
      Group.apply(this, arguments);
    },
    _getOwner: function () {
      return this._parent || this._index != null && this._project;
    },
    isInserted: function isInserted() {
      return this._parent ? isInserted.base.call(this) : this._index != null;
    },
    activate: function () {
      this._project._activeLayer = this;
    },
    _hitTestSelf: function () {}
  });
  var Shape = Item.extend({
    _class: 'Shape',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _canScaleStroke: true,
    _serializeFields: {
      type: null,
      size: null,
      radius: null
    },
    initialize: function Shape(props, point) {
      this._initialize(props, point);
    },
    _equals: function (item) {
      return this._type === item._type && this._size.equals(item._size) && Base.equals(this._radius, item._radius);
    },
    copyContent: function (source) {
      this.setType(source._type);
      this.setSize(source._size);
      this.setRadius(source._radius);
    },
    getType: function () {
      return this._type;
    },
    setType: function (type) {
      this._type = type;
    },
    getShape: '#getType',
    setShape: '#setType',
    getSize: function () {
      var size = this._size;
      return new LinkedSize(size.width, size.height, this, 'setSize');
    },
    setSize: function () {
      var size = Size.read(arguments);

      if (!this._size) {
        this._size = size.clone();
      } else if (!this._size.equals(size)) {
        var type = this._type,
            width = size.width,
            height = size.height;

        if (type === 'rectangle') {
          this._radius.set(Size.min(this._radius, size.divide(2).abs()));
        } else if (type === 'circle') {
          width = height = (width + height) / 2;
          this._radius = width / 2;
        } else if (type === 'ellipse') {
          this._radius._set(width / 2, height / 2);
        }

        this._size._set(width, height);

        this._changed(9);
      }
    },
    getRadius: function () {
      var rad = this._radius;
      return this._type === 'circle' ? rad : new LinkedSize(rad.width, rad.height, this, 'setRadius');
    },
    setRadius: function (radius) {
      var type = this._type;

      if (type === 'circle') {
        if (radius === this._radius) return;
        var size = radius * 2;
        this._radius = radius;

        this._size._set(size, size);
      } else {
        radius = Size.read(arguments);

        if (!this._radius) {
          this._radius = radius.clone();
        } else {
          if (this._radius.equals(radius)) return;

          this._radius.set(radius);

          if (type === 'rectangle') {
            var size = Size.max(this._size, radius.multiply(2));

            this._size.set(size);
          } else if (type === 'ellipse') {
            this._size._set(radius.width * 2, radius.height * 2);
          }
        }
      }

      this._changed(9);
    },
    isEmpty: function () {
      return false;
    },
    toPath: function (insert) {
      var path = new Path[Base.capitalize(this._type)]({
        center: new Point(),
        size: this._size,
        radius: this._radius,
        insert: false
      });
      path.copyAttributes(this);
      if (paper.settings.applyMatrix) path.setApplyMatrix(true);
      if (insert === undefined || insert) path.insertAbove(this);
      return path;
    },
    toShape: '#clone',
    _asPathItem: function () {
      return this.toPath(false);
    },
    _draw: function (ctx, param, viewMatrix, strokeMatrix) {
      var style = this._style,
          hasFill = style.hasFill(),
          hasStroke = style.hasStroke(),
          dontPaint = param.dontFinish || param.clip,
          untransformed = !strokeMatrix;

      if (hasFill || hasStroke || dontPaint) {
        var type = this._type,
            radius = this._radius,
            isCircle = type === 'circle';
        if (!param.dontStart) ctx.beginPath();

        if (untransformed && isCircle) {
          ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
        } else {
          var rx = isCircle ? radius : radius.width,
              ry = isCircle ? radius : radius.height,
              size = this._size,
              width = size.width,
              height = size.height;

          if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
            ctx.rect(-width / 2, -height / 2, width, height);
          } else {
            var x = width / 2,
                y = height / 2,
                kappa = 1 - 0.5522847498307936,
                cx = rx * kappa,
                cy = ry * kappa,
                c = [-x, -y + ry, -x, -y + cy, -x + cx, -y, -x + rx, -y, x - rx, -y, x - cx, -y, x, -y + cy, x, -y + ry, x, y - ry, x, y - cy, x - cx, y, x - rx, y, -x + rx, y, -x + cx, y, -x, y - cy, -x, y - ry];
            if (strokeMatrix) strokeMatrix.transform(c, c, 32);
            ctx.moveTo(c[0], c[1]);
            ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
            if (x !== rx) ctx.lineTo(c[8], c[9]);
            ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
            if (y !== ry) ctx.lineTo(c[16], c[17]);
            ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
            if (x !== rx) ctx.lineTo(c[24], c[25]);
            ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
          }
        }

        ctx.closePath();
      }

      if (!dontPaint && (hasFill || hasStroke)) {
        this._setStyles(ctx, param, viewMatrix);

        if (hasFill) {
          ctx.fill(style.getFillRule());
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (hasStroke) ctx.stroke();
      }
    },
    _canComposite: function () {
      return !(this.hasFill() && this.hasStroke());
    },
    _getBounds: function (matrix, options) {
      var rect = new Rectangle(this._size).setCenter(0, 0),
          style = this._style,
          strokeWidth = options.stroke && style.hasStroke() && style.getStrokeWidth();
      if (matrix) rect = matrix._transformBounds(rect);
      return strokeWidth ? rect.expand(Path._getStrokePadding(strokeWidth, this._getStrokeMatrix(matrix, options))) : rect;
    }
  }, new function () {
    function getCornerCenter(that, point, expand) {
      var radius = that._radius;

      if (!radius.isZero()) {
        var halfSize = that._size.divide(2);

        for (var q = 1; q <= 4; q++) {
          var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),
              corner = dir.multiply(halfSize),
              center = corner.subtract(dir.multiply(radius)),
              rect = new Rectangle(expand ? corner.add(dir.multiply(expand)) : corner, center);
          if (rect.contains(point)) return {
            point: center,
            quadrant: q
          };
        }
      }
    }

    function isOnEllipseStroke(point, radius, padding, quadrant) {
      var vector = point.divide(radius);
      return (!quadrant || vector.isInQuadrant(quadrant)) && vector.subtract(vector.normalize()).multiply(radius).divide(padding).length <= 1;
    }

    return {
      _contains: function _contains(point) {
        if (this._type === 'rectangle') {
          var center = getCornerCenter(this, point);
          return center ? point.subtract(center.point).divide(this._radius).getLength() <= 1 : _contains.base.call(this, point);
        } else {
          return point.divide(this.size).getLength() <= 0.5;
        }
      },
      _hitTestSelf: function _hitTestSelf(point, options, viewMatrix, strokeMatrix) {
        var hit = false,
            style = this._style,
            hitStroke = options.stroke && style.hasStroke(),
            hitFill = options.fill && style.hasFill();

        if (hitStroke || hitFill) {
          var type = this._type,
              radius = this._radius,
              strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,
              strokePadding = options._tolerancePadding.add(Path._getStrokePadding(strokeRadius, !style.getStrokeScaling() && strokeMatrix));

          if (type === 'rectangle') {
            var padding = strokePadding.multiply(2),
                center = getCornerCenter(this, point, padding);

            if (center) {
              hit = isOnEllipseStroke(point.subtract(center.point), radius, strokePadding, center.quadrant);
            } else {
              var rect = new Rectangle(this._size).setCenter(0, 0),
                  outer = rect.expand(padding),
                  inner = rect.expand(padding.negate());
              hit = outer._containsPoint(point) && !inner._containsPoint(point);
            }
          } else {
            hit = isOnEllipseStroke(point, radius, strokePadding);
          }
        }

        return hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this) : _hitTestSelf.base.apply(this, arguments);
      }
    };
  }(), {
    statics: new function () {
      function createShape(type, point, size, radius, args) {
        var item = Base.create(Shape.prototype);
        item._type = type;
        item._size = size;
        item._radius = radius;

        item._initialize(Base.getNamed(args), point);

        return item;
      }

      return {
        Circle: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              radius = Base.readNamed(args, 'radius');
          return createShape('circle', center, new Size(radius * 2), radius, args);
        },
        Rectangle: function () {
          var args = arguments,
              rect = Rectangle.readNamed(args, 'rectangle'),
              radius = Size.min(Size.readNamed(args, 'radius'), rect.getSize(true).divide(2));
          return createShape('rectangle', rect.getCenter(true), rect.getSize(true), radius, args);
        },
        Ellipse: function () {
          var args = arguments,
              ellipse = Shape._readEllipse(args),
              radius = ellipse.radius;

          return createShape('ellipse', ellipse.center, radius.multiply(2), radius, args);
        },
        _readEllipse: function (args) {
          var center, radius;

          if (Base.hasNamed(args, 'radius')) {
            center = Point.readNamed(args, 'center');
            radius = Size.readNamed(args, 'radius');
          } else {
            var rect = Rectangle.readNamed(args, 'rectangle');
            center = rect.getCenter(true);
            radius = rect.getSize(true).divide(2);
          }

          return {
            center: center,
            radius: radius
          };
        }
      };
    }()
  });
  var Raster = Item.extend({
    _class: 'Raster',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsOptions: {
      stroke: false,
      handle: false
    },
    _serializeFields: {
      crossOrigin: null,
      source: null
    },
    _prioritize: ['crossOrigin'],
    _smoothing: true,
    beans: true,
    initialize: function Raster(source, position) {
      if (!this._initialize(source, position !== undefined && Point.read(arguments))) {
        var image,
            type = typeof source,
            object = type === 'string' ? document.getElementById(source) : type === 'object' ? source : null;

        if (object && object !== Item.NO_INSERT) {
          if (object.getContext || object.naturalHeight != null) {
            image = object;
          } else if (object) {
            var size = Size.read(arguments);

            if (!size.isZero()) {
              image = CanvasProvider.getCanvas(size);
            }
          }
        }

        if (image) {
          this.setImage(image);
        } else {
          this.setSource(source);
        }
      }

      if (!this._size) {
        this._size = new Size();
        this._loaded = false;
      }
    },
    _equals: function (item) {
      return this.getSource() === item.getSource();
    },
    copyContent: function (source) {
      var image = source._image,
          canvas = source._canvas;

      if (image) {
        this._setImage(image);
      } else if (canvas) {
        var copyCanvas = CanvasProvider.getCanvas(source._size);
        copyCanvas.getContext('2d').drawImage(canvas, 0, 0);

        this._setImage(copyCanvas);
      }

      this._crossOrigin = source._crossOrigin;
    },
    getSize: function () {
      var size = this._size;
      return new LinkedSize(size ? size.width : 0, size ? size.height : 0, this, 'setSize');
    },
    setSize: function () {
      var size = Size.read(arguments);

      if (!size.equals(this._size)) {
        if (size.width > 0 && size.height > 0) {
          var element = this.getElement();

          this._setImage(CanvasProvider.getCanvas(size));

          if (element) this.getContext(true).drawImage(element, 0, 0, size.width, size.height);
        } else {
          if (this._canvas) CanvasProvider.release(this._canvas);
          this._size = size.clone();
        }
      }
    },
    getWidth: function () {
      return this._size ? this._size.width : 0;
    },
    setWidth: function (width) {
      this.setSize(width, this.getHeight());
    },
    getHeight: function () {
      return this._size ? this._size.height : 0;
    },
    setHeight: function (height) {
      this.setSize(this.getWidth(), height);
    },
    getLoaded: function () {
      return this._loaded;
    },
    isEmpty: function () {
      var size = this._size;
      return !size || size.width === 0 && size.height === 0;
    },
    getResolution: function () {
      var matrix = this._matrix,
          orig = new Point(0, 0).transform(matrix),
          u = new Point(1, 0).transform(matrix).subtract(orig),
          v = new Point(0, 1).transform(matrix).subtract(orig);
      return new Size(72 / u.getLength(), 72 / v.getLength());
    },
    getPpi: '#getResolution',
    getImage: function () {
      return this._image;
    },
    setImage: function (image) {
      var that = this;

      function emit(event) {
        var view = that.getView(),
            type = event && event.type || 'load';

        if (view && that.responds(type)) {
          paper = view._scope;
          that.emit(type, new Event(event));
        }
      }

      this._setImage(image);

      if (this._loaded) {
        setTimeout(emit, 0);
      } else if (image) {
        DomEvent.add(image, {
          load: function (event) {
            that._setImage(image);

            emit(event);
          },
          error: emit
        });
      }
    },
    _setImage: function (image) {
      if (this._canvas) CanvasProvider.release(this._canvas);

      if (image && image.getContext) {
        this._image = null;
        this._canvas = image;
        this._loaded = true;
      } else {
        this._image = image;
        this._canvas = null;
        this._loaded = !!(image && image.src && image.complete);
      }

      this._size = new Size(image ? image.naturalWidth || image.width : 0, image ? image.naturalHeight || image.height : 0);
      this._context = null;

      this._changed(1033);
    },
    getCanvas: function () {
      if (!this._canvas) {
        var ctx = CanvasProvider.getContext(this._size);

        try {
          if (this._image) ctx.drawImage(this._image, 0, 0);
          this._canvas = ctx.canvas;
        } catch (e) {
          CanvasProvider.release(ctx);
        }
      }

      return this._canvas;
    },
    setCanvas: '#setImage',
    getContext: function (_change) {
      if (!this._context) this._context = this.getCanvas().getContext('2d');

      if (_change) {
        this._image = null;

        this._changed(1025);
      }

      return this._context;
    },
    setContext: function (context) {
      this._context = context;
    },
    getSource: function () {
      var image = this._image;
      return image && image.src || this.toDataURL();
    },
    setSource: function (src) {
      var image = new self.Image(),
          crossOrigin = this._crossOrigin;
      if (crossOrigin) image.crossOrigin = crossOrigin;
      if (src) image.src = src;
      this.setImage(image);
    },
    getCrossOrigin: function () {
      var image = this._image;
      return image && image.crossOrigin || this._crossOrigin || '';
    },
    setCrossOrigin: function (crossOrigin) {
      this._crossOrigin = crossOrigin;
      var image = this._image;
      if (image) image.crossOrigin = crossOrigin;
    },
    getSmoothing: function () {
      return this._smoothing;
    },
    setSmoothing: function (smoothing) {
      this._smoothing = smoothing;

      this._changed(257);
    },
    getElement: function () {
      return this._canvas || this._loaded && this._image;
    }
  }, {
    beans: false,
    getSubCanvas: function () {
      var rect = Rectangle.read(arguments),
          ctx = CanvasProvider.getContext(rect.getSize());
      ctx.drawImage(this.getCanvas(), rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
      return ctx.canvas;
    },
    getSubRaster: function () {
      var rect = Rectangle.read(arguments),
          raster = new Raster(Item.NO_INSERT);

      raster._setImage(this.getSubCanvas(rect));

      raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));

      raster._matrix.prepend(this._matrix);

      raster.insertAbove(this);
      return raster;
    },
    toDataURL: function () {
      var image = this._image,
          src = image && image.src;
      if (/^data:/.test(src)) return src;
      var canvas = this.getCanvas();
      return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
    },
    drawImage: function (image) {
      var point = Point.read(arguments, 1);
      this.getContext(true).drawImage(image, point.x, point.y);
    },
    getAverageColor: function (object) {
      var bounds, path;

      if (!object) {
        bounds = this.getBounds();
      } else if (object instanceof PathItem) {
        path = object;
        bounds = object.getBounds();
      } else if (typeof object === 'object') {
        if ('width' in object) {
          bounds = new Rectangle(object);
        } else if ('x' in object) {
          bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
        }
      }

      if (!bounds) return null;
      var sampleSize = 32,
          width = Math.min(bounds.width, sampleSize),
          height = Math.min(bounds.height, sampleSize);
      var ctx = Raster._sampleContext;

      if (!ctx) {
        ctx = Raster._sampleContext = CanvasProvider.getContext(new Size(sampleSize));
      } else {
        ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
      }

      ctx.save();
      var matrix = new Matrix().scale(width / bounds.width, height / bounds.height).translate(-bounds.x, -bounds.y);
      matrix.applyToContext(ctx);
      if (path) path.draw(ctx, new Base({
        clip: true,
        matrices: [matrix]
      }));

      this._matrix.applyToContext(ctx);

      var element = this.getElement(),
          size = this._size;
      if (element) ctx.drawImage(element, -size.width / 2, -size.height / 2);
      ctx.restore();
      var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width), Math.ceil(height)).data,
          channels = [0, 0, 0],
          total = 0;

      for (var i = 0, l = pixels.length; i < l; i += 4) {
        var alpha = pixels[i + 3];
        total += alpha;
        alpha /= 255;
        channels[0] += pixels[i] * alpha;
        channels[1] += pixels[i + 1] * alpha;
        channels[2] += pixels[i + 2] * alpha;
      }

      for (var i = 0; i < 3; i++) channels[i] /= total;

      return total ? Color.read(channels) : null;
    },
    getPixel: function () {
      var point = Point.read(arguments);
      var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
      return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255], data[3] / 255);
    },
    setPixel: function () {
      var args = arguments,
          point = Point.read(args),
          color = Color.read(args),
          components = color._convert('rgb'),
          alpha = color._alpha,
          ctx = this.getContext(true),
          imageData = ctx.createImageData(1, 1),
          data = imageData.data;

      data[0] = components[0] * 255;
      data[1] = components[1] * 255;
      data[2] = components[2] * 255;
      data[3] = alpha != null ? alpha * 255 : 255;
      ctx.putImageData(imageData, point.x, point.y);
    },
    clear: function () {
      var size = this._size;
      this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);
    },
    createImageData: function () {
      var size = Size.read(arguments);
      return this.getContext().createImageData(size.width, size.height);
    },
    getImageData: function () {
      var rect = Rectangle.read(arguments);
      if (rect.isEmpty()) rect = new Rectangle(this._size);
      return this.getContext().getImageData(rect.x, rect.y, rect.width, rect.height);
    },
    setImageData: function (data) {
      var point = Point.read(arguments, 1);
      this.getContext(true).putImageData(data, point.x, point.y);
    },
    _getBounds: function (matrix, options) {
      var rect = new Rectangle(this._size).setCenter(0, 0);
      return matrix ? matrix._transformBounds(rect) : rect;
    },
    _hitTestSelf: function (point) {
      if (this._contains(point)) {
        var that = this;
        return new HitResult('pixel', that, {
          offset: point.add(that._size.divide(2)).round(),
          color: {
            get: function () {
              return that.getPixel(this.offset);
            }
          }
        });
      }
    },
    _draw: function (ctx, param, viewMatrix) {
      var element = this.getElement();

      if (element && element.width > 0 && element.height > 0) {
        ctx.globalAlpha = Numerical.clamp(this._opacity, 0, 1);

        this._setStyles(ctx, param, viewMatrix);

        DomElement.setPrefixed(ctx, 'imageSmoothingEnabled', this._smoothing);
        ctx.drawImage(element, -this._size.width / 2, -this._size.height / 2);
      }
    },
    _canComposite: function () {
      return true;
    }
  });
  var SymbolItem = Item.extend({
    _class: 'SymbolItem',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsOptions: {
      stroke: true
    },
    _serializeFields: {
      symbol: null
    },
    initialize: function SymbolItem(arg0, arg1) {
      if (!this._initialize(arg0, arg1 !== undefined && Point.read(arguments, 1))) this.setDefinition(arg0 instanceof SymbolDefinition ? arg0 : new SymbolDefinition(arg0));
    },
    _equals: function (item) {
      return this._definition === item._definition;
    },
    copyContent: function (source) {
      this.setDefinition(source._definition);
    },
    getDefinition: function () {
      return this._definition;
    },
    setDefinition: function (definition) {
      this._definition = definition;

      this._changed(9);
    },
    getSymbol: '#getDefinition',
    setSymbol: '#setDefinition',
    isEmpty: function () {
      return this._definition._item.isEmpty();
    },
    _getBounds: function (matrix, options) {
      var item = this._definition._item;
      return item._getCachedBounds(item._matrix.prepended(matrix), options);
    },
    _hitTestSelf: function (point, options, viewMatrix) {
      var opts = options.extend({
        all: false
      });

      var res = this._definition._item._hitTest(point, opts, viewMatrix);

      if (res) res.item = this;
      return res;
    },
    _draw: function (ctx, param) {
      this._definition._item.draw(ctx, param);
    }
  });
  var SymbolDefinition = Base.extend({
    _class: 'SymbolDefinition',
    initialize: function SymbolDefinition(item, dontCenter) {
      this._id = UID.get();
      this.project = paper.project;
      if (item) this.setItem(item, dontCenter);
    },
    _serialize: function (options, dictionary) {
      return dictionary.add(this, function () {
        return Base.serialize([this._class, this._item], options, false, dictionary);
      });
    },
    _changed: function (flags) {
      if (flags & 8) Item._clearBoundsCache(this);
      if (flags & 1) this.project._changed(flags);
    },
    getItem: function () {
      return this._item;
    },
    setItem: function (item, _dontCenter) {
      if (item._symbol) item = item.clone();
      if (this._item) this._item._symbol = null;
      this._item = item;
      item.remove();
      item.setSelected(false);
      if (!_dontCenter) item.setPosition(new Point());
      item._symbol = this;

      this._changed(9);
    },
    getDefinition: '#getItem',
    setDefinition: '#setItem',
    place: function (position) {
      return new SymbolItem(this, position);
    },
    clone: function () {
      return new SymbolDefinition(this._item.clone(false));
    },
    equals: function (symbol) {
      return symbol === this || symbol && this._item.equals(symbol._item) || false;
    }
  });
  var HitResult = Base.extend({
    _class: 'HitResult',
    initialize: function HitResult(type, item, values) {
      this.type = type;
      this.item = item;
      if (values) this.inject(values);
    },
    statics: {
      getOptions: function (args) {
        var options = args && Base.read(args);
        return new Base({
          type: null,
          tolerance: paper.settings.hitTolerance,
          fill: !options,
          stroke: !options,
          segments: !options,
          handles: false,
          ends: false,
          position: false,
          center: false,
          bounds: false,
          guides: false,
          selected: false
        }, options);
      }
    }
  });
  var Segment = Base.extend({
    _class: 'Segment',
    beans: true,
    _selection: 0,
    initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
      var count = arguments.length,
          point,
          handleIn,
          handleOut,
          selection;

      if (count > 0) {
        if (arg0 == null || typeof arg0 === 'object') {
          if (count === 1 && arg0 && 'point' in arg0) {
            point = arg0.point;
            handleIn = arg0.handleIn;
            handleOut = arg0.handleOut;
            selection = arg0.selection;
          } else {
            point = arg0;
            handleIn = arg1;
            handleOut = arg2;
            selection = arg3;
          }
        } else {
          point = [arg0, arg1];
          handleIn = arg2 !== undefined ? [arg2, arg3] : null;
          handleOut = arg4 !== undefined ? [arg4, arg5] : null;
        }
      }

      new SegmentPoint(point, this, '_point');
      new SegmentPoint(handleIn, this, '_handleIn');
      new SegmentPoint(handleOut, this, '_handleOut');
      if (selection) this.setSelection(selection);
    },
    _serialize: function (options, dictionary) {
      var point = this._point,
          selection = this._selection,
          obj = selection || this.hasHandles() ? [point, this._handleIn, this._handleOut] : point;
      if (selection) obj.push(selection);
      return Base.serialize(obj, options, true, dictionary);
    },
    _changed: function (point) {
      var path = this._path;
      if (!path) return;
      var curves = path._curves,
          index = this._index,
          curve;

      if (curves) {
        if ((!point || point === this._point || point === this._handleIn) && (curve = index > 0 ? curves[index - 1] : path._closed ? curves[curves.length - 1] : null)) curve._changed();
        if ((!point || point === this._point || point === this._handleOut) && (curve = curves[index])) curve._changed();
      }

      path._changed(41);
    },
    getPoint: function () {
      return this._point;
    },
    setPoint: function () {
      this._point.set(Point.read(arguments));
    },
    getHandleIn: function () {
      return this._handleIn;
    },
    setHandleIn: function () {
      this._handleIn.set(Point.read(arguments));
    },
    getHandleOut: function () {
      return this._handleOut;
    },
    setHandleOut: function () {
      this._handleOut.set(Point.read(arguments));
    },
    hasHandles: function () {
      return !this._handleIn.isZero() || !this._handleOut.isZero();
    },
    isSmooth: function () {
      var handleIn = this._handleIn,
          handleOut = this._handleOut;
      return !handleIn.isZero() && !handleOut.isZero() && handleIn.isCollinear(handleOut);
    },
    clearHandles: function () {
      this._handleIn._set(0, 0);

      this._handleOut._set(0, 0);
    },
    getSelection: function () {
      return this._selection;
    },
    setSelection: function (selection) {
      var oldSelection = this._selection,
          path = this._path;
      this._selection = selection = selection || 0;

      if (path && selection !== oldSelection) {
        path._updateSelection(this, oldSelection, selection);

        path._changed(257);
      }
    },
    _changeSelection: function (flag, selected) {
      var selection = this._selection;
      this.setSelection(selected ? selection | flag : selection & ~flag);
    },
    isSelected: function () {
      return !!(this._selection & 7);
    },
    setSelected: function (selected) {
      this._changeSelection(7, selected);
    },
    getIndex: function () {
      return this._index !== undefined ? this._index : null;
    },
    getPath: function () {
      return this._path || null;
    },
    getCurve: function () {
      var path = this._path,
          index = this._index;

      if (path) {
        if (index > 0 && !path._closed && index === path._segments.length - 1) index--;
        return path.getCurves()[index] || null;
      }

      return null;
    },
    getLocation: function () {
      var curve = this.getCurve();
      return curve ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1) : null;
    },
    getNext: function () {
      var segments = this._path && this._path._segments;
      return segments && (segments[this._index + 1] || this._path._closed && segments[0]) || null;
    },
    smooth: function (options, _first, _last) {
      var opts = options || {},
          type = opts.type,
          factor = opts.factor,
          prev = this.getPrevious(),
          next = this.getNext(),
          p0 = (prev || this)._point,
          p1 = this._point,
          p2 = (next || this)._point,
          d1 = p0.getDistance(p1),
          d2 = p1.getDistance(p2);

      if (!type || type === 'catmull-rom') {
        var a = factor === undefined ? 0.5 : factor,
            d1_a = Math.pow(d1, a),
            d1_2a = d1_a * d1_a,
            d2_a = Math.pow(d2, a),
            d2_2a = d2_a * d2_a;

        if (!_first && prev) {
          var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,
              N = 3 * d2_a * (d2_a + d1_a);
          this.setHandleIn(N !== 0 ? new Point((d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x, (d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y) : new Point());
        }

        if (!_last && next) {
          var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,
              N = 3 * d1_a * (d1_a + d2_a);
          this.setHandleOut(N !== 0 ? new Point((d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x, (d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y) : new Point());
        }
      } else if (type === 'geometric') {
        if (prev && next) {
          var vector = p0.subtract(p2),
              t = factor === undefined ? 0.4 : factor,
              k = t * d1 / (d1 + d2);
          if (!_first) this.setHandleIn(vector.multiply(k));
          if (!_last) this.setHandleOut(vector.multiply(k - t));
        }
      } else {
        throw new Error('Smoothing method \'' + type + '\' not supported.');
      }
    },
    getPrevious: function () {
      var segments = this._path && this._path._segments;
      return segments && (segments[this._index - 1] || this._path._closed && segments[segments.length - 1]) || null;
    },
    isFirst: function () {
      return !this._index;
    },
    isLast: function () {
      var path = this._path;
      return path && this._index === path._segments.length - 1 || false;
    },
    reverse: function () {
      var handleIn = this._handleIn,
          handleOut = this._handleOut,
          tmp = handleIn.clone();
      handleIn.set(handleOut);
      handleOut.set(tmp);
    },
    reversed: function () {
      return new Segment(this._point, this._handleOut, this._handleIn);
    },
    remove: function () {
      return this._path ? !!this._path.removeSegment(this._index) : false;
    },
    clone: function () {
      return new Segment(this._point, this._handleIn, this._handleOut);
    },
    equals: function (segment) {
      return segment === this || segment && this._class === segment._class && this._point.equals(segment._point) && this._handleIn.equals(segment._handleIn) && this._handleOut.equals(segment._handleOut) || false;
    },
    toString: function () {
      var parts = ['point: ' + this._point];
      if (!this._handleIn.isZero()) parts.push('handleIn: ' + this._handleIn);
      if (!this._handleOut.isZero()) parts.push('handleOut: ' + this._handleOut);
      return '{ ' + parts.join(', ') + ' }';
    },
    transform: function (matrix) {
      this._transformCoordinates(matrix, new Array(6), true);

      this._changed();
    },
    interpolate: function (from, to, factor) {
      var u = 1 - factor,
          v = factor,
          point1 = from._point,
          point2 = to._point,
          handleIn1 = from._handleIn,
          handleIn2 = to._handleIn,
          handleOut2 = to._handleOut,
          handleOut1 = from._handleOut;

      this._point._set(u * point1._x + v * point2._x, u * point1._y + v * point2._y, true);

      this._handleIn._set(u * handleIn1._x + v * handleIn2._x, u * handleIn1._y + v * handleIn2._y, true);

      this._handleOut._set(u * handleOut1._x + v * handleOut2._x, u * handleOut1._y + v * handleOut2._y, true);

      this._changed();
    },
    _transformCoordinates: function (matrix, coords, change) {
      var point = this._point,
          handleIn = !change || !this._handleIn.isZero() ? this._handleIn : null,
          handleOut = !change || !this._handleOut.isZero() ? this._handleOut : null,
          x = point._x,
          y = point._y,
          i = 2;
      coords[0] = x;
      coords[1] = y;

      if (handleIn) {
        coords[i++] = handleIn._x + x;
        coords[i++] = handleIn._y + y;
      }

      if (handleOut) {
        coords[i++] = handleOut._x + x;
        coords[i++] = handleOut._y + y;
      }

      if (matrix) {
        matrix._transformCoordinates(coords, coords, i / 2);

        x = coords[0];
        y = coords[1];

        if (change) {
          point._x = x;
          point._y = y;
          i = 2;

          if (handleIn) {
            handleIn._x = coords[i++] - x;
            handleIn._y = coords[i++] - y;
          }

          if (handleOut) {
            handleOut._x = coords[i++] - x;
            handleOut._y = coords[i++] - y;
          }
        } else {
          if (!handleIn) {
            coords[i++] = x;
            coords[i++] = y;
          }

          if (!handleOut) {
            coords[i++] = x;
            coords[i++] = y;
          }
        }
      }

      return coords;
    }
  });
  var SegmentPoint = Point.extend({
    initialize: function SegmentPoint(point, owner, key) {
      var x, y, selected;

      if (!point) {
        x = y = 0;
      } else if ((x = point[0]) !== undefined) {
        y = point[1];
      } else {
        var pt = point;

        if ((x = pt.x) === undefined) {
          pt = Point.read(arguments);
          x = pt.x;
        }

        y = pt.y;
        selected = pt.selected;
      }

      this._x = x;
      this._y = y;
      this._owner = owner;
      owner[key] = this;
      if (selected) this.setSelected(true);
    },
    _set: function (x, y) {
      this._x = x;
      this._y = y;

      this._owner._changed(this);

      return this;
    },
    getX: function () {
      return this._x;
    },
    setX: function (x) {
      this._x = x;

      this._owner._changed(this);
    },
    getY: function () {
      return this._y;
    },
    setY: function (y) {
      this._y = y;

      this._owner._changed(this);
    },
    isZero: function () {
      var isZero = Numerical.isZero;
      return isZero(this._x) && isZero(this._y);
    },
    isSelected: function () {
      return !!(this._owner._selection & this._getSelection());
    },
    setSelected: function (selected) {
      this._owner._changeSelection(this._getSelection(), selected);
    },
    _getSelection: function () {
      var owner = this._owner;
      return this === owner._point ? 1 : this === owner._handleIn ? 2 : this === owner._handleOut ? 4 : 0;
    }
  });
  var Curve = Base.extend({
    _class: 'Curve',
    beans: true,
    initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      var count = arguments.length,
          seg1,
          seg2,
          point1,
          point2,
          handle1,
          handle2;

      if (count === 3) {
        this._path = arg0;
        seg1 = arg1;
        seg2 = arg2;
      } else if (!count) {
        seg1 = new Segment();
        seg2 = new Segment();
      } else if (count === 1) {
        if ('segment1' in arg0) {
          seg1 = new Segment(arg0.segment1);
          seg2 = new Segment(arg0.segment2);
        } else if ('point1' in arg0) {
          point1 = arg0.point1;
          handle1 = arg0.handle1;
          handle2 = arg0.handle2;
          point2 = arg0.point2;
        } else if (Array.isArray(arg0)) {
          point1 = [arg0[0], arg0[1]];
          point2 = [arg0[6], arg0[7]];
          handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
          handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
        }
      } else if (count === 2) {
        seg1 = new Segment(arg0);
        seg2 = new Segment(arg1);
      } else if (count === 4) {
        point1 = arg0;
        handle1 = arg1;
        handle2 = arg2;
        point2 = arg3;
      } else if (count === 8) {
        point1 = [arg0, arg1];
        point2 = [arg6, arg7];
        handle1 = [arg2 - arg0, arg3 - arg1];
        handle2 = [arg4 - arg6, arg5 - arg7];
      }

      this._segment1 = seg1 || new Segment(point1, null, handle1);
      this._segment2 = seg2 || new Segment(point2, handle2, null);
    },
    _serialize: function (options, dictionary) {
      return Base.serialize(this.hasHandles() ? [this.getPoint1(), this.getHandle1(), this.getHandle2(), this.getPoint2()] : [this.getPoint1(), this.getPoint2()], options, true, dictionary);
    },
    _changed: function () {
      this._length = this._bounds = undefined;
    },
    clone: function () {
      return new Curve(this._segment1, this._segment2);
    },
    toString: function () {
      var parts = ['point1: ' + this._segment1._point];
      if (!this._segment1._handleOut.isZero()) parts.push('handle1: ' + this._segment1._handleOut);
      if (!this._segment2._handleIn.isZero()) parts.push('handle2: ' + this._segment2._handleIn);
      parts.push('point2: ' + this._segment2._point);
      return '{ ' + parts.join(', ') + ' }';
    },
    classify: function () {
      return Curve.classify(this.getValues());
    },
    remove: function () {
      var removed = false;

      if (this._path) {
        var segment2 = this._segment2,
            handleOut = segment2._handleOut;
        removed = segment2.remove();
        if (removed) this._segment1._handleOut.set(handleOut);
      }

      return removed;
    },
    getPoint1: function () {
      return this._segment1._point;
    },
    setPoint1: function () {
      this._segment1._point.set(Point.read(arguments));
    },
    getPoint2: function () {
      return this._segment2._point;
    },
    setPoint2: function () {
      this._segment2._point.set(Point.read(arguments));
    },
    getHandle1: function () {
      return this._segment1._handleOut;
    },
    setHandle1: function () {
      this._segment1._handleOut.set(Point.read(arguments));
    },
    getHandle2: function () {
      return this._segment2._handleIn;
    },
    setHandle2: function () {
      this._segment2._handleIn.set(Point.read(arguments));
    },
    getSegment1: function () {
      return this._segment1;
    },
    getSegment2: function () {
      return this._segment2;
    },
    getPath: function () {
      return this._path;
    },
    getIndex: function () {
      return this._segment1._index;
    },
    getNext: function () {
      var curves = this._path && this._path._curves;
      return curves && (curves[this._segment1._index + 1] || this._path._closed && curves[0]) || null;
    },
    getPrevious: function () {
      var curves = this._path && this._path._curves;
      return curves && (curves[this._segment1._index - 1] || this._path._closed && curves[curves.length - 1]) || null;
    },
    isFirst: function () {
      return !this._segment1._index;
    },
    isLast: function () {
      var path = this._path;
      return path && this._segment1._index === path._curves.length - 1 || false;
    },
    isSelected: function () {
      return this.getPoint1().isSelected() && this.getHandle1().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
    },
    setSelected: function (selected) {
      this.getPoint1().setSelected(selected);
      this.getHandle1().setSelected(selected);
      this.getHandle2().setSelected(selected);
      this.getPoint2().setSelected(selected);
    },
    getValues: function (matrix) {
      return Curve.getValues(this._segment1, this._segment2, matrix);
    },
    getPoints: function () {
      var coords = this.getValues(),
          points = [];

      for (var i = 0; i < 8; i += 2) points.push(new Point(coords[i], coords[i + 1]));

      return points;
    }
  }, {
    getLength: function () {
      if (this._length == null) this._length = Curve.getLength(this.getValues(), 0, 1);
      return this._length;
    },
    getArea: function () {
      return Curve.getArea(this.getValues());
    },
    getLine: function () {
      return new Line(this._segment1._point, this._segment2._point);
    },
    getPart: function (from, to) {
      return new Curve(Curve.getPart(this.getValues(), from, to));
    },
    getPartLength: function (from, to) {
      return Curve.getLength(this.getValues(), from, to);
    },
    divideAt: function (location) {
      return this.divideAtTime(location && location.curve === this ? location.time : this.getTimeAt(location));
    },
    divideAtTime: function (time, _setHandles) {
      var tMin = 1e-8,
          tMax = 1 - tMin,
          res = null;

      if (time >= tMin && time <= tMax) {
        var parts = Curve.subdivide(this.getValues(), time),
            left = parts[0],
            right = parts[1],
            setHandles = _setHandles || this.hasHandles(),
            seg1 = this._segment1,
            seg2 = this._segment2,
            path = this._path;

        if (setHandles) {
          seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);

          seg2._handleIn._set(right[4] - right[6], right[5] - right[7]);
        }

        var x = left[6],
            y = left[7],
            segment = new Segment(new Point(x, y), setHandles && new Point(left[4] - x, left[5] - y), setHandles && new Point(right[2] - x, right[3] - y));

        if (path) {
          path.insert(seg1._index + 1, segment);
          res = this.getNext();
        } else {
          this._segment2 = segment;

          this._changed();

          res = new Curve(segment, seg2);
        }
      }

      return res;
    },
    splitAt: function (location) {
      var path = this._path;
      return path ? path.splitAt(location) : null;
    },
    splitAtTime: function (time) {
      return this.splitAt(this.getLocationAtTime(time));
    },
    divide: function (offset, isTime) {
      return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset : this.getTimeAt(offset));
    },
    split: function (offset, isTime) {
      return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset : this.getTimeAt(offset));
    },
    reversed: function () {
      return new Curve(this._segment2.reversed(), this._segment1.reversed());
    },
    clearHandles: function () {
      this._segment1._handleOut._set(0, 0);

      this._segment2._handleIn._set(0, 0);
    },
    statics: {
      getValues: function (segment1, segment2, matrix, straight) {
        var p1 = segment1._point,
            h1 = segment1._handleOut,
            h2 = segment2._handleIn,
            p2 = segment2._point,
            x1 = p1.x,
            y1 = p1.y,
            x2 = p2.x,
            y2 = p2.y,
            values = straight ? [x1, y1, x1, y1, x2, y2, x2, y2] : [x1, y1, x1 + h1._x, y1 + h1._y, x2 + h2._x, y2 + h2._y, x2, y2];
        if (matrix) matrix._transformCoordinates(values, values, 4);
        return values;
      },
      subdivide: function (v, t) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7];
        if (t === undefined) t = 0.5;
        var u = 1 - t,
            x4 = u * x0 + t * x1,
            y4 = u * y0 + t * y1,
            x5 = u * x1 + t * x2,
            y5 = u * y1 + t * y2,
            x6 = u * x2 + t * x3,
            y6 = u * y2 + t * y3,
            x7 = u * x4 + t * x5,
            y7 = u * y4 + t * y5,
            x8 = u * x5 + t * x6,
            y8 = u * y5 + t * y6,
            x9 = u * x7 + t * x8,
            y9 = u * y7 + t * y8;
        return [[x0, y0, x4, y4, x7, y7, x9, y9], [x9, y9, x8, y8, x6, y6, x3, y3]];
      },
      getMonoCurves: function (v, dir) {
        var curves = [],
            io = dir ? 0 : 1,
            o0 = v[io + 0],
            o1 = v[io + 2],
            o2 = v[io + 4],
            o3 = v[io + 6];

        if (o0 >= o1 === o1 >= o2 && o1 >= o2 === o2 >= o3 || Curve.isStraight(v)) {
          curves.push(v);
        } else {
          var a = 3 * (o1 - o2) - o0 + o3,
              b = 2 * (o0 + o2) - 4 * o1,
              c = o1 - o0,
              tMin = 1e-8,
              tMax = 1 - tMin,
              roots = [],
              n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);

          if (!n) {
            curves.push(v);
          } else {
            roots.sort();
            var t = roots[0],
                parts = Curve.subdivide(v, t);
            curves.push(parts[0]);

            if (n > 1) {
              t = (roots[1] - t) / (1 - t);
              parts = Curve.subdivide(parts[1], t);
              curves.push(parts[0]);
            }

            curves.push(parts[1]);
          }
        }

        return curves;
      },
      solveCubic: function (v, coord, val, roots, min, max) {
        var v0 = v[coord],
            v1 = v[coord + 2],
            v2 = v[coord + 4],
            v3 = v[coord + 6],
            res = 0;

        if (!(v0 < val && v3 < val && v1 < val && v2 < val || v0 > val && v3 > val && v1 > val && v2 > val)) {
          var c = 3 * (v1 - v0),
              b = 3 * (v2 - v1) - c,
              a = v3 - v0 - c - b;
          res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);
        }

        return res;
      },
      getTimeOf: function (v, point) {
        var p0 = new Point(v[0], v[1]),
            p3 = new Point(v[6], v[7]),
            epsilon = 1e-12,
            geomEpsilon = 1e-7,
            t = point.isClose(p0, epsilon) ? 0 : point.isClose(p3, epsilon) ? 1 : null;

        if (t === null) {
          var coords = [point.x, point.y],
              roots = [];

          for (var c = 0; c < 2; c++) {
            var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);

            for (var i = 0; i < count; i++) {
              var u = roots[i];
              if (point.isClose(Curve.getPoint(v, u), geomEpsilon)) return u;
            }
          }
        }

        return point.isClose(p0, geomEpsilon) ? 0 : point.isClose(p3, geomEpsilon) ? 1 : null;
      },
      getNearestTime: function (v, point) {
        if (Curve.isStraight(v)) {
          var x0 = v[0],
              y0 = v[1],
              x3 = v[6],
              y3 = v[7],
              vx = x3 - x0,
              vy = y3 - y0,
              det = vx * vx + vy * vy;
          if (det === 0) return 0;
          var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
          return u < 1e-12 ? 0 : u > 0.999999999999 ? 1 : Curve.getTimeOf(v, new Point(x0 + u * vx, y0 + u * vy));
        }

        var count = 100,
            minDist = Infinity,
            minT = 0;

        function refine(t) {
          if (t >= 0 && t <= 1) {
            var dist = point.getDistance(Curve.getPoint(v, t), true);

            if (dist < minDist) {
              minDist = dist;
              minT = t;
              return true;
            }
          }
        }

        for (var i = 0; i <= count; i++) refine(i / count);

        var step = 1 / (count * 2);

        while (step > 1e-8) {
          if (!refine(minT - step) && !refine(minT + step)) step /= 2;
        }

        return minT;
      },
      getPart: function (v, from, to) {
        var flip = from > to;

        if (flip) {
          var tmp = from;
          from = to;
          to = tmp;
        }

        if (from > 0) v = Curve.subdivide(v, from)[1];
        if (to < 1) v = Curve.subdivide(v, (to - from) / (1 - from))[0];
        return flip ? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]] : v;
      },
      isFlatEnough: function (v, flatness) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7],
            ux = 3 * x1 - 2 * x0 - x3,
            uy = 3 * y1 - 2 * y0 - y3,
            vx = 3 * x2 - 2 * x3 - x0,
            vy = 3 * y2 - 2 * y3 - y0;
        return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy) <= 16 * flatness * flatness;
      },
      getArea: function (v) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7];
        return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2) + y1 * (x0 - x2) - x1 * (y0 - y2) + y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
      },
      getBounds: function (v) {
        var min = v.slice(0, 2),
            max = min.slice(),
            roots = [0, 0];

        for (var i = 0; i < 2; i++) Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6], i, 0, min, max, roots);

        return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      _addBounds: function (v0, v1, v2, v3, coord, padding, min, max, roots) {
        function add(value, padding) {
          var left = value - padding,
              right = value + padding;
          if (left < min[coord]) min[coord] = left;
          if (right > max[coord]) max[coord] = right;
        }

        padding /= 2;
        var minPad = min[coord] + padding,
            maxPad = max[coord] - padding;

        if (v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad || v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
          if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
            add(v0, 0);
            add(v3, 0);
          } else {
            var a = 3 * (v1 - v2) - v0 + v3,
                b = 2 * (v0 + v2) - 4 * v1,
                c = v1 - v0,
                count = Numerical.solveQuadratic(a, b, c, roots),
                tMin = 1e-8,
                tMax = 1 - tMin;
            add(v3, 0);

            for (var i = 0; i < count; i++) {
              var t = roots[i],
                  u = 1 - t;
              if (tMin <= t && t <= tMax) add(u * u * u * v0 + 3 * u * u * t * v1 + 3 * u * t * t * v2 + t * t * t * v3, padding);
            }
          }
        }
      }
    }
  }, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds'], function (name) {
    this[name] = function () {
      if (!this._bounds) this._bounds = {};
      var bounds = this._bounds[name];

      if (!bounds) {
        bounds = this._bounds[name] = Path[name]([this._segment1, this._segment2], false, this._path);
      }

      return bounds.clone();
    };
  }, {}), Base.each({
    isStraight: function (p1, h1, h2, p2) {
      if (h1.isZero() && h2.isZero()) {
        return true;
      } else {
        var v = p2.subtract(p1);

        if (v.isZero()) {
          return false;
        } else if (v.isCollinear(h1) && v.isCollinear(h2)) {
          var l = new Line(p1, p2),
              epsilon = 1e-7;

          if (l.getDistance(p1.add(h1)) < epsilon && l.getDistance(p2.add(h2)) < epsilon) {
            var div = v.dot(v),
                s1 = v.dot(h1) / div,
                s2 = v.dot(h2) / div;
            return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
          }
        }
      }

      return false;
    },
    isLinear: function (p1, h1, h2, p2) {
      var third = p2.subtract(p1).divide(3);
      return h1.equals(third) && h2.negate().equals(third);
    }
  }, function (test, name) {
    this[name] = function (epsilon) {
      var seg1 = this._segment1,
          seg2 = this._segment2;
      return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point, epsilon);
    };

    this.statics[name] = function (v, epsilon) {
      var x0 = v[0],
          y0 = v[1],
          x3 = v[6],
          y3 = v[7];
      return test(new Point(x0, y0), new Point(v[2] - x0, v[3] - y0), new Point(v[4] - x3, v[5] - y3), new Point(x3, y3), epsilon);
    };
  }, {
    statics: {},
    hasHandles: function () {
      return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero();
    },
    hasLength: function (epsilon) {
      return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (epsilon || 0);
    },
    isCollinear: function (curve) {
      return curve && this.isStraight() && curve.isStraight() && this.getLine().isCollinear(curve.getLine());
    },
    isHorizontal: function () {
      return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y) < 1e-8;
    },
    isVertical: function () {
      return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x) < 1e-8;
    }
  }), {
    beans: false,
    getLocationAt: function (offset, _isTime) {
      return this.getLocationAtTime(_isTime ? offset : this.getTimeAt(offset));
    },
    getLocationAtTime: function (t) {
      return t != null && t >= 0 && t <= 1 ? new CurveLocation(this, t) : null;
    },
    getTimeAt: function (offset, start) {
      return Curve.getTimeAt(this.getValues(), offset, start);
    },
    getParameterAt: '#getTimeAt',
    getTimesWithTangent: function () {
      var tangent = Point.read(arguments);
      return tangent.isZero() ? [] : Curve.getTimesWithTangent(this.getValues(), tangent);
    },
    getOffsetAtTime: function (t) {
      return this.getPartLength(0, t);
    },
    getLocationOf: function () {
      return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
    },
    getOffsetOf: function () {
      var loc = this.getLocationOf.apply(this, arguments);
      return loc ? loc.getOffset() : null;
    },
    getTimeOf: function () {
      return Curve.getTimeOf(this.getValues(), Point.read(arguments));
    },
    getParameterOf: '#getTimeOf',
    getNearestLocation: function () {
      var point = Point.read(arguments),
          values = this.getValues(),
          t = Curve.getNearestTime(values, point),
          pt = Curve.getPoint(values, t);
      return new CurveLocation(this, t, pt, null, point.getDistance(pt));
    },
    getNearestPoint: function () {
      var loc = this.getNearestLocation.apply(this, arguments);
      return loc ? loc.getPoint() : loc;
    }
  }, new function () {
    var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent', 'getWeightedNormal', 'getCurvature'];
    return Base.each(methods, function (name) {
      this[name + 'At'] = function (location, _isTime) {
        var values = this.getValues();
        return Curve[name](values, _isTime ? location : Curve.getTimeAt(values, location));
      };

      this[name + 'AtTime'] = function (time) {
        return Curve[name](this.getValues(), time);
      };
    }, {
      statics: {
        _evaluateMethods: methods
      }
    });
  }(), new function () {
    function getLengthIntegrand(v) {
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          ax = 9 * (x1 - x2) + 3 * (x3 - x0),
          bx = 6 * (x0 + x2) - 12 * x1,
          cx = 3 * (x1 - x0),
          ay = 9 * (y1 - y2) + 3 * (y3 - y0),
          by = 6 * (y0 + y2) - 12 * y1,
          cy = 3 * (y1 - y0);
      return function (t) {
        var dx = (ax * t + bx) * t + cx,
            dy = (ay * t + by) * t + cy;
        return Math.sqrt(dx * dx + dy * dy);
      };
    }

    function getIterations(a, b) {
      return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
    }

    function evaluate(v, t, type, normalized) {
      if (t == null || t < 0 || t > 1) return null;
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          isZero = Numerical.isZero;

      if (isZero(x1 - x0) && isZero(y1 - y0)) {
        x1 = x0;
        y1 = y0;
      }

      if (isZero(x2 - x3) && isZero(y2 - y3)) {
        x2 = x3;
        y2 = y3;
      }

      var cx = 3 * (x1 - x0),
          bx = 3 * (x2 - x1) - cx,
          ax = x3 - x0 - cx - bx,
          cy = 3 * (y1 - y0),
          by = 3 * (y2 - y1) - cy,
          ay = y3 - y0 - cy - by,
          x,
          y;

      if (type === 0) {
        x = t === 0 ? x0 : t === 1 ? x3 : ((ax * t + bx) * t + cx) * t + x0;
        y = t === 0 ? y0 : t === 1 ? y3 : ((ay * t + by) * t + cy) * t + y0;
      } else {
        var tMin = 1e-8,
            tMax = 1 - tMin;

        if (t < tMin) {
          x = cx;
          y = cy;
        } else if (t > tMax) {
          x = 3 * (x3 - x2);
          y = 3 * (y3 - y2);
        } else {
          x = (3 * ax * t + 2 * bx) * t + cx;
          y = (3 * ay * t + 2 * by) * t + cy;
        }

        if (normalized) {
          if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
            x = x2 - x1;
            y = y2 - y1;
          }

          var len = Math.sqrt(x * x + y * y);

          if (len) {
            x /= len;
            y /= len;
          }
        }

        if (type === 3) {
          var x2 = 6 * ax * t + 2 * bx,
              y2 = 6 * ay * t + 2 * by,
              d = Math.pow(x * x + y * y, 3 / 2);
          x = d !== 0 ? (x * y2 - y * x2) / d : 0;
          y = 0;
        }
      }

      return type === 2 ? new Point(y, -x) : new Point(x, y);
    }

    return {
      statics: {
        classify: function (v) {
          var x0 = v[0],
              y0 = v[1],
              x1 = v[2],
              y1 = v[3],
              x2 = v[4],
              y2 = v[5],
              x3 = v[6],
              y3 = v[7],
              a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,
              a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,
              a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,
              d3 = 3 * a3,
              d2 = d3 - a2,
              d1 = d2 - a2 + a1,
              l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),
              s = l !== 0 ? 1 / l : 0,
              isZero = Numerical.isZero,
              serpentine = 'serpentine';
          d1 *= s;
          d2 *= s;
          d3 *= s;

          function type(type, t1, t2) {
            var hasRoots = t1 !== undefined,
                t1Ok = hasRoots && t1 > 0 && t1 < 1,
                t2Ok = hasRoots && t2 > 0 && t2 < 1;

            if (hasRoots && (!(t1Ok || t2Ok) || type === 'loop' && !(t1Ok && t2Ok))) {
              type = 'arch';
              t1Ok = t2Ok = false;
            }

            return {
              type: type,
              roots: t1Ok || t2Ok ? t1Ok && t2Ok ? t1 < t2 ? [t1, t2] : [t2, t1] : [t1Ok ? t1 : t2] : null
            };
          }

          if (isZero(d1)) {
            return isZero(d2) ? type(isZero(d3) ? 'line' : 'quadratic') : type(serpentine, d3 / (3 * d2));
          }

          var d = 3 * d2 * d2 - 4 * d1 * d3;

          if (isZero(d)) {
            return type('cusp', d2 / (2 * d1));
          }

          var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),
              f2 = 2 * d1;
          return type(d > 0 ? serpentine : 'loop', (d2 + f1) / f2, (d2 - f1) / f2);
        },
        getLength: function (v, a, b, ds) {
          if (a === undefined) a = 0;
          if (b === undefined) b = 1;

          if (Curve.isStraight(v)) {
            var c = v;

            if (b < 1) {
              c = Curve.subdivide(c, b)[0];
              a /= b;
            }

            if (a > 0) {
              c = Curve.subdivide(c, a)[1];
            }

            var dx = c[6] - c[0],
                dy = c[7] - c[1];
            return Math.sqrt(dx * dx + dy * dy);
          }

          return Numerical.integrate(ds || getLengthIntegrand(v), a, b, getIterations(a, b));
        },
        getTimeAt: function (v, offset, start) {
          if (start === undefined) start = offset < 0 ? 1 : 0;
          if (offset === 0) return start;
          var abs = Math.abs,
              epsilon = 1e-12,
              forward = offset > 0,
              a = forward ? start : 0,
              b = forward ? 1 : start,
              ds = getLengthIntegrand(v),
              rangeLength = Curve.getLength(v, a, b, ds),
              diff = abs(offset) - rangeLength;

          if (abs(diff) < epsilon) {
            return forward ? b : a;
          } else if (diff > epsilon) {
            return null;
          }

          var guess = offset / rangeLength,
              length = 0;

          function f(t) {
            length += Numerical.integrate(ds, start, t, getIterations(start, t));
            start = t;
            return length - offset;
          }

          return Numerical.findRoot(f, ds, start + guess, a, b, 32, 1e-12);
        },
        getPoint: function (v, t) {
          return evaluate(v, t, 0, false);
        },
        getTangent: function (v, t) {
          return evaluate(v, t, 1, true);
        },
        getWeightedTangent: function (v, t) {
          return evaluate(v, t, 1, false);
        },
        getNormal: function (v, t) {
          return evaluate(v, t, 2, true);
        },
        getWeightedNormal: function (v, t) {
          return evaluate(v, t, 2, false);
        },
        getCurvature: function (v, t) {
          return evaluate(v, t, 3, false).x;
        },
        getPeaks: function (v) {
          var x0 = v[0],
              y0 = v[1],
              x1 = v[2],
              y1 = v[3],
              x2 = v[4],
              y2 = v[5],
              x3 = v[6],
              y3 = v[7],
              ax = -x0 + 3 * x1 - 3 * x2 + x3,
              bx = 3 * x0 - 6 * x1 + 3 * x2,
              cx = -3 * x0 + 3 * x1,
              ay = -y0 + 3 * y1 - 3 * y2 + y3,
              by = 3 * y0 - 6 * y1 + 3 * y2,
              cy = -3 * y0 + 3 * y1,
              tMin = 1e-8,
              tMax = 1 - tMin,
              roots = [];
          Numerical.solveCubic(9 * (ax * ax + ay * ay), 9 * (ax * bx + by * ay), 2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay), cx * bx + by * cy, roots, tMin, tMax);
          return roots.sort();
        }
      }
    };
  }(), new function () {
    function addLocation(locations, include, c1, t1, c2, t2, overlap) {
      var excludeStart = !overlap && c1.getPrevious() === c2,
          excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,
          tMin = 1e-8,
          tMax = 1 - tMin;

      if (t1 !== null && t1 >= (excludeStart ? tMin : 0) && t1 <= (excludeEnd ? tMax : 1)) {
        if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) && t2 <= (excludeStart ? tMax : 1)) {
          var loc1 = new CurveLocation(c1, t1, null, overlap),
              loc2 = new CurveLocation(c2, t2, null, overlap);
          loc1._intersection = loc2;
          loc2._intersection = loc1;

          if (!include || include(loc1)) {
            CurveLocation.insert(locations, loc1, true);
          }
        }
      }
    }

    function addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMin, tMax, uMin, uMax) {
      if (++calls >= 4096 || ++recursion >= 40) return calls;
      var fatLineEpsilon = 1e-9,
          q0x = v2[0],
          q0y = v2[1],
          q3x = v2[6],
          q3y = v2[7],
          getSignedDistance = Line.getSignedDistance,
          d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
          d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
          factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
          dMin = factor * Math.min(0, d1, d2),
          dMax = factor * Math.max(0, d1, d2),
          dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
          dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
          dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
          dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
          hull = getConvexHull(dp0, dp1, dp2, dp3),
          top = hull[0],
          bottom = hull[1],
          tMinClip,
          tMaxClip;
      if (d1 === 0 && d2 === 0 && dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0 || (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null || (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(), dMin, dMax)) == null) return calls;
      var tMinNew = tMin + (tMax - tMin) * tMinClip,
          tMaxNew = tMin + (tMax - tMin) * tMaxClip;

      if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
        var t = (tMinNew + tMaxNew) / 2,
            u = (uMin + uMax) / 2;
        addLocation(locations, include, flip ? c2 : c1, flip ? u : t, flip ? c1 : c2, flip ? t : u);
      } else {
        v1 = Curve.getPart(v1, tMinClip, tMaxClip);
        var uDiff = uMax - uMin;

        if (tMaxClip - tMinClip > 0.8) {
          if (tMaxNew - tMinNew > uDiff) {
            var parts = Curve.subdivide(v1, 0.5),
                t = (tMinNew + tMaxNew) / 2;
            calls = addCurveIntersections(v2, parts[0], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, t);
            calls = addCurveIntersections(v2, parts[1], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, t, tMaxNew);
          } else {
            var parts = Curve.subdivide(v2, 0.5),
                u = (uMin + uMax) / 2;
            calls = addCurveIntersections(parts[0], v1, c2, c1, locations, include, !flip, recursion, calls, uMin, u, tMinNew, tMaxNew);
            calls = addCurveIntersections(parts[1], v1, c2, c1, locations, include, !flip, recursion, calls, u, uMax, tMinNew, tMaxNew);
          }
        } else {
          if (uDiff === 0 || uDiff >= fatLineEpsilon) {
            calls = addCurveIntersections(v2, v1, c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, tMaxNew);
          } else {
            calls = addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMinNew, tMaxNew, uMin, uMax);
          }
        }
      }

      return calls;
    }

    function getConvexHull(dq0, dq1, dq2, dq3) {
      var p0 = [0, dq0],
          p1 = [1 / 3, dq1],
          p2 = [2 / 3, dq2],
          p3 = [1, dq3],
          dist1 = dq1 - (2 * dq0 + dq3) / 3,
          dist2 = dq2 - (dq0 + 2 * dq3) / 3,
          hull;

      if (dist1 * dist2 < 0) {
        hull = [[p0, p1, p3], [p0, p2, p3]];
      } else {
        var distRatio = dist1 / dist2;
        hull = [distRatio >= 2 ? [p0, p1, p3] : distRatio <= 0.5 ? [p0, p2, p3] : [p0, p1, p2, p3], [p0, p3]];
      }

      return (dist1 || dist2) < 0 ? hull.reverse() : hull;
    }

    function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
      if (hullTop[0][1] < dMin) {
        return clipConvexHullPart(hullTop, true, dMin);
      } else if (hullBottom[0][1] > dMax) {
        return clipConvexHullPart(hullBottom, false, dMax);
      } else {
        return hullTop[0][0];
      }
    }

    function clipConvexHullPart(part, top, threshold) {
      var px = part[0][0],
          py = part[0][1];

      for (var i = 1, l = part.length; i < l; i++) {
        var qx = part[i][0],
            qy = part[i][1];

        if (top ? qy >= threshold : qy <= threshold) {
          return qy === threshold ? qx : px + (threshold - py) * (qx - px) / (qy - py);
        }

        px = qx;
        py = qy;
      }

      return null;
    }

    function getCurveLineIntersections(v, px, py, vx, vy) {
      var isZero = Numerical.isZero;

      if (isZero(vx) && isZero(vy)) {
        var t = Curve.getTimeOf(v, new Point(px, py));
        return t === null ? [] : [t];
      }

      var angle = Math.atan2(-vy, vx),
          sin = Math.sin(angle),
          cos = Math.cos(angle),
          rv = [],
          roots = [];

      for (var i = 0; i < 8; i += 2) {
        var x = v[i] - px,
            y = v[i + 1] - py;
        rv.push(x * cos - y * sin, x * sin + y * cos);
      }

      Curve.solveCubic(rv, 1, 0, roots, 0, 1);
      return roots;
    }

    function addCurveLineIntersections(v1, v2, c1, c2, locations, include, flip) {
      var x1 = v2[0],
          y1 = v2[1],
          x2 = v2[6],
          y2 = v2[7],
          roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);

      for (var i = 0, l = roots.length; i < l; i++) {
        var t1 = roots[i],
            p1 = Curve.getPoint(v1, t1),
            t2 = Curve.getTimeOf(v2, p1);

        if (t2 !== null) {
          addLocation(locations, include, flip ? c2 : c1, flip ? t2 : t1, flip ? c1 : c2, flip ? t1 : t2);
        }
      }
    }

    function addLineIntersection(v1, v2, c1, c2, locations, include) {
      var pt = Line.intersect(v1[0], v1[1], v1[6], v1[7], v2[0], v2[1], v2[6], v2[7]);

      if (pt) {
        addLocation(locations, include, c1, Curve.getTimeOf(v1, pt), c2, Curve.getTimeOf(v2, pt));
      }
    }

    function getCurveIntersections(v1, v2, c1, c2, locations, include) {
      var epsilon = 1e-12,
          min = Math.min,
          max = Math.max;

      if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon > min(v2[0], v2[2], v2[4], v2[6]) && min(v1[0], v1[2], v1[4], v1[6]) - epsilon < max(v2[0], v2[2], v2[4], v2[6]) && max(v1[1], v1[3], v1[5], v1[7]) + epsilon > min(v2[1], v2[3], v2[5], v2[7]) && min(v1[1], v1[3], v1[5], v1[7]) - epsilon < max(v2[1], v2[3], v2[5], v2[7])) {
        var overlaps = getOverlaps(v1, v2);

        if (overlaps) {
          for (var i = 0; i < 2; i++) {
            var overlap = overlaps[i];
            addLocation(locations, include, c1, overlap[0], c2, overlap[1], true);
          }
        } else {
          var straight1 = Curve.isStraight(v1),
              straight2 = Curve.isStraight(v2),
              straight = straight1 && straight2,
              flip = straight1 && !straight2,
              before = locations.length;
          (straight ? addLineIntersection : straight1 || straight2 ? addCurveLineIntersections : addCurveIntersections)(flip ? v2 : v1, flip ? v1 : v2, flip ? c2 : c1, flip ? c1 : c2, locations, include, flip, 0, 0, 0, 1, 0, 1);

          if (!straight || locations.length === before) {
            for (var i = 0; i < 4; i++) {
              var t1 = i >> 1,
                  t2 = i & 1,
                  i1 = t1 * 6,
                  i2 = t2 * 6,
                  p1 = new Point(v1[i1], v1[i1 + 1]),
                  p2 = new Point(v2[i2], v2[i2 + 1]);

              if (p1.isClose(p2, epsilon)) {
                addLocation(locations, include, c1, t1, c2, t2);
              }
            }
          }
        }
      }

      return locations;
    }

    function getSelfIntersection(v1, c1, locations, include) {
      var info = Curve.classify(v1);

      if (info.type === 'loop') {
        var roots = info.roots;
        addLocation(locations, include, c1, roots[0], c1, roots[1]);
      }

      return locations;
    }

    function getIntersections(curves1, curves2, include, matrix1, matrix2, _returnFirst) {
      var epsilon = 1e-7,
          self = !curves2;
      if (self) curves2 = curves1;
      var length1 = curves1.length,
          length2 = curves2.length,
          values1 = new Array(length1),
          values2 = self ? values1 : new Array(length2),
          locations = [];

      for (var i = 0; i < length1; i++) {
        values1[i] = curves1[i].getValues(matrix1);
      }

      if (!self) {
        for (var i = 0; i < length2; i++) {
          values2[i] = curves2[i].getValues(matrix2);
        }
      }

      var boundsCollisions = CollisionDetection.findCurveBoundsCollisions(values1, values2, epsilon);

      for (var index1 = 0; index1 < length1; index1++) {
        var curve1 = curves1[index1],
            v1 = values1[index1];

        if (self) {
          getSelfIntersection(v1, curve1, locations, include);
        }

        var collisions1 = boundsCollisions[index1];

        if (collisions1) {
          for (var j = 0; j < collisions1.length; j++) {
            if (_returnFirst && locations.length) return locations;
            var index2 = collisions1[j];

            if (!self || index2 > index1) {
              var curve2 = curves2[index2],
                  v2 = values2[index2];
              getCurveIntersections(v1, v2, curve1, curve2, locations, include);
            }
          }
        }
      }

      return locations;
    }

    function getOverlaps(v1, v2) {
      function getSquaredLineLength(v) {
        var x = v[6] - v[0],
            y = v[7] - v[1];
        return x * x + y * y;
      }

      var abs = Math.abs,
          getDistance = Line.getDistance,
          timeEpsilon = 1e-8,
          geomEpsilon = 1e-7,
          straight1 = Curve.isStraight(v1),
          straight2 = Curve.isStraight(v2),
          straightBoth = straight1 && straight2,
          flip = getSquaredLineLength(v1) < getSquaredLineLength(v2),
          l1 = flip ? v2 : v1,
          l2 = flip ? v1 : v2,
          px = l1[0],
          py = l1[1],
          vx = l1[6] - px,
          vy = l1[7] - py;

      if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
        if (!straightBoth && getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
          straight1 = straight2 = straightBoth = true;
        }
      } else if (straightBoth) {
        return null;
      }

      if (straight1 ^ straight2) {
        return null;
      }

      var v = [v1, v2],
          pairs = [];

      for (var i = 0; i < 4 && pairs.length < 2; i++) {
        var i1 = i & 1,
            i2 = i1 ^ 1,
            t1 = i >> 1,
            t2 = Curve.getTimeOf(v[i1], new Point(v[i2][t1 ? 6 : 0], v[i2][t1 ? 7 : 1]));

        if (t2 != null) {
          var pair = i1 ? [t1, t2] : [t2, t1];

          if (!pairs.length || abs(pair[0] - pairs[0][0]) > timeEpsilon && abs(pair[1] - pairs[0][1]) > timeEpsilon) {
            pairs.push(pair);
          }
        }

        if (i > 2 && !pairs.length) break;
      }

      if (pairs.length !== 2) {
        pairs = null;
      } else if (!straightBoth) {
        var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
            o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
        if (abs(o2[2] - o1[2]) > geomEpsilon || abs(o2[3] - o1[3]) > geomEpsilon || abs(o2[4] - o1[4]) > geomEpsilon || abs(o2[5] - o1[5]) > geomEpsilon) pairs = null;
      }

      return pairs;
    }

    function getTimesWithTangent(v, tangent) {
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          normalized = tangent.normalize(),
          tx = normalized.x,
          ty = normalized.y,
          ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,
          ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,
          bx = 6 * x2 - 12 * x1 + 6 * x0,
          by = 6 * y2 - 12 * y1 + 6 * y0,
          cx = 3 * x1 - 3 * x0,
          cy = 3 * y1 - 3 * y0,
          den = 2 * ax * ty - 2 * ay * tx,
          times = [];

      if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {
        var num = ax * cy - ay * cx,
            den = ax * by - ay * bx;

        if (den != 0) {
          var t = -num / den;
          if (t >= 0 && t <= 1) times.push(t);
        }
      } else {
        var delta = (bx * bx - 4 * ax * cx) * ty * ty + (-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty + (by * by - 4 * ay * cy) * tx * tx,
            k = bx * ty - by * tx;

        if (delta >= 0 && den != 0) {
          var d = Math.sqrt(delta),
              t0 = -(k + d) / den,
              t1 = (-k + d) / den;
          if (t0 >= 0 && t0 <= 1) times.push(t0);
          if (t1 >= 0 && t1 <= 1) times.push(t1);
        }
      }

      return times;
    }

    return {
      getIntersections: function (curve) {
        var v1 = this.getValues(),
            v2 = curve && curve !== this && curve.getValues();
        return v2 ? getCurveIntersections(v1, v2, this, curve, []) : getSelfIntersection(v1, this, []);
      },
      statics: {
        getOverlaps: getOverlaps,
        getIntersections: getIntersections,
        getCurveLineIntersections: getCurveLineIntersections,
        getTimesWithTangent: getTimesWithTangent
      }
    };
  }());
  var CurveLocation = Base.extend({
    _class: 'CurveLocation',
    initialize: function CurveLocation(curve, time, point, _overlap, _distance) {
      if (time >= 0.99999999) {
        var next = curve.getNext();

        if (next) {
          time = 0;
          curve = next;
        }
      }

      this._setCurve(curve);

      this._time = time;
      this._point = point || curve.getPointAtTime(time);
      this._overlap = _overlap;
      this._distance = _distance;
      this._intersection = this._next = this._previous = null;
    },
    _setPath: function (path) {
      this._path = path;
      this._version = path ? path._version : 0;
    },
    _setCurve: function (curve) {
      this._setPath(curve._path);

      this._curve = curve;
      this._segment = null;
      this._segment1 = curve._segment1;
      this._segment2 = curve._segment2;
    },
    _setSegment: function (segment) {
      var curve = segment.getCurve();

      if (curve) {
        this._setCurve(curve);
      } else {
        this._setPath(segment._path);

        this._segment1 = segment;
        this._segment2 = null;
      }

      this._segment = segment;
      this._time = segment === this._segment1 ? 0 : 1;
      this._point = segment._point.clone();
    },
    getSegment: function () {
      var segment = this._segment;

      if (!segment) {
        var curve = this.getCurve(),
            time = this.getTime();

        if (time === 0) {
          segment = curve._segment1;
        } else if (time === 1) {
          segment = curve._segment2;
        } else if (time != null) {
          segment = curve.getPartLength(0, time) < curve.getPartLength(time, 1) ? curve._segment1 : curve._segment2;
        }

        this._segment = segment;
      }

      return segment;
    },
    getCurve: function () {
      var path = this._path,
          that = this;

      if (path && path._version !== this._version) {
        this._time = this._offset = this._curveOffset = this._curve = null;
      }

      function trySegment(segment) {
        var curve = segment && segment.getCurve();

        if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
          that._setCurve(curve);

          return curve;
        }
      }

      return this._curve || trySegment(this._segment) || trySegment(this._segment1) || trySegment(this._segment2.getPrevious());
    },
    getPath: function () {
      var curve = this.getCurve();
      return curve && curve._path;
    },
    getIndex: function () {
      var curve = this.getCurve();
      return curve && curve.getIndex();
    },
    getTime: function () {
      var curve = this.getCurve(),
          time = this._time;
      return curve && time == null ? this._time = curve.getTimeOf(this._point) : time;
    },
    getParameter: '#getTime',
    getPoint: function () {
      return this._point;
    },
    getOffset: function () {
      var offset = this._offset;

      if (offset == null) {
        offset = 0;
        var path = this.getPath(),
            index = this.getIndex();

        if (path && index != null) {
          var curves = path.getCurves();

          for (var i = 0; i < index; i++) offset += curves[i].getLength();
        }

        this._offset = offset += this.getCurveOffset();
      }

      return offset;
    },
    getCurveOffset: function () {
      var offset = this._curveOffset;

      if (offset == null) {
        var curve = this.getCurve(),
            time = this.getTime();
        this._curveOffset = offset = time != null && curve && curve.getPartLength(0, time);
      }

      return offset;
    },
    getIntersection: function () {
      return this._intersection;
    },
    getDistance: function () {
      return this._distance;
    },
    divide: function () {
      var curve = this.getCurve(),
          res = curve && curve.divideAtTime(this.getTime());

      if (res) {
        this._setSegment(res._segment1);
      }

      return res;
    },
    split: function () {
      var curve = this.getCurve(),
          path = curve._path,
          res = curve && curve.splitAtTime(this.getTime());

      if (res) {
        this._setSegment(path.getLastSegment());
      }

      return res;
    },
    equals: function (loc, _ignoreOther) {
      var res = this === loc;

      if (!res && loc instanceof CurveLocation) {
        var c1 = this.getCurve(),
            c2 = loc.getCurve(),
            p1 = c1._path,
            p2 = c2._path;

        if (p1 === p2) {
          var abs = Math.abs,
              epsilon = 1e-7,
              diff = abs(this.getOffset() - loc.getOffset()),
              i1 = !_ignoreOther && this._intersection,
              i2 = !_ignoreOther && loc._intersection;
          res = (diff < epsilon || p1 && abs(p1.getLength() - diff) < epsilon) && (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
        }
      }

      return res;
    },
    toString: function () {
      var parts = [],
          point = this.getPoint(),
          f = Formatter.instance;
      if (point) parts.push('point: ' + point);
      var index = this.getIndex();
      if (index != null) parts.push('index: ' + index);
      var time = this.getTime();
      if (time != null) parts.push('time: ' + f.number(time));
      if (this._distance != null) parts.push('distance: ' + f.number(this._distance));
      return '{ ' + parts.join(', ') + ' }';
    },
    isTouching: function () {
      var inter = this._intersection;

      if (inter && this.getTangent().isCollinear(inter.getTangent())) {
        var curve1 = this.getCurve(),
            curve2 = inter.getCurve();
        return !(curve1.isStraight() && curve2.isStraight() && curve1.getLine().intersect(curve2.getLine()));
      }

      return false;
    },
    isCrossing: function () {
      var inter = this._intersection;
      if (!inter) return false;
      var t1 = this.getTime(),
          t2 = inter.getTime(),
          tMin = 1e-8,
          tMax = 1 - tMin,
          t1Inside = t1 >= tMin && t1 <= tMax,
          t2Inside = t2 >= tMin && t2 <= tMax;
      if (t1Inside && t2Inside) return !this.isTouching();
      var c2 = this.getCurve(),
          c1 = c2 && t1 < tMin ? c2.getPrevious() : c2,
          c4 = inter.getCurve(),
          c3 = c4 && t2 < tMin ? c4.getPrevious() : c4;
      if (t1 > tMax) c2 = c2.getNext();
      if (t2 > tMax) c4 = c4.getNext();
      if (!c1 || !c2 || !c3 || !c4) return false;
      var offsets = [];

      function addOffsets(curve, end) {
        var v = curve.getValues(),
            roots = Curve.classify(v).roots || Curve.getPeaks(v),
            count = roots.length,
            offset = Curve.getLength(v, end && count ? roots[count - 1] : 0, !end && count ? roots[0] : 1);
        offsets.push(count ? offset : offset / 32);
      }

      function isInRange(angle, min, max) {
        return min < max ? angle > min && angle < max : angle > min || angle < max;
      }

      if (!t1Inside) {
        addOffsets(c1, true);
        addOffsets(c2, false);
      }

      if (!t2Inside) {
        addOffsets(c3, true);
        addOffsets(c4, false);
      }

      var pt = this.getPoint(),
          offset = Math.min.apply(Math, offsets),
          v2 = t1Inside ? c2.getTangentAtTime(t1) : c2.getPointAt(offset).subtract(pt),
          v1 = t1Inside ? v2.negate() : c1.getPointAt(-offset).subtract(pt),
          v4 = t2Inside ? c4.getTangentAtTime(t2) : c4.getPointAt(offset).subtract(pt),
          v3 = t2Inside ? v4.negate() : c3.getPointAt(-offset).subtract(pt),
          a1 = v1.getAngle(),
          a2 = v2.getAngle(),
          a3 = v3.getAngle(),
          a4 = v4.getAngle();
      return !!(t1Inside ? isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4) && isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3) : isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2) && isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));
    },
    hasOverlap: function () {
      return !!this._overlap;
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    var get = name + 'At';

    this[name] = function () {
      var curve = this.getCurve(),
          time = this.getTime();
      return time != null && curve && curve[get](time, true);
    };
  }, {
    preserve: true
  }), new function () {
    function insert(locations, loc, merge) {
      var length = locations.length,
          l = 0,
          r = length - 1;

      function search(index, dir) {
        for (var i = index + dir; i >= -1 && i <= length; i += dir) {
          var loc2 = locations[(i % length + length) % length];
          if (!loc.getPoint().isClose(loc2.getPoint(), 1e-7)) break;
          if (loc.equals(loc2)) return loc2;
        }

        return null;
      }

      while (l <= r) {
        var m = l + r >>> 1,
            loc2 = locations[m],
            found;

        if (merge && (found = loc.equals(loc2) ? loc2 : search(m, -1) || search(m, 1))) {
          if (loc._overlap) {
            found._overlap = found._intersection._overlap = true;
          }

          return found;
        }

        var path1 = loc.getPath(),
            path2 = loc2.getPath(),
            diff = path1 !== path2 ? path1._id - path2._id : loc.getIndex() + loc.getTime() - (loc2.getIndex() + loc2.getTime());

        if (diff < 0) {
          r = m - 1;
        } else {
          l = m + 1;
        }
      }

      locations.splice(l, 0, loc);
      return loc;
    }

    return {
      statics: {
        insert: insert,
        expand: function (locations) {
          var expanded = locations.slice();

          for (var i = locations.length - 1; i >= 0; i--) {
            insert(expanded, locations[i]._intersection, false);
          }

          return expanded;
        }
      }
    };
  }());
  var PathItem = Item.extend({
    _class: 'PathItem',
    _selectBounds: false,
    _canScaleStroke: true,
    beans: true,
    initialize: function PathItem() {},
    statics: {
      create: function (arg) {
        var data, segments, compound;

        if (Base.isPlainObject(arg)) {
          segments = arg.segments;
          data = arg.pathData;
        } else if (Array.isArray(arg)) {
          segments = arg;
        } else if (typeof arg === 'string') {
          data = arg;
        }

        if (segments) {
          var first = segments[0];
          compound = first && Array.isArray(first[0]);
        } else if (data) {
          compound = (data.match(/m/gi) || []).length > 1 || /z\s*\S+/i.test(data);
        }

        var ctor = compound ? CompoundPath : Path;
        return new ctor(arg);
      }
    },
    _asPathItem: function () {
      return this;
    },
    isClockwise: function () {
      return this.getArea() >= 0;
    },
    setClockwise: function (clockwise) {
      if (this.isClockwise() != (clockwise = !!clockwise)) this.reverse();
    },
    setPathData: function (data) {
      var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
          coords,
          relative = false,
          previous,
          control,
          current = new Point(),
          start = new Point();

      function getCoord(index, coord) {
        var val = +coords[index];
        if (relative) val += current[coord];
        return val;
      }

      function getPoint(index) {
        return new Point(getCoord(index, 'x'), getCoord(index + 1, 'y'));
      }

      this.clear();

      for (var i = 0, l = parts && parts.length; i < l; i++) {
        var part = parts[i],
            command = part[0],
            lower = command.toLowerCase();
        coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
        var length = coords && coords.length;
        relative = command === lower;
        if (previous === 'z' && !/[mz]/.test(lower)) this.moveTo(current);

        switch (lower) {
          case 'm':
          case 'l':
            var move = lower === 'm';

            for (var j = 0; j < length; j += 2) {
              this[move ? 'moveTo' : 'lineTo'](current = getPoint(j));

              if (move) {
                start = current;
                move = false;
              }
            }

            control = current;
            break;

          case 'h':
          case 'v':
            var coord = lower === 'h' ? 'x' : 'y';
            current = current.clone();

            for (var j = 0; j < length; j++) {
              current[coord] = getCoord(j, coord);
              this.lineTo(current);
            }

            control = current;
            break;

          case 'c':
            for (var j = 0; j < length; j += 6) {
              this.cubicCurveTo(getPoint(j), control = getPoint(j + 2), current = getPoint(j + 4));
            }

            break;

          case 's':
            for (var j = 0; j < length; j += 4) {
              this.cubicCurveTo(/[cs]/.test(previous) ? current.multiply(2).subtract(control) : current, control = getPoint(j), current = getPoint(j + 2));
              previous = lower;
            }

            break;

          case 'q':
            for (var j = 0; j < length; j += 4) {
              this.quadraticCurveTo(control = getPoint(j), current = getPoint(j + 2));
            }

            break;

          case 't':
            for (var j = 0; j < length; j += 2) {
              this.quadraticCurveTo(control = /[qt]/.test(previous) ? current.multiply(2).subtract(control) : current, current = getPoint(j));
              previous = lower;
            }

            break;

          case 'a':
            for (var j = 0; j < length; j += 7) {
              this.arcTo(current = getPoint(j + 5), new Size(+coords[j], +coords[j + 1]), +coords[j + 2], +coords[j + 4], +coords[j + 3]);
            }

            break;

          case 'z':
            this.closePath(1e-12);
            current = start;
            break;
        }

        previous = lower;
      }
    },
    _canComposite: function () {
      return !(this.hasFill() && this.hasStroke());
    },
    _contains: function (point) {
      var winding = point.isInside(this.getBounds({
        internal: true,
        handle: true
      })) ? this._getWinding(point) : {};
      return winding.onPath || !!(this.getFillRule() === 'evenodd' ? winding.windingL & 1 || winding.windingR & 1 : winding.winding);
    },
    getIntersections: function (path, include, _matrix, _returnFirst) {
      var self = this === path || !path,
          matrix1 = this._matrix._orNullIfIdentity(),
          matrix2 = self ? matrix1 : (_matrix || path._matrix)._orNullIfIdentity();

      return self || this.getBounds(matrix1).intersects(path.getBounds(matrix2), 1e-12) ? Curve.getIntersections(this.getCurves(), !self && path.getCurves(), include, matrix1, matrix2, _returnFirst) : [];
    },
    getCrossings: function (path) {
      return this.getIntersections(path, function (inter) {
        return inter.isCrossing();
      });
    },
    getNearestLocation: function () {
      var point = Point.read(arguments),
          curves = this.getCurves(),
          minDist = Infinity,
          minLoc = null;

      for (var i = 0, l = curves.length; i < l; i++) {
        var loc = curves[i].getNearestLocation(point);

        if (loc._distance < minDist) {
          minDist = loc._distance;
          minLoc = loc;
        }
      }

      return minLoc;
    },
    getNearestPoint: function () {
      var loc = this.getNearestLocation.apply(this, arguments);
      return loc ? loc.getPoint() : loc;
    },
    interpolate: function (from, to, factor) {
      var isPath = !this._children,
          name = isPath ? '_segments' : '_children',
          itemsFrom = from[name],
          itemsTo = to[name],
          items = this[name];

      if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
        throw new Error('Invalid operands in interpolate() call: ' + from + ', ' + to);
      }

      var current = items.length,
          length = itemsTo.length;

      if (current < length) {
        var ctor = isPath ? Segment : Path;

        for (var i = current; i < length; i++) {
          this.add(new ctor());
        }
      } else if (current > length) {
        this[isPath ? 'removeSegments' : 'removeChildren'](length, current);
      }

      for (var i = 0; i < length; i++) {
        items[i].interpolate(itemsFrom[i], itemsTo[i], factor);
      }

      if (isPath) {
        this.setClosed(from._closed);

        this._changed(9);
      }
    },
    compare: function (path) {
      var ok = false;

      if (path) {
        var paths1 = this._children || [this],
            paths2 = path._children ? path._children.slice() : [path],
            length1 = paths1.length,
            length2 = paths2.length,
            matched = [],
            count = 0;
        ok = true;
        var boundsOverlaps = CollisionDetection.findItemBoundsCollisions(paths1, paths2, Numerical.GEOMETRIC_EPSILON);

        for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
          var path1 = paths1[i1];
          ok = false;
          var pathBoundsOverlaps = boundsOverlaps[i1];

          if (pathBoundsOverlaps) {
            for (var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--) {
              if (path1.compare(paths2[pathBoundsOverlaps[i2]])) {
                if (!matched[pathBoundsOverlaps[i2]]) {
                  matched[pathBoundsOverlaps[i2]] = true;
                  count++;
                }

                ok = true;
              }
            }
          }
        }

        ok = ok && count === length2;
      }

      return ok;
    }
  });
  var Path = PathItem.extend({
    _class: 'Path',
    _serializeFields: {
      segments: [],
      closed: false
    },
    initialize: function Path(arg) {
      this._closed = false;
      this._segments = [];
      this._version = 0;
      var args = arguments,
          segments = Array.isArray(arg) ? typeof arg[0] === 'object' ? arg : args : arg && arg.size === undefined && (arg.x !== undefined || arg.point !== undefined) ? args : null;

      if (segments && segments.length > 0) {
        this.setSegments(segments);
      } else {
        this._curves = undefined;
        this._segmentSelection = 0;

        if (!segments && typeof arg === 'string') {
          this.setPathData(arg);
          arg = null;
        }
      }

      this._initialize(!segments && arg);
    },
    _equals: function (item) {
      return this._closed === item._closed && Base.equals(this._segments, item._segments);
    },
    copyContent: function (source) {
      this.setSegments(source._segments);
      this._closed = source._closed;
    },
    _changed: function _changed(flags) {
      _changed.base.call(this, flags);

      if (flags & 8) {
        this._length = this._area = undefined;

        if (flags & 32) {
          this._version++;
        } else if (this._curves) {
          for (var i = 0, l = this._curves.length; i < l; i++) this._curves[i]._changed();
        }
      } else if (flags & 64) {
        this._bounds = undefined;
      }
    },
    getStyle: function () {
      var parent = this._parent;
      return (parent instanceof CompoundPath ? parent : this)._style;
    },
    getSegments: function () {
      return this._segments;
    },
    setSegments: function (segments) {
      var fullySelected = this.isFullySelected(),
          length = segments && segments.length;
      this._segments.length = 0;
      this._segmentSelection = 0;
      this._curves = undefined;

      if (length) {
        var last = segments[length - 1];

        if (typeof last === 'boolean') {
          this.setClosed(last);
          length--;
        }

        this._add(Segment.readList(segments, 0, {}, length));
      }

      if (fullySelected) this.setFullySelected(true);
    },
    getFirstSegment: function () {
      return this._segments[0];
    },
    getLastSegment: function () {
      return this._segments[this._segments.length - 1];
    },
    getCurves: function () {
      var curves = this._curves,
          segments = this._segments;

      if (!curves) {
        var length = this._countCurves();

        curves = this._curves = new Array(length);

        for (var i = 0; i < length; i++) curves[i] = new Curve(this, segments[i], segments[i + 1] || segments[0]);
      }

      return curves;
    },
    getFirstCurve: function () {
      return this.getCurves()[0];
    },
    getLastCurve: function () {
      var curves = this.getCurves();
      return curves[curves.length - 1];
    },
    isClosed: function () {
      return this._closed;
    },
    setClosed: function (closed) {
      if (this._closed != (closed = !!closed)) {
        this._closed = closed;

        if (this._curves) {
          var length = this._curves.length = this._countCurves();

          if (closed) this._curves[length - 1] = new Curve(this, this._segments[length - 1], this._segments[0]);
        }

        this._changed(41);
      }
    }
  }, {
    beans: true,
    getPathData: function (_matrix, _precision) {
      var segments = this._segments,
          length = segments.length,
          f = new Formatter(_precision),
          coords = new Array(6),
          first = true,
          curX,
          curY,
          prevX,
          prevY,
          inX,
          inY,
          outX,
          outY,
          parts = [];

      function addSegment(segment, skipLine) {
        segment._transformCoordinates(_matrix, coords);

        curX = coords[0];
        curY = coords[1];

        if (first) {
          parts.push('M' + f.pair(curX, curY));
          first = false;
        } else {
          inX = coords[2];
          inY = coords[3];

          if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
            if (!skipLine) {
              var dx = curX - prevX,
                  dy = curY - prevY;
              parts.push(dx === 0 ? 'v' + f.number(dy) : dy === 0 ? 'h' + f.number(dx) : 'l' + f.pair(dx, dy));
            }
          } else {
            parts.push('c' + f.pair(outX - prevX, outY - prevY) + ' ' + f.pair(inX - prevX, inY - prevY) + ' ' + f.pair(curX - prevX, curY - prevY));
          }
        }

        prevX = curX;
        prevY = curY;
        outX = coords[4];
        outY = coords[5];
      }

      if (!length) return '';

      for (var i = 0; i < length; i++) addSegment(segments[i]);

      if (this._closed && length > 0) {
        addSegment(segments[0], true);
        parts.push('z');
      }

      return parts.join('');
    },
    isEmpty: function () {
      return !this._segments.length;
    },
    _transformContent: function (matrix) {
      var segments = this._segments,
          coords = new Array(6);

      for (var i = 0, l = segments.length; i < l; i++) segments[i]._transformCoordinates(matrix, coords, true);

      return true;
    },
    _add: function (segs, index) {
      var segments = this._segments,
          curves = this._curves,
          amount = segs.length,
          append = index == null,
          index = append ? segments.length : index;

      for (var i = 0; i < amount; i++) {
        var segment = segs[i];
        if (segment._path) segment = segs[i] = segment.clone();
        segment._path = this;
        segment._index = index + i;
        if (segment._selection) this._updateSelection(segment, 0, segment._selection);
      }

      if (append) {
        Base.push(segments, segs);
      } else {
        segments.splice.apply(segments, [index, 0].concat(segs));

        for (var i = index + amount, l = segments.length; i < l; i++) segments[i]._index = i;
      }

      if (curves) {
        var total = this._countCurves(),
            start = index > 0 && index + amount - 1 === total ? index - 1 : index,
            insert = start,
            end = Math.min(start + amount, total);

        if (segs._curves) {
          curves.splice.apply(curves, [start, 0].concat(segs._curves));
          insert += segs._curves.length;
        }

        for (var i = insert; i < end; i++) curves.splice(i, 0, new Curve(this, null, null));

        this._adjustCurves(start, end);
      }

      this._changed(41);

      return segs;
    },
    _adjustCurves: function (start, end) {
      var segments = this._segments,
          curves = this._curves,
          curve;

      for (var i = start; i < end; i++) {
        curve = curves[i];
        curve._path = this;
        curve._segment1 = segments[i];
        curve._segment2 = segments[i + 1] || segments[0];

        curve._changed();
      }

      if (curve = curves[this._closed && !start ? segments.length - 1 : start - 1]) {
        curve._segment2 = segments[start] || segments[0];

        curve._changed();
      }

      if (curve = curves[end]) {
        curve._segment1 = segments[end];

        curve._changed();
      }
    },
    _countCurves: function () {
      var length = this._segments.length;
      return !this._closed && length > 0 ? length - 1 : length;
    },
    add: function (segment1) {
      var args = arguments;
      return args.length > 1 && typeof segment1 !== 'number' ? this._add(Segment.readList(args)) : this._add([Segment.read(args)])[0];
    },
    insert: function (index, segment1) {
      var args = arguments;
      return args.length > 2 && typeof segment1 !== 'number' ? this._add(Segment.readList(args, 1), index) : this._add([Segment.read(args, 1)], index)[0];
    },
    addSegment: function () {
      return this._add([Segment.read(arguments)])[0];
    },
    insertSegment: function (index) {
      return this._add([Segment.read(arguments, 1)], index)[0];
    },
    addSegments: function (segments) {
      return this._add(Segment.readList(segments));
    },
    insertSegments: function (index, segments) {
      return this._add(Segment.readList(segments), index);
    },
    removeSegment: function (index) {
      return this.removeSegments(index, index + 1)[0] || null;
    },
    removeSegments: function (start, end, _includeCurves) {
      start = start || 0;
      end = Base.pick(end, this._segments.length);
      var segments = this._segments,
          curves = this._curves,
          count = segments.length,
          removed = segments.splice(start, end - start),
          amount = removed.length;
      if (!amount) return removed;

      for (var i = 0; i < amount; i++) {
        var segment = removed[i];
        if (segment._selection) this._updateSelection(segment, segment._selection, 0);
        segment._index = segment._path = null;
      }

      for (var i = start, l = segments.length; i < l; i++) segments[i]._index = i;

      if (curves) {
        var index = start > 0 && end === count + (this._closed ? 1 : 0) ? start - 1 : start,
            curves = curves.splice(index, amount);

        for (var i = curves.length - 1; i >= 0; i--) curves[i]._path = null;

        if (_includeCurves) removed._curves = curves.slice(1);

        this._adjustCurves(index, index);
      }

      this._changed(41);

      return removed;
    },
    clear: '#removeSegments',
    hasHandles: function () {
      var segments = this._segments;

      for (var i = 0, l = segments.length; i < l; i++) {
        if (segments[i].hasHandles()) return true;
      }

      return false;
    },
    clearHandles: function () {
      var segments = this._segments;

      for (var i = 0, l = segments.length; i < l; i++) segments[i].clearHandles();
    },
    getLength: function () {
      if (this._length == null) {
        var curves = this.getCurves(),
            length = 0;

        for (var i = 0, l = curves.length; i < l; i++) length += curves[i].getLength();

        this._length = length;
      }

      return this._length;
    },
    getArea: function () {
      var area = this._area;

      if (area == null) {
        var segments = this._segments,
            closed = this._closed;
        area = 0;

        for (var i = 0, l = segments.length; i < l; i++) {
          var last = i + 1 === l;
          area += Curve.getArea(Curve.getValues(segments[i], segments[last ? 0 : i + 1], null, last && !closed));
        }

        this._area = area;
      }

      return area;
    },
    isFullySelected: function () {
      var length = this._segments.length;
      return this.isSelected() && length > 0 && this._segmentSelection === length * 7;
    },
    setFullySelected: function (selected) {
      if (selected) this._selectSegments(true);
      this.setSelected(selected);
    },
    setSelection: function setSelection(selection) {
      if (!(selection & 1)) this._selectSegments(false);
      setSelection.base.call(this, selection);
    },
    _selectSegments: function (selected) {
      var segments = this._segments,
          length = segments.length,
          selection = selected ? 7 : 0;
      this._segmentSelection = selection * length;

      for (var i = 0; i < length; i++) segments[i]._selection = selection;
    },
    _updateSelection: function (segment, oldSelection, newSelection) {
      segment._selection = newSelection;
      var selection = this._segmentSelection += newSelection - oldSelection;
      if (selection > 0) this.setSelected(true);
    },
    divideAt: function (location) {
      var loc = this.getLocationAt(location),
          curve;
      return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset())) ? curve._segment1 : null;
    },
    splitAt: function (location) {
      var loc = this.getLocationAt(location),
          index = loc && loc.index,
          time = loc && loc.time,
          tMin = 1e-8,
          tMax = 1 - tMin;

      if (time > tMax) {
        index++;
        time = 0;
      }

      var curves = this.getCurves();

      if (index >= 0 && index < curves.length) {
        if (time >= tMin) {
          curves[index++].divideAtTime(time);
        }

        var segs = this.removeSegments(index, this._segments.length, true),
            path;

        if (this._closed) {
          this.setClosed(false);
          path = this;
        } else {
          path = new Path(Item.NO_INSERT);
          path.insertAbove(this);
          path.copyAttributes(this);
        }

        path._add(segs, 0);

        this.addSegment(segs[0]);
        return path;
      }

      return null;
    },
    split: function (index, time) {
      var curve,
          location = time === undefined ? index : (curve = this.getCurves()[index]) && curve.getLocationAtTime(time);
      return location != null ? this.splitAt(location) : null;
    },
    join: function (path, tolerance) {
      var epsilon = tolerance || 0;

      if (path && path !== this) {
        var segments = path._segments,
            last1 = this.getLastSegment(),
            last2 = path.getLastSegment();
        if (!last2) return this;
        if (last1 && last1._point.isClose(last2._point, epsilon)) path.reverse();
        var first2 = path.getFirstSegment();

        if (last1 && last1._point.isClose(first2._point, epsilon)) {
          last1.setHandleOut(first2._handleOut);

          this._add(segments.slice(1));
        } else {
          var first1 = this.getFirstSegment();
          if (first1 && first1._point.isClose(first2._point, epsilon)) path.reverse();
          last2 = path.getLastSegment();

          if (first1 && first1._point.isClose(last2._point, epsilon)) {
            first1.setHandleIn(last2._handleIn);

            this._add(segments.slice(0, segments.length - 1), 0);
          } else {
            this._add(segments.slice());
          }
        }

        if (path._closed) this._add([segments[0]]);
        path.remove();
      }

      var first = this.getFirstSegment(),
          last = this.getLastSegment();

      if (first !== last && first._point.isClose(last._point, epsilon)) {
        first.setHandleIn(last._handleIn);
        last.remove();
        this.setClosed(true);
      }

      return this;
    },
    reduce: function (options) {
      var curves = this.getCurves(),
          simplify = options && options.simplify,
          tolerance = simplify ? 1e-7 : 0;

      for (var i = curves.length - 1; i >= 0; i--) {
        var curve = curves[i];
        if (!curve.hasHandles() && (!curve.hasLength(tolerance) || simplify && curve.isCollinear(curve.getNext()))) curve.remove();
      }

      return this;
    },
    reverse: function () {
      this._segments.reverse();

      for (var i = 0, l = this._segments.length; i < l; i++) {
        var segment = this._segments[i];
        var handleIn = segment._handleIn;
        segment._handleIn = segment._handleOut;
        segment._handleOut = handleIn;
        segment._index = i;
      }

      this._curves = null;

      this._changed(9);
    },
    flatten: function (flatness) {
      var flattener = new PathFlattener(this, flatness || 0.25, 256, true),
          parts = flattener.parts,
          length = parts.length,
          segments = [];

      for (var i = 0; i < length; i++) {
        segments.push(new Segment(parts[i].curve.slice(0, 2)));
      }

      if (!this._closed && length > 0) {
        segments.push(new Segment(parts[length - 1].curve.slice(6)));
      }

      this.setSegments(segments);
    },
    simplify: function (tolerance) {
      var segments = new PathFitter(this).fit(tolerance || 2.5);
      if (segments) this.setSegments(segments);
      return !!segments;
    },
    smooth: function (options) {
      var that = this,
          opts = options || {},
          type = opts.type || 'asymmetric',
          segments = this._segments,
          length = segments.length,
          closed = this._closed;

      function getIndex(value, _default) {
        var index = value && value.index;

        if (index != null) {
          var path = value.path;
          if (path && path !== that) throw new Error(value._class + ' ' + index + ' of ' + path + ' is not part of ' + that);
          if (_default && value instanceof Curve) index++;
        } else {
          index = typeof value === 'number' ? value : _default;
        }

        return Math.min(index < 0 && closed ? index % length : index < 0 ? index + length : index, length - 1);
      }

      var loop = closed && opts.from === undefined && opts.to === undefined,
          from = getIndex(opts.from, 0),
          to = getIndex(opts.to, length - 1);

      if (from > to) {
        if (closed) {
          from -= length;
        } else {
          var tmp = from;
          from = to;
          to = tmp;
        }
      }

      if (/^(?:asymmetric|continuous)$/.test(type)) {
        var asymmetric = type === 'asymmetric',
            min = Math.min,
            amount = to - from + 1,
            n = amount - 1,
            padding = loop ? min(amount, 4) : 1,
            paddingLeft = padding,
            paddingRight = padding,
            knots = [];

        if (!closed) {
          paddingLeft = min(1, from);
          paddingRight = min(1, length - to - 1);
        }

        n += paddingLeft + paddingRight;
        if (n <= 1) return;

        for (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {
          knots[i] = segments[(j < 0 ? j + length : j) % length]._point;
        }

        var x = knots[0]._x + 2 * knots[1]._x,
            y = knots[0]._y + 2 * knots[1]._y,
            f = 2,
            n_1 = n - 1,
            rx = [x],
            ry = [y],
            rf = [f],
            px = [],
            py = [];

        for (var i = 1; i < n; i++) {
          var internal = i < n_1,
              a = internal ? 1 : asymmetric ? 1 : 2,
              b = internal ? 4 : asymmetric ? 2 : 7,
              u = internal ? 4 : asymmetric ? 3 : 8,
              v = internal ? 2 : asymmetric ? 0 : 1,
              m = a / f;
          f = rf[i] = b - m;
          x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;
          y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;
        }

        px[n_1] = rx[n_1] / rf[n_1];
        py[n_1] = ry[n_1] / rf[n_1];

        for (var i = n - 2; i >= 0; i--) {
          px[i] = (rx[i] - px[i + 1]) / rf[i];
          py[i] = (ry[i] - py[i + 1]) / rf[i];
        }

        px[n] = (3 * knots[n]._x - px[n_1]) / 2;
        py[n] = (3 * knots[n]._y - py[n_1]) / 2;

        for (var i = paddingLeft, max = n - paddingRight, j = from; i <= max; i++, j++) {
          var segment = segments[j < 0 ? j + length : j],
              pt = segment._point,
              hx = px[i] - pt._x,
              hy = py[i] - pt._y;
          if (loop || i < max) segment.setHandleOut(hx, hy);
          if (loop || i > paddingLeft) segment.setHandleIn(-hx, -hy);
        }
      } else {
        for (var i = from; i <= to; i++) {
          segments[i < 0 ? i + length : i].smooth(opts, !loop && i === from, !loop && i === to);
        }
      }
    },
    toShape: function (insert) {
      if (!this._closed) return null;
      var segments = this._segments,
          type,
          size,
          radius,
          topCenter;

      function isCollinear(i, j) {
        var seg1 = segments[i],
            seg2 = seg1.getNext(),
            seg3 = segments[j],
            seg4 = seg3.getNext();
        return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg3._handleOut.isZero() && seg4._handleIn.isZero() && seg2._point.subtract(seg1._point).isCollinear(seg4._point.subtract(seg3._point));
      }

      function isOrthogonal(i) {
        var seg2 = segments[i],
            seg1 = seg2.getPrevious(),
            seg3 = seg2.getNext();
        return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg2._handleOut.isZero() && seg3._handleIn.isZero() && seg2._point.subtract(seg1._point).isOrthogonal(seg3._point.subtract(seg2._point));
      }

      function isArc(i) {
        var seg1 = segments[i],
            seg2 = seg1.getNext(),
            handle1 = seg1._handleOut,
            handle2 = seg2._handleIn,
            kappa = 0.5522847498307936;

        if (handle1.isOrthogonal(handle2)) {
          var pt1 = seg1._point,
              pt2 = seg2._point,
              corner = new Line(pt1, handle1, true).intersect(new Line(pt2, handle2, true), true);
          return corner && Numerical.isZero(handle1.getLength() / corner.subtract(pt1).getLength() - kappa) && Numerical.isZero(handle2.getLength() / corner.subtract(pt2).getLength() - kappa);
        }

        return false;
      }

      function getDistance(i, j) {
        return segments[i]._point.getDistance(segments[j]._point);
      }

      if (!this.hasHandles() && segments.length === 4 && isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
        type = Shape.Rectangle;
        size = new Size(getDistance(0, 3), getDistance(0, 1));
        topCenter = segments[1]._point.add(segments[2]._point).divide(2);
      } else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4) && isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
        type = Shape.Rectangle;
        size = new Size(getDistance(1, 6), getDistance(0, 3));
        radius = size.subtract(new Size(getDistance(0, 7), getDistance(1, 2))).divide(2);
        topCenter = segments[3]._point.add(segments[4]._point).divide(2);
      } else if (segments.length === 4 && isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
        if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
          type = Shape.Circle;
          radius = getDistance(0, 2) / 2;
        } else {
          type = Shape.Ellipse;
          radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
        }

        topCenter = segments[1]._point;
      }

      if (type) {
        var center = this.getPosition(true),
            shape = new type({
          center: center,
          size: size,
          radius: radius,
          insert: false
        });
        shape.copyAttributes(this, true);

        shape._matrix.prepend(this._matrix);

        shape.rotate(topCenter.subtract(center).getAngle() + 90);
        if (insert === undefined || insert) shape.insertAbove(this);
        return shape;
      }

      return null;
    },
    toPath: '#clone',
    compare: function compare(path) {
      if (!path || path instanceof CompoundPath) return compare.base.call(this, path);
      var curves1 = this.getCurves(),
          curves2 = path.getCurves(),
          length1 = curves1.length,
          length2 = curves2.length;

      if (!length1 || !length2) {
        return length1 == length2;
      }

      var v1 = curves1[0].getValues(),
          values2 = [],
          pos1 = 0,
          pos2,
          end1 = 0,
          end2;

      for (var i = 0; i < length2; i++) {
        var v2 = curves2[i].getValues();
        values2.push(v2);
        var overlaps = Curve.getOverlaps(v1, v2);

        if (overlaps) {
          pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;
          end2 = overlaps[0][1];
          break;
        }
      }

      var abs = Math.abs,
          epsilon = 1e-8,
          v2 = values2[pos2],
          start2;

      while (v1 && v2) {
        var overlaps = Curve.getOverlaps(v1, v2);

        if (overlaps) {
          var t1 = overlaps[0][0];

          if (abs(t1 - end1) < epsilon) {
            end1 = overlaps[1][0];

            if (end1 === 1) {
              v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
              end1 = 0;
            }

            var t2 = overlaps[0][1];

            if (abs(t2 - end2) < epsilon) {
              if (!start2) start2 = [pos2, t2];
              end2 = overlaps[1][1];

              if (end2 === 1) {
                if (++pos2 >= length2) pos2 = 0;
                v2 = values2[pos2] || curves2[pos2].getValues();
                end2 = 0;
              }

              if (!v1) {
                return start2[0] === pos2 && start2[1] === end2;
              }

              continue;
            }
          }
        }

        break;
      }

      return false;
    },
    _hitTestSelf: function (point, options, viewMatrix, strokeMatrix) {
      var that = this,
          style = this.getStyle(),
          segments = this._segments,
          numSegments = segments.length,
          closed = this._closed,
          tolerancePadding = options._tolerancePadding,
          strokePadding = tolerancePadding,
          join,
          cap,
          miterLimit,
          area,
          loc,
          res,
          hitStroke = options.stroke && style.hasStroke(),
          hitFill = options.fill && style.hasFill(),
          hitCurves = options.curves,
          strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : hitFill && options.tolerance > 0 || hitCurves ? 0 : null;

      if (strokeRadius !== null) {
        if (strokeRadius > 0) {
          join = style.getStrokeJoin();
          cap = style.getStrokeCap();
          miterLimit = style.getMiterLimit();
          strokePadding = strokePadding.add(Path._getStrokePadding(strokeRadius, strokeMatrix));
        } else {
          join = cap = 'round';
        }
      }

      function isCloseEnough(pt, padding) {
        return point.subtract(pt).divide(padding).length <= 1;
      }

      function checkSegmentPoint(seg, pt, name) {
        if (!options.selected || pt.isSelected()) {
          var anchor = seg._point;
          if (pt !== anchor) pt = pt.add(anchor);

          if (isCloseEnough(pt, strokePadding)) {
            return new HitResult(name, that, {
              segment: seg,
              point: pt
            });
          }
        }
      }

      function checkSegmentPoints(seg, ends) {
        return (ends || options.segments) && checkSegmentPoint(seg, seg._point, 'segment') || !ends && options.handles && (checkSegmentPoint(seg, seg._handleIn, 'handle-in') || checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
      }

      function addToArea(point) {
        area.add(point);
      }

      function checkSegmentStroke(segment) {
        var isJoin = closed || segment._index > 0 && segment._index < numSegments - 1;

        if ((isJoin ? join : cap) === 'round') {
          return isCloseEnough(segment._point, strokePadding);
        } else {
          area = new Path({
            internal: true,
            closed: true
          });

          if (isJoin) {
            if (!segment.isSmooth()) {
              Path._addBevelJoin(segment, join, strokeRadius, miterLimit, null, strokeMatrix, addToArea, true);
            }
          } else if (cap === 'square') {
            Path._addSquareCap(segment, cap, strokeRadius, null, strokeMatrix, addToArea, true);
          }

          if (!area.isEmpty()) {
            var loc;
            return area.contains(point) || (loc = area.getNearestLocation(point)) && isCloseEnough(loc.getPoint(), tolerancePadding);
          }
        }
      }

      if (options.ends && !options.segments && !closed) {
        if (res = checkSegmentPoints(segments[0], true) || checkSegmentPoints(segments[numSegments - 1], true)) return res;
      } else if (options.segments || options.handles) {
        for (var i = 0; i < numSegments; i++) if (res = checkSegmentPoints(segments[i])) return res;
      }

      if (strokeRadius !== null) {
        loc = this.getNearestLocation(point);

        if (loc) {
          var time = loc.getTime();

          if (time === 0 || time === 1 && numSegments > 1) {
            if (!checkSegmentStroke(loc.getSegment())) loc = null;
          } else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
            loc = null;
          }
        }

        if (!loc && join === 'miter' && numSegments > 1) {
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];

            if (point.getDistance(segment._point) <= miterLimit * strokeRadius && checkSegmentStroke(segment)) {
              loc = segment.getLocation();
              break;
            }
          }
        }
      }

      return !loc && hitFill && this._contains(point) || loc && !hitStroke && !hitCurves ? new HitResult('fill', this) : loc ? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
        location: loc,
        point: loc.getPoint()
      }) : null;
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    this[name + 'At'] = function (offset) {
      var loc = this.getLocationAt(offset);
      return loc && loc[name]();
    };
  }, {
    beans: false,
    getLocationOf: function () {
      var point = Point.read(arguments),
          curves = this.getCurves();

      for (var i = 0, l = curves.length; i < l; i++) {
        var loc = curves[i].getLocationOf(point);
        if (loc) return loc;
      }

      return null;
    },
    getOffsetOf: function () {
      var loc = this.getLocationOf.apply(this, arguments);
      return loc ? loc.getOffset() : null;
    },
    getLocationAt: function (offset) {
      if (typeof offset === 'number') {
        var curves = this.getCurves(),
            length = 0;

        for (var i = 0, l = curves.length; i < l; i++) {
          var start = length,
              curve = curves[i];
          length += curve.getLength();

          if (length > offset) {
            return curve.getLocationAt(offset - start);
          }
        }

        if (curves.length > 0 && offset <= this.getLength()) {
          return new CurveLocation(curves[curves.length - 1], 1);
        }
      } else if (offset && offset.getPath && offset.getPath() === this) {
        return offset;
      }

      return null;
    },
    getOffsetsWithTangent: function () {
      var tangent = Point.read(arguments);

      if (tangent.isZero()) {
        return [];
      }

      var offsets = [];
      var curveStart = 0;
      var curves = this.getCurves();

      for (var i = 0, l = curves.length; i < l; i++) {
        var curve = curves[i];
        var curveTimes = curve.getTimesWithTangent(tangent);

        for (var j = 0, m = curveTimes.length; j < m; j++) {
          var offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);

          if (offsets.indexOf(offset) < 0) {
            offsets.push(offset);
          }
        }

        curveStart += curve.length;
      }

      return offsets;
    }
  }), new function () {
    function drawHandles(ctx, segments, matrix, size) {
      if (size <= 0) return;
      var half = size / 2,
          miniSize = size - 2,
          miniHalf = half - 1,
          coords = new Array(6),
          pX,
          pY;

      function drawHandle(index) {
        var hX = coords[index],
            hY = coords[index + 1];

        if (pX != hX || pY != hY) {
          ctx.beginPath();
          ctx.moveTo(pX, pY);
          ctx.lineTo(hX, hY);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
          ctx.fill();
        }
      }

      for (var i = 0, l = segments.length; i < l; i++) {
        var segment = segments[i],
            selection = segment._selection;

        segment._transformCoordinates(matrix, coords);

        pX = coords[0];
        pY = coords[1];
        if (selection & 2) drawHandle(2);
        if (selection & 4) drawHandle(4);
        ctx.fillRect(pX - half, pY - half, size, size);

        if (miniSize > 0 && !(selection & 1)) {
          var fillStyle = ctx.fillStyle;
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);
          ctx.fillStyle = fillStyle;
        }
      }
    }

    function drawSegments(ctx, path, matrix) {
      var segments = path._segments,
          length = segments.length,
          coords = new Array(6),
          first = true,
          curX,
          curY,
          prevX,
          prevY,
          inX,
          inY,
          outX,
          outY;

      function drawSegment(segment) {
        if (matrix) {
          segment._transformCoordinates(matrix, coords);

          curX = coords[0];
          curY = coords[1];
        } else {
          var point = segment._point;
          curX = point._x;
          curY = point._y;
        }

        if (first) {
          ctx.moveTo(curX, curY);
          first = false;
        } else {
          if (matrix) {
            inX = coords[2];
            inY = coords[3];
          } else {
            var handle = segment._handleIn;
            inX = curX + handle._x;
            inY = curY + handle._y;
          }

          if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
            ctx.lineTo(curX, curY);
          } else {
            ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
          }
        }

        prevX = curX;
        prevY = curY;

        if (matrix) {
          outX = coords[4];
          outY = coords[5];
        } else {
          var handle = segment._handleOut;
          outX = prevX + handle._x;
          outY = prevY + handle._y;
        }
      }

      for (var i = 0; i < length; i++) drawSegment(segments[i]);

      if (path._closed && length > 0) drawSegment(segments[0]);
    }

    return {
      _draw: function (ctx, param, viewMatrix, strokeMatrix) {
        var dontStart = param.dontStart,
            dontPaint = param.dontFinish || param.clip,
            style = this.getStyle(),
            hasFill = style.hasFill(),
            hasStroke = style.hasStroke(),
            dashArray = style.getDashArray(),
            dashLength = !paper.support.nativeDash && hasStroke && dashArray && dashArray.length;
        if (!dontStart) ctx.beginPath();

        if (hasFill || hasStroke && !dashLength || dontPaint) {
          drawSegments(ctx, this, strokeMatrix);
          if (this._closed) ctx.closePath();
        }

        function getOffset(i) {
          return dashArray[(i % dashLength + dashLength) % dashLength];
        }

        if (!dontPaint && (hasFill || hasStroke)) {
          this._setStyles(ctx, param, viewMatrix);

          if (hasFill) {
            ctx.fill(style.getFillRule());
            ctx.shadowColor = 'rgba(0,0,0,0)';
          }

          if (hasStroke) {
            if (dashLength) {
              if (!dontStart) ctx.beginPath();
              var flattener = new PathFlattener(this, 0.25, 32, false, strokeMatrix),
                  length = flattener.length,
                  from = -style.getDashOffset(),
                  to,
                  i = 0;

              while (from > 0) {
                from -= getOffset(i--) + getOffset(i--);
              }

              while (from < length) {
                to = from + getOffset(i++);
                if (from > 0 || to > 0) flattener.drawPart(ctx, Math.max(from, 0), Math.max(to, 0));
                from = to + getOffset(i++);
              }
            }

            ctx.stroke();
          }
        }
      },
      _drawSelected: function (ctx, matrix) {
        ctx.beginPath();
        drawSegments(ctx, this, matrix);
        ctx.stroke();
        drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
      }
    };
  }(), new function () {
    function getCurrentSegment(that) {
      var segments = that._segments;
      if (!segments.length) throw new Error('Use a moveTo() command first');
      return segments[segments.length - 1];
    }

    return {
      moveTo: function () {
        var segments = this._segments;
        if (segments.length === 1) this.removeSegment(0);
        if (!segments.length) this._add([new Segment(Point.read(arguments))]);
      },
      moveBy: function () {
        throw new Error('moveBy() is unsupported on Path items.');
      },
      lineTo: function () {
        this._add([new Segment(Point.read(arguments))]);
      },
      cubicCurveTo: function () {
        var args = arguments,
            handle1 = Point.read(args),
            handle2 = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this);
        current.setHandleOut(handle1.subtract(current._point));

        this._add([new Segment(to, handle2.subtract(to))]);
      },
      quadraticCurveTo: function () {
        var args = arguments,
            handle = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.cubicCurveTo(handle.add(current.subtract(handle).multiply(1 / 3)), handle.add(to.subtract(handle).multiply(1 / 3)), to);
      },
      curveTo: function () {
        var args = arguments,
            through = Point.read(args),
            to = Point.read(args),
            t = Base.pick(Base.read(args), 0.5),
            t1 = 1 - t,
            current = getCurrentSegment(this)._point,
            handle = through.subtract(current.multiply(t1 * t1)).subtract(to.multiply(t * t)).divide(2 * t * t1);

        if (handle.isNaN()) throw new Error('Cannot put a curve through points with parameter = ' + t);
        this.quadraticCurveTo(handle, to);
      },
      arcTo: function () {
        var args = arguments,
            abs = Math.abs,
            sqrt = Math.sqrt,
            current = getCurrentSegment(this),
            from = current._point,
            to = Point.read(args),
            through,
            peek = Base.peek(args),
            clockwise = Base.pick(peek, true),
            center,
            extent,
            vector,
            matrix;

        if (typeof clockwise === 'boolean') {
          var middle = from.add(to).divide(2),
              through = middle.add(middle.subtract(from).rotate(clockwise ? -90 : 90));
        } else if (Base.remain(args) <= 2) {
          through = to;
          to = Point.read(args);
        } else if (!from.equals(to)) {
          var radius = Size.read(args),
              isZero = Numerical.isZero;
          if (isZero(radius.width) || isZero(radius.height)) return this.lineTo(to);
          var rotation = Base.read(args),
              clockwise = !!Base.read(args),
              large = !!Base.read(args),
              middle = from.add(to).divide(2),
              pt = from.subtract(middle).rotate(-rotation),
              x = pt.x,
              y = pt.y,
              rx = abs(radius.width),
              ry = abs(radius.height),
              rxSq = rx * rx,
              rySq = ry * ry,
              xSq = x * x,
              ySq = y * y;
          var factor = sqrt(xSq / rxSq + ySq / rySq);

          if (factor > 1) {
            rx *= factor;
            ry *= factor;
            rxSq = rx * rx;
            rySq = ry * ry;
          }

          factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) / (rxSq * ySq + rySq * xSq);
          if (abs(factor) < 1e-12) factor = 0;
          if (factor < 0) throw new Error('Cannot create an arc with the given arguments');
          center = new Point(rx * y / ry, -ry * x / rx).multiply((large === clockwise ? -1 : 1) * sqrt(factor)).rotate(rotation).add(middle);
          matrix = new Matrix().translate(center).rotate(rotation).scale(rx, ry);
          vector = matrix._inverseTransform(from);
          extent = vector.getDirectedAngle(matrix._inverseTransform(to));
          if (!clockwise && extent > 0) extent -= 360;else if (clockwise && extent < 0) extent += 360;
        }

        if (through) {
          var l1 = new Line(from.add(through).divide(2), through.subtract(from).rotate(90), true),
              l2 = new Line(through.add(to).divide(2), to.subtract(through).rotate(90), true),
              line = new Line(from, to),
              throughSide = line.getSide(through);
          center = l1.intersect(l2, true);

          if (!center) {
            if (!throughSide) return this.lineTo(to);
            throw new Error('Cannot create an arc with the given arguments');
          }

          vector = from.subtract(center);
          extent = vector.getDirectedAngle(to.subtract(center));
          var centerSide = line.getSide(center, true);

          if (centerSide === 0) {
            extent = throughSide * abs(extent);
          } else if (throughSide === centerSide) {
            extent += extent < 0 ? 360 : -360;
          }
        }

        if (extent) {
          var epsilon = 1e-7,
              ext = abs(extent),
              count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),
              inc = extent / count,
              half = inc * Math.PI / 360,
              z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
              segments = [];

          for (var i = 0; i <= count; i++) {
            var pt = to,
                out = null;

            if (i < count) {
              out = vector.rotate(90).multiply(z);

              if (matrix) {
                pt = matrix._transformPoint(vector);
                out = matrix._transformPoint(vector.add(out)).subtract(pt);
              } else {
                pt = center.add(vector);
              }
            }

            if (!i) {
              current.setHandleOut(out);
            } else {
              var _in = vector.rotate(-90).multiply(z);

              if (matrix) {
                _in = matrix._transformPoint(vector.add(_in)).subtract(pt);
              }

              segments.push(new Segment(pt, _in, out));
            }

            vector = vector.rotate(inc);
          }

          this._add(segments);
        }
      },
      lineBy: function () {
        var to = Point.read(arguments),
            current = getCurrentSegment(this)._point;

        this.lineTo(current.add(to));
      },
      curveBy: function () {
        var args = arguments,
            through = Point.read(args),
            to = Point.read(args),
            parameter = Base.read(args),
            current = getCurrentSegment(this)._point;

        this.curveTo(current.add(through), current.add(to), parameter);
      },
      cubicCurveBy: function () {
        var args = arguments,
            handle1 = Point.read(args),
            handle2 = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.cubicCurveTo(current.add(handle1), current.add(handle2), current.add(to));
      },
      quadraticCurveBy: function () {
        var args = arguments,
            handle = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.quadraticCurveTo(current.add(handle), current.add(to));
      },
      arcBy: function () {
        var args = arguments,
            current = getCurrentSegment(this)._point,
            point = current.add(Point.read(args)),
            clockwise = Base.pick(Base.peek(args), true);

        if (typeof clockwise === 'boolean') {
          this.arcTo(point, clockwise);
        } else {
          this.arcTo(point, current.add(Point.read(args)));
        }
      },
      closePath: function (tolerance) {
        this.setClosed(true);
        this.join(this, tolerance);
      }
    };
  }(), {
    _getBounds: function (matrix, options) {
      var method = options.handle ? 'getHandleBounds' : options.stroke ? 'getStrokeBounds' : 'getBounds';
      return Path[method](this._segments, this._closed, this, matrix, options);
    },
    statics: {
      getBounds: function (segments, closed, path, matrix, options, strokePadding) {
        var first = segments[0];
        if (!first) return new Rectangle();

        var coords = new Array(6),
            prevCoords = first._transformCoordinates(matrix, new Array(6)),
            min = prevCoords.slice(0, 2),
            max = min.slice(),
            roots = new Array(2);

        function processSegment(segment) {
          segment._transformCoordinates(matrix, coords);

          for (var i = 0; i < 2; i++) {
            Curve._addBounds(prevCoords[i], prevCoords[i + 4], coords[i + 2], coords[i], i, strokePadding ? strokePadding[i] : 0, min, max, roots);
          }

          var tmp = prevCoords;
          prevCoords = coords;
          coords = tmp;
        }

        for (var i = 1, l = segments.length; i < l; i++) processSegment(segments[i]);

        if (closed) processSegment(first);
        return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      getStrokeBounds: function (segments, closed, path, matrix, options) {
        var style = path.getStyle(),
            stroke = style.hasStroke(),
            strokeWidth = style.getStrokeWidth(),
            strokeMatrix = stroke && path._getStrokeMatrix(matrix, options),
            strokePadding = stroke && Path._getStrokePadding(strokeWidth, strokeMatrix),
            bounds = Path.getBounds(segments, closed, path, matrix, options, strokePadding);

        if (!stroke) return bounds;
        var strokeRadius = strokeWidth / 2,
            join = style.getStrokeJoin(),
            cap = style.getStrokeCap(),
            miterLimit = style.getMiterLimit(),
            joinBounds = new Rectangle(new Size(strokePadding));

        function addPoint(point) {
          bounds = bounds.include(point);
        }

        function addRound(segment) {
          bounds = bounds.unite(joinBounds.setCenter(segment._point.transform(matrix)));
        }

        function addJoin(segment, join) {
          if (join === 'round' || segment.isSmooth()) {
            addRound(segment);
          } else {
            Path._addBevelJoin(segment, join, strokeRadius, miterLimit, matrix, strokeMatrix, addPoint);
          }
        }

        function addCap(segment, cap) {
          if (cap === 'round') {
            addRound(segment);
          } else {
            Path._addSquareCap(segment, cap, strokeRadius, matrix, strokeMatrix, addPoint);
          }
        }

        var length = segments.length - (closed ? 0 : 1);

        if (length > 0) {
          for (var i = 1; i < length; i++) {
            addJoin(segments[i], join);
          }

          if (closed) {
            addJoin(segments[0], join);
          } else {
            addCap(segments[0], cap);
            addCap(segments[segments.length - 1], cap);
          }
        }

        return bounds;
      },
      _getStrokePadding: function (radius, matrix) {
        if (!matrix) return [radius, radius];
        var hor = new Point(radius, 0).transform(matrix),
            ver = new Point(0, radius).transform(matrix),
            phi = hor.getAngleInRadians(),
            a = hor.getLength(),
            b = ver.getLength();
        var sin = Math.sin(phi),
            cos = Math.cos(phi),
            tan = Math.tan(phi),
            tx = Math.atan2(b * tan, a),
            ty = Math.atan2(b, tan * a);
        return [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin), Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
      },
      _addBevelJoin: function (segment, join, radius, miterLimit, matrix, strokeMatrix, addPoint, isArea) {
        var curve2 = segment.getCurve(),
            curve1 = curve2.getPrevious(),
            point = curve2.getPoint1().transform(matrix),
            normal1 = curve1.getNormalAtTime(1).multiply(radius).transform(strokeMatrix),
            normal2 = curve2.getNormalAtTime(0).multiply(radius).transform(strokeMatrix),
            angle = normal1.getDirectedAngle(normal2);

        if (angle < 0 || angle >= 180) {
          normal1 = normal1.negate();
          normal2 = normal2.negate();
        }

        if (isArea) addPoint(point);
        addPoint(point.add(normal1));

        if (join === 'miter') {
          var corner = new Line(point.add(normal1), new Point(-normal1.y, normal1.x), true).intersect(new Line(point.add(normal2), new Point(-normal2.y, normal2.x), true), true);

          if (corner && point.getDistance(corner) <= miterLimit * radius) {
            addPoint(corner);
          }
        }

        addPoint(point.add(normal2));
      },
      _addSquareCap: function (segment, cap, radius, matrix, strokeMatrix, addPoint, isArea) {
        var point = segment._point.transform(matrix),
            loc = segment.getLocation(),
            normal = loc.getNormal().multiply(loc.getTime() === 0 ? radius : -radius).transform(strokeMatrix);

        if (cap === 'square') {
          if (isArea) {
            addPoint(point.subtract(normal));
            addPoint(point.add(normal));
          }

          point = point.add(normal.rotate(-90));
        }

        addPoint(point.add(normal));
        addPoint(point.subtract(normal));
      },
      getHandleBounds: function (segments, closed, path, matrix, options) {
        var style = path.getStyle(),
            stroke = options.stroke && style.hasStroke(),
            strokePadding,
            joinPadding;

        if (stroke) {
          var strokeMatrix = path._getStrokeMatrix(matrix, options),
              strokeRadius = style.getStrokeWidth() / 2,
              joinRadius = strokeRadius;

          if (style.getStrokeJoin() === 'miter') joinRadius = strokeRadius * style.getMiterLimit();
          if (style.getStrokeCap() === 'square') joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
          strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
          joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
        }

        var coords = new Array(6),
            x1 = Infinity,
            x2 = -x1,
            y1 = x1,
            y2 = x2;

        for (var i = 0, l = segments.length; i < l; i++) {
          var segment = segments[i];

          segment._transformCoordinates(matrix, coords);

          for (var j = 0; j < 6; j += 2) {
            var padding = !j ? joinPadding : strokePadding,
                paddingX = padding ? padding[0] : 0,
                paddingY = padding ? padding[1] : 0,
                x = coords[j],
                y = coords[j + 1],
                xn = x - paddingX,
                xx = x + paddingX,
                yn = y - paddingY,
                yx = y + paddingY;
            if (xn < x1) x1 = xn;
            if (xx > x2) x2 = xx;
            if (yn < y1) y1 = yn;
            if (yx > y2) y2 = yx;
          }
        }

        return new Rectangle(x1, y1, x2 - x1, y2 - y1);
      }
    }
  });
  Path.inject({
    statics: new function () {
      var kappa = 0.5522847498307936,
          ellipseSegments = [new Segment([-1, 0], [0, kappa], [0, -kappa]), new Segment([0, -1], [-kappa, 0], [kappa, 0]), new Segment([1, 0], [0, -kappa], [0, kappa]), new Segment([0, 1], [kappa, 0], [-kappa, 0])];

      function createPath(segments, closed, args) {
        var props = Base.getNamed(args),
            path = new Path(props && props.insert == false && Item.NO_INSERT);

        path._add(segments);

        path._closed = closed;
        return path.set(props, {
          insert: true
        });
      }

      function createEllipse(center, radius, args) {
        var segments = new Array(4);

        for (var i = 0; i < 4; i++) {
          var segment = ellipseSegments[i];
          segments[i] = new Segment(segment._point.multiply(radius).add(center), segment._handleIn.multiply(radius), segment._handleOut.multiply(radius));
        }

        return createPath(segments, true, args);
      }

      return {
        Line: function () {
          var args = arguments;
          return createPath([new Segment(Point.readNamed(args, 'from')), new Segment(Point.readNamed(args, 'to'))], false, args);
        },
        Circle: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              radius = Base.readNamed(args, 'radius');
          return createEllipse(center, new Size(radius), args);
        },
        Rectangle: function () {
          var args = arguments,
              rect = Rectangle.readNamed(args, 'rectangle'),
              radius = Size.readNamed(args, 'radius', 0, {
            readNull: true
          }),
              bl = rect.getBottomLeft(true),
              tl = rect.getTopLeft(true),
              tr = rect.getTopRight(true),
              br = rect.getBottomRight(true),
              segments;

          if (!radius || radius.isZero()) {
            segments = [new Segment(bl), new Segment(tl), new Segment(tr), new Segment(br)];
          } else {
            radius = Size.min(radius, rect.getSize(true).divide(2));
            var rx = radius.width,
                ry = radius.height,
                hx = rx * kappa,
                hy = ry * kappa;
            segments = [new Segment(bl.add(rx, 0), null, [-hx, 0]), new Segment(bl.subtract(0, ry), [0, hy]), new Segment(tl.add(0, ry), null, [0, -hy]), new Segment(tl.add(rx, 0), [-hx, 0], null), new Segment(tr.subtract(rx, 0), null, [hx, 0]), new Segment(tr.add(0, ry), [0, -hy], null), new Segment(br.subtract(0, ry), null, [0, hy]), new Segment(br.subtract(rx, 0), [hx, 0])];
          }

          return createPath(segments, true, args);
        },
        RoundRectangle: '#Rectangle',
        Ellipse: function () {
          var args = arguments,
              ellipse = Shape._readEllipse(args);

          return createEllipse(ellipse.center, ellipse.radius, args);
        },
        Oval: '#Ellipse',
        Arc: function () {
          var args = arguments,
              from = Point.readNamed(args, 'from'),
              through = Point.readNamed(args, 'through'),
              to = Point.readNamed(args, 'to'),
              props = Base.getNamed(args),
              path = new Path(props && props.insert == false && Item.NO_INSERT);
          path.moveTo(from);
          path.arcTo(through, to);
          return path.set(props);
        },
        RegularPolygon: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              sides = Base.readNamed(args, 'sides'),
              radius = Base.readNamed(args, 'radius'),
              step = 360 / sides,
              three = sides % 3 === 0,
              vector = new Point(0, three ? -radius : radius),
              offset = three ? -1 : 0.5,
              segments = new Array(sides);

          for (var i = 0; i < sides; i++) segments[i] = new Segment(center.add(vector.rotate((i + offset) * step)));

          return createPath(segments, true, args);
        },
        Star: function () {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              points = Base.readNamed(args, 'points') * 2,
              radius1 = Base.readNamed(args, 'radius1'),
              radius2 = Base.readNamed(args, 'radius2'),
              step = 360 / points,
              vector = new Point(0, -1),
              segments = new Array(points);

          for (var i = 0; i < points; i++) segments[i] = new Segment(center.add(vector.rotate(step * i).multiply(i % 2 ? radius2 : radius1)));

          return createPath(segments, true, args);
        }
      };
    }()
  });
  var CompoundPath = PathItem.extend({
    _class: 'CompoundPath',
    _serializeFields: {
      children: []
    },
    beans: true,
    initialize: function CompoundPath(arg) {
      this._children = [];
      this._namedChildren = {};

      if (!this._initialize(arg)) {
        if (typeof arg === 'string') {
          this.setPathData(arg);
        } else {
          this.addChildren(Array.isArray(arg) ? arg : arguments);
        }
      }
    },
    insertChildren: function insertChildren(index, items) {
      var list = items,
          first = list[0];
      if (first && typeof first[0] === 'number') list = [list];

      for (var i = items.length - 1; i >= 0; i--) {
        var item = list[i];
        if (list === items && !(item instanceof Path)) list = Base.slice(list);

        if (Array.isArray(item)) {
          list[i] = new Path({
            segments: item,
            insert: false
          });
        } else if (item instanceof CompoundPath) {
          list.splice.apply(list, [i, 1].concat(item.removeChildren()));
          item.remove();
        }
      }

      return insertChildren.base.call(this, index, list);
    },
    reduce: function reduce(options) {
      var children = this._children;

      for (var i = children.length - 1; i >= 0; i--) {
        var path = children[i].reduce(options);
        if (path.isEmpty()) path.remove();
      }

      if (!children.length) {
        var path = new Path(Item.NO_INSERT);
        path.copyAttributes(this);
        path.insertAbove(this);
        this.remove();
        return path;
      }

      return reduce.base.call(this);
    },
    isClosed: function () {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        if (!children[i]._closed) return false;
      }

      return true;
    },
    setClosed: function (closed) {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].setClosed(closed);
      }
    },
    getFirstSegment: function () {
      var first = this.getFirstChild();
      return first && first.getFirstSegment();
    },
    getLastSegment: function () {
      var last = this.getLastChild();
      return last && last.getLastSegment();
    },
    getCurves: function () {
      var children = this._children,
          curves = [];

      for (var i = 0, l = children.length; i < l; i++) {
        Base.push(curves, children[i].getCurves());
      }

      return curves;
    },
    getFirstCurve: function () {
      var first = this.getFirstChild();
      return first && first.getFirstCurve();
    },
    getLastCurve: function () {
      var last = this.getLastChild();
      return last && last.getLastCurve();
    },
    getArea: function () {
      var children = this._children,
          area = 0;

      for (var i = 0, l = children.length; i < l; i++) area += children[i].getArea();

      return area;
    },
    getLength: function () {
      var children = this._children,
          length = 0;

      for (var i = 0, l = children.length; i < l; i++) length += children[i].getLength();

      return length;
    },
    getPathData: function (_matrix, _precision) {
      var children = this._children,
          paths = [];

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i],
            mx = child._matrix;
        paths.push(child.getPathData(_matrix && !mx.isIdentity() ? _matrix.appended(mx) : _matrix, _precision));
      }

      return paths.join('');
    },
    _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
      return _hitTestChildren.base.call(this, point, options.class === Path || options.type === 'path' ? options : Base.set({}, options, {
        fill: false
      }), viewMatrix);
    },
    _draw: function (ctx, param, viewMatrix, strokeMatrix) {
      var children = this._children;
      if (!children.length) return;
      param = param.extend({
        dontStart: true,
        dontFinish: true
      });
      ctx.beginPath();

      for (var i = 0, l = children.length; i < l; i++) children[i].draw(ctx, param, strokeMatrix);

      if (!param.clip) {
        this._setStyles(ctx, param, viewMatrix);

        var style = this._style;

        if (style.hasFill()) {
          ctx.fill(style.getFillRule());
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (style.hasStroke()) ctx.stroke();
      }
    },
    _drawSelected: function (ctx, matrix, selectionItems) {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i],
            mx = child._matrix;

        if (!selectionItems[child._id]) {
          child._drawSelected(ctx, mx.isIdentity() ? matrix : matrix.appended(mx));
        }
      }
    }
  }, new function () {
    function getCurrentPath(that, check) {
      var children = that._children;
      if (check && !children.length) throw new Error('Use a moveTo() command first');
      return children[children.length - 1];
    }

    return Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'], function (key) {
      this[key] = function () {
        var path = getCurrentPath(this, true);
        path[key].apply(path, arguments);
      };
    }, {
      moveTo: function () {
        var current = getCurrentPath(this),
            path = current && current.isEmpty() ? current : new Path(Item.NO_INSERT);
        if (path !== current) this.addChild(path);
        path.moveTo.apply(path, arguments);
      },
      moveBy: function () {
        var current = getCurrentPath(this, true),
            last = current && current.getLastSegment(),
            point = Point.read(arguments);
        this.moveTo(last ? point.add(last._point) : point);
      },
      closePath: function (tolerance) {
        getCurrentPath(this, true).closePath(tolerance);
      }
    });
  }(), Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function (key) {
    this[key] = function (param) {
      var children = this._children,
          res;

      for (var i = 0, l = children.length; i < l; i++) {
        res = children[i][key](param) || res;
      }

      return res;
    };
  }, {}));
  PathItem.inject(new function () {
    var min = Math.min,
        max = Math.max,
        abs = Math.abs,
        operators = {
      unite: {
        '1': true,
        '2': true
      },
      intersect: {
        '2': true
      },
      subtract: {
        '1': true
      },
      exclude: {
        '1': true,
        '-1': true
      }
    };

    function getPaths(path) {
      return path._children || [path];
    }

    function preparePath(path, resolve) {
      var res = path.clone(false).reduce({
        simplify: true
      }).transform(null, true, true);

      if (resolve) {
        var paths = getPaths(res);

        for (var i = 0, l = paths.length; i < l; i++) {
          var path = paths[i];

          if (!path._closed && !path.isEmpty()) {
            path.closePath(1e-12);
            path.getFirstSegment().setHandleIn(0, 0);
            path.getLastSegment().setHandleOut(0, 0);
          }
        }

        res = res.resolveCrossings().reorient(res.getFillRule() === 'nonzero', true);
      }

      return res;
    }

    function createResult(paths, simplify, path1, path2, options) {
      var result = new CompoundPath(Item.NO_INSERT);
      result.addChildren(paths, true);
      result = result.reduce({
        simplify: simplify
      });

      if (!(options && options.insert == false)) {
        result.insertAbove(path2 && path1.isSibling(path2) && path1.getIndex() < path2.getIndex() ? path2 : path1);
      }

      result.copyAttributes(path1, true);
      return result;
    }

    function filterIntersection(inter) {
      return inter.hasOverlap() || inter.isCrossing();
    }

    function traceBoolean(path1, path2, operation, options) {
      if (options && (options.trace == false || options.stroke) && /^(subtract|intersect)$/.test(operation)) return splitBoolean(path1, path2, operation);

      var _path1 = preparePath(path1, true),
          _path2 = path2 && path1 !== path2 && preparePath(path2, true),
          operator = operators[operation];

      operator[operation] = true;
      if (_path2 && (operator.subtract || operator.exclude) ^ (_path2.isClockwise() ^ _path1.isClockwise())) _path2.reverse();

      var crossings = divideLocations(CurveLocation.expand(_path1.getIntersections(_path2, filterIntersection))),
          paths1 = getPaths(_path1),
          paths2 = _path2 && getPaths(_path2),
          segments = [],
          curves = [],
          paths;

      function collectPaths(paths) {
        for (var i = 0, l = paths.length; i < l; i++) {
          var path = paths[i];
          Base.push(segments, path._segments);
          Base.push(curves, path.getCurves());
          path._overlapsOnly = true;
        }
      }

      function getCurves(indices) {
        var list = [];

        for (var i = 0, l = indices && indices.length; i < l; i++) {
          list.push(curves[indices[i]]);
        }

        return list;
      }

      if (crossings.length) {
        collectPaths(paths1);
        if (paths2) collectPaths(paths2);
        var curvesValues = new Array(curves.length);

        for (var i = 0, l = curves.length; i < l; i++) {
          curvesValues[i] = curves[i].getValues();
        }

        var curveCollisions = CollisionDetection.findCurveBoundsCollisions(curvesValues, curvesValues, 0, true);
        var curveCollisionsMap = {};

        for (var i = 0; i < curves.length; i++) {
          var curve = curves[i],
              id = curve._path._id,
              map = curveCollisionsMap[id] = curveCollisionsMap[id] || {};
          map[curve.getIndex()] = {
            hor: getCurves(curveCollisions[i].hor),
            ver: getCurves(curveCollisions[i].ver)
          };
        }

        for (var i = 0, l = crossings.length; i < l; i++) {
          propagateWinding(crossings[i]._segment, _path1, _path2, curveCollisionsMap, operator);
        }

        for (var i = 0, l = segments.length; i < l; i++) {
          var segment = segments[i],
              inter = segment._intersection;

          if (!segment._winding) {
            propagateWinding(segment, _path1, _path2, curveCollisionsMap, operator);
          }

          if (!(inter && inter._overlap)) segment._path._overlapsOnly = false;
        }

        paths = tracePaths(segments, operator);
      } else {
        paths = reorientPaths(paths2 ? paths1.concat(paths2) : paths1.slice(), function (w) {
          return !!operator[w];
        });
      }

      return createResult(paths, true, path1, path2, options);
    }

    function splitBoolean(path1, path2, operation) {
      var _path1 = preparePath(path1),
          _path2 = preparePath(path2),
          crossings = _path1.getIntersections(_path2, filterIntersection),
          subtract = operation === 'subtract',
          divide = operation === 'divide',
          added = {},
          paths = [];

      function addPath(path) {
        if (!added[path._id] && (divide || _path2.contains(path.getPointAt(path.getLength() / 2)) ^ subtract)) {
          paths.unshift(path);
          return added[path._id] = true;
        }
      }

      for (var i = crossings.length - 1; i >= 0; i--) {
        var path = crossings[i].split();

        if (path) {
          if (addPath(path)) path.getFirstSegment().setHandleIn(0, 0);

          _path1.getLastSegment().setHandleOut(0, 0);
        }
      }

      addPath(_path1);
      return createResult(paths, false, path1, path2);
    }

    function linkIntersections(from, to) {
      var prev = from;

      while (prev) {
        if (prev === to) return;
        prev = prev._previous;
      }

      while (from._next && from._next !== to) from = from._next;

      if (!from._next) {
        while (to._previous) to = to._previous;

        from._next = to;
        to._previous = from;
      }
    }

    function clearCurveHandles(curves) {
      for (var i = curves.length - 1; i >= 0; i--) curves[i].clearHandles();
    }

    function reorientPaths(paths, isInside, clockwise) {
      var length = paths && paths.length;

      if (length) {
        var lookup = Base.each(paths, function (path, i) {
          this[path._id] = {
            container: null,
            winding: path.isClockwise() ? 1 : -1,
            index: i
          };
        }, {}),
            sorted = paths.slice().sort(function (a, b) {
          return abs(b.getArea()) - abs(a.getArea());
        }),
            first = sorted[0];
        var collisions = CollisionDetection.findItemBoundsCollisions(sorted, null, Numerical.GEOMETRIC_EPSILON);
        if (clockwise == null) clockwise = first.isClockwise();

        for (var i = 0; i < length; i++) {
          var path1 = sorted[i],
              entry1 = lookup[path1._id],
              containerWinding = 0,
              indices = collisions[i];

          if (indices) {
            var point = null;

            for (var j = indices.length - 1; j >= 0; j--) {
              if (indices[j] < i) {
                point = point || path1.getInteriorPoint();
                var path2 = sorted[indices[j]];

                if (path2.contains(point)) {
                  var entry2 = lookup[path2._id];
                  containerWinding = entry2.winding;
                  entry1.winding += containerWinding;
                  entry1.container = entry2.exclude ? entry2.container : path2;
                  break;
                }
              }
            }
          }

          if (isInside(entry1.winding) === isInside(containerWinding)) {
            entry1.exclude = true;
            paths[entry1.index] = null;
          } else {
            var container = entry1.container;
            path1.setClockwise(container ? !container.isClockwise() : clockwise);
          }
        }
      }

      return paths;
    }

    function divideLocations(locations, include, clearLater) {
      var results = include && [],
          tMin = 1e-8,
          tMax = 1 - tMin,
          clearHandles = false,
          clearCurves = clearLater || [],
          clearLookup = clearLater && {},
          renormalizeLocs,
          prevCurve,
          prevTime;

      function getId(curve) {
        return curve._path._id + '.' + curve._segment1._index;
      }

      for (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {
        var curve = clearLater[i];
        if (curve._path) clearLookup[getId(curve)] = true;
      }

      for (var i = locations.length - 1; i >= 0; i--) {
        var loc = locations[i],
            time = loc._time,
            origTime = time,
            exclude = include && !include(loc),
            curve = loc._curve,
            segment;

        if (curve) {
          if (curve !== prevCurve) {
            clearHandles = !curve.hasHandles() || clearLookup && clearLookup[getId(curve)];
            renormalizeLocs = [];
            prevTime = null;
            prevCurve = curve;
          } else if (prevTime >= tMin) {
            time /= prevTime;
          }
        }

        if (exclude) {
          if (renormalizeLocs) renormalizeLocs.push(loc);
          continue;
        } else if (include) {
          results.unshift(loc);
        }

        prevTime = origTime;

        if (time < tMin) {
          segment = curve._segment1;
        } else if (time > tMax) {
          segment = curve._segment2;
        } else {
          var newCurve = curve.divideAtTime(time, true);
          if (clearHandles) clearCurves.push(curve, newCurve);
          segment = newCurve._segment1;

          for (var j = renormalizeLocs.length - 1; j >= 0; j--) {
            var l = renormalizeLocs[j];
            l._time = (l._time - time) / (1 - time);
          }
        }

        loc._setSegment(segment);

        var inter = segment._intersection,
            dest = loc._intersection;

        if (inter) {
          linkIntersections(inter, dest);
          var other = inter;

          while (other) {
            linkIntersections(other._intersection, inter);
            other = other._next;
          }
        } else {
          segment._intersection = dest;
        }
      }

      if (!clearLater) clearCurveHandles(clearCurves);
      return results || locations;
    }

    function getWinding(point, curves, dir, closed, dontFlip) {
      var curvesList = Array.isArray(curves) ? curves : curves[dir ? 'hor' : 'ver'];
      var ia = dir ? 1 : 0,
          io = ia ^ 1,
          pv = [point.x, point.y],
          pa = pv[ia],
          po = pv[io],
          windingEpsilon = 1e-9,
          qualityEpsilon = 1e-6,
          paL = pa - windingEpsilon,
          paR = pa + windingEpsilon,
          windingL = 0,
          windingR = 0,
          pathWindingL = 0,
          pathWindingR = 0,
          onPath = false,
          onAnyPath = false,
          quality = 1,
          roots = [],
          vPrev,
          vClose;

      function addWinding(v) {
        var o0 = v[io + 0],
            o3 = v[io + 6];

        if (po < min(o0, o3) || po > max(o0, o3)) {
          return;
        }

        var a0 = v[ia + 0],
            a1 = v[ia + 2],
            a2 = v[ia + 4],
            a3 = v[ia + 6];

        if (o0 === o3) {
          if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
            onPath = true;
          }

          return;
        }

        var t = po === o0 ? 0 : po === o3 ? 1 : paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? 1 : Curve.solveCubic(v, io, po, roots, 0, 1) > 0 ? roots[0] : 1,
            a = t === 0 ? a0 : t === 1 ? a3 : Curve.getPoint(v, t)[dir ? 'y' : 'x'],
            winding = o0 > o3 ? 1 : -1,
            windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,
            a3Prev = vPrev[ia + 6];

        if (po !== o0) {
          if (a < paL) {
            pathWindingL += winding;
          } else if (a > paR) {
            pathWindingR += winding;
          } else {
            onPath = true;
          }

          if (a > pa - qualityEpsilon && a < pa + qualityEpsilon) quality /= 2;
        } else {
          if (winding !== windingPrev) {
            if (a0 < paL) {
              pathWindingL += winding;
            } else if (a0 > paR) {
              pathWindingR += winding;
            }
          } else if (a0 != a3Prev) {
            if (a3Prev < paR && a > paR) {
              pathWindingR += winding;
              onPath = true;
            } else if (a3Prev > paL && a < paL) {
              pathWindingL += winding;
              onPath = true;
            }
          }

          quality /= 4;
        }

        vPrev = v;
        return !dontFlip && a > paL && a < paR && Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0 && getWinding(point, curves, !dir, closed, true);
      }

      function handleCurve(v) {
        var o0 = v[io + 0],
            o1 = v[io + 2],
            o2 = v[io + 4],
            o3 = v[io + 6];

        if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {
          var a0 = v[ia + 0],
              a1 = v[ia + 2],
              a2 = v[ia + 4],
              a3 = v[ia + 6],
              monoCurves = paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? [v] : Curve.getMonoCurves(v, dir),
              res;

          for (var i = 0, l = monoCurves.length; i < l; i++) {
            if (res = addWinding(monoCurves[i])) return res;
          }
        }
      }

      for (var i = 0, l = curvesList.length; i < l; i++) {
        var curve = curvesList[i],
            path = curve._path,
            v = curve.getValues(),
            res;

        if (!i || curvesList[i - 1]._path !== path) {
          vPrev = null;

          if (!path._closed) {
            vClose = Curve.getValues(path.getLastCurve().getSegment2(), curve.getSegment1(), null, !closed);

            if (vClose[io] !== vClose[io + 6]) {
              vPrev = vClose;
            }
          }

          if (!vPrev) {
            vPrev = v;
            var prev = path.getLastCurve();

            while (prev && prev !== curve) {
              var v2 = prev.getValues();

              if (v2[io] !== v2[io + 6]) {
                vPrev = v2;
                break;
              }

              prev = prev.getPrevious();
            }
          }
        }

        if (res = handleCurve(v)) return res;

        if (i + 1 === l || curvesList[i + 1]._path !== path) {
          if (vClose && (res = handleCurve(vClose))) return res;

          if (onPath && !pathWindingL && !pathWindingR) {
            pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir ? 1 : -1;
          }

          windingL += pathWindingL;
          windingR += pathWindingR;
          pathWindingL = pathWindingR = 0;

          if (onPath) {
            onAnyPath = true;
            onPath = false;
          }

          vClose = null;
        }
      }

      windingL = abs(windingL);
      windingR = abs(windingR);
      return {
        winding: max(windingL, windingR),
        windingL: windingL,
        windingR: windingR,
        quality: quality,
        onPath: onAnyPath
      };
    }

    function propagateWinding(segment, path1, path2, curveCollisionsMap, operator) {
      var chain = [],
          start = segment,
          totalLength = 0,
          winding;

      do {
        var curve = segment.getCurve();

        if (curve) {
          var length = curve.getLength();
          chain.push({
            segment: segment,
            curve: curve,
            length: length
          });
          totalLength += length;
        }

        segment = segment.getNext();
      } while (segment && !segment._intersection && segment !== start);

      var offsets = [0.5, 0.25, 0.75],
          winding = {
        winding: 0,
        quality: -1
      },
          tMin = 1e-3,
          tMax = 1 - tMin;

      for (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {
        var length = totalLength * offsets[i];

        for (var j = 0, l = chain.length; j < l; j++) {
          var entry = chain[j],
              curveLength = entry.length;

          if (length <= curveLength) {
            var curve = entry.curve,
                path = curve._path,
                parent = path._parent,
                operand = parent instanceof CompoundPath ? parent : path,
                t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),
                pt = curve.getPointAtTime(t),
                dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;
            var wind = null;

            if (operator.subtract && path2) {
              var otherPath = operand === path1 ? path2 : path1,
                  pathWinding = otherPath._getWinding(pt, dir, true);

              if (operand === path1 && pathWinding.winding || operand === path2 && !pathWinding.winding) {
                if (pathWinding.quality < 1) {
                  continue;
                } else {
                  wind = {
                    winding: 0,
                    quality: 1
                  };
                }
              }
            }

            wind = wind || getWinding(pt, curveCollisionsMap[path._id][curve.getIndex()], dir, true);
            if (wind.quality > winding.quality) winding = wind;
            break;
          }

          length -= curveLength;
        }
      }

      for (var j = chain.length - 1; j >= 0; j--) {
        chain[j].segment._winding = winding;
      }
    }

    function tracePaths(segments, operator) {
      var paths = [],
          starts;

      function isValid(seg) {
        var winding;
        return !!(seg && !seg._visited && (!operator || operator[(winding = seg._winding || {}).winding] && !(operator.unite && winding.winding === 2 && winding.windingL && winding.windingR)));
      }

      function isStart(seg) {
        if (seg) {
          for (var i = 0, l = starts.length; i < l; i++) {
            if (seg === starts[i]) return true;
          }
        }

        return false;
      }

      function visitPath(path) {
        var segments = path._segments;

        for (var i = 0, l = segments.length; i < l; i++) {
          segments[i]._visited = true;
        }
      }

      function getCrossingSegments(segment, collectStarts) {
        var inter = segment._intersection,
            start = inter,
            crossings = [];
        if (collectStarts) starts = [segment];

        function collect(inter, end) {
          while (inter && inter !== end) {
            var other = inter._segment,
                path = other && other._path;

            if (path) {
              var next = other.getNext() || path.getFirstSegment(),
                  nextInter = next._intersection;

              if (other !== segment && (isStart(other) || isStart(next) || next && isValid(other) && (isValid(next) || nextInter && isValid(nextInter._segment)))) {
                crossings.push(other);
              }

              if (collectStarts) starts.push(other);
            }

            inter = inter._next;
          }
        }

        if (inter) {
          collect(inter);

          while (inter && inter._previous) inter = inter._previous;

          collect(inter, start);
        }

        return crossings;
      }

      segments.sort(function (seg1, seg2) {
        var inter1 = seg1._intersection,
            inter2 = seg2._intersection,
            over1 = !!(inter1 && inter1._overlap),
            over2 = !!(inter2 && inter2._overlap),
            path1 = seg1._path,
            path2 = seg2._path;
        return over1 ^ over2 ? over1 ? 1 : -1 : !inter1 ^ !inter2 ? inter1 ? 1 : -1 : path1 !== path2 ? path1._id - path2._id : seg1._index - seg2._index;
      });

      for (var i = 0, l = segments.length; i < l; i++) {
        var seg = segments[i],
            valid = isValid(seg),
            path = null,
            finished = false,
            closed = true,
            branches = [],
            branch,
            visited,
            handleIn;

        if (valid && seg._path._overlapsOnly) {
          var path1 = seg._path,
              path2 = seg._intersection._segment._path;

          if (path1.compare(path2)) {
            if (path1.getArea()) paths.push(path1.clone(false));
            visitPath(path1);
            visitPath(path2);
            valid = false;
          }
        }

        while (valid) {
          var first = !path,
              crossings = getCrossingSegments(seg, first),
              other = crossings.shift(),
              finished = !first && (isStart(seg) || isStart(other)),
              cross = !finished && other;

          if (first) {
            path = new Path(Item.NO_INSERT);
            branch = null;
          }

          if (finished) {
            if (seg.isFirst() || seg.isLast()) closed = seg._path._closed;
            seg._visited = true;
            break;
          }

          if (cross && branch) {
            branches.push(branch);
            branch = null;
          }

          if (!branch) {
            if (cross) crossings.push(seg);
            branch = {
              start: path._segments.length,
              crossings: crossings,
              visited: visited = [],
              handleIn: handleIn
            };
          }

          if (cross) seg = other;

          if (!isValid(seg)) {
            path.removeSegments(branch.start);

            for (var j = 0, k = visited.length; j < k; j++) {
              visited[j]._visited = false;
            }

            visited.length = 0;

            do {
              seg = branch && branch.crossings.shift();

              if (!seg || !seg._path) {
                seg = null;
                branch = branches.pop();

                if (branch) {
                  visited = branch.visited;
                  handleIn = branch.handleIn;
                }
              }
            } while (branch && !isValid(seg));

            if (!seg) break;
          }

          var next = seg.getNext();
          path.add(new Segment(seg._point, handleIn, next && seg._handleOut));
          seg._visited = true;
          visited.push(seg);
          seg = next || seg._path.getFirstSegment();
          handleIn = next && next._handleIn;
        }

        if (finished) {
          if (closed) {
            path.getFirstSegment().setHandleIn(handleIn);
            path.setClosed(closed);
          }

          if (path.getArea() !== 0) {
            paths.push(path);
          }
        }
      }

      return paths;
    }

    return {
      _getWinding: function (point, dir, closed) {
        return getWinding(point, this.getCurves(), dir, closed);
      },
      unite: function (path, options) {
        return traceBoolean(this, path, 'unite', options);
      },
      intersect: function (path, options) {
        return traceBoolean(this, path, 'intersect', options);
      },
      subtract: function (path, options) {
        return traceBoolean(this, path, 'subtract', options);
      },
      exclude: function (path, options) {
        return traceBoolean(this, path, 'exclude', options);
      },
      divide: function (path, options) {
        return options && (options.trace == false || options.stroke) ? splitBoolean(this, path, 'divide') : createResult([this.subtract(path, options), this.intersect(path, options)], true, this, path, options);
      },
      resolveCrossings: function () {
        var children = this._children,
            paths = children || [this];

        function hasOverlap(seg, path) {
          var inter = seg && seg._intersection;
          return inter && inter._overlap && inter._path === path;
        }

        var hasOverlaps = false,
            hasCrossings = false,
            intersections = this.getIntersections(null, function (inter) {
          return inter.hasOverlap() && (hasOverlaps = true) || inter.isCrossing() && (hasCrossings = true);
        }),
            clearCurves = hasOverlaps && hasCrossings && [];
        intersections = CurveLocation.expand(intersections);

        if (hasOverlaps) {
          var overlaps = divideLocations(intersections, function (inter) {
            return inter.hasOverlap();
          }, clearCurves);

          for (var i = overlaps.length - 1; i >= 0; i--) {
            var overlap = overlaps[i],
                path = overlap._path,
                seg = overlap._segment,
                prev = seg.getPrevious(),
                next = seg.getNext();

            if (hasOverlap(prev, path) && hasOverlap(next, path)) {
              seg.remove();

              prev._handleOut._set(0, 0);

              next._handleIn._set(0, 0);

              if (prev !== seg && !prev.getCurve().hasLength()) {
                next._handleIn.set(prev._handleIn);

                prev.remove();
              }
            }
          }
        }

        if (hasCrossings) {
          divideLocations(intersections, hasOverlaps && function (inter) {
            var curve1 = inter.getCurve(),
                seg1 = inter.getSegment(),
                other = inter._intersection,
                curve2 = other._curve,
                seg2 = other._segment;
            if (curve1 && curve2 && curve1._path && curve2._path) return true;
            if (seg1) seg1._intersection = null;
            if (seg2) seg2._intersection = null;
          }, clearCurves);
          if (clearCurves) clearCurveHandles(clearCurves);
          paths = tracePaths(Base.each(paths, function (path) {
            Base.push(this, path._segments);
          }, []));
        }

        var length = paths.length,
            item;

        if (length > 1 && children) {
          if (paths !== children) this.setChildren(paths);
          item = this;
        } else if (length === 1 && !children) {
          if (paths[0] !== this) this.setSegments(paths[0].removeSegments());
          item = this;
        }

        if (!item) {
          item = new CompoundPath(Item.NO_INSERT);
          item.addChildren(paths);
          item = item.reduce();
          item.copyAttributes(this);
          this.replaceWith(item);
        }

        return item;
      },
      reorient: function (nonZero, clockwise) {
        var children = this._children;

        if (children && children.length) {
          this.setChildren(reorientPaths(this.removeChildren(), function (w) {
            return !!(nonZero ? w : w & 1);
          }, clockwise));
        } else if (clockwise !== undefined) {
          this.setClockwise(clockwise);
        }

        return this;
      },
      getInteriorPoint: function () {
        var bounds = this.getBounds(),
            point = bounds.getCenter(true);

        if (!this.contains(point)) {
          var curves = this.getCurves(),
              y = point.y,
              intercepts = [],
              roots = [];

          for (var i = 0, l = curves.length; i < l; i++) {
            var v = curves[i].getValues(),
                o0 = v[1],
                o1 = v[3],
                o2 = v[5],
                o3 = v[7];

            if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {
              var monoCurves = Curve.getMonoCurves(v);

              for (var j = 0, m = monoCurves.length; j < m; j++) {
                var mv = monoCurves[j],
                    mo0 = mv[1],
                    mo3 = mv[7];

                if (mo0 !== mo3 && (y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)) {
                  var x = y === mo0 ? mv[0] : y === mo3 ? mv[6] : Curve.solveCubic(mv, 1, y, roots, 0, 1) === 1 ? Curve.getPoint(mv, roots[0]).x : (mv[0] + mv[6]) / 2;
                  intercepts.push(x);
                }
              }
            }
          }

          if (intercepts.length > 1) {
            intercepts.sort(function (a, b) {
              return a - b;
            });
            point.x = (intercepts[0] + intercepts[1]) / 2;
          }
        }

        return point;
      }
    };
  }());
  var PathFlattener = Base.extend({
    _class: 'PathFlattener',
    initialize: function (path, flatness, maxRecursion, ignoreStraight, matrix) {
      var curves = [],
          parts = [],
          length = 0,
          minSpan = 1 / (maxRecursion || 32),
          segments = path._segments,
          segment1 = segments[0],
          segment2;

      function addCurve(segment1, segment2) {
        var curve = Curve.getValues(segment1, segment2, matrix);
        curves.push(curve);
        computeParts(curve, segment1._index, 0, 1);
      }

      function computeParts(curve, index, t1, t2) {
        if (t2 - t1 > minSpan && !(ignoreStraight && Curve.isStraight(curve)) && !Curve.isFlatEnough(curve, flatness || 0.25)) {
          var halves = Curve.subdivide(curve, 0.5),
              tMid = (t1 + t2) / 2;
          computeParts(halves[0], index, t1, tMid);
          computeParts(halves[1], index, tMid, t2);
        } else {
          var dx = curve[6] - curve[0],
              dy = curve[7] - curve[1],
              dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            length += dist;
            parts.push({
              offset: length,
              curve: curve,
              index: index,
              time: t2
            });
          }
        }
      }

      for (var i = 1, l = segments.length; i < l; i++) {
        segment2 = segments[i];
        addCurve(segment1, segment2);
        segment1 = segment2;
      }

      if (path._closed) addCurve(segment2 || segment1, segments[0]);
      this.curves = curves;
      this.parts = parts;
      this.length = length;
      this.index = 0;
    },
    _get: function (offset) {
      var parts = this.parts,
          length = parts.length,
          start,
          i,
          j = this.index;

      for (;;) {
        i = j;
        if (!j || parts[--j].offset < offset) break;
      }

      for (; i < length; i++) {
        var part = parts[i];

        if (part.offset >= offset) {
          this.index = i;
          var prev = parts[i - 1],
              prevTime = prev && prev.index === part.index ? prev.time : 0,
              prevOffset = prev ? prev.offset : 0;
          return {
            index: part.index,
            time: prevTime + (part.time - prevTime) * (offset - prevOffset) / (part.offset - prevOffset)
          };
        }
      }

      return {
        index: parts[length - 1].index,
        time: 1
      };
    },
    drawPart: function (ctx, from, to) {
      var start = this._get(from),
          end = this._get(to);

      for (var i = start.index, l = end.index; i <= l; i++) {
        var curve = Curve.getPart(this.curves[i], i === start.index ? start.time : 0, i === end.index ? end.time : 1);
        if (i === start.index) ctx.moveTo(curve[0], curve[1]);
        ctx.bezierCurveTo.apply(ctx, curve.slice(2));
      }
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    this[name + 'At'] = function (offset) {
      var param = this._get(offset);

      return Curve[name](this.curves[param.index], param.time);
    };
  }, {}));
  var PathFitter = Base.extend({
    initialize: function (path) {
      var points = this.points = [],
          segments = path._segments,
          closed = path._closed;

      for (var i = 0, prev, l = segments.length; i < l; i++) {
        var point = segments[i].point;

        if (!prev || !prev.equals(point)) {
          points.push(prev = point.clone());
        }
      }

      if (closed) {
        points.unshift(points[points.length - 1]);
        points.push(points[1]);
      }

      this.closed = closed;
    },
    fit: function (error) {
      var points = this.points,
          length = points.length,
          segments = null;

      if (length > 0) {
        segments = [new Segment(points[0])];

        if (length > 1) {
          this.fitCubic(segments, error, 0, length - 1, points[1].subtract(points[0]), points[length - 2].subtract(points[length - 1]));

          if (this.closed) {
            segments.shift();
            segments.pop();
          }
        }
      }

      return segments;
    },
    fitCubic: function (segments, error, first, last, tan1, tan2) {
      var points = this.points;

      if (last - first === 1) {
        var pt1 = points[first],
            pt2 = points[last],
            dist = pt1.getDistance(pt2) / 3;
        this.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)), pt2.add(tan2.normalize(dist)), pt2]);
        return;
      }

      var uPrime = this.chordLengthParameterize(first, last),
          maxError = Math.max(error, error * error),
          split,
          parametersInOrder = true;

      for (var i = 0; i <= 4; i++) {
        var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
        var max = this.findMaxError(first, last, curve, uPrime);

        if (max.error < error && parametersInOrder) {
          this.addCurve(segments, curve);
          return;
        }

        split = max.index;
        if (max.error >= maxError) break;
        parametersInOrder = this.reparameterize(first, last, uPrime, curve);
        maxError = max.error;
      }

      var tanCenter = points[split - 1].subtract(points[split + 1]);
      this.fitCubic(segments, error, first, split, tan1, tanCenter);
      this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
    },
    addCurve: function (segments, curve) {
      var prev = segments[segments.length - 1];
      prev.setHandleOut(curve[1].subtract(curve[0]));
      segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
    },
    generateBezier: function (first, last, uPrime, tan1, tan2) {
      var epsilon = 1e-12,
          abs = Math.abs,
          points = this.points,
          pt1 = points[first],
          pt2 = points[last],
          C = [[0, 0], [0, 0]],
          X = [0, 0];

      for (var i = 0, l = last - first + 1; i < l; i++) {
        var u = uPrime[i],
            t = 1 - u,
            b = 3 * u * t,
            b0 = t * t * t,
            b1 = b * t,
            b2 = b * u,
            b3 = u * u * u,
            a1 = tan1.normalize(b1),
            a2 = tan2.normalize(b2),
            tmp = points[first + i].subtract(pt1.multiply(b0 + b1)).subtract(pt2.multiply(b2 + b3));
        C[0][0] += a1.dot(a1);
        C[0][1] += a1.dot(a2);
        C[1][0] = C[0][1];
        C[1][1] += a2.dot(a2);
        X[0] += a1.dot(tmp);
        X[1] += a2.dot(tmp);
      }

      var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
          alpha1,
          alpha2;

      if (abs(detC0C1) > epsilon) {
        var detC0X = C[0][0] * X[1] - C[1][0] * X[0],
            detXC1 = X[0] * C[1][1] - X[1] * C[0][1];
        alpha1 = detXC1 / detC0C1;
        alpha2 = detC0X / detC0C1;
      } else {
        var c0 = C[0][0] + C[0][1],
            c1 = C[1][0] + C[1][1];
        alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0 : abs(c1) > epsilon ? X[1] / c1 : 0;
      }

      var segLength = pt2.getDistance(pt1),
          eps = epsilon * segLength,
          handle1,
          handle2;

      if (alpha1 < eps || alpha2 < eps) {
        alpha1 = alpha2 = segLength / 3;
      } else {
        var line = pt2.subtract(pt1);
        handle1 = tan1.normalize(alpha1);
        handle2 = tan2.normalize(alpha2);

        if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
          alpha1 = alpha2 = segLength / 3;
          handle1 = handle2 = null;
        }
      }

      return [pt1, pt1.add(handle1 || tan1.normalize(alpha1)), pt2.add(handle2 || tan2.normalize(alpha2)), pt2];
    },
    reparameterize: function (first, last, u, curve) {
      for (var i = first; i <= last; i++) {
        u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
      }

      for (var i = 1, l = u.length; i < l; i++) {
        if (u[i] <= u[i - 1]) return false;
      }

      return true;
    },
    findRoot: function (curve, point, u) {
      var curve1 = [],
          curve2 = [];

      for (var i = 0; i <= 2; i++) {
        curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
      }

      for (var i = 0; i <= 1; i++) {
        curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
      }

      var pt = this.evaluate(3, curve, u),
          pt1 = this.evaluate(2, curve1, u),
          pt2 = this.evaluate(1, curve2, u),
          diff = pt.subtract(point),
          df = pt1.dot(pt1) + diff.dot(pt2);
      return Numerical.isMachineZero(df) ? u : u - diff.dot(pt1) / df;
    },
    evaluate: function (degree, curve, t) {
      var tmp = curve.slice();

      for (var i = 1; i <= degree; i++) {
        for (var j = 0; j <= degree - i; j++) {
          tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
        }
      }

      return tmp[0];
    },
    chordLengthParameterize: function (first, last) {
      var u = [0];

      for (var i = first + 1; i <= last; i++) {
        u[i - first] = u[i - first - 1] + this.points[i].getDistance(this.points[i - 1]);
      }

      for (var i = 1, m = last - first; i <= m; i++) {
        u[i] /= u[m];
      }

      return u;
    },
    findMaxError: function (first, last, curve, u) {
      var index = Math.floor((last - first + 1) / 2),
          maxDist = 0;

      for (var i = first + 1; i < last; i++) {
        var P = this.evaluate(3, curve, u[i - first]);
        var v = P.subtract(this.points[i]);
        var dist = v.x * v.x + v.y * v.y;

        if (dist >= maxDist) {
          maxDist = dist;
          index = i;
        }
      }

      return {
        error: maxDist,
        index: index
      };
    }
  });
  var TextItem = Item.extend({
    _class: 'TextItem',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _serializeFields: {
      content: null
    },
    _boundsOptions: {
      stroke: false,
      handle: false
    },
    initialize: function TextItem(arg) {
      this._content = '';
      this._lines = [];
      var hasProps = arg && Base.isPlainObject(arg) && arg.x === undefined && arg.y === undefined;

      this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
    },
    _equals: function (item) {
      return this._content === item._content;
    },
    copyContent: function (source) {
      this.setContent(source._content);
    },
    getContent: function () {
      return this._content;
    },
    setContent: function (content) {
      this._content = '' + content;
      this._lines = this._content.split(/\r\n|\n|\r/mg);

      this._changed(521);
    },
    isEmpty: function () {
      return !this._content;
    },
    getCharacterStyle: '#getStyle',
    setCharacterStyle: '#setStyle',
    getParagraphStyle: '#getStyle',
    setParagraphStyle: '#setStyle'
  });
  var PointText = TextItem.extend({
    _class: 'PointText',
    initialize: function PointText() {
      TextItem.apply(this, arguments);
    },
    getPoint: function () {
      var point = this._matrix.getTranslation();

      return new LinkedPoint(point.x, point.y, this, 'setPoint');
    },
    setPoint: function () {
      var point = Point.read(arguments);
      this.translate(point.subtract(this._matrix.getTranslation()));
    },
    _draw: function (ctx, param, viewMatrix) {
      if (!this._content) return;

      this._setStyles(ctx, param, viewMatrix);

      var lines = this._lines,
          style = this._style,
          hasFill = style.hasFill(),
          hasStroke = style.hasStroke(),
          leading = style.getLeading(),
          shadowColor = ctx.shadowColor;
      ctx.font = style.getFontStyle();
      ctx.textAlign = style.getJustification();

      for (var i = 0, l = lines.length; i < l; i++) {
        ctx.shadowColor = shadowColor;
        var line = lines[i];

        if (hasFill) {
          ctx.fillText(line, 0, 0);
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (hasStroke) ctx.strokeText(line, 0, 0);
        ctx.translate(0, leading);
      }
    },
    _getBounds: function (matrix, options) {
      var style = this._style,
          lines = this._lines,
          numLines = lines.length,
          justification = style.getJustification(),
          leading = style.getLeading(),
          width = this.getView().getTextWidth(style.getFontStyle(), lines),
          x = 0;
      if (justification !== 'left') x -= width / (justification === 'center' ? 2 : 1);
      var rect = new Rectangle(x, numLines ? -0.75 * leading : 0, width, numLines * leading);
      return matrix ? matrix._transformBounds(rect, rect) : rect;
    }
  });
  var Color = Base.extend(new function () {
    var types = {
      gray: ['gray'],
      rgb: ['red', 'green', 'blue'],
      hsb: ['hue', 'saturation', 'brightness'],
      hsl: ['hue', 'saturation', 'lightness'],
      gradient: ['gradient', 'origin', 'destination', 'highlight']
    };
    var componentParsers = {},
        namedColors = {
      transparent: [0, 0, 0, 0]
    },
        colorCtx;

    function fromCSS(string) {
      var match = string.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i) || string.match(/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i),
          type = 'rgb',
          components;

      if (match) {
        var amount = match[4] ? 4 : 3;
        components = new Array(amount);

        for (var i = 0; i < amount; i++) {
          var value = match[i + 1];
          components[i] = parseInt(value.length == 1 ? value + value : value, 16) / 255;
        }
      } else if (match = string.match(/^(rgb|hsl)a?\((.*)\)$/)) {
        type = match[1];
        components = match[2].trim().split(/[,\s]+/g);
        var isHSL = type === 'hsl';

        for (var i = 0, l = Math.min(components.length, 4); i < l; i++) {
          var component = components[i];
          var value = parseFloat(component);

          if (isHSL) {
            if (i === 0) {
              var unit = component.match(/([a-z]*)$/)[1];
              value *= {
                turn: 360,
                rad: 180 / Math.PI,
                grad: 0.9
              }[unit] || 1;
            } else if (i < 3) {
              value /= 100;
            }
          } else if (i < 3) {
            value /= /%$/.test(component) ? 100 : 255;
          }

          components[i] = value;
        }
      } else {
        var color = namedColors[string];

        if (!color) {
          if (window) {
            if (!colorCtx) {
              colorCtx = CanvasProvider.getContext(1, 1);
              colorCtx.globalCompositeOperation = 'copy';
            }

            colorCtx.fillStyle = 'rgba(0,0,0,0)';
            colorCtx.fillStyle = string;
            colorCtx.fillRect(0, 0, 1, 1);
            var data = colorCtx.getImageData(0, 0, 1, 1).data;
            color = namedColors[string] = [data[0] / 255, data[1] / 255, data[2] / 255];
          } else {
            color = [0, 0, 0];
          }
        }

        components = color.slice();
      }

      return [type, components];
    }

    var hsbIndices = [[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]];
    var converters = {
      'rgb-hsb': function (r, g, b) {
        var max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            delta = max - min,
            h = delta === 0 ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60;
        return [h, max === 0 ? 0 : delta / max, max];
      },
      'hsb-rgb': function (h, s, b) {
        h = (h / 60 % 6 + 6) % 6;
        var i = Math.floor(h),
            f = h - i,
            i = hsbIndices[i],
            v = [b, b * (1 - s), b * (1 - s * f), b * (1 - s * (1 - f))];
        return [v[i[0]], v[i[1]], v[i[2]]];
      },
      'rgb-hsl': function (r, g, b) {
        var max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            delta = max - min,
            achromatic = delta === 0,
            h = achromatic ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60,
            l = (max + min) / 2,
            s = achromatic ? 0 : l < 0.5 ? delta / (max + min) : delta / (2 - max - min);
        return [h, s, l];
      },
      'hsl-rgb': function (h, s, l) {
        h = (h / 360 % 1 + 1) % 1;
        if (s === 0) return [l, l, l];
        var t3s = [h + 1 / 3, h, h - 1 / 3],
            t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
            t1 = 2 * l - t2,
            c = [];

        for (var i = 0; i < 3; i++) {
          var t3 = t3s[i];
          if (t3 < 0) t3 += 1;
          if (t3 > 1) t3 -= 1;
          c[i] = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
        }

        return c;
      },
      'rgb-gray': function (r, g, b) {
        return [r * 0.2989 + g * 0.587 + b * 0.114];
      },
      'gray-rgb': function (g) {
        return [g, g, g];
      },
      'gray-hsb': function (g) {
        return [0, 0, g];
      },
      'gray-hsl': function (g) {
        return [0, 0, g];
      },
      'gradient-rgb': function () {
        return [];
      },
      'rgb-gradient': function () {
        return [];
      }
    };
    return Base.each(types, function (properties, type) {
      componentParsers[type] = [];
      Base.each(properties, function (name, index) {
        var part = Base.capitalize(name),
            hasOverlap = /^(hue|saturation)$/.test(name),
            parser = componentParsers[type][index] = type === 'gradient' ? name === 'gradient' ? function (value) {
          var current = this._components[0];
          value = Gradient.read(Array.isArray(value) ? value : arguments, 0, {
            readNull: true
          });

          if (current !== value) {
            if (current) current._removeOwner(this);
            if (value) value._addOwner(this);
          }

          return value;
        } : function () {
          return Point.read(arguments, 0, {
            readNull: name === 'highlight',
            clone: true
          });
        } : function (value) {
          return value == null || isNaN(value) ? 0 : +value;
        };

        this['get' + part] = function () {
          return this._type === type || hasOverlap && /^hs[bl]$/.test(this._type) ? this._components[index] : this._convert(type)[index];
        };

        this['set' + part] = function (value) {
          if (this._type !== type && !(hasOverlap && /^hs[bl]$/.test(this._type))) {
            this._components = this._convert(type);
            this._properties = types[type];
            this._type = type;
          }

          this._components[index] = parser.call(this, value);

          this._changed();
        };
      }, this);
    }, {
      _class: 'Color',
      _readIndex: true,
      initialize: function Color(arg) {
        var args = arguments,
            reading = this.__read,
            read = 0,
            type,
            components,
            alpha,
            values;

        if (Array.isArray(arg)) {
          args = arg;
          arg = args[0];
        }

        var argType = arg != null && typeof arg;

        if (argType === 'string' && arg in types) {
          type = arg;
          arg = args[1];

          if (Array.isArray(arg)) {
            components = arg;
            alpha = args[2];
          } else {
            if (reading) read = 1;
            args = Base.slice(args, 1);
            argType = typeof arg;
          }
        }

        if (!components) {
          values = argType === 'number' ? args : argType === 'object' && arg.length != null ? arg : null;

          if (values) {
            if (!type) type = values.length >= 3 ? 'rgb' : 'gray';
            var length = types[type].length;
            alpha = values[length];

            if (reading) {
              read += values === arguments ? length + (alpha != null ? 1 : 0) : 1;
            }

            if (values.length > length) values = Base.slice(values, 0, length);
          } else if (argType === 'string') {
            var converted = fromCSS(arg);
            type = converted[0];
            components = converted[1];

            if (components.length === 4) {
              alpha = components[3];
              components.length--;
            }
          } else if (argType === 'object') {
            if (arg.constructor === Color) {
              type = arg._type;
              components = arg._components.slice();
              alpha = arg._alpha;

              if (type === 'gradient') {
                for (var i = 1, l = components.length; i < l; i++) {
                  var point = components[i];
                  if (point) components[i] = point.clone();
                }
              }
            } else if (arg.constructor === Gradient) {
              type = 'gradient';
              values = args;
            } else {
              type = 'hue' in arg ? 'lightness' in arg ? 'hsl' : 'hsb' : 'gradient' in arg || 'stops' in arg || 'radial' in arg ? 'gradient' : 'gray' in arg ? 'gray' : 'rgb';
              var properties = types[type],
                  parsers = componentParsers[type];
              this._components = components = [];

              for (var i = 0, l = properties.length; i < l; i++) {
                var value = arg[properties[i]];

                if (value == null && !i && type === 'gradient' && 'stops' in arg) {
                  value = {
                    stops: arg.stops,
                    radial: arg.radial
                  };
                }

                value = parsers[i].call(this, value);
                if (value != null) components[i] = value;
              }

              alpha = arg.alpha;
            }
          }

          if (reading && type) read = 1;
        }

        this._type = type || 'rgb';

        if (!components) {
          this._components = components = [];
          var parsers = componentParsers[this._type];

          for (var i = 0, l = parsers.length; i < l; i++) {
            var value = parsers[i].call(this, values && values[i]);
            if (value != null) components[i] = value;
          }
        }

        this._components = components;
        this._properties = types[this._type];
        this._alpha = alpha;
        if (reading) this.__read = read;
        return this;
      },
      set: '#initialize',
      _serialize: function (options, dictionary) {
        var components = this.getComponents();
        return Base.serialize(/^(gray|rgb)$/.test(this._type) ? components : [this._type].concat(components), options, true, dictionary);
      },
      _changed: function () {
        this._canvasStyle = null;

        if (this._owner) {
          if (this._setter) {
            this._owner[this._setter](this);
          } else {
            this._owner._changed(129);
          }
        }
      },
      _convert: function (type) {
        var converter;
        return this._type === type ? this._components.slice() : (converter = converters[this._type + '-' + type]) ? converter.apply(this, this._components) : converters['rgb-' + type].apply(this, converters[this._type + '-rgb'].apply(this, this._components));
      },
      convert: function (type) {
        return new Color(type, this._convert(type), this._alpha);
      },
      getType: function () {
        return this._type;
      },
      setType: function (type) {
        this._components = this._convert(type);
        this._properties = types[type];
        this._type = type;
      },
      getComponents: function () {
        var components = this._components.slice();

        if (this._alpha != null) components.push(this._alpha);
        return components;
      },
      getAlpha: function () {
        return this._alpha != null ? this._alpha : 1;
      },
      setAlpha: function (alpha) {
        this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);

        this._changed();
      },
      hasAlpha: function () {
        return this._alpha != null;
      },
      equals: function (color) {
        var col = Base.isPlainValue(color, true) ? Color.read(arguments) : color;
        return col === this || col && this._class === col._class && this._type === col._type && this.getAlpha() === col.getAlpha() && Base.equals(this._components, col._components) || false;
      },
      toString: function () {
        var properties = this._properties,
            parts = [],
            isGradient = this._type === 'gradient',
            f = Formatter.instance;

        for (var i = 0, l = properties.length; i < l; i++) {
          var value = this._components[i];
          if (value != null) parts.push(properties[i] + ': ' + (isGradient ? value : f.number(value)));
        }

        if (this._alpha != null) parts.push('alpha: ' + f.number(this._alpha));
        return '{ ' + parts.join(', ') + ' }';
      },
      toCSS: function (hex) {
        var components = this._convert('rgb'),
            alpha = hex || this._alpha == null ? 1 : this._alpha;

        function convert(val) {
          return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
        }

        components = [convert(components[0]), convert(components[1]), convert(components[2])];
        if (alpha < 1) components.push(alpha < 0 ? 0 : alpha);
        return hex ? '#' + ((1 << 24) + (components[0] << 16) + (components[1] << 8) + components[2]).toString(16).slice(1) : (components.length == 4 ? 'rgba(' : 'rgb(') + components.join(',') + ')';
      },
      toCanvasStyle: function (ctx, matrix) {
        if (this._canvasStyle) return this._canvasStyle;
        if (this._type !== 'gradient') return this._canvasStyle = this.toCSS();
        var components = this._components,
            gradient = components[0],
            stops = gradient._stops,
            origin = components[1],
            destination = components[2],
            highlight = components[3],
            inverse = matrix && matrix.inverted(),
            canvasGradient;

        if (inverse) {
          origin = inverse._transformPoint(origin);
          destination = inverse._transformPoint(destination);
          if (highlight) highlight = inverse._transformPoint(highlight);
        }

        if (gradient._radial) {
          var radius = destination.getDistance(origin);

          if (highlight) {
            var vector = highlight.subtract(origin);
            if (vector.getLength() > radius) highlight = origin.add(vector.normalize(radius - 0.1));
          }

          var start = highlight || origin;
          canvasGradient = ctx.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius);
        } else {
          canvasGradient = ctx.createLinearGradient(origin.x, origin.y, destination.x, destination.y);
        }

        for (var i = 0, l = stops.length; i < l; i++) {
          var stop = stops[i],
              offset = stop._offset;
          canvasGradient.addColorStop(offset == null ? i / (l - 1) : offset, stop._color.toCanvasStyle());
        }

        return this._canvasStyle = canvasGradient;
      },
      transform: function (matrix) {
        if (this._type === 'gradient') {
          var components = this._components;

          for (var i = 1, l = components.length; i < l; i++) {
            var point = components[i];

            matrix._transformPoint(point, point, true);
          }

          this._changed();
        }
      },
      statics: {
        _types: types,
        random: function () {
          var random = Math.random;
          return new Color(random(), random(), random());
        },
        _setOwner: function (color, owner, setter) {
          if (color) {
            if (color._owner && owner && color._owner !== owner) {
              color = color.clone();
            }

            if (!color._owner ^ !owner) {
              color._owner = owner || null;
              color._setter = setter || null;
            }
          }

          return color;
        }
      }
    });
  }(), new function () {
    var operators = {
      add: function (a, b) {
        return a + b;
      },
      subtract: function (a, b) {
        return a - b;
      },
      multiply: function (a, b) {
        return a * b;
      },
      divide: function (a, b) {
        return a / b;
      }
    };
    return Base.each(operators, function (operator, name) {
      this[name] = function (color) {
        color = Color.read(arguments);

        var type = this._type,
            components1 = this._components,
            components2 = color._convert(type);

        for (var i = 0, l = components1.length; i < l; i++) components2[i] = operator(components1[i], components2[i]);

        return new Color(type, components2, this._alpha != null ? operator(this._alpha, color.getAlpha()) : null);
      };
    }, {});
  }());
  var Gradient = Base.extend({
    _class: 'Gradient',
    initialize: function Gradient(stops, radial) {
      this._id = UID.get();

      if (stops && Base.isPlainObject(stops)) {
        this.set(stops);
        stops = radial = null;
      }

      if (this._stops == null) {
        this.setStops(stops || ['white', 'black']);
      }

      if (this._radial == null) {
        this.setRadial(typeof radial === 'string' && radial === 'radial' || radial || false);
      }
    },
    _serialize: function (options, dictionary) {
      return dictionary.add(this, function () {
        return Base.serialize([this._stops, this._radial], options, true, dictionary);
      });
    },
    _changed: function () {
      for (var i = 0, l = this._owners && this._owners.length; i < l; i++) {
        this._owners[i]._changed();
      }
    },
    _addOwner: function (color) {
      if (!this._owners) this._owners = [];

      this._owners.push(color);
    },
    _removeOwner: function (color) {
      var index = this._owners ? this._owners.indexOf(color) : -1;

      if (index != -1) {
        this._owners.splice(index, 1);

        if (!this._owners.length) this._owners = undefined;
      }
    },
    clone: function () {
      var stops = [];

      for (var i = 0, l = this._stops.length; i < l; i++) {
        stops[i] = this._stops[i].clone();
      }

      return new Gradient(stops, this._radial);
    },
    getStops: function () {
      return this._stops;
    },
    setStops: function (stops) {
      if (stops.length < 2) {
        throw new Error('Gradient stop list needs to contain at least two stops.');
      }

      var _stops = this._stops;

      if (_stops) {
        for (var i = 0, l = _stops.length; i < l; i++) _stops[i]._owner = undefined;
      }

      _stops = this._stops = GradientStop.readList(stops, 0, {
        clone: true
      });

      for (var i = 0, l = _stops.length; i < l; i++) _stops[i]._owner = this;

      this._changed();
    },
    getRadial: function () {
      return this._radial;
    },
    setRadial: function (radial) {
      this._radial = radial;

      this._changed();
    },
    equals: function (gradient) {
      if (gradient === this) return true;

      if (gradient && this._class === gradient._class) {
        var stops1 = this._stops,
            stops2 = gradient._stops,
            length = stops1.length;

        if (length === stops2.length) {
          for (var i = 0; i < length; i++) {
            if (!stops1[i].equals(stops2[i])) return false;
          }

          return true;
        }
      }

      return false;
    }
  });
  var GradientStop = Base.extend({
    _class: 'GradientStop',
    initialize: function GradientStop(arg0, arg1) {
      var color = arg0,
          offset = arg1;

      if (typeof arg0 === 'object' && arg1 === undefined) {
        if (Array.isArray(arg0) && typeof arg0[0] !== 'number') {
          color = arg0[0];
          offset = arg0[1];
        } else if ('color' in arg0 || 'offset' in arg0 || 'rampPoint' in arg0) {
          color = arg0.color;
          offset = arg0.offset || arg0.rampPoint || 0;
        }
      }

      this.setColor(color);
      this.setOffset(offset);
    },
    clone: function () {
      return new GradientStop(this._color.clone(), this._offset);
    },
    _serialize: function (options, dictionary) {
      var color = this._color,
          offset = this._offset;
      return Base.serialize(offset == null ? [color] : [color, offset], options, true, dictionary);
    },
    _changed: function () {
      if (this._owner) this._owner._changed(129);
    },
    getOffset: function () {
      return this._offset;
    },
    setOffset: function (offset) {
      this._offset = offset;

      this._changed();
    },
    getRampPoint: '#getOffset',
    setRampPoint: '#setOffset',
    getColor: function () {
      return this._color;
    },
    setColor: function () {
      Color._setOwner(this._color, null);

      this._color = Color._setOwner(Color.read(arguments, 0), this, 'setColor');

      this._changed();
    },
    equals: function (stop) {
      return stop === this || stop && this._class === stop._class && this._color.equals(stop._color) && this._offset == stop._offset || false;
    }
  });
  var Style = Base.extend(new function () {
    var itemDefaults = {
      fillColor: null,
      fillRule: 'nonzero',
      strokeColor: null,
      strokeWidth: 1,
      strokeCap: 'butt',
      strokeJoin: 'miter',
      strokeScaling: true,
      miterLimit: 10,
      dashOffset: 0,
      dashArray: [],
      shadowColor: null,
      shadowBlur: 0,
      shadowOffset: new Point(),
      selectedColor: null
    },
        groupDefaults = Base.set({}, itemDefaults, {
      fontFamily: 'sans-serif',
      fontWeight: 'normal',
      fontSize: 12,
      leading: null,
      justification: 'left'
    }),
        textDefaults = Base.set({}, groupDefaults, {
      fillColor: new Color()
    }),
        flags = {
      strokeWidth: 193,
      strokeCap: 193,
      strokeJoin: 193,
      strokeScaling: 201,
      miterLimit: 193,
      fontFamily: 9,
      fontWeight: 9,
      fontSize: 9,
      font: 9,
      leading: 9,
      justification: 9
    },
        item = {
      beans: true
    },
        fields = {
      _class: 'Style',
      beans: true,
      initialize: function Style(style, _owner, _project) {
        this._values = {};
        this._owner = _owner;
        this._project = _owner && _owner._project || _project || paper.project;
        this._defaults = !_owner || _owner instanceof Group ? groupDefaults : _owner instanceof TextItem ? textDefaults : itemDefaults;
        if (style) this.set(style);
      }
    };
    Base.each(groupDefaults, function (value, key) {
      var isColor = /Color$/.test(key),
          isPoint = key === 'shadowOffset',
          part = Base.capitalize(key),
          flag = flags[key],
          set = 'set' + part,
          get = 'get' + part;

      fields[set] = function (value) {
        var owner = this._owner,
            children = owner && owner._children,
            applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath);

        if (applyToChildren) {
          for (var i = 0, l = children.length; i < l; i++) children[i]._style[set](value);
        }

        if ((key === 'selectedColor' || !applyToChildren) && key in this._defaults) {
          var old = this._values[key];

          if (old !== value) {
            if (isColor) {
              if (old) {
                Color._setOwner(old, null);

                old._canvasStyle = null;
              }

              if (value && value.constructor === Color) {
                value = Color._setOwner(value, owner, applyToChildren && set);
              }
            }

            this._values[key] = value;
            if (owner) owner._changed(flag || 129);
          }
        }
      };

      fields[get] = function (_dontMerge) {
        var owner = this._owner,
            children = owner && owner._children,
            applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath),
            value;

        if (applyToChildren && !_dontMerge) {
          for (var i = 0, l = children.length; i < l; i++) {
            var childValue = children[i]._style[get]();

            if (!i) {
              value = childValue;
            } else if (!Base.equals(value, childValue)) {
              return undefined;
            }
          }
        } else if (key in this._defaults) {
          var value = this._values[key];

          if (value === undefined) {
            value = this._defaults[key];

            if (value && value.clone) {
              value = value.clone();
            }
          } else {
            var ctor = isColor ? Color : isPoint ? Point : null;

            if (ctor && !(value && value.constructor === ctor)) {
              this._values[key] = value = ctor.read([value], 0, {
                readNull: true,
                clone: true
              });
            }
          }
        }

        if (value && isColor) {
          value = Color._setOwner(value, owner, applyToChildren && set);
        }

        return value;
      };

      item[get] = function (_dontMerge) {
        return this._style[get](_dontMerge);
      };

      item[set] = function (value) {
        this._style[set](value);
      };
    });
    Base.each({
      Font: 'FontFamily',
      WindingRule: 'FillRule'
    }, function (value, key) {
      var get = 'get' + key,
          set = 'set' + key;
      fields[get] = item[get] = '#get' + value;
      fields[set] = item[set] = '#set' + value;
    });
    Item.inject(item);
    return fields;
  }(), {
    set: function (style) {
      var isStyle = style instanceof Style,
          values = isStyle ? style._values : style;

      if (values) {
        for (var key in values) {
          if (key in this._defaults) {
            var value = values[key];
            this[key] = value && isStyle && value.clone ? value.clone() : value;
          }
        }
      }
    },
    equals: function (style) {
      function compare(style1, style2, secondary) {
        var values1 = style1._values,
            values2 = style2._values,
            defaults2 = style2._defaults;

        for (var key in values1) {
          var value1 = values1[key],
              value2 = values2[key];
          if (!(secondary && key in values2) && !Base.equals(value1, value2 === undefined ? defaults2[key] : value2)) return false;
        }

        return true;
      }

      return style === this || style && this._class === style._class && compare(this, style) && compare(style, this, true) || false;
    },
    _dispose: function () {
      var color;
      color = this.getFillColor();
      if (color) color._canvasStyle = null;
      color = this.getStrokeColor();
      if (color) color._canvasStyle = null;
      color = this.getShadowColor();
      if (color) color._canvasStyle = null;
    },
    hasFill: function () {
      var color = this.getFillColor();
      return !!color && color.alpha > 0;
    },
    hasStroke: function () {
      var color = this.getStrokeColor();
      return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
    },
    hasShadow: function () {
      var color = this.getShadowColor();
      return !!color && color.alpha > 0 && (this.getShadowBlur() > 0 || !this.getShadowOffset().isZero());
    },
    getView: function () {
      return this._project._view;
    },
    getFontStyle: function () {
      var fontSize = this.getFontSize();
      return this.getFontWeight() + ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ') + this.getFontFamily();
    },
    getFont: '#getFontFamily',
    setFont: '#setFontFamily',
    getLeading: function getLeading() {
      var leading = getLeading.base.call(this),
          fontSize = this.getFontSize();
      if (/pt|em|%|px/.test(fontSize)) fontSize = this.getView().getPixelSize(fontSize);
      return leading != null ? leading : fontSize * 1.2;
    }
  });
  var DomElement = new function () {
    function handlePrefix(el, name, set, value) {
      var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
          suffix = name[0].toUpperCase() + name.substring(1);

      for (var i = 0; i < 6; i++) {
        var prefix = prefixes[i],
            key = prefix ? prefix + suffix : name;

        if (key in el) {
          if (set) {
            el[key] = value;
          } else {
            return el[key];
          }

          break;
        }
      }
    }

    return {
      getStyles: function (el) {
        var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
            view = doc && doc.defaultView;
        return view && view.getComputedStyle(el, '');
      },
      getBounds: function (el, viewport) {
        var doc = el.ownerDocument,
            body = doc.body,
            html = doc.documentElement,
            rect;

        try {
          rect = el.getBoundingClientRect();
        } catch (e) {
          rect = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
          };
        }

        var x = rect.left - (html.clientLeft || body.clientLeft || 0),
            y = rect.top - (html.clientTop || body.clientTop || 0);

        if (!viewport) {
          var view = doc.defaultView;
          x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
          y += view.pageYOffset || html.scrollTop || body.scrollTop;
        }

        return new Rectangle(x, y, rect.width, rect.height);
      },
      getViewportBounds: function (el) {
        var doc = el.ownerDocument,
            view = doc.defaultView,
            html = doc.documentElement;
        return new Rectangle(0, 0, view.innerWidth || html.clientWidth, view.innerHeight || html.clientHeight);
      },
      getOffset: function (el, viewport) {
        return DomElement.getBounds(el, viewport).getPoint();
      },
      getSize: function (el) {
        return DomElement.getBounds(el, true).getSize();
      },
      isInvisible: function (el) {
        return DomElement.getSize(el).equals(new Size(0, 0));
      },
      isInView: function (el) {
        return !DomElement.isInvisible(el) && DomElement.getViewportBounds(el).intersects(DomElement.getBounds(el, true));
      },
      isInserted: function (el) {
        return document.body.contains(el);
      },
      getPrefixed: function (el, name) {
        return el && handlePrefix(el, name);
      },
      setPrefixed: function (el, name, value) {
        if (typeof name === 'object') {
          for (var key in name) handlePrefix(el, key, true, name[key]);
        } else {
          handlePrefix(el, name, true, value);
        }
      }
    };
  }();
  var DomEvent = {
    add: function (el, events) {
      if (el) {
        for (var type in events) {
          var func = events[type],
              parts = type.split(/[\s,]+/g);

          for (var i = 0, l = parts.length; i < l; i++) {
            var name = parts[i];
            var options = el === document && (name === 'touchstart' || name === 'touchmove') ? {
              passive: false
            } : false;
            el.addEventListener(name, func, options);
          }
        }
      }
    },
    remove: function (el, events) {
      if (el) {
        for (var type in events) {
          var func = events[type],
              parts = type.split(/[\s,]+/g);

          for (var i = 0, l = parts.length; i < l; i++) el.removeEventListener(parts[i], func, false);
        }
      }
    },
    getPoint: function (event) {
      var pos = event.targetTouches ? event.targetTouches.length ? event.targetTouches[0] : event.changedTouches[0] : event;
      return new Point(pos.pageX || pos.clientX + document.documentElement.scrollLeft, pos.pageY || pos.clientY + document.documentElement.scrollTop);
    },
    getTarget: function (event) {
      return event.target || event.srcElement;
    },
    getRelatedTarget: function (event) {
      return event.relatedTarget || event.toElement;
    },
    getOffset: function (event, target) {
      return DomEvent.getPoint(event).subtract(DomElement.getOffset(target || DomEvent.getTarget(event)));
    }
  };
  DomEvent.requestAnimationFrame = new function () {
    var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
        requested = false,
        callbacks = [],
        timer;

    function handleCallbacks() {
      var functions = callbacks;
      callbacks = [];

      for (var i = 0, l = functions.length; i < l; i++) functions[i]();

      requested = nativeRequest && callbacks.length;
      if (requested) nativeRequest(handleCallbacks);
    }

    return function (callback) {
      callbacks.push(callback);

      if (nativeRequest) {
        if (!requested) {
          nativeRequest(handleCallbacks);
          requested = true;
        }
      } else if (!timer) {
        timer = setInterval(handleCallbacks, 1000 / 60);
      }
    };
  }();
  var View = Base.extend(Emitter, {
    _class: 'View',
    initialize: function View(project, element) {
      function getSize(name) {
        return element[name] || parseInt(element.getAttribute(name), 10);
      }

      function getCanvasSize() {
        var size = DomElement.getSize(element);
        return size.isNaN() || size.isZero() ? new Size(getSize('width'), getSize('height')) : size;
      }

      var size;

      if (window && element) {
        this._id = element.getAttribute('id');
        if (this._id == null) element.setAttribute('id', this._id = 'paper-view-' + View._id++);
        DomEvent.add(element, this._viewEvents);
        var none = 'none';
        DomElement.setPrefixed(element.style, {
          userDrag: none,
          userSelect: none,
          touchCallout: none,
          contentZooming: none,
          tapHighlightColor: 'rgba(0,0,0,0)'
        });

        if (PaperScope.hasAttribute(element, 'resize')) {
          var that = this;
          DomEvent.add(window, this._windowEvents = {
            resize: function () {
              that.setViewSize(getCanvasSize());
            }
          });
        }

        size = getCanvasSize();

        if (PaperScope.hasAttribute(element, 'stats') && typeof Stats !== 'undefined') {
          this._stats = new Stats();
          var stats = this._stats.domElement,
              style = stats.style,
              offset = DomElement.getOffset(element);
          style.position = 'absolute';
          style.left = offset.x + 'px';
          style.top = offset.y + 'px';
          document.body.appendChild(stats);
        }
      } else {
        size = new Size(element);
        element = null;
      }

      this._project = project;
      this._scope = project._scope;
      this._element = element;
      if (!this._pixelRatio) this._pixelRatio = window && window.devicePixelRatio || 1;

      this._setElementSize(size.width, size.height);

      this._viewSize = size;

      View._views.push(this);

      View._viewsById[this._id] = this;
      (this._matrix = new Matrix())._owner = this;
      if (!View._focused) View._focused = this;
      this._frameItems = {};
      this._frameItemCount = 0;
      this._itemEvents = {
        native: {},
        virtual: {}
      };
      this._autoUpdate = !paper.agent.node;
      this._needsUpdate = false;
    },
    remove: function () {
      if (!this._project) return false;
      if (View._focused === this) View._focused = null;

      View._views.splice(View._views.indexOf(this), 1);

      delete View._viewsById[this._id];
      var project = this._project;
      if (project._view === this) project._view = null;
      DomEvent.remove(this._element, this._viewEvents);
      DomEvent.remove(window, this._windowEvents);
      this._element = this._project = null;
      this.off('frame');
      this._animate = false;
      this._frameItems = {};
      return true;
    },
    _events: Base.each(Item._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']), function (name) {
      this[name] = {};
    }, {
      onFrame: {
        install: function () {
          this.play();
        },
        uninstall: function () {
          this.pause();
        }
      }
    }),
    _animate: false,
    _time: 0,
    _count: 0,
    getAutoUpdate: function () {
      return this._autoUpdate;
    },
    setAutoUpdate: function (autoUpdate) {
      this._autoUpdate = autoUpdate;
      if (autoUpdate) this.requestUpdate();
    },
    update: function () {},
    draw: function () {
      this.update();
    },
    requestUpdate: function () {
      if (!this._requested) {
        var that = this;
        DomEvent.requestAnimationFrame(function () {
          that._requested = false;

          if (that._animate) {
            that.requestUpdate();
            var element = that._element;

            if ((!DomElement.getPrefixed(document, 'hidden') || PaperScope.getAttribute(element, 'keepalive') === 'true') && DomElement.isInView(element)) {
              that._handleFrame();
            }
          }

          if (that._autoUpdate) that.update();
        });
        this._requested = true;
      }
    },
    play: function () {
      this._animate = true;
      this.requestUpdate();
    },
    pause: function () {
      this._animate = false;
    },
    _handleFrame: function () {
      paper = this._scope;
      var now = Date.now() / 1000,
          delta = this._last ? now - this._last : 0;
      this._last = now;
      this.emit('frame', new Base({
        delta: delta,
        time: this._time += delta,
        count: this._count++
      }));
      if (this._stats) this._stats.update();
    },
    _animateItem: function (item, animate) {
      var items = this._frameItems;

      if (animate) {
        items[item._id] = {
          item: item,
          time: 0,
          count: 0
        };
        if (++this._frameItemCount === 1) this.on('frame', this._handleFrameItems);
      } else {
        delete items[item._id];

        if (--this._frameItemCount === 0) {
          this.off('frame', this._handleFrameItems);
        }
      }
    },
    _handleFrameItems: function (event) {
      for (var i in this._frameItems) {
        var entry = this._frameItems[i];
        entry.item.emit('frame', new Base(event, {
          time: entry.time += event.delta,
          count: entry.count++
        }));
      }
    },
    _changed: function () {
      this._project._changed(4097);

      this._bounds = this._decomposed = undefined;
    },
    getElement: function () {
      return this._element;
    },
    getPixelRatio: function () {
      return this._pixelRatio;
    },
    getResolution: function () {
      return this._pixelRatio * 72;
    },
    getViewSize: function () {
      var size = this._viewSize;
      return new LinkedSize(size.width, size.height, this, 'setViewSize');
    },
    setViewSize: function () {
      var size = Size.read(arguments),
          delta = size.subtract(this._viewSize);
      if (delta.isZero()) return;

      this._setElementSize(size.width, size.height);

      this._viewSize.set(size);

      this._changed();

      this.emit('resize', {
        size: size,
        delta: delta
      });

      if (this._autoUpdate) {
        this.update();
      }
    },
    _setElementSize: function (width, height) {
      var element = this._element;

      if (element) {
        if (element.width !== width) element.width = width;
        if (element.height !== height) element.height = height;
      }
    },
    getBounds: function () {
      if (!this._bounds) this._bounds = this._matrix.inverted()._transformBounds(new Rectangle(new Point(), this._viewSize));
      return this._bounds;
    },
    getSize: function () {
      return this.getBounds().getSize();
    },
    isVisible: function () {
      return DomElement.isInView(this._element);
    },
    isInserted: function () {
      return DomElement.isInserted(this._element);
    },
    getPixelSize: function (size) {
      var element = this._element,
          pixels;

      if (element) {
        var parent = element.parentNode,
            temp = document.createElement('div');
        temp.style.fontSize = size;
        parent.appendChild(temp);
        pixels = parseFloat(DomElement.getStyles(temp).fontSize);
        parent.removeChild(temp);
      } else {
        pixels = parseFloat(pixels);
      }

      return pixels;
    },
    getTextWidth: function (font, lines) {
      return 0;
    }
  }, Base.each(['rotate', 'scale', 'shear', 'skew'], function (key) {
    var rotate = key === 'rotate';

    this[key] = function () {
      var args = arguments,
          value = (rotate ? Base : Point).read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      return this.transform(new Matrix()[key](value, center || this.getCenter(true)));
    };
  }, {
    _decompose: function () {
      return this._decomposed || (this._decomposed = this._matrix.decompose());
    },
    translate: function () {
      var mx = new Matrix();
      return this.transform(mx.translate.apply(mx, arguments));
    },
    getCenter: function () {
      return this.getBounds().getCenter();
    },
    setCenter: function () {
      var center = Point.read(arguments);
      this.translate(this.getCenter().subtract(center));
    },
    getZoom: function () {
      var scaling = this._decompose().scaling;

      return (scaling.x + scaling.y) / 2;
    },
    setZoom: function (zoom) {
      this.transform(new Matrix().scale(zoom / this.getZoom(), this.getCenter()));
    },
    getRotation: function () {
      return this._decompose().rotation;
    },
    setRotation: function (rotation) {
      var current = this.getRotation();

      if (current != null && rotation != null) {
        this.rotate(rotation - current);
      }
    },
    getScaling: function () {
      var scaling = this._decompose().scaling;

      return new LinkedPoint(scaling.x, scaling.y, this, 'setScaling');
    },
    setScaling: function () {
      var current = this.getScaling(),
          scaling = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });

      if (current && scaling) {
        this.scale(scaling.x / current.x, scaling.y / current.y);
      }
    },
    getMatrix: function () {
      return this._matrix;
    },
    setMatrix: function () {
      var matrix = this._matrix;
      matrix.set.apply(matrix, arguments);
    },
    transform: function (matrix) {
      this._matrix.append(matrix);
    },
    scrollBy: function () {
      this.translate(Point.read(arguments).negate());
    }
  }), {
    projectToView: function () {
      return this._matrix._transformPoint(Point.read(arguments));
    },
    viewToProject: function () {
      return this._matrix._inverseTransform(Point.read(arguments));
    },
    getEventPoint: function (event) {
      return this.viewToProject(DomEvent.getOffset(event, this._element));
    }
  }, {
    statics: {
      _views: [],
      _viewsById: {},
      _id: 0,
      create: function (project, element) {
        if (document && typeof element === 'string') element = document.getElementById(element);
        var ctor = window ? CanvasView : View;
        return new ctor(project, element);
      }
    }
  }, new function () {
    if (!window) return;
    var prevFocus,
        tempFocus,
        dragging = false,
        mouseDown = false;

    function getView(event) {
      var target = DomEvent.getTarget(event);
      return target.getAttribute && View._viewsById[target.getAttribute('id')];
    }

    function updateFocus() {
      var view = View._focused;

      if (!view || !view.isVisible()) {
        for (var i = 0, l = View._views.length; i < l; i++) {
          if ((view = View._views[i]).isVisible()) {
            View._focused = tempFocus = view;
            break;
          }
        }
      }
    }

    function handleMouseMove(view, event, point) {
      view._handleMouseEvent('mousemove', event, point);
    }

    var navigator = window.navigator,
        mousedown,
        mousemove,
        mouseup;

    if (navigator.pointerEnabled || navigator.msPointerEnabled) {
      mousedown = 'pointerdown MSPointerDown';
      mousemove = 'pointermove MSPointerMove';
      mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
    } else {
      mousedown = 'touchstart';
      mousemove = 'touchmove';
      mouseup = 'touchend touchcancel';

      if (!('ontouchstart' in window && navigator.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
        mousedown += ' mousedown';
        mousemove += ' mousemove';
        mouseup += ' mouseup';
      }
    }

    var viewEvents = {},
        docEvents = {
      mouseout: function (event) {
        var view = View._focused,
            target = DomEvent.getRelatedTarget(event);

        if (view && (!target || target.nodeName === 'HTML')) {
          var offset = DomEvent.getOffset(event, view._element),
              x = offset.x,
              abs = Math.abs,
              ax = abs(x),
              max = 1 << 25,
              diff = ax - max;
          offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;
          handleMouseMove(view, event, view.viewToProject(offset));
        }
      },
      scroll: updateFocus
    };

    viewEvents[mousedown] = function (event) {
      var view = View._focused = getView(event);

      if (!dragging) {
        dragging = true;

        view._handleMouseEvent('mousedown', event);
      }
    };

    docEvents[mousemove] = function (event) {
      var view = View._focused;

      if (!mouseDown) {
        var target = getView(event);

        if (target) {
          if (view !== target) {
            if (view) handleMouseMove(view, event);
            if (!prevFocus) prevFocus = view;
            view = View._focused = tempFocus = target;
          }
        } else if (tempFocus && tempFocus === view) {
          if (prevFocus && !prevFocus.isInserted()) prevFocus = null;
          view = View._focused = prevFocus;
          prevFocus = null;
          updateFocus();
        }
      }

      if (view) handleMouseMove(view, event);
    };

    docEvents[mousedown] = function () {
      mouseDown = true;
    };

    docEvents[mouseup] = function (event) {
      var view = View._focused;
      if (view && dragging) view._handleMouseEvent('mouseup', event);
      mouseDown = dragging = false;
    };

    DomEvent.add(document, docEvents);
    DomEvent.add(window, {
      load: updateFocus
    });
    var called = false,
        prevented = false,
        fallbacks = {
      doubleclick: 'click',
      mousedrag: 'mousemove'
    },
        wasInView = false,
        overView,
        downPoint,
        lastPoint,
        downItem,
        overItem,
        dragItem,
        clickItem,
        clickTime,
        dblClick;

    function emitMouseEvent(obj, target, type, event, point, prevPoint, stopItem) {
      var stopped = false,
          mouseEvent;

      function emit(obj, type) {
        if (obj.responds(type)) {
          if (!mouseEvent) {
            mouseEvent = new MouseEvent(type, event, point, target || obj, prevPoint ? point.subtract(prevPoint) : null);
          }

          if (obj.emit(type, mouseEvent)) {
            called = true;
            if (mouseEvent.prevented) prevented = true;
            if (mouseEvent.stopped) return stopped = true;
          }
        } else {
          var fallback = fallbacks[type];
          if (fallback) return emit(obj, fallback);
        }
      }

      while (obj && obj !== stopItem) {
        if (emit(obj, type)) break;
        obj = obj._parent;
      }

      return stopped;
    }

    function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
      view._project.removeOn(type);

      prevented = called = false;
      return dragItem && emitMouseEvent(dragItem, null, type, event, point, prevPoint) || hitItem && hitItem !== dragItem && !hitItem.isDescendant(dragItem) && emitMouseEvent(hitItem, null, type === 'mousedrag' ? 'mousemove' : type, event, point, prevPoint, dragItem) || emitMouseEvent(view, dragItem || hitItem || view, type, event, point, prevPoint);
    }

    var itemEventsMap = {
      mousedown: {
        mousedown: 1,
        mousedrag: 1,
        click: 1,
        doubleclick: 1
      },
      mouseup: {
        mouseup: 1,
        mousedrag: 1,
        click: 1,
        doubleclick: 1
      },
      mousemove: {
        mousedrag: 1,
        mousemove: 1,
        mouseenter: 1,
        mouseleave: 1
      }
    };
    return {
      _viewEvents: viewEvents,
      _handleMouseEvent: function (type, event, point) {
        var itemEvents = this._itemEvents,
            hitItems = itemEvents.native[type],
            nativeMove = type === 'mousemove',
            tool = this._scope.tool,
            view = this;

        function responds(type) {
          return itemEvents.virtual[type] || view.responds(type) || tool && tool.responds(type);
        }

        if (nativeMove && dragging && responds('mousedrag')) type = 'mousedrag';
        if (!point) point = this.getEventPoint(event);

        var inView = this.getBounds().contains(point),
            hit = hitItems && inView && view._project.hitTest(point, {
          tolerance: 0,
          fill: true,
          stroke: true
        }),
            hitItem = hit && hit.item || null,
            handle = false,
            mouse = {};

        mouse[type.substr(5)] = true;

        if (hitItems && hitItem !== overItem) {
          if (overItem) {
            emitMouseEvent(overItem, null, 'mouseleave', event, point);
          }

          if (hitItem) {
            emitMouseEvent(hitItem, null, 'mouseenter', event, point);
          }

          overItem = hitItem;
        }

        if (wasInView ^ inView) {
          emitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave', event, point);
          overView = inView ? this : null;
          handle = true;
        }

        if ((inView || mouse.drag) && !point.equals(lastPoint)) {
          emitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove', event, point, lastPoint);
          handle = true;
        }

        wasInView = inView;

        if (mouse.down && inView || mouse.up && downPoint) {
          emitMouseEvents(this, hitItem, type, event, point, downPoint);

          if (mouse.down) {
            dblClick = hitItem === clickItem && Date.now() - clickTime < 300;
            downItem = clickItem = hitItem;

            if (!prevented && hitItem) {
              var item = hitItem;

              while (item && !item.responds('mousedrag')) item = item._parent;

              if (item) dragItem = hitItem;
            }

            downPoint = point;
          } else if (mouse.up) {
            if (!prevented && hitItem === downItem) {
              clickTime = Date.now();
              emitMouseEvents(this, hitItem, dblClick ? 'doubleclick' : 'click', event, point, downPoint);
              dblClick = false;
            }

            downItem = dragItem = null;
          }

          wasInView = false;
          handle = true;
        }

        lastPoint = point;

        if (handle && tool) {
          called = tool._handleMouseEvent(type, event, point, mouse) || called;
        }

        if (event.cancelable !== false && (called && !mouse.move || mouse.down && responds('mouseup'))) {
          event.preventDefault();
        }
      },
      _handleKeyEvent: function (type, event, key, character) {
        var scope = this._scope,
            tool = scope.tool,
            keyEvent;

        function emit(obj) {
          if (obj.responds(type)) {
            paper = scope;
            obj.emit(type, keyEvent = keyEvent || new KeyEvent(type, event, key, character));
          }
        }

        if (this.isVisible()) {
          emit(this);
          if (tool && tool.responds(type)) emit(tool);
        }
      },
      _countItemEvent: function (type, sign) {
        var itemEvents = this._itemEvents,
            native = itemEvents.native,
            virtual = itemEvents.virtual;

        for (var key in itemEventsMap) {
          native[key] = (native[key] || 0) + (itemEventsMap[key][type] || 0) * sign;
        }

        virtual[type] = (virtual[type] || 0) + sign;
      },
      statics: {
        updateFocus: updateFocus,
        _resetState: function () {
          dragging = mouseDown = called = wasInView = false;
          prevFocus = tempFocus = overView = downPoint = lastPoint = downItem = overItem = dragItem = clickItem = clickTime = dblClick = null;
        }
      }
    };
  }());
  var CanvasView = View.extend({
    _class: 'CanvasView',
    initialize: function CanvasView(project, canvas) {
      if (!(canvas instanceof window.HTMLCanvasElement)) {
        var size = Size.read(arguments, 1);
        if (size.isZero()) throw new Error('Cannot create CanvasView with the provided argument: ' + Base.slice(arguments, 1));
        canvas = CanvasProvider.getCanvas(size);
      }

      var ctx = this._context = canvas.getContext('2d');
      ctx.save();
      this._pixelRatio = 1;

      if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
        var deviceRatio = window.devicePixelRatio || 1,
            backingStoreRatio = DomElement.getPrefixed(ctx, 'backingStorePixelRatio') || 1;
        this._pixelRatio = deviceRatio / backingStoreRatio;
      }

      View.call(this, project, canvas);
      this._needsUpdate = true;
    },
    remove: function remove() {
      this._context.restore();

      return remove.base.call(this);
    },
    _setElementSize: function _setElementSize(width, height) {
      var pixelRatio = this._pixelRatio;

      _setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);

      if (pixelRatio !== 1) {
        var element = this._element,
            ctx = this._context;

        if (!PaperScope.hasAttribute(element, 'resize')) {
          var style = element.style;
          style.width = width + 'px';
          style.height = height + 'px';
        }

        ctx.restore();
        ctx.save();
        ctx.scale(pixelRatio, pixelRatio);
      }
    },
    getContext: function () {
      return this._context;
    },
    getPixelSize: function getPixelSize(size) {
      var agent = paper.agent,
          pixels;

      if (agent && agent.firefox) {
        pixels = getPixelSize.base.call(this, size);
      } else {
        var ctx = this._context,
            prevFont = ctx.font;
        ctx.font = size + ' serif';
        pixels = parseFloat(ctx.font);
        ctx.font = prevFont;
      }

      return pixels;
    },
    getTextWidth: function (font, lines) {
      var ctx = this._context,
          prevFont = ctx.font,
          width = 0;
      ctx.font = font;

      for (var i = 0, l = lines.length; i < l; i++) width = Math.max(width, ctx.measureText(lines[i]).width);

      ctx.font = prevFont;
      return width;
    },
    update: function () {
      if (!this._needsUpdate) return false;
      var project = this._project,
          ctx = this._context,
          size = this._viewSize;
      ctx.clearRect(0, 0, size.width + 1, size.height + 1);
      if (project) project.draw(ctx, this._matrix, this._pixelRatio);
      this._needsUpdate = false;
      return true;
    }
  });
  var Event = Base.extend({
    _class: 'Event',
    initialize: function Event(event) {
      this.event = event;
      this.type = event && event.type;
    },
    prevented: false,
    stopped: false,
    preventDefault: function () {
      this.prevented = true;
      this.event.preventDefault();
    },
    stopPropagation: function () {
      this.stopped = true;
      this.event.stopPropagation();
    },
    stop: function () {
      this.stopPropagation();
      this.preventDefault();
    },
    getTimeStamp: function () {
      return this.event.timeStamp;
    },
    getModifiers: function () {
      return Key.modifiers;
    }
  });
  var KeyEvent = Event.extend({
    _class: 'KeyEvent',
    initialize: function KeyEvent(type, event, key, character) {
      this.type = type;
      this.event = event;
      this.key = key;
      this.character = character;
    },
    toString: function () {
      return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
    }
  });
  var Key = new function () {
    var keyLookup = {
      '\t': 'tab',
      ' ': 'space',
      '\b': 'backspace',
      '\x7f': 'delete',
      'Spacebar': 'space',
      'Del': 'delete',
      'Win': 'meta',
      'Esc': 'escape'
    },
        charLookup = {
      'tab': '\t',
      'space': ' ',
      'enter': '\r'
    },
        keyMap = {},
        charMap = {},
        metaFixMap,
        downKey,
        modifiers = new Base({
      shift: false,
      control: false,
      alt: false,
      meta: false,
      capsLock: false,
      space: false
    }).inject({
      option: {
        get: function () {
          return this.alt;
        }
      },
      command: {
        get: function () {
          var agent = paper && paper.agent;
          return agent && agent.mac ? this.meta : this.control;
        }
      }
    });

    function getKey(event) {
      var key = event.key || event.keyIdentifier;
      key = /^U\+/.test(key) ? String.fromCharCode(parseInt(key.substr(2), 16)) : /^Arrow[A-Z]/.test(key) ? key.substr(5) : key === 'Unidentified' || key === undefined ? String.fromCharCode(event.keyCode) : key;
      return keyLookup[key] || (key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
    }

    function handleKey(down, key, character, event) {
      var type = down ? 'keydown' : 'keyup',
          view = View._focused,
          name;
      keyMap[key] = down;

      if (down) {
        charMap[key] = character;
      } else {
        delete charMap[key];
      }

      if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
        modifiers[name] = down;
        var agent = paper && paper.agent;

        if (name === 'meta' && agent && agent.mac) {
          if (down) {
            metaFixMap = {};
          } else {
            for (var k in metaFixMap) {
              if (k in charMap) handleKey(false, k, metaFixMap[k], event);
            }

            metaFixMap = null;
          }
        }
      } else if (down && metaFixMap) {
        metaFixMap[key] = character;
      }

      if (view) {
        view._handleKeyEvent(down ? 'keydown' : 'keyup', event, key, character);
      }
    }

    DomEvent.add(document, {
      keydown: function (event) {
        var key = getKey(event),
            agent = paper && paper.agent;

        if (key.length > 1 || agent && agent.chrome && (event.altKey || agent.mac && event.metaKey || !agent.mac && event.ctrlKey)) {
          handleKey(true, key, charLookup[key] || (key.length > 1 ? '' : key), event);
        } else {
          downKey = key;
        }
      },
      keypress: function (event) {
        if (downKey) {
          var key = getKey(event),
              code = event.charCode,
              character = code >= 32 ? String.fromCharCode(code) : key.length > 1 ? '' : key;

          if (key !== downKey) {
            key = character.toLowerCase();
          }

          handleKey(true, key, character, event);
          downKey = null;
        }
      },
      keyup: function (event) {
        var key = getKey(event);
        if (key in charMap) handleKey(false, key, charMap[key], event);
      }
    });
    DomEvent.add(window, {
      blur: function (event) {
        for (var key in charMap) handleKey(false, key, charMap[key], event);
      }
    });
    return {
      modifiers: modifiers,
      isDown: function (key) {
        return !!keyMap[key];
      }
    };
  }();
  var MouseEvent = Event.extend({
    _class: 'MouseEvent',
    initialize: function MouseEvent(type, event, point, target, delta) {
      this.type = type;
      this.event = event;
      this.point = point;
      this.target = target;
      this.delta = delta;
    },
    toString: function () {
      return "{ type: '" + this.type + "', point: " + this.point + ', target: ' + this.target + (this.delta ? ', delta: ' + this.delta : '') + ', modifiers: ' + this.getModifiers() + ' }';
    }
  });
  var ToolEvent = Event.extend({
    _class: 'ToolEvent',
    _item: null,
    initialize: function ToolEvent(tool, type, event) {
      this.tool = tool;
      this.type = type;
      this.event = event;
    },
    _choosePoint: function (point, toolPoint) {
      return point ? point : toolPoint ? toolPoint.clone() : null;
    },
    getPoint: function () {
      return this._choosePoint(this._point, this.tool._point);
    },
    setPoint: function (point) {
      this._point = point;
    },
    getLastPoint: function () {
      return this._choosePoint(this._lastPoint, this.tool._lastPoint);
    },
    setLastPoint: function (lastPoint) {
      this._lastPoint = lastPoint;
    },
    getDownPoint: function () {
      return this._choosePoint(this._downPoint, this.tool._downPoint);
    },
    setDownPoint: function (downPoint) {
      this._downPoint = downPoint;
    },
    getMiddlePoint: function () {
      if (!this._middlePoint && this.tool._lastPoint) {
        return this.tool._point.add(this.tool._lastPoint).divide(2);
      }

      return this._middlePoint;
    },
    setMiddlePoint: function (middlePoint) {
      this._middlePoint = middlePoint;
    },
    getDelta: function () {
      return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
    },
    setDelta: function (delta) {
      this._delta = delta;
    },
    getCount: function () {
      return this.tool[/^mouse(down|up)$/.test(this.type) ? '_downCount' : '_moveCount'];
    },
    setCount: function (count) {
      this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count'] = count;
    },
    getItem: function () {
      if (!this._item) {
        var result = this.tool._scope.project.hitTest(this.getPoint());

        if (result) {
          var item = result.item,
              parent = item._parent;

          while (/^(Group|CompoundPath)$/.test(parent._class)) {
            item = parent;
            parent = parent._parent;
          }

          this._item = item;
        }
      }

      return this._item;
    },
    setItem: function (item) {
      this._item = item;
    },
    toString: function () {
      return '{ type: ' + this.type + ', point: ' + this.getPoint() + ', count: ' + this.getCount() + ', modifiers: ' + this.getModifiers() + ' }';
    }
  });
  var Tool = PaperScopeItem.extend({
    _class: 'Tool',
    _list: 'tools',
    _reference: 'tool',
    _events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove', 'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown', 'onKeyUp'],
    initialize: function Tool(props) {
      PaperScopeItem.call(this);
      this._moveCount = -1;
      this._downCount = -1;
      this.set(props);
    },
    getMinDistance: function () {
      return this._minDistance;
    },
    setMinDistance: function (minDistance) {
      this._minDistance = minDistance;

      if (minDistance != null && this._maxDistance != null && minDistance > this._maxDistance) {
        this._maxDistance = minDistance;
      }
    },
    getMaxDistance: function () {
      return this._maxDistance;
    },
    setMaxDistance: function (maxDistance) {
      this._maxDistance = maxDistance;

      if (this._minDistance != null && maxDistance != null && maxDistance < this._minDistance) {
        this._minDistance = maxDistance;
      }
    },
    getFixedDistance: function () {
      return this._minDistance == this._maxDistance ? this._minDistance : null;
    },
    setFixedDistance: function (distance) {
      this._minDistance = this._maxDistance = distance;
    },
    _handleMouseEvent: function (type, event, point, mouse) {
      paper = this._scope;
      if (mouse.drag && !this.responds(type)) type = 'mousemove';
      var move = mouse.move || mouse.drag,
          responds = this.responds(type),
          minDistance = this.minDistance,
          maxDistance = this.maxDistance,
          called = false,
          tool = this;

      function update(minDistance, maxDistance) {
        var pt = point,
            toolPoint = move ? tool._point : tool._downPoint || pt;

        if (move) {
          if (tool._moveCount >= 0 && pt.equals(toolPoint)) {
            return false;
          }

          if (toolPoint && (minDistance != null || maxDistance != null)) {
            var vector = pt.subtract(toolPoint),
                distance = vector.getLength();
            if (distance < (minDistance || 0)) return false;

            if (maxDistance) {
              pt = toolPoint.add(vector.normalize(Math.min(distance, maxDistance)));
            }
          }

          tool._moveCount++;
        }

        tool._point = pt;
        tool._lastPoint = toolPoint || pt;

        if (mouse.down) {
          tool._moveCount = -1;
          tool._downPoint = pt;
          tool._downCount++;
        }

        return true;
      }

      function emit() {
        if (responds) {
          called = tool.emit(type, new ToolEvent(tool, type, event)) || called;
        }
      }

      if (mouse.down) {
        update();
        emit();
      } else if (mouse.up) {
        update(null, maxDistance);
        emit();
      } else if (responds) {
        while (update(minDistance, maxDistance)) emit();
      }

      return called;
    }
  });
  var Tween = Base.extend(Emitter, {
    _class: 'Tween',
    statics: {
      easings: {
        linear: function (t) {
          return t;
        },
        easeInQuad: function (t) {
          return t * t;
        },
        easeOutQuad: function (t) {
          return t * (2 - t);
        },
        easeInOutQuad: function (t) {
          return t < 0.5 ? 2 * t * t : -1 + 2 * (2 - t) * t;
        },
        easeInCubic: function (t) {
          return t * t * t;
        },
        easeOutCubic: function (t) {
          return --t * t * t + 1;
        },
        easeInOutCubic: function (t) {
          return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        },
        easeInQuart: function (t) {
          return t * t * t * t;
        },
        easeOutQuart: function (t) {
          return 1 - --t * t * t * t;
        },
        easeInOutQuart: function (t) {
          return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
        },
        easeInQuint: function (t) {
          return t * t * t * t * t;
        },
        easeOutQuint: function (t) {
          return 1 + --t * t * t * t * t;
        },
        easeInOutQuint: function (t) {
          return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
        }
      }
    },
    initialize: function Tween(object, from, to, duration, easing, start) {
      this.object = object;
      var type = typeof easing;
      var isFunction = type === 'function';
      this.type = isFunction ? type : type === 'string' ? easing : 'linear';
      this.easing = isFunction ? easing : Tween.easings[this.type];
      this.duration = duration;
      this.running = false;
      this._then = null;
      this._startTime = null;
      var state = from || to;
      this._keys = state ? Object.keys(state) : [];
      this._parsedKeys = this._parseKeys(this._keys);
      this._from = state && this._getState(from);
      this._to = state && this._getState(to);

      if (start !== false) {
        this.start();
      }
    },
    then: function (then) {
      this._then = then;
      return this;
    },
    start: function () {
      this._startTime = null;
      this.running = true;
      return this;
    },
    stop: function () {
      this.running = false;
      return this;
    },
    update: function (progress) {
      if (this.running) {
        if (progress >= 1) {
          progress = 1;
          this.running = false;
        }

        var factor = this.easing(progress),
            keys = this._keys,
            getValue = function (value) {
          return typeof value === 'function' ? value(factor, progress) : value;
        };

        for (var i = 0, l = keys && keys.length; i < l; i++) {
          var key = keys[i],
              from = getValue(this._from[key]),
              to = getValue(this._to[key]),
              value = from && to && from.__add && to.__add ? to.__subtract(from).__multiply(factor).__add(from) : (to - from) * factor + from;

          this._setProperty(this._parsedKeys[key], value);
        }

        if (this.responds('update')) {
          this.emit('update', new Base({
            progress: progress,
            factor: factor
          }));
        }

        if (!this.running && this._then) {
          this._then(this.object);
        }
      }

      return this;
    },
    _events: {
      onUpdate: {}
    },
    _handleFrame: function (time) {
      var startTime = this._startTime,
          progress = startTime ? (time - startTime) / this.duration : 0;

      if (!startTime) {
        this._startTime = time;
      }

      this.update(progress);
    },
    _getState: function (state) {
      var keys = this._keys,
          result = {};

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i],
            path = this._parsedKeys[key],
            current = this._getProperty(path),
            value;

        if (state) {
          var resolved = this._resolveValue(current, state[key]);

          this._setProperty(path, resolved);

          value = this._getProperty(path);
          value = value && value.clone ? value.clone() : value;

          this._setProperty(path, current);
        } else {
          value = current && current.clone ? current.clone() : current;
        }

        result[key] = value;
      }

      return result;
    },
    _resolveValue: function (current, value) {
      if (value) {
        if (Array.isArray(value) && value.length === 2) {
          var operator = value[0];
          return operator && operator.match && operator.match(/^[+\-\*\/]=/) ? this._calculate(current, operator[0], value[1]) : value;
        } else if (typeof value === 'string') {
          var match = value.match(/^[+\-*/]=(.*)/);

          if (match) {
            var parsed = JSON.parse(match[1].replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": '));
            return this._calculate(current, value[0], parsed);
          }
        }
      }

      return value;
    },
    _calculate: function (left, operator, right) {
      return paper.PaperScript.calculateBinary(left, operator, right);
    },
    _parseKeys: function (keys) {
      var parsed = {};

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i],
            path = key.replace(/\.([^.]*)/g, '/$1').replace(/\[['"]?([^'"\]]*)['"]?\]/g, '/$1');
        parsed[key] = path.split('/');
      }

      return parsed;
    },
    _getProperty: function (path, offset) {
      var obj = this.object;

      for (var i = 0, l = path.length - (offset || 0); i < l && obj; i++) {
        obj = obj[path[i]];
      }

      return obj;
    },
    _setProperty: function (path, value) {
      var dest = this._getProperty(path, 1);

      if (dest) {
        dest[path[path.length - 1]] = value;
      }
    }
  });
  var Http = {
    request: function (options) {
      var xhr = new self.XMLHttpRequest();
      xhr.open((options.method || 'get').toUpperCase(), options.url, Base.pick(options.async, true));
      if (options.mimeType) xhr.overrideMimeType(options.mimeType);

      xhr.onload = function () {
        var status = xhr.status;

        if (status === 0 || status === 200) {
          if (options.onLoad) {
            options.onLoad.call(xhr, xhr.responseText);
          }
        } else {
          xhr.onerror();
        }
      };

      xhr.onerror = function () {
        var status = xhr.status,
            message = 'Could not load "' + options.url + '" (Status: ' + status + ')';

        if (options.onError) {
          options.onError(message, status);
        } else {
          throw new Error(message);
        }
      };

      return xhr.send(null);
    }
  };
  var CanvasProvider = Base.exports.CanvasProvider = {
    canvases: [],
    getCanvas: function (width, height) {
      if (!window) return null;
      var canvas,
          clear = true;

      if (typeof width === 'object') {
        height = width.height;
        width = width.width;
      }

      if (this.canvases.length) {
        canvas = this.canvases.pop();
      } else {
        canvas = document.createElement('canvas');
        clear = false;
      }

      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Canvas ' + canvas + ' is unable to provide a 2D context.');
      }

      if (canvas.width === width && canvas.height === height) {
        if (clear) ctx.clearRect(0, 0, width + 1, height + 1);
      } else {
        canvas.width = width;
        canvas.height = height;
      }

      ctx.save();
      return canvas;
    },
    getContext: function (width, height) {
      var canvas = this.getCanvas(width, height);
      return canvas ? canvas.getContext('2d') : null;
    },
    release: function (obj) {
      var canvas = obj && obj.canvas ? obj.canvas : obj;

      if (canvas && canvas.getContext) {
        canvas.getContext('2d').restore();
        this.canvases.push(canvas);
      }
    }
  };
  var BlendMode = new function () {
    var min = Math.min,
        max = Math.max,
        abs = Math.abs,
        sr,
        sg,
        sb,
        sa,
        br,
        bg,
        bb,
        ba,
        dr,
        dg,
        db;

    function getLum(r, g, b) {
      return 0.2989 * r + 0.587 * g + 0.114 * b;
    }

    function setLum(r, g, b, l) {
      var d = l - getLum(r, g, b);
      dr = r + d;
      dg = g + d;
      db = b + d;
      var l = getLum(dr, dg, db),
          mn = min(dr, dg, db),
          mx = max(dr, dg, db);

      if (mn < 0) {
        var lmn = l - mn;
        dr = l + (dr - l) * l / lmn;
        dg = l + (dg - l) * l / lmn;
        db = l + (db - l) * l / lmn;
      }

      if (mx > 255) {
        var ln = 255 - l,
            mxl = mx - l;
        dr = l + (dr - l) * ln / mxl;
        dg = l + (dg - l) * ln / mxl;
        db = l + (db - l) * ln / mxl;
      }
    }

    function getSat(r, g, b) {
      return max(r, g, b) - min(r, g, b);
    }

    function setSat(r, g, b, s) {
      var col = [r, g, b],
          mx = max(r, g, b),
          mn = min(r, g, b),
          md;
      mn = mn === r ? 0 : mn === g ? 1 : 2;
      mx = mx === r ? 0 : mx === g ? 1 : 2;
      md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;

      if (col[mx] > col[mn]) {
        col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
        col[mx] = s;
      } else {
        col[md] = col[mx] = 0;
      }

      col[mn] = 0;
      dr = col[0];
      dg = col[1];
      db = col[2];
    }

    var modes = {
      multiply: function () {
        dr = br * sr / 255;
        dg = bg * sg / 255;
        db = bb * sb / 255;
      },
      screen: function () {
        dr = br + sr - br * sr / 255;
        dg = bg + sg - bg * sg / 255;
        db = bb + sb - bb * sb / 255;
      },
      overlay: function () {
        dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
        dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
        db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
      },
      'soft-light': function () {
        var t = sr * br / 255;
        dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
        t = sg * bg / 255;
        dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
        t = sb * bb / 255;
        db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
      },
      'hard-light': function () {
        dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
        dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
        db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
      },
      'color-dodge': function () {
        dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
        dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
        db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
      },
      'color-burn': function () {
        dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
        dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
        db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
      },
      darken: function () {
        dr = br < sr ? br : sr;
        dg = bg < sg ? bg : sg;
        db = bb < sb ? bb : sb;
      },
      lighten: function () {
        dr = br > sr ? br : sr;
        dg = bg > sg ? bg : sg;
        db = bb > sb ? bb : sb;
      },
      difference: function () {
        dr = br - sr;
        if (dr < 0) dr = -dr;
        dg = bg - sg;
        if (dg < 0) dg = -dg;
        db = bb - sb;
        if (db < 0) db = -db;
      },
      exclusion: function () {
        dr = br + sr * (255 - br - br) / 255;
        dg = bg + sg * (255 - bg - bg) / 255;
        db = bb + sb * (255 - bb - bb) / 255;
      },
      hue: function () {
        setSat(sr, sg, sb, getSat(br, bg, bb));
        setLum(dr, dg, db, getLum(br, bg, bb));
      },
      saturation: function () {
        setSat(br, bg, bb, getSat(sr, sg, sb));
        setLum(dr, dg, db, getLum(br, bg, bb));
      },
      luminosity: function () {
        setLum(br, bg, bb, getLum(sr, sg, sb));
      },
      color: function () {
        setLum(sr, sg, sb, getLum(br, bg, bb));
      },
      add: function () {
        dr = min(br + sr, 255);
        dg = min(bg + sg, 255);
        db = min(bb + sb, 255);
      },
      subtract: function () {
        dr = max(br - sr, 0);
        dg = max(bg - sg, 0);
        db = max(bb - sb, 0);
      },
      average: function () {
        dr = (br + sr) / 2;
        dg = (bg + sg) / 2;
        db = (bb + sb) / 2;
      },
      negation: function () {
        dr = 255 - abs(255 - sr - br);
        dg = 255 - abs(255 - sg - bg);
        db = 255 - abs(255 - sb - bb);
      }
    };
    var nativeModes = this.nativeModes = Base.each(['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'darker', 'copy', 'xor'], function (mode) {
      this[mode] = true;
    }, {});
    var ctx = CanvasProvider.getContext(1, 1);

    if (ctx) {
      Base.each(modes, function (func, mode) {
        var darken = mode === 'darken',
            ok = false;
        ctx.save();

        try {
          ctx.fillStyle = darken ? '#300' : '#a00';
          ctx.fillRect(0, 0, 1, 1);
          ctx.globalCompositeOperation = mode;

          if (ctx.globalCompositeOperation === mode) {
            ctx.fillStyle = darken ? '#a00' : '#300';
            ctx.fillRect(0, 0, 1, 1);
            ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
          }
        } catch (e) {}

        ctx.restore();
        nativeModes[mode] = ok;
      });
      CanvasProvider.release(ctx);
    }

    this.process = function (mode, srcContext, dstContext, alpha, offset) {
      var srcCanvas = srcContext.canvas,
          normal = mode === 'normal';

      if (normal || nativeModes[mode]) {
        dstContext.save();
        dstContext.setTransform(1, 0, 0, 1, 0, 0);
        dstContext.globalAlpha = alpha;
        if (!normal) dstContext.globalCompositeOperation = mode;
        dstContext.drawImage(srcCanvas, offset.x, offset.y);
        dstContext.restore();
      } else {
        var process = modes[mode];
        if (!process) return;
        var dstData = dstContext.getImageData(offset.x, offset.y, srcCanvas.width, srcCanvas.height),
            dst = dstData.data,
            src = srcContext.getImageData(0, 0, srcCanvas.width, srcCanvas.height).data;

        for (var i = 0, l = dst.length; i < l; i += 4) {
          sr = src[i];
          br = dst[i];
          sg = src[i + 1];
          bg = dst[i + 1];
          sb = src[i + 2];
          bb = dst[i + 2];
          sa = src[i + 3];
          ba = dst[i + 3];
          process();
          var a1 = sa * alpha / 255,
              a2 = 1 - a1;
          dst[i] = a1 * dr + a2 * br;
          dst[i + 1] = a1 * dg + a2 * bg;
          dst[i + 2] = a1 * db + a2 * bb;
          dst[i + 3] = sa * alpha + a2 * ba;
        }

        dstContext.putImageData(dstData, offset.x, offset.y);
      }
    };
  }();
  var SvgElement = new function () {
    var svg = 'http://www.w3.org/2000/svg',
        xmlns = 'http://www.w3.org/2000/xmlns',
        xlink = 'http://www.w3.org/1999/xlink',
        attributeNamespace = {
      href: xlink,
      xlink: xmlns,
      xmlns: xmlns + '/',
      'xmlns:xlink': xmlns + '/'
    };

    function create(tag, attributes, formatter) {
      return set(document.createElementNS(svg, tag), attributes, formatter);
    }

    function get(node, name) {
      var namespace = attributeNamespace[name],
          value = namespace ? node.getAttributeNS(namespace, name) : node.getAttribute(name);
      return value === 'null' ? null : value;
    }

    function set(node, attributes, formatter) {
      for (var name in attributes) {
        var value = attributes[name],
            namespace = attributeNamespace[name];
        if (typeof value === 'number' && formatter) value = formatter.number(value);

        if (namespace) {
          node.setAttributeNS(namespace, name, value);
        } else {
          node.setAttribute(name, value);
        }
      }

      return node;
    }

    return {
      svg: svg,
      xmlns: xmlns,
      xlink: xlink,
      create: create,
      get: get,
      set: set
    };
  }();
  var SvgStyles = Base.each({
    fillColor: ['fill', 'color'],
    fillRule: ['fill-rule', 'string'],
    strokeColor: ['stroke', 'color'],
    strokeWidth: ['stroke-width', 'number'],
    strokeCap: ['stroke-linecap', 'string'],
    strokeJoin: ['stroke-linejoin', 'string'],
    strokeScaling: ['vector-effect', 'lookup', {
      true: 'none',
      false: 'non-scaling-stroke'
    }, function (item, value) {
      return !value && (item instanceof PathItem || item instanceof Shape || item instanceof TextItem);
    }],
    miterLimit: ['stroke-miterlimit', 'number'],
    dashArray: ['stroke-dasharray', 'array'],
    dashOffset: ['stroke-dashoffset', 'number'],
    fontFamily: ['font-family', 'string'],
    fontWeight: ['font-weight', 'string'],
    fontSize: ['font-size', 'number'],
    justification: ['text-anchor', 'lookup', {
      left: 'start',
      center: 'middle',
      right: 'end'
    }],
    opacity: ['opacity', 'number'],
    blendMode: ['mix-blend-mode', 'style']
  }, function (entry, key) {
    var part = Base.capitalize(key),
        lookup = entry[2];
    this[key] = {
      type: entry[1],
      property: key,
      attribute: entry[0],
      toSVG: lookup,
      fromSVG: lookup && Base.each(lookup, function (value, name) {
        this[value] = name;
      }, {}),
      exportFilter: entry[3],
      get: 'get' + part,
      set: 'set' + part
    };
  }, {});
  new function () {
    var formatter;

    function getTransform(matrix, coordinates, center) {
      var attrs = new Base(),
          trans = matrix.getTranslation();

      if (coordinates) {
        var point;

        if (matrix.isInvertible()) {
          matrix = matrix._shiftless();
          point = matrix._inverseTransform(trans);
          trans = null;
        } else {
          point = new Point();
        }

        attrs[center ? 'cx' : 'x'] = point.x;
        attrs[center ? 'cy' : 'y'] = point.y;
      }

      if (!matrix.isIdentity()) {
        var decomposed = matrix.decompose();

        if (decomposed) {
          var parts = [],
              angle = decomposed.rotation,
              scale = decomposed.scaling,
              skew = decomposed.skewing;
          if (trans && !trans.isZero()) parts.push('translate(' + formatter.point(trans) + ')');
          if (angle) parts.push('rotate(' + formatter.number(angle) + ')');
          if (!Numerical.isZero(scale.x - 1) || !Numerical.isZero(scale.y - 1)) parts.push('scale(' + formatter.point(scale) + ')');
          if (skew.x) parts.push('skewX(' + formatter.number(skew.x) + ')');
          if (skew.y) parts.push('skewY(' + formatter.number(skew.y) + ')');
          attrs.transform = parts.join(' ');
        } else {
          attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
        }
      }

      return attrs;
    }

    function exportGroup(item, options) {
      var attrs = getTransform(item._matrix),
          children = item._children;
      var node = SvgElement.create('g', attrs, formatter);

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        var childNode = exportSVG(child, options);

        if (childNode) {
          if (child.isClipMask()) {
            var clip = SvgElement.create('clipPath');
            clip.appendChild(childNode);
            setDefinition(child, clip, 'clip');
            SvgElement.set(node, {
              'clip-path': 'url(#' + clip.id + ')'
            });
          } else {
            node.appendChild(childNode);
          }
        }
      }

      return node;
    }

    function exportRaster(item, options) {
      var attrs = getTransform(item._matrix, true),
          size = item.getSize(),
          image = item.getImage();
      attrs.x -= size.width / 2;
      attrs.y -= size.height / 2;
      attrs.width = size.width;
      attrs.height = size.height;
      attrs.href = options.embedImages == false && image && image.src || item.toDataURL();
      return SvgElement.create('image', attrs, formatter);
    }

    function exportPath(item, options) {
      var matchShapes = options.matchShapes;

      if (matchShapes) {
        var shape = item.toShape(false);
        if (shape) return exportShape(shape, options);
      }

      var segments = item._segments,
          length = segments.length,
          type,
          attrs = getTransform(item._matrix);

      if (matchShapes && length >= 2 && !item.hasHandles()) {
        if (length > 2) {
          type = item._closed ? 'polygon' : 'polyline';
          var parts = [];

          for (var i = 0; i < length; i++) {
            parts.push(formatter.point(segments[i]._point));
          }

          attrs.points = parts.join(' ');
        } else {
          type = 'line';
          var start = segments[0]._point,
              end = segments[1]._point;
          attrs.set({
            x1: start.x,
            y1: start.y,
            x2: end.x,
            y2: end.y
          });
        }
      } else {
        type = 'path';
        attrs.d = item.getPathData(null, options.precision);
      }

      return SvgElement.create(type, attrs, formatter);
    }

    function exportShape(item) {
      var type = item._type,
          radius = item._radius,
          attrs = getTransform(item._matrix, true, type !== 'rectangle');

      if (type === 'rectangle') {
        type = 'rect';
        var size = item._size,
            width = size.width,
            height = size.height;
        attrs.x -= width / 2;
        attrs.y -= height / 2;
        attrs.width = width;
        attrs.height = height;
        if (radius.isZero()) radius = null;
      }

      if (radius) {
        if (type === 'circle') {
          attrs.r = radius;
        } else {
          attrs.rx = radius.width;
          attrs.ry = radius.height;
        }
      }

      return SvgElement.create(type, attrs, formatter);
    }

    function exportCompoundPath(item, options) {
      var attrs = getTransform(item._matrix);
      var data = item.getPathData(null, options.precision);
      if (data) attrs.d = data;
      return SvgElement.create('path', attrs, formatter);
    }

    function exportSymbolItem(item, options) {
      var attrs = getTransform(item._matrix, true),
          definition = item._definition,
          node = getDefinition(definition, 'symbol'),
          definitionItem = definition._item,
          bounds = definitionItem.getStrokeBounds();

      if (!node) {
        node = SvgElement.create('symbol', {
          viewBox: formatter.rectangle(bounds)
        });
        node.appendChild(exportSVG(definitionItem, options));
        setDefinition(definition, node, 'symbol');
      }

      attrs.href = '#' + node.id;
      attrs.x += bounds.x;
      attrs.y += bounds.y;
      attrs.width = bounds.width;
      attrs.height = bounds.height;
      attrs.overflow = 'visible';
      return SvgElement.create('use', attrs, formatter);
    }

    function exportGradient(color) {
      var gradientNode = getDefinition(color, 'color');

      if (!gradientNode) {
        var gradient = color.getGradient(),
            radial = gradient._radial,
            origin = color.getOrigin(),
            destination = color.getDestination(),
            attrs;

        if (radial) {
          attrs = {
            cx: origin.x,
            cy: origin.y,
            r: origin.getDistance(destination)
          };
          var highlight = color.getHighlight();

          if (highlight) {
            attrs.fx = highlight.x;
            attrs.fy = highlight.y;
          }
        } else {
          attrs = {
            x1: origin.x,
            y1: origin.y,
            x2: destination.x,
            y2: destination.y
          };
        }

        attrs.gradientUnits = 'userSpaceOnUse';
        gradientNode = SvgElement.create((radial ? 'radial' : 'linear') + 'Gradient', attrs, formatter);
        var stops = gradient._stops;

        for (var i = 0, l = stops.length; i < l; i++) {
          var stop = stops[i],
              stopColor = stop._color,
              alpha = stopColor.getAlpha(),
              offset = stop._offset;
          attrs = {
            offset: offset == null ? i / (l - 1) : offset
          };
          if (stopColor) attrs['stop-color'] = stopColor.toCSS(true);
          if (alpha < 1) attrs['stop-opacity'] = alpha;
          gradientNode.appendChild(SvgElement.create('stop', attrs, formatter));
        }

        setDefinition(color, gradientNode, 'color');
      }

      return 'url(#' + gradientNode.id + ')';
    }

    function exportText(item) {
      var node = SvgElement.create('text', getTransform(item._matrix, true), formatter);
      node.textContent = item._content;
      return node;
    }

    var exporters = {
      Group: exportGroup,
      Layer: exportGroup,
      Raster: exportRaster,
      Path: exportPath,
      Shape: exportShape,
      CompoundPath: exportCompoundPath,
      SymbolItem: exportSymbolItem,
      PointText: exportText
    };

    function applyStyle(item, node, isRoot) {
      var attrs = {},
          parent = !isRoot && item.getParent(),
          style = [];
      if (item._name != null) attrs.id = item._name;
      Base.each(SvgStyles, function (entry) {
        var get = entry.get,
            type = entry.type,
            value = item[get]();

        if (entry.exportFilter ? entry.exportFilter(item, value) : !parent || !Base.equals(parent[get](), value)) {
          if (type === 'color' && value != null) {
            var alpha = value.getAlpha();
            if (alpha < 1) attrs[entry.attribute + '-opacity'] = alpha;
          }

          if (type === 'style') {
            style.push(entry.attribute + ': ' + value);
          } else {
            attrs[entry.attribute] = value == null ? 'none' : type === 'color' ? value.gradient ? exportGradient(value, item) : value.toCSS(true) : type === 'array' ? value.join(',') : type === 'lookup' ? entry.toSVG[value] : value;
          }
        }
      });
      if (style.length) attrs.style = style.join(';');
      if (attrs.opacity === 1) delete attrs.opacity;
      if (!item._visible) attrs.visibility = 'hidden';
      return SvgElement.set(node, attrs, formatter);
    }

    var definitions;

    function getDefinition(item, type) {
      if (!definitions) definitions = {
        ids: {},
        svgs: {}
      };
      return item && definitions.svgs[type + '-' + (item._id || item.__id || (item.__id = UID.get('svg')))];
    }

    function setDefinition(item, node, type) {
      if (!definitions) getDefinition();
      var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
      node.id = type + '-' + typeId;
      definitions.svgs[type + '-' + (item._id || item.__id)] = node;
    }

    function exportDefinitions(node, options) {
      var svg = node,
          defs = null;

      if (definitions) {
        svg = node.nodeName.toLowerCase() === 'svg' && node;

        for (var i in definitions.svgs) {
          if (!defs) {
            if (!svg) {
              svg = SvgElement.create('svg');
              svg.appendChild(node);
            }

            defs = svg.insertBefore(SvgElement.create('defs'), svg.firstChild);
          }

          defs.appendChild(definitions.svgs[i]);
        }

        definitions = null;
      }

      return options.asString ? new self.XMLSerializer().serializeToString(svg) : svg;
    }

    function exportSVG(item, options, isRoot) {
      var exporter = exporters[item._class],
          node = exporter && exporter(item, options);

      if (node) {
        var onExport = options.onExport;
        if (onExport) node = onExport(item, node, options) || node;
        var data = JSON.stringify(item._data);
        if (data && data !== '{}' && data !== 'null') node.setAttribute('data-paper-data', data);
      }

      return node && applyStyle(item, node, isRoot);
    }

    function setOptions(options) {
      if (!options) options = {};
      formatter = new Formatter(options.precision);
      return options;
    }

    Item.inject({
      exportSVG: function (options) {
        options = setOptions(options);
        return exportDefinitions(exportSVG(this, options, true), options);
      }
    });
    Project.inject({
      exportSVG: function (options) {
        options = setOptions(options);
        var children = this._children,
            view = this.getView(),
            bounds = Base.pick(options.bounds, 'view'),
            mx = options.matrix || bounds === 'view' && view._matrix,
            matrix = mx && Matrix.read([mx]),
            rect = bounds === 'view' ? new Rectangle([0, 0], view.getViewSize()) : bounds === 'content' ? Item._getBounds(children, matrix, {
          stroke: true
        }).rect : Rectangle.read([bounds], 0, {
          readNull: true
        }),
            attrs = {
          version: '1.1',
          xmlns: SvgElement.svg,
          'xmlns:xlink': SvgElement.xlink
        };

        if (rect) {
          attrs.width = rect.width;
          attrs.height = rect.height;
          if (rect.x || rect.x === 0 || rect.y || rect.y === 0) attrs.viewBox = formatter.rectangle(rect);
        }

        var node = SvgElement.create('svg', attrs, formatter),
            parent = node;

        if (matrix && !matrix.isIdentity()) {
          parent = node.appendChild(SvgElement.create('g', getTransform(matrix), formatter));
        }

        for (var i = 0, l = children.length; i < l; i++) {
          parent.appendChild(exportSVG(children[i], options, true));
        }

        return exportDefinitions(node, options);
      }
    });
  }();
  new function () {
    var definitions = {},
        rootSize;

    function getValue(node, name, isString, allowNull, allowPercent, defaultValue) {
      var value = SvgElement.get(node, name) || defaultValue,
          res = value == null ? allowNull ? null : isString ? '' : 0 : isString ? value : parseFloat(value);
      return /%\s*$/.test(value) ? res / 100 * (allowPercent ? 1 : rootSize[/x|^width/.test(name) ? 'width' : 'height']) : res;
    }

    function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {
      x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);
      y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);
      return allowNull && (x == null || y == null) ? null : new Point(x, y);
    }

    function getSize(node, w, h, allowNull, allowPercent) {
      w = getValue(node, w || 'width', false, allowNull, allowPercent);
      h = getValue(node, h || 'height', false, allowNull, allowPercent);
      return allowNull && (w == null || h == null) ? null : new Size(w, h);
    }

    function convertValue(value, type, lookup) {
      return value === 'none' ? null : type === 'number' ? parseFloat(value) : type === 'array' ? value ? value.split(/[\s,]+/g).map(parseFloat) : [] : type === 'color' ? getDefinition(value) || value : type === 'lookup' ? lookup[value] : value;
    }

    function importGroup(node, type, options, isRoot) {
      var nodes = node.childNodes,
          isClip = type === 'clippath',
          isDefs = type === 'defs',
          item = new Group(),
          project = item._project,
          currentStyle = project._currentStyle,
          children = [];

      if (!isClip && !isDefs) {
        item = applyAttributes(item, node, isRoot);
        project._currentStyle = item._style.clone();
      }

      if (isRoot) {
        var defs = node.querySelectorAll('defs');

        for (var i = 0, l = defs.length; i < l; i++) {
          importNode(defs[i], options, false);
        }
      }

      for (var i = 0, l = nodes.length; i < l; i++) {
        var childNode = nodes[i],
            child;
        if (childNode.nodeType === 1 && !/^defs$/i.test(childNode.nodeName) && (child = importNode(childNode, options, false)) && !(child instanceof SymbolDefinition)) children.push(child);
      }

      item.addChildren(children);
      if (isClip) item = applyAttributes(item.reduce(), node, isRoot);
      project._currentStyle = currentStyle;

      if (isClip || isDefs) {
        item.remove();
        item = null;
      }

      return item;
    }

    function importPoly(node, type) {
      var coords = node.getAttribute('points').match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
          points = [];

      for (var i = 0, l = coords.length; i < l; i += 2) points.push(new Point(parseFloat(coords[i]), parseFloat(coords[i + 1])));

      var path = new Path(points);
      if (type === 'polygon') path.closePath();
      return path;
    }

    function importPath(node) {
      return PathItem.create(node.getAttribute('d'));
    }

    function importGradient(node, type) {
      var id = (getValue(node, 'href', true) || '').substring(1),
          radial = type === 'radialgradient',
          gradient;

      if (id) {
        gradient = definitions[id].getGradient();

        if (gradient._radial ^ radial) {
          gradient = gradient.clone();
          gradient._radial = radial;
        }
      } else {
        var nodes = node.childNodes,
            stops = [];

        for (var i = 0, l = nodes.length; i < l; i++) {
          var child = nodes[i];
          if (child.nodeType === 1) stops.push(applyAttributes(new GradientStop(), child));
        }

        gradient = new Gradient(stops, radial);
      }

      var origin,
          destination,
          highlight,
          scaleToBounds = getValue(node, 'gradientUnits', true) !== 'userSpaceOnUse';

      if (radial) {
        origin = getPoint(node, 'cx', 'cy', false, scaleToBounds, '50%', '50%');
        destination = origin.add(getValue(node, 'r', false, false, scaleToBounds, '50%'), 0);
        highlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);
      } else {
        origin = getPoint(node, 'x1', 'y1', false, scaleToBounds, '0%', '0%');
        destination = getPoint(node, 'x2', 'y2', false, scaleToBounds, '100%', '0%');
      }

      var color = applyAttributes(new Color(gradient, origin, destination, highlight), node);
      color._scaleToBounds = scaleToBounds;
      return null;
    }

    var importers = {
      '#document': function (node, type, options, isRoot) {
        var nodes = node.childNodes;

        for (var i = 0, l = nodes.length; i < l; i++) {
          var child = nodes[i];
          if (child.nodeType === 1) return importNode(child, options, isRoot);
        }
      },
      g: importGroup,
      svg: importGroup,
      clippath: importGroup,
      polygon: importPoly,
      polyline: importPoly,
      path: importPath,
      lineargradient: importGradient,
      radialgradient: importGradient,
      image: function (node) {
        var raster = new Raster(getValue(node, 'href', true));
        raster.on('load', function () {
          var size = getSize(node);
          this.setSize(size);
          var center = getPoint(node).add(size.divide(2));

          this._matrix.append(new Matrix().translate(center));
        });
        return raster;
      },
      symbol: function (node, type, options, isRoot) {
        return new SymbolDefinition(importGroup(node, type, options, isRoot), true);
      },
      defs: importGroup,
      use: function (node) {
        var id = (getValue(node, 'href', true) || '').substring(1),
            definition = definitions[id],
            point = getPoint(node);
        return definition ? definition instanceof SymbolDefinition ? definition.place(point) : definition.clone().translate(point) : null;
      },
      circle: function (node) {
        return new Shape.Circle(getPoint(node, 'cx', 'cy'), getValue(node, 'r'));
      },
      ellipse: function (node) {
        return new Shape.Ellipse({
          center: getPoint(node, 'cx', 'cy'),
          radius: getSize(node, 'rx', 'ry')
        });
      },
      rect: function (node) {
        return new Shape.Rectangle(new Rectangle(getPoint(node), getSize(node)), getSize(node, 'rx', 'ry'));
      },
      line: function (node) {
        return new Path.Line(getPoint(node, 'x1', 'y1'), getPoint(node, 'x2', 'y2'));
      },
      text: function (node) {
        var text = new PointText(getPoint(node).add(getPoint(node, 'dx', 'dy')));
        text.setContent(node.textContent.trim() || '');
        return text;
      },
      switch: importGroup
    };

    function applyTransform(item, value, name, node) {
      if (item.transform) {
        var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
            matrix = new Matrix();

        for (var i = 0, l = transforms.length; i < l; i++) {
          var transform = transforms[i];
          if (!transform) break;
          var parts = transform.split(/\(\s*/),
              command = parts[0],
              v = parts[1].split(/[\s,]+/g);

          for (var j = 0, m = v.length; j < m; j++) v[j] = parseFloat(v[j]);

          switch (command) {
            case 'matrix':
              matrix.append(new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
              break;

            case 'rotate':
              matrix.rotate(v[0], v[1] || 0, v[2] || 0);
              break;

            case 'translate':
              matrix.translate(v[0], v[1] || 0);
              break;

            case 'scale':
              matrix.scale(v);
              break;

            case 'skewX':
              matrix.skew(v[0], 0);
              break;

            case 'skewY':
              matrix.skew(0, v[0]);
              break;
          }
        }

        item.transform(matrix);
      }
    }

    function applyOpacity(item, value, name) {
      var key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',
          color = item[key] && item[key]();
      if (color) color.setAlpha(parseFloat(value));
    }

    var attributes = Base.set(Base.each(SvgStyles, function (entry) {
      this[entry.attribute] = function (item, value) {
        if (item[entry.set]) {
          item[entry.set](convertValue(value, entry.type, entry.fromSVG));

          if (entry.type === 'color') {
            var color = item[entry.get]();

            if (color) {
              if (color._scaleToBounds) {
                var bounds = item.getBounds();
                color.transform(new Matrix().translate(bounds.getPoint()).scale(bounds.getSize()));
              }
            }
          }
        }
      };
    }, {}), {
      id: function (item, value) {
        definitions[value] = item;
        if (item.setName) item.setName(value);
      },
      'clip-path': function (item, value) {
        var clip = getDefinition(value);

        if (clip) {
          clip = clip.clone();
          clip.setClipMask(true);

          if (item instanceof Group) {
            item.insertChild(0, clip);
          } else {
            return new Group(clip, item);
          }
        }
      },
      gradientTransform: applyTransform,
      transform: applyTransform,
      'fill-opacity': applyOpacity,
      'stroke-opacity': applyOpacity,
      visibility: function (item, value) {
        if (item.setVisible) item.setVisible(value === 'visible');
      },
      display: function (item, value) {
        if (item.setVisible) item.setVisible(value !== null);
      },
      'stop-color': function (item, value) {
        if (item.setColor) item.setColor(value);
      },
      'stop-opacity': function (item, value) {
        if (item._color) item._color.setAlpha(parseFloat(value));
      },
      offset: function (item, value) {
        if (item.setOffset) {
          var percent = value.match(/(.*)%$/);
          item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
        }
      },
      viewBox: function (item, value, name, node, styles) {
        var rect = new Rectangle(convertValue(value, 'array')),
            size = getSize(node, null, null, true),
            group,
            matrix;

        if (item instanceof Group) {
          var scale = size ? size.divide(rect.getSize()) : 1,
              matrix = new Matrix().scale(scale).translate(rect.getPoint().negate());
          group = item;
        } else if (item instanceof SymbolDefinition) {
          if (size) rect.setSize(size);
          group = item._item;
        }

        if (group) {
          if (getAttribute(node, 'overflow', styles) !== 'visible') {
            var clip = new Shape.Rectangle(rect);
            clip.setClipMask(true);
            group.addChild(clip);
          }

          if (matrix) group.transform(matrix);
        }
      }
    });

    function getAttribute(node, name, styles) {
      var attr = node.attributes[name],
          value = attr && attr.value;

      if (!value && node.style) {
        var style = Base.camelize(name);
        value = node.style[style];
        if (!value && styles.node[style] !== styles.parent[style]) value = styles.node[style];
      }

      return !value ? undefined : value === 'none' ? null : value;
    }

    function applyAttributes(item, node, isRoot) {
      var parent = node.parentNode,
          styles = {
        node: DomElement.getStyles(node) || {},
        parent: !isRoot && !/^defs$/i.test(parent.tagName) && DomElement.getStyles(parent) || {}
      };
      Base.each(attributes, function (apply, name) {
        var value = getAttribute(node, name, styles);
        item = value !== undefined && apply(item, value, name, node, styles) || item;
      });
      return item;
    }

    function getDefinition(value) {
      var match = value && value.match(/\((?:["'#]*)([^"')]+)/),
          name = match && match[1],
          res = name && definitions[window ? name.replace(window.location.href.split('#')[0] + '#', '') : name];

      if (res && res._scaleToBounds) {
        res = res.clone();
        res._scaleToBounds = true;
      }

      return res;
    }

    function importNode(node, options, isRoot) {
      var type = node.nodeName.toLowerCase(),
          isElement = type !== '#document',
          body = document.body,
          container,
          parent,
          next;

      if (isRoot && isElement) {
        rootSize = paper.getView().getSize();
        rootSize = getSize(node, null, null, true) || rootSize;
        container = SvgElement.create('svg', {
          style: 'stroke-width: 1px; stroke-miterlimit: 10'
        });
        parent = node.parentNode;
        next = node.nextSibling;
        container.appendChild(node);
        body.appendChild(container);
      }

      var settings = paper.settings,
          applyMatrix = settings.applyMatrix,
          insertItems = settings.insertItems;
      settings.applyMatrix = false;
      settings.insertItems = false;
      var importer = importers[type],
          item = importer && importer(node, type, options, isRoot) || null;
      settings.insertItems = insertItems;
      settings.applyMatrix = applyMatrix;

      if (item) {
        if (isElement && !(item instanceof Group)) item = applyAttributes(item, node, isRoot);
        var onImport = options.onImport,
            data = isElement && node.getAttribute('data-paper-data');
        if (onImport) item = onImport(node, item, options) || item;

        if (options.expandShapes && item instanceof Shape) {
          item.remove();
          item = item.toPath();
        }

        if (data) item._data = JSON.parse(data);
      }

      if (container) {
        body.removeChild(container);

        if (parent) {
          if (next) {
            parent.insertBefore(node, next);
          } else {
            parent.appendChild(node);
          }
        }
      }

      if (isRoot) {
        definitions = {};
        if (item && Base.pick(options.applyMatrix, applyMatrix)) item.matrix.apply(true, true);
      }

      return item;
    }

    function importSVG(source, options, owner) {
      if (!source) return null;
      options = typeof options === 'function' ? {
        onLoad: options
      } : options || {};
      var scope = paper,
          item = null;

      function onLoad(svg) {
        try {
          var node = typeof svg === 'object' ? svg : new self.DOMParser().parseFromString(svg.trim(), 'image/svg+xml');

          if (!node.nodeName) {
            node = null;
            throw new Error('Unsupported SVG source: ' + source);
          }

          paper = scope;
          item = importNode(node, options, true);

          if (!options || options.insert !== false) {
            owner._insertItem(undefined, item);
          }

          var onLoad = options.onLoad;
          if (onLoad) onLoad(item, svg);
        } catch (e) {
          onError(e);
        }
      }

      function onError(message, status) {
        var onError = options.onError;

        if (onError) {
          onError(message, status);
        } else {
          throw new Error(message);
        }
      }

      if (typeof source === 'string' && !/^[\s\S]*</.test(source)) {
        var node = document.getElementById(source);

        if (node) {
          onLoad(node);
        } else {
          Http.request({
            url: source,
            async: true,
            onLoad: onLoad,
            onError: onError
          });
        }
      } else if (typeof File !== 'undefined' && source instanceof File) {
        var reader = new FileReader();

        reader.onload = function () {
          onLoad(reader.result);
        };

        reader.onerror = function () {
          onError(reader.error);
        };

        return reader.readAsText(source);
      } else {
        onLoad(source);
      }

      return item;
    }

    Item.inject({
      importSVG: function (node, options) {
        return importSVG(node, options, this);
      }
    });
    Project.inject({
      importSVG: function (node, options) {
        this.activate();
        return importSVG(node, options, this);
      }
    });
  }();

  Base.exports.PaperScript = function () {
    var global = this,
        acorn = global.acorn;

    if (!acorn && "function" !== 'undefined') {
      try {
        acorn = __webpack_require__(/*! acorn */ "./node_modules/acorn/dist/acorn.mjs");
      } catch (e) {}
    }

    if (!acorn) {
      var exports, module;
      acorn = exports = module = {};

      (function (root, mod) {
        if (typeof exports == "object" && typeof module == "object") return mod(exports);
        if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        mod(root.acorn || (root.acorn = {}));
      })(this, function (exports) {
        "use strict";

        exports.version = "0.5.0";
        var options, input, inputLen, sourceFile;

        exports.parse = function (inpt, opts) {
          input = String(inpt);
          inputLen = input.length;
          setOptions(opts);
          initTokenState();
          return parseTopLevel(options.program);
        };

        var defaultOptions = exports.defaultOptions = {
          ecmaVersion: 5,
          strictSemicolons: false,
          allowTrailingCommas: true,
          forbidReserved: false,
          allowReturnOutsideFunction: false,
          locations: false,
          onComment: null,
          ranges: false,
          program: null,
          sourceFile: null,
          directSourceFile: null
        };

        function setOptions(opts) {
          options = opts || {};

          for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt)) options[opt] = defaultOptions[opt];

          sourceFile = options.sourceFile || null;
        }

        var getLineInfo = exports.getLineInfo = function (input, offset) {
          for (var line = 1, cur = 0;;) {
            lineBreak.lastIndex = cur;
            var match = lineBreak.exec(input);

            if (match && match.index < offset) {
              ++line;
              cur = match.index + match[0].length;
            } else break;
          }

          return {
            line: line,
            column: offset - cur
          };
        };

        exports.tokenize = function (inpt, opts) {
          input = String(inpt);
          inputLen = input.length;
          setOptions(opts);
          initTokenState();
          var t = {};

          function getToken(forceRegexp) {
            lastEnd = tokEnd;
            readToken(forceRegexp);
            t.start = tokStart;
            t.end = tokEnd;
            t.startLoc = tokStartLoc;
            t.endLoc = tokEndLoc;
            t.type = tokType;
            t.value = tokVal;
            return t;
          }

          getToken.jumpTo = function (pos, reAllowed) {
            tokPos = pos;

            if (options.locations) {
              tokCurLine = 1;
              tokLineStart = lineBreak.lastIndex = 0;
              var match;

              while ((match = lineBreak.exec(input)) && match.index < pos) {
                ++tokCurLine;
                tokLineStart = match.index + match[0].length;
              }
            }

            tokRegexpAllowed = reAllowed;
            skipSpace();
          };

          return getToken;
        };

        var tokPos;
        var tokStart, tokEnd;
        var tokStartLoc, tokEndLoc;
        var tokType, tokVal;
        var tokRegexpAllowed;
        var tokCurLine, tokLineStart;
        var lastStart, lastEnd, lastEndLoc;
        var inFunction, labels, strict;

        function raise(pos, message) {
          var loc = getLineInfo(input, pos);
          message += " (" + loc.line + ":" + loc.column + ")";
          var err = new SyntaxError(message);
          err.pos = pos;
          err.loc = loc;
          err.raisedAt = tokPos;
          throw err;
        }

        var empty = [];
        var _num = {
          type: "num"
        },
            _regexp = {
          type: "regexp"
        },
            _string = {
          type: "string"
        };
        var _name = {
          type: "name"
        },
            _eof = {
          type: "eof"
        };
        var _break = {
          keyword: "break"
        },
            _case = {
          keyword: "case",
          beforeExpr: true
        },
            _catch = {
          keyword: "catch"
        };
        var _continue = {
          keyword: "continue"
        },
            _debugger = {
          keyword: "debugger"
        },
            _default = {
          keyword: "default"
        };
        var _do = {
          keyword: "do",
          isLoop: true
        },
            _else = {
          keyword: "else",
          beforeExpr: true
        };
        var _finally = {
          keyword: "finally"
        },
            _for = {
          keyword: "for",
          isLoop: true
        },
            _function = {
          keyword: "function"
        };
        var _if = {
          keyword: "if"
        },
            _return = {
          keyword: "return",
          beforeExpr: true
        },
            _switch = {
          keyword: "switch"
        };
        var _throw = {
          keyword: "throw",
          beforeExpr: true
        },
            _try = {
          keyword: "try"
        },
            _var = {
          keyword: "var"
        };
        var _while = {
          keyword: "while",
          isLoop: true
        },
            _with = {
          keyword: "with"
        },
            _new = {
          keyword: "new",
          beforeExpr: true
        };
        var _this = {
          keyword: "this"
        };
        var _null = {
          keyword: "null",
          atomValue: null
        },
            _true = {
          keyword: "true",
          atomValue: true
        };
        var _false = {
          keyword: "false",
          atomValue: false
        };
        var _in = {
          keyword: "in",
          binop: 7,
          beforeExpr: true
        };
        var keywordTypes = {
          "break": _break,
          "case": _case,
          "catch": _catch,
          "continue": _continue,
          "debugger": _debugger,
          "default": _default,
          "do": _do,
          "else": _else,
          "finally": _finally,
          "for": _for,
          "function": _function,
          "if": _if,
          "return": _return,
          "switch": _switch,
          "throw": _throw,
          "try": _try,
          "var": _var,
          "while": _while,
          "with": _with,
          "null": _null,
          "true": _true,
          "false": _false,
          "new": _new,
          "in": _in,
          "instanceof": {
            keyword: "instanceof",
            binop: 7,
            beforeExpr: true
          },
          "this": _this,
          "typeof": {
            keyword: "typeof",
            prefix: true,
            beforeExpr: true
          },
          "void": {
            keyword: "void",
            prefix: true,
            beforeExpr: true
          },
          "delete": {
            keyword: "delete",
            prefix: true,
            beforeExpr: true
          }
        };
        var _bracketL = {
          type: "[",
          beforeExpr: true
        },
            _bracketR = {
          type: "]"
        },
            _braceL = {
          type: "{",
          beforeExpr: true
        };
        var _braceR = {
          type: "}"
        },
            _parenL = {
          type: "(",
          beforeExpr: true
        },
            _parenR = {
          type: ")"
        };
        var _comma = {
          type: ",",
          beforeExpr: true
        },
            _semi = {
          type: ";",
          beforeExpr: true
        };
        var _colon = {
          type: ":",
          beforeExpr: true
        },
            _dot = {
          type: "."
        },
            _question = {
          type: "?",
          beforeExpr: true
        };
        var _slash = {
          binop: 10,
          beforeExpr: true
        },
            _eq = {
          isAssign: true,
          beforeExpr: true
        };
        var _assign = {
          isAssign: true,
          beforeExpr: true
        };
        var _incDec = {
          postfix: true,
          prefix: true,
          isUpdate: true
        },
            _prefix = {
          prefix: true,
          beforeExpr: true
        };
        var _logicalOR = {
          binop: 1,
          beforeExpr: true
        };
        var _logicalAND = {
          binop: 2,
          beforeExpr: true
        };
        var _bitwiseOR = {
          binop: 3,
          beforeExpr: true
        };
        var _bitwiseXOR = {
          binop: 4,
          beforeExpr: true
        };
        var _bitwiseAND = {
          binop: 5,
          beforeExpr: true
        };
        var _equality = {
          binop: 6,
          beforeExpr: true
        };
        var _relational = {
          binop: 7,
          beforeExpr: true
        };
        var _bitShift = {
          binop: 8,
          beforeExpr: true
        };
        var _plusMin = {
          binop: 9,
          prefix: true,
          beforeExpr: true
        };
        var _multiplyModulo = {
          binop: 10,
          beforeExpr: true
        };
        exports.tokTypes = {
          bracketL: _bracketL,
          bracketR: _bracketR,
          braceL: _braceL,
          braceR: _braceR,
          parenL: _parenL,
          parenR: _parenR,
          comma: _comma,
          semi: _semi,
          colon: _colon,
          dot: _dot,
          question: _question,
          slash: _slash,
          eq: _eq,
          name: _name,
          eof: _eof,
          num: _num,
          regexp: _regexp,
          string: _string
        };

        for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

        function makePredicate(words) {
          words = words.split(" ");
          var f = "",
              cats = [];

          out: for (var i = 0; i < words.length; ++i) {
            for (var j = 0; j < cats.length; ++j) if (cats[j][0].length == words[i].length) {
              cats[j].push(words[i]);
              continue out;
            }

            cats.push([words[i]]);
          }

          function compareTo(arr) {
            if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
            f += "switch(str){";

            for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";

            f += "return true}return false;";
          }

          if (cats.length > 3) {
            cats.sort(function (a, b) {
              return b.length - a.length;
            });
            f += "switch(str.length){";

            for (var i = 0; i < cats.length; ++i) {
              var cat = cats[i];
              f += "case " + cat[0].length + ":";
              compareTo(cat);
            }

            f += "}";
          } else {
            compareTo(words);
          }

          return new Function("str", f);
        }

        var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");
        var isReservedWord5 = makePredicate("class enum extends super const export import");
        var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");
        var isStrictBadIdWord = makePredicate("eval arguments");
        var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");
        var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
        var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
        var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        var newline = /[\n\r\u2028\u2029]/;
        var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

        var isIdentifierStart = exports.isIdentifierStart = function (code) {
          if (code < 65) return code === 36;
          if (code < 91) return true;
          if (code < 97) return code === 95;
          if (code < 123) return true;
          return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
        };

        var isIdentifierChar = exports.isIdentifierChar = function (code) {
          if (code < 48) return code === 36;
          if (code < 58) return true;
          if (code < 65) return false;
          if (code < 91) return true;
          if (code < 97) return code === 95;
          if (code < 123) return true;
          return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
        };

        function line_loc_t() {
          this.line = tokCurLine;
          this.column = tokPos - tokLineStart;
        }

        function initTokenState() {
          tokCurLine = 1;
          tokPos = tokLineStart = 0;
          tokRegexpAllowed = true;
          skipSpace();
        }

        function finishToken(type, val) {
          tokEnd = tokPos;
          if (options.locations) tokEndLoc = new line_loc_t();
          tokType = type;
          skipSpace();
          tokVal = val;
          tokRegexpAllowed = type.beforeExpr;
        }

        function skipBlockComment() {
          var startLoc = options.onComment && options.locations && new line_loc_t();
          var start = tokPos,
              end = input.indexOf("*/", tokPos += 2);
          if (end === -1) raise(tokPos - 2, "Unterminated comment");
          tokPos = end + 2;

          if (options.locations) {
            lineBreak.lastIndex = start;
            var match;

            while ((match = lineBreak.exec(input)) && match.index < tokPos) {
              ++tokCurLine;
              tokLineStart = match.index + match[0].length;
            }
          }

          if (options.onComment) options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new line_loc_t());
        }

        function skipLineComment() {
          var start = tokPos;
          var startLoc = options.onComment && options.locations && new line_loc_t();
          var ch = input.charCodeAt(tokPos += 2);

          while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
            ++tokPos;
            ch = input.charCodeAt(tokPos);
          }

          if (options.onComment) options.onComment(false, input.slice(start + 2, tokPos), start, tokPos, startLoc, options.locations && new line_loc_t());
        }

        function skipSpace() {
          while (tokPos < inputLen) {
            var ch = input.charCodeAt(tokPos);

            if (ch === 32) {
              ++tokPos;
            } else if (ch === 13) {
              ++tokPos;
              var next = input.charCodeAt(tokPos);

              if (next === 10) {
                ++tokPos;
              }

              if (options.locations) {
                ++tokCurLine;
                tokLineStart = tokPos;
              }
            } else if (ch === 10 || ch === 8232 || ch === 8233) {
              ++tokPos;

              if (options.locations) {
                ++tokCurLine;
                tokLineStart = tokPos;
              }
            } else if (ch > 8 && ch < 14) {
              ++tokPos;
            } else if (ch === 47) {
              var next = input.charCodeAt(tokPos + 1);

              if (next === 42) {
                skipBlockComment();
              } else if (next === 47) {
                skipLineComment();
              } else break;
            } else if (ch === 160) {
              ++tokPos;
            } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
              ++tokPos;
            } else {
              break;
            }
          }
        }

        function readToken_dot() {
          var next = input.charCodeAt(tokPos + 1);
          if (next >= 48 && next <= 57) return readNumber(true);
          ++tokPos;
          return finishToken(_dot);
        }

        function readToken_slash() {
          var next = input.charCodeAt(tokPos + 1);

          if (tokRegexpAllowed) {
            ++tokPos;
            return readRegexp();
          }

          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_slash, 1);
        }

        function readToken_mult_modulo() {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_multiplyModulo, 1);
        }

        function readToken_pipe_amp(code) {
          var next = input.charCodeAt(tokPos + 1);
          if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
        }

        function readToken_caret() {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_bitwiseXOR, 1);
        }

        function readToken_plus_min(code) {
          var next = input.charCodeAt(tokPos + 1);

          if (next === code) {
            if (next == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd, tokPos))) {
              tokPos += 3;
              skipLineComment();
              skipSpace();
              return readToken();
            }

            return finishOp(_incDec, 2);
          }

          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_plusMin, 1);
        }

        function readToken_lt_gt(code) {
          var next = input.charCodeAt(tokPos + 1);
          var size = 1;

          if (next === code) {
            size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
            if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
            return finishOp(_bitShift, size);
          }

          if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45) {
            tokPos += 4;
            skipLineComment();
            skipSpace();
            return readToken();
          }

          if (next === 61) size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
          return finishOp(_relational, size);
        }

        function readToken_eq_excl(code) {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
          return finishOp(code === 61 ? _eq : _prefix, 1);
        }

        function getTokenFromCode(code) {
          switch (code) {
            case 46:
              return readToken_dot();

            case 40:
              ++tokPos;
              return finishToken(_parenL);

            case 41:
              ++tokPos;
              return finishToken(_parenR);

            case 59:
              ++tokPos;
              return finishToken(_semi);

            case 44:
              ++tokPos;
              return finishToken(_comma);

            case 91:
              ++tokPos;
              return finishToken(_bracketL);

            case 93:
              ++tokPos;
              return finishToken(_bracketR);

            case 123:
              ++tokPos;
              return finishToken(_braceL);

            case 125:
              ++tokPos;
              return finishToken(_braceR);

            case 58:
              ++tokPos;
              return finishToken(_colon);

            case 63:
              ++tokPos;
              return finishToken(_question);

            case 48:
              var next = input.charCodeAt(tokPos + 1);
              if (next === 120 || next === 88) return readHexNumber();

            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return readNumber(false);

            case 34:
            case 39:
              return readString(code);

            case 47:
              return readToken_slash(code);

            case 37:
            case 42:
              return readToken_mult_modulo();

            case 124:
            case 38:
              return readToken_pipe_amp(code);

            case 94:
              return readToken_caret();

            case 43:
            case 45:
              return readToken_plus_min(code);

            case 60:
            case 62:
              return readToken_lt_gt(code);

            case 61:
            case 33:
              return readToken_eq_excl(code);

            case 126:
              return finishOp(_prefix, 1);
          }

          return false;
        }

        function readToken(forceRegexp) {
          if (!forceRegexp) tokStart = tokPos;else tokPos = tokStart + 1;
          if (options.locations) tokStartLoc = new line_loc_t();
          if (forceRegexp) return readRegexp();
          if (tokPos >= inputLen) return finishToken(_eof);
          var code = input.charCodeAt(tokPos);
          if (isIdentifierStart(code) || code === 92) return readWord();
          var tok = getTokenFromCode(code);

          if (tok === false) {
            var ch = String.fromCharCode(code);
            if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
            raise(tokPos, "Unexpected character '" + ch + "'");
          }

          return tok;
        }

        function finishOp(type, size) {
          var str = input.slice(tokPos, tokPos + size);
          tokPos += size;
          finishToken(type, str);
        }

        function readRegexp() {
          var content = "",
              escaped,
              inClass,
              start = tokPos;

          for (;;) {
            if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
            var ch = input.charAt(tokPos);
            if (newline.test(ch)) raise(start, "Unterminated regular expression");

            if (!escaped) {
              if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
              escaped = ch === "\\";
            } else escaped = false;

            ++tokPos;
          }

          var content = input.slice(start, tokPos);
          ++tokPos;
          var mods = readWord1();
          if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");

          try {
            var value = new RegExp(content, mods);
          } catch (e) {
            if (e instanceof SyntaxError) raise(start, e.message);
            raise(e);
          }

          return finishToken(_regexp, value);
        }

        function readInt(radix, len) {
          var start = tokPos,
              total = 0;

          for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
            var code = input.charCodeAt(tokPos),
                val;
            if (code >= 97) val = code - 97 + 10;else if (code >= 65) val = code - 65 + 10;else if (code >= 48 && code <= 57) val = code - 48;else val = Infinity;
            if (val >= radix) break;
            ++tokPos;
            total = total * radix + val;
          }

          if (tokPos === start || len != null && tokPos - start !== len) return null;
          return total;
        }

        function readHexNumber() {
          tokPos += 2;
          var val = readInt(16);
          if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
          if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
          return finishToken(_num, val);
        }

        function readNumber(startsWithDot) {
          var start = tokPos,
              isFloat = false,
              octal = input.charCodeAt(tokPos) === 48;
          if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");

          if (input.charCodeAt(tokPos) === 46) {
            ++tokPos;
            readInt(10);
            isFloat = true;
          }

          var next = input.charCodeAt(tokPos);

          if (next === 69 || next === 101) {
            next = input.charCodeAt(++tokPos);
            if (next === 43 || next === 45) ++tokPos;
            if (readInt(10) === null) raise(start, "Invalid number");
            isFloat = true;
          }

          if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
          var str = input.slice(start, tokPos),
              val;
          if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || strict) raise(start, "Invalid number");else val = parseInt(str, 8);
          return finishToken(_num, val);
        }

        function readString(quote) {
          tokPos++;
          var out = "";

          for (;;) {
            if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
            var ch = input.charCodeAt(tokPos);

            if (ch === quote) {
              ++tokPos;
              return finishToken(_string, out);
            }

            if (ch === 92) {
              ch = input.charCodeAt(++tokPos);
              var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
              if (octal) octal = octal[0];

              while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);

              if (octal === "0") octal = null;
              ++tokPos;

              if (octal) {
                if (strict) raise(tokPos - 2, "Octal literal in strict mode");
                out += String.fromCharCode(parseInt(octal, 8));
                tokPos += octal.length - 1;
              } else {
                switch (ch) {
                  case 110:
                    out += "\n";
                    break;

                  case 114:
                    out += "\r";
                    break;

                  case 120:
                    out += String.fromCharCode(readHexChar(2));
                    break;

                  case 117:
                    out += String.fromCharCode(readHexChar(4));
                    break;

                  case 85:
                    out += String.fromCharCode(readHexChar(8));
                    break;

                  case 116:
                    out += "\t";
                    break;

                  case 98:
                    out += "\b";
                    break;

                  case 118:
                    out += "\u000b";
                    break;

                  case 102:
                    out += "\f";
                    break;

                  case 48:
                    out += "\0";
                    break;

                  case 13:
                    if (input.charCodeAt(tokPos) === 10) ++tokPos;

                  case 10:
                    if (options.locations) {
                      tokLineStart = tokPos;
                      ++tokCurLine;
                    }

                    break;

                  default:
                    out += String.fromCharCode(ch);
                    break;
                }
              }
            } else {
              if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, "Unterminated string constant");
              out += String.fromCharCode(ch);
              ++tokPos;
            }
          }
        }

        function readHexChar(len) {
          var n = readInt(16, len);
          if (n === null) raise(tokStart, "Bad character escape sequence");
          return n;
        }

        var containsEsc;

        function readWord1() {
          containsEsc = false;
          var word,
              first = true,
              start = tokPos;

          for (;;) {
            var ch = input.charCodeAt(tokPos);

            if (isIdentifierChar(ch)) {
              if (containsEsc) word += input.charAt(tokPos);
              ++tokPos;
            } else if (ch === 92) {
              if (!containsEsc) word = input.slice(start, tokPos);
              containsEsc = true;
              if (input.charCodeAt(++tokPos) != 117) raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
              ++tokPos;
              var esc = readHexChar(4);
              var escStr = String.fromCharCode(esc);
              if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
              if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) raise(tokPos - 4, "Invalid Unicode escape");
              word += escStr;
            } else {
              break;
            }

            first = false;
          }

          return containsEsc ? word : input.slice(start, tokPos);
        }

        function readWord() {
          var word = readWord1();
          var type = _name;
          if (!containsEsc && isKeyword(word)) type = keywordTypes[word];
          return finishToken(type, word);
        }

        function next() {
          lastStart = tokStart;
          lastEnd = tokEnd;
          lastEndLoc = tokEndLoc;
          readToken();
        }

        function setStrict(strct) {
          strict = strct;
          tokPos = tokStart;

          if (options.locations) {
            while (tokPos < tokLineStart) {
              tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
              --tokCurLine;
            }
          }

          skipSpace();
          readToken();
        }

        function node_t() {
          this.type = null;
          this.start = tokStart;
          this.end = null;
        }

        function node_loc_t() {
          this.start = tokStartLoc;
          this.end = null;
          if (sourceFile !== null) this.source = sourceFile;
        }

        function startNode() {
          var node = new node_t();
          if (options.locations) node.loc = new node_loc_t();
          if (options.directSourceFile) node.sourceFile = options.directSourceFile;
          if (options.ranges) node.range = [tokStart, 0];
          return node;
        }

        function startNodeFrom(other) {
          var node = new node_t();
          node.start = other.start;

          if (options.locations) {
            node.loc = new node_loc_t();
            node.loc.start = other.loc.start;
          }

          if (options.ranges) node.range = [other.range[0], 0];
          return node;
        }

        function finishNode(node, type) {
          node.type = type;
          node.end = lastEnd;
          if (options.locations) node.loc.end = lastEndLoc;
          if (options.ranges) node.range[1] = lastEnd;
          return node;
        }

        function isUseStrict(stmt) {
          return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
        }

        function eat(type) {
          if (tokType === type) {
            next();
            return true;
          }
        }

        function canInsertSemicolon() {
          return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
        }

        function semicolon() {
          if (!eat(_semi) && !canInsertSemicolon()) unexpected();
        }

        function expect(type) {
          if (tokType === type) next();else unexpected();
        }

        function unexpected() {
          raise(tokStart, "Unexpected token");
        }

        function checkLVal(expr) {
          if (expr.type !== "Identifier" && expr.type !== "MemberExpression") raise(expr.start, "Assigning to rvalue");
          if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name)) raise(expr.start, "Assigning to " + expr.name + " in strict mode");
        }

        function parseTopLevel(program) {
          lastStart = lastEnd = tokPos;
          if (options.locations) lastEndLoc = new line_loc_t();
          inFunction = strict = null;
          labels = [];
          readToken();
          var node = program || startNode(),
              first = true;
          if (!program) node.body = [];

          while (tokType !== _eof) {
            var stmt = parseStatement();
            node.body.push(stmt);
            if (first && isUseStrict(stmt)) setStrict(true);
            first = false;
          }

          return finishNode(node, "Program");
        }

        var loopLabel = {
          kind: "loop"
        },
            switchLabel = {
          kind: "switch"
        };

        function parseStatement() {
          if (tokType === _slash || tokType === _assign && tokVal == "/=") readToken(true);
          var starttype = tokType,
              node = startNode();

          switch (starttype) {
            case _break:
            case _continue:
              next();
              var isBreak = starttype === _break;
              if (eat(_semi) || canInsertSemicolon()) node.label = null;else if (tokType !== _name) unexpected();else {
                node.label = parseIdent();
                semicolon();
              }

              for (var i = 0; i < labels.length; ++i) {
                var lab = labels[i];

                if (node.label == null || lab.name === node.label.name) {
                  if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
                  if (node.label && isBreak) break;
                }
              }

              if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
              return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

            case _debugger:
              next();
              semicolon();
              return finishNode(node, "DebuggerStatement");

            case _do:
              next();
              labels.push(loopLabel);
              node.body = parseStatement();
              labels.pop();
              expect(_while);
              node.test = parseParenExpression();
              semicolon();
              return finishNode(node, "DoWhileStatement");

            case _for:
              next();
              labels.push(loopLabel);
              expect(_parenL);
              if (tokType === _semi) return parseFor(node, null);

              if (tokType === _var) {
                var init = startNode();
                next();
                parseVar(init, true);
                finishNode(init, "VariableDeclaration");
                if (init.declarations.length === 1 && eat(_in)) return parseForIn(node, init);
                return parseFor(node, init);
              }

              var init = parseExpression(false, true);

              if (eat(_in)) {
                checkLVal(init);
                return parseForIn(node, init);
              }

              return parseFor(node, init);

            case _function:
              next();
              return parseFunction(node, true);

            case _if:
              next();
              node.test = parseParenExpression();
              node.consequent = parseStatement();
              node.alternate = eat(_else) ? parseStatement() : null;
              return finishNode(node, "IfStatement");

            case _return:
              if (!inFunction && !options.allowReturnOutsideFunction) raise(tokStart, "'return' outside of function");
              next();
              if (eat(_semi) || canInsertSemicolon()) node.argument = null;else {
                node.argument = parseExpression();
                semicolon();
              }
              return finishNode(node, "ReturnStatement");

            case _switch:
              next();
              node.discriminant = parseParenExpression();
              node.cases = [];
              expect(_braceL);
              labels.push(switchLabel);

              for (var cur, sawDefault; tokType != _braceR;) {
                if (tokType === _case || tokType === _default) {
                  var isCase = tokType === _case;
                  if (cur) finishNode(cur, "SwitchCase");
                  node.cases.push(cur = startNode());
                  cur.consequent = [];
                  next();
                  if (isCase) cur.test = parseExpression();else {
                    if (sawDefault) raise(lastStart, "Multiple default clauses");
                    sawDefault = true;
                    cur.test = null;
                  }
                  expect(_colon);
                } else {
                  if (!cur) unexpected();
                  cur.consequent.push(parseStatement());
                }
              }

              if (cur) finishNode(cur, "SwitchCase");
              next();
              labels.pop();
              return finishNode(node, "SwitchStatement");

            case _throw:
              next();
              if (newline.test(input.slice(lastEnd, tokStart))) raise(lastEnd, "Illegal newline after throw");
              node.argument = parseExpression();
              semicolon();
              return finishNode(node, "ThrowStatement");

            case _try:
              next();
              node.block = parseBlock();
              node.handler = null;

              if (tokType === _catch) {
                var clause = startNode();
                next();
                expect(_parenL);
                clause.param = parseIdent();
                if (strict && isStrictBadIdWord(clause.param.name)) raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
                expect(_parenR);
                clause.guard = null;
                clause.body = parseBlock();
                node.handler = finishNode(clause, "CatchClause");
              }

              node.guardedHandlers = empty;
              node.finalizer = eat(_finally) ? parseBlock() : null;
              if (!node.handler && !node.finalizer) raise(node.start, "Missing catch or finally clause");
              return finishNode(node, "TryStatement");

            case _var:
              next();
              parseVar(node);
              semicolon();
              return finishNode(node, "VariableDeclaration");

            case _while:
              next();
              node.test = parseParenExpression();
              labels.push(loopLabel);
              node.body = parseStatement();
              labels.pop();
              return finishNode(node, "WhileStatement");

            case _with:
              if (strict) raise(tokStart, "'with' in strict mode");
              next();
              node.object = parseParenExpression();
              node.body = parseStatement();
              return finishNode(node, "WithStatement");

            case _braceL:
              return parseBlock();

            case _semi:
              next();
              return finishNode(node, "EmptyStatement");

            default:
              var maybeName = tokVal,
                  expr = parseExpression();

              if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
                for (var i = 0; i < labels.length; ++i) if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");

                var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
                labels.push({
                  name: maybeName,
                  kind: kind
                });
                node.body = parseStatement();
                labels.pop();
                node.label = expr;
                return finishNode(node, "LabeledStatement");
              } else {
                node.expression = expr;
                semicolon();
                return finishNode(node, "ExpressionStatement");
              }

          }
        }

        function parseParenExpression() {
          expect(_parenL);
          var val = parseExpression();
          expect(_parenR);
          return val;
        }

        function parseBlock(allowStrict) {
          var node = startNode(),
              first = true,
              strict = false,
              oldStrict;
          node.body = [];
          expect(_braceL);

          while (!eat(_braceR)) {
            var stmt = parseStatement();
            node.body.push(stmt);

            if (first && allowStrict && isUseStrict(stmt)) {
              oldStrict = strict;
              setStrict(strict = true);
            }

            first = false;
          }

          if (strict && !oldStrict) setStrict(false);
          return finishNode(node, "BlockStatement");
        }

        function parseFor(node, init) {
          node.init = init;
          expect(_semi);
          node.test = tokType === _semi ? null : parseExpression();
          expect(_semi);
          node.update = tokType === _parenR ? null : parseExpression();
          expect(_parenR);
          node.body = parseStatement();
          labels.pop();
          return finishNode(node, "ForStatement");
        }

        function parseForIn(node, init) {
          node.left = init;
          node.right = parseExpression();
          expect(_parenR);
          node.body = parseStatement();
          labels.pop();
          return finishNode(node, "ForInStatement");
        }

        function parseVar(node, noIn) {
          node.declarations = [];
          node.kind = "var";

          for (;;) {
            var decl = startNode();
            decl.id = parseIdent();
            if (strict && isStrictBadIdWord(decl.id.name)) raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
            decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
            node.declarations.push(finishNode(decl, "VariableDeclarator"));
            if (!eat(_comma)) break;
          }

          return node;
        }

        function parseExpression(noComma, noIn) {
          var expr = parseMaybeAssign(noIn);

          if (!noComma && tokType === _comma) {
            var node = startNodeFrom(expr);
            node.expressions = [expr];

            while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));

            return finishNode(node, "SequenceExpression");
          }

          return expr;
        }

        function parseMaybeAssign(noIn) {
          var left = parseMaybeConditional(noIn);

          if (tokType.isAssign) {
            var node = startNodeFrom(left);
            node.operator = tokVal;
            node.left = left;
            next();
            node.right = parseMaybeAssign(noIn);
            checkLVal(left);
            return finishNode(node, "AssignmentExpression");
          }

          return left;
        }

        function parseMaybeConditional(noIn) {
          var expr = parseExprOps(noIn);

          if (eat(_question)) {
            var node = startNodeFrom(expr);
            node.test = expr;
            node.consequent = parseExpression(true);
            expect(_colon);
            node.alternate = parseExpression(true, noIn);
            return finishNode(node, "ConditionalExpression");
          }

          return expr;
        }

        function parseExprOps(noIn) {
          return parseExprOp(parseMaybeUnary(), -1, noIn);
        }

        function parseExprOp(left, minPrec, noIn) {
          var prec = tokType.binop;

          if (prec != null && (!noIn || tokType !== _in)) {
            if (prec > minPrec) {
              var node = startNodeFrom(left);
              node.left = left;
              node.operator = tokVal;
              var op = tokType;
              next();
              node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
              var exprNode = finishNode(node, op === _logicalOR || op === _logicalAND ? "LogicalExpression" : "BinaryExpression");
              return parseExprOp(exprNode, minPrec, noIn);
            }
          }

          return left;
        }

        function parseMaybeUnary() {
          if (tokType.prefix) {
            var node = startNode(),
                update = tokType.isUpdate;
            node.operator = tokVal;
            node.prefix = true;
            tokRegexpAllowed = true;
            next();
            node.argument = parseMaybeUnary();
            if (update) checkLVal(node.argument);else if (strict && node.operator === "delete" && node.argument.type === "Identifier") raise(node.start, "Deleting local variable in strict mode");
            return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
          }

          var expr = parseExprSubscripts();

          while (tokType.postfix && !canInsertSemicolon()) {
            var node = startNodeFrom(expr);
            node.operator = tokVal;
            node.prefix = false;
            node.argument = expr;
            checkLVal(expr);
            next();
            expr = finishNode(node, "UpdateExpression");
          }

          return expr;
        }

        function parseExprSubscripts() {
          return parseSubscripts(parseExprAtom());
        }

        function parseSubscripts(base, noCalls) {
          if (eat(_dot)) {
            var node = startNodeFrom(base);
            node.object = base;
            node.property = parseIdent(true);
            node.computed = false;
            return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
          } else if (eat(_bracketL)) {
            var node = startNodeFrom(base);
            node.object = base;
            node.property = parseExpression();
            node.computed = true;
            expect(_bracketR);
            return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
          } else if (!noCalls && eat(_parenL)) {
            var node = startNodeFrom(base);
            node.callee = base;
            node.arguments = parseExprList(_parenR, false);
            return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
          } else return base;
        }

        function parseExprAtom() {
          switch (tokType) {
            case _this:
              var node = startNode();
              next();
              return finishNode(node, "ThisExpression");

            case _name:
              return parseIdent();

            case _num:
            case _string:
            case _regexp:
              var node = startNode();
              node.value = tokVal;
              node.raw = input.slice(tokStart, tokEnd);
              next();
              return finishNode(node, "Literal");

            case _null:
            case _true:
            case _false:
              var node = startNode();
              node.value = tokType.atomValue;
              node.raw = tokType.keyword;
              next();
              return finishNode(node, "Literal");

            case _parenL:
              var tokStartLoc1 = tokStartLoc,
                  tokStart1 = tokStart;
              next();
              var val = parseExpression();
              val.start = tokStart1;
              val.end = tokEnd;

              if (options.locations) {
                val.loc.start = tokStartLoc1;
                val.loc.end = tokEndLoc;
              }

              if (options.ranges) val.range = [tokStart1, tokEnd];
              expect(_parenR);
              return val;

            case _bracketL:
              var node = startNode();
              next();
              node.elements = parseExprList(_bracketR, true, true);
              return finishNode(node, "ArrayExpression");

            case _braceL:
              return parseObj();

            case _function:
              var node = startNode();
              next();
              return parseFunction(node, false);

            case _new:
              return parseNew();

            default:
              unexpected();
          }
        }

        function parseNew() {
          var node = startNode();
          next();
          node.callee = parseSubscripts(parseExprAtom(), true);
          if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);else node.arguments = empty;
          return finishNode(node, "NewExpression");
        }

        function parseObj() {
          var node = startNode(),
              first = true,
              sawGetSet = false;
          node.properties = [];
          next();

          while (!eat(_braceR)) {
            if (!first) {
              expect(_comma);
              if (options.allowTrailingCommas && eat(_braceR)) break;
            } else first = false;

            var prop = {
              key: parsePropertyName()
            },
                isGetSet = false,
                kind;

            if (eat(_colon)) {
              prop.value = parseExpression(true);
              kind = prop.kind = "init";
            } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set")) {
              isGetSet = sawGetSet = true;
              kind = prop.kind = prop.key.name;
              prop.key = parsePropertyName();
              if (tokType !== _parenL) unexpected();
              prop.value = parseFunction(startNode(), false);
            } else unexpected();

            if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
              for (var i = 0; i < node.properties.length; ++i) {
                var other = node.properties[i];

                if (other.key.name === prop.key.name) {
                  var conflict = kind == other.kind || isGetSet && other.kind === "init" || kind === "init" && (other.kind === "get" || other.kind === "set");
                  if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
                  if (conflict) raise(prop.key.start, "Redefinition of property");
                }
              }
            }

            node.properties.push(prop);
          }

          return finishNode(node, "ObjectExpression");
        }

        function parsePropertyName() {
          if (tokType === _num || tokType === _string) return parseExprAtom();
          return parseIdent(true);
        }

        function parseFunction(node, isStatement) {
          if (tokType === _name) node.id = parseIdent();else if (isStatement) unexpected();else node.id = null;
          node.params = [];
          var first = true;
          expect(_parenL);

          while (!eat(_parenR)) {
            if (!first) expect(_comma);else first = false;
            node.params.push(parseIdent());
          }

          var oldInFunc = inFunction,
              oldLabels = labels;
          inFunction = true;
          labels = [];
          node.body = parseBlock(true);
          inFunction = oldInFunc;
          labels = oldLabels;

          if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
            for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
              var id = i < 0 ? node.id : node.params[i];
              if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name)) raise(id.start, "Defining '" + id.name + "' in strict mode");
              if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name) raise(id.start, "Argument name clash in strict mode");
            }
          }

          return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
        }

        function parseExprList(close, allowTrailingComma, allowEmpty) {
          var elts = [],
              first = true;

          while (!eat(close)) {
            if (!first) {
              expect(_comma);
              if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
            } else first = false;

            if (allowEmpty && tokType === _comma) elts.push(null);else elts.push(parseExpression(true));
          }

          return elts;
        }

        function parseIdent(liberal) {
          var node = startNode();
          if (liberal && options.forbidReserved == "everywhere") liberal = false;

          if (tokType === _name) {
            if (!liberal && (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) || strict && isStrictReservedWord(tokVal)) && input.slice(tokStart, tokEnd).indexOf("\\") == -1) raise(tokStart, "The keyword '" + tokVal + "' is reserved");
            node.name = tokVal;
          } else if (liberal && tokType.keyword) {
            node.name = tokType.keyword;
          } else {
            unexpected();
          }

          tokRegexpAllowed = false;
          next();
          return finishNode(node, "Identifier");
        }
      });

      if (!acorn.version) acorn = null;
    }

    function parse(code, options) {
      return (global.acorn || acorn).parse(code, options);
    }

    var binaryOperators = {
      '+': '__add',
      '-': '__subtract',
      '*': '__multiply',
      '/': '__divide',
      '%': '__modulo',
      '==': '__equals',
      '!=': '__equals'
    };
    var unaryOperators = {
      '-': '__negate',
      '+': '__self'
    };
    var fields = Base.each(['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'], function (name) {
      this['__' + name] = '#' + name;
    }, {
      __self: function () {
        return this;
      }
    });
    Point.inject(fields);
    Size.inject(fields);
    Color.inject(fields);

    function __$__(left, operator, right) {
      var handler = binaryOperators[operator];

      if (left && left[handler]) {
        var res = left[handler](right);
        return operator === '!=' ? !res : res;
      }

      switch (operator) {
        case '+':
          return left + right;

        case '-':
          return left - right;

        case '*':
          return left * right;

        case '/':
          return left / right;

        case '%':
          return left % right;

        case '==':
          return left == right;

        case '!=':
          return left != right;
      }
    }

    function $__(operator, value) {
      var handler = unaryOperators[operator];
      if (value && value[handler]) return value[handler]();

      switch (operator) {
        case '+':
          return +value;

        case '-':
          return -value;
      }
    }

    function compile(code, options) {
      if (!code) return '';
      options = options || {};
      var insertions = [];

      function getOffset(offset) {
        for (var i = 0, l = insertions.length; i < l; i++) {
          var insertion = insertions[i];
          if (insertion[0] >= offset) break;
          offset += insertion[1];
        }

        return offset;
      }

      function getCode(node) {
        return code.substring(getOffset(node.range[0]), getOffset(node.range[1]));
      }

      function getBetween(left, right) {
        return code.substring(getOffset(left.range[1]), getOffset(right.range[0]));
      }

      function replaceCode(node, str) {
        var start = getOffset(node.range[0]),
            end = getOffset(node.range[1]),
            insert = 0;

        for (var i = insertions.length - 1; i >= 0; i--) {
          if (start > insertions[i][0]) {
            insert = i + 1;
            break;
          }
        }

        insertions.splice(insert, 0, [start, str.length - end + start]);
        code = code.substring(0, start) + str + code.substring(end);
      }

      function handleOverloading(node, parent) {
        switch (node.type) {
          case 'UnaryExpression':
            if (node.operator in unaryOperators && node.argument.type !== 'Literal') {
              var arg = getCode(node.argument);
              replaceCode(node, '$__("' + node.operator + '", ' + arg + ')');
            }

            break;

          case 'BinaryExpression':
            if (node.operator in binaryOperators && node.left.type !== 'Literal') {
              var left = getCode(node.left),
                  right = getCode(node.right),
                  between = getBetween(node.left, node.right),
                  operator = node.operator;
              replaceCode(node, '__$__(' + left + ',' + between.replace(new RegExp('\\' + operator), '"' + operator + '"') + ', ' + right + ')');
            }

            break;

          case 'UpdateExpression':
          case 'AssignmentExpression':
            var parentType = parent && parent.type;

            if (!(parentType === 'ForStatement' || parentType === 'BinaryExpression' && /^[=!<>]/.test(parent.operator) || parentType === 'MemberExpression' && parent.computed)) {
              if (node.type === 'UpdateExpression') {
                var arg = getCode(node.argument),
                    exp = '__$__(' + arg + ', "' + node.operator[0] + '", 1)',
                    str = arg + ' = ' + exp;

                if (node.prefix) {
                  str = '(' + str + ')';
                } else if (parentType === 'AssignmentExpression' || parentType === 'VariableDeclarator' || parentType === 'BinaryExpression') {
                  if (getCode(parent.left || parent.id) === arg) str = exp;
                  str = arg + '; ' + str;
                }

                replaceCode(node, str);
              } else {
                if (/^.=$/.test(node.operator) && node.left.type !== 'Literal') {
                  var left = getCode(node.left),
                      right = getCode(node.right),
                      exp = left + ' = __$__(' + left + ', "' + node.operator[0] + '", ' + right + ')';
                  replaceCode(node, /^\(.*\)$/.test(getCode(node)) ? '(' + exp + ')' : exp);
                }
              }
            }

            break;
        }
      }

      function handleExports(node) {
        switch (node.type) {
          case 'ExportDefaultDeclaration':
            replaceCode({
              range: [node.start, node.declaration.start]
            }, 'module.exports = ');
            break;

          case 'ExportNamedDeclaration':
            var declaration = node.declaration;
            var specifiers = node.specifiers;

            if (declaration) {
              var declarations = declaration.declarations;

              if (declarations) {
                declarations.forEach(function (dec) {
                  replaceCode(dec, 'module.exports.' + getCode(dec));
                });
                replaceCode({
                  range: [node.start, declaration.start + declaration.kind.length]
                }, '');
              }
            } else if (specifiers) {
              var exports = specifiers.map(function (specifier) {
                var name = getCode(specifier);
                return 'module.exports.' + name + ' = ' + name + '; ';
              }).join('');

              if (exports) {
                replaceCode(node, exports);
              }
            }

            break;
        }
      }

      function walkAST(node, parent, paperFeatures) {
        if (node) {
          for (var key in node) {
            if (key !== 'range' && key !== 'loc') {
              var value = node[key];

              if (Array.isArray(value)) {
                for (var i = 0, l = value.length; i < l; i++) {
                  walkAST(value[i], node, paperFeatures);
                }
              } else if (value && typeof value === 'object') {
                walkAST(value, node, paperFeatures);
              }
            }
          }

          if (paperFeatures.operatorOverloading !== false) {
            handleOverloading(node, parent);
          }

          if (paperFeatures.moduleExports !== false) {
            handleExports(node);
          }
        }
      }

      function encodeVLQ(value) {
        var res = '',
            base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);

        while (value || !res) {
          var next = value & 32 - 1;
          value >>= 5;
          if (value) next |= 32;
          res += base64[next];
        }

        return res;
      }

      var url = options.url || '',
          sourceMaps = options.sourceMaps,
          paperFeatures = options.paperFeatures || {},
          source = options.source || code,
          offset = options.offset || 0,
          agent = paper.agent,
          version = agent.versionNumber,
          offsetCode = false,
          lineBreaks = /\r\n|\n|\r/mg,
          map;

      if (sourceMaps && (agent.chrome && version >= 30 || agent.webkit && version >= 537.76 || agent.firefox && version >= 23 || agent.node)) {
        if (agent.node) {
          offset -= 2;
        } else if (window && url && !window.location.href.indexOf(url)) {
          var html = document.getElementsByTagName('html')[0].innerHTML;
          offset = html.substr(0, html.indexOf(code) + 1).match(lineBreaks).length + 1;
        }

        offsetCode = offset > 0 && !(agent.chrome && version >= 36 || agent.safari && version >= 600 || agent.firefox && version >= 40 || agent.node);
        var mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];
        mappings.length = (code.match(lineBreaks) || []).length + 1 + (offsetCode ? offset : 0);
        map = {
          version: 3,
          file: url,
          names: [],
          mappings: mappings.join(';AACA'),
          sourceRoot: '',
          sources: [url],
          sourcesContent: [source]
        };
      }

      if (paperFeatures.operatorOverloading !== false || paperFeatures.moduleExports !== false) {
        walkAST(parse(code, {
          ranges: true,
          preserveParens: true,
          sourceType: 'module'
        }), null, paperFeatures);
      }

      if (map) {
        if (offsetCode) {
          code = new Array(offset + 1).join('\n') + code;
        }

        if (/^(inline|both)$/.test(sourceMaps)) {
          code += "\n//# sourceMappingURL=data:application/json;base64," + self.btoa(unescape(encodeURIComponent(JSON.stringify(map))));
        }

        code += "\n//# sourceURL=" + (url || 'paperscript');
      }

      return {
        url: url,
        source: source,
        code: code,
        map: map
      };
    }

    function execute(code, scope, options) {
      paper = scope;
      var view = scope.getView(),
          tool = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code) && !/\bnew\s+Tool\b/.test(code) ? new Tool() : null,
          toolHandlers = tool ? tool._events : [],
          handlers = ['onFrame', 'onResize'].concat(toolHandlers),
          params = [],
          args = [],
          func,
          compiled = typeof code === 'object' ? code : compile(code, options);
      code = compiled.code;

      function expose(scope, hidden) {
        for (var key in scope) {
          if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)' + key.replace(/\$/g, '\\$') + '\\b').test(code)) {
            params.push(key);
            args.push(scope[key]);
          }
        }
      }

      expose({
        __$__: __$__,
        $__: $__,
        paper: scope,
        tool: tool
      }, true);
      expose(scope);
      code = 'var module = { exports: {} }; ' + code;
      var exports = Base.each(handlers, function (key) {
        if (new RegExp('\\s+' + key + '\\b').test(code)) {
          params.push(key);
          this.push('module.exports.' + key + ' = ' + key + ';');
        }
      }, []).join('\n');

      if (exports) {
        code += '\n' + exports;
      }

      code += '\nreturn module.exports;';
      var agent = paper.agent;

      if (document && (agent.chrome || agent.firefox && agent.versionNumber < 40)) {
        var script = document.createElement('script'),
            head = document.head || document.getElementsByTagName('head')[0];
        if (agent.firefox) code = '\n' + code;
        script.appendChild(document.createTextNode('document.__paperscript__ = function(' + params + ') {' + code + '\n}'));
        head.appendChild(script);
        func = document.__paperscript__;
        delete document.__paperscript__;
        head.removeChild(script);
      } else {
        func = Function(params, code);
      }

      var exports = func && func.apply(scope, args);
      var obj = exports || {};
      Base.each(toolHandlers, function (key) {
        var value = obj[key];
        if (value) tool[key] = value;
      });

      if (view) {
        if (obj.onResize) view.setOnResize(obj.onResize);
        view.emit('resize', {
          size: view.size,
          delta: new Point()
        });
        if (obj.onFrame) view.setOnFrame(obj.onFrame);
        view.requestUpdate();
      }

      return exports;
    }

    function loadScript(script) {
      if (/^text\/(?:x-|)paperscript$/.test(script.type) && PaperScope.getAttribute(script, 'ignore') !== 'true') {
        var canvasId = PaperScope.getAttribute(script, 'canvas'),
            canvas = document.getElementById(canvasId),
            src = script.src || script.getAttribute('data-src'),
            async = PaperScope.hasAttribute(script, 'async'),
            scopeAttribute = 'data-paper-scope';
        if (!canvas) throw new Error('Unable to find canvas with id "' + canvasId + '"');
        var scope = PaperScope.get(canvas.getAttribute(scopeAttribute)) || new PaperScope().setup(canvas);
        canvas.setAttribute(scopeAttribute, scope._id);

        if (src) {
          Http.request({
            url: src,
            async: async,
            mimeType: 'text/plain',
            onLoad: function (code) {
              execute(code, scope, src);
            }
          });
        } else {
          execute(script.innerHTML, scope, script.baseURI);
        }

        script.setAttribute('data-paper-ignore', 'true');
        return scope;
      }
    }

    function loadAll() {
      Base.each(document && document.getElementsByTagName('script'), loadScript);
    }

    function load(script) {
      return script ? loadScript(script) : loadAll();
    }

    if (window) {
      if (document.readyState === 'complete') {
        setTimeout(loadAll);
      } else {
        DomEvent.add(window, {
          load: loadAll
        });
      }
    }

    return {
      compile: compile,
      execute: execute,
      load: load,
      parse: parse,
      calculateBinary: __$__,
      calculateUnary: $__
    };
  }.call(this);

  var paper = new (PaperScope.inject(Base.exports, {
    Base: Base,
    Numerical: Numerical,
    Key: Key,
    DomEvent: DomEvent,
    DomElement: DomElement,
    document: document,
    window: window,
    Symbol: SymbolDefinition,
    PlacedSymbol: SymbolItem
  }))();

  if (paper.agent.node) {
    __webpack_require__(/*! ./node/extend.js */ 1)(paper);
  }

  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

  return paper;
}.call(this, typeof self === 'object' ? self : null);

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/index.scss */ "./src/styles/index.scss");
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_index_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-full.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _scripts_sidebar_sidebar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/sidebar/sidebar */ "./src/scripts/sidebar/sidebar.js");
/* harmony import */ var _scripts_util_sidebar_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/util/sidebar_data */ "./src/scripts/util/sidebar_data.js");
/* harmony import */ var _scripts_canvas_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scripts/canvas/canvas */ "./src/scripts/canvas/canvas.js");
/* harmony import */ var _scripts_modal_modal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scripts/modal/modal */ "./src/scripts/modal/modal.js");






window.addEventListener("DOMContentLoaded", function (main) {
  // canvas
  var canvasElement = document.getElementById('myCanvas');
  var myCanvas = new _scripts_canvas_canvas__WEBPACK_IMPORTED_MODULE_4__["default"](canvasElement); //sidebar

  var sidebarElement = document.getElementById('section-content-sidebar');
  var sidebar = new _scripts_sidebar_sidebar__WEBPACK_IMPORTED_MODULE_2__["default"](_scripts_util_sidebar_data__WEBPACK_IMPORTED_MODULE_3__["default"][0], sidebarElement, myCanvas.drawShapes);
});

/***/ }),

/***/ "./src/scripts/canvas/canvas.js":
/*!**************************************!*\
  !*** ./src/scripts/canvas/canvas.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constants */ "./src/scripts/util/constants.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-full.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _modal_modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modal/modal */ "./src/scripts/modal/modal.js");
/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/util */ "./src/scripts/util/util.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





var boundsIdentifierObj = {
  1: 'topLeft',
  2: 'topRight',
  3: 'bottomRight',
  0: 'bottomLeft'
};
var LINE = 'line';

var MyCanvas =
/*#__PURE__*/
function () {
  function MyCanvas(canvasElement) {
    _classCallCheck(this, MyCanvas);

    this.canvasElement = canvasElement;
    this.centerPosition = this.getCenterPosition();
    this.strokeColor = 'black';
    this.fillColor = "white";
    this.defaultSize = [100, 100];
    this.currentActiveItem = null;
    this.strokeWidth = 2; // sets up paper js on canvas

    paper__WEBPACK_IMPORTED_MODULE_1___default.a.setup(canvasElement); //creates new project in paper

    this.project = new paper__WEBPACK_IMPORTED_MODULE_1__["Project"](canvasElement); //creating tool

    this.tool = new paper__WEBPACK_IMPORTED_MODULE_1__["Tool"](); // has moved at least 10 points:

    paper__WEBPACK_IMPORTED_MODULE_1__["tool"].minDistance = 2; //binds methods
    //shapes method binding

    this.drawShapes = this.drawShapes.bind(this);
    this.drawClassShape = this.drawClassShape.bind(this);
    this.drawLineShape = this.drawLineShape.bind(this);
    this.drawObjectShape = this.drawObjectShape.bind(this);
    this.drawTextShape = this.drawTextShape.bind(this);
    this.drawUserCaseShape = this.drawUseCaseShape.bind(this);
    this.drawComponentShape = this.drawComponentShape.bind(this);
    this.drawModuleShape = this.drawModuleShape.bind(this);
    this.drawActivityShape = this.drawActivityShape.bind(this);
    this.drawDecisionShape = this.drawDecisionShape.bind(this);
    this.drawActorShape = this.drawActorShape.bind(this); //general method binding

    this.getCenterPosition = this.getCenterPosition.bind(this); //user interaction method binding

    this.onToolDoubleClick = this.onToolDoubleClick.bind(this);
    this.onToolMouseDown = this.onToolMouseDown.bind(this);
    this.setOneItemSelected = this.setOneItemSelected.bind(this);
    this.onToolDrag = this.onToolDrag.bind(this);
    this.onToolKeyDown = this.onToolKeyDown.bind(this); //tool level clicklistener

    this.tool.onMouseDown = this.onToolMouseDown;
    this.tool.onMouseUp = this.onToolMouseUp;
    this.tool.onMouseDrag = this.onToolDrag;
    this.tool.onKeyDown = this.onToolKeyDown; //add double click listener on canvas because tool have no double click listener

    this.canvasElement.addEventListener("dblclick", this.onToolDoubleClick); //set right menu liteners

    this.setRightMenuListeners = this.setRightMenuListeners.bind(this);
    this.setRightMenuListeners();
  } //set right menu click listener


  _createClass(MyCanvas, [{
    key: "setRightMenuListeners",
    value: function setRightMenuListeners() {
      var openFileElement = document.getElementById('open-file');
      var downloadFileElement = document.getElementById('download-file');
      openFileElement.addEventListener('click', this.openFile);
      downloadFileElement.addEventListener('click', this.downloadAsSVG.bind(this));
    } //set input to open file picker dialog

  }, {
    key: "openFile",
    value: function openFile() {
      var _this = this;

      var input = document.createElement('input');
      input.type = 'file';
      input.multiple = false;
      input.accept = 'image/svg+xml';

      input.onchange = function () {
        _this.project.importSVG(URL.createObjectURL(input.files[0]), function (group, svg) {
          _this.project.clear();

          var that = _this;
          debugger;

          while (group.children[1].children.length > 0) {
            that.project.activeLayer.addChild(group.children[1].children[0]);
          }
        });
      };

      input.click();
    } // set download project as svg

  }, {
    key: "downloadAsSVG",
    value: function downloadAsSVG() {
      if (this.project.activeLayer.children.length == 0) return;
      var fileName = "umlchart_".concat(Date.now(), ".svg");
      var url = "data:image/svg+xml;utf8," + encodeURIComponent(this.project.exportSVG({
        asString: true
      }));
      var downloadLinkElement = document.createElement("a");
      downloadLinkElement.download = fileName;
      downloadLinkElement.href = url;
      downloadLinkElement.click();
    } //shape draw distributor

  }, {
    key: "drawShapes",
    value: function drawShapes(shapeName) {
      switch (shapeName) {
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CLASS:
          this.drawClassShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ASSOCIATION:
          var startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 50, this.centerPosition.y);
          var endPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 50, this.centerPosition.y);
          this.drawLineShape(startPoint, endPoint, shapeName);
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].SQUARE:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].OBJECT:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].INTERFACE:
          this.drawObjectShape(shapeName);
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].TITLE:
          startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 25, this.centerPosition.y - 25);
          this.drawTextShape(startPoint, "Add Text");
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CIRCLE:
        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].USECASE:
          this.drawUseCaseShape(shapeName);
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPONENT:
          this.drawComponentShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].MODULE:
          this.drawModuleShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTIVITY:
          this.drawActivityShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DECISION:
          this.drawDecisionShape();
          break;

        case _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTOR:
          this.drawActorShape();

        default:
          break;
      }
    } // Creates three rectangle to make a class UML

  }, {
    key: "drawClassShape",
    value: function drawClassShape() {
      //creates group and add shapes
      //create class rectangle
      var groupClass = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      var firstRectX = this.centerPosition.x - 50;
      var firstRectY = this.centerPosition.y - 50;
      var firstRectHeight = 20;
      var fristRectWidth = this.defaultSize[1];
      var classNameRectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(firstRectX, firstRectY, fristRectWidth, firstRectHeight);
      this.setStrokeAndFill(classNameRectangle);
      groupClass.addChild(classNameRectangle); //create varaible rectangle

      var secRectX = firstRectX;
      var secRectY = firstRectY + firstRectHeight;
      var secRectHeight = 50;
      var secRectWidth = this.defaultSize[1];
      var variableNameRectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(secRectX, secRectY, secRectWidth, secRectHeight);
      this.setStrokeAndFill(variableNameRectangle);
      groupClass.addChild(variableNameRectangle); //create method rectangle

      var thirdRectX = firstRectX;
      var thirdRectY = secRectY + secRectHeight;
      var thirdRectHeight = 30;
      var thirdRectWidth = this.defaultSize[1];
      var methodNameRectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(thirdRectX, thirdRectY, thirdRectWidth, thirdRectHeight);
      this.setStrokeAndFill(methodNameRectangle);
      groupClass.addChild(methodNameRectangle);
    } // adds text to the clicked area

  }, {
    key: "drawTextShape",
    value: function drawTextShape(position, text) {
      //create text shape
      var textShape = new paper__WEBPACK_IMPORTED_MODULE_1__["PointText"](position);
      textShape.fillColor = this.strokeColor;
      textShape.content = text; //adds doubleclick listner to text

      textShape.onDoubleClick = function (e) {
        //show modal to update text
        if (textShape.selected) {
          new _modal_modal__WEBPACK_IMPORTED_MODULE_2__["default"](function (updatedText) {
            textShape.content = updatedText;
          }).show();
        }
      };

      return textShape;
    } //add Divider/Association/Compositioin/Aggregation with head shape and three circles (to aid movement and drag)

  }, {
    key: "drawLineShape",
    value: function drawLineShape(startPoint, endPoint, lineType) {
      var mainGroup = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"](); //draw line

      var line = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(startPoint, endPoint);
      this.setStrokeAndFill(line); // draw head circle

      var headCircle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(endPoint, 5);
      headCircle.fillColor = 'black';
      headCircle.strokeWidth = 1; //draw middle circle

      var midPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"]((startPoint.x + endPoint.x) / 2, (startPoint.y + endPoint.y) / 2);
      var midCircle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(midPoint, 4);
      midCircle.fillColor = 'black';
      midCircle.strokeWidth = 1; //draw tail circle

      var tailCircle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(startPoint, 5);
      tailCircle.fillColor = 'black';
      tailCircle.strokeWidth = 1; //add circles and line to group

      group.addChild(line);
      group.addChild(tailCircle);
      group.addChild(midCircle);
      group.addChild(headCircle); //draw arrow shape

      var headShape = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"]();
      headShape.strokeColor = this.strokeColor;
      headShape.strokeWidth = this.strokeWidth;
      var arrowCenter = endPoint; //based on line type draw shape

      if (lineType !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER) {
        var leftEdge = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](arrowCenter.x - 10, arrowCenter.y - 10);
        var rightEdge = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](arrowCenter.x - 10, arrowCenter.y + 10);
        headShape.add(leftEdge);
        headShape.add(arrowCenter);
        headShape.add(rightEdge);

        if (lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION || lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION) {
          var bottomRightEdge = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](arrowCenter.x - 20, arrowCenter.y);
          var bottomLeftEdge = leftEdge;
          headShape.add(bottomRightEdge);
          headShape.add(bottomLeftEdge);

          if (lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION) {
            headShape.strokeColor = 'white';
            headShape.fillColor = 'white';
            headShape.shadowColor = 'gray';
            headShape.shadowOffset = 1;
          }

          if (lineType === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION) {
            headShape.fillColor = 'black';
          }
        }
      } //rotate the head shape


      if (lineType !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER) headShape.rotate(Object(_util_util__WEBPACK_IMPORTED_MODULE_3__["getAngleDeg"])(endPoint.x, endPoint.y, startPoint.x, startPoint.y), arrowCenter); //add group to main group

      mainGroup.addChild(group);
      if (lineType !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER) mainGroup.addChild(headShape);
      mainGroup.data.type = LINE;
      mainGroup.data.lineType = lineType;
      return mainGroup;
    } //add Object/Interface shape

  }, {
    key: "drawObjectShape",
    value: function drawObjectShape(type) {
      //creates object rectangle
      var startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 50, this.centerPosition.y - 25);
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(startPoint.x, startPoint.y, this.defaultSize[0], this.defaultSize[0] / 2);
      this.setStrokeAndFill(rectangle); //create textshape

      if (type !== _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].SQUARE) {
        var textShapeStartPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](startPoint.x + 30, startPoint.y + 30);
        var textShape = this.drawTextShape(textShapeStartPoint, type);
      }
    } //add Usecase/Activity shape

  }, {
    key: "drawUseCaseShape",
    value: function drawUseCaseShape(type) {
      //draw circle
      var circlePath = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(this.centerPosition, 25);
      circlePath.scale(2, 1.2); //scale to make it an oval

      this.setStrokeAndFill(circlePath);

      if (type === _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].USECASE) {
        //add Text
        var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 25, this.centerPosition.y + 5), type);
      }
    } //add Component shape

  }, {
    key: "drawComponentShape",
    value: function drawComponentShape() {
      //draw main rectangle
      var startPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 50, this.centerPosition.y - 25);
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(startPoint.x, startPoint.y, this.defaultSize[0] + 20, this.defaultSize[0] - 45);
      this.setStrokeAndFill(rectangle); // draw sub part of the shape

      var subRect = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topRight.x - 25, startPoint.y + 6, 20, 25);
      this.setStrokeAndFill(subRect);
      subRect.strokeWidth = 2 / this.strokeWidth; //draw two sub rec

      var subRect1 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topRight.x - 28, startPoint.y + 9, 7, 7);
      this.setStrokeAndFill(subRect1);
      subRect1.strokeWidth = 2 / this.strokeWidth;
      var subRect2 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topRight.x - 28, startPoint.y + 20, 7, 7);
      this.setStrokeAndFill(subRect2);
      subRect2.strokeWidth = 2 / this.strokeWidth; //create group and add shapes

      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      group.addChild(rectangle);
      group.addChild(subRect);
      group.addChild(subRect1);
      group.addChild(subRect2); //add text to shape

      var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 25, this.centerPosition.y + 8), _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPONENT);
    } //add module shape

  }, {
    key: "drawModuleShape",
    value: function drawModuleShape() {
      // draw main rect
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(this.centerPosition.x - 50, this.centerPosition.y - 50, this.defaultSize[0] + 20, this.defaultSize[0] - 40);
      this.setStrokeAndFill(rectangle); //draw two sub rec

      var subRect1 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topLeft.x - 7, rectangle.bounds.topLeft.y + 12, 15, 12);
      this.setStrokeAndFill(subRect1);
      var subRect2 = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle.bounds.topLeft.x - 7, rectangle.bounds.topLeft.y + 35, 15, 12);
      this.setStrokeAndFill(subRect2); //create group and add shapes

      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      group.addChild(rectangle);
      group.addChild(subRect1);
      group.addChild(subRect2); //add text to shape

      var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 10, this.centerPosition.y - 15), _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].MODULE);
    } //add activity shape

  }, {
    key: "drawActivityShape",
    value: function drawActivityShape() {
      //create rounded shape rectangle
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](this.centerPosition.subtract(50), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 70, this.centerPosition.y));
      var radius = new paper__WEBPACK_IMPORTED_MODULE_1__["Size"](30, 30);
      var path = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(rectangle, radius);
      this.setStrokeAndFill(path); //add text to shape

      var textShape = this.drawTextShape(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 10, this.centerPosition.y - 20), _util_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTIVITY);
    } //add decision shape

  }, {
    key: "drawDecisionShape",
    value: function drawDecisionShape() {
      //create rectangle
      var rectangle = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(this.centerPosition.x - 20, this.centerPosition.y - 20, this.defaultSize[0] / 2.5, this.defaultSize[0] / 2.5);
      this.setStrokeAndFill(rectangle); //rotate

      rectangle.rotate(45);
    } //on tool click

  }, {
    key: "onToolMouseDown",
    value: function onToolMouseDown(e) {
      //toggle item selected
      this.setOneItemSelected(e); //return if no currentActiveItem

      if (!this.currentActiveItem) return; //clearing currentActiveItem data to fix the issue of unintended moves

      this.currentActiveItem.data.state = null;

      if (this.currentActiveItem.contains(e.point)) {
        this.currentActiveItem.data.state = 'move';
      } //set items data based on item mouseDown point


      if (this.currentActiveItem.data.type !== LINE) {
        if (this.currentActiveItem.hitTest(e.point, {
          bounds: true,
          tolerance: 5
        })) {
          //get bounds of the shape
          var bounds = this.currentActiveItem.bounds; //itrating to find the exact bound point

          for (var _i = 0, _Object$entries = Object.entries(boundsIdentifierObj); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                key = _Object$entries$_i[0],
                value = _Object$entries$_i[1];

            if (bounds[value].isClose(e.point, 5)) {
              var oppositeBound = bounds[boundsIdentifierObj[(parseInt(key) + 2) % 4]]; //get opposite bound point

              var oppositePoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](oppositeBound.x, oppositeBound.y); //get current bound point

              var currentPoint = new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](bounds[value].x, bounds[value].y); //set shape data to be used for resizing later

              this.currentActiveItem.data.state = 'resize';
              this.currentActiveItem.data.from = oppositePoint;
              this.currentActiveItem.data.to = currentPoint;
              break;
            }
          }
        }
      } else {
        //only for shapes with type LINE
        var headCircleItem = this.currentActiveItem.firstChild.children[3];

        if (headCircleItem.contains(e.point)) {
          this.currentActiveItem.data.state = 'resize';
        }
      }
    } //draw actor shape

  }, {
    key: "drawActorShape",
    value: function drawActorShape() {
      //draw actor head
      var head = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Circle(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 50), 7);
      this.setStrokeAndFill(head); //draw actor body

      var body = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 43), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 10));
      this.setStrokeAndFill(body); //draw actor arms

      var arms = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 20, this.centerPosition.y - 38), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 20, this.centerPosition.y - 38));
      this.setStrokeAndFill(arms); //draw feet

      var leftFeet = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x - 20, this.centerPosition.y + 5), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 10));
      this.setStrokeAndFill(leftFeet);
      var rightFeet = new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Line(new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x, this.centerPosition.y - 10), new paper__WEBPACK_IMPORTED_MODULE_1__["Point"](this.centerPosition.x + 20, this.centerPosition.y + 5));
      this.setStrokeAndFill(rightFeet); //add shapes to group to make full actor

      var group = new paper__WEBPACK_IMPORTED_MODULE_1__["Group"]();
      group.addChild(head);
      group.addChild(body);
      group.addChild(arms);
      group.addChild(leftFeet);
      group.addChild(rightFeet);
    } //item drag listener

  }, {
    key: "onToolDrag",
    value: function onToolDrag(e) {
      // debugger
      if (this.currentActiveItem == null) return;

      if (this.currentActiveItem.data.state === 'move') {
        this.currentActiveItem.position = e.point;
      } else if (this.currentActiveItem.data.state === 'resize') {
        if (this.currentActiveItem.data.type === LINE) {
          //shapes with type line, re-rendering line on each user move
          var lineStartPoint = this.currentActiveItem.firstChild.firstChild.segments[0].point;
          var lineType = this.currentActiveItem.data.lineType;
          this.currentActiveItem.remove();
          this.currentActiveItem = this.drawLineShape(lineStartPoint, e.point, lineType);
          this.currentActiveItem.data.state = 'resize';
        } else {
          //shapes other than line, updating the bounds
          this.currentActiveItem.bounds = new paper__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](this.currentActiveItem.data.from, e.point);
        }

        this.currentActiveItem.selected = true;
      }
    } //on tool double click

  }, {
    key: "onToolDoubleClick",
    value: function onToolDoubleClick(e) {
      if (e.ctrlKey) {
        this.drawTextShape({
          x: e.layerX,
          y: e.layerY
        }, "Add Text");
      }
    } //toggle item selecteion and saving currentActiveItem

  }, {
    key: "setOneItemSelected",
    value: function setOneItemSelected(e) {
      var position = e.point;
      var clickedItems = [];
      this.project.activeLayer.children.forEach(function (child) {
        if (child.contains(position)) {
          clickedItems.push(child);
        } else {
          child.selected = false;
        }
      }); //return if no item is selected

      if (clickedItems.length === 0) return; //select the clicked item

      var latestItem = clickedItems[0];

      for (var i = 0; i < clickedItems.length; i++) {
        if (latestItem.id < clickedItems[i].id) {
          latestItem = clickedItems[i];
        } else {
          clickedItems[i].selected = false;
        }
      }

      this.currentActiveItem = latestItem;
      latestItem.selected = true;
    } // keyboard intraction to move shapes

  }, {
    key: "onToolKeyDown",
    value: function onToolKeyDown(e) {
      if (!this.currentActiveItem) return;
      var position = this.currentActiveItem.position;
      var step = 5;

      switch (e.key) {
        case 'left':
          position.x -= step;
          break;

        case 'right':
          position.x += step;
          break;

        case 'up':
          position.y -= step;
          break;

        case 'down':
          position.y += step;
          break;
      }

      this.currentActiveItem.position = position;
    } //----------------------- general methods --------------------------------------
    // return center position of canvas

  }, {
    key: "getCenterPosition",
    value: function getCenterPosition() {
      return new paper__WEBPACK_IMPORTED_MODULE_1__["Point"]({
        x: this.canvasElement.clientWidth / 2,
        y: this.canvasElement.clientHeight / 2
      });
    } // helper to set stroke and fill

  }, {
    key: "setStrokeAndFill",
    value: function setStrokeAndFill(item) {
      item.strokeWidth = this.strokeWidth;
      item.strokeColor = this.strokeColor;
      item.fillColor = this.fillColor;
    }
  }]);

  return MyCanvas;
}();

/* harmony default export */ __webpack_exports__["default"] = (MyCanvas);

/***/ }),

/***/ "./src/scripts/modal/modal.js":
/*!************************************!*\
  !*** ./src/scripts/modal/modal.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Modal; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Modal =
/*#__PURE__*/
function () {
  function Modal(textCallback) {
    _classCallCheck(this, Modal);

    this.textCallback = textCallback;
    this.show = this.show.bind(this);
  }

  _createClass(Modal, [{
    key: "show",
    value: function show() {
      var _this = this;

      var bodyElement = document.getElementById('body');
      var modalMainContainerElement = document.createElement('div');
      modalMainContainerElement.setAttribute('class', 'modal-main-container');
      var modalContainerElement = document.createElement('div');
      modalContainerElement.setAttribute('class', 'modal-container');
      var modalTitleConainerElement = document.createElement('div');
      modalTitleConainerElement.setAttribute('class', 'modal-title-container');
      var modalTitleElement = document.createElement('h1');
      modalTitleElement.innerHTML = "Add Text";
      modalTitleElement.setAttribute('class', 'modal-title');
      var modalCloseElement = document.createElement('span');
      modalCloseElement.innerHTML = "X";
      modalCloseElement.setAttribute('class', 'modal-close');
      var modalInputElement = document.createElement('input');
      modalInputElement.placeholder = "Add text here";
      modalInputElement.setAttribute('class', 'modal-input');
      var modalSubmitElement = document.createElement('button');
      modalSubmitElement.innerHTML = "Submit";
      modalSubmitElement.setAttribute('class', 'modal-submit');
      modalTitleConainerElement.appendChild(modalTitleElement);
      modalTitleConainerElement.appendChild(modalCloseElement);
      modalContainerElement.appendChild(modalTitleConainerElement);
      modalContainerElement.appendChild(modalInputElement);
      modalContainerElement.appendChild(modalSubmitElement);
      modalMainContainerElement.appendChild(modalContainerElement);
      bodyElement.appendChild(modalMainContainerElement); //adds listeners
      //close modal on outside click

      modalMainContainerElement.addEventListener('click', function (e) {
        modalMainContainerElement.setAttribute('class', 'hiddden');
      }); //stops modal from closing if clicked inside modal

      modalContainerElement.addEventListener('click', function (e) {
        e.stopPropagation();
      }); //closes modal on click

      modalCloseElement.addEventListener('click', function (e) {
        modalMainContainerElement.setAttribute('class', 'hiddden');
      }); //gets text form input on submit and sending to callback

      modalSubmitElement.addEventListener('click', function (e) {
        var inputText = modalInputElement.value;

        _this.textCallback(inputText);

        modalMainContainerElement.setAttribute('class', 'hiddden');
      });
    }
  }]);

  return Modal;
}();



/***/ }),

/***/ "./src/scripts/sidebar/sidebar.js":
/*!****************************************!*\
  !*** ./src/scripts/sidebar/sidebar.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Sidebar; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Sidebar =
/*#__PURE__*/
function () {
  function Sidebar(categoryObj, sidebarElement, onShapeClickCallback) {
    _classCallCheck(this, Sidebar);

    this.categoryTitle = categoryObj.categoryName;
    this.shapes = categoryObj.shapes;
    this.sidebarElement = sidebarElement;
    this.onShapeClickCallback = onShapeClickCallback;
    this.draw();
    this.shapeClickListener = this.shapeClickListener.bind(this);
  }

  _createClass(Sidebar, [{
    key: "shapeClickListener",
    value: function shapeClickListener(shapeName) {
      var _this = this;

      return function (e) {
        _this.onShapeClickCallback(shapeName);
      };
    }
  }, {
    key: "draw",
    value: function draw() {
      //adds category title in sidebar
      var categoryTitleElement = document.createElement('h1');
      categoryTitleElement.innerHTML = this.categoryTitle;
      categoryTitleElement.setAttribute('class', 'sidebar-category-title');
      this.sidebarElement.appendChild(categoryTitleElement); //adds category shapes in sidebar

      var shapesUlElement = document.createElement('ul');
      shapesUlElement.setAttribute('class', "sidebar-category-shapes-ul");

      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];
        var shapeLiElement = document.createElement('li');
        shapeLiElement.setAttribute('class', "sidebar-category-shapes-li");
        shapeLiElement.addEventListener("click", this.shapeClickListener(shape.name));
        var shapeImageElement = document.createElement('img');
        shapeImageElement.setAttribute('class', "sidebar-category-images");
        shapeImageElement.src = shape.uri;
        shapeLiElement.appendChild(shapeImageElement);
        shapesUlElement.appendChild(shapeLiElement);
      }

      this.sidebarElement.appendChild(shapesUlElement);
    }
  }]);

  return Sidebar;
}();



/***/ }),

/***/ "./src/scripts/util/constants.js":
/*!***************************************!*\
  !*** ./src/scripts/util/constants.js ***!
  \***************************************/
/*! exports provided: SHAPES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHAPES", function() { return SHAPES; });
var SHAPES = {
  CLASS: 'Class',
  SQUARE: 'Square',
  DIVIDER: 'Divider',
  CIRCLE: 'Circle',
  OBJECT: 'Object',
  INTERFACE: 'Interface',
  ACTOR: 'Actor',
  AGGREGATION: 'Aggregation',
  COMPOSITION: 'Composition',
  ASSOCIATION: 'Association',
  COMPONENT: 'Component',
  MODULE: 'Module',
  TITLE: 'Title',
  ACTIVITY: 'Activity',
  USECASE: 'Use Case',
  DECISION: 'Decision'
};

/***/ }),

/***/ "./src/scripts/util/sidebar_data.js":
/*!******************************************!*\
  !*** ./src/scripts/util/sidebar_data.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/scripts/util/constants.js");

var sidebarData = [{
  categoryName: "UML",
  shapes: [{
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].OBJECT,
    uri: './src/images/object.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].INTERFACE,
    uri: './src/images/interface.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CLASS,
    uri: './src/images/class.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DIVIDER,
    uri: './src/images/divider.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].TITLE,
    uri: './src/images/title.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPONENT,
    uri: './src/images/component.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].MODULE,
    uri: './src/images/module.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTOR,
    uri: './src/images/actor.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].USECASE,
    uri: './src/images/usercase.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ACTIVITY,
    uri: './src/images/activity.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].DECISION,
    uri: './src/images/decision.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].AGGREGATION,
    uri: './src/images/aggregation.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].COMPOSITION,
    uri: './src/images/composition.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].ASSOCIATION,
    uri: './src/images/association.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].CIRCLE,
    uri: './src/images/circle.svg'
  }, {
    name: _constants__WEBPACK_IMPORTED_MODULE_0__["SHAPES"].SQUARE,
    uri: './src/images/square.svg'
  }]
}];
/* harmony default export */ __webpack_exports__["default"] = (sidebarData);

/***/ }),

/***/ "./src/scripts/util/util.js":
/*!**********************************!*\
  !*** ./src/scripts/util/util.js ***!
  \**********************************/
/*! exports provided: getAngleDeg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngleDeg", function() { return getAngleDeg; });
function getAngleDeg(ex, ey, cx, cy) {
  var dy = ey - cy;
  var dx = ex - cx;
  var theta = Math.atan2(dy, dx);
  theta *= 180 / Math.PI;
  return theta;
}

/***/ }),

/***/ "./src/styles/index.scss":
/*!*******************************!*\
  !*** ./src/styles/index.scss ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 0:
/*!********************************!*\
  !*** ./node/self.js (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************************!*\
  !*** ./node/extend.js (ignored) ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fjb3JuL2Rpc3QvYWNvcm4ubWpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWZ1bGwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NhbnZhcy9jYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvbW9kYWwvbW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvc2lkZWJhci9zaWRlYmFyLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3V0aWwvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3V0aWwvc2lkZWJhcl9kYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL2luZGV4LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZS9zZWxmLmpzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9ub2RlL2V4dGVuZC5qcyAoaWdub3JlZCkiXSwibmFtZXMiOlsid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1haW4iLCJjYW52YXNFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm15Q2FudmFzIiwiTXlDYW52YXMiLCJzaWRlYmFyRWxlbWVudCIsInNpZGViYXIiLCJTaWRlYmFyIiwic2lkZWJhckRhdGEiLCJkcmF3U2hhcGVzIiwiYm91bmRzSWRlbnRpZmllck9iaiIsIkxJTkUiLCJjZW50ZXJQb3NpdGlvbiIsImdldENlbnRlclBvc2l0aW9uIiwic3Ryb2tlQ29sb3IiLCJmaWxsQ29sb3IiLCJkZWZhdWx0U2l6ZSIsImN1cnJlbnRBY3RpdmVJdGVtIiwic3Ryb2tlV2lkdGgiLCJwYXBlciIsInNldHVwIiwicHJvamVjdCIsIlByb2plY3QiLCJ0b29sIiwiVG9vbCIsIm1pbkRpc3RhbmNlIiwiYmluZCIsImRyYXdDbGFzc1NoYXBlIiwiZHJhd0xpbmVTaGFwZSIsImRyYXdPYmplY3RTaGFwZSIsImRyYXdUZXh0U2hhcGUiLCJkcmF3VXNlckNhc2VTaGFwZSIsImRyYXdVc2VDYXNlU2hhcGUiLCJkcmF3Q29tcG9uZW50U2hhcGUiLCJkcmF3TW9kdWxlU2hhcGUiLCJkcmF3QWN0aXZpdHlTaGFwZSIsImRyYXdEZWNpc2lvblNoYXBlIiwiZHJhd0FjdG9yU2hhcGUiLCJvblRvb2xEb3VibGVDbGljayIsIm9uVG9vbE1vdXNlRG93biIsInNldE9uZUl0ZW1TZWxlY3RlZCIsIm9uVG9vbERyYWciLCJvblRvb2xLZXlEb3duIiwib25Nb3VzZURvd24iLCJvbk1vdXNlVXAiLCJvblRvb2xNb3VzZVVwIiwib25Nb3VzZURyYWciLCJvbktleURvd24iLCJzZXRSaWdodE1lbnVMaXN0ZW5lcnMiLCJvcGVuRmlsZUVsZW1lbnQiLCJkb3dubG9hZEZpbGVFbGVtZW50Iiwib3BlbkZpbGUiLCJkb3dubG9hZEFzU1ZHIiwiaW5wdXQiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsIm11bHRpcGxlIiwiYWNjZXB0Iiwib25jaGFuZ2UiLCJpbXBvcnRTVkciLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJmaWxlcyIsImdyb3VwIiwic3ZnIiwiY2xlYXIiLCJ0aGF0IiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJhY3RpdmVMYXllciIsImFkZENoaWxkIiwiY2xpY2siLCJmaWxlTmFtZSIsIkRhdGUiLCJub3ciLCJ1cmwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJleHBvcnRTVkciLCJhc1N0cmluZyIsImRvd25sb2FkTGlua0VsZW1lbnQiLCJkb3dubG9hZCIsImhyZWYiLCJzaGFwZU5hbWUiLCJTSEFQRVMiLCJDTEFTUyIsIkFHR1JFR0FUSU9OIiwiQ09NUE9TSVRJT04iLCJESVZJREVSIiwiQVNTT0NJQVRJT04iLCJzdGFydFBvaW50IiwiUG9pbnQiLCJ4IiwieSIsImVuZFBvaW50IiwiU1FVQVJFIiwiT0JKRUNUIiwiSU5URVJGQUNFIiwiVElUTEUiLCJDSVJDTEUiLCJVU0VDQVNFIiwiQ09NUE9ORU5UIiwiTU9EVUxFIiwiQUNUSVZJVFkiLCJERUNJU0lPTiIsIkFDVE9SIiwiZ3JvdXBDbGFzcyIsIkdyb3VwIiwiZmlyc3RSZWN0WCIsImZpcnN0UmVjdFkiLCJmaXJzdFJlY3RIZWlnaHQiLCJmcmlzdFJlY3RXaWR0aCIsImNsYXNzTmFtZVJlY3RhbmdsZSIsIlBhdGgiLCJSZWN0YW5nbGUiLCJzZXRTdHJva2VBbmRGaWxsIiwic2VjUmVjdFgiLCJzZWNSZWN0WSIsInNlY1JlY3RIZWlnaHQiLCJzZWNSZWN0V2lkdGgiLCJ2YXJpYWJsZU5hbWVSZWN0YW5nbGUiLCJ0aGlyZFJlY3RYIiwidGhpcmRSZWN0WSIsInRoaXJkUmVjdEhlaWdodCIsInRoaXJkUmVjdFdpZHRoIiwibWV0aG9kTmFtZVJlY3RhbmdsZSIsInBvc2l0aW9uIiwidGV4dCIsInRleHRTaGFwZSIsIlBvaW50VGV4dCIsImNvbnRlbnQiLCJvbkRvdWJsZUNsaWNrIiwiZSIsInNlbGVjdGVkIiwiTW9kYWwiLCJ1cGRhdGVkVGV4dCIsInNob3ciLCJsaW5lVHlwZSIsIm1haW5Hcm91cCIsImxpbmUiLCJMaW5lIiwiaGVhZENpcmNsZSIsIkNpcmNsZSIsIm1pZFBvaW50IiwibWlkQ2lyY2xlIiwidGFpbENpcmNsZSIsImhlYWRTaGFwZSIsImFycm93Q2VudGVyIiwibGVmdEVkZ2UiLCJyaWdodEVkZ2UiLCJhZGQiLCJib3R0b21SaWdodEVkZ2UiLCJib3R0b21MZWZ0RWRnZSIsInNoYWRvd0NvbG9yIiwic2hhZG93T2Zmc2V0Iiwicm90YXRlIiwiZ2V0QW5nbGVEZWciLCJkYXRhIiwicmVjdGFuZ2xlIiwidGV4dFNoYXBlU3RhcnRQb2ludCIsImNpcmNsZVBhdGgiLCJzY2FsZSIsInN1YlJlY3QiLCJib3VuZHMiLCJ0b3BSaWdodCIsInN1YlJlY3QxIiwic3ViUmVjdDIiLCJ0b3BMZWZ0Iiwic3VidHJhY3QiLCJyYWRpdXMiLCJTaXplIiwicGF0aCIsInN0YXRlIiwiY29udGFpbnMiLCJwb2ludCIsImhpdFRlc3QiLCJ0b2xlcmFuY2UiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJpc0Nsb3NlIiwib3Bwb3NpdGVCb3VuZCIsInBhcnNlSW50Iiwib3Bwb3NpdGVQb2ludCIsImN1cnJlbnRQb2ludCIsImZyb20iLCJ0byIsImhlYWRDaXJjbGVJdGVtIiwiZmlyc3RDaGlsZCIsImhlYWQiLCJib2R5IiwiYXJtcyIsImxlZnRGZWV0IiwicmlnaHRGZWV0IiwibGluZVN0YXJ0UG9pbnQiLCJzZWdtZW50cyIsInJlbW92ZSIsImN0cmxLZXkiLCJsYXllclgiLCJsYXllclkiLCJjbGlja2VkSXRlbXMiLCJmb3JFYWNoIiwiY2hpbGQiLCJwdXNoIiwibGF0ZXN0SXRlbSIsImkiLCJpZCIsInN0ZXAiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIml0ZW0iLCJ0ZXh0Q2FsbGJhY2siLCJib2R5RWxlbWVudCIsIm1vZGFsTWFpbkNvbnRhaW5lckVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJtb2RhbENvbnRhaW5lckVsZW1lbnQiLCJtb2RhbFRpdGxlQ29uYWluZXJFbGVtZW50IiwibW9kYWxUaXRsZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJtb2RhbENsb3NlRWxlbWVudCIsIm1vZGFsSW5wdXRFbGVtZW50IiwicGxhY2Vob2xkZXIiLCJtb2RhbFN1Ym1pdEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsInN0b3BQcm9wYWdhdGlvbiIsImlucHV0VGV4dCIsImNhdGVnb3J5T2JqIiwib25TaGFwZUNsaWNrQ2FsbGJhY2siLCJjYXRlZ29yeVRpdGxlIiwiY2F0ZWdvcnlOYW1lIiwic2hhcGVzIiwiZHJhdyIsInNoYXBlQ2xpY2tMaXN0ZW5lciIsImNhdGVnb3J5VGl0bGVFbGVtZW50Iiwic2hhcGVzVWxFbGVtZW50Iiwic2hhcGUiLCJzaGFwZUxpRWxlbWVudCIsIm5hbWUiLCJzaGFwZUltYWdlRWxlbWVudCIsInNyYyIsInVyaSIsImV4IiwiZXkiLCJjeCIsImN5IiwiZHkiLCJkeCIsInRoZXRhIiwiTWF0aCIsImF0YW4yIiwiUEkiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzQ0FBc0M7QUFDM0M7QUFDQSxLQUFLLHVDQUF1QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLLHNDQUFzQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsWUFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsT0FBTzs7QUFFcEQsdURBQXVELE9BQU87O0FBRTlEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLDJEQUEyRDtBQUMxRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLDZFQUE2RTtBQUM1RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLHVJQUF1STtBQUN0SixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0MsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQkFBa0I7QUFDbEI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkRBQTZELE9BQU87QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RCxPQUFPOztBQUUvRDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQSxzREFBc0QsT0FBTztBQUM3RCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGlHQUFpRztBQUNqRztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLE9BQU87QUFDaEM7O0FBRUEsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixZQUFZOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixPQUFPOztBQUU5QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlO0FBQ2Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixXQUFXO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsWUFBWTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRSxVQUFVO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVCQUF1QixpQkFBaUI7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7O0FBRUEsOENBQThDLE9BQU87QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFlBQVk7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxxQkFBcUIsNkNBQTZDO0FBQ2xFOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhGQUE4RjtBQUM5Rjs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWCwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFF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QUNMO0FBQ0EsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVAsd0NBQXdDLE9BQU87O0FBRS9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQ0FBa0M7QUFDbEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLGtJQUFrSTtBQUNqSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsMktBQTJLO0FBQzFMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLGtJQUFrSTtBQUNqSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxzREFBc0QsY0FBYztBQUNwRTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFlBQVk7QUFDckM7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQWM7QUFDaEM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBTztBQUMvQixPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLElBQXlDLFNBQVMsaUNBQU8sQ0FBQyxPQUFTLENBQUMsb0NBQUUsR0FBRztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUN0RiwwQ0FBMEM7QUFDMUMsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLGtCQUFrQjtBQUNoRCwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEZBQTRGO0FBQzVGLDhCQUE4Qjs7QUFFOUIsMkJBQTJCLGdCQUFnQjs7QUFFM0MsOEJBQThCLGFBQWE7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHFDQUFxQzs7QUFFckMsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxnREFBZ0Q7QUFDN0Y7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELE9BQU87QUFDbEU7QUFDQTtBQUNBLGlEQUFpRCwwQ0FBMEMsbURBQW1EO0FBQzlJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2REFBNkQsb0VBQW9FO0FBQzlLO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UseUNBQXlDO0FBQ2pIO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsbUJBQW1CO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixtQkFBbUI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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ckIsRUFBd0JDLEVBQXhCLEVBQTJCQyxFQUEzQixFQUE4QkMsRUFBOUIsRUFBa0M7QUFDdkMsTUFBSUMsRUFBRSxHQUFHSCxFQUFFLEdBQUdFLEVBQWQ7QUFDQSxNQUFJRSxFQUFFLEdBQUdMLEVBQUUsR0FBR0UsRUFBZDtBQUNBLE1BQUlJLEtBQUssR0FBR0MsSUFBSSxDQUFDQyxLQUFMLENBQVdKLEVBQVgsRUFBZUMsRUFBZixDQUFaO0FBQ0FDLE9BQUssSUFBSSxNQUFNQyxJQUFJLENBQUNFLEVBQXBCO0FBQ0EsU0FBT0gsS0FBUDtBQUNELEM7Ozs7Ozs7Ozs7O0FDTkQsdUM7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9kaXN0L1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsIi8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbnZhciByZXNlcnZlZFdvcmRzID0ge1xuICAzOiBcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIixcbiAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICA2OiBcImVudW1cIixcbiAgc3RyaWN0OiBcImltcGxlbWVudHMgaW50ZXJmYWNlIGxldCBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgeWllbGRcIixcbiAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG59O1xuXG4vLyBBbmQgdGhlIGtleXdvcmRzXG5cbnZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbnZhciBrZXl3b3JkcyA9IHtcbiAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gIFwiNW1vZHVsZVwiOiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGV4cG9ydCBpbXBvcnRcIixcbiAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXJcIlxufTtcblxudmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxuLy8gQmlnIHVnbHkgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGNoYXJhY3RlcnMgaW4gdGhlXG4vLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuLy8gYXJlIG9ubHkgYXBwbGllZCB3aGVuIGEgY2hhcmFjdGVyIGlzIGZvdW5kIHRvIGFjdHVhbGx5IGhhdmUgYVxuLy8gY29kZSBwb2ludCBhYm92ZSAxMjguXG4vLyBHZW5lcmF0ZWQgYnkgYGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzYC5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4YTAtXFx1MDhiNFxcdTA4YjYtXFx1MDhiZFxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzYwXFx1MGM2MVxcdTBjODBcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNTQtXFx1MGQ1NlxcdTBkNWYtXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODYtXFx1MGU4YVxcdTBlOGMtXFx1MGVhM1xcdTBlYTVcXHUwZWE3LVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNVxcdTEzZjgtXFx1MTNmZFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmOFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxZVxcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjODAtXFx1MWM4OFxcdTFjOTAtXFx1MWNiYVxcdTFjYmQtXFx1MWNiZlxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmM1xcdTFjZjVcXHUxY2Y2XFx1MWNmYVxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWItXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZlxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZlZlxcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjlkXFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhN2JmXFx1YTdjMi1cXHVhN2M2XFx1YTdmNy1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE4ZmRcXHVhOGZlXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWE5ZTAtXFx1YTllNFxcdWE5ZTYtXFx1YTllZlxcdWE5ZmEtXFx1YTlmZVxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTdlLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiMzAtXFx1YWI1YVxcdWFiNWMtXFx1YWI2N1xcdWFiNzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDhkMy1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAwLVxcdTBjMDRcXHUwYzNlLVxcdTBjNDRcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MS1cXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGY5XFx1MWRmYi1cXHUxZGZmXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzVcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOGZmLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhOWU1XFx1YTlmMC1cXHVhOWY5XFx1YWEyOS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3Yi1cXHVhYTdkXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcblxuLy8gVGhlc2UgYXJlIGEgcnVuLWxlbmd0aCBhbmQgb2Zmc2V0IGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4vLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4vLyBvZmZzZXQgc3RhcnRzIGF0IDB4MTAwMDAsIGFuZCBlYWNoIHBhaXIgb2YgbnVtYmVycyByZXByZXNlbnRzIGFuXG4vLyBvZmZzZXQgdG8gdGhlIG5leHQgcmFuZ2UsIGFuZCB0aGVuIGEgc2l6ZSBvZiB0aGUgcmFuZ2UuIFRoZXkgd2VyZVxuLy8gZ2VuZXJhdGVkIGJ5IGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG52YXIgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMgPSBbMCwxMSwyLDI1LDIsMTgsMiwxLDIsMTQsMywxMywzNSwxMjIsNzAsNTIsMjY4LDI4LDQsNDgsNDgsMzEsMTQsMjksNiwzNywxMSwyOSwzLDM1LDUsNywyLDQsNDMsMTU3LDE5LDM1LDUsMzUsNSwzOSw5LDUxLDE1NywzMTAsMTAsMjEsMTEsNywxNTMsNSwzLDAsMiw0MywyLDEsNCwwLDMsMjIsMTEsMjIsMTAsMzAsNjYsMTgsMiwxLDExLDIxLDExLDI1LDcxLDU1LDcsMSw2NSwwLDE2LDMsMiwyLDIsMjgsNDMsMjgsNCwyOCwzNiw3LDIsMjcsMjgsNTMsMTEsMjEsMTEsMTgsMTQsMTcsMTExLDcyLDU2LDUwLDE0LDUwLDE0LDM1LDQ3NywyOCwxMSwwLDksMjEsMTU1LDIyLDEzLDUyLDc2LDQ0LDMzLDI0LDI3LDM1LDMwLDAsMTIsMzQsNCwwLDEzLDQ3LDE1LDMsMjIsMCwyLDAsMzYsMTcsMiwyNCw4NSw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsMjEsMCwzMyw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDE0LDAsNzIsMjYsMjMwLDQzLDExNyw2MywzMiwwLDE2MSw3LDMsMzgsMTcsMCwyLDAsMjksMCwxMSwzOSw4LDAsMjIsMCwxMiw0NSwyMCwwLDM1LDU2LDI2NCw4LDIsMzYsMTgsMCw1MCwyOSwxMTMsNiwyLDEsMiwzNywyMiwwLDI2LDUsMiwxLDIsMzEsMTUsMCwzMjgsMTgsMjcwLDkyMSwxMDMsMTEwLDE4LDE5NSwyNzQ5LDEwNzAsNDA1MCw1ODIsODYzNCw1NjgsOCwzMCwxMTQsMjksMTksNDcsMTcsMywzMiwyMCw2LDE4LDY4OSw2MywxMjksNzQsNiwwLDY3LDEyLDY1LDEsMiwwLDI5LDYxMzUsOSw3NTQsOTQ4NiwyODYsNTAsMiwxOCwzLDksMzk1LDIzMDksMTA2LDYsMTIsNCw4LDgsOSw1OTkxLDg0LDIsNzAsMiwxLDMsMCwzLDEsMywzLDIsMTEsMiwwLDIsNiwyLDY0LDIsMywzLDcsMiw2LDIsMjcsMiwzLDIsNCwyLDAsNCw2LDIsMzM5LDMsMjQsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiw3LDIzNTcsNDQsMTEsNiwxNywwLDM3MCw0MywxMzAxLDE5Niw2MCw2Nyw4LDAsMTIwNSwzLDIsMjYsMiwxLDIsMCwzLDAsMiw5LDIsMywyLDAsMiwwLDcsMCw1LDAsMiwwLDIsMCwyLDIsMiwxLDIsMCwzLDAsMiwwLDIsMCwyLDAsMiwwLDIsMSwyLDAsMywzLDIsNiwyLDMsMiwzLDIsMCwyLDksMiwxNiw2LDIsMiw0LDIsMTYsNDQyMSw0MjcxMCw0Miw0MTQ4LDEyLDIyMSwzLDU3NjEsMTUsNzQ3MiwzMTA0LDU0MV07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG52YXIgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwwLDIyNywwLDE1MCw0LDI5NCw5LDEzNjgsMiwyLDEsNiwzLDQxLDIsNSwwLDE2NiwxLDU3NCwzLDksOSw1MjUsMTAsMTc2LDIsNTQsMTQsMzIsOSwxNiwzLDQ2LDEwLDU0LDksNywyLDM3LDEzLDIsOSw2LDEsNDUsMCwxMywyLDQ5LDEzLDksMyw0LDksODMsMTEsNywwLDE2MSwxMSw2LDksNywzLDU2LDEsMiw2LDMsMSwzLDIsMTAsMCwxMSwxLDMsNiw0LDQsMTkzLDE3LDEwLDksNSwwLDgyLDE5LDEzLDksMjE0LDYsMyw4LDI4LDEsODMsMTYsMTYsOSw4MiwxMiw5LDksODQsMTQsNSw5LDI0MywxNCwxNjYsOSwyMzIsNiwzLDYsNCwwLDI5LDksNDEsNiwyLDMsOSwwLDEwLDEwLDQ3LDE1LDQwNiw3LDIsNywxNyw5LDU3LDIxLDIsMTMsMTIzLDUsNCwwLDIsMSwyLDYsMiwwLDksOSw0OSw0LDIsMSwyLDQsOSw5LDMzMCwzLDE5MzA2LDksMTM1LDQsNjAsNiwyNiw5LDEwMTQsMCwyLDU0LDgsMywxOTcyMywxLDUzMTksNCw0LDUsOSw3LDMsNiwzMSwzLDE0OSwyLDE0MTgsNDksNTEzLDU0LDUsNDksOSwwLDE1LDAsMjMsNCwyLDE0LDEzNjEsNiwyLDE2LDMsNiwyLDEsMiw0LDI2Miw2LDEwLDksNDE5LDEzLDE0OTUsNiwxMTAsNiw2LDksNzkyNDg3LDIzOV07XG5cbi8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbi8vIGFzc3VtcHRpb24gaXMgdGhhdCBsb29raW5nIHVwIGFzdHJhbCBpZGVudGlmaWVyIGNoYXJhY3RlcnMgaXNcbi8vIHJhcmUuXG5mdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICB2YXIgcG9zID0gMHgxMDAwMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxufVxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2Rlcylcbn1cblxuLy8gIyMgVG9rZW4gdHlwZXNcblxuLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbi8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuLy8gdG9rZW4gaW4gYSB3YXkgdGhhdCBpcyB2ZXJ5IGNoZWFwIGZvciB0aGUgcGFyc2VyIHRvIGxvb2sgdXAuXG5cbi8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbi8vIFRoZSBgYmVmb3JlRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiByZWd1bGFyXG4vLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4vLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuLy8gcmVndWxhciBleHByZXNzaW9uKS5cbi8vXG4vLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuLy8gYHlpZWxkYCBleHByZXNzaW9uLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgZWl0aGVyIGNhblxuLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbi8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuLy9cbi8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbi8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbnZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxufVxudmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cbi8vIE1hcCBrZXl3b3JkIG5hbWVzIHRvIHRva2VuIHR5cGVzLlxuXG52YXIga2V5d29yZHMkMSA9IHt9O1xuXG4vLyBTdWNjaW5jdCBkZWZpbml0aW9ucyBvZiBrZXl3b3JkIHRva2VuIHR5cGVzXG5mdW5jdGlvbiBrdyhuYW1lLCBvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIG9wdGlvbnMua2V5d29yZCA9IG5hbWU7XG4gIHJldHVybiBrZXl3b3JkcyQxW25hbWVdID0gbmV3IFRva2VuVHlwZShuYW1lLCBvcHRpb25zKVxufVxuXG52YXIgdHlwZXMgPSB7XG4gIG51bTogbmV3IFRva2VuVHlwZShcIm51bVwiLCBzdGFydHNFeHByKSxcbiAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHN0YXJ0c0V4cHIpLFxuICBzdHJpbmc6IG5ldyBUb2tlblR5cGUoXCJzdHJpbmdcIiwgc3RhcnRzRXhwciksXG4gIG5hbWU6IG5ldyBUb2tlblR5cGUoXCJuYW1lXCIsIHN0YXJ0c0V4cHIpLFxuICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gIGJyYWNrZXRMOiBuZXcgVG9rZW5UeXBlKFwiW1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICBjb21tYTogbmV3IFRva2VuVHlwZShcIixcIiwgYmVmb3JlRXhwciksXG4gIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gIGRvdDogbmV3IFRva2VuVHlwZShcIi5cIiksXG4gIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgYXJyb3c6IG5ldyBUb2tlblR5cGUoXCI9PlwiLCBiZWZvcmVFeHByKSxcbiAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgaW52YWxpZFRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwiaW52YWxpZFRlbXBsYXRlXCIpLFxuICBlbGxpcHNpczogbmV3IFRva2VuVHlwZShcIi4uLlwiLCBiZWZvcmVFeHByKSxcbiAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcblxuICAvLyBPcGVyYXRvcnMuIFRoZXNlIGNhcnJ5IHNldmVyYWwga2luZHMgb2YgcHJvcGVydGllcyB0byBoZWxwIHRoZVxuICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gIC8vIHdoYXQgY2F0ZWdvcml6ZXMgdGhlbSBhcyBvcGVyYXRvcnMpLlxuICAvL1xuICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgLy8gb3BlcmF0b3IsIGFuZCB3aWxsIHJlZmVyIHRvIGl0cyBwcmVjZWRlbmNlLlxuICAvL1xuICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgLy8gdW5hcnkgb3BlcmF0b3IuXG4gIC8vXG4gIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gIC8vIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCBhIHZlcnkgbG93IHByZWNlZGVuY2UsIHRoYXQgc2hvdWxkIHJlc3VsdFxuICAvLyBpbiBBc3NpZ25tZW50RXhwcmVzc2lvbiBub2Rlcy5cblxuICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICBpbmNEZWM6IG5ldyBUb2tlblR5cGUoXCIrKy8tLVwiLCB7cHJlZml4OiB0cnVlLCBwb3N0Zml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIHByZWZpeDogbmV3IFRva2VuVHlwZShcIiEvflwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGxvZ2ljYWxPUjogYmlub3AoXCJ8fFwiLCAxKSxcbiAgbG9naWNhbEFORDogYmlub3AoXCImJlwiLCAyKSxcbiAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gIGJpdHdpc2VYT1I6IGJpbm9wKFwiXlwiLCA0KSxcbiAgYml0d2lzZUFORDogYmlub3AoXCImXCIsIDUpLFxuICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPS89PT0vIT09XCIsIDYpLFxuICByZWxhdGlvbmFsOiBiaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgYml0U2hpZnQ6IGJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIG1vZHVsbzogYmlub3AoXCIlXCIsIDEwKSxcbiAgc3RhcjogYmlub3AoXCIqXCIsIDEwKSxcbiAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gIHN0YXJzdGFyOiBuZXcgVG9rZW5UeXBlKFwiKipcIiwge2JlZm9yZUV4cHI6IHRydWV9KSxcblxuICAvLyBLZXl3b3JkIHRva2VuIHR5cGVzLlxuICBfYnJlYWs6IGt3KFwiYnJlYWtcIiksXG4gIF9jYXNlOiBrdyhcImNhc2VcIiwgYmVmb3JlRXhwciksXG4gIF9jYXRjaDoga3coXCJjYXRjaFwiKSxcbiAgX2NvbnRpbnVlOiBrdyhcImNvbnRpbnVlXCIpLFxuICBfZGVidWdnZXI6IGt3KFwiZGVidWdnZXJcIiksXG4gIF9kZWZhdWx0OiBrdyhcImRlZmF1bHRcIiwgYmVmb3JlRXhwciksXG4gIF9kbzoga3coXCJkb1wiLCB7aXNMb29wOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSksXG4gIF9lbHNlOiBrdyhcImVsc2VcIiwgYmVmb3JlRXhwciksXG4gIF9maW5hbGx5OiBrdyhcImZpbmFsbHlcIiksXG4gIF9mb3I6IGt3KFwiZm9yXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgX2Z1bmN0aW9uOiBrdyhcImZ1bmN0aW9uXCIsIHN0YXJ0c0V4cHIpLFxuICBfaWY6IGt3KFwiaWZcIiksXG4gIF9yZXR1cm46IGt3KFwicmV0dXJuXCIsIGJlZm9yZUV4cHIpLFxuICBfc3dpdGNoOiBrdyhcInN3aXRjaFwiKSxcbiAgX3Rocm93OiBrdyhcInRocm93XCIsIGJlZm9yZUV4cHIpLFxuICBfdHJ5OiBrdyhcInRyeVwiKSxcbiAgX3Zhcjoga3coXCJ2YXJcIiksXG4gIF9jb25zdDoga3coXCJjb25zdFwiKSxcbiAgX3doaWxlOiBrdyhcIndoaWxlXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgX3dpdGg6IGt3KFwid2l0aFwiKSxcbiAgX25ldzoga3coXCJuZXdcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgX3RoaXM6IGt3KFwidGhpc1wiLCBzdGFydHNFeHByKSxcbiAgX3N1cGVyOiBrdyhcInN1cGVyXCIsIHN0YXJ0c0V4cHIpLFxuICBfY2xhc3M6IGt3KFwiY2xhc3NcIiwgc3RhcnRzRXhwciksXG4gIF9leHRlbmRzOiBrdyhcImV4dGVuZHNcIiwgYmVmb3JlRXhwciksXG4gIF9leHBvcnQ6IGt3KFwiZXhwb3J0XCIpLFxuICBfaW1wb3J0OiBrdyhcImltcG9ydFwiLCBzdGFydHNFeHByKSxcbiAgX251bGw6IGt3KFwibnVsbFwiLCBzdGFydHNFeHByKSxcbiAgX3RydWU6IGt3KFwidHJ1ZVwiLCBzdGFydHNFeHByKSxcbiAgX2ZhbHNlOiBrdyhcImZhbHNlXCIsIHN0YXJ0c0V4cHIpLFxuICBfaW46IGt3KFwiaW5cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gIF9pbnN0YW5jZW9mOiBrdyhcImluc3RhbmNlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gIF90eXBlb2Y6IGt3KFwidHlwZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgX3ZvaWQ6IGt3KFwidm9pZFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF9kZWxldGU6IGt3KFwiZGVsZXRlXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KVxufTtcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbnZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5LztcbnZhciBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIGlzTmV3TGluZShjb2RlLCBlY21hMjAxOVN0cmluZykge1xuICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgKCFlY21hMjAxOVN0cmluZyAmJiAoY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT09IDB4MjAyOSkpXG59XG5cbnZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbnZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nO1xuXG52YXIgcmVmID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHJlZi5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IHJlZi50b1N0cmluZztcblxuLy8gQ2hlY2tzIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS5cblxuZnVuY3Rpb24gaGFzKG9iaiwgcHJvcE5hbWUpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4pOyB9KTtcblxuZnVuY3Rpb24gd29yZHNSZWdleHAod29yZHMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB3b3Jkcy5yZXBsYWNlKC8gL2csIFwifFwiKSArIFwiKSRcIilcbn1cblxuLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4vLyBgc3RhcnRMb2NgIGFuZCBgZW5kTG9jYCBwcm9wZXJ0aWVzLlxuXG52YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgdGhpcy5saW5lID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gPSBjb2w7XG59O1xuXG5Qb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0IChuKSB7XG4gIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lLCB0aGlzLmNvbHVtbiArIG4pXG59O1xuXG52YXIgU291cmNlTG9jYXRpb24gPSBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihwLCBzdGFydCwgZW5kKSB7XG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgdGhpcy5lbmQgPSBlbmQ7XG4gIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHsgdGhpcy5zb3VyY2UgPSBwLnNvdXJjZUZpbGU7IH1cbn07XG5cbi8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbi8vIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvZmYgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSBhbmQgeW91XG4vLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuLy8gaW50by5cblxuZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBjdXI7XG4gICAgdmFyIG1hdGNoID0gbGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICsrbGluZTtcbiAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cilcbiAgICB9XG4gIH1cbn1cblxuLy8gQSBzZWNvbmQgb3B0aW9uYWwgYXJndW1lbnQgY2FuIGJlIGdpdmVuIHRvIGZ1cnRoZXIgY29uZmlndXJlXG4vLyB0aGUgcGFyc2VyIHByb2Nlc3MuIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQ6XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdCBiZVxuICAvLyBlaXRoZXIgMywgNSwgNiAoMjAxNSksIDcgKDIwMTYpLCA4ICgyMDE3KSwgOSAoMjAxOCksIG9yIDEwXG4gIC8vICgyMDE5KS4gVGhpcyBpbmZsdWVuY2VzIHN1cHBvcnQgZm9yIHN0cmljdCBtb2RlLCB0aGUgc2V0IG9mXG4gIC8vIHJlc2VydmVkIHdvcmRzLCBhbmQgc3VwcG9ydCBmb3IgbmV3IHN5bnRheCBmZWF0dXJlcy4gVGhlIGRlZmF1bHRcbiAgLy8gaXMgOS5cbiAgZWNtYVZlcnNpb246IDksXG4gIC8vIGBzb3VyY2VUeXBlYCBpbmRpY2F0ZXMgdGhlIG1vZGUgdGhlIGNvZGUgc2hvdWxkIGJlIHBhcnNlZCBpbi5cbiAgLy8gQ2FuIGJlIGVpdGhlciBgXCJzY3JpcHRcImAgb3IgYFwibW9kdWxlXCJgLiBUaGlzIGluZmx1ZW5jZXMgZ2xvYmFsXG4gIC8vIHN0cmljdCBtb2RlIGFuZCBwYXJzaW5nIG9mIGBpbXBvcnRgIGFuZCBgZXhwb3J0YCBkZWNsYXJhdGlvbnMuXG4gIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gIC8vIGBvbkluc2VydGVkU2VtaWNvbG9uYCBjYW4gYmUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gIC8vIHdoZW4gYSBzZW1pY29sb24gaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZC4gSXQgd2lsbCBiZSBwYXNzZWRcbiAgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBjb21tYSBhcyBhbiBvZmZzZXQsIGFuZCBpZiBgbG9jYXRpb25zYCBpc1xuICAvLyBlbmFibGVkLCBpdCBpcyBnaXZlbiB0aGUgbG9jYXRpb24gYXMgYSBge2xpbmUsIGNvbHVtbn1gIG9iamVjdFxuICAvLyBhcyBzZWNvbmQgYXJndW1lbnQuXG4gIG9uSW5zZXJ0ZWRTZW1pY29sb246IG51bGwsXG4gIC8vIGBvblRyYWlsaW5nQ29tbWFgIGlzIHNpbWlsYXIgdG8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gLCBidXQgZm9yXG4gIC8vIHRyYWlsaW5nIGNvbW1hcy5cbiAgb25UcmFpbGluZ0NvbW1hOiBudWxsLFxuICAvLyBCeSBkZWZhdWx0LCByZXNlcnZlZCB3b3JkcyBhcmUgb25seSBlbmZvcmNlZCBpZiBlY21hVmVyc2lvbiA+PSA1LlxuICAvLyBTZXQgYGFsbG93UmVzZXJ2ZWRgIHRvIGEgYm9vbGVhbiB2YWx1ZSB0byBleHBsaWNpdGx5IHR1cm4gdGhpcyBvblxuICAvLyBhbiBvZmYuIFdoZW4gdGhpcyBvcHRpb24gaGFzIHRoZSB2YWx1ZSBcIm5ldmVyXCIsIHJlc2VydmVkIHdvcmRzXG4gIC8vIGFuZCBrZXl3b3JkcyBjYW4gYWxzbyBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eSBuYW1lcy5cbiAgYWxsb3dSZXNlcnZlZDogbnVsbCxcbiAgLy8gV2hlbiBlbmFibGVkLCBhIHJldHVybiBhdCB0aGUgdG9wIGxldmVsIGlzIG5vdCBjb25zaWRlcmVkIGFuXG4gIC8vIGVycm9yLlxuICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gZW5hYmxlZCwgaW1wb3J0L2V4cG9ydCBzdGF0ZW1lbnRzIGFyZSBub3QgY29uc3RyYWluZWQgdG9cbiAgLy8gYXBwZWFyaW5nIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW0uXG4gIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gIC8vIFdoZW4gZW5hYmxlZCwgYXdhaXQgaWRlbnRpZmllcnMgYXJlIGFsbG93ZWQgdG8gYXBwZWFyIGF0IHRoZSB0b3AtbGV2ZWwgc2NvcGUsXG4gIC8vIGJ1dCB0aGV5IGFyZSBzdGlsbCBub3QgYWxsb3dlZCBpbiBub24tYXN5bmMgZnVuY3Rpb25zLlxuICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBoYXNoYmFuZyBkaXJlY3RpdmUgaW4gdGhlIGJlZ2lubmluZyBvZiBmaWxlXG4gIC8vIGlzIGFsbG93ZWQgYW5kIHRyZWF0ZWQgYXMgYSBsaW5lIGNvbW1lbnQuXG4gIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gIC8vIG5vZGVzLlxuICBsb2NhdGlvbnM6IGZhbHNlLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gIC8vIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvblRva2VuOiBudWxsLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgb25Db21tZW50OiBudWxsLFxuICAvLyBOb2RlcyBoYXZlIHRoZWlyIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVycyBvZmZzZXRzIHJlY29yZGVkIGluXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgKGRpcmVjdGx5IG9uIHRoZSBub2RlLCByYXRoZXIgdGhhblxuICAvLyB0aGUgYGxvY2Agb2JqZWN0LCB3aGljaCBob2xkcyBsaW5lL2NvbHVtbiBkYXRhLiBUbyBhbHNvIGFkZCBhXG4gIC8vIFtzZW1pLXN0YW5kYXJkaXplZF1bcmFuZ2VdIGByYW5nZWAgcHJvcGVydHkgaG9sZGluZyBhIGBbc3RhcnQsXG4gIC8vIGVuZF1gIGFycmF5IHdpdGggdGhlIHNhbWUgbnVtYmVycywgc2V0IHRoZSBgcmFuZ2VzYCBvcHRpb24gdG9cbiAgLy8gYHRydWVgLlxuICAvL1xuICAvLyBbcmFuZ2VdOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDU2NzhcbiAgcmFuZ2VzOiBmYWxzZSxcbiAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGFyc2UgbXVsdGlwbGUgZmlsZXMgaW50byBhIHNpbmdsZSBBU1QgYnlcbiAgLy8gcGFzc2luZyB0aGUgdHJlZSBwcm9kdWNlZCBieSBwYXJzaW5nIHRoZSBmaXJzdCBmaWxlIGFzXG4gIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gIC8vIHRvcGxldmVsIGZvcm1zIG9mIHRoZSBwYXJzZWQgZmlsZSB0byB0aGUgYFByb2dyYW1gICh0b3ApIG5vZGVcbiAgLy8gb2YgYW4gZXhpc3RpbmcgcGFyc2UgdHJlZS5cbiAgcHJvZ3JhbTogbnVsbCxcbiAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgeW91IGNhbiBwYXNzIHRoaXMgdG8gcmVjb3JkIHRoZSBzb3VyY2VcbiAgLy8gZmlsZSBpbiBldmVyeSBub2RlJ3MgYGxvY2Agb2JqZWN0LlxuICBzb3VyY2VGaWxlOiBudWxsLFxuICAvLyBUaGlzIHZhbHVlLCBpZiBnaXZlbiwgaXMgc3RvcmVkIGluIGV2ZXJ5IG5vZGUsIHdoZXRoZXJcbiAgLy8gYGxvY2F0aW9uc2AgaXMgb24gb3Igb2ZmLlxuICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbnMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gIC8vIChub24tc3RhbmRhcmQpIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIG5vZGVzXG4gIHByZXNlcnZlUGFyZW5zOiBmYWxzZVxufTtcblxuLy8gSW50ZXJwcmV0IGFuZCBkZWZhdWx0IGFuIG9wdGlvbnMgb2JqZWN0XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIGZvciAodmFyIG9wdCBpbiBkZWZhdWx0T3B0aW9ucylcbiAgICB7IG9wdGlvbnNbb3B0XSA9IG9wdHMgJiYgaGFzKG9wdHMsIG9wdCkgPyBvcHRzW29wdF0gOiBkZWZhdWx0T3B0aW9uc1tvcHRdOyB9XG5cbiAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMjAxNSlcbiAgICB7IG9wdGlvbnMuZWNtYVZlcnNpb24gLT0gMjAwOTsgfVxuXG4gIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gbnVsbClcbiAgICB7IG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPCA1OyB9XG5cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gIH1cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICB2YWx1ZTogdGV4dCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgfVxufVxuXG4vLyBFYWNoIHNjb3BlIGdldHMgYSBiaXRzZXQgdGhhdCBtYXkgY29udGFpbiB0aGVzZSBmbGFnc1xudmFyXG4gICAgU0NPUEVfVE9QID0gMSxcbiAgICBTQ09QRV9GVU5DVElPTiA9IDIsXG4gICAgU0NPUEVfVkFSID0gU0NPUEVfVE9QIHwgU0NPUEVfRlVOQ1RJT04sXG4gICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgIFNDT1BFX0dFTkVSQVRPUiA9IDgsXG4gICAgU0NPUEVfQVJST1cgPSAxNixcbiAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICBTQ09QRV9TVVBFUiA9IDY0LFxuICAgIFNDT1BFX0RJUkVDVF9TVVBFUiA9IDEyODtcblxuZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhhc3luYywgZ2VuZXJhdG9yKSB7XG4gIHJldHVybiBTQ09QRV9GVU5DVElPTiB8IChhc3luYyA/IFNDT1BFX0FTWU5DIDogMCkgfCAoZ2VuZXJhdG9yID8gU0NPUEVfR0VORVJBVE9SIDogMClcbn1cblxuLy8gVXNlZCBpbiBjaGVja0xWYWwgYW5kIGRlY2xhcmVOYW1lIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBhIGJpbmRpbmdcbnZhclxuICAgIEJJTkRfTk9ORSA9IDAsIC8vIE5vdCBhIGJpbmRpbmdcbiAgICBCSU5EX1ZBUiA9IDEsIC8vIFZhci1zdHlsZSBiaW5kaW5nXG4gICAgQklORF9MRVhJQ0FMID0gMiwgLy8gTGV0LSBvciBjb25zdC1zdHlsZSBiaW5kaW5nXG4gICAgQklORF9GVU5DVElPTiA9IDMsIC8vIEZ1bmN0aW9uIGRlY2xhcmF0aW9uXG4gICAgQklORF9TSU1QTEVfQ0FUQ0ggPSA0LCAvLyBTaW1wbGUgKGlkZW50aWZpZXIgcGF0dGVybikgY2F0Y2ggYmluZGluZ1xuICAgIEJJTkRfT1VUU0lERSA9IDU7IC8vIFNwZWNpYWwgY2FzZSBmb3IgZnVuY3Rpb24gbmFtZXMgYXMgYm91bmQgaW5zaWRlIHRoZSBmdW5jdGlvblxuXG52YXIgUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMsIGlucHV0LCBzdGFydFBvcykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgdGhpcy5zb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlO1xuICB0aGlzLmtleXdvcmRzID0gd29yZHNSZWdleHAoa2V5d29yZHNbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIiA/IFwiNW1vZHVsZVwiIDogNV0pO1xuICB2YXIgcmVzZXJ2ZWQgPSBcIlwiO1xuICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSB0cnVlKSB7XG4gICAgZm9yICh2YXIgdiA9IG9wdGlvbnMuZWNtYVZlcnNpb247OyB2LS0pXG4gICAgICB7IGlmIChyZXNlcnZlZCA9IHJlc2VydmVkV29yZHNbdl0pIHsgYnJlYWsgfSB9XG4gICAgaWYgKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIikgeyByZXNlcnZlZCArPSBcIiBhd2FpdFwiOyB9XG4gIH1cbiAgdGhpcy5yZXNlcnZlZFdvcmRzID0gd29yZHNSZWdleHAocmVzZXJ2ZWQpO1xuICB2YXIgcmVzZXJ2ZWRTdHJpY3QgPSAocmVzZXJ2ZWQgPyByZXNlcnZlZCArIFwiIFwiIDogXCJcIikgKyByZXNlcnZlZFdvcmRzLnN0cmljdDtcbiAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0ID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QpO1xuICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QgKyBcIiBcIiArIHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG4gIHRoaXMuaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuXG4gIC8vIFVzZWQgdG8gc2lnbmFsIHRvIGNhbGxlcnMgb2YgYHJlYWRXb3JkMWAgd2hldGhlciB0aGUgd29yZFxuICAvLyBjb250YWluZWQgYW55IGVzY2FwZSBzZXF1ZW5jZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugd29yZHMgd2l0aFxuICAvLyBlc2NhcGUgc2VxdWVuY2VzIG11c3Qgbm90IGJlIGludGVycHJldGVkIGFzIGtleXdvcmRzLlxuICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG5cbiAgLy8gU2V0IHVwIHRva2VuIHN0YXRlXG5cbiAgLy8gVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHRva2VuaXplciBpbiB0aGUgaW5wdXQuXG4gIGlmIChzdGFydFBvcykge1xuICAgIHRoaXMucG9zID0gc3RhcnRQb3M7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHN0YXJ0UG9zIC0gMSkgKyAxO1xuICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaW5wdXQuc2xpY2UoMCwgdGhpcy5saW5lU3RhcnQpLnNwbGl0KGxpbmVCcmVhaykubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucG9zID0gdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgIHRoaXMuY3VyTGluZSA9IDE7XG4gIH1cblxuICAvLyBQcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRva2VuOlxuICAvLyBJdHMgdHlwZVxuICB0aGlzLnR5cGUgPSB0eXBlcy5lb2Y7XG4gIC8vIEZvciB0b2tlbnMgdGhhdCBpbmNsdWRlIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGVpciB0eXBlLCB0aGUgdmFsdWVcbiAgdGhpcy52YWx1ZSA9IG51bGw7XG4gIC8vIEl0cyBzdGFydCBhbmQgZW5kIG9mZnNldFxuICB0aGlzLnN0YXJ0ID0gdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgLy8gQW5kLCBpZiBsb2NhdGlvbnMgYXJlIHVzZWQsIHRoZSB7bGluZSwgY29sdW1ufSBvYmplY3RcbiAgLy8gY29ycmVzcG9uZGluZyB0byB0aG9zZSBvZmZzZXRzXG4gIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAvLyBQb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIHByZXZpb3VzIHRva2VuXG4gIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLnBvcztcblxuICAvLyBUaGUgY29udGV4dCBzdGFjayBpcyB1c2VkIHRvIHN1cGVyZmljaWFsbHkgdHJhY2sgc3ludGFjdGljXG4gIC8vIGNvbnRleHQgdG8gcHJlZGljdCB3aGV0aGVyIGEgcmVndWxhciBleHByZXNzaW9uIGlzIGFsbG93ZWQgaW4gYVxuICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0aWFsQ29udGV4dCgpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcblxuICAvLyBGaWd1cmUgb3V0IGlmIGl0J3MgYSBtb2R1bGUgY29kZS5cbiAgdGhpcy5pbk1vZHVsZSA9IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgdGhpcy5zdHJpY3QgPSB0aGlzLmluTW9kdWxlIHx8IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMucG9zKTtcblxuICAvLyBVc2VkIHRvIHNpZ25pZnkgdGhlIHN0YXJ0IG9mIGEgcG90ZW50aWFsIGFycm93IGZ1bmN0aW9uXG4gIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuXG4gIC8vIFBvc2l0aW9ucyB0byBkZWxheWVkLWNoZWNrIHRoYXQgeWllbGQvYXdhaXQgZG9lcyBub3QgZXhpc3QgaW4gZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICB0aGlzLnlpZWxkUG9zID0gdGhpcy5hd2FpdFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gIC8vIExhYmVscyBpbiBzY29wZS5cbiAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgLy8gVGh1cy1mYXIgdW5kZWZpbmVkIGV4cG9ydHMuXG4gIHRoaXMudW5kZWZpbmVkRXhwb3J0cyA9IHt9O1xuXG4gIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICB7IHRoaXMuc2tpcExpbmVDb21tZW50KDIpOyB9XG5cbiAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgdGhpcy5lbnRlclNjb3BlKFNDT1BFX1RPUCk7XG5cbiAgLy8gRm9yIFJlZ0V4cCB2YWxpZGF0aW9uXG4gIHRoaXMucmVnZXhwU3RhdGUgPSBudWxsO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgaW5GdW5jdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkdlbmVyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkFzeW5jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dEaXJlY3RTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cmVhdEZ1bmN0aW9uc0FzVmFyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5vcHRpb25zLnByb2dyYW0gfHwgdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbChub2RlKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmluRnVuY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5wcm90b3R5cGVBY2Nlc3NvcnMuaW5HZW5lcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9HRU5FUkFUT1IpID4gMCB9O1xucHJvdG90eXBlQWNjZXNzb3JzLmluQXN5bmMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9BU1lOQykgPiAwIH07XG5wcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9TVVBFUikgPiAwIH07XG5wcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dEaXJlY3RTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9ESVJFQ1RfU1VQRVIpID4gMCB9O1xucHJvdG90eXBlQWNjZXNzb3JzLnRyZWF0RnVuY3Rpb25zQXNWYXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKSB9O1xuXG4vLyBTd2l0Y2ggdG8gYSBnZXR0ZXIgZm9yIDcuMC4wLlxuUGFyc2VyLnByb3RvdHlwZS5pbk5vbkFycm93RnVuY3Rpb24gPSBmdW5jdGlvbiBpbk5vbkFycm93RnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xuXG5QYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICgpIHtcbiAgICB2YXIgcGx1Z2lucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBwbHVnaW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgdmFyIGNscyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykgeyBjbHMgPSBwbHVnaW5zW2ldKGNscyk7IH1cbiAgcmV0dXJuIGNsc1xufTtcblxuUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCkucGFyc2UoKVxufTtcblxuUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0ID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQgKGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICBwYXJzZXIubmV4dFRva2VuKCk7XG4gIHJldHVybiBwYXJzZXIucGFyc2VFeHByZXNzaW9uKClcbn07XG5cblBhcnNlci50b2tlbml6ZXIgPSBmdW5jdGlvbiB0b2tlbml6ZXIgKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dClcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQYXJzZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMgUGFyc2VyIHV0aWxpdGllc1xuXG52YXIgbGl0ZXJhbCA9IC9eKD86JygoPzpcXFxcLnxbXiddKSo/KSd8XCIoKD86XFxcXC58W15cIl0pKj8pXCIpLztcbnBwLnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gIGZvciAoOzspIHtcbiAgICAvLyBUcnkgdG8gZmluZCBzdHJpbmcgbGl0ZXJhbC5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2ggPSBsaXRlcmFsLmV4ZWModGhpcy5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHsgcmV0dXJuIHRydWUgfVxuICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcblxuICAgIC8vIFNraXAgc2VtaWNvbG9uLCBpZiBhbnkuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgaWYgKHRoaXMuaW5wdXRbc3RhcnRdID09PSBcIjtcIilcbiAgICAgIHsgc3RhcnQrKzsgfVxuICB9XG59O1xuXG4vLyBQcmVkaWNhdGUgdGhhdCB0ZXN0cyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlblxuLy8gdHlwZSwgYW5kIGlmIHllcywgY29uc3VtZXMgaXQgYXMgYSBzaWRlIGVmZmVjdC5cblxucHAuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSAmJiB0aGlzLnZhbHVlID09PSBuYW1lICYmICF0aGlzLmNvbnRhaW5zRXNjXG59O1xuXG4vLyBDb25zdW1lcyBjb250ZXh0dWFsIGtleXdvcmQgaWYgcG9zc2libGUuXG5cbnBwLmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5pc0NvbnRleHR1YWwobmFtZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxucHAuZXhwZWN0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwobmFtZSkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbi8vIFRlc3Qgd2hldGhlciBhIHNlbWljb2xvbiBjYW4gYmUgaW5zZXJ0ZWQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG5cbnBwLmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5lb2YgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNlUiB8fFxuICAgIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbn07XG5cbnBwLmluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbilcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24odGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcblxuLy8gQ29uc3VtZSBhIHNlbWljb2xvbiwgb3IsIGZhaWxpbmcgdGhhdCwgc2VlIGlmIHdlIGFyZSBhbGxvd2VkIHRvXG4vLyBwcmV0ZW5kIHRoYXQgdGhlcmUgaXMgYSBzZW1pY29sb24gYXQgdGhpcyBwb3NpdGlvbi5cblxucHAuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5lYXQodHlwZXMuc2VtaSkgJiYgIXRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbnBwLmFmdGVyVHJhaWxpbmdDb21tYSA9IGZ1bmN0aW9uKHRva1R5cGUsIG5vdE5leHQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdG9rVHlwZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7IH1cbiAgICBpZiAoIW5vdE5leHQpXG4gICAgICB7IHRoaXMubmV4dCgpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcblxuLy8gRXhwZWN0IGEgdG9rZW4gb2YgYSBnaXZlbiB0eXBlLiBJZiBmb3VuZCwgY29uc3VtZSBpdCwgb3RoZXJ3aXNlLFxuLy8gcmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxucHAuZXhwZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQoKTtcbn07XG5cbi8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbihwb3MpIHtcbiAgdGhpcy5yYWlzZShwb3MgIT0gbnVsbCA/IHBvcyA6IHRoaXMuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbn07XG5cbmZ1bmN0aW9uIERlc3RydWN0dXJpbmdFcnJvcnMoKSB7XG4gIHRoaXMuc2hvcnRoYW5kQXNzaWduID1cbiAgdGhpcy50cmFpbGluZ0NvbW1hID1cbiAgdGhpcy5wYXJlbnRoZXNpemVkQXNzaWduID1cbiAgdGhpcy5wYXJlbnRoZXNpemVkQmluZCA9XG4gIHRoaXMuZG91YmxlUHJvdG8gPVxuICAgIC0xO1xufVxuXG5wcC5jaGVja1BhdHRlcm5FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBpc0Fzc2lnbikge1xuICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIH1cbiAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+IC0xKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgdmFyIHBhcmVucyA9IGlzQXNzaWduID8gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDogcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZDtcbiAgaWYgKHBhcmVucyA+IC0xKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwYXJlbnMsIFwiUGFyZW50aGVzaXplZCBwYXR0ZXJuXCIpOyB9XG59O1xuXG5wcC5jaGVja0V4cHJlc3Npb25FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhbmRUaHJvdykge1xuICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIHNob3J0aGFuZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduO1xuICB2YXIgZG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICBpZiAoIWFuZFRocm93KSB7IHJldHVybiBzaG9ydGhhbmRBc3NpZ24gPj0gMCB8fCBkb3VibGVQcm90byA+PSAwIH1cbiAgaWYgKHNob3J0aGFuZEFzc2lnbiA+PSAwKVxuICAgIHsgdGhpcy5yYWlzZShzaG9ydGhhbmRBc3NpZ24sIFwiU2hvcnRoYW5kIHByb3BlcnR5IGFzc2lnbm1lbnRzIGFyZSB2YWxpZCBvbmx5IGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnNcIik7IH1cbiAgaWYgKGRvdWJsZVByb3RvID49IDApXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZG91YmxlUHJvdG8sIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxufTtcblxucHAuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnlpZWxkUG9zICYmICghdGhpcy5hd2FpdFBvcyB8fCB0aGlzLnlpZWxkUG9zIDwgdGhpcy5hd2FpdFBvcykpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMueWllbGRQb3MsIFwiWWllbGQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gIGlmICh0aGlzLmF3YWl0UG9zKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0UG9zLCBcIkF3YWl0IGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxufTtcblxucHAuaXNTaW1wbGVBc3NpZ25UYXJnZXQgPSBmdW5jdGlvbihleHByKSB7XG4gIGlmIChleHByLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICB7IHJldHVybiB0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIuZXhwcmVzc2lvbikgfVxuICByZXR1cm4gZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fCBleHByLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiXG59O1xuXG52YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vICMjIyBTdGF0ZW1lbnQgcGFyc2luZ1xuXG4vLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2Zcbi8vIHN0YXRlbWVudHMsIGFuZCB3cmFwcyB0aGVtIGluIGEgUHJvZ3JhbSBub2RlLiAgT3B0aW9uYWxseSB0YWtlcyBhXG4vLyBgcHJvZ3JhbWAgYXJndW1lbnQuICBJZiBwcmVzZW50LCB0aGUgc3RhdGVtZW50cyB3aWxsIGJlIGFwcGVuZGVkXG4vLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbnBwJDEucGFyc2VUb3BMZXZlbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgaWYgKCFub2RlLmJvZHkpIHsgbm9kZS5ib2R5ID0gW107IH1cbiAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMuZW9mKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwsIHRydWUsIGV4cG9ydHMpO1xuICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICB9XG4gIGlmICh0aGlzLmluTW9kdWxlKVxuICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh0aGlzLnVuZGVmaW5lZEV4cG9ydHMpOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV0uc3RhcnQsIChcIkV4cG9ydCAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgIH0gfVxuICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5KTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxufTtcblxudmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn0sIHN3aXRjaExhYmVsID0ge2tpbmQ6IFwic3dpdGNoXCJ9O1xuXG5wcCQxLmlzTGV0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gIC8vIEZvciBhbWJpZ3VvdXMgY2FzZXMsIGRldGVybWluZSBpZiBhIExleGljYWxEZWNsYXJhdGlvbiAob3Igb25seSBhXG4gIC8vIFN0YXRlbWVudCkgaXMgYWxsb3dlZCBoZXJlLiBJZiBjb250ZXh0IGlzIG5vdCBlbXB0eSB0aGVuIG9ubHkgYSBTdGF0ZW1lbnRcbiAgLy8gaXMgYWxsb3dlZC4gSG93ZXZlciwgYGxldCBbYCBpcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSBsb29rYWhlYWQgZm9yXG4gIC8vIEV4cHJlc3Npb25TdGF0ZW1lbnQsIHNvIHNwZWNpYWwtY2FzZSBpdCBmaXJzdC5cbiAgaWYgKG5leHRDaCA9PT0gOTEpIHsgcmV0dXJuIHRydWUgfSAvLyAnWydcbiAgaWYgKGNvbnRleHQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBpZiAobmV4dENoID09PSAxMjMpIHsgcmV0dXJuIHRydWUgfSAvLyAneydcbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KG5leHRDaCwgdHJ1ZSkpIHtcbiAgICB2YXIgcG9zID0gbmV4dCArIDE7XG4gICAgd2hpbGUgKGlzSWRlbnRpZmllckNoYXIodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyksIHRydWUpKSB7ICsrcG9zOyB9XG4gICAgdmFyIGlkZW50ID0gdGhpcy5pbnB1dC5zbGljZShuZXh0LCBwb3MpO1xuICAgIGlmICgha2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci50ZXN0KGlkZW50KSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBjaGVjayAnYXN5bmMgW25vIExpbmVUZXJtaW5hdG9yIGhlcmVdIGZ1bmN0aW9uJ1xuLy8gLSAnYXN5bmMgLypmb28qLyBmdW5jdGlvbicgaXMgT0suXG4vLyAtICdhc3luYyAvKlxcbiovIGZ1bmN0aW9uJyBpcyBpbnZhbGlkLlxucHAkMS5pc0FzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwiYXN5bmNcIikpXG4gICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aDtcbiAgcmV0dXJuICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCBuZXh0KSkgJiZcbiAgICB0aGlzLmlucHV0LnNsaWNlKG5leHQsIG5leHQgKyA4KSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fCAhaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJBdChuZXh0ICsgOCkpKVxufTtcblxuLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuLy9cbi8vIElmIGV4cGVjdGluZyBhIHN0YXRlbWVudCBhbmQgZmluZGluZyBhIHNsYXNoIG9wZXJhdG9yLCBwYXJzZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuLy8gYGlmIChmb28pIC9ibGFoLy5leGVjKGZvbylgLCB3aGVyZSBsb29raW5nIGF0IHRoZSBwcmV2aW91cyB0b2tlblxuLy8gZG9lcyBub3QgaGVscC5cblxucHAkMS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGNvbnRleHQsIHRvcExldmVsLCBleHBvcnRzKSB7XG4gIHZhciBzdGFydHR5cGUgPSB0aGlzLnR5cGUsIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kO1xuXG4gIGlmICh0aGlzLmlzTGV0KGNvbnRleHQpKSB7XG4gICAgc3RhcnR0eXBlID0gdHlwZXMuX3ZhcjtcbiAgICBraW5kID0gXCJsZXRcIjtcbiAgfVxuXG4gIC8vIE1vc3QgdHlwZXMgb2Ygc3RhdGVtZW50cyBhcmUgcmVjb2duaXplZCBieSB0aGUga2V5d29yZCB0aGV5XG4gIC8vIHN0YXJ0IHdpdGguIE1hbnkgYXJlIHRyaXZpYWwgdG8gcGFyc2UsIHNvbWUgcmVxdWlyZSBhIGJpdCBvZlxuICAvLyBjb21wbGV4aXR5LlxuXG4gIHN3aXRjaCAoc3RhcnR0eXBlKSB7XG4gIGNhc2UgdHlwZXMuX2JyZWFrOiBjYXNlIHR5cGVzLl9jb250aW51ZTogcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZS5rZXl3b3JkKVxuICBjYXNlIHR5cGVzLl9kZWJ1Z2dlcjogcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9kbzogcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9mb3I6IHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgIC8vIEZ1bmN0aW9uIGFzIHNvbGUgYm9keSBvZiBlaXRoZXIgYW4gaWYgc3RhdGVtZW50IG9yIGEgbGFiZWxlZCBzdGF0ZW1lbnRcbiAgICAvLyB3b3JrcywgYnV0IG5vdCB3aGVuIGl0IGlzIHBhcnQgb2YgYSBsYWJlbGVkIHN0YXRlbWVudCB0aGF0IGlzIHRoZSBzb2xlXG4gICAgLy8gYm9keSBvZiBhbiBpZiBzdGF0ZW1lbnQuXG4gICAgaWYgKChjb250ZXh0ICYmICh0aGlzLnN0cmljdCB8fCBjb250ZXh0ICE9PSBcImlmXCIgJiYgY29udGV4dCAhPT0gXCJsYWJlbFwiKSkgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlLCAhY29udGV4dClcbiAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gIGNhc2UgdHlwZXMuX2lmOiByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3JldHVybjogcmV0dXJuIHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl90aHJvdzogcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl90cnk6IHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2NvbnN0OiBjYXNlIHR5cGVzLl92YXI6XG4gICAga2luZCA9IGtpbmQgfHwgdGhpcy52YWx1ZTtcbiAgICBpZiAoY29udGV4dCAmJiBraW5kICE9PSBcInZhclwiKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZClcbiAgY2FzZSB0eXBlcy5fd2hpbGU6IHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fd2l0aDogcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuYnJhY2VMOiByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKHRydWUsIG5vZGUpXG4gIGNhc2UgdHlwZXMuc2VtaTogcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9leHBvcnQ6XG4gIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID4gMTAgJiYgc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0KSB7XG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgaWYgKG5leHRDaCA9PT0gNDApIC8vICcoJ1xuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCB0aGlzLnBhcnNlRXhwcmVzc2lvbigpKSB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgIGlmICghdGhpcy5pbk1vZHVsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgZGVmYXVsdDpcbiAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVOYW1lID0gdGhpcy52YWx1ZSwgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMubmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KHR5cGVzLmNvbG9uKSlcbiAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkgfVxuICAgIGVsc2UgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcikgfVxuICB9XG59O1xuXG5wcCQxLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtleXdvcmQpIHtcbiAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmxhYmVsID0gbnVsbDsgfVxuICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgZWxzZSB7XG4gICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgLy8gY29udGludWUgdG8uXG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsYWIgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIHsgYnJlYWsgfVxuICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIGlmIChpID09PSB0aGlzLmxhYmVscy5sZW5ndGgpIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsga2V5d29yZCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRG9TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJkb1wiKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLl93aGlsZSk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgIHsgdGhpcy5lYXQodHlwZXMuc2VtaSk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKVxufTtcblxuLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuLy8gbG9vcCBpcyBub24tdHJpdmlhbC4gQmFzaWNhbGx5LCB3ZSBoYXZlIHRvIHBhcnNlIHRoZSBpbml0IGB2YXJgXG4vLyBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbiwgZGlzYWxsb3dpbmcgdGhlIGBpbmAgb3BlcmF0b3IgKHNlZVxuLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuLy8gd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBgaW5gIG9yIGBvZmAuIFdoZW4gdGhlcmUgaXMgbm8gaW5pdFxuLy8gcGFydCAoc2VtaWNvbG9uIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzKSwgaXRcbi8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG5wcCQxLnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgKHRoaXMuaW5Bc3luYyB8fCAoIXRoaXMuaW5GdW5jdGlvbiAmJiB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikpICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImF3YWl0XCIpKSA/IHRoaXMubGFzdFRva1N0YXJ0IDogLTE7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgdGhpcy5lbnRlclNjb3BlKDApO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pKSB7XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKVxuICB9XG4gIHZhciBpc0xldCA9IHRoaXMuaXNMZXQoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX3ZhciB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLl9jb25zdCB8fCBpc0xldCkge1xuICAgIHZhciBpbml0JDEgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kID0gaXNMZXQgPyBcImxldFwiIDogdGhpcy52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKGluaXQkMSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgIGlmICgodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSAmJiBpbml0JDEuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbikge1xuICAgICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCQxKVxuICAgIH1cbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQkMSlcbiAgfVxuICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICB2YXIgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4pIHtcbiAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICB9XG4gICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGluaXQpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgfVxuICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KVxufTtcblxucHAkMS5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgaXNBc3luYywgZGVjbGFyYXRpb25Qb3NpdGlvbikge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBGVU5DX1NUQVRFTUVOVCB8IChkZWNsYXJhdGlvblBvc2l0aW9uID8gMCA6IEZVTkNfSEFOR0lOR19TVEFURU1FTlQpLCBmYWxzZSwgaXNBc3luYylcbn07XG5cbnBwJDEucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgLy8gYWxsb3cgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGluIGJyYW5jaGVzLCBidXQgb25seSBpbiBub24tc3RyaWN0IG1vZGVcbiAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpO1xuICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZWF0KHR5cGVzLl9lbHNlKSA/IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKSA6IG51bGw7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKCF0aGlzLmluRnVuY3Rpb24gJiYgIXRoaXMub3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIEluIGByZXR1cm5gIChhbmQgYGJyZWFrYC9gY29udGludWVgKSwgdGhlIGtleXdvcmRzIHdpdGhcbiAgLy8gb3B0aW9uYWwgYXJndW1lbnRzLCB3ZSBlYWdlcmx5IGxvb2sgZm9yIGEgc2VtaWNvbG9uIG9yIHRoZVxuICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IG5vZGUuYXJndW1lbnQgPSBudWxsOyB9XG4gIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgdGhpcy5zZW1pY29sb24oKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5kaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuY2FzZXMgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gIHRoaXMuZW50ZXJTY29wZSgwKTtcblxuICAvLyBTdGF0ZW1lbnRzIHVuZGVyIG11c3QgYmUgZ3JvdXBlZCAoYnkgbGFiZWwpIGluIFN3aXRjaENhc2VcbiAgLy8gbm9kZXMuIGBjdXJgIGlzIHVzZWQgdG8ga2VlcCB0aGUgbm9kZSB0aGF0IHdlIGFyZSBjdXJyZW50bHlcbiAgLy8gYWRkaW5nIHN0YXRlbWVudHMgdG8uXG5cbiAgdmFyIGN1cjtcbiAgZm9yICh2YXIgc2F3RGVmYXVsdCA9IGZhbHNlOyB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUjspIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2FzZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLl9kZWZhdWx0KSB7XG4gICAgICB2YXIgaXNDYXNlID0gdGhpcy50eXBlID09PSB0eXBlcy5fY2FzZTtcbiAgICAgIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzYXdEZWZhdWx0KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIik7IH1cbiAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjdXIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7XG4gICAgfVxuICB9XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG4gIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gIHRoaXMubmV4dCgpOyAvLyBDbG9zaW5nIGJyYWNlXG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSlcbiAgICB7IHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTsgfVxuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG59O1xuXG4vLyBSZXVzZWQgZW1wdHkgYXJyYXkgYWRkZWQgZm9yIG5vZGUgZmllbGRzIHRoYXQgYXJlIGFsd2F5cyBlbXB0eS5cblxudmFyIGVtcHR5ID0gW107XG5cbnBwJDEucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXRjaCkge1xuICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgIHZhciBzaW1wbGUgPSBjbGF1c2UucGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCI7XG4gICAgICB0aGlzLmVudGVyU2NvcGUoc2ltcGxlID8gU0NPUEVfU0lNUExFX0NBVENIIDogMCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChjbGF1c2UucGFyYW0sIHNpbXBsZSA/IEJJTkRfU0lNUExFX0NBVENIIDogQklORF9MRVhJQ0FMKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgY2xhdXNlLnBhcmFtID0gbnVsbDtcbiAgICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICB9XG4gICAgY2xhdXNlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgfVxuICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR5cGVzLl9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKVxuICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVZhclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtpbmQpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxufTtcblxucHAkMS5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aGlsZVwiKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICh0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndpdGhcIik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VMYWJlbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB7XG4gIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgIHtcbiAgICB2YXIgbGFiZWwgPSBsaXN0W2kkMV07XG5cbiAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgeyB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gIH0gfVxuICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICBmb3IgKHZhciBpID0gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFiZWwkMSA9IHRoaXMubGFiZWxzW2ldO1xuICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAvLyBVcGRhdGUgaW5mb3JtYXRpb24gYWJvdXQgcHJldmlvdXMgbGFiZWxzIG9uIHRoaXMgbm9kZVxuICAgICAgbGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgfVxuICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoY29udGV4dCA/IGNvbnRleHQuaW5kZXhPZihcImxhYmVsXCIpID09PSAtMSA/IGNvbnRleHQgKyBcImxhYmVsXCIgOiBjb250ZXh0IDogXCJsYWJlbFwiKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIG5vZGUubGFiZWwgPSBleHByO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHNlbWljb2xvbi1lbmNsb3NlZCBibG9jayBvZiBzdGF0ZW1lbnRzLCBoYW5kbGluZyBgXCJ1c2Vcbi8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4vLyBmdW5jdGlvbiBib2RpZXMpLlxuXG5wcCQxLnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIG5vZGUpIHtcbiAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG4gIGlmICggbm9kZSA9PT0gdm9pZCAwICkgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgbm9kZS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHsgdGhpcy5lbnRlclNjb3BlKDApOyB9XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgfVxuICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZXhpdFNjb3BlKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHJlZ3VsYXIgYGZvcmAgbG9vcC4gVGhlIGRpc2FtYmlndWF0aW9uIGNvZGUgaW5cbi8vIGBwYXJzZVN0YXRlbWVudGAgd2lsbCBhbHJlYWR5IGhhdmUgcGFyc2VkIHRoZSBpbml0IHN0YXRlbWVudCBvclxuLy8gZXhwcmVzc2lvbi5cblxucHAkMS5wYXJzZUZvciA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgbm9kZS5pbml0ID0gaW5pdDtcbiAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgbm9kZS51cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuUiA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICB0aGlzLmV4aXRTY29wZSgpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3Rcbi8vIHNhbWUgZnJvbSBwYXJzZXIncyBwZXJzcGVjdGl2ZS5cblxucHAkMS5wYXJzZUZvckluID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICB2YXIgaXNGb3JJbiA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2luO1xuICB0aGlzLm5leHQoKTtcblxuICBpZiAoXG4gICAgaW5pdC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJlxuICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJlxuICAgIChcbiAgICAgICFpc0ZvckluIHx8XG4gICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8XG4gICAgICB0aGlzLnN0cmljdCB8fFxuICAgICAgaW5pdC5raW5kICE9PSBcInZhclwiIHx8XG4gICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIlxuICAgIClcbiAgKSB7XG4gICAgdGhpcy5yYWlzZShcbiAgICAgIGluaXQuc3RhcnQsXG4gICAgICAoKGlzRm9ySW4gPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIikgKyBcIiBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiKVxuICAgICk7XG4gIH0gZWxzZSBpZiAoaW5pdC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICB0aGlzLnJhaXNlKGluaXQuc3RhcnQsIFwiSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItbG9vcFwiKTtcbiAgfVxuICBub2RlLmxlZnQgPSBpbml0O1xuICBub2RlLnJpZ2h0ID0gaXNGb3JJbiA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNGb3JJbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbnBwJDEucGFyc2VWYXIgPSBmdW5jdGlvbihub2RlLCBpc0Zvciwga2luZCkge1xuICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICBub2RlLmtpbmQgPSBraW5kO1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuZXEpKSB7XG4gICAgICBkZWNsLmluaXQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oaXNGb3IpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJjb25zdFwiICYmICEodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfSBlbHNlIGlmIChkZWNsLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiQ29tcGxleCBiaW5kaW5nIHBhdHRlcm5zIHJlcXVpcmUgYW4gaW5pdGlhbGl6YXRpb24gdmFsdWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnBwJDEucGFyc2VWYXJJZCA9IGZ1bmN0aW9uKGRlY2wsIGtpbmQpIHtcbiAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB0aGlzLmNoZWNrTFZhbChkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbn07XG5cbnZhciBGVU5DX1NUQVRFTUVOVCA9IDEsIEZVTkNfSEFOR0lOR19TVEFURU1FTlQgPSAyLCBGVU5DX05VTExBQkxFX0lEID0gNDtcblxuLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlRgKS5cblxuLy8gUmVtb3ZlIGBhbGxvd0V4cHJlc3Npb25Cb2R5YCBmb3IgNy4wLjAsIGFzIGl0IGlzIG9ubHkgY2FsbGVkIHdpdGggZmFsc2VcbnBwJDEucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYykge1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5IHx8IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFpc0FzeW5jKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3RhciAmJiAoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgaWYgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSB7XG4gICAgbm9kZS5pZCA9IChzdGF0ZW1lbnQgJiBGVU5DX05VTExBQkxFX0lEKSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUgPyBudWxsIDogdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgaWYgKG5vZGUuaWQgJiYgIShzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgIC8vIElmIGl0IGlzIGEgcmVndWxhciBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpbiBzbG9wcHkgbW9kZSwgdGhlbiBpdCBpc1xuICAgICAgLy8gc3ViamVjdCB0byBBbm5leCBCIHNlbWFudGljcyAoQklORF9GVU5DVElPTikuIE90aGVyd2lzZSwgdGhlIGJpbmRpbmdcbiAgICAgIC8vIG1vZGUgZGVwZW5kcyBvbiBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHNjb3BlIChzZWVcbiAgICAgIC8vIHRyZWF0RnVuY3Rpb25zQXNWYXIpLlxuICAgICAgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCAodGhpcy5zdHJpY3QgfHwgbm9kZS5nZW5lcmF0b3IgfHwgbm9kZS5hc3luYykgPyB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCA6IEJJTkRfRlVOQ1RJT04pOyB9XG4gIH1cblxuICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3Mobm9kZS5hc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcblxuICBpZiAoIShzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkpXG4gICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiBudWxsOyB9XG5cbiAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGZhbHNlKTtcblxuICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxucHAkMS5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG59O1xuXG4vLyBQYXJzZSBhIGNsYXNzIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbi8vIGBpc1N0YXRlbWVudGAgcGFyYW1ldGVyKS5cblxucHAkMS5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gZWNtYS0yNjIgMTQuNiBDbGFzcyBEZWZpbml0aW9uc1xuICAvLyBBIGNsYXNzIGRlZmluaXRpb24gaXMgYWx3YXlzIHN0cmljdCBtb2RlIGNvZGUuXG4gIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdDtcbiAgdGhpcy5zdHJpY3QgPSB0cnVlO1xuXG4gIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gIHZhciBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgaGFkQ29uc3RydWN0b3IgPSBmYWxzZTtcbiAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50KG5vZGUuc3VwZXJDbGFzcyAhPT0gbnVsbCk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBlbGVtZW50LmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcy5yYWlzZShlbGVtZW50LnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzc1wiKTsgfVxuICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpO1xuICB0aGlzLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbn07XG5cbnBwJDEucGFyc2VDbGFzc0VsZW1lbnQgPSBmdW5jdGlvbihjb25zdHJ1Y3RvckFsbG93c1N1cGVyKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgdmFyIG1ldGhvZCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciB0cnlDb250ZXh0dWFsID0gZnVuY3Rpb24gKGssIG5vTGluZUJyZWFrKSB7XG4gICAgaWYgKCBub0xpbmVCcmVhayA9PT0gdm9pZCAwICkgbm9MaW5lQnJlYWsgPSBmYWxzZTtcblxuICAgIHZhciBzdGFydCA9IHRoaXMkMS5zdGFydCwgc3RhcnRMb2MgPSB0aGlzJDEuc3RhcnRMb2M7XG4gICAgaWYgKCF0aGlzJDEuZWF0Q29udGV4dHVhbChrKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0aGlzJDEudHlwZSAhPT0gdHlwZXMucGFyZW5MICYmICghbm9MaW5lQnJlYWsgfHwgIXRoaXMkMS5jYW5JbnNlcnRTZW1pY29sb24oKSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChtZXRob2Qua2V5KSB7IHRoaXMkMS51bmV4cGVjdGVkKCk7IH1cbiAgICBtZXRob2QuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICBtZXRob2Qua2V5ID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0LCBzdGFydExvYyk7XG4gICAgbWV0aG9kLmtleS5uYW1lID0gaztcbiAgICB0aGlzJDEuZmluaXNoTm9kZShtZXRob2Qua2V5LCBcIklkZW50aWZpZXJcIik7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICBtZXRob2Quc3RhdGljID0gdHJ5Q29udGV4dHVhbChcInN0YXRpY1wiKTtcbiAgdmFyIGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gIHZhciBpc0FzeW5jID0gZmFsc2U7XG4gIGlmICghaXNHZW5lcmF0b3IpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgdHJ5Q29udGV4dHVhbChcImFzeW5jXCIsIHRydWUpKSB7XG4gICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgfSBlbHNlIGlmICh0cnlDb250ZXh0dWFsKFwiZ2V0XCIpKSB7XG4gICAgICBtZXRob2Qua2luZCA9IFwiZ2V0XCI7XG4gICAgfSBlbHNlIGlmICh0cnlDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICBtZXRob2Qua2luZCA9IFwic2V0XCI7XG4gICAgfVxuICB9XG4gIGlmICghbWV0aG9kLmtleSkgeyB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7IH1cbiAgdmFyIGtleSA9IG1ldGhvZC5rZXk7XG4gIHZhciBhbGxvd3NEaXJlY3RTdXBlciA9IGZhbHNlO1xuICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiAhbWV0aG9kLnN0YXRpYyAmJiAoa2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHxcbiAgICAgIGtleS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICBpZiAobWV0aG9kLmtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpOyB9XG4gICAgaWYgKGlzR2VuZXJhdG9yKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCI7XG4gICAgYWxsb3dzRGlyZWN0U3VwZXIgPSBjb25zdHJ1Y3RvckFsbG93c1N1cGVyO1xuICB9IGVsc2UgaWYgKG1ldGhvZC5zdGF0aWMgJiYga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlXCIpO1xuICB9XG4gIHRoaXMucGFyc2VDbGFzc01ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMClcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUuc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDEpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICByZXR1cm4gbWV0aG9kXG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NNZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIilcbn07XG5cbnBwJDEucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICBpZiAoaXNTdGF0ZW1lbnQpXG4gICAgICB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfTEVYSUNBTCwgZmFsc2UpOyB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzU3RhdGVtZW50ID09PSB0cnVlKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIG5vZGUuaWQgPSBudWxsO1xuICB9XG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NTdXBlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQodHlwZXMuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCkgOiBudWxsO1xufTtcblxuLy8gUGFyc2VzIG1vZHVsZSBleHBvcnQgZGVjbGFyYXRpb24uXG5cbnBwJDEucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gIHRoaXMubmV4dCgpO1xuICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5zdGFyKSkge1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5fZGVmYXVsdCkpIHsgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXG4gICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBcImRlZmF1bHRcIiwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgIHZhciBpc0FzeW5jO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpKSB7XG4gICAgICB2YXIgZk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNBc3luYykgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbihmTm9kZSwgRlVOQ19TVEFURU1FTlQgfCBGVU5DX05VTExBQkxFX0lELCBmYWxzZSwgaXNBc3luYyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jbGFzcykge1xuICAgICAgdmFyIGNOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3MoY05vZGUsIFwibnVsbGFibGVJRFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKVxuICB9XG4gIC8vIGV4cG9ydCB2YXJ8Y29uc3R8bGV0fGZ1bmN0aW9ufGNsYXNzIC4uLlxuICBpZiAodGhpcy5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCgpKSB7XG4gICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgaWYgKG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gICAgICB7IHRoaXMuY2hlY2tWYXJpYWJsZUV4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucyk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5pZC5uYW1lLCBub2RlLmRlY2xhcmF0aW9uLmlkLnN0YXJ0KTsgfVxuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgfSBlbHNlIHsgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnMoZXhwb3J0cyk7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnNwZWNpZmllcnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBrZXl3b3JkcyB1c2VkIGFzIGxvY2FsIG5hbWVzXG4gICAgICAgIHZhciBzcGVjID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChzcGVjLmxvY2FsKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgZXhwb3J0IGlzIGRlZmluZWRcbiAgICAgICAgdGhpcy5jaGVja0xvY2FsRXhwb3J0KHNwZWMubG9jYWwpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDEuY2hlY2tFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBwb3MpIHtcbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGlmIChoYXMoZXhwb3J0cywgbmFtZSkpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCBcIkR1cGxpY2F0ZSBleHBvcnQgJ1wiICsgbmFtZSArIFwiJ1wiKTsgfVxuICBleHBvcnRzW25hbWVdID0gdHJ1ZTtcbn07XG5cbnBwJDEuY2hlY2tQYXR0ZXJuRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgcGF0KSB7XG4gIHZhciB0eXBlID0gcGF0LnR5cGU7XG4gIGlmICh0eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgcGF0Lm5hbWUsIHBhdC5zdGFydCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHByb3ApO1xuICAgICAgfSB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpXG4gICAgeyBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBwYXQuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICB2YXIgZWx0ID0gbGlzdCQxW2kkMV07XG5cbiAgICAgICAgaWYgKGVsdCkgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBlbHQpOyB9XG4gICAgfSB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiUHJvcGVydHlcIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC52YWx1ZSk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmxlZnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5hcmd1bWVudCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmV4cHJlc3Npb24pOyB9XG59O1xuXG5wcCQxLmNoZWNrVmFyaWFibGVFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWNscykge1xuICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBkZWNsczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBkZWNsID0gbGlzdFtpXTtcblxuICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGRlY2wuaWQpO1xuICB9XG59O1xuXG5wcCQxLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjbGFzc1wiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgIHRoaXMuaXNMZXQoKSB8fFxuICAgIHRoaXMuaXNBc3luY0Z1bmN0aW9uKClcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBleHBvcnRzLlxuXG5wcCQxLnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlSWRlbnQodHJ1ZSkgOiBub2RlLmxvY2FsO1xuICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5leHBvcnRlZC5uYW1lLCBub2RlLmV4cG9ydGVkLnN0YXJ0KTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzXG59O1xuXG4vLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQxLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgLy8gaW1wb3J0ICcuLi4nXG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZykge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IGVtcHR5O1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGltcG9ydHMuXG5cbnBwJDEucGFyc2VJbXBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAvLyBpbXBvcnQgZGVmYXVsdE9iaiwgeyB4LCB5IGFzIHogfSBmcm9tICcuLi4nXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbChub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgcmV0dXJuIG5vZGVzIH1cbiAgfVxuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSB7XG4gICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiYXNcIik7XG4gICAgbm9kZSQxLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZSQxLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgIHJldHVybiBub2Rlc1xuICB9XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlJDIuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBub2RlJDIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSQyLmltcG9ydGVkKTtcbiAgICAgIG5vZGUkMi5sb2NhbCA9IG5vZGUkMi5pbXBvcnRlZDtcbiAgICB9XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZSQyLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJJbXBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG4gIHJldHVybiBub2Rlc1xufTtcblxuLy8gU2V0IGBFeHByZXNzaW9uU3RhdGVtZW50I2RpcmVjdGl2ZWAgcHJvcGVydHkgZm9yIGRpcmVjdGl2ZSBwcm9sb2d1ZXMuXG5wcCQxLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUgPSBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGggJiYgdGhpcy5pc0RpcmVjdGl2ZUNhbmRpZGF0ZShzdGF0ZW1lbnRzW2ldKTsgKytpKSB7XG4gICAgc3RhdGVtZW50c1tpXS5kaXJlY3RpdmUgPSBzdGF0ZW1lbnRzW2ldLmV4cHJlc3Npb24ucmF3LnNsaWNlKDEsIC0xKTtcbiAgfVxufTtcbnBwJDEuaXNEaXJlY3RpdmVDYW5kaWRhdGUgPSBmdW5jdGlvbihzdGF0ZW1lbnQpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICBzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJlxuICAgIHR5cGVvZiBzdGF0ZW1lbnQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIC8vIFJlamVjdCBwYXJlbnRoZXNpemVkIHN0cmluZ3MuXG4gICAgKHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCJcXFwiXCIgfHwgdGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIidcIilcbiAgKVxufTtcblxudmFyIHBwJDIgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBDb252ZXJ0IGV4aXN0aW5nIGV4cHJlc3Npb24gYXRvbSB0byBhc3NpZ25hYmxlIHBhdHRlcm5cbi8vIGlmIHBvc3NpYmxlLlxuXG5wcCQyLnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbm9kZS5uYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICBub2RlLnR5cGUgPSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAvLyBFYXJseSBlcnJvcjpcbiAgICAgICAgLy8gICBBc3NpZ25tZW50UmVzdFByb3BlcnR5W1lpZWxkLCBBd2FpdF0gOlxuICAgICAgICAvLyAgICAgYC4uLmAgRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRbWWllbGQsIEF3YWl0XVxuICAgICAgICAvL1xuICAgICAgICAvLyAgIEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIHxEZXN0cnVjdHVyaW5nQXNzaWdubWVudFRhcmdldHwgaXMgYW4gfEFycmF5TGl0ZXJhbHwgb3IgYW4gfE9iamVjdExpdGVyYWx8LlxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiZcbiAgICAgICAgICAocHJvcC5hcmd1bWVudC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMucmFpc2UocHJvcC5hcmd1bWVudC5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJpbml0XCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIik7IH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgbm9kZS50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5hcmd1bWVudCwgaXNCaW5kaW5nKTtcbiAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuYXJndW1lbnQuc3RhcnQsIFwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikgeyB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7IH1cbiAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0JpbmRpbmcpO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaCB0byBBc3NpZ25tZW50UGF0dGVyblxuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmICghaXNCaW5kaW5nKSB7IGJyZWFrIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gQ29udmVydCBsaXN0IG9mIGV4cHJlc3Npb24gYXRvbXMgdG8gYmluZGluZyBsaXN0LlxuXG5wcCQyLnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gIHZhciBlbmQgPSBleHByTGlzdC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgaWYgKGVsdCkgeyB0aGlzLnRvQXNzaWduYWJsZShlbHQsIGlzQmluZGluZyk7IH1cbiAgfVxuICBpZiAoZW5kKSB7XG4gICAgdmFyIGxhc3QgPSBleHByTGlzdFtlbmQgLSAxXTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIGlzQmluZGluZyAmJiBsYXN0ICYmIGxhc3QudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmIGxhc3QuYXJndW1lbnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICB9XG4gIHJldHVybiBleHByTGlzdFxufTtcblxuLy8gUGFyc2VzIHNwcmVhZCBlbGVtZW50LlxuXG5wcCQyLnBhcnNlU3ByZWFkID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbn07XG5cbnBwJDIucGFyc2VSZXN0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIFJlc3RFbGVtZW50IGluc2lkZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciBtdXN0IGJlIGFuIGlkZW50aWZpZXJcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpXG4gICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbnBwJDIucGFyc2VCaW5kaW5nQXRvbSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKVxuXG4gICAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0cnVlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KClcbn07XG5cbnBwJDIucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmIChmaXJzdCkgeyBmaXJzdCA9IGZhbHNlOyB9XG4gICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTsgfVxuICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICB9IGVsc2UgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShyZXN0KTtcbiAgICAgIGVsdHMucHVzaChyZXN0KTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbGVtID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKTtcbiAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgICBlbHRzLnB1c2goZWxlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQyLnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgcmV0dXJuIHBhcmFtXG59O1xuXG4vLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG5wcCQyLnBhcnNlTWF5YmVEZWZhdWx0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KSB7XG4gIGxlZnQgPSBsZWZ0IHx8IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMuZXEpKSB7IHJldHVybiBsZWZ0IH1cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG59O1xuXG4vLyBWZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbCDigJQgc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4vLyB0by5cbi8vIGJpbmRpbmdUeXBlIGNhbiBiZSBlaXRoZXI6XG4vLyAndmFyJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGx2YWwgY3JlYXRlcyBhICd2YXInIGJpbmRpbmdcbi8vICdsZXQnIGluZGljYXRpbmcgdGhhdCB0aGUgbHZhbCBjcmVhdGVzIGEgbGV4aWNhbCAoJ2xldCcgb3IgJ2NvbnN0JykgYmluZGluZ1xuLy8gJ25vbmUnIGluZGljYXRpbmcgdGhhdCB0aGUgYmluZGluZyBzaG91bGQgYmUgY2hlY2tlZCBmb3IgaWxsZWdhbCBpZGVudGlmaWVycywgYnV0IG5vdCBmb3IgZHVwbGljYXRlIHJlZmVyZW5jZXNcblxucHAkMi5jaGVja0xWYWwgPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gIGlmICggYmluZGluZ1R5cGUgPT09IHZvaWQgMCApIGJpbmRpbmdUeXBlID0gQklORF9OT05FO1xuXG4gIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwgJiYgZXhwci5uYW1lID09PSBcImxldFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lXCIpOyB9XG4gICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICBpZiAoaGFzKGNoZWNrQ2xhc2hlcywgZXhwci5uYW1lKSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoXCIpOyB9XG4gICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAhPT0gQklORF9OT05FICYmIGJpbmRpbmdUeXBlICE9PSBCSU5EX09VVFNJREUpIHsgdGhpcy5kZWNsYXJlTmFtZShleHByLm5hbWUsIGJpbmRpbmdUeXBlLCBleHByLnN0YXJ0KTsgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICBpZiAoYmluZGluZ1R5cGUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHIucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgdGhpcy5jaGVja0xWYWwocHJvcCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gIH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgIC8vIEFzc2lnbm1lbnRQcm9wZXJ0eSBoYXMgdHlwZSA9PT0gXCJQcm9wZXJ0eVwiXG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci52YWx1ZSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbGVtID0gbGlzdCQxW2kkMV07XG5cbiAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbChlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgIH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLmFyZ3VtZW50LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBkZWZhdWx0OlxuICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nXCIgOiBcIkFzc2lnbmluZyB0b1wiKSArIFwiIHJ2YWx1ZVwiKTtcbiAgfVxufTtcblxuLy8gQSByZWN1cnNpdmUgZGVzY2VudCBwYXJzZXIgb3BlcmF0ZXMgYnkgZGVmaW5pbmcgZnVuY3Rpb25zIGZvciBhbGxcblxudmFyIHBwJDMgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBDaGVjayBpZiBwcm9wZXJ0eSBuYW1lIGNsYXNoZXMgd2l0aCBhbHJlYWR5IGFkZGVkLlxuLy8gT2JqZWN0L2NsYXNzIGdldHRlcnMgYW5kIHNldHRlcnMgYXJlIG5vdCBhbGxvd2VkIHRvIGNsYXNoIOKAlFxuLy8gZWl0aGVyIHdpdGggZWFjaCBvdGhlciBvciB3aXRoIGFuIGluaXQgcHJvcGVydHkg4oCUIGFuZCBpblxuLy8gc3RyaWN0IG1vZGUsIGluaXQgcHJvcGVydGllcyBhcmUgYWxzbyBub3QgYWxsb3dlZCB0byBiZSByZXBlYXRlZC5cblxucHAkMy5jaGVja1Byb3BDbGFzaCA9IGZ1bmN0aW9uKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBwcm9wLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKVxuICAgIHsgcmV0dXJuIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIChwcm9wLmNvbXB1dGVkIHx8IHByb3AubWV0aG9kIHx8IHByb3Auc2hvcnRoYW5kKSlcbiAgICB7IHJldHVybiB9XG4gIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgdmFyIG5hbWU7XG4gIHN3aXRjaCAoa2V5LnR5cGUpIHtcbiAgY2FzZSBcIklkZW50aWZpZXJcIjogbmFtZSA9IGtleS5uYW1lOyBicmVha1xuICBjYXNlIFwiTGl0ZXJhbFwiOiBuYW1lID0gU3RyaW5nKGtleS52YWx1ZSk7IGJyZWFrXG4gIGRlZmF1bHQ6IHJldHVyblxuICB9XG4gIHZhciBraW5kID0gcHJvcC5raW5kO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiAmJiBraW5kID09PSBcImluaXRcIikge1xuICAgICAgaWYgKHByb3BIYXNoLnByb3RvKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPCAwKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBrZXkuc3RhcnQ7IH1cbiAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdCBrbHVkZ2UuIENhbiBiZSByZW1vdmVkIGluIHZlcnNpb24gNi4wXG4gICAgICAgIGVsc2UgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbiAgICAgIH1cbiAgICAgIHByb3BIYXNoLnByb3RvID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgbmFtZSA9IFwiJFwiICsgbmFtZTtcbiAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gIGlmIChvdGhlcikge1xuICAgIHZhciByZWRlZmluaXRpb247XG4gICAgaWYgKGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICByZWRlZmluaXRpb24gPSB0aGlzLnN0cmljdCAmJiBvdGhlci5pbml0IHx8IG90aGVyLmdldCB8fCBvdGhlci5zZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZGVmaW5pdGlvbiA9IG90aGVyLmluaXQgfHwgb3RoZXJba2luZF07XG4gICAgfVxuICAgIGlmIChyZWRlZmluaXRpb24pXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpOyB9XG4gIH0gZWxzZSB7XG4gICAgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXSA9IHtcbiAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgZ2V0OiBmYWxzZSxcbiAgICAgIHNldDogZmFsc2VcbiAgICB9O1xuICB9XG4gIG90aGVyW2tpbmRdID0gdHJ1ZTtcbn07XG5cbi8vICMjIyBFeHByZXNzaW9uIHBhcnNpbmdcblxuLy8gVGhlc2UgbmVzdCwgZnJvbSB0aGUgbW9zdCBnZW5lcmFsIGV4cHJlc3Npb24gdHlwZSBhdCB0aGUgdG9wIHRvXG4vLyAnYXRvbWljJywgbm9uZGl2aXNpYmxlIGV4cHJlc3Npb24gdHlwZXMgYXQgdGhlIGJvdHRvbS4gTW9zdCBvZlxuLy8gdGhlIGZ1bmN0aW9ucyB3aWxsIHNpbXBseSBsZXQgdGhlIGZ1bmN0aW9uKHMpIGJlbG93IHRoZW0gcGFyc2UsXG4vLyBhbmQsICppZiogdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3QgdGhleSBoYW5kbGUgaXMgcHJlc2VudCwgd3JhcFxuLy8gdGhlIEFTVCBub2RlIHRoYXQgdGhlIGlubmVyIHBhcnNlciBnYXZlIHRoZW0gaW4gYW5vdGhlciBub2RlLlxuXG4vLyBQYXJzZSBhIGZ1bGwgZXhwcmVzc2lvbi4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBhcmUgdXNlZCB0b1xuLy8gZm9yYmlkIHRoZSBgaW5gIG9wZXJhdG9yIChpbiBmb3IgbG9vcHMgaW5pdGFsaXphdGlvbiBleHByZXNzaW9ucylcbi8vIGFuZCBwcm92aWRlIHJlZmVyZW5jZSBmb3Igc3RvcmluZyAnPScgb3BlcmF0b3IgaW5zaWRlIHNob3J0aGFuZFxuLy8gcHJvcGVydHkgYXNzaWdubWVudCBpbiBjb250ZXh0cyB3aGVyZSBib3RoIG9iamVjdCBleHByZXNzaW9uXG4vLyBhbmQgb2JqZWN0IHBhdHRlcm4gbWlnaHQgYXBwZWFyIChzbyBpdCdzIHBvc3NpYmxlIHRvIHJhaXNlXG4vLyBkZWxheWVkIHN5bnRheCBlcnJvciBhdCBjb3JyZWN0IHBvc2l0aW9uKS5cblxucHAkMy5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKVxuICB9XG4gIHJldHVybiBleHByXG59O1xuXG4vLyBQYXJzZSBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uIFRoaXMgaW5jbHVkZXMgYXBwbGljYXRpb25zIG9mXG4vLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG5wcCQzLnBhcnNlTWF5YmVBc3NpZ24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJ5aWVsZFwiKSkge1xuICAgIGlmICh0aGlzLmluR2VuZXJhdG9yKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQobm9JbikgfVxuICAgIC8vIFRoZSB0b2tlbml6ZXIgd2lsbCBhc3N1bWUgYW4gZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGFmdGVyXG4gICAgLy8gYHlpZWxkYCwgYnV0IHRoaXMgaXNuJ3QgdGhhdCBraW5kIG9mIHlpZWxkXG4gICAgZWxzZSB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICB9XG5cbiAgdmFyIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSBmYWxzZSwgb2xkUGFyZW5Bc3NpZ24gPSAtMSwgb2xkVHJhaWxpbmdDb21tYSA9IC0xLCBvbGRTaG9ydGhhbmRBc3NpZ24gPSAtMTtcbiAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBvbGRQYXJlbkFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbjtcbiAgICBvbGRUcmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgIG9sZFNob3J0aGFuZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduO1xuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgfHwgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lKVxuICAgIHsgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDsgfVxuICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHsgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTsgfVxuICBpZiAodGhpcy50eXBlLmlzQXNzaWduKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgbm9kZS5sZWZ0ID0gdGhpcy50eXBlID09PSB0eXBlcy5lcSA/IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSA6IGxlZnQ7XG4gICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IERlc3RydWN0dXJpbmdFcnJvcnMuY2FsbChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IC8vIHJlc2V0IGJlY2F1c2Ugc2hvcnRoYW5kIGRlZmF1bHQgd2FzIHVzZWQgY29ycmVjdGx5XG4gICAgdGhpcy5jaGVja0xWYWwobGVmdCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIilcbiAgfSBlbHNlIHtcbiAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICB9XG4gIGlmIChvbGRQYXJlbkFzc2lnbiA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IG9sZFBhcmVuQXNzaWduOyB9XG4gIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICBpZiAob2xkU2hvcnRoYW5kQXNzaWduID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSBvbGRTaG9ydGhhbmRBc3NpZ247IH1cbiAgcmV0dXJuIGxlZnRcbn07XG5cbi8vIFBhcnNlIGEgdGVybmFyeSBjb25kaXRpb25hbCAoYD86YCkgb3BlcmF0b3IuXG5cbnBwJDMucGFyc2VNYXliZUNvbmRpdGlvbmFsID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJPcHMobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLnRlc3QgPSBleHByO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpXG4gIH1cbiAgcmV0dXJuIGV4cHJcbn07XG5cbi8vIFN0YXJ0IHRoZSBwcmVjZWRlbmNlIHBhcnNlci5cblxucHAkMy5wYXJzZUV4cHJPcHMgPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gIHJldHVybiBleHByLnN0YXJ0ID09PSBzdGFydFBvcyAmJiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGV4cHIgOiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIG5vSW4pXG59O1xuXG4vLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbi8vIGBtaW5QcmVjYCBwcm92aWRlcyBjb250ZXh0IHRoYXQgYWxsb3dzIHRoZSBmdW5jdGlvbiB0byBzdG9wIGFuZFxuLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuXG5wcCQzLnBhcnNlRXhwck9wID0gZnVuY3Rpb24obGVmdCwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pIHtcbiAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRoaXMudHlwZSAhPT0gdHlwZXMuX2luKSkge1xuICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgdmFyIGxvZ2ljYWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxPUiB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxBTkQ7XG4gICAgICB2YXIgb3AgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBub0luKTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5idWlsZEJpbmFyeShsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGVmdFxufTtcblxucHAkMy5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLm9wZXJhdG9yID0gb3A7XG4gIG5vZGUucmlnaHQgPSByaWdodDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSB1bmFyeSBvcGVyYXRvcnMsIGJvdGggcHJlZml4IGFuZCBwb3N0Zml4LlxuXG5wcCQzLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5KSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgZXhwcjtcbiAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikgJiYgKHRoaXMuaW5Bc3luYyB8fCAoIXRoaXMuaW5GdW5jdGlvbiAmJiB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikpKSB7XG4gICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdCgpO1xuICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUucHJlZml4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmluY0RlYztcbiAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIGlmICh1cGRhdGUpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudCk7IH1cbiAgICBlbHNlIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmXG4gICAgICAgICAgICAgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICBlbHNlIHsgc2F3VW5hcnkgPSB0cnVlOyB9XG4gICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICB9IGVsc2Uge1xuICAgIGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICB3aGlsZSAodGhpcy50eXBlLnBvc3RmaXggJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlJDEub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZSQxLnByZWZpeCA9IGZhbHNlO1xuICAgICAgbm9kZSQxLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2F3VW5hcnkgJiYgdGhpcy5lYXQodHlwZXMuc3RhcnN0YXIpKVxuICAgIHsgcmV0dXJuIHRoaXMuYnVpbGRCaW5hcnkoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByLCB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIFwiKipcIiwgZmFsc2UpIH1cbiAgZWxzZVxuICAgIHsgcmV0dXJuIGV4cHIgfVxufTtcblxuLy8gUGFyc2UgY2FsbCwgZG90LCBhbmQgYFtdYC1zdWJzY3JpcHQgZXhwcmVzc2lvbnMuXG5cbnBwJDMucGFyc2VFeHByU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgdmFyIHNraXBBcnJvd1N1YnNjcmlwdHMgPSBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tFbmQpICE9PSBcIilcIjtcbiAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHx8IHNraXBBcnJvd1N1YnNjcmlwdHMpIHsgcmV0dXJuIGV4cHIgfVxuICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVzdWx0LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gLTE7IH1cbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IC0xOyB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblxucHAkMy5wYXJzZVN1YnNjcmlwdHMgPSBmdW5jdGlvbihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgIHRoaXMubGFzdFRva0VuZCA9PT0gYmFzZS5lbmQgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5pbnB1dC5zbGljZShiYXNlLnN0YXJ0LCBiYXNlLmVuZCkgPT09IFwiYXN5bmNcIjtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3cpO1xuICAgIGlmIChlbGVtZW50ID09PSBiYXNlIHx8IGVsZW1lbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7IHJldHVybiBlbGVtZW50IH1cbiAgICBiYXNlID0gZWxlbWVudDtcbiAgfVxufTtcblxucHAkMy5wYXJzZVN1YnNjcmlwdCA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93KSB7XG4gIHZhciBjb21wdXRlZCA9IHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKTtcbiAgaWYgKGNvbXB1dGVkIHx8IHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IGNvbXB1dGVkID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICBub2RlLmNvbXB1dGVkID0gISFjb21wdXRlZDtcbiAgICBpZiAoY29tcHV0ZWQpIHsgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpOyB9XG4gICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgYmFzZS50eXBlICE9PSBcIkltcG9ydFwiLCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICBpZiAodGhpcy5hd2FpdElkZW50UG9zID4gMClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRJZGVudFBvcywgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlKVxuICAgIH1cbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zIHx8IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUkMS5jYWxsZWUgPSBiYXNlO1xuICAgIG5vZGUkMS5hcmd1bWVudHMgPSBleHByTGlzdDtcbiAgICBpZiAobm9kZSQxLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgICBpZiAobm9kZSQxLmFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShub2RlJDEuc3RhcnQsIFwiaW1wb3J0KCkgcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnRcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbXBvcnRBcmcgPSBub2RlJDEuYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKGltcG9ydEFyZyAmJiBpbXBvcnRBcmcudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShpbXBvcnRBcmcuc3RhcnQsIFwiLi4uIGlzIG5vdCBhbGxvd2VkIGluIGltcG9ydCgpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZSkge1xuICAgIHZhciBub2RlJDIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZSQyLnRhZyA9IGJhc2U7XG4gICAgbm9kZSQyLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQyLCBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKTtcbiAgfVxuICByZXR1cm4gYmFzZVxufTtcblxuLy8gUGFyc2UgYW4gYXRvbWljIGV4cHJlc3Npb24g4oCUIGVpdGhlciBhIHNpbmdsZSB0b2tlbiB0aGF0IGlzIGFuXG4vLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuLy8gYG5ld2AsIG9yIGFuIGV4cHJlc3Npb24gd3JhcHBlZCBpbiBwdW5jdHVhdGlvbiBsaWtlIGAoKWAsIGBbXWAsXG4vLyBvciBge31gLlxuXG5wcCQzLnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIC8vIElmIGEgZGl2aXNpb24gb3BlcmF0b3IgYXBwZWFycyBpbiBhbiBleHByZXNzaW9uIHBvc2l0aW9uLCB0aGVcbiAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2xhc2gpIHsgdGhpcy5yZWFkUmVnZXhwKCk7IH1cblxuICB2YXIgbm9kZSwgY2FuQmVBcnJvdyA9IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGFydDtcbiAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgY2FzZSB0eXBlcy5fc3VwZXI6XG4gICAgaWYgKCF0aGlzLmFsbG93U3VwZXIpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInc3VwZXInIGtleXdvcmQgb3V0c2lkZSBhIG1ldGhvZFwiKTsgfVxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwic3VwZXIoKSBjYWxsIG91dHNpZGUgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzc1wiKTsgfVxuICAgIC8vIFRoZSBgc3VwZXJgIGtleXdvcmQgY2FuIGFwcGVhciBhdCBiZWxvdzpcbiAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgIC8vICAgICBzdXBlciBbIEV4cHJlc3Npb24gXVxuICAgIC8vICAgICBzdXBlciAuIElkZW50aWZpZXJOYW1lXG4gICAgLy8gU3VwZXJDYWxsOlxuICAgIC8vICAgICBzdXBlciBBcmd1bWVudHNcbiAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5kb3QgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFja2V0TCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuTClcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICBjYXNlIHR5cGVzLl90aGlzOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMubmFtZTpcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhY29udGFpbnNFc2MgJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLl9mdW5jdGlvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCAwLCBmYWxzZSwgdHJ1ZSkgfVxuICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UpIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmICFjb250YWluc0VzYykge1xuICAgICAgICBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZFxuXG4gIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgbm9kZSA9IHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLnZhbHVlKTtcbiAgICBub2RlLnJlZ2V4ID0ge3BhdHRlcm46IHZhbHVlLnBhdHRlcm4sIGZsYWdzOiB2YWx1ZS5mbGFnc307XG4gICAgcmV0dXJuIG5vZGVcblxuICBjYXNlIHR5cGVzLm51bTogY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgY2FzZSB0eXBlcy5fbnVsbDogY2FzZSB0eXBlcy5fdHJ1ZTogY2FzZSB0eXBlcy5fZmFsc2U6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX251bGwgPyBudWxsIDogdGhpcy50eXBlID09PSB0eXBlcy5fdHJ1ZTtcbiAgICBub2RlLnJhdyA9IHRoaXMudHlwZS5rZXl3b3JkO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgY2FzZSB0eXBlcy5wYXJlbkw6XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDAgJiYgIXRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwcikpXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcblxuICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIilcblxuICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICByZXR1cm4gdGhpcy5wYXJzZU9iaihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcblxuICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDApXG5cbiAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICBjYXNlIHR5cGVzLl9uZXc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gIGNhc2UgdHlwZXMuYmFja1F1b3RlOlxuICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID4gMTApIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnVuZXhwZWN0ZWQoKVxuICAgIH1cblxuICBkZWZhdWx0OlxuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcCQzLnBhcnNlRHluYW1pY0ltcG9ydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5wYXJlbkwpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0XCIpXG59O1xuXG5wcCQzLnBhcnNlTGl0ZXJhbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBub2RlLnJhdyA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICBpZiAobm9kZS5yYXcuY2hhckNvZGVBdChub2RlLnJhdy5sZW5ndGggLSAxKSA9PT0gMTEwKSB7IG5vZGUuYmlnaW50ID0gbm9kZS5yYXcuc2xpY2UoMCwgLTEpOyB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxufTtcblxucHAkMy5wYXJzZVBhcmVuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICB2YXIgdmFsID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgcmV0dXJuIHZhbFxufTtcblxucHAkMy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24oY2FuQmVBcnJvdykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIHZhbCwgYWxsb3dUcmFpbGluZ0NvbW1hID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDg7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBzcHJlYWRTdGFydDtcbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAvLyBEbyBub3Qgc2F2ZSBhd2FpdElkZW50UG9zIHRvIGFsbG93IGNoZWNraW5nIGF3YWl0cyBuZXN0ZWQgaW4gcGFyYW1ldGVyc1xuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuUikge1xuICAgICAgZmlyc3QgPyBmaXJzdCA9IGZhbHNlIDogdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5wYXJlblIsIHRydWUpKSB7XG4gICAgICAgIGxhc3RJc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZVBhcmVuSXRlbSh0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKSkpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lckVuZExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BcnJvd0xpc3Qoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdClcbiAgICB9XG5cbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgaWYgKHNwcmVhZFN0YXJ0KSB7IHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7IH1cbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcblxuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGVBdCh2YWwsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIGlubmVyRW5kUG9zLCBpbm5lckVuZExvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBwYXIuZXhwcmVzc2lvbiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxcbiAgfVxufTtcblxucHAkMy5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW1cbn07XG5cbnBwJDMucGFyc2VQYXJlbkFycm93TGlzdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdClcbn07XG5cbi8vIE5ldydzIHByZWNlZGVuY2UgaXMgc2xpZ2h0bHkgdHJpY2t5LiBJdCBtdXN0IGFsbG93IGl0cyBhcmd1bWVudCB0b1xuLy8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0IGxlYXN0LFxuLy8gbm90IHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gcGFyZW50aGVzZXMuIFRodXMsIGl0IHVzZXMgdGhlIG5vQ2FsbHNcbi8vIGFyZ3VtZW50IHRvIHBhcnNlU3Vic2NyaXB0cyB0byBwcmV2ZW50IGl0IGZyb20gY29uc3VtaW5nIHRoZVxuLy8gYXJndW1lbnQgbGlzdC5cblxudmFyIGVtcHR5JDEgPSBbXTtcblxucHAkMy5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIgfHwgY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyBuZXcudGFyZ2V0XCIpOyB9XG4gICAgaWYgKCF0aGlzLmluTm9uQXJyb3dGdW5jdGlvbigpKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJuZXcudGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICB9XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCB0cnVlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICB0aGlzLnJhaXNlKG5vZGUuY2FsbGVlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KC4uLilcIik7XG4gIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHsgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBub2RlLmNhbGxlZS50eXBlICE9PSBcIkltcG9ydFwiLCBmYWxzZSk7IH1cbiAgZWxzZSB7IG5vZGUuYXJndW1lbnRzID0gZW1wdHkkMTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgdGVtcGxhdGUgZXhwcmVzc2lvbi5cblxucHAkMy5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7XG5cbiAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpIHtcbiAgICBpZiAoIWlzVGFnZ2VkKSB7XG4gICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJCYWQgZXNjYXBlIHNlcXVlbmNlIGluIHVudGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcIik7XG4gICAgfVxuICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICByYXc6IHRoaXMudmFsdWUsXG4gICAgICBjb29rZWQ6IG51bGxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICByYXc6IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIiksXG4gICAgICBjb29rZWQ6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICBlbGVtLnRhaWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKVxufTtcblxucHAkMy5wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkOyBpZiAoIGlzVGFnZ2VkID09PSB2b2lkIDAgKSBpc1RhZ2dlZCA9IGZhbHNlO1xuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgdmFyIGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pO1xuICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZW9mKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWxcIik7IH1cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5kb2xsYXJCcmFjZUwpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSkpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpXG59O1xuXG5wcCQzLmlzQXN5bmNQcm9wID0gZnVuY3Rpb24ocHJvcCkge1xuICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNrZXRMIHx8IHRoaXMudHlwZS5rZXl3b3JkIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpKSAmJlxuICAgICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG59O1xuXG4vLyBQYXJzZSBhbiBvYmplY3QgbGl0ZXJhbCBvciBiaW5kaW5nIHBhdHRlcm4uXG5cbnBwJDMucGFyc2VPYmogPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWUsIHByb3BIYXNoID0ge307XG4gIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICB0aGlzLm5leHQoKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBwcm9wID0gdGhpcy5wYXJzZVByb3BlcnR5KGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKCFpc1BhdHRlcm4pIHsgdGhpcy5jaGVja1Byb3BDbGFzaChwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzUGF0dGVybiA/IFwiT2JqZWN0UGF0dGVyblwiIDogXCJPYmplY3RFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQzLnBhcnNlUHJvcGVydHkgPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHByb3AgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpXG4gICAgfVxuICAgIC8vIFRvIGRpc2FsbG93IHBhcmVudGhlc2l6ZWQgaWRlbnRpZmllciB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJzZSBhcmd1bWVudC5cbiAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAvLyBUbyBkaXNhbGxvdyB0cmFpbGluZyBjb21tYSB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMCkge1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgLy8gRmluaXNoXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybiB8fCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBzdGFydFBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgfVxuICAgIGlmICghaXNQYXR0ZXJuKVxuICAgICAgeyBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpOyB9XG4gIH1cbiAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLmlzQXN5bmNQcm9wKHByb3ApKSB7XG4gICAgaXNBc3luYyA9IHRydWU7XG4gICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICB9IGVsc2Uge1xuICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlByb3BlcnR5XCIpXG59O1xuXG5wcCQzLnBhcnNlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpIHtcbiAgaWYgKChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbG9uKVxuICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICBpZiAodGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MKSB7XG4gICAgaWYgKGlzUGF0dGVybikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIH0gZWxzZSBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgICAgIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmXG4gICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gdHlwZXMuY29tbWEgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwcm9wLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQocHJvcC5rZXkpO1xuICAgIGlmIChwcm9wLmtleS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gc3RhcnRQb3M7IH1cbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gcHJvcC5rZXk7XG4gICAgfVxuICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgIHJldHVybiBwcm9wLmtleVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIilcbn07XG5cbi8vIEluaXRpYWxpemUgZW1wdHkgZnVuY3Rpb24gbm9kZS5cblxucHAkMy5pbml0RnVuY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUuaWQgPSBudWxsO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgbm9kZS5nZW5lcmF0b3IgPSBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9IGZhbHNlOyB9XG59O1xuXG4vLyBQYXJzZSBvYmplY3Qgb3IgY2xhc3MgbWV0aG9kLlxuXG5wcCQzLnBhcnNlTWV0aG9kID0gZnVuY3Rpb24oaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93RGlyZWN0U3VwZXIpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgdGhpcy55aWVsZFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRQb3MgPSAwO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikgfCBTQ09QRV9TVVBFUiB8IChhbGxvd0RpcmVjdFN1cGVyID8gU0NPUEVfRElSRUNUX1NVUEVSIDogMCkpO1xuXG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLlxuXG5wcCQzLnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jKSB7XG4gIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSkgfCBTQ09QRV9BUlJPVyk7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcblxuICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUsIGZhbHNlKTtcblxuICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSBmdW5jdGlvbiBib2R5IGFuZCBjaGVjayBwYXJhbWV0ZXJzLlxuXG5wcCQzLnBhcnNlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24obm9kZSwgaXNBcnJvd0Z1bmN0aW9uLCBpc01ldGhvZCkge1xuICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VMO1xuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3QsIHVzZVN0cmljdCA9IGZhbHNlO1xuXG4gIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub25TaW1wbGUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiAhdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcyk7XG4gICAgaWYgKCFvbGRTdHJpY3QgfHwgbm9uU2ltcGxlKSB7XG4gICAgICB1c2VTdHJpY3QgPSB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLmVuZCk7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgc3RyaWN0IG1vZGUgZnVuY3Rpb24sIHZlcmlmeSB0aGF0IGFyZ3VtZW50IG5hbWVzXG4gICAgICAvLyBhcmUgbm90IHJlcGVhdGVkLCBhbmQgaXQgZG9lcyBub3QgdHJ5IHRvIGJpbmQgdGhlIHdvcmRzIGBldmFsYFxuICAgICAgLy8gb3IgYGFyZ3VtZW50c2AuXG4gICAgICBpZiAodXNlU3RyaWN0ICYmIG5vblNpbXBsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpOyB9XG4gICAgfVxuICAgIC8vIFN0YXJ0IGEgbmV3IHNjb3BlIHdpdGggcmVnYXJkIHRvIGxhYmVscyBhbmQgdGhlIGBpbkZ1bmN0aW9uYFxuICAgIC8vIGZsYWcgKHJlc3RvcmUgdGhlbSB0byB0aGVpciBvbGQgdmFsdWUgYWZ0ZXJ3YXJkcykuXG4gICAgdmFyIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgaWYgKHVzZVN0cmljdCkgeyB0aGlzLnN0cmljdCA9IHRydWU7IH1cblxuICAgIC8vIEFkZCB0aGUgcGFyYW1zIHRvIHZhckRlY2xhcmVkTmFtZXMgdG8gZW5zdXJlIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgLy8gaWYgYSBsZXQvY29uc3QgZGVjbGFyYXRpb24gaW4gdGhlIGZ1bmN0aW9uIGNsYXNoZXMgd2l0aCBvbmUgb2YgdGhlIHBhcmFtcy5cbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICFvbGRTdHJpY3QgJiYgIXVzZVN0cmljdCAmJiAhaXNBcnJvd0Z1bmN0aW9uICYmICFpc01ldGhvZCAmJiB0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgIHRoaXMubGFiZWxzID0gb2xkTGFiZWxzO1xuICB9XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG5cbiAgLy8gRW5zdXJlIHRoZSBmdW5jdGlvbiBuYW1lIGlzbid0IGEgZm9yYmlkZGVuIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUsIGUuZy4gJ2V2YWwnXG4gIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLmlkKSB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfT1VUU0lERSk7IH1cbiAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG59O1xuXG5wcCQzLmlzU2ltcGxlUGFyYW1MaXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBDaGVja3MgZnVuY3Rpb24gcGFyYW1zIGZvciB2YXJpb3VzIGRpc2FsbG93ZWQgcGF0dGVybnMgc3VjaCBhcyB1c2luZyBcImV2YWxcIlxuLy8gb3IgXCJhcmd1bWVudHNcIiBhbmQgZHVwbGljYXRlIHBhcmFtZXRlcnMuXG5cbnBwJDMuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIG5hbWVIYXNoID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgdGhpcy5jaGVja0xWYWwocGFyYW0sIEJJTkRfVkFSLCBhbGxvd0R1cGxpY2F0ZXMgPyBudWxsIDogbmFtZUhhc2gpO1xuICB9XG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleHByZXNzaW9ucywgYW5kIHJldHVybnMgdGhlbSBhc1xuLy8gYW4gYXJyYXkuIGBjbG9zZWAgaXMgdGhlIHRva2VuIHR5cGUgdGhhdCBlbmRzIHRoZSBsaXN0LCBhbmRcbi8vIGBhbGxvd0VtcHR5YCBjYW4gYmUgdHVybmVkIG9uIHRvIGFsbG93IHN1YnNlcXVlbnQgY29tbWFzIHdpdGhcbi8vIG5vdGhpbmcgaW4gYmV0d2VlbiB0aGVtIHRvIGJlIHBhcnNlZCBhcyBgbnVsbGAgKHdoaWNoIGlzIG5lZWRlZFxuLy8gZm9yIGFycmF5IGxpdGVyYWxzKS5cblxucHAkMy5wYXJzZUV4cHJMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dFbXB0eSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKVxuICAgICAgeyBlbHQgPSBudWxsOyB9XG4gICAgZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgZWx0ID0gdGhpcy5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0OyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgfVxuICAgIGVsdHMucHVzaChlbHQpO1xuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQzLmNoZWNrVW5yZXNlcnZlZCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gIHZhciBlbmQgPSByZWYuZW5kO1xuICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7IH1cbiAgaWYgKHRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gIGlmICh0aGlzLmtleXdvcmRzLnRlc3QobmFtZSkpXG4gICAgeyB0aGlzLnJhaXNlKHN0YXJ0LCAoXCJVbmV4cGVjdGVkIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJ1wiKSk7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgJiZcbiAgICB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkgeyByZXR1cm4gfVxuICB2YXIgcmUgPSB0aGlzLnN0cmljdCA/IHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA6IHRoaXMucmVzZXJ2ZWRXb3JkcztcbiAgaWYgKHJlLnRlc3QobmFtZSkpIHtcbiAgICBpZiAoIXRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlIGtleXdvcmQgJ2F3YWl0JyBvdXRzaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCAoXCJUaGUga2V5d29yZCAnXCIgKyBuYW1lICsgXCInIGlzIHJlc2VydmVkXCIpKTtcbiAgfVxufTtcblxuLy8gUGFyc2UgdGhlIG5leHQgdG9rZW4gYXMgYW4gaWRlbnRpZmllci4gSWYgYGxpYmVyYWxgIGlzIHRydWUgKHVzZWRcbi8vIHdoZW4gcGFyc2luZyBwcm9wZXJ0aWVzKSwgaXQgd2lsbCBhbHNvIGNvbnZlcnQga2V5d29yZHMgaW50b1xuLy8gaWRlbnRpZmllcnMuXG5cbnBwJDMucGFyc2VJZGVudCA9IGZ1bmN0aW9uKGxpYmVyYWwsIGlzQmluZGluZykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG5cbiAgICAvLyBUbyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzLzU3NVxuICAgIC8vIGBjbGFzc2AgYW5kIGBmdW5jdGlvbmAga2V5d29yZHMgcHVzaCBuZXcgY29udGV4dCBpbnRvIHRoaXMuY29udGV4dC5cbiAgICAvLyBCdXQgdGhlcmUgaXMgbm8gY2hhbmNlIHRvIHBvcCB0aGUgY29udGV4dCBpZiB0aGUga2V5d29yZCBpcyBjb25zdW1lZCBhcyBhbiBpZGVudGlmaWVyIHN1Y2ggYXMgYSBwcm9wZXJ0eSBuYW1lLlxuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBhIGRvdCwgdGhpcyBkb2VzIG5vdCBhcHBseSBiZWNhdXNlIHRoZSBjb250ZXh0LW1hbmFnaW5nIGNvZGUgYWxyZWFkeSBpZ25vcmVkIHRoZSBrZXl3b3JkXG4gICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgaWYgKCFsaWJlcmFsKSB7XG4gICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSk7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IG5vZGUuc3RhcnQ7IH1cbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gUGFyc2VzIHlpZWxkIGV4cHJlc3Npb24gaW5zaWRlIGdlbmVyYXRvci5cblxucHAkMy5wYXJzZVlpZWxkID0gZnVuY3Rpb24obm9Jbikge1xuICBpZiAoIXRoaXMueWllbGRQb3MpIHsgdGhpcy55aWVsZFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RhciAmJiAhdGhpcy50eXBlLnN0YXJ0c0V4cHIpKSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJZaWVsZEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDMucGFyc2VBd2FpdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuYXdhaXRQb3MpIHsgdGhpcy5hd2FpdFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIilcbn07XG5cbnZhciBwcCQ0ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMgb24gcGFyc2UgZXJyb3JzLiBJdFxuLy8gdGFrZXMgYW4gb2Zmc2V0IGludGVnZXIgKGludG8gdGhlIGN1cnJlbnQgYGlucHV0YCkgdG8gaW5kaWNhdGVcbi8vIHRoZSBsb2NhdGlvbiBvZiB0aGUgZXJyb3IsIGF0dGFjaGVzIHRoZSBwb3NpdGlvbiB0byB0aGUgZW5kXG4vLyBvZiB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIHRoZW4gcmFpc2VzIGEgYFN5bnRheEVycm9yYCB3aXRoIHRoYXRcbi8vIG1lc3NhZ2UuXG5cbnBwJDQucmFpc2UgPSBmdW5jdGlvbihwb3MsIG1lc3NhZ2UpIHtcbiAgdmFyIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgZXJyLnBvcyA9IHBvczsgZXJyLmxvYyA9IGxvYzsgZXJyLnJhaXNlZEF0ID0gdGhpcy5wb3M7XG4gIHRocm93IGVyclxufTtcblxucHAkNC5yYWlzZVJlY292ZXJhYmxlID0gcHAkNC5yYWlzZTtcblxucHAkNC5jdXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0KVxuICB9XG59O1xuXG52YXIgcHAkNSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnZhciBTY29wZSA9IGZ1bmN0aW9uIFNjb3BlKGZsYWdzKSB7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgLy8gQSBsaXN0IG9mIHZhci1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIHRoaXMudmFyID0gW107XG4gIC8vIEEgbGlzdCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICB0aGlzLmxleGljYWwgPSBbXTtcbiAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBGdW5jdGlvbkRlY2xhcmF0aW9uIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbn07XG5cbi8vIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUga2VlcCB0cmFjayBvZiBkZWNsYXJlZCB2YXJpYWJsZXMgaW4gdGhlIGN1cnJlbnQgc2NvcGUgaW4gb3JkZXIgdG8gZGV0ZWN0IGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcy5cblxucHAkNS5lbnRlclNjb3BlID0gZnVuY3Rpb24oZmxhZ3MpIHtcbiAgdGhpcy5zY29wZVN0YWNrLnB1c2gobmV3IFNjb3BlKGZsYWdzKSk7XG59O1xuXG5wcCQ1LmV4aXRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG59O1xuXG4vLyBUaGUgc3BlYyBzYXlzOlxuLy8gPiBBdCB0aGUgdG9wIGxldmVsIG9mIGEgZnVuY3Rpb24sIG9yIHNjcmlwdCwgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGFyZVxuLy8gPiB0cmVhdGVkIGxpa2UgdmFyIGRlY2xhcmF0aW9ucyByYXRoZXIgdGhhbiBsaWtlIGxleGljYWwgZGVjbGFyYXRpb25zLlxucHAkNS50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHJldHVybiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgfHwgIXRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKVxufTtcblxucHAkNS5kZWNsYXJlTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIGJpbmRpbmdUeXBlLCBwb3MpIHtcbiAgdmFyIHJlZGVjbGFyZWQgPSBmYWxzZTtcbiAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIHJlZGVjbGFyZWQgPSBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLnZhci5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9TSU1QTEVfQ0FUQ0gpIHtcbiAgICB2YXIgc2NvcGUkMSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgc2NvcGUkMS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfRlVOQ1RJT04pIHtcbiAgICB2YXIgc2NvcGUkMiA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgaWYgKHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhcilcbiAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICBlbHNlXG4gICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlJDIudmFyLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgIHNjb3BlJDIuZnVuY3Rpb25zLnB1c2gobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHNjb3BlJDMgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUkMy5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSAmJiAhKChzY29wZSQzLmZsYWdzICYgU0NPUEVfU0lNUExFX0NBVENIKSAmJiBzY29wZSQzLmxleGljYWxbMF0gPT09IG5hbWUpIHx8XG4gICAgICAgICAgIXRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUoc2NvcGUkMykgJiYgc2NvcGUkMy5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIHJlZGVjbGFyZWQgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgc2NvcGUkMy52YXIucHVzaChuYW1lKTtcbiAgICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgICBpZiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1ZBUikgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIGlmIChyZWRlY2xhcmVkKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIChcIklkZW50aWZpZXIgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTsgfVxufTtcblxucHAkNS5jaGVja0xvY2FsRXhwb3J0ID0gZnVuY3Rpb24oaWQpIHtcbiAgLy8gc2NvcGUuZnVuY3Rpb25zIG11c3QgYmUgZW1wdHkgYXMgTW9kdWxlIGNvZGUgaXMgYWx3YXlzIHN0cmljdC5cbiAgaWYgKHRoaXMuc2NvcGVTdGFja1swXS5sZXhpY2FsLmluZGV4T2YoaWQubmFtZSkgPT09IC0xICYmXG4gICAgICB0aGlzLnNjb3BlU3RhY2tbMF0udmFyLmluZGV4T2YoaWQubmFtZSkgPT09IC0xKSB7XG4gICAgdGhpcy51bmRlZmluZWRFeHBvcnRzW2lkLm5hbWVdID0gaWQ7XG4gIH1cbn07XG5cbnBwJDUuY3VycmVudFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdXG59O1xuXG5wcCQ1LmN1cnJlbnRWYXJTY29wZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSKSB7IHJldHVybiBzY29wZSB9XG4gIH1cbn07XG5cbi8vIENvdWxkIGJlIHVzZWZ1bCBmb3IgYHRoaXNgLCBgbmV3LnRhcmdldGAsIGBzdXBlcigpYCwgYHN1cGVyLnByb3BlcnR5YCwgYW5kIGBzdXBlcltwcm9wZXJ0eV1gLlxucHAkNS5jdXJyZW50VGhpc1Njb3BlID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9WQVIgJiYgIShzY29wZS5mbGFncyAmIFNDT1BFX0FSUk9XKSkgeyByZXR1cm4gc2NvcGUgfVxuICB9XG59O1xuXG52YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUocGFyc2VyLCBwb3MsIGxvYykge1xuICB0aGlzLnR5cGUgPSBcIlwiO1xuICB0aGlzLnN0YXJ0ID0gcG9zO1xuICB0aGlzLmVuZCA9IDA7XG4gIGlmIChwYXJzZXIub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgaWYgKHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpXG4gICAgeyB0aGlzLnNvdXJjZUZpbGUgPSBwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgeyB0aGlzLnJhbmdlID0gW3BvcywgMF07IH1cbn07XG5cbi8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbnZhciBwcCQ2ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkNi5zdGFydE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG59O1xuXG5wcCQ2LnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24ocG9zLCBsb2MpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxufTtcblxuLy8gRmluaXNoIGFuIEFTVCBub2RlLCBhZGRpbmcgYHR5cGVgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzLlxuXG5mdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgbm9kZS50eXBlID0gdHlwZTtcbiAgbm9kZS5lbmQgPSBwb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgbm9kZS5sb2MuZW5kID0gbG9jOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICByZXR1cm4gbm9kZVxufVxuXG5wcCQ2LmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCB0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYylcbn07XG5cbi8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbnBwJDYuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHBvcywgbG9jKVxufTtcblxuLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuXG52YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICB0aGlzLnRva2VuID0gdG9rZW47XG4gIHRoaXMuaXNFeHByID0gISFpc0V4cHI7XG4gIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICB0aGlzLmdlbmVyYXRvciA9ICEhZ2VuZXJhdG9yO1xufTtcblxudmFyIHR5cGVzJDEgPSB7XG4gIGJfc3RhdDogbmV3IFRva0NvbnRleHQoXCJ7XCIsIGZhbHNlKSxcbiAgYl9leHByOiBuZXcgVG9rQ29udGV4dChcIntcIiwgdHJ1ZSksXG4gIGJfdG1wbDogbmV3IFRva0NvbnRleHQoXCIke1wiLCBmYWxzZSksXG4gIHBfc3RhdDogbmV3IFRva0NvbnRleHQoXCIoXCIsIGZhbHNlKSxcbiAgcF9leHByOiBuZXcgVG9rQ29udGV4dChcIihcIiwgdHJ1ZSksXG4gIHFfdG1wbDogbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuKCk7IH0pLFxuICBmX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UpLFxuICBmX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSksXG4gIGZfZXhwcl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSwgZmFsc2UsIG51bGwsIHRydWUpLFxuICBmX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSwgZmFsc2UsIG51bGwsIHRydWUpXG59O1xuXG52YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnBwJDcuaW5pdGlhbENvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFt0eXBlcyQxLmJfc3RhdF1cbn07XG5cbnBwJDcuYnJhY2VJc0Jsb2NrID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICBpZiAocGFyZW50ID09PSB0eXBlcyQxLmZfZXhwciB8fCBwYXJlbnQgPT09IHR5cGVzJDEuZl9zdGF0KVxuICAgIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uICYmIChwYXJlbnQgPT09IHR5cGVzJDEuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMkMS5iX2V4cHIpKVxuICAgIHsgcmV0dXJuICFwYXJlbnQuaXNFeHByIH1cblxuICAvLyBUaGUgY2hlY2sgZm9yIGB0dC5uYW1lICYmIGV4cHJBbGxvd2VkYCBkZXRlY3RzIHdoZXRoZXIgd2UgYXJlXG4gIC8vIGFmdGVyIGEgYHlpZWxkYCBvciBgb2ZgIGNvbnN0cnVjdC4gU2VlIHRoZSBgdXBkYXRlQ29udGV4dGAgZm9yXG4gIC8vIGB0dC5uYW1lYC5cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fcmV0dXJuIHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgeyByZXR1cm4gbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzLnNlbWkgfHwgcHJldlR5cGUgPT09IHR5cGVzLmVvZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMucGFyZW5SIHx8IHByZXZUeXBlID09PSB0eXBlcy5hcnJvdylcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5icmFjZUwpXG4gICAgeyByZXR1cm4gcGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG59O1xuXG5wcCQ3LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRbaV07XG4gICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbnBwJDcudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT09IHR5cGVzLmRvdClcbiAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICBlbHNlIGlmICh1cGRhdGUgPSB0eXBlLnVwZGF0ZUNvbnRleHQpXG4gICAgeyB1cGRhdGUuY2FsbCh0aGlzLCBwcmV2VHlwZSk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjsgfVxufTtcblxuLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG50eXBlcy5wYXJlblIudXBkYXRlQ29udGV4dCA9IHR5cGVzLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgaWYgKG91dCA9PT0gdHlwZXMkMS5iX3N0YXQgJiYgdGhpcy5jdXJDb250ZXh0KCkudG9rZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gIW91dC5pc0V4cHI7XG59O1xuXG50eXBlcy5icmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzJDEuYl9zdGF0IDogdHlwZXMkMS5iX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLmRvbGxhckJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuYl90bXBsKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBzdGF0ZW1lbnRQYXJlbnMgPSBwcmV2VHlwZSA9PT0gdHlwZXMuX2lmIHx8IHByZXZUeXBlID09PSB0eXBlcy5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2l0aCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3doaWxlO1xuICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcyQxLnBfc3RhdCA6IHR5cGVzJDEucF9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5pbmNEZWMudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbn07XG5cbnR5cGVzLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMuX2NsYXNzLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuc2VtaSAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuX2Vsc2UgJiZcbiAgICAgICEocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gJiYgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSkgJiZcbiAgICAgICEoKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5iX3N0YXQpKVxuICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX2V4cHIpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9zdGF0KTsgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG50eXBlcy5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEucV90bXBsKVxuICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEucV90bXBsKTsgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG50eXBlcy5zdGFyLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxO1xuICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcyQxLmZfZXhwcilcbiAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9leHByX2dlbjsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9nZW47IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLm5hbWUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuZG90KSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICB0aGlzLnZhbHVlID09PSBcInlpZWxkXCIgJiYgdGhpcy5pbkdlbmVyYXRvckNvbnRleHQoKSlcbiAgICAgIHsgYWxsb3dlZCA9IHRydWU7IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gYWxsb3dlZDtcbn07XG5cbi8vIFRoaXMgZmlsZSBjb250YWlucyBVbmljb2RlIHByb3BlcnRpZXMgZXh0cmFjdGVkIGZyb20gdGhlIEVDTUFTY3JpcHRcbi8vIHNwZWNpZmljYXRpb24uIFRoZSBsaXN0cyBhcmUgZXh0cmFjdGVkIGxpa2Ugc286XG4vLyAkJCgnI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXMgPiBmaWd1cmUgPiB0YWJsZSA+IHRib2R5ID4gdHIgPiB0ZDpudGgtY2hpbGQoMSkgY29kZScpLm1hcChlbCA9PiBlbC5pbm5lclRleHQpXG5cbi8vICN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzXG52YXIgZWNtYTlCaW5hcnlQcm9wZXJ0aWVzID0gXCJBU0NJSSBBU0NJSV9IZXhfRGlnaXQgQUhleCBBbHBoYWJldGljIEFscGhhIEFueSBBc3NpZ25lZCBCaWRpX0NvbnRyb2wgQmlkaV9DIEJpZGlfTWlycm9yZWQgQmlkaV9NIENhc2VfSWdub3JhYmxlIENJIENhc2VkIENoYW5nZXNfV2hlbl9DYXNlZm9sZGVkIENXQ0YgQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQgQ1dDTSBDaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCBDV0wgQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZCBDV0tDRiBDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCBDV1QgQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQgQ1dVIERhc2ggRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBESSBEZXByZWNhdGVkIERlcCBEaWFjcml0aWMgRGlhIEVtb2ppIEVtb2ppX0NvbXBvbmVudCBFbW9qaV9Nb2RpZmllciBFbW9qaV9Nb2RpZmllcl9CYXNlIEVtb2ppX1ByZXNlbnRhdGlvbiBFeHRlbmRlciBFeHQgR3JhcGhlbWVfQmFzZSBHcl9CYXNlIEdyYXBoZW1lX0V4dGVuZCBHcl9FeHQgSGV4X0RpZ2l0IEhleCBJRFNfQmluYXJ5X09wZXJhdG9yIElEU0IgSURTX1RyaW5hcnlfT3BlcmF0b3IgSURTVCBJRF9Db250aW51ZSBJREMgSURfU3RhcnQgSURTIElkZW9ncmFwaGljIElkZW8gSm9pbl9Db250cm9sIEpvaW5fQyBMb2dpY2FsX09yZGVyX0V4Y2VwdGlvbiBMT0UgTG93ZXJjYXNlIExvd2VyIE1hdGggTm9uY2hhcmFjdGVyX0NvZGVfUG9pbnQgTkNoYXIgUGF0dGVybl9TeW50YXggUGF0X1N5biBQYXR0ZXJuX1doaXRlX1NwYWNlIFBhdF9XUyBRdW90YXRpb25fTWFyayBRTWFyayBSYWRpY2FsIFJlZ2lvbmFsX0luZGljYXRvciBSSSBTZW50ZW5jZV9UZXJtaW5hbCBTVGVybSBTb2Z0X0RvdHRlZCBTRCBUZXJtaW5hbF9QdW5jdHVhdGlvbiBUZXJtIFVuaWZpZWRfSWRlb2dyYXBoIFVJZGVvIFVwcGVyY2FzZSBVcHBlciBWYXJpYXRpb25fU2VsZWN0b3IgVlMgV2hpdGVfU3BhY2Ugc3BhY2UgWElEX0NvbnRpbnVlIFhJREMgWElEX1N0YXJ0IFhJRFNcIjtcbnZhciBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTlCaW5hcnlQcm9wZXJ0aWVzICsgXCIgRXh0ZW5kZWRfUGljdG9ncmFwaGljXCI7XG52YXIgZWNtYTExQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMEJpbmFyeVByb3BlcnRpZXM7XG52YXIgdW5pY29kZUJpbmFyeVByb3BlcnRpZXMgPSB7XG4gIDk6IGVjbWE5QmluYXJ5UHJvcGVydGllcyxcbiAgMTA6IGVjbWExMEJpbmFyeVByb3BlcnRpZXMsXG4gIDExOiBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzXG59O1xuXG4vLyAjdGFibGUtdW5pY29kZS1nZW5lcmFsLWNhdGVnb3J5LXZhbHVlc1xudmFyIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMgPSBcIkNhc2VkX0xldHRlciBMQyBDbG9zZV9QdW5jdHVhdGlvbiBQZSBDb25uZWN0b3JfUHVuY3R1YXRpb24gUGMgQ29udHJvbCBDYyBjbnRybCBDdXJyZW5jeV9TeW1ib2wgU2MgRGFzaF9QdW5jdHVhdGlvbiBQZCBEZWNpbWFsX051bWJlciBOZCBkaWdpdCBFbmNsb3NpbmdfTWFyayBNZSBGaW5hbF9QdW5jdHVhdGlvbiBQZiBGb3JtYXQgQ2YgSW5pdGlhbF9QdW5jdHVhdGlvbiBQaSBMZXR0ZXIgTCBMZXR0ZXJfTnVtYmVyIE5sIExpbmVfU2VwYXJhdG9yIFpsIExvd2VyY2FzZV9MZXR0ZXIgTGwgTWFyayBNIENvbWJpbmluZ19NYXJrIE1hdGhfU3ltYm9sIFNtIE1vZGlmaWVyX0xldHRlciBMbSBNb2RpZmllcl9TeW1ib2wgU2sgTm9uc3BhY2luZ19NYXJrIE1uIE51bWJlciBOIE9wZW5fUHVuY3R1YXRpb24gUHMgT3RoZXIgQyBPdGhlcl9MZXR0ZXIgTG8gT3RoZXJfTnVtYmVyIE5vIE90aGVyX1B1bmN0dWF0aW9uIFBvIE90aGVyX1N5bWJvbCBTbyBQYXJhZ3JhcGhfU2VwYXJhdG9yIFpwIFByaXZhdGVfVXNlIENvIFB1bmN0dWF0aW9uIFAgcHVuY3QgU2VwYXJhdG9yIFogU3BhY2VfU2VwYXJhdG9yIFpzIFNwYWNpbmdfTWFyayBNYyBTdXJyb2dhdGUgQ3MgU3ltYm9sIFMgVGl0bGVjYXNlX0xldHRlciBMdCBVbmFzc2lnbmVkIENuIFVwcGVyY2FzZV9MZXR0ZXIgTHVcIjtcblxuLy8gI3RhYmxlLXVuaWNvZGUtc2NyaXB0LXZhbHVlc1xudmFyIGVjbWE5U2NyaXB0VmFsdWVzID0gXCJBZGxhbSBBZGxtIEFob20gQWhvbSBBbmF0b2xpYW5fSGllcm9nbHlwaHMgSGx1dyBBcmFiaWMgQXJhYiBBcm1lbmlhbiBBcm1uIEF2ZXN0YW4gQXZzdCBCYWxpbmVzZSBCYWxpIEJhbXVtIEJhbXUgQmFzc2FfVmFoIEJhc3MgQmF0YWsgQmF0ayBCZW5nYWxpIEJlbmcgQmhhaWtzdWtpIEJoa3MgQm9wb21vZm8gQm9wbyBCcmFobWkgQnJhaCBCcmFpbGxlIEJyYWkgQnVnaW5lc2UgQnVnaSBCdWhpZCBCdWhkIENhbmFkaWFuX0Fib3JpZ2luYWwgQ2FucyBDYXJpYW4gQ2FyaSBDYXVjYXNpYW5fQWxiYW5pYW4gQWdoYiBDaGFrbWEgQ2FrbSBDaGFtIENoYW0gQ2hlcm9rZWUgQ2hlciBDb21tb24gWnl5eSBDb3B0aWMgQ29wdCBRYWFjIEN1bmVpZm9ybSBYc3V4IEN5cHJpb3QgQ3BydCBDeXJpbGxpYyBDeXJsIERlc2VyZXQgRHNydCBEZXZhbmFnYXJpIERldmEgRHVwbG95YW4gRHVwbCBFZ3lwdGlhbl9IaWVyb2dseXBocyBFZ3lwIEVsYmFzYW4gRWxiYSBFdGhpb3BpYyBFdGhpIEdlb3JnaWFuIEdlb3IgR2xhZ29saXRpYyBHbGFnIEdvdGhpYyBHb3RoIEdyYW50aGEgR3JhbiBHcmVlayBHcmVrIEd1amFyYXRpIEd1anIgR3VybXVraGkgR3VydSBIYW4gSGFuaSBIYW5ndWwgSGFuZyBIYW51bm9vIEhhbm8gSGF0cmFuIEhhdHIgSGVicmV3IEhlYnIgSGlyYWdhbmEgSGlyYSBJbXBlcmlhbF9BcmFtYWljIEFybWkgSW5oZXJpdGVkIFppbmggUWFhaSBJbnNjcmlwdGlvbmFsX1BhaGxhdmkgUGhsaSBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuIFBydGkgSmF2YW5lc2UgSmF2YSBLYWl0aGkgS3RoaSBLYW5uYWRhIEtuZGEgS2F0YWthbmEgS2FuYSBLYXlhaF9MaSBLYWxpIEtoYXJvc2h0aGkgS2hhciBLaG1lciBLaG1yIEtob2praSBLaG9qIEtodWRhd2FkaSBTaW5kIExhbyBMYW9vIExhdGluIExhdG4gTGVwY2hhIExlcGMgTGltYnUgTGltYiBMaW5lYXJfQSBMaW5hIExpbmVhcl9CIExpbmIgTGlzdSBMaXN1IEx5Y2lhbiBMeWNpIEx5ZGlhbiBMeWRpIE1haGFqYW5pIE1haGogTWFsYXlhbGFtIE1seW0gTWFuZGFpYyBNYW5kIE1hbmljaGFlYW4gTWFuaSBNYXJjaGVuIE1hcmMgTWFzYXJhbV9Hb25kaSBHb25tIE1lZXRlaV9NYXllayBNdGVpIE1lbmRlX0tpa2FrdWkgTWVuZCBNZXJvaXRpY19DdXJzaXZlIE1lcmMgTWVyb2l0aWNfSGllcm9nbHlwaHMgTWVybyBNaWFvIFBscmQgTW9kaSBNb2RpIE1vbmdvbGlhbiBNb25nIE1ybyBNcm9vIE11bHRhbmkgTXVsdCBNeWFubWFyIE15bXIgTmFiYXRhZWFuIE5iYXQgTmV3X1RhaV9MdWUgVGFsdSBOZXdhIE5ld2EgTmtvIE5rb28gTnVzaHUgTnNodSBPZ2hhbSBPZ2FtIE9sX0NoaWtpIE9sY2sgT2xkX0h1bmdhcmlhbiBIdW5nIE9sZF9JdGFsaWMgSXRhbCBPbGRfTm9ydGhfQXJhYmlhbiBOYXJiIE9sZF9QZXJtaWMgUGVybSBPbGRfUGVyc2lhbiBYcGVvIE9sZF9Tb3V0aF9BcmFiaWFuIFNhcmIgT2xkX1R1cmtpYyBPcmtoIE9yaXlhIE9yeWEgT3NhZ2UgT3NnZSBPc21hbnlhIE9zbWEgUGFoYXdoX0htb25nIEhtbmcgUGFsbXlyZW5lIFBhbG0gUGF1X0Npbl9IYXUgUGF1YyBQaGFnc19QYSBQaGFnIFBob2VuaWNpYW4gUGhueCBQc2FsdGVyX1BhaGxhdmkgUGhscCBSZWphbmcgUmpuZyBSdW5pYyBSdW5yIFNhbWFyaXRhbiBTYW1yIFNhdXJhc2h0cmEgU2F1ciBTaGFyYWRhIFNocmQgU2hhdmlhbiBTaGF3IFNpZGRoYW0gU2lkZCBTaWduV3JpdGluZyBTZ253IFNpbmhhbGEgU2luaCBTb3JhX1NvbXBlbmcgU29yYSBTb3lvbWJvIFNveW8gU3VuZGFuZXNlIFN1bmQgU3lsb3RpX05hZ3JpIFN5bG8gU3lyaWFjIFN5cmMgVGFnYWxvZyBUZ2xnIFRhZ2JhbndhIFRhZ2IgVGFpX0xlIFRhbGUgVGFpX1RoYW0gTGFuYSBUYWlfVmlldCBUYXZ0IFRha3JpIFRha3IgVGFtaWwgVGFtbCBUYW5ndXQgVGFuZyBUZWx1Z3UgVGVsdSBUaGFhbmEgVGhhYSBUaGFpIFRoYWkgVGliZXRhbiBUaWJ0IFRpZmluYWdoIFRmbmcgVGlyaHV0YSBUaXJoIFVnYXJpdGljIFVnYXIgVmFpIFZhaWkgV2FyYW5nX0NpdGkgV2FyYSBZaSBZaWlpIFphbmFiYXphcl9TcXVhcmUgWmFuYlwiO1xudmFyIGVjbWExMFNjcmlwdFZhbHVlcyA9IGVjbWE5U2NyaXB0VmFsdWVzICsgXCIgRG9ncmEgRG9nciBHdW5qYWxhX0dvbmRpIEdvbmcgSGFuaWZpX1JvaGluZ3lhIFJvaGcgTWFrYXNhciBNYWthIE1lZGVmYWlkcmluIE1lZGYgT2xkX1NvZ2RpYW4gU29nbyBTb2dkaWFuIFNvZ2RcIjtcbnZhciBlY21hMTFTY3JpcHRWYWx1ZXMgPSBlY21hMTBTY3JpcHRWYWx1ZXMgKyBcIiBFbHltYWljIEVseW0gTmFuZGluYWdhcmkgTmFuZCBOeWlha2VuZ19QdWFjaHVlX0htb25nIEhtbnAgV2FuY2hvIFdjaG9cIjtcbnZhciB1bmljb2RlU2NyaXB0VmFsdWVzID0ge1xuICA5OiBlY21hOVNjcmlwdFZhbHVlcyxcbiAgMTA6IGVjbWExMFNjcmlwdFZhbHVlcyxcbiAgMTE6IGVjbWExMVNjcmlwdFZhbHVlc1xufTtcblxudmFyIGRhdGEgPSB7fTtcbmZ1bmN0aW9uIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pIHtcbiAgdmFyIGQgPSBkYXRhW2VjbWFWZXJzaW9uXSA9IHtcbiAgICBiaW5hcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzW2VjbWFWZXJzaW9uXSArIFwiIFwiICsgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgbm9uQmluYXJ5OiB7XG4gICAgICBHZW5lcmFsX0NhdGVnb3J5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICAgIFNjcmlwdDogd29yZHNSZWdleHAodW5pY29kZVNjcmlwdFZhbHVlc1tlY21hVmVyc2lvbl0pXG4gICAgfVxuICB9O1xuICBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcblxuICBkLm5vbkJpbmFyeS5nYyA9IGQubm9uQmluYXJ5LkdlbmVyYWxfQ2F0ZWdvcnk7XG4gIGQubm9uQmluYXJ5LnNjID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuICBkLm5vbkJpbmFyeS5zY3ggPSBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucztcbn1cbmJ1aWxkVW5pY29kZURhdGEoOSk7XG5idWlsZFVuaWNvZGVEYXRhKDEwKTtcbmJ1aWxkVW5pY29kZURhdGEoMTEpO1xuXG52YXIgcHAkOCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnZhciBSZWdFeHBWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiBSZWdFeHBWYWxpZGF0aW9uU3RhdGUocGFyc2VyKSB7XG4gIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB0aGlzLnZhbGlkRmxhZ3MgPSBcImdpbVwiICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyBcInV5XCIgOiBcIlwiKSArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ID8gXCJzXCIgOiBcIlwiKTtcbiAgdGhpcy51bmljb2RlUHJvcGVydGllcyA9IGRhdGFbcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgPyAxMSA6IHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uXTtcbiAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICB0aGlzLmZsYWdzID0gXCJcIjtcbiAgdGhpcy5zdGFydCA9IDA7XG4gIHRoaXMuc3dpdGNoVSA9IGZhbHNlO1xuICB0aGlzLnN3aXRjaE4gPSBmYWxzZTtcbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHRoaXMubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgdGhpcy5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgdGhpcy5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICB0aGlzLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICB0aGlzLmdyb3VwTmFtZXMgPSBbXTtcbiAgdGhpcy5iYWNrUmVmZXJlbmNlTmFtZXMgPSBbXTtcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKSB7XG4gIHZhciB1bmljb2RlID0gZmxhZ3MuaW5kZXhPZihcInVcIikgIT09IC0xO1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQgfCAwO1xuICB0aGlzLnNvdXJjZSA9IHBhdHRlcm4gKyBcIlwiO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIHRoaXMuc3dpdGNoVSA9IHVuaWNvZGUgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICB0aGlzLnN3aXRjaE4gPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOTtcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmFpc2UgPSBmdW5jdGlvbiByYWlzZSAobWVzc2FnZSkge1xuICB0aGlzLnBhcnNlci5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIChcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvXCIgKyAodGhpcy5zb3VyY2UpICsgXCIvOiBcIiArIG1lc3NhZ2UpKTtcbn07XG5cbi8vIElmIHUgZmxhZyBpcyBnaXZlbiwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBpbmRleCAoaXQgY29tYmluZXMgYSBzdXJyb2dhdGUgcGFpcikuXG4vLyBPdGhlcndpc2UsIHRoaXMgcmV0dXJucyB0aGUgY29kZSB1bml0IG9mIHRoZSBpbmRleCAoY2FuIGJlIGEgcGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyKS5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaSkge1xuICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICB2YXIgbCA9IHMubGVuZ3RoO1xuICBpZiAoaSA+PSBsKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gIGlmICghdGhpcy5zd2l0Y2hVIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwpIHtcbiAgICByZXR1cm4gY1xuICB9XG4gIHZhciBuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgcmV0dXJuIG5leHQgPj0gMHhEQzAwICYmIG5leHQgPD0gMHhERkZGID8gKGMgPDwgMTApICsgbmV4dCAtIDB4MzVGREMwMCA6IGNcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubmV4dEluZGV4ID0gZnVuY3Rpb24gbmV4dEluZGV4IChpKSB7XG4gIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gIHZhciBsID0gcy5sZW5ndGg7XG4gIGlmIChpID49IGwpIHtcbiAgICByZXR1cm4gbFxuICB9XG4gIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpLCBuZXh0O1xuICBpZiAoIXRoaXMuc3dpdGNoVSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsIHx8XG4gICAgICAobmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhEQzAwIHx8IG5leHQgPiAweERGRkYpIHtcbiAgICByZXR1cm4gaSArIDFcbiAgfVxuICByZXR1cm4gaSArIDJcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQgKCkge1xuICByZXR1cm4gdGhpcy5hdCh0aGlzLnBvcylcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkICgpIHtcbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5uZXh0SW5kZXgodGhpcy5wb3MpKVxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gYWR2YW5jZSAoKSB7XG4gIHRoaXMucG9zID0gdGhpcy5uZXh0SW5kZXgodGhpcy5wb3MpO1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKGNoKSB7XG4gIGlmICh0aGlzLmN1cnJlbnQoKSA9PT0gY2gpIHtcbiAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmcoY2gpIHtcbiAgaWYgKGNoIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCkgfVxuICBjaCAtPSAweDEwMDAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY2ggPj4gMTApICsgMHhEODAwLCAoY2ggJiAweDAzRkYpICsgMHhEQzAwKVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBmbGFncyBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5wcCQ4LnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgdmFsaWRGbGFncyA9IHN0YXRlLnZhbGlkRmxhZ3M7XG4gIHZhciBmbGFncyA9IHN0YXRlLmZsYWdzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZmxhZyA9IGZsYWdzLmNoYXJBdChpKTtcbiAgICBpZiAodmFsaWRGbGFncy5pbmRleE9mKGZsYWcpID09PSAtMSkge1xuICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MuaW5kZXhPZihmbGFnLCBpICsgMSkgPiAtMSkge1xuICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBwYXR0ZXJuIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbnBwJDgudmFsaWRhdGVSZWdFeHBQYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG5cbiAgLy8gVGhlIGdvYWwgc3ltYm9sIGZvciB0aGUgcGFyc2UgaXMgfFBhdHRlcm5bflUsIH5OXXwuIElmIHRoZSByZXN1bHQgb2ZcbiAgLy8gcGFyc2luZyBjb250YWlucyBhIHxHcm91cE5hbWV8LCByZXBhcnNlIHdpdGggdGhlIGdvYWwgc3ltYm9sXG4gIC8vIHxQYXR0ZXJuW35VLCArTl18IGFuZCB1c2UgdGhpcyByZXN1bHQgaW5zdGVhZC4gVGhyb3cgYSAqU3ludGF4RXJyb3IqXG4gIC8vIGV4Y2VwdGlvbiBpZiBfUF8gZGlkIG5vdCBjb25mb3JtIHRvIHRoZSBncmFtbWFyLCBpZiBhbnkgZWxlbWVudHMgb2YgX1BfXG4gIC8vIHdlcmUgbm90IG1hdGNoZWQgYnkgdGhlIHBhcnNlLCBvciBpZiBhbnkgRWFybHkgRXJyb3IgY29uZGl0aW9ucyBleGlzdC5cbiAgaWYgKCFzdGF0ZS5zd2l0Y2hOICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID4gMCkge1xuICAgIHN0YXRlLnN3aXRjaE4gPSB0cnVlO1xuICAgIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1QYXR0ZXJuXG5wcCQ4LnJlZ2V4cF9wYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUucG9zID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA9IDA7XG4gIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5sZW5ndGggPSAwO1xuXG4gIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcblxuICBpZiAoc3RhdGUucG9zICE9PSBzdGF0ZS5zb3VyY2UubGVuZ3RoKSB7XG4gICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlcyBhcyBWOC5cbiAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiVW5tYXRjaGVkICcpJ1wiKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDVEIC8qIFsgKi8pIHx8IHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPiBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBuYW1lID0gbGlzdFtpXTtcblxuICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgY2FwdHVyZSByZWZlcmVuY2VkXCIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGlzanVuY3Rpb25cbnBwJDgucmVnZXhwX2Rpc2p1bmN0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICB3aGlsZSAoc3RhdGUuZWF0KDB4N0MgLyogfCAqLykpIHtcbiAgICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gIH1cblxuICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gIH1cbiAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUFsdGVybmF0aXZlXG5wcCQ4LnJlZ2V4cF9hbHRlcm5hdGl2ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGF0ZS5zb3VyY2UubGVuZ3RoICYmIHRoaXMucmVnZXhwX2VhdFRlcm0oc3RhdGUpKVxuICAgIHsgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLVRlcm1cbnBwJDgucmVnZXhwX2VhdFRlcm0gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAodGhpcy5yZWdleHBfZWF0QXNzZXJ0aW9uKHN0YXRlKSkge1xuICAgIC8vIEhhbmRsZSBgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uIFF1YW50aWZpZXJgIGFsdGVybmF0aXZlLlxuICAgIC8vIGBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGVgIGlzIHRydWUgaWYgdGhlIGxhc3QgZWF0ZW4gQXNzZXJ0aW9uXG4gICAgLy8gaXMgYSBRdWFudGlmaWFibGVBc3NlcnRpb24uXG4gICAgaWYgKHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSAmJiB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKSkge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHF1YW50aWZpZXJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoc3RhdGUuc3dpdGNoVSA/IHRoaXMucmVnZXhwX2VhdEF0b20oc3RhdGUpIDogdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tKHN0YXRlKSkge1xuICAgIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1Bc3NlcnRpb25cbnBwJDgucmVnZXhwX2VhdEFzc2VydGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG5cbiAgLy8gXiwgJFxuICBpZiAoc3RhdGUuZWF0KDB4NUUgLyogXiAqLykgfHwgc3RhdGUuZWF0KDB4MjQgLyogJCAqLykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gXFxiIFxcQlxuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDQyIC8qIEIgKi8pIHx8IHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIC8vIExvb2thaGVhZCAvIExvb2tiZWhpbmRcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pICYmIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgdmFyIGxvb2tiZWhpbmQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIGxvb2tiZWhpbmQgPSBzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDNEIC8qID0gKi8pIHx8IHN0YXRlLmVhdCgweDIxIC8qICEgKi8pKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICBpZiAoIXN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gIWxvb2tiZWhpbmQ7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJcbnBwJDgucmVnZXhwX2VhdFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICBpZiAoIG5vRXJyb3IgPT09IHZvaWQgMCApIG5vRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeChzdGF0ZSwgbm9FcnJvcikpIHtcbiAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclByZWZpeFxucHAkOC5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeCA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGUuZWF0KDB4MkEgLyogKiAqLykgfHxcbiAgICBzdGF0ZS5lYXQoMHgyQiAvKiArICovKSB8fFxuICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgbm9FcnJvcilcbiAgKVxufTtcbnBwJDgucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgIHZhciBtaW4gPSAwLCBtYXggPSAtMTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgIG1pbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyQyAvKiAsICovKSAmJiB0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgICBtYXggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgICAgLy8gU3ludGF4RXJyb3IgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3NlYy10ZXJtXG4gICAgICAgIGlmIChtYXggIT09IC0xICYmIG1heCA8IG1pbiAmJiAhbm9FcnJvcikge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwibnVtYmVycyBvdXQgb2Ygb3JkZXIgaW4ge30gcXVhbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAhbm9FcnJvcikge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbmNvbXBsZXRlIHF1YW50aWZpZXJcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQXRvbVxucHAkOC5yZWdleHBfZWF0QXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMoc3RhdGUpIHx8XG4gICAgc3RhdGUuZWF0KDB4MkUgLyogLiAqLykgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSlcbiAgKVxufTtcbnBwJDgucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBdG9tRXNjYXBlKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOC5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pICYmIHN0YXRlLmVhdCgweDNBIC8qIDogKi8pKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgdGhpcy5yZWdleHBfZ3JvdXBTcGVjaWZpZXIoc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDNGIC8qID8gKi8pIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICB9XG4gICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zICs9IDE7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1FeHRlbmRlZEF0b21cbnBwJDgucmVnZXhwX2VhdEV4dGVuZGVkQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGUuZWF0KDB4MkUgLyogLiAqLykgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllcihzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIoc3RhdGUpXG4gIClcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JbnZhbGlkQnJhY2VkUXVhbnRpZmllclxucHAkOC5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAodGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtU3ludGF4Q2hhcmFjdGVyXG5wcCQ4LnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1N5bnRheENoYXJhY3RlcihjaCkge1xuICByZXR1cm4gKFxuICAgIGNoID09PSAweDI0IC8qICQgKi8gfHxcbiAgICBjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovIHx8XG4gICAgY2ggPT09IDB4MkUgLyogLiAqLyB8fFxuICAgIGNoID09PSAweDNGIC8qID8gKi8gfHxcbiAgICBjaCA+PSAweDVCIC8qIFsgKi8gJiYgY2ggPD0gMHg1RSAvKiBeICovIHx8XG4gICAgY2ggPj0gMHg3QiAvKiB7ICovICYmIGNoIDw9IDB4N0QgLyogfSAqL1xuICApXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5DaGFyYWN0ZXJcbi8vIEJ1dCBlYXQgZWFnZXIuXG5wcCQ4LnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgIT09IC0xICYmICFpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1FeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXJcbnBwJDgucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKFxuICAgIGNoICE9PSAtMSAmJlxuICAgIGNoICE9PSAweDI0IC8qICQgKi8gJiZcbiAgICAhKGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8pICYmXG4gICAgY2ggIT09IDB4MkUgLyogLiAqLyAmJlxuICAgIGNoICE9PSAweDNGIC8qID8gKi8gJiZcbiAgICBjaCAhPT0gMHg1QiAvKiBbICovICYmXG4gICAgY2ggIT09IDB4NUUgLyogXiAqLyAmJlxuICAgIGNoICE9PSAweDdDIC8qIHwgKi9cbiAgKSB7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBHcm91cFNwZWNpZmllcltVXSA6OlxuLy8gICBbZW1wdHldXG4vLyAgIGA/YCBHcm91cE5hbWVbP1VdXG5wcCQ4LnJlZ2V4cF9ncm91cFNwZWNpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmdyb3VwTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgfVxufTtcblxuLy8gR3JvdXBOYW1lW1VdIDo6XG4vLyAgIGA8YCBSZWdFeHBJZGVudGlmaWVyTmFtZVs/VV0gYD5gXG4vLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbnBwJDgucmVnZXhwX2VhdEdyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIGlmIChzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0UgLyogPiAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZWdFeHBJZGVudGlmaWVyTmFtZVtVXSA6OlxuLy8gICBSZWdFeHBJZGVudGlmaWVyU3RhcnRbP1VdXG4vLyAgIFJlZ0V4cElkZW50aWZpZXJOYW1lWz9VXSBSZWdFeHBJZGVudGlmaWVyUGFydFs/VV1cbi8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxucHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0KHN0YXRlKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydChzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gUmVnRXhwSWRlbnRpZmllclN0YXJ0W1VdIDo6XG4vLyAgIFVuaWNvZGVJRFN0YXJ0XG4vLyAgIGAkYFxuLy8gICBgX2Bcbi8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbP1VdXG5wcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgc3RhdGUuYWR2YW5jZSgpO1xuXG4gIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB7XG4gICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gIH1cbiAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgcmV0dXJuIGlzSWRlbnRpZmllclN0YXJ0KGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbn1cblxuLy8gUmVnRXhwSWRlbnRpZmllclBhcnRbVV0gOjpcbi8vICAgVW5pY29kZUlEQ29udGludWVcbi8vICAgYCRgXG4vLyAgIGBfYFxuLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVs/VV1cbi8vICAgPFpXTko+XG4vLyAgIDxaV0o+XG5wcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBzdGF0ZS5hZHZhbmNlKCk7XG5cbiAgaWYgKGNoID09PSAweDVDIC8qIFxcICovICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHtcbiAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgfVxuICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgcmV0dXJuIGlzSWRlbnRpZmllckNoYXIoY2gsIHRydWUpIHx8IGNoID09PSAweDI0IC8qICQgKi8gfHwgY2ggPT09IDB4NUYgLyogXyAqLyB8fCBjaCA9PT0gMHgyMDBDIC8qIDxaV05KPiAqLyB8fCBjaCA9PT0gMHgyMDBEIC8qIDxaV0o+ICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1BdG9tRXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXRBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKFxuICAgIHRoaXMucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2Uoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgIChzdGF0ZS5zd2l0Y2hOICYmIHRoaXMucmVnZXhwX2VhdEtHcm91cE5hbWUoc3RhdGUpKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4NjMgLyogYyAqLykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDgucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlKHN0YXRlKSkge1xuICAgIHZhciBuID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAvLyBGb3IgU3ludGF4RXJyb3IgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3NlYy1hdG9tZXNjYXBlXG4gICAgICBpZiAobiA+IHN0YXRlLm1heEJhY2tSZWZlcmVuY2UpIHtcbiAgICAgICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAobiA8PSBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDgucmVnZXhwX2VhdEtHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4NkIgLyogayAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCByZWZlcmVuY2VcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2hhcmFjdGVyRXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0WmVybyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgKCFzdGF0ZS5zd2l0Y2hVICYmIHRoaXMucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlKHN0YXRlKVxuICApXG59O1xucHAkOC5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOC5yZWdleHBfZWF0WmVybyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4MzAgLyogMCAqLyAmJiAhaXNEZWNpbWFsRGlnaXQoc3RhdGUubG9va2FoZWFkKCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNvbnRyb2xFc2NhcGVcbnBwJDgucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCA9PT0gMHg3NCAvKiB0ICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwOTsgLyogXFx0ICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDZFIC8qIG4gKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBBOyAvKiBcXG4gKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NzYgLyogdiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEI7IC8qIFxcdiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg2NiAvKiBmICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQzsgLyogXFxmICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDcyIC8qIHIgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBEOyAvKiBcXHIgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNvbnRyb2xMZXR0ZXJcbnBwJDgucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc0NvbnRyb2xMZXR0ZXIoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzQ29udHJvbExldHRlcihjaCkge1xuICByZXR1cm4gKFxuICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg1QSAvKiBaICovKSB8fFxuICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg3QSAvKiB6ICovKVxuICApXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVxucHAkOC5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgIHZhciBsZWFkID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgbGVhZCA+PSAweEQ4MDAgJiYgbGVhZCA8PSAweERCRkYpIHtcbiAgICAgICAgdmFyIGxlYWRTdXJyb2dhdGVFbmQgPSBzdGF0ZS5wb3M7XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykgJiYgc3RhdGUuZWF0KDB4NzUgLyogdSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgICAgdmFyIHRyYWlsID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICAgIGlmICh0cmFpbCA+PSAweERDMDAgJiYgdHJhaWwgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zID0gbGVhZFN1cnJvZ2F0ZUVuZDtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbGVhZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHN0YXRlLnN3aXRjaFUgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhEaWdpdHMoc3RhdGUpICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSAmJlxuICAgICAgaXNWYWxpZFVuaWNvZGUoc3RhdGUubGFzdEludFZhbHVlKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1ZhbGlkVW5pY29kZShjaCkge1xuICByZXR1cm4gY2ggPj0gMCAmJiBjaCA8PSAweDEwRkZGRlxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItSWRlbnRpdHlFc2NhcGVcbnBwJDgucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDJGIC8qIC8gKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJGOyAvKiAvICovXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoICE9PSAweDYzIC8qIGMgKi8gJiYgKCFzdGF0ZS5zd2l0Y2hOIHx8IGNoICE9PSAweDZCIC8qIGsgKi8pKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxFc2NhcGVcbnBwJDgucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCA+PSAweDMxIC8qIDEgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB7XG4gICAgZG8ge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH0gd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NFc2NhcGVcbnBwJDgucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuXG4gIGlmIChpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKFxuICAgIHN0YXRlLnN3aXRjaFUgJiZcbiAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJlxuICAgIChjaCA9PT0gMHg1MCAvKiBQICovIHx8IGNoID09PSAweDcwIC8qIHAgKi8pXG4gICkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uKHN0YXRlKSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLylcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkge1xuICByZXR1cm4gKFxuICAgIGNoID09PSAweDY0IC8qIGQgKi8gfHxcbiAgICBjaCA9PT0gMHg0NCAvKiBEICovIHx8XG4gICAgY2ggPT09IDB4NzMgLyogcyAqLyB8fFxuICAgIGNoID09PSAweDUzIC8qIFMgKi8gfHxcbiAgICBjaCA9PT0gMHg3NyAvKiB3ICovIHx8XG4gICAgY2ggPT09IDB4NTcgLyogVyAqL1xuICApXG59XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuLy8gICBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbnBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAvLyBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0QgLyogPSAqLykpIHtcbiAgICB2YXIgbmFtZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZShzdGF0ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG5cbiAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUpKSB7XG4gICAgdmFyIG5hbWVPclZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUsIG5hbWVPclZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDgucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaGFzKHN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeSwgbmFtZSkpXG4gICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeVtuYW1lXS50ZXN0KHZhbHVlKSlcbiAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZVwiKTsgfVxufTtcbnBwJDgucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZU9yVmFsdWUpIHtcbiAgaWYgKCFzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnkudGVzdChuYW1lT3JWYWx1ZSkpXG4gICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxufTtcblxuLy8gVW5pY29kZVByb3BlcnR5TmFtZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyc1xucHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxufTtcbmZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkge1xuICByZXR1cm4gaXNDb250cm9sTGV0dGVyKGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG59XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eVZhbHVlIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xucHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG59O1xuZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCkge1xuICByZXR1cm4gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB8fCBpc0RlY2ltYWxEaWdpdChjaClcbn1cblxuLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xucHAkOC5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NcbnBwJDgucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDVCIC8qIFsgKi8pKSB7XG4gICAgc3RhdGUuZWF0KDB4NUUgLyogXiAqLyk7XG4gICAgdGhpcy5yZWdleHBfY2xhc3NSYW5nZXMoc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBbICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gVW5yZWFjaGFibGUgc2luY2UgaXQgdGhyZXcgXCJ1bnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIgZXJyb3IgYmVmb3JlLlxuICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzUmFuZ2VzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXG5wcCQ4LnJlZ2V4cF9jbGFzc1JhbmdlcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgdmFyIGxlZnQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pICYmIHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgIHZhciByaWdodCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIChsZWZ0ID09PSAtMSB8fCByaWdodCA9PT0gLTEpKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICB9XG4gICAgICBpZiAobGVmdCAhPT0gLTEgJiYgcmlnaHQgIT09IC0xICYmIGxlZnQgPiByaWdodCkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbU5vRGFzaFxucHAkOC5yZWdleHBfZWF0Q2xhc3NBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NFc2NhcGUoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgdmFyIGNoJDEgPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICBpZiAoY2gkMSA9PT0gMHg2MyAvKiBjICovIHx8IGlzT2N0YWxEaWdpdChjaCQxKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2xhc3MgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCAhPT0gMHg1RCAvKiBbICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0VzY2FwZVxucHAkOC5yZWdleHBfZWF0Q2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwODsgLyogPEJTPiAqL1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkQ7IC8qIC0gKi9cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKCFzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpXG4gIClcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0NvbnRyb2xMZXR0ZXJcbnBwJDgucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RXNjYXBlU2VxdWVuY2VcbnBwJDgucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NzggLyogeCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRGlnaXRzXG5wcCQ4LnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcbmZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0c1xucHAkOC5yZWdleHBfZWF0SGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICB3aGlsZSAoaXNIZXhEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5mdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gIHJldHVybiAoXG4gICAgKGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHx8XG4gICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDQ2IC8qIEYgKi8pIHx8XG4gICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pXG4gIClcbn1cbmZ1bmN0aW9uIGhleFRvSW50KGNoKSB7XG4gIGlmIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB7XG4gICAgcmV0dXJuIDEwICsgKGNoIC0gMHg0MSAvKiBBICovKVxuICB9XG4gIGlmIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKSB7XG4gICAgcmV0dXJuIDEwICsgKGNoIC0gMHg2MSAvKiBhICovKVxuICB9XG4gIHJldHVybiBjaCAtIDB4MzAgLyogMCAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItTGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZVxuLy8gQWxsb3dzIG9ubHkgMC0zNzcob2N0YWwpIGkuZS4gMC0yNTUoZGVjaW1hbCkuXG5wcCQ4LnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgdmFyIG4xID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgdmFyIG4yID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKG4xIDw9IDMgJiYgdGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA2NCArIG4yICogOCArIHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogOCArIG4yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU9jdGFsRGlnaXRcbnBwJDgucmVnZXhwX2VhdE9jdGFsRGlnaXQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggLSAweDMwOyAvKiAwICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzNyAvKiA3ICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleDREaWdpdHNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0XG4vLyBBbmQgSGV4RGlnaXQgSGV4RGlnaXQgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RXNjYXBlU2VxdWVuY2VcbnBwJDgucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUsIGxlbmd0aCkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKCFpc0hleERpZ2l0KGNoKSkge1xuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBPYmplY3QgdHlwZSB1c2VkIHRvIHJlcHJlc2VudCB0b2tlbnMuIE5vdGUgdGhhdCBub3JtYWxseSwgdG9rZW5zXG4vLyBzaW1wbHkgZXhpc3QgYXMgcHJvcGVydGllcyBvbiB0aGUgcGFyc2VyIG9iamVjdC4gVGhpcyBpcyBvbmx5XG4vLyB1c2VkIGZvciB0aGUgb25Ub2tlbiBjYWxsYmFjayBhbmQgdGhlIGV4dGVybmFsIHRva2VuaXplci5cblxudmFyIFRva2VuID0gZnVuY3Rpb24gVG9rZW4ocCkge1xuICB0aGlzLnR5cGUgPSBwLnR5cGU7XG4gIHRoaXMudmFsdWUgPSBwLnZhbHVlO1xuICB0aGlzLnN0YXJ0ID0gcC5zdGFydDtcbiAgdGhpcy5lbmQgPSBwLmVuZDtcbiAgaWYgKHAub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwLCBwLnN0YXJ0TG9jLCBwLmVuZExvYyk7IH1cbiAgaWYgKHAub3B0aW9ucy5yYW5nZXMpXG4gICAgeyB0aGlzLnJhbmdlID0gW3Auc3RhcnQsIHAuZW5kXTsgfVxufTtcblxuLy8gIyMgVG9rZW5pemVyXG5cbnZhciBwcCQ5ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gTW92ZSB0byB0aGUgbmV4dCB0b2tlblxuXG5wcCQ5Lm5leHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5vblRva2VuKVxuICAgIHsgdGhpcy5vcHRpb25zLm9uVG9rZW4obmV3IFRva2VuKHRoaXMpKTsgfVxuXG4gIHRoaXMubGFzdFRva0VuZCA9IHRoaXMuZW5kO1xuICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMuc3RhcnQ7XG4gIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMuZW5kTG9jO1xuICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHRoaXMubmV4dFRva2VuKCk7XG59O1xuXG5wcCQ5LmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gbmV3IFRva2VuKHRoaXMpXG59O1xuXG4vLyBJZiB3ZSdyZSBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIG1ha2UgcGFyc2VycyBpdGVyYWJsZVxuaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpXG4gIHsgcHAkOVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzJDEuZ2V0VG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0b2tlbi50eXBlID09PSB0eXBlcy5lb2YsXG4gICAgICAgICAgdmFsdWU6IHRva2VuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07IH1cblxuLy8gVG9nZ2xlIHN0cmljdCBtb2RlLiBSZS1yZWFkcyB0aGUgbmV4dCBudW1iZXIgb3Igc3RyaW5nIHRvIHBsZWFzZVxuLy8gcGVkYW50aWMgdGVzdHMgKGBcInVzZSBzdHJpY3RcIjsgMDEwO2Agc2hvdWxkIGZhaWwpLlxuXG5wcCQ5LmN1ckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV1cbn07XG5cbi8vIFJlYWQgYSBzaW5nbGUgdG9rZW4sIHVwZGF0aW5nIHRoZSBwYXJzZXIgb2JqZWN0J3MgdG9rZW4tcmVsYXRlZFxuLy8gcHJvcGVydGllcy5cblxucHAkOS5uZXh0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHsgdGhpcy5za2lwU3BhY2UoKTsgfVxuXG4gIHRoaXMuc3RhcnQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5zdGFydExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZW9mKSB9XG5cbiAgaWYgKGN1ckNvbnRleHQub3ZlcnJpZGUpIHsgcmV0dXJuIGN1ckNvbnRleHQub3ZlcnJpZGUodGhpcykgfVxuICBlbHNlIHsgdGhpcy5yZWFkVG9rZW4odGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKTsgfVxufTtcblxucHAkOS5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSB7XG4gIC8vIElkZW50aWZpZXIgb3Iga2V5d29yZC4gJ1xcdVhYWFgnIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCBpblxuICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKVxuICAgIHsgcmV0dXJuIHRoaXMucmVhZFdvcmQoKSB9XG5cbiAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKVxufTtcblxucHAkOS5mdWxsQ2hhckNvZGVBdFBvcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIGlmIChjb2RlIDw9IDB4ZDdmZiB8fCBjb2RlID49IDB4ZTAwMCkgeyByZXR1cm4gY29kZSB9XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHJldHVybiAoY29kZSA8PCAxMCkgKyBuZXh0IC0gMHgzNWZkYzAwXG59O1xuXG5wcCQ5LnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zLCBlbmQgPSB0aGlzLmlucHV0LmluZGV4T2YoXCIqL1wiLCB0aGlzLnBvcyArPSAyKTtcbiAgaWYgKGVuZCA9PT0gLTEpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7IH1cbiAgdGhpcy5wb3MgPSBlbmQgKyAyO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgdmFyIG1hdGNoO1xuICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWModGhpcy5pbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdGhpcy5wb3MpIHtcbiAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgdGhpcy5saW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxufTtcblxucHAkOS5za2lwTGluZUNvbW1lbnQgPSBmdW5jdGlvbihzdGFydFNraXApIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgIWlzTmV3TGluZShjaCkpIHtcbiAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQoZmFsc2UsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyBzdGFydFNraXAsIHRoaXMucG9zKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbn07XG5cbi8vIENhbGxlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHBhcnNlIGFuZCBhZnRlciBldmVyeSB0b2tlbi4gU2tpcHNcbi8vIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBhbmQuXG5cbnBwJDkuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAzMjogY2FzZSAxNjA6IC8vICcgJ1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxMzpcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICBjYXNlIDEwOiBjYXNlIDgyMzI6IGNhc2UgODIzMzpcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpKSB7XG4gICAgICBjYXNlIDQyOiAvLyAnKidcbiAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrIGxvb3BcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbi8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbi8vIHRoZSB0b2tlbiwgc28gdGhhdCB0aGUgbmV4dCBvbmUncyBgc3RhcnRgIHdpbGwgcG9pbnQgYXQgdGhlXG4vLyByaWdodCBwb3NpdGlvbi5cblxucHAkOS5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHZhbCkge1xuICB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICB2YXIgcHJldlR5cGUgPSB0aGlzLnR5cGU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudmFsdWUgPSB2YWw7XG5cbiAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbn07XG5cbi8vICMjIyBUb2tlbiByZWFkaW5nXG5cbi8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLiBJdFxuLy8gaXMgc29tZXdoYXQgb2JzY3VyZSwgYmVjYXVzZSBpdCB3b3JrcyBpbiBjaGFyYWN0ZXIgY29kZXMgcmF0aGVyXG4vLyB0aGFuIGNoYXJhY3RlcnMsIGFuZCBiZWNhdXNlIG9wZXJhdG9yIHBhcnNpbmcgaGFzIGJlZW4gaW5saW5lZFxuLy8gaW50byBpdC5cbi8vXG4vLyBBbGwgaW4gdGhlIG5hbWUgb2Ygc3BlZWQuXG4vL1xucHAkOS5yZWFkVG9rZW5fZG90ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHsgcmV0dXJuIHRoaXMucmVhZE51bWJlcih0cnVlKSB9XG4gIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbmV4dCA9PT0gNDYgJiYgbmV4dDIgPT09IDQ2KSB7IC8vIDQ2ID0gZG90ICcuJ1xuICAgIHRoaXMucG9zICs9IDM7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZWxsaXBzaXMpXG4gIH0gZWxzZSB7XG4gICAgKyt0aGlzLnBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb3QpXG4gIH1cbn07XG5cbnBwJDkucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24oKSB7IC8vICcvJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAodGhpcy5leHByQWxsb3dlZCkgeyArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5yZWFkUmVnZXhwKCkgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnNsYXNoLCAxKVxufTtcblxucHAkOS5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnJSonXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHZhciBzaXplID0gMTtcbiAgdmFyIHRva2VudHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMuc3RhciA6IHR5cGVzLm1vZHVsbztcblxuICAvLyBleHBvbmVudGlhdGlvbiBvcGVyYXRvciAqKiBhbmQgKio9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiBjb2RlID09PSA0MiAmJiBuZXh0ID09PSA0Mikge1xuICAgICsrc2l6ZTtcbiAgICB0b2tlbnR5cGUgPSB0eXBlcy5zdGFyc3RhcjtcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0b2tlbnR5cGUsIHNpemUpXG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJ3wmJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5sb2dpY2FsT1IgOiB0eXBlcy5sb2dpY2FsQU5ELCAyKSB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMuYml0d2lzZU9SIDogdHlwZXMuYml0d2lzZUFORCwgMSlcbn07XG5cbnBwJDkucmVhZFRva2VuX2NhcmV0ID0gZnVuY3Rpb24oKSB7IC8vICdeJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdHdpc2VYT1IsIDEpXG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9wbHVzX21pbiA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJystJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIGlmIChuZXh0ID09PSA0NSAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgJiZcbiAgICAgICAgKHRoaXMubGFzdFRva0VuZCA9PT0gMCB8fCBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5wb3MpKSkpIHtcbiAgICAgIC8vIEEgYC0tPmAgbGluZSBjb21tZW50XG4gICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5pbmNEZWMsIDIpXG4gIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wbHVzTWluLCAxKVxufTtcblxucHAkOS5yZWFkVG9rZW5fbHRfZ3QgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc8PidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgdmFyIHNpemUgPSAxO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIHNpemUgPSBjb2RlID09PSA2MiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcbiAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgc2l6ZSkgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXRTaGlmdCwgc2l6ZSlcbiAgfVxuICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAvLyBgPCEtLWAsIGFuIFhNTC1zdHlsZSBjb21tZW50IHRoYXQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgbGluZSBjb21tZW50XG4gICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyBzaXplID0gMjsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5yZWxhdGlvbmFsLCBzaXplKVxufTtcblxucHAkOS5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJz0hJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuZXF1YWxpdHksIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKSB9XG4gIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2MiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyAvLyAnPT4nXG4gICAgdGhpcy5wb3MgKz0gMjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5hcnJvdylcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR5cGVzLmVxIDogdHlwZXMucHJlZml4LCAxKVxufTtcblxucHAkOS5nZXRUb2tlbkZyb21Db2RlID0gZnVuY3Rpb24oY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAvLyBieSBhIGRpZ2l0IG9yIGFub3RoZXIgdHdvIGRvdHMuXG4gIGNhc2UgNDY6IC8vICcuJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKVxuXG4gIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgY2FzZSA0MDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5MKVxuICBjYXNlIDQxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlblIpXG4gIGNhc2UgNTk6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnNlbWkpXG4gIGNhc2UgNDQ6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbW1hKVxuICBjYXNlIDkxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0TClcbiAgY2FzZSA5MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldFIpXG4gIGNhc2UgMTIzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZUwpXG4gIGNhc2UgMTI1OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZVIpXG4gIGNhc2UgNTg6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbG9uKVxuICBjYXNlIDYzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5xdWVzdGlvbilcblxuICBjYXNlIDk2OiAvLyAnYCdcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyBicmVhayB9XG4gICAgKyt0aGlzLnBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG5cbiAgY2FzZSA0ODogLy8gJzAnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigxNikgfSAvLyAnMHgnLCAnMFgnIC0gaGV4IG51bWJlclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoOCkgfSAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpIH0gLy8gJzBiJywgJzBCJyAtIGJpbmFyeSBudW1iZXJcbiAgICB9XG5cbiAgLy8gQW55dGhpbmcgZWxzZSBiZWdpbm5pbmcgd2l0aCBhIGRpZ2l0IGlzIGFuIGludGVnZXIsIG9jdGFsXG4gIC8vIG51bWJlciwgb3IgZmxvYXQuXG4gIGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IC8vIDEtOVxuICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIoZmFsc2UpXG5cbiAgLy8gUXVvdGVzIHByb2R1Y2Ugc3RyaW5ncy5cbiAgY2FzZSAzNDogY2FzZSAzOTogLy8gJ1wiJywgXCInXCJcbiAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKGNvZGUpXG5cbiAgLy8gT3BlcmF0b3JzIGFyZSBwYXJzZWQgaW5saW5lIGluIHRpbnkgc3RhdGUgbWFjaGluZXMuICc9JyAoNjEpIGlzXG4gIC8vIG9mdGVuIHJlZmVycmVkIHRvLiBgZmluaXNoT3BgIHNpbXBseSBza2lwcyB0aGUgYW1vdW50IG9mXG4gIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gIC8vIG9mIHRoZSB0eXBlIGdpdmVuIGJ5IGl0cyBmaXJzdCBhcmd1bWVudC5cblxuICBjYXNlIDQ3OiAvLyAnLydcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKVxuXG4gIGNhc2UgMzc6IGNhc2UgNDI6IC8vICclKidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwKGNvZGUpXG5cbiAgY2FzZSAxMjQ6IGNhc2UgMzg6IC8vICd8JidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSlcblxuICBjYXNlIDk0OiAvLyAnXidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fY2FyZXQoKVxuXG4gIGNhc2UgNDM6IGNhc2UgNDU6IC8vICcrLSdcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSlcblxuICBjYXNlIDYwOiBjYXNlIDYyOiAvLyAnPD4nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2x0X2d0KGNvZGUpXG5cbiAgY2FzZSA2MTogY2FzZSAzMzogLy8gJz0hJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKGNvZGUpXG5cbiAgY2FzZSAxMjY6IC8vICd+J1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnByZWZpeCwgMSlcbiAgfVxuXG4gIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmckMShjb2RlKSArIFwiJ1wiKTtcbn07XG5cbnBwJDkuZmluaXNoT3AgPSBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG4gIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpO1xuICB0aGlzLnBvcyArPSBzaXplO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpXG59O1xuXG5wcCQ5LnJlYWRSZWdleHAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVzY2FwZWQsIGluQ2xhc3MsIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgIGlmIChsaW5lQnJlYWsudGVzdChjaCkpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICBpZiAoY2ggPT09IFwiW1wiKSB7IGluQ2xhc3MgPSB0cnVlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgeyBpbkNsYXNzID0gZmFsc2U7IH1cbiAgICAgIGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykgeyBicmVhayB9XG4gICAgICBlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuICAgIH0gZWxzZSB7IGVzY2FwZWQgPSBmYWxzZTsgfVxuICAgICsrdGhpcy5wb3M7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICsrdGhpcy5wb3M7XG4gIHZhciBmbGFnc1N0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBmbGFncyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMudW5leHBlY3RlZChmbGFnc1N0YXJ0KTsgfVxuXG4gIC8vIFZhbGlkYXRlIHBhdHRlcm5cbiAgdmFyIHN0YXRlID0gdGhpcy5yZWdleHBTdGF0ZSB8fCAodGhpcy5yZWdleHBTdGF0ZSA9IG5ldyBSZWdFeHBWYWxpZGF0aW9uU3RhdGUodGhpcykpO1xuICBzdGF0ZS5yZXNldChzdGFydCwgcGF0dGVybiwgZmxhZ3MpO1xuICB0aGlzLnZhbGlkYXRlUmVnRXhwRmxhZ3Moc3RhdGUpO1xuICB0aGlzLnZhbGlkYXRlUmVnRXhwUGF0dGVybihzdGF0ZSk7XG5cbiAgLy8gQ3JlYXRlIExpdGVyYWwjdmFsdWUgcHJvcGVydHkgdmFsdWUuXG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFsdWUgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEVTVHJlZSByZXF1aXJlcyBudWxsIGlmIGl0IGZhaWxlZCB0byBpbnN0YW50aWF0ZSBSZWdFeHAgb2JqZWN0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVlL2Jsb2IvYTI3MDAzYWRmNGZkN2JmYWQ0NGRlOWNlZjM3MmEyZWFjZDUyN2IxYy9lczUubWQjcmVnZXhwbGl0ZXJhbFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucmVnZXhwLCB7cGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzLCB2YWx1ZTogdmFsdWV9KVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyIGluIHRoZSBnaXZlbiByYWRpeC4gUmV0dXJuIG51bGwgaWYgemVybyBkaWdpdHNcbi8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4vLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxucHAkOS5yZWFkSW50ID0gZnVuY3Rpb24ocmFkaXgsIGxlbikge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2kpIHtcbiAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIHZhbCA9ICh2b2lkIDApO1xuICAgIGlmIChjb2RlID49IDk3KSB7IHZhbCA9IGNvZGUgLSA5NyArIDEwOyB9IC8vIGFcbiAgICBlbHNlIGlmIChjb2RlID49IDY1KSB7IHZhbCA9IGNvZGUgLSA2NSArIDEwOyB9IC8vIEFcbiAgICBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHsgdmFsID0gY29kZSAtIDQ4OyB9IC8vIDAtOVxuICAgIGVsc2UgeyB2YWwgPSBJbmZpbml0eTsgfVxuICAgIGlmICh2YWwgPj0gcmFkaXgpIHsgYnJlYWsgfVxuICAgICsrdGhpcy5wb3M7XG4gICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICB9XG4gIGlmICh0aGlzLnBvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdGhpcy5wb3MgLSBzdGFydCAhPT0gbGVuKSB7IHJldHVybiBudWxsIH1cblxuICByZXR1cm4gdG90YWxcbn07XG5cbnBwJDkucmVhZFJhZGl4TnVtYmVyID0gZnVuY3Rpb24ocmFkaXgpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIHRoaXMucG9zICs9IDI7IC8vIDB4XG4gIHZhciB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICBpZiAodmFsID09IG51bGwpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMTApIHtcbiAgICB2YWwgPSB0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiID8gQmlnSW50KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSkgOiBudWxsO1xuICAgICsrdGhpcy5wb3M7XG4gIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbnBwJDkucmVhZE51bWJlciA9IGZ1bmN0aW9uKHN0YXJ0c1dpdGhEb3QpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIGlmICghc3RhcnRzV2l0aERvdCAmJiB0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICBpZiAob2N0YWwgJiYgdGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICBpZiAob2N0YWwgJiYgL1s4OV0vLnRlc3QodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKSkgeyBvY3RhbCA9IGZhbHNlOyB9XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgaWYgKCFvY3RhbCAmJiAhc3RhcnRzV2l0aERvdCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgbmV4dCA9PT0gMTEwKSB7XG4gICAgdmFyIHN0ciQxID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICAgIHZhciB2YWwkMSA9IHR5cGVvZiBCaWdJbnQgIT09IFwidW5kZWZpbmVkXCIgPyBCaWdJbnQoc3RyJDEpIDogbnVsbDtcbiAgICArK3RoaXMucG9zO1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbCQxKVxuICB9XG4gIGlmIChuZXh0ID09PSA0NiAmJiAhb2N0YWwpIHsgLy8gJy4nXG4gICAgKyt0aGlzLnBvcztcbiAgICB0aGlzLnJlYWRJbnQoMTApO1xuICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICB9XG4gIGlmICgobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSAmJiAhb2N0YWwpIHsgLy8gJ2VFJ1xuICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSB7ICsrdGhpcy5wb3M7IH0gLy8gJystJ1xuICAgIGlmICh0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgfVxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG5cbiAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgdmFyIHZhbCA9IG9jdGFsID8gcGFyc2VJbnQoc3RyLCA4KSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpXG59O1xuXG4vLyBSZWFkIGEgc3RyaW5nIHZhbHVlLCBpbnRlcnByZXRpbmcgYmFja3NsYXNoLWVzY2FwZXMuXG5cbnBwJDkucmVhZENvZGVQb2ludCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCBjb2RlO1xuXG4gIGlmIChjaCA9PT0gMTIzKSB7IC8vICd7J1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgdmFyIGNvZGVQb3MgPSArK3RoaXMucG9zO1xuICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZihcIn1cIiwgdGhpcy5wb3MpIC0gdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgaWYgKGNvZGUgPiAweDEwRkZGRikgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kc1wiKTsgfVxuICB9IGVsc2Uge1xuICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQpO1xuICB9XG4gIHJldHVybiBjb2RlXG59O1xuXG5mdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyQxKGNvZGUpIHtcbiAgLy8gVVRGLTE2IERlY29kaW5nXG4gIGlmIChjb2RlIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSB9XG4gIGNvZGUgLT0gMHgxMDAwMDtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhEODAwLCAoY29kZSAmIDEwMjMpICsgMHhEQzAwKVxufVxuXG5wcCQ5LnJlYWRTdHJpbmcgPSBmdW5jdGlvbihxdW90ZSkge1xuICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9ICsrdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmIChjaCA9PT0gcXVvdGUpIHsgYnJlYWsgfVxuICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzTmV3TGluZShjaCwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEwKSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gIH1cbiAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnN0cmluZywgb3V0KVxufTtcblxuLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxudmFyIElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SID0ge307XG5cbnBwJDkudHJ5UmVhZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IHRydWU7XG4gIHRyeSB7XG4gICAgdGhpcy5yZWFkVG1wbFRva2VuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgPT09IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SKSB7XG4gICAgICB0aGlzLnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gZmFsc2U7XG59O1xuXG5wcCQ5LmludmFsaWRTdHJpbmdUb2tlbiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLmluVGVtcGxhdGVFbGVtZW50ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgdGhyb3cgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1JcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJhaXNlKHBvc2l0aW9uLCBtZXNzYWdlKTtcbiAgfVxufTtcblxucHAkOS5yZWFkVG1wbFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEyMykgeyAvLyAnYCcsICckeydcbiAgICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5zdGFydCAmJiAodGhpcy50eXBlID09PSB0eXBlcy50ZW1wbGF0ZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmludmFsaWRUZW1wbGF0ZSkpIHtcbiAgICAgICAgaWYgKGNoID09PSAzNikge1xuICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG9sbGFyQnJhY2VMKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy50ZW1wbGF0ZSwgb3V0KVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2UgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICBjYXNlIDEzOlxuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfVxuICAgICAgY2FzZSAxMDpcbiAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH1cbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gIH1cbn07XG5cbi8vIFJlYWRzIGEgdGVtcGxhdGUgdG9rZW4gdG8gc2VhcmNoIGZvciB0aGUgZW5kLCB3aXRob3V0IHZhbGlkYXRpbmcgYW55IGVzY2FwZSBzZXF1ZW5jZXNcbnBwJDkucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gIGZvciAoOyB0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoOyB0aGlzLnBvcysrKSB7XG4gICAgc3dpdGNoICh0aGlzLmlucHV0W3RoaXMucG9zXSkge1xuICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCIkXCI6XG4gICAgICBpZiAodGhpcy5pbnB1dFt0aGlzLnBvcyArIDFdICE9PSBcIntcIikge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgIGNhc2UgXCJgXCI6XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5pbnZhbGlkVGVtcGxhdGUsIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpKVxuXG4gICAgLy8gbm8gZGVmYXVsdFxuICAgIH1cbiAgfVxuICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpO1xufTtcblxuLy8gVXNlZCB0byByZWFkIGVzY2FwZWQgY2hhcmFjdGVyc1xuXG5wcCQ5LnJlYWRFc2NhcGVkQ2hhciA9IGZ1bmN0aW9uKGluVGVtcGxhdGUpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICArK3RoaXMucG9zO1xuICBzd2l0Y2ggKGNoKSB7XG4gIGNhc2UgMTEwOiByZXR1cm4gXCJcXG5cIiAvLyAnbicgLT4gJ1xcbidcbiAgY2FzZSAxMTQ6IHJldHVybiBcIlxcclwiIC8vICdyJyAtPiAnXFxyJ1xuICBjYXNlIDEyMDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSGV4Q2hhcigyKSkgLy8gJ3gnXG4gIGNhc2UgMTE3OiByZXR1cm4gY29kZVBvaW50VG9TdHJpbmckMSh0aGlzLnJlYWRDb2RlUG9pbnQoKSkgLy8gJ3UnXG4gIGNhc2UgMTE2OiByZXR1cm4gXCJcXHRcIiAvLyAndCcgLT4gJ1xcdCdcbiAgY2FzZSA5ODogcmV0dXJuIFwiXFxiXCIgLy8gJ2InIC0+ICdcXGInXG4gIGNhc2UgMTE4OiByZXR1cm4gXCJcXHUwMDBiXCIgLy8gJ3YnIC0+ICdcXHUwMDBiJ1xuICBjYXNlIDEwMjogcmV0dXJuIFwiXFxmXCIgLy8gJ2YnIC0+ICdcXGYnXG4gIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9IC8vICdcXHJcXG4nXG4gIGNhc2UgMTA6IC8vICcgXFxuJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7ICsrdGhpcy5jdXJMaW5lOyB9XG4gICAgcmV0dXJuIFwiXCJcbiAgZGVmYXVsdDpcbiAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKChvY3RhbFN0ciAhPT0gXCIwXCIgfHwgY2ggPT09IDU2IHx8IGNoID09PSA1NykgJiYgKHRoaXMuc3RyaWN0IHx8IGluVGVtcGxhdGUpKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgIHRoaXMucG9zIC0gMSAtIG9jdGFsU3RyLmxlbmd0aCxcbiAgICAgICAgICBpblRlbXBsYXRlXG4gICAgICAgICAgICA/IFwiT2N0YWwgbGl0ZXJhbCBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICAgICAgOiBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgfVxuICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAvLyBVbmljb2RlIG5ldyBsaW5lIGNoYXJhY3RlcnMgYWZ0ZXIgXFwgZ2V0IHJlbW92ZWQgZnJvbSBvdXRwdXQgaW4gYm90aFxuICAgICAgLy8gdGVtcGxhdGUgbGl0ZXJhbHMgYW5kIHN0cmluZ3NcbiAgICAgIHJldHVybiBcIlwiXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKVxuICB9XG59O1xuXG4vLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JywgJ1xcVScpLlxuXG5wcCQ5LnJlYWRIZXhDaGFyID0gZnVuY3Rpb24obGVuKSB7XG4gIHZhciBjb2RlUG9zID0gdGhpcy5wb3M7XG4gIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICBpZiAobiA9PT0gbnVsbCkgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpOyB9XG4gIHJldHVybiBuXG59O1xuXG4vLyBSZWFkIGFuIGlkZW50aWZpZXIsIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcuIFNldHMgYHRoaXMuY29udGFpbnNFc2NgXG4vLyB0byB3aGV0aGVyIHRoZSB3b3JkIGNvbnRhaW5lZCBhICdcXHUnIGVzY2FwZS5cbi8vXG4vLyBJbmNyZW1lbnRhbGx5IGFkZHMgb25seSBlc2NhcGVkIGNoYXJzLCBhZGRpbmcgb3RoZXIgY2h1bmtzIGFzLWlzXG4vLyBhcyBhIG1pY3JvLW9wdGltaXphdGlvbi5cblxucHAkOS5yZWFkV29yZDEgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuICB2YXIgd29yZCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZSwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpO1xuICAgIGlmIChpc0lkZW50aWZpZXJDaGFyKGNoLCBhc3RyYWwpKSB7XG4gICAgICB0aGlzLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICB9IGVsc2UgaWYgKGNoID09PSA5MikgeyAvLyBcIlxcXCJcbiAgICAgIHRoaXMuY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIHZhciBlc2NTdGFydCA9IHRoaXMucG9zO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKSAhPT0gMTE3KSAvLyBcInVcIlxuICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHRoaXMucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICB2YXIgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KCk7XG4gICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCBhc3RyYWwpKVxuICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGVzY1N0YXJ0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7IH1cbiAgICAgIHdvcmQgKz0gY29kZVBvaW50VG9TdHJpbmckMShlc2MpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBmaXJzdCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB3b3JkICsgdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcylcbn07XG5cbi8vIFJlYWQgYW4gaWRlbnRpZmllciBvciBrZXl3b3JkIHRva2VuLiBXaWxsIGNoZWNrIGZvciByZXNlcnZlZFxuLy8gd29yZHMgd2hlbiBuZWNlc3NhcnkuXG5cbnBwJDkucmVhZFdvcmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHdvcmQgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICB2YXIgdHlwZSA9IHR5cGVzLm5hbWU7XG4gIGlmICh0aGlzLmtleXdvcmRzLnRlc3Qod29yZCkpIHtcbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBcIiArIHdvcmQpOyB9XG4gICAgdHlwZSA9IGtleXdvcmRzJDFbd29yZF07XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZClcbn07XG5cbi8vIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQuXG5cbnZhciB2ZXJzaW9uID0gXCI2LjQuMFwiO1xuXG5QYXJzZXIuYWNvcm4gPSB7XG4gIFBhcnNlcjogUGFyc2VyLFxuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICBkZWZhdWx0T3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG4gIFBvc2l0aW9uOiBQb3NpdGlvbixcbiAgU291cmNlTG9jYXRpb246IFNvdXJjZUxvY2F0aW9uLFxuICBnZXRMaW5lSW5mbzogZ2V0TGluZUluZm8sXG4gIE5vZGU6IE5vZGUsXG4gIFRva2VuVHlwZTogVG9rZW5UeXBlLFxuICB0b2tUeXBlczogdHlwZXMsXG4gIGtleXdvcmRUeXBlczoga2V5d29yZHMkMSxcbiAgVG9rQ29udGV4dDogVG9rQ29udGV4dCxcbiAgdG9rQ29udGV4dHM6IHR5cGVzJDEsXG4gIGlzSWRlbnRpZmllckNoYXI6IGlzSWRlbnRpZmllckNoYXIsXG4gIGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgVG9rZW46IFRva2VuLFxuICBpc05ld0xpbmU6IGlzTmV3TGluZSxcbiAgbGluZUJyZWFrOiBsaW5lQnJlYWssXG4gIGxpbmVCcmVha0c6IGxpbmVCcmVha0csXG4gIG5vbkFTQ0lJd2hpdGVzcGFjZTogbm9uQVNDSUl3aGl0ZXNwYWNlXG59O1xuXG4vLyBUaGUgbWFpbiBleHBvcnRlZCBpbnRlcmZhY2UgKHVuZGVyIGBzZWxmLmFjb3JuYCB3aGVuIGluIHRoZVxuLy8gYnJvd3NlcikgaXMgYSBgcGFyc2VgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjb2RlIHN0cmluZyBhbmRcbi8vIHJldHVybnMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgYXMgc3BlY2lmaWVkIGJ5IFtNb3ppbGxhIHBhcnNlclxuLy8gQVBJXVthcGldLlxuLy9cbi8vIFthcGldOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJXG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBQYXJzZXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4vLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4vLyB0aGF0IGVtYmVkIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMuXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKVxufVxuXG4vLyBBY29ybiBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuLy8gVGhlIGB0b2tlbml6ZXJgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cblxuZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBQYXJzZXIudG9rZW5pemVyKGlucHV0LCBvcHRpb25zKVxufVxuXG5leHBvcnQgeyBOb2RlLCBQYXJzZXIsIFBvc2l0aW9uLCBTb3VyY2VMb2NhdGlvbiwgVG9rQ29udGV4dCwgVG9rZW4sIFRva2VuVHlwZSwgZGVmYXVsdE9wdGlvbnMsIGdldExpbmVJbmZvLCBpc0lkZW50aWZpZXJDaGFyLCBpc0lkZW50aWZpZXJTdGFydCwgaXNOZXdMaW5lLCBrZXl3b3JkcyQxIGFzIGtleXdvcmRUeXBlcywgbGluZUJyZWFrLCBsaW5lQnJlYWtHLCBub25BU0NJSXdoaXRlc3BhY2UsIHBhcnNlLCBwYXJzZUV4cHJlc3Npb25BdCwgdHlwZXMkMSBhcyB0b2tDb250ZXh0cywgdHlwZXMgYXMgdG9rVHlwZXMsIHRva2VuaXplciwgdmVyc2lvbiB9O1xuIiwiLyohXG4gKiBQYXBlci5qcyB2MC4xMi4xMSAtIFRoZSBTd2lzcyBBcm15IEtuaWZlIG9mIFZlY3RvciBHcmFwaGljcyBTY3JpcHRpbmcuXG4gKiBodHRwOi8vcGFwZXJqcy5vcmcvXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExIC0gMjAyMCwgSsO8cmcgTGVobmkgJiBKb25hdGhhbiBQdWNrZXlcbiAqIGh0dHA6Ly9qdWVyZ2xlaG5pLmNvbS8gJiBodHRwczovL3B1Y2tleS5zdHVkaW8vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuICpcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogRGF0ZTogRnJpIEp1biAxOSAxOToxNDozMyAyMDIwICswMjAwXG4gKlxuICoqKlxuICpcbiAqIFN0cmFwcy5qcyAtIENsYXNzIGluaGVyaXRhbmNlIGxpYnJhcnkgd2l0aCBzdXBwb3J0IGZvciBiZWFuLXN0eWxlIGFjY2Vzc29yc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAwNiAtIDIwMjAgSsO8cmcgTGVobmlcbiAqIGh0dHA6Ly9qdWVyZ2xlaG5pLmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKlxuICoqKlxuICpcbiAqIEFjb3JuLmpzXG4gKiBodHRwczovL21hcmlqbmhhdmVyYmVrZS5ubC9hY29ybi9cbiAqXG4gKiBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LFxuICogY3JlYXRlZCBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS5cbiAqXG4gKi9cbnZhciBwYXBlciA9IGZ1bmN0aW9uIChzZWxmLCB1bmRlZmluZWQpIHtcbiAgc2VsZiA9IHNlbGYgfHwgcmVxdWlyZSgnLi9ub2RlL3NlbGYuanMnKTtcbiAgdmFyIHdpbmRvdyA9IHNlbGYud2luZG93LFxuICAgICAgZG9jdW1lbnQgPSBzZWxmLmRvY3VtZW50O1xuICB2YXIgQmFzZSA9IG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhpZGRlbiA9IC9eKHN0YXRpY3N8ZW51bWVyYWJsZXxiZWFuc3xwcmVzZXJ2ZSkkLyxcbiAgICAgICAgYXJyYXkgPSBbXSxcbiAgICAgICAgc2xpY2UgPSBhcnJheS5zbGljZSxcbiAgICAgICAgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgZGVzY3JpYmUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgICAgICBkZWZpbmUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICAgIGZvckVhY2ggPSBhcnJheS5mb3JFYWNoIHx8IGZ1bmN0aW9uIChpdGVyLCBiaW5kKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBmb3JJbiA9IGZ1bmN0aW9uIChpdGVyLCBiaW5kKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkpIGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBzZXQgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIChkc3QpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRzdDtcbiAgICB9LFxuICAgICAgICBlYWNoID0gZnVuY3Rpb24gKG9iaiwgaXRlciwgYmluZCkge1xuICAgICAgaWYgKG9iaikge1xuICAgICAgICB2YXIgZGVzYyA9IGRlc2NyaWJlKG9iaiwgJ2xlbmd0aCcpO1xuICAgICAgICAoZGVzYyAmJiB0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ251bWJlcicgPyBmb3JFYWNoIDogZm9ySW4pLmNhbGwob2JqLCBpdGVyLCBiaW5kID0gYmluZCB8fCBvYmopO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmluZDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5qZWN0KGRlc3QsIHNyYywgZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKSB7XG4gICAgICB2YXIgYmVhbnNOYW1lcyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBmaWVsZChuYW1lLCB2YWwpIHtcbiAgICAgICAgdmFsID0gdmFsIHx8ICh2YWwgPSBkZXNjcmliZShzcmMsIG5hbWUpKSAmJiAodmFsLmdldCA/IHZhbCA6IHZhbC52YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWxbMF0gPT09ICcjJykgdmFsID0gZGVzdFt2YWwuc3Vic3RyaW5nKDEpXSB8fCB2YWw7XG4gICAgICAgIHZhciBpc0Z1bmMgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgcmVzID0gdmFsLFxuICAgICAgICAgICAgcHJldiA9IHByZXNlcnZlIHx8IGlzRnVuYyAmJiAhdmFsLmJhc2UgPyB2YWwgJiYgdmFsLmdldCA/IG5hbWUgaW4gZGVzdCA6IGRlc3RbbmFtZV0gOiBudWxsLFxuICAgICAgICAgICAgYmVhbjtcblxuICAgICAgICBpZiAoIXByZXNlcnZlIHx8ICFwcmV2KSB7XG4gICAgICAgICAgaWYgKGlzRnVuYyAmJiBwcmV2KSB2YWwuYmFzZSA9IHByZXY7XG4gICAgICAgICAgaWYgKGlzRnVuYyAmJiBiZWFucyAhPT0gZmFsc2UgJiYgKGJlYW4gPSBuYW1lLm1hdGNoKC9eKFtnc11ldHxpcykoKFtBLVpdKSguKikpJC8pKSkgYmVhbnNOYW1lc1tiZWFuWzNdLnRvTG93ZXJDYXNlKCkgKyBiZWFuWzRdXSA9IGJlYW5bMl07XG5cbiAgICAgICAgICBpZiAoIXJlcyB8fCBpc0Z1bmMgfHwgIXJlcy5nZXQgfHwgdHlwZW9mIHJlcy5nZXQgIT09ICdmdW5jdGlvbicgfHwgIUJhc2UuaXNQbGFpbk9iamVjdChyZXMpKSB7XG4gICAgICAgICAgICByZXMgPSB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZXMsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgoZGVzY3JpYmUoZGVzdCwgbmFtZSkgfHwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSkuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICByZXMuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZSAhPSBudWxsID8gZW51bWVyYWJsZSA6ICFiZWFuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmluZShkZXN0LCBuYW1lLCByZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBzcmMpIHtcbiAgICAgICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KG5hbWUpICYmICFoaWRkZW4udGVzdChuYW1lKSkgZmllbGQobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGJlYW5zTmFtZXMpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IGJlYW5zTmFtZXNbbmFtZV0sXG4gICAgICAgICAgICAgIHNldCA9IGRlc3RbJ3NldCcgKyBwYXJ0XSxcbiAgICAgICAgICAgICAgZ2V0ID0gZGVzdFsnZ2V0JyArIHBhcnRdIHx8IHNldCAmJiBkZXN0WydpcycgKyBwYXJ0XTtcbiAgICAgICAgICBpZiAoZ2V0ICYmIChiZWFucyA9PT0gdHJ1ZSB8fCBnZXQubGVuZ3RoID09PSAwKSkgZmllbGQobmFtZSwge1xuICAgICAgICAgICAgZ2V0OiBnZXQsXG4gICAgICAgICAgICBzZXQ6IHNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEJhc2UoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaWYgKHNyYykgc2V0KHRoaXMsIHNyYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBpbmplY3QoQmFzZSwge1xuICAgICAgaW5qZWN0OiBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICB2YXIgc3RhdGljcyA9IHNyYy5zdGF0aWNzID09PSB0cnVlID8gc3JjIDogc3JjLnN0YXRpY3MsXG4gICAgICAgICAgICAgIGJlYW5zID0gc3JjLmJlYW5zLFxuICAgICAgICAgICAgICBwcmVzZXJ2ZSA9IHNyYy5wcmVzZXJ2ZTtcbiAgICAgICAgICBpZiAoc3RhdGljcyAhPT0gc3JjKSBpbmplY3QodGhpcy5wcm90b3R5cGUsIHNyYywgc3JjLmVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG4gICAgICAgICAgaW5qZWN0KHRoaXMsIHN0YXRpY3MsIG51bGwsIGJlYW5zLCBwcmVzZXJ2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHRoaXMuaW5qZWN0KGFyZ3VtZW50c1tpXSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYXNlID0gdGhpcyxcbiAgICAgICAgICAgIGN0b3IsXG4gICAgICAgICAgICBwcm90bztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgb2JqLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGwgJiYgIShjdG9yICYmIHByb3RvKTsgaSsrKSB7XG4gICAgICAgICAgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGN0b3IgPSBjdG9yIHx8IG9iai5pbml0aWFsaXplO1xuICAgICAgICAgIHByb3RvID0gcHJvdG8gfHwgb2JqLnByb3RvdHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0b3IgPSBjdG9yIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvdG8gPSBjdG9yLnByb3RvdHlwZSA9IHByb3RvIHx8IGNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG4gICAgICAgIGRlZmluZShwcm90bywgJ2NvbnN0cnVjdG9yJywge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaW5qZWN0KGN0b3IsIHRoaXMpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgdGhpcy5pbmplY3QuYXBwbHkoY3RvciwgYXJndW1lbnRzKTtcbiAgICAgICAgY3Rvci5iYXNlID0gYmFzZTtcbiAgICAgICAgcmV0dXJuIGN0b3I7XG4gICAgICB9XG4gICAgfSkuaW5qZWN0KHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgaW5pdGlhbGl6ZTogQmFzZSxcbiAgICAgIHNldDogQmFzZSxcbiAgICAgIGluamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgaW5qZWN0KHRoaXMsIHNyYywgc3JjLmVudW1lcmFibGUsIHNyYy5iZWFucywgc3JjLnByZXNlcnZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBleHRlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IGNyZWF0ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlcy5pbmplY3QuYXBwbHkocmVzLCBhcmd1bWVudHMpO1xuICAgICAgfSxcbiAgICAgIGVhY2g6IGZ1bmN0aW9uIChpdGVyLCBiaW5kKSB7XG4gICAgICAgIHJldHVybiBlYWNoKHRoaXMsIGl0ZXIsIGJpbmQpO1xuICAgICAgfSxcbiAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBzdGF0aWNzOiB7XG4gICAgICAgIHNldDogc2V0LFxuICAgICAgICBlYWNoOiBlYWNoLFxuICAgICAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICAgICAgZGVmaW5lOiBkZWZpbmUsXG4gICAgICAgIGRlc2NyaWJlOiBkZXNjcmliZSxcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gc2V0KG5ldyBvYmouY29uc3RydWN0b3IoKSwgb2JqKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNQbGFpbk9iamVjdDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHZhciBjdG9yID0gb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIHJldHVybiBjdG9yICYmIChjdG9yID09PSBPYmplY3QgfHwgY3RvciA9PT0gQmFzZSB8fCBjdG9yLm5hbWUgPT09ICdPYmplY3QnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGljazogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYSAhPT0gdW5kZWZpbmVkID8gYSA6IGI7XG4gICAgICAgIH0sXG4gICAgICAgIHNsaWNlOiBmdW5jdGlvbiAobGlzdCwgYmVnaW4sIGVuZCkge1xuICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKGxpc3QsIGJlZ2luLCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0oKTtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IEJhc2U7XG4gIEJhc2UuaW5qZWN0KHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lkICE9IG51bGwgPyAodGhpcy5fY2xhc3MgfHwgJ09iamVjdCcpICsgKHRoaXMuX25hbWUgPyBcIiAnXCIgKyB0aGlzLl9uYW1lICsgXCInXCIgOiAnIEAnICsgdGhpcy5faWQpIDogJ3sgJyArIEJhc2UuZWFjaCh0aGlzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoIS9eXy8udGVzdChrZXkpKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgdGhpcy5wdXNoKGtleSArICc6ICcgKyAodHlwZSA9PT0gJ251bWJlcicgPyBGb3JtYXR0ZXIuaW5zdGFuY2UubnVtYmVyKHZhbHVlKSA6IHR5cGUgPT09ICdzdHJpbmcnID8gXCInXCIgKyB2YWx1ZSArIFwiJ1wiIDogdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSwgW10pLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH0sXG4gICAgZ2V0Q2xhc3NOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xhc3MgfHwgJyc7XG4gICAgfSxcbiAgICBpbXBvcnRKU09OOiBmdW5jdGlvbiAoanNvbikge1xuICAgICAgcmV0dXJuIEJhc2UuaW1wb3J0SlNPTihqc29uLCB0aGlzKTtcbiAgICB9LFxuICAgIGV4cG9ydEpTT046IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gQmFzZS5leHBvcnRKU09OKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChwcm9wcywgZXhjbHVkZSkge1xuICAgICAgaWYgKHByb3BzKSBCYXNlLmZpbHRlcih0aGlzLCBwcm9wcywgZXhjbHVkZSwgdGhpcy5fcHJpb3JpdGl6ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBiZWFuczogZmFsc2UsXG4gICAgc3RhdGljczoge1xuICAgICAgZXhwb3J0czoge30sXG4gICAgICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICBuYW1lID0gcmVzLnByb3RvdHlwZS5fY2xhc3M7XG4gICAgICAgIGlmIChuYW1lICYmICFCYXNlLmV4cG9ydHNbbmFtZV0pIEJhc2UuZXhwb3J0c1tuYW1lXSA9IHJlcztcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0sXG4gICAgICBlcXVhbHM6IGZ1bmN0aW9uIChvYmoxLCBvYmoyKSB7XG4gICAgICAgIGlmIChvYmoxID09PSBvYmoyKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9iajEgJiYgb2JqMS5lcXVhbHMpIHJldHVybiBvYmoxLmVxdWFscyhvYmoyKTtcbiAgICAgICAgaWYgKG9iajIgJiYgb2JqMi5lcXVhbHMpIHJldHVybiBvYmoyLmVxdWFscyhvYmoxKTtcblxuICAgICAgICBpZiAob2JqMSAmJiBvYmoyICYmIHR5cGVvZiBvYmoxID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqMiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSAmJiBBcnJheS5pc0FycmF5KG9iajIpKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gb2JqMS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoICE9PSBvYmoyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgaWYgKCFCYXNlLmVxdWFscyhvYmoxW2xlbmd0aF0sIG9iajJbbGVuZ3RoXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmoxKSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgICAgICAgaWYgKCEob2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIEJhc2UuZXF1YWxzKG9iajFba2V5XSwgb2JqMltrZXldKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZWFkOiBmdW5jdGlvbiAobGlzdCwgc3RhcnQsIG9wdGlvbnMsIGFtb3VudCkge1xuICAgICAgICBpZiAodGhpcyA9PT0gQmFzZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGVlayhsaXN0LCBzdGFydCk7XG4gICAgICAgICAgbGlzdC5fX2luZGV4Kys7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3RvID0gdGhpcy5wcm90b3R5cGUsXG4gICAgICAgICAgICByZWFkSW5kZXggPSBwcm90by5fcmVhZEluZGV4LFxuICAgICAgICAgICAgYmVnaW4gPSBzdGFydCB8fCByZWFkSW5kZXggJiYgbGlzdC5fX2luZGV4IHx8IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBsaXN0Lmxlbmd0aCxcbiAgICAgICAgICAgIG9iaiA9IGxpc3RbYmVnaW5dO1xuICAgICAgICBhbW91bnQgPSBhbW91bnQgfHwgbGVuZ3RoIC0gYmVnaW47XG5cbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIHRoaXMgfHwgb3B0aW9ucyAmJiBvcHRpb25zLnJlYWROdWxsICYmIG9iaiA9PSBudWxsICYmIGFtb3VudCA8PSAxKSB7XG4gICAgICAgICAgaWYgKHJlYWRJbmRleCkgbGlzdC5fX2luZGV4ID0gYmVnaW4gKyAxO1xuICAgICAgICAgIHJldHVybiBvYmogJiYgb3B0aW9ucyAmJiBvcHRpb25zLmNsb25lID8gb2JqLmNsb25lKCkgOiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBCYXNlLmNyZWF0ZShwcm90byk7XG4gICAgICAgIGlmIChyZWFkSW5kZXgpIG9iai5fX3JlYWQgPSB0cnVlO1xuICAgICAgICBvYmogPSBvYmouaW5pdGlhbGl6ZS5hcHBseShvYmosIGJlZ2luID4gMCB8fCBiZWdpbiArIGFtb3VudCA8IGxlbmd0aCA/IEJhc2Uuc2xpY2UobGlzdCwgYmVnaW4sIGJlZ2luICsgYW1vdW50KSA6IGxpc3QpIHx8IG9iajtcblxuICAgICAgICBpZiAocmVhZEluZGV4KSB7XG4gICAgICAgICAgbGlzdC5fX2luZGV4ID0gYmVnaW4gKyBvYmouX19yZWFkO1xuICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IG9iai5fX2ZpbHRlcmVkO1xuXG4gICAgICAgICAgaWYgKGZpbHRlcmVkKSB7XG4gICAgICAgICAgICBsaXN0Ll9fZmlsdGVyZWQgPSBmaWx0ZXJlZDtcbiAgICAgICAgICAgIG9iai5fX2ZpbHRlcmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9iai5fX3JlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSxcbiAgICAgIHBlZWs6IGZ1bmN0aW9uIChsaXN0LCBzdGFydCkge1xuICAgICAgICByZXR1cm4gbGlzdFtsaXN0Ll9faW5kZXggPSBzdGFydCB8fCBsaXN0Ll9faW5kZXggfHwgMF07XG4gICAgICB9LFxuICAgICAgcmVtYWluOiBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICByZXR1cm4gbGlzdC5sZW5ndGggLSAobGlzdC5fX2luZGV4IHx8IDApO1xuICAgICAgfSxcbiAgICAgIHJlYWRMaXN0OiBmdW5jdGlvbiAobGlzdCwgc3RhcnQsIG9wdGlvbnMsIGFtb3VudCkge1xuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgIGJlZ2luID0gc3RhcnQgfHwgMCxcbiAgICAgICAgICAgIGVuZCA9IGFtb3VudCA/IGJlZ2luICsgYW1vdW50IDogbGlzdC5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICByZXMucHVzaChBcnJheS5pc0FycmF5KGVudHJ5ID0gbGlzdFtpXSkgPyB0aGlzLnJlYWQoZW50cnksIDAsIG9wdGlvbnMpIDogdGhpcy5yZWFkKGxpc3QsIGksIG9wdGlvbnMsIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9LFxuICAgICAgcmVhZE5hbWVkOiBmdW5jdGlvbiAobGlzdCwgbmFtZSwgc3RhcnQsIG9wdGlvbnMsIGFtb3VudCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpLFxuICAgICAgICAgICAgaGFzVmFsdWUgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGxpc3QuX19maWx0ZXJlZDtcblxuICAgICAgICAgIGlmICghZmlsdGVyZWQpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZShsaXN0KTtcbiAgICAgICAgICAgIGZpbHRlcmVkID0gbGlzdC5fX2ZpbHRlcmVkID0gQmFzZS5jcmVhdGUoc291cmNlKTtcbiAgICAgICAgICAgIGZpbHRlcmVkLl9fdW5maWx0ZXJlZCA9IHNvdXJjZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWx0ZXJlZFtuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWQoaGFzVmFsdWUgPyBbdmFsdWVdIDogbGlzdCwgc3RhcnQsIG9wdGlvbnMsIGFtb3VudCk7XG4gICAgICB9LFxuICAgICAgcmVhZFN1cHBvcnRlZDogZnVuY3Rpb24gKGxpc3QsIGRlc3QpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKGxpc3QpLFxuICAgICAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICByZWFkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGRlc3QpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhhdC5yZWFkTmFtZWQobGlzdCwga2V5KTtcblxuICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVhZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVhZDtcbiAgICAgIH0sXG4gICAgICBnZXRTb3VyY2U6IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBsaXN0Ll9fc291cmNlO1xuXG4gICAgICAgIGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBhcmcgPSBsaXN0Lmxlbmd0aCA9PT0gMSAmJiBsaXN0WzBdO1xuICAgICAgICAgIHNvdXJjZSA9IGxpc3QuX19zb3VyY2UgPSBhcmcgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZykgPyBhcmcgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH0sXG4gICAgICBnZXROYW1lZDogZnVuY3Rpb24gKGxpc3QsIG5hbWUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKGxpc3QpO1xuXG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZSA/IHNvdXJjZVtuYW1lXSA6IGxpc3QuX19maWx0ZXJlZCB8fCBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXNOYW1lZDogZnVuY3Rpb24gKGxpc3QsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICBmaWx0ZXI6IGZ1bmN0aW9uIChkZXN0LCBzb3VyY2UsIGV4Y2x1ZGUsIHByaW9yaXRpemUpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NlZDtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVLZXkoa2V5KSB7XG4gICAgICAgICAgaWYgKCEoZXhjbHVkZSAmJiBrZXkgaW4gZXhjbHVkZSkgJiYgIShwcm9jZXNzZWQgJiYga2V5IGluIHByb2Nlc3NlZCkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIGRlc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmlvcml0aXplKSB7XG4gICAgICAgICAgdmFyIGtleXMgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXksIGwgPSBwcmlvcml0aXplLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKChrZXkgPSBwcmlvcml0aXplW2ldKSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgaGFuZGxlS2V5KGtleSk7XG4gICAgICAgICAgICAgIGtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJvY2Vzc2VkID0ga2V5cztcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZS5fX3VuZmlsdGVyZWQgfHwgc291cmNlKS5mb3JFYWNoKGhhbmRsZUtleSk7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgfSxcbiAgICAgIGlzUGxhaW5WYWx1ZTogZnVuY3Rpb24gKG9iaiwgYXNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIEJhc2UuaXNQbGFpbk9iamVjdChvYmopIHx8IEFycmF5LmlzQXJyYXkob2JqKSB8fCBhc1N0cmluZyAmJiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcbiAgICAgIH0sXG4gICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMsIGNvbXBhY3QsIGRpY3Rpb25hcnkpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBpc1Jvb3QgPSAhZGljdGlvbmFyeSxcbiAgICAgICAgICAgIHJlcztcblxuICAgICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgICAgb3B0aW9ucy5mb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgICAgICBkaWN0aW9uYXJ5ID0ge1xuICAgICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgICAgZGVmaW5pdGlvbnM6IHt9LFxuICAgICAgICAgICAgcmVmZXJlbmNlczoge30sXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChpdGVtLCBjcmVhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gJyMnICsgaXRlbS5faWQsXG4gICAgICAgICAgICAgICAgICByZWYgPSB0aGlzLnJlZmVyZW5jZXNbaWRdO1xuXG4gICAgICAgICAgICAgIGlmICghcmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gY3JlYXRlLmNhbGwoaXRlbSksXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBpdGVtLl9jbGFzcztcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiByZXNbMF0gIT09IG5hbWUpIHJlcy51bnNoaWZ0KG5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbnNbaWRdID0gcmVzO1xuICAgICAgICAgICAgICAgIHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF0gPSBbaWRdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iaiAmJiBvYmouX3NlcmlhbGl6ZSkge1xuICAgICAgICAgIHJlcyA9IG9iai5fc2VyaWFsaXplKG9wdGlvbnMsIGRpY3Rpb25hcnkpO1xuICAgICAgICAgIHZhciBuYW1lID0gb2JqLl9jbGFzcztcblxuICAgICAgICAgIGlmIChuYW1lICYmICFvYmouX2NvbXBhY3RTZXJpYWxpemUgJiYgKGlzUm9vdCB8fCAhY29tcGFjdCkgJiYgcmVzWzBdICE9PSBuYW1lKSB7XG4gICAgICAgICAgICByZXMudW5zaGlmdChuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgcmVzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHJlc1tpXSA9IEJhc2Uuc2VyaWFsaXplKG9ialtpXSwgb3B0aW9ucywgY29tcGFjdCwgZGljdGlvbmFyeSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHJlc1trZXldID0gQmFzZS5zZXJpYWxpemUob2JqW2tleV0sIG9wdGlvbnMsIGNvbXBhY3QsIGRpY3Rpb25hcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJlcyA9IG9wdGlvbnMuZm9ybWF0dGVyLm51bWJlcihvYmosIG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNSb290ICYmIGRpY3Rpb25hcnkubGVuZ3RoID4gMCA/IFtbJ2RpY3Rpb25hcnknLCBkaWN0aW9uYXJ5LmRlZmluaXRpb25zXSwgcmVzXSA6IHJlcztcbiAgICAgIH0sXG4gICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGpzb24sIGNyZWF0ZSwgX2RhdGEsIF9zZXREaWN0aW9uYXJ5LCBfaXNSb290KSB7XG4gICAgICAgIHZhciByZXMgPSBqc29uLFxuICAgICAgICAgICAgaXNGaXJzdCA9ICFfZGF0YSxcbiAgICAgICAgICAgIGhhc0RpY3Rpb25hcnkgPSBpc0ZpcnN0ICYmIGpzb24gJiYganNvbi5sZW5ndGggJiYganNvblswXVswXSA9PT0gJ2RpY3Rpb25hcnknO1xuICAgICAgICBfZGF0YSA9IF9kYXRhIHx8IHt9O1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBqc29uWzBdLFxuICAgICAgICAgICAgICBpc0RpY3Rpb25hcnkgPSB0eXBlID09PSAnZGljdGlvbmFyeSc7XG5cbiAgICAgICAgICBpZiAoanNvbi5sZW5ndGggPT0gMSAmJiAvXiMvLnRlc3QodHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfZGF0YS5kaWN0aW9uYXJ5W3R5cGVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHR5cGUgPSBCYXNlLmV4cG9ydHNbdHlwZV07XG4gICAgICAgICAgcmVzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gdHlwZSA/IDEgOiAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKEJhc2UuZGVzZXJpYWxpemUoanNvbltpXSwgY3JlYXRlLCBfZGF0YSwgaXNEaWN0aW9uYXJ5LCBoYXNEaWN0aW9uYXJ5KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gcmVzO1xuXG4gICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh0eXBlLCBhcmdzLCBpc0ZpcnN0IHx8IF9pc1Jvb3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzID0gbmV3IHR5cGUoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChqc29uKSkge1xuICAgICAgICAgIHJlcyA9IHt9O1xuICAgICAgICAgIGlmIChfc2V0RGljdGlvbmFyeSkgX2RhdGEuZGljdGlvbmFyeSA9IHJlcztcblxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBqc29uKSByZXNba2V5XSA9IEJhc2UuZGVzZXJpYWxpemUoanNvbltrZXldLCBjcmVhdGUsIF9kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNEaWN0aW9uYXJ5ID8gcmVzWzFdIDogcmVzO1xuICAgICAgfSxcbiAgICAgIGV4cG9ydEpTT046IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGpzb24gPSBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmFzU3RyaW5nID09IGZhbHNlID8ganNvbiA6IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuICAgICAgfSxcbiAgICAgIGltcG9ydEpTT046IGZ1bmN0aW9uIChqc29uLCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIEJhc2UuZGVzZXJpYWxpemUodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb24sIGZ1bmN0aW9uIChjdG9yLCBhcmdzLCBpc1Jvb3QpIHtcbiAgICAgICAgICB2YXIgdXNlVGFyZ2V0ID0gaXNSb290ICYmIHRhcmdldCAmJiB0YXJnZXQuY29uc3RydWN0b3IgPT09IGN0b3IsXG4gICAgICAgICAgICAgIG9iaiA9IHVzZVRhcmdldCA/IHRhcmdldCA6IEJhc2UuY3JlYXRlKGN0b3IucHJvdG90eXBlKTtcblxuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBvYmogaW5zdGFuY2VvZiBJdGVtICYmICh1c2VUYXJnZXQgfHwgIShvYmogaW5zdGFuY2VvZiBMYXllcikpKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc1swXTtcblxuICAgICAgICAgICAgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKSB7XG4gICAgICAgICAgICAgIGFyZy5pbnNlcnQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAodXNlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFt7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAodXNlVGFyZ2V0ID8gb2JqLnNldCA6IGN0b3IpLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgICAgaWYgKHVzZVRhcmdldCkgdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBwdXNoOiBmdW5jdGlvbiAobGlzdCwgaXRlbXMpIHtcbiAgICAgICAgdmFyIGl0ZW1zTGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChpdGVtc0xlbmd0aCA8IDQwOTYpIHtcbiAgICAgICAgICBsaXN0LnB1c2guYXBwbHkobGlzdCwgaXRlbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFydExlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgIGxpc3QubGVuZ3RoICs9IGl0ZW1zTGVuZ3RoO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0W3N0YXJ0TGVuZ3RoICsgaV0gPSBpdGVtc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH0sXG4gICAgICBzcGxpY2U6IGZ1bmN0aW9uIChsaXN0LCBpdGVtcywgaW5kZXgsIHJlbW92ZSkge1xuICAgICAgICB2YXIgYW1vdW50ID0gaXRlbXMgJiYgaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgYXBwZW5kID0gaW5kZXggPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaW5kZXggPSBhcHBlbmQgPyBsaXN0Lmxlbmd0aCA6IGluZGV4O1xuICAgICAgICBpZiAoaW5kZXggPiBsaXN0Lmxlbmd0aCkgaW5kZXggPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSBpdGVtc1tpXS5faW5kZXggPSBpbmRleCArIGk7XG5cbiAgICAgICAgaWYgKGFwcGVuZCkge1xuICAgICAgICAgIEJhc2UucHVzaChsaXN0LCBpdGVtcyk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhcmdzID0gW2luZGV4LCByZW1vdmVdO1xuICAgICAgICAgIGlmIChpdGVtcykgQmFzZS5wdXNoKGFyZ3MsIGl0ZW1zKTtcbiAgICAgICAgICB2YXIgcmVtb3ZlZCA9IGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZW1vdmVkLmxlbmd0aDsgaSA8IGw7IGkrKykgcmVtb3ZlZFtpXS5faW5kZXggPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykgbGlzdFtpXS5faW5kZXggPSBpO1xuXG4gICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYXBpdGFsaXplOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxiW2Etel0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNhbWVsaXplOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGNocikge1xuICAgICAgICAgIHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaHlwaGVuYXRlOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgRW1pdHRlciA9IHtcbiAgICBvbjogZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgQmFzZS5lYWNoKHR5cGUsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgdGhpcy5vbihrZXksIHZhbHVlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuICAgICAgICAgICAgZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcbiAgICAgICAgICAgIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgICBoYW5kbGVycyA9IGhhbmRsZXJzW3R5cGVdID0gaGFuZGxlcnNbdHlwZV0gfHwgW107XG5cbiAgICAgICAgaWYgKGhhbmRsZXJzLmluZGV4T2YoZnVuYykgPT09IC0xKSB7XG4gICAgICAgICAgaGFuZGxlcnMucHVzaChmdW5jKTtcbiAgICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkuaW5zdGFsbCAmJiBoYW5kbGVycy5sZW5ndGggPT09IDEpIGVudHJ5Lmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgQmFzZS5lYWNoKHR5cGUsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgdGhpcy5vZmYoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG4gICAgICAgICAgZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcbiAgICAgICAgICBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0sXG4gICAgICAgICAgaW5kZXg7XG5cbiAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICBpZiAoIWZ1bmMgfHwgKGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZihmdW5jKSkgIT09IC0xICYmIGhhbmRsZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS51bmluc3RhbGwpIGVudHJ5LnVuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG9uY2U6IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgICByZXR1cm4gdGhpcy5vbih0eXBlLCBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMub2ZmKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiAodHlwZSwgZXZlbnQpIHtcbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG4gICAgICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgYXJncyA9IEJhc2Uuc2xpY2UoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICBzZXRUYXJnZXQgPSBldmVudCAmJiBldmVudC50YXJnZXQgJiYgIWV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBoYW5kbGVycyA9IGhhbmRsZXJzLnNsaWNlKCk7XG4gICAgICBpZiAoc2V0VGFyZ2V0KSBldmVudC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGhhbmRsZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpID09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnN0b3ApIGV2ZW50LnN0b3AoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0VGFyZ2V0KSBkZWxldGUgZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcmVzcG9uZHM6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICByZXR1cm4gISEodGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSk7XG4gICAgfSxcbiAgICBhdHRhY2g6ICcjb24nLFxuICAgIGRldGFjaDogJyNvZmYnLFxuICAgIGZpcmU6ICcjZW1pdCcsXG4gICAgX2luc3RhbGxFdmVudHM6IGZ1bmN0aW9uIChpbnN0YWxsKSB7XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuICAgICAgICAgIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzLFxuICAgICAgICAgIGtleSA9IGluc3RhbGwgPyAnaW5zdGFsbCcgOiAndW5pbnN0YWxsJztcblxuICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdHlwZXNbdHlwZV0sXG4gICAgICAgICAgICAgICAgZnVuYyA9IGVudHJ5ICYmIGVudHJ5W2tleV07XG4gICAgICAgICAgICBpZiAoZnVuYykgZnVuYy5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3RhdGljczoge1xuICAgICAgaW5qZWN0OiBmdW5jdGlvbiBpbmplY3Qoc3JjKSB7XG4gICAgICAgIHZhciBldmVudHMgPSBzcmMuX2V2ZW50cztcblxuICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgdmFyIHR5cGVzID0ge307XG4gICAgICAgICAgQmFzZS5lYWNoKGV2ZW50cywgZnVuY3Rpb24gKGVudHJ5LCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgbmFtZSA9IGlzU3RyaW5nID8gZW50cnkgOiBrZXksXG4gICAgICAgICAgICAgICAgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcbiAgICAgICAgICAgICAgICB0eXBlID0gbmFtZS5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gaXNTdHJpbmcgPyB7fSA6IGVudHJ5O1xuICAgICAgICAgICAgbmFtZSA9ICdfJyArIG5hbWU7XG5cbiAgICAgICAgICAgIHNyY1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNyY1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgICBpZiAocHJldikgdGhpcy5vZmYodHlwZSwgcHJldik7XG4gICAgICAgICAgICAgIGlmIChmdW5jKSB0aGlzLm9uKHR5cGUsIGZ1bmMpO1xuICAgICAgICAgICAgICB0aGlzW25hbWVdID0gZnVuYztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3JjLl9ldmVudFR5cGVzID0gdHlwZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5qZWN0LmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBQYXBlclNjb3BlID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1BhcGVyU2NvcGUnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhcGVyU2NvcGUoKSB7XG4gICAgICBwYXBlciA9IHRoaXM7XG4gICAgICB0aGlzLnNldHRpbmdzID0gbmV3IEJhc2Uoe1xuICAgICAgICBhcHBseU1hdHJpeDogdHJ1ZSxcbiAgICAgICAgaW5zZXJ0SXRlbXM6IHRydWUsXG4gICAgICAgIGhhbmRsZVNpemU6IDQsXG4gICAgICAgIGhpdFRvbGVyYW5jZTogMFxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb2plY3QgPSBudWxsO1xuICAgICAgdGhpcy5wcm9qZWN0cyA9IFtdO1xuICAgICAgdGhpcy50b29scyA9IFtdO1xuICAgICAgdGhpcy5faWQgPSBQYXBlclNjb3BlLl9pZCsrO1xuICAgICAgUGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXSA9IHRoaXM7XG4gICAgICB2YXIgcHJvdG8gPSBQYXBlclNjb3BlLnByb3RvdHlwZTtcblxuICAgICAgaWYgKCF0aGlzLnN1cHBvcnQpIHtcbiAgICAgICAgdmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSkgfHwge307XG4gICAgICAgIHByb3RvLnN1cHBvcnQgPSB7XG4gICAgICAgICAgbmF0aXZlRGFzaDogJ3NldExpbmVEYXNoJyBpbiBjdHggfHwgJ21vekRhc2gnIGluIGN0eCxcbiAgICAgICAgICBuYXRpdmVCbGVuZE1vZGVzOiBCbGVuZE1vZGUubmF0aXZlTW9kZXNcbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuYWdlbnQpIHtcbiAgICAgICAgdmFyIHVzZXIgPSBzZWxmLm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIG9zID0gKC8oZGFyd2lufHdpbnxtYWN8bGludXh8ZnJlZWJzZHxzdW5vcykvLmV4ZWModXNlcikgfHwgW10pWzBdLFxuICAgICAgICAgICAgcGxhdGZvcm0gPSBvcyA9PT0gJ2RhcndpbicgPyAnbWFjJyA6IG9zLFxuICAgICAgICAgICAgYWdlbnQgPSBwcm90by5hZ2VudCA9IHByb3RvLmJyb3dzZXIgPSB7XG4gICAgICAgICAgcGxhdGZvcm06IHBsYXRmb3JtXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwbGF0Zm9ybSkgYWdlbnRbcGxhdGZvcm1dID0gdHJ1ZTtcbiAgICAgICAgdXNlci5yZXBsYWNlKC8ob3BlcmF8Y2hyb21lfHNhZmFyaXx3ZWJraXR8ZmlyZWZveHxtc2llfHRyaWRlbnR8YXRvbXxub2RlfGpzZG9tKVxcLz9cXHMqKFsuXFxkXSspKD86Lip2ZXJzaW9uXFwvKFsuXFxkXSspKT8oPzouKnJ2XFw6dj8oWy5cXGRdKykpPy9nLCBmdW5jdGlvbiAobWF0Y2gsIG4sIHYxLCB2MiwgcnYpIHtcbiAgICAgICAgICBpZiAoIWFnZW50LmNocm9tZSkge1xuICAgICAgICAgICAgdmFyIHYgPSBuID09PSAnb3BlcmEnID8gdjIgOiAvXihub2RlfHRyaWRlbnQpJC8udGVzdChuKSA/IHJ2IDogdjE7XG4gICAgICAgICAgICBhZ2VudC52ZXJzaW9uID0gdjtcbiAgICAgICAgICAgIGFnZW50LnZlcnNpb25OdW1iZXIgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgICAgICAgbiA9IHtcbiAgICAgICAgICAgICAgdHJpZGVudDogJ21zaWUnLFxuICAgICAgICAgICAgICBqc2RvbTogJ25vZGUnXG4gICAgICAgICAgICB9W25dIHx8IG47XG4gICAgICAgICAgICBhZ2VudC5uYW1lID0gbjtcbiAgICAgICAgICAgIGFnZW50W25dID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWdlbnQuY2hyb21lKSBkZWxldGUgYWdlbnQud2Via2l0O1xuICAgICAgICBpZiAoYWdlbnQuYXRvbSkgZGVsZXRlIGFnZW50LmNocm9tZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZlcnNpb246IFwiMC4xMi4xMVwiLFxuICAgIGdldFZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5wcm9qZWN0O1xuICAgICAgcmV0dXJuIHByb2plY3QgJiYgcHJvamVjdC5fdmlldztcbiAgICB9LFxuICAgIGdldFBhcGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChjb2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZXhwb3J0cyA9IHBhcGVyLlBhcGVyU2NyaXB0LmV4ZWN1dGUoY29kZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgICBWaWV3LnVwZGF0ZUZvY3VzKCk7XG4gICAgICByZXR1cm4gZXhwb3J0cztcbiAgICB9LFxuICAgIGluc3RhbGw6IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgQmFzZS5lYWNoKFsncHJvamVjdCcsICd2aWV3JywgJ3Rvb2wnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBCYXNlLmRlZmluZShzY29wZSwga2V5LCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoYXRba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSBpZiAoIS9eXy8udGVzdChrZXkpICYmIHRoaXNba2V5XSkgc2NvcGVba2V5XSA9IHRoaXNba2V5XTtcbiAgICB9LFxuICAgIHNldHVwOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcGFwZXIgPSB0aGlzO1xuICAgICAgdGhpcy5wcm9qZWN0ID0gbmV3IFByb2plY3QoZWxlbWVudCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNyZWF0ZUNhbnZhczogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBDYW52YXNQcm92aWRlci5nZXRDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBhY3RpdmF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcGFwZXIgPSB0aGlzO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm9qZWN0cyA9IHRoaXMucHJvamVjdHMsXG4gICAgICAgICAgdG9vbHMgPSB0aGlzLnRvb2xzO1xuXG4gICAgICBmb3IgKHZhciBpID0gcHJvamVjdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHByb2plY3RzW2ldLnJlbW92ZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gdG9vbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHRvb2xzW2ldLnJlbW92ZSgpO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICBkZWxldGUgUGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXTtcbiAgICB9LFxuICAgIHN0YXRpY3M6IG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICBuYW1lICs9ICdBdHRyaWJ1dGUnO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsLCBhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIGVsW25hbWVdKGF0dHIpIHx8IGVsW25hbWVdKCdkYXRhLXBhcGVyLScgKyBhdHRyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3Njb3Blczoge30sXG4gICAgICAgIF9pZDogMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGVzW2lkXSB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBnZXRBdHRyaWJ1dGU6IGhhbmRsZUF0dHJpYnV0ZSgnZ2V0JyksXG4gICAgICAgIGhhc0F0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdoYXMnKVxuICAgICAgfTtcbiAgICB9KClcbiAgfSk7XG4gIHZhciBQYXBlclNjb3BlSXRlbSA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoYWN0aXZhdGUpIHtcbiAgICAgIHRoaXMuX3Njb3BlID0gcGFwZXI7XG4gICAgICB0aGlzLl9pbmRleCA9IHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLnB1c2godGhpcykgLSAxO1xuICAgICAgaWYgKGFjdGl2YXRlIHx8ICF0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdKSB0aGlzLmFjdGl2YXRlKCk7XG4gICAgfSxcbiAgICBhY3RpdmF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9zY29wZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHByZXYgPSB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdO1xuICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gdGhpcykgcHJldi5lbWl0KCdkZWFjdGl2YXRlJyk7XG4gICAgICB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID0gdGhpcztcbiAgICAgIHRoaXMuZW1pdCgnYWN0aXZhdGUnLCBwcmV2KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09PSB0aGlzO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5faW5kZXggPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgQmFzZS5zcGxpY2UodGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0sIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcbiAgICAgIGlmICh0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09IHRoaXMpIHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSBudWxsO1xuICAgICAgdGhpcy5fc2NvcGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2NvcGUuZ2V0VmlldygpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBDb2xsaXNpb25EZXRlY3Rpb24gPSB7XG4gICAgZmluZEl0ZW1Cb3VuZHNDb2xsaXNpb25zOiBmdW5jdGlvbiAoaXRlbXMxLCBpdGVtczIsIHRvbGVyYW5jZSkge1xuICAgICAgZnVuY3Rpb24gZ2V0Qm91bmRzKGl0ZW1zKSB7XG4gICAgICAgIHZhciBib3VuZHMgPSBuZXcgQXJyYXkoaXRlbXMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSBpdGVtc1tpXS5nZXRCb3VuZHMoKTtcbiAgICAgICAgICBib3VuZHNbaV0gPSBbcmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC5yaWdodCwgcmVjdC5ib3R0b21dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdW5kczEgPSBnZXRCb3VuZHMoaXRlbXMxKSxcbiAgICAgICAgICBib3VuZHMyID0gIWl0ZW1zMiB8fCBpdGVtczIgPT09IGl0ZW1zMSA/IGJvdW5kczEgOiBnZXRCb3VuZHMoaXRlbXMyKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRCb3VuZHNDb2xsaXNpb25zKGJvdW5kczEsIGJvdW5kczIsIHRvbGVyYW5jZSB8fCAwKTtcbiAgICB9LFxuICAgIGZpbmRDdXJ2ZUJvdW5kc0NvbGxpc2lvbnM6IGZ1bmN0aW9uIChjdXJ2ZXMxLCBjdXJ2ZXMyLCB0b2xlcmFuY2UsIGJvdGhBeGlzKSB7XG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZHMoY3VydmVzKSB7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4LFxuICAgICAgICAgICAgYm91bmRzID0gbmV3IEFycmF5KGN1cnZlcy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHYgPSBjdXJ2ZXNbaV07XG4gICAgICAgICAgYm91bmRzW2ldID0gW21pbih2WzBdLCB2WzJdLCB2WzRdLCB2WzZdKSwgbWluKHZbMV0sIHZbM10sIHZbNV0sIHZbN10pLCBtYXgodlswXSwgdlsyXSwgdls0XSwgdls2XSksIG1heCh2WzFdLCB2WzNdLCB2WzVdLCB2WzddKV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRzMSA9IGdldEJvdW5kcyhjdXJ2ZXMxKSxcbiAgICAgICAgICBib3VuZHMyID0gIWN1cnZlczIgfHwgY3VydmVzMiA9PT0gY3VydmVzMSA/IGJvdW5kczEgOiBnZXRCb3VuZHMoY3VydmVzMik7XG5cbiAgICAgIGlmIChib3RoQXhpcykge1xuICAgICAgICB2YXIgaG9yID0gdGhpcy5maW5kQm91bmRzQ29sbGlzaW9ucyhib3VuZHMxLCBib3VuZHMyLCB0b2xlcmFuY2UgfHwgMCwgZmFsc2UsIHRydWUpLFxuICAgICAgICAgICAgdmVyID0gdGhpcy5maW5kQm91bmRzQ29sbGlzaW9ucyhib3VuZHMxLCBib3VuZHMyLCB0b2xlcmFuY2UgfHwgMCwgdHJ1ZSwgdHJ1ZSksXG4gICAgICAgICAgICBsaXN0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3IubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbGlzdFtpXSA9IHtcbiAgICAgICAgICAgIGhvcjogaG9yW2ldLFxuICAgICAgICAgICAgdmVyOiB2ZXJbaV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZpbmRCb3VuZHNDb2xsaXNpb25zKGJvdW5kczEsIGJvdW5kczIsIHRvbGVyYW5jZSB8fCAwKTtcbiAgICB9LFxuICAgIGZpbmRCb3VuZHNDb2xsaXNpb25zOiBmdW5jdGlvbiAoYm91bmRzQSwgYm91bmRzQiwgdG9sZXJhbmNlLCBzd2VlcFZlcnRpY2FsLCBvbmx5U3dlZXBBeGlzQ29sbGlzaW9ucykge1xuICAgICAgdmFyIHNlbGYgPSAhYm91bmRzQiB8fCBib3VuZHNBID09PSBib3VuZHNCLFxuICAgICAgICAgIGFsbEJvdW5kcyA9IHNlbGYgPyBib3VuZHNBIDogYm91bmRzQS5jb25jYXQoYm91bmRzQiksXG4gICAgICAgICAgbGVuZ3RoQSA9IGJvdW5kc0EubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aEFsbCA9IGFsbEJvdW5kcy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChpbmRpY2VzLCBjb29yZCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGxvID0gMCxcbiAgICAgICAgICAgIGhpID0gaW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICB2YXIgbWlkID0gaGkgKyBsbyA+Pj4gMTtcblxuICAgICAgICAgIGlmIChhbGxCb3VuZHNbaW5kaWNlc1ttaWRdXVtjb29yZF0gPCB2YWx1ZSkge1xuICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG8gLSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJpMCA9IHN3ZWVwVmVydGljYWwgPyAxIDogMCxcbiAgICAgICAgICBwcmkxID0gcHJpMCArIDIsXG4gICAgICAgICAgc2VjMCA9IHN3ZWVwVmVydGljYWwgPyAwIDogMSxcbiAgICAgICAgICBzZWMxID0gc2VjMCArIDI7XG4gICAgICB2YXIgYWxsSW5kaWNlc0J5UHJpMCA9IG5ldyBBcnJheShsZW5ndGhBbGwpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aEFsbDsgaSsrKSB7XG4gICAgICAgIGFsbEluZGljZXNCeVByaTBbaV0gPSBpO1xuICAgICAgfVxuXG4gICAgICBhbGxJbmRpY2VzQnlQcmkwLnNvcnQoZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICByZXR1cm4gYWxsQm91bmRzW2kxXVtwcmkwXSAtIGFsbEJvdW5kc1tpMl1bcHJpMF07XG4gICAgICB9KTtcbiAgICAgIHZhciBhY3RpdmVJbmRpY2VzQnlQcmkxID0gW10sXG4gICAgICAgICAgYWxsQ29sbGlzaW9ucyA9IG5ldyBBcnJheShsZW5ndGhBKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhBbGw7IGkrKykge1xuICAgICAgICB2YXIgY3VySW5kZXggPSBhbGxJbmRpY2VzQnlQcmkwW2ldLFxuICAgICAgICAgICAgY3VyQm91bmRzID0gYWxsQm91bmRzW2N1ckluZGV4XSxcbiAgICAgICAgICAgIG9yaWdJbmRleCA9IHNlbGYgPyBjdXJJbmRleCA6IGN1ckluZGV4IC0gbGVuZ3RoQSxcbiAgICAgICAgICAgIGlzQ3VycmVudEEgPSBjdXJJbmRleCA8IGxlbmd0aEEsXG4gICAgICAgICAgICBpc0N1cnJlbnRCID0gc2VsZiB8fCAhaXNDdXJyZW50QSxcbiAgICAgICAgICAgIGN1ckNvbGxpc2lvbnMgPSBpc0N1cnJlbnRBID8gW10gOiBudWxsO1xuXG4gICAgICAgIGlmIChhY3RpdmVJbmRpY2VzQnlQcmkxLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBwcnVuZUNvdW50ID0gYmluYXJ5U2VhcmNoKGFjdGl2ZUluZGljZXNCeVByaTEsIHByaTEsIGN1ckJvdW5kc1twcmkwXSAtIHRvbGVyYW5jZSkgKyAxO1xuICAgICAgICAgIGFjdGl2ZUluZGljZXNCeVByaTEuc3BsaWNlKDAsIHBydW5lQ291bnQpO1xuXG4gICAgICAgICAgaWYgKHNlbGYgJiYgb25seVN3ZWVwQXhpc0NvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgIGN1ckNvbGxpc2lvbnMgPSBjdXJDb2xsaXNpb25zLmNvbmNhdChhY3RpdmVJbmRpY2VzQnlQcmkxKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhY3RpdmVJbmRpY2VzQnlQcmkxLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBhY3RpdmVJbmRleCA9IGFjdGl2ZUluZGljZXNCeVByaTFbal07XG4gICAgICAgICAgICAgIGFsbENvbGxpc2lvbnNbYWN0aXZlSW5kZXhdLnB1c2gob3JpZ0luZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1clNlYzEgPSBjdXJCb3VuZHNbc2VjMV0sXG4gICAgICAgICAgICAgICAgY3VyU2VjMCA9IGN1ckJvdW5kc1tzZWMwXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhY3RpdmVJbmRpY2VzQnlQcmkxLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBhY3RpdmVJbmRleCA9IGFjdGl2ZUluZGljZXNCeVByaTFbal0sXG4gICAgICAgICAgICAgICAgICBhY3RpdmVCb3VuZHMgPSBhbGxCb3VuZHNbYWN0aXZlSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgaXNBY3RpdmVBID0gYWN0aXZlSW5kZXggPCBsZW5ndGhBLFxuICAgICAgICAgICAgICAgICAgaXNBY3RpdmVCID0gc2VsZiB8fCBhY3RpdmVJbmRleCA+PSBsZW5ndGhBO1xuXG4gICAgICAgICAgICAgIGlmIChvbmx5U3dlZXBBeGlzQ29sbGlzaW9ucyB8fCAoaXNDdXJyZW50QSAmJiBpc0FjdGl2ZUIgfHwgaXNDdXJyZW50QiAmJiBpc0FjdGl2ZUEpICYmIGN1clNlYzEgPj0gYWN0aXZlQm91bmRzW3NlYzBdIC0gdG9sZXJhbmNlICYmIGN1clNlYzAgPD0gYWN0aXZlQm91bmRzW3NlYzFdICsgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEEgJiYgaXNBY3RpdmVCKSB7XG4gICAgICAgICAgICAgICAgICBjdXJDb2xsaXNpb25zLnB1c2goc2VsZiA/IGFjdGl2ZUluZGV4IDogYWN0aXZlSW5kZXggLSBsZW5ndGhBKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50QiAmJiBpc0FjdGl2ZUEpIHtcbiAgICAgICAgICAgICAgICAgIGFsbENvbGxpc2lvbnNbYWN0aXZlSW5kZXhdLnB1c2gob3JpZ0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDdXJyZW50QSkge1xuICAgICAgICAgIGlmIChib3VuZHNBID09PSBib3VuZHNCKSB7XG4gICAgICAgICAgICBjdXJDb2xsaXNpb25zLnB1c2goY3VySW5kZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFsbENvbGxpc2lvbnNbY3VySW5kZXhdID0gY3VyQ29sbGlzaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3RpdmVJbmRpY2VzQnlQcmkxLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBjdXJQcmkxID0gY3VyQm91bmRzW3ByaTFdLFxuICAgICAgICAgICAgICBpbmRleCA9IGJpbmFyeVNlYXJjaChhY3RpdmVJbmRpY2VzQnlQcmkxLCBwcmkxLCBjdXJQcmkxKTtcbiAgICAgICAgICBhY3RpdmVJbmRpY2VzQnlQcmkxLnNwbGljZShpbmRleCArIDEsIDAsIGN1ckluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3RpdmVJbmRpY2VzQnlQcmkxLnB1c2goY3VySW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsQ29sbGlzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29sbGlzaW9ucyA9IGFsbENvbGxpc2lvbnNbaV07XG5cbiAgICAgICAgaWYgKGNvbGxpc2lvbnMpIHtcbiAgICAgICAgICBjb2xsaXNpb25zLnNvcnQoZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgICAgcmV0dXJuIGkxIC0gaTI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbENvbGxpc2lvbnM7XG4gICAgfVxuICB9O1xuICB2YXIgRm9ybWF0dGVyID0gQmFzZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gQmFzZS5waWNrKHByZWNpc2lvbiwgNSk7XG4gICAgICB0aGlzLm11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgdGhpcy5wcmVjaXNpb24pO1xuICAgIH0sXG4gICAgbnVtYmVyOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVjaXNpb24gPCAxNiA/IE1hdGgucm91bmQodmFsICogdGhpcy5tdWx0aXBsaWVyKSAvIHRoaXMubXVsdGlwbGllciA6IHZhbDtcbiAgICB9LFxuICAgIHBhaXI6IGZ1bmN0aW9uICh2YWwxLCB2YWwyLCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWJlcih2YWwxKSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbDIpO1xuICAgIH0sXG4gICAgcG9pbnQ6IGZ1bmN0aW9uICh2YWwsIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHRoaXMubnVtYmVyKHZhbC54KSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbC55KTtcbiAgICB9LFxuICAgIHNpemU6IGZ1bmN0aW9uICh2YWwsIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHRoaXMubnVtYmVyKHZhbC53aWR0aCkgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLm51bWJlcih2YWwuaGVpZ2h0KTtcbiAgICB9LFxuICAgIHJlY3RhbmdsZTogZnVuY3Rpb24gKHZhbCwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb2ludCh2YWwsIHNlcGFyYXRvcikgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLnNpemUodmFsLCBzZXBhcmF0b3IpO1xuICAgIH1cbiAgfSk7XG4gIEZvcm1hdHRlci5pbnN0YW5jZSA9IG5ldyBGb3JtYXR0ZXIoKTtcbiAgdmFyIE51bWVyaWNhbCA9IG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFic2Npc3NhcyA9IFtbMC41NzczNTAyNjkxODk2MjU3NjQ1MDkxNDg4XSwgWzAsIDAuNzc0NTk2NjY5MjQxNDgzMzc3MDM1ODUzMV0sIFswLjMzOTk4MTA0MzU4NDg1NjI2NDgwMjY2NTgsIDAuODYxMTM2MzExNTk0MDUyNTc1MjIzOTQ2NV0sIFswLCAwLjUzODQ2OTMxMDEwNTY4MzA5MTAzNjMxNDQsIDAuOTA2MTc5ODQ1OTM4NjYzOTkyNzk3NjI2OV0sIFswLjIzODYxOTE4NjA4MzE5NjkwODYzMDUwMTcsIDAuNjYxMjA5Mzg2NDY2MjY0NTEzNjYxMzk5NiwgMC45MzI0Njk1MTQyMDMxNTIwMjc4MTIzMDE2XSwgWzAsIDAuNDA1ODQ1MTUxMzc3Mzk3MTY2OTA2NjA2NCwgMC43NDE1MzExODU1OTkzOTQ0Mzk4NjM4NjQ4LCAwLjk0OTEwNzkxMjM0Mjc1ODUyNDUyNjE4OTddLCBbMC4xODM0MzQ2NDI0OTU2NDk4MDQ5Mzk0NzYxLCAwLjUyNTUzMjQwOTkxNjMyODk4NTgxNzczOTAsIDAuNzk2NjY2NDc3NDEzNjI2NzM5NTkxNTUzOSwgMC45NjAyODk4NTY0OTc1MzYyMzE2ODM1NjA5XSwgWzAsIDAuMzI0MjUzNDIzNDAzODA4OTI5MDM4NTM4MCwgMC42MTMzNzE0MzI3MDA1OTAzOTczMDg3MDIwLCAwLjgzNjAzMTEwNzMyNjYzNTc5NDI5OTQyOTgsIDAuOTY4MTYwMjM5NTA3NjI2MDg5ODM1NTc2Ml0sIFswLjE0ODg3NDMzODk4MTYzMTIxMDg4NDgyNjAsIDAuNDMzMzk1Mzk0MTI5MjQ3MTkwNzk5MjY1OSwgMC42Nzk0MDk1NjgyOTkwMjQ0MDYyMzQzMjc0LCAwLjg2NTA2MzM2NjY4ODk4NDUxMDczMjA5NjcsIDAuOTczOTA2NTI4NTE3MTcxNzIwMDc3OTY0MF0sIFswLCAwLjI2OTU0MzE1NTk1MjM0NDk3MjMzMTUzMjAsIDAuNTE5MDk2MTI5MjA2ODExODE1OTI1NzI1NywgMC43MzAxNTIwMDU1NzQwNDkzMjQwOTM0MTYzLCAwLjg4NzA2MjU5OTc2ODA5NTI5OTA3NTE1NzgsIDAuOTc4MjI4NjU4MTQ2MDU2OTkyODAzOTM4MF0sIFswLjEyNTIzMzQwODUxMTQ2ODkxNTQ3MjQ0MTQsIDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNSwgMC41ODczMTc5NTQyODY2MTc0NDcyOTY3MDI0LCAwLjc2OTkwMjY3NDE5NDMwNDY4NzAzNjg5MzgsIDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1OSwgMC45ODE1NjA2MzQyNDY3MTkyNTA2OTA1NDkxXSwgWzAsIDAuMjMwNDU4MzE1OTU1MTM0Nzk0MDY1NTI4MSwgMC40NDg0OTI3NTEwMzY0NDY4NTI4Nzc5MTI5LCAwLjY0MjM0OTMzOTQ0MDM0MDIyMDY0Mzk4NDYsIDAuODAxNTc4MDkwNzMzMzA5OTEyNzk0MjA2NSwgMC45MTc1OTgzOTkyMjI5Nzc5NjUyMDY1NDc4LCAwLjk4NDE4MzA1NDcxODU4ODE0OTQ3MjgyOTRdLCBbMC4xMDgwNTQ5NDg3MDczNDM2NjIwNjYyNDQ3LCAwLjMxOTExMjM2ODkyNzg4OTc2MDQzNTY3MTgsIDAuNTE1MjQ4NjM2MzU4MTU0MDkxOTY1MjkwNywgMC42ODcyOTI5MDQ4MTE2ODU0NzAxNDgwMTk4LCAwLjgyNzIwMTMxNTA2OTc2NDk5MzE4OTc5NDcsIDAuOTI4NDM0ODgzNjYzNTczNTE3MzM2MzkxMSwgMC45ODYyODM4MDg2OTY4MTIzMzg4NDE1OTczXSwgWzAsIDAuMjAxMTk0MDkzOTk3NDM0NTIyMzAwNjI4MywgMC4zOTQxNTEzNDcwNzc1NjMzNjk4OTcyMDc0LCAwLjU3MDk3MjE3MjYwODUzODg0NzUzNzIyNjcsIDAuNzI0NDE3NzMxMzYwMTcwMDQ3NDE2MTg2MSwgMC44NDgyMDY1ODM0MTA0MjcyMTYyMDA2NDgzLCAwLjkzNzI3MzM5MjQwMDcwNTkwNDMwNzc1ODksIDAuOTg3OTkyNTE4MDIwNDg1NDI4NDg5NTY1N10sIFswLjA5NTAxMjUwOTgzNzYzNzQ0MDE4NTMxOTMsIDAuMjgxNjAzNTUwNzc5MjU4OTEzMjMwNDYwNSwgMC40NTgwMTY3Nzc2NTcyMjczODYzNDI0MTk0LCAwLjYxNzg3NjI0NDQwMjY0Mzc0ODQ0NjY3MTgsIDAuNzU1NDA0NDA4MzU1MDAzMDMzODk1MTAxMiwgMC44NjU2MzEyMDIzODc4MzE3NDM4ODA0Njc5LCAwLjk0NDU3NTAyMzA3MzIzMjU3NjA3Nzk4ODQsIDAuOTg5NDAwOTM0OTkxNjQ5OTMyNTk2MTU0Ml1dO1xuICAgIHZhciB3ZWlnaHRzID0gW1sxXSwgWzAuODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwgMC41NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU2XSwgWzAuNjUyMTQ1MTU0ODYyNTQ2MTQyNjI2OTM2MSwgMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSwgWzAuNTY4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwgMC40Nzg2Mjg2NzA0OTkzNjY0NjgwNDEyOTE1LCAwLjIzNjkyNjg4NTA1NjE4OTA4NzUxNDI2NDBdLCBbMC40Njc5MTM5MzQ1NzI2OTEwNDczODk4NzAzLCAwLjM2MDc2MTU3MzA0ODEzODYwNzU2OTgzMzUsIDAuMTcxMzI0NDkyMzc5MTcwMzQ1MDQwMjk2MV0sIFswLjQxNzk1OTE4MzY3MzQ2OTM4Nzc1NTEwMjAsIDAuMzgxODMwMDUwNTA1MTE4OTQ0OTUwMzY5OCwgMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LCAwLjEyOTQ4NDk2NjE2ODg2OTY5MzI3MDYxMTRdLCBbMC4zNjI2ODM3ODMzNzgzNjE5ODI5NjUxNTA0LCAwLjMxMzcwNjY0NTg3Nzg4NzI4NzMzNzk2MjIsIDAuMjIyMzgxMDM0NDUzMzc0NDcwNTQ0MzU2MCwgMC4xMDEyMjg1MzYyOTAzNzYyNTkxNTI1MzE0XSwgWzAuMzMwMjM5MzU1MDAxMjU5NzYzMTY0NTI1MSwgMC4zMTIzNDcwNzcwNDAwMDI4NDAwNjg2MzA0LCAwLjI2MDYxMDY5NjQwMjkzNTQ2MjMxODc0MjksIDAuMTgwNjQ4MTYwNjk0ODU3NDA0MDU4NDcyMCwgMC4wODEyNzQzODgzNjE1NzQ0MTE5NzE4OTIyXSwgWzAuMjk1NTI0MjI0NzE0NzUyODcwMTczODkzMCwgMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LCAwLjIxOTA4NjM2MjUxNTk4MjA0Mzk5NTUzNDksIDAuMTQ5NDUxMzQ5MTUwNTgwNTkzMTQ1Nzc2MywgMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSwgWzAuMjcyOTI1MDg2Nzc3OTAwNjMwNzE0NDgzNSwgMC4yNjI4MDQ1NDQ1MTAyNDY2NjIxODA2ODg5LCAwLjIzMzE5Mzc2NDU5MTk5MDQ3OTkxODUyMzcsIDAuMTg2MjkwMjEwOTI3NzM0MjUxNDI2MDk3NiwgMC4xMjU1ODAzNjk0NjQ5MDQ2MjQ2MzQ2OTQzLCAwLjA1NTY2ODU2NzExNjE3MzY2NjQ4Mjc1MzddLCBbMC4yNDkxNDcwNDU4MTM0MDI3ODUwMDA1NjI0LCAwLjIzMzQ5MjUzNjUzODM1NDgwODc2MDg0OTksIDAuMjAzMTY3NDI2NzIzMDY1OTIxNzQ5MDY0NSwgMC4xNjAwNzgzMjg1NDMzNDYyMjYzMzQ2NTI1LCAwLjEwNjkzOTMyNTk5NTMxODQzMDk2MDI1NDcsIDAuMDQ3MTc1MzM2Mzg2NTExODI3MTk0NjE2MF0sIFswLjIzMjU1MTU1MzIzMDg3MzkxMDE5NDU4OTUsIDAuMjI2MjgzMTgwMjYyODk3MjM4NDEyMDkwMiwgMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLCAwLjE3ODE0NTk4MDc2MTk0NTczODI4MDA0NjcsIDAuMTM4ODczNTEwMjE5Nzg3MjM4NDYzNjAxOCwgMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LCAwLjA0MDQ4NDAwNDc2NTMxNTg3OTUyMDAyMTZdLCBbMC4yMTUyNjM4NTM0NjMxNTc3OTAxOTU4NzY0LCAwLjIwNTE5ODQ2MzcyMTI5NTYwMzk2NTkyNDEsIDAuMTg1NTM4Mzk3NDc3OTM3ODEzNzQxNzE2NiwgMC4xNTcyMDMxNjcxNTgxOTM1MzQ1Njk2MDE5LCAwLjEyMTUxODU3MDY4NzkwMzE4NDY4OTQxNDgsIDAuMDgwMTU4MDg3MTU5NzYwMjA5ODA1NjMzMywgMC4wMzUxMTk0NjAzMzE3NTE4NjMwMzE4MzI5XSwgWzAuMjAyNTc4MjQxOTI1NTYxMjcyODgwNjIwMiwgMC4xOTg0MzE0ODUzMjcxMTE1NzY0NTYxMTgzLCAwLjE4NjE2MTAwMDAxNTU2MjIxMTAyNjgwMDYsIDAuMTY2MjY5MjA1ODE2OTkzOTMzNTUzMjAwOSwgMC4xMzk1NzA2Nzc5MjYxNTQzMTQ0NDc4MDQ4LCAwLjEwNzE1OTIyMDQ2NzE3MTkzNTAxMTg2OTUsIDAuMDcwMzY2MDQ3NDg4MTA4MTI0NzA5MjY3NCwgMC4wMzA3NTMyNDE5OTYxMTcyNjgzNTQ2Mjg0XSwgWzAuMTg5NDUwNjEwNDU1MDY4NDk2Mjg1Mzk2NywgMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LCAwLjE2OTE1NjUxOTM5NTAwMjUzODE4OTMxMjEsIDAuMTQ5NTk1OTg4ODE2NTc2NzMyMDgxNTAxNywgMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLCAwLjA5NTE1ODUxMTY4MjQ5Mjc4NDgwOTkyNTEsIDAuMDYyMjUzNTIzOTM4NjQ3ODkyODYyODQzOCwgMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XV07XG5cbiAgICB2YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgICBsb2cyID0gTWF0aC5sb2cyIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzJFO1xuICAgIH0sXG4gICAgICAgIEVQU0lMT04gPSAxZS0xMixcbiAgICAgICAgTUFDSElORV9FUFNJTE9OID0gMS4xMmUtMTY7XG5cbiAgICBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGlzY3JpbWluYW50KGEsIGIsIGMpIHtcbiAgICAgIGZ1bmN0aW9uIHNwbGl0KHYpIHtcbiAgICAgICAgdmFyIHggPSB2ICogMTM0MjE3NzI5LFxuICAgICAgICAgICAgeSA9IHYgLSB4LFxuICAgICAgICAgICAgaGkgPSB5ICsgeCxcbiAgICAgICAgICAgIGxvID0gdiAtIGhpO1xuICAgICAgICByZXR1cm4gW2hpLCBsb107XG4gICAgICB9XG5cbiAgICAgIHZhciBEID0gYiAqIGIgLSBhICogYyxcbiAgICAgICAgICBFID0gYiAqIGIgKyBhICogYztcblxuICAgICAgaWYgKGFicyhEKSAqIDMgPCBFKSB7XG4gICAgICAgIHZhciBhZCA9IHNwbGl0KGEpLFxuICAgICAgICAgICAgYmQgPSBzcGxpdChiKSxcbiAgICAgICAgICAgIGNkID0gc3BsaXQoYyksXG4gICAgICAgICAgICBwID0gYiAqIGIsXG4gICAgICAgICAgICBkcCA9IGJkWzBdICogYmRbMF0gLSBwICsgMiAqIGJkWzBdICogYmRbMV0gKyBiZFsxXSAqIGJkWzFdLFxuICAgICAgICAgICAgcSA9IGEgKiBjLFxuICAgICAgICAgICAgZHEgPSBhZFswXSAqIGNkWzBdIC0gcSArIGFkWzBdICogY2RbMV0gKyBhZFsxXSAqIGNkWzBdICsgYWRbMV0gKiBjZFsxXTtcbiAgICAgICAgRCA9IHAgLSBxICsgKGRwIC0gZHEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gRDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uRmFjdG9yKCkge1xuICAgICAgdmFyIG5vcm0gPSBNYXRoLm1heC5hcHBseShNYXRoLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5vcm0gJiYgKG5vcm0gPCAxZS04IHx8IG5vcm0gPiAxZTgpID8gcG93KDIsIC1NYXRoLnJvdW5kKGxvZzIobm9ybSkpKSA6IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIEVQU0lMT046IEVQU0lMT04sXG4gICAgICBNQUNISU5FX0VQU0lMT046IE1BQ0hJTkVfRVBTSUxPTixcbiAgICAgIENVUlZFVElNRV9FUFNJTE9OOiAxZS04LFxuICAgICAgR0VPTUVUUklDX0VQU0lMT046IDFlLTcsXG4gICAgICBUUklHT05PTUVUUklDX0VQU0lMT046IDFlLTgsXG4gICAgICBLQVBQQTogNCAqIChzcXJ0KDIpIC0gMSkgLyAzLFxuICAgICAgaXNaZXJvOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPj0gLUVQU0lMT04gJiYgdmFsIDw9IEVQU0lMT047XG4gICAgICB9LFxuICAgICAgaXNNYWNoaW5lWmVybzogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID49IC1NQUNISU5FX0VQU0lMT04gJiYgdmFsIDw9IE1BQ0hJTkVfRVBTSUxPTjtcbiAgICAgIH0sXG4gICAgICBjbGFtcDogY2xhbXAsXG4gICAgICBpbnRlZ3JhdGU6IGZ1bmN0aW9uIChmLCBhLCBiLCBuKSB7XG4gICAgICAgIHZhciB4ID0gYWJzY2lzc2FzW24gLSAyXSxcbiAgICAgICAgICAgIHcgPSB3ZWlnaHRzW24gLSAyXSxcbiAgICAgICAgICAgIEEgPSAoYiAtIGEpICogMC41LFxuICAgICAgICAgICAgQiA9IEEgKyBhLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBtID0gbiArIDEgPj4gMSxcbiAgICAgICAgICAgIHN1bSA9IG4gJiAxID8gd1tpKytdICogZihCKSA6IDA7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBtKSB7XG4gICAgICAgICAgdmFyIEF4ID0gQSAqIHhbaV07XG4gICAgICAgICAgc3VtICs9IHdbaSsrXSAqIChmKEIgKyBBeCkgKyBmKEIgLSBBeCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEEgKiBzdW07XG4gICAgICB9LFxuICAgICAgZmluZFJvb3Q6IGZ1bmN0aW9uIChmLCBkZiwgeCwgYSwgYiwgbiwgdG9sZXJhbmNlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZ4ID0gZih4KSxcbiAgICAgICAgICAgICAgZHggPSBmeCAvIGRmKHgpLFxuICAgICAgICAgICAgICBueCA9IHggLSBkeDtcblxuICAgICAgICAgIGlmIChhYnMoZHgpIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB4ID0gbng7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZnggPiAwKSB7XG4gICAgICAgICAgICBiID0geDtcbiAgICAgICAgICAgIHggPSBueCA8PSBhID8gKGEgKyBiKSAqIDAuNSA6IG54O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhID0geDtcbiAgICAgICAgICAgIHggPSBueCA+PSBiID8gKGEgKyBiKSAqIDAuNSA6IG54O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGFtcCh4LCBhLCBiKTtcbiAgICAgIH0sXG4gICAgICBzb2x2ZVF1YWRyYXRpYzogZnVuY3Rpb24gKGEsIGIsIGMsIHJvb3RzLCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgeDEsXG4gICAgICAgICAgICB4MiA9IEluZmluaXR5O1xuXG4gICAgICAgIGlmIChhYnMoYSkgPCBFUFNJTE9OKSB7XG4gICAgICAgICAgaWYgKGFicyhiKSA8IEVQU0lMT04pIHJldHVybiBhYnMoYykgPCBFUFNJTE9OID8gLTEgOiAwO1xuICAgICAgICAgIHgxID0gLWMgLyBiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGIgKj0gLTAuNTtcbiAgICAgICAgICB2YXIgRCA9IGdldERpc2NyaW1pbmFudChhLCBiLCBjKTtcblxuICAgICAgICAgIGlmIChEICYmIGFicyhEKSA8IE1BQ0hJTkVfRVBTSUxPTikge1xuICAgICAgICAgICAgdmFyIGYgPSBnZXROb3JtYWxpemF0aW9uRmFjdG9yKGFicyhhKSwgYWJzKGIpLCBhYnMoYykpO1xuXG4gICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICBhICo9IGY7XG4gICAgICAgICAgICAgIGIgKj0gZjtcbiAgICAgICAgICAgICAgYyAqPSBmO1xuICAgICAgICAgICAgICBEID0gZ2V0RGlzY3JpbWluYW50KGEsIGIsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChEID49IC1NQUNISU5FX0VQU0lMT04pIHtcbiAgICAgICAgICAgIHZhciBRID0gRCA8IDAgPyAwIDogc3FydChEKSxcbiAgICAgICAgICAgICAgICBSID0gYiArIChiIDwgMCA/IC1RIDogUSk7XG5cbiAgICAgICAgICAgIGlmIChSID09PSAwKSB7XG4gICAgICAgICAgICAgIHgxID0gYyAvIGE7XG4gICAgICAgICAgICAgIHgyID0gLXgxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeDEgPSBSIC8gYTtcbiAgICAgICAgICAgICAgeDIgPSBjIC8gUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgICAgYm91bmRsZXNzID0gbWluID09IG51bGwsXG4gICAgICAgICAgICBtaW5CID0gbWluIC0gRVBTSUxPTixcbiAgICAgICAgICAgIG1heEIgPSBtYXggKyBFUFNJTE9OO1xuICAgICAgICBpZiAoaXNGaW5pdGUoeDEpICYmIChib3VuZGxlc3MgfHwgeDEgPiBtaW5CICYmIHgxIDwgbWF4QikpIHJvb3RzW2NvdW50KytdID0gYm91bmRsZXNzID8geDEgOiBjbGFtcCh4MSwgbWluLCBtYXgpO1xuICAgICAgICBpZiAoeDIgIT09IHgxICYmIGlzRmluaXRlKHgyKSAmJiAoYm91bmRsZXNzIHx8IHgyID4gbWluQiAmJiB4MiA8IG1heEIpKSByb290c1tjb3VudCsrXSA9IGJvdW5kbGVzcyA/IHgyIDogY2xhbXAoeDIsIG1pbiwgbWF4KTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgfSxcbiAgICAgIHNvbHZlQ3ViaWM6IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCByb290cywgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIGYgPSBnZXROb3JtYWxpemF0aW9uRmFjdG9yKGFicyhhKSwgYWJzKGIpLCBhYnMoYyksIGFicyhkKSksXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgYjEsXG4gICAgICAgICAgICBjMixcbiAgICAgICAgICAgIHFkLFxuICAgICAgICAgICAgcTtcblxuICAgICAgICBpZiAoZikge1xuICAgICAgICAgIGEgKj0gZjtcbiAgICAgICAgICBiICo9IGY7XG4gICAgICAgICAgYyAqPSBmO1xuICAgICAgICAgIGQgKj0gZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlKHgwKSB7XG4gICAgICAgICAgeCA9IHgwO1xuICAgICAgICAgIHZhciB0bXAgPSBhICogeDtcbiAgICAgICAgICBiMSA9IHRtcCArIGI7XG4gICAgICAgICAgYzIgPSBiMSAqIHggKyBjO1xuICAgICAgICAgIHFkID0gKHRtcCArIGIxKSAqIHggKyBjMjtcbiAgICAgICAgICBxID0gYzIgKiB4ICsgZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYnMoYSkgPCBFUFNJTE9OKSB7XG4gICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgYjEgPSBjO1xuICAgICAgICAgIGMyID0gZDtcbiAgICAgICAgICB4ID0gSW5maW5pdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGQpIDwgRVBTSUxPTikge1xuICAgICAgICAgIGIxID0gYjtcbiAgICAgICAgICBjMiA9IGM7XG4gICAgICAgICAgeCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZhbHVhdGUoLShiIC8gYSkgLyAzKTtcbiAgICAgICAgICB2YXIgdCA9IHEgLyBhLFxuICAgICAgICAgICAgICByID0gcG93KGFicyh0KSwgMSAvIDMpLFxuICAgICAgICAgICAgICBzID0gdCA8IDAgPyAtMSA6IDEsXG4gICAgICAgICAgICAgIHRkID0gLXFkIC8gYSxcbiAgICAgICAgICAgICAgcmQgPSB0ZCA+IDAgPyAxLjMyNDcxNzk1NzI0NDc0NiAqIE1hdGgubWF4KHIsIHNxcnQodGQpKSA6IHIsXG4gICAgICAgICAgICAgIHgwID0geCAtIHMgKiByZDtcblxuICAgICAgICAgIGlmICh4MCAhPT0geCkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBldmFsdWF0ZSh4MCk7XG4gICAgICAgICAgICAgIHgwID0gcWQgPT09IDAgPyB4IDogeCAtIHEgLyBxZCAvICgxICsgTUFDSElORV9FUFNJTE9OKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHMgKiB4MCA+IHMgKiB4KTtcblxuICAgICAgICAgICAgaWYgKGFicyhhKSAqIHggKiB4ID4gYWJzKGQgLyB4KSkge1xuICAgICAgICAgICAgICBjMiA9IC1kIC8geDtcbiAgICAgICAgICAgICAgYjEgPSAoYzIgLSBjKSAvIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIxLCBjMiwgcm9vdHMsIG1pbiwgbWF4KSxcbiAgICAgICAgICAgIGJvdW5kbGVzcyA9IG1pbiA9PSBudWxsO1xuICAgICAgICBpZiAoaXNGaW5pdGUoeCkgJiYgKGNvdW50ID09PSAwIHx8IGNvdW50ID4gMCAmJiB4ICE9PSByb290c1swXSAmJiB4ICE9PSByb290c1sxXSkgJiYgKGJvdW5kbGVzcyB8fCB4ID4gbWluIC0gRVBTSUxPTiAmJiB4IDwgbWF4ICsgRVBTSUxPTikpIHJvb3RzW2NvdW50KytdID0gYm91bmRsZXNzID8geCA6IGNsYW1wKHgsIG1pbiwgbWF4KTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgfVxuICAgIH07XG4gIH0oKTtcbiAgdmFyIFVJRCA9IHtcbiAgICBfaWQ6IDEsXG4gICAgX3Bvb2xzOiB7fSxcbiAgICBnZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgcG9vbCA9IHRoaXMuX3Bvb2xzW25hbWVdO1xuICAgICAgICBpZiAoIXBvb2wpIHBvb2wgPSB0aGlzLl9wb29sc1tuYW1lXSA9IHtcbiAgICAgICAgICBfaWQ6IDFcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBvb2wuX2lkKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQrKztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBQb2ludCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdQb2ludCcsXG4gICAgX3JlYWRJbmRleDogdHJ1ZSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludChhcmcwLCBhcmcxKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhcmcwLFxuICAgICAgICAgIHJlYWRpbmcgPSB0aGlzLl9fcmVhZCxcbiAgICAgICAgICByZWFkID0gMDtcblxuICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBoYXNZID0gdHlwZW9mIGFyZzEgPT09ICdudW1iZXInO1xuXG4gICAgICAgIHRoaXMuX3NldChhcmcwLCBoYXNZID8gYXJnMSA6IGFyZzApO1xuXG4gICAgICAgIGlmIChyZWFkaW5nKSByZWFkID0gaGFzWSA/IDIgOiAxO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NldCgwLCAwKTtcblxuICAgICAgICBpZiAocmVhZGluZykgcmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvYmogPSB0eXBlID09PSAnc3RyaW5nJyA/IGFyZzAuc3BsaXQoL1tcXHMsXSsvKSB8fCBbXSA6IGFyZzA7XG4gICAgICAgIHJlYWQgPSAxO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICB0aGlzLl9zZXQoK29ialswXSwgKyhvYmoubGVuZ3RoID4gMSA/IG9ialsxXSA6IG9ialswXSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCd4JyBpbiBvYmopIHtcbiAgICAgICAgICB0aGlzLl9zZXQob2JqLnggfHwgMCwgb2JqLnkgfHwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ3dpZHRoJyBpbiBvYmopIHtcbiAgICAgICAgICB0aGlzLl9zZXQob2JqLndpZHRoIHx8IDAsIG9iai5oZWlnaHQgfHwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2FuZ2xlJyBpbiBvYmopIHtcbiAgICAgICAgICB0aGlzLl9zZXQob2JqLmxlbmd0aCB8fCAwLCAwKTtcblxuICAgICAgICAgIHRoaXMuc2V0QW5nbGUob2JqLmFuZ2xlIHx8IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldCgwLCAwKTtcblxuICAgICAgICAgIHJlYWQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWFkaW5nKSB0aGlzLl9fcmVhZCA9IHJlYWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNldDogJyNpbml0aWFsaXplJyxcbiAgICBfc2V0OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gdGhpcyA9PT0gcG9pbnQgfHwgcG9pbnQgJiYgKHRoaXMueCA9PT0gcG9pbnQueCAmJiB0aGlzLnkgPT09IHBvaW50LnkgfHwgQXJyYXkuaXNBcnJheShwb2ludCkgJiYgdGhpcy54ID09PSBwb2ludFswXSAmJiB0aGlzLnkgPT09IHBvaW50WzFdKSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcbiAgICAgIHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KSArICcsIHk6ICcgKyBmLm51bWJlcih0aGlzLnkpICsgJyB9JztcbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuICAgICAgcmV0dXJuIFtmLm51bWJlcih0aGlzLngpLCBmLm51bWJlcih0aGlzLnkpXTtcbiAgICB9LFxuICAgIGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuICAgIH0sXG4gICAgc2V0TGVuZ3RoOiBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLl9hbmdsZSB8fCAwO1xuXG4gICAgICAgIHRoaXMuX3NldChNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsIE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2NhbGUgPSBsZW5ndGggLyB0aGlzLmdldExlbmd0aCgpO1xuICAgICAgICBpZiAoTnVtZXJpY2FsLmlzWmVybyhzY2FsZSkpIHRoaXMuZ2V0QW5nbGUoKTtcblxuICAgICAgICB0aGlzLl9zZXQodGhpcy54ICogc2NhbGUsIHRoaXMueSAqIHNjYWxlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEFuZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBbmdsZUluUmFkaWFucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogMTgwIC8gTWF0aC5QSTtcbiAgICB9LFxuICAgIHNldEFuZ2xlOiBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgIHRoaXMuc2V0QW5nbGVJblJhZGlhbnMuY2FsbCh0aGlzLCBhbmdsZSAqIE1hdGguUEkgLyAxODApO1xuICAgIH0sXG4gICAgZ2V0QW5nbGVJbkRlZ3JlZXM6ICcjZ2V0QW5nbGUnLFxuICAgIHNldEFuZ2xlSW5EZWdyZWVzOiAnI3NldEFuZ2xlJyxcbiAgICBnZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzWmVybygpID8gdGhpcy5fYW5nbGUgfHwgMCA6IHRoaXMuX2FuZ2xlID0gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBkaXYgPSB0aGlzLmdldExlbmd0aCgpICogcG9pbnQuZ2V0TGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKE51bWVyaWNhbC5pc1plcm8oZGl2KSkge1xuICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLmRvdChwb2ludCkgLyBkaXY7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhhIDwgLTEgPyAtMSA6IGEgPiAxID8gMSA6IGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICB0aGlzLl9hbmdsZSA9IGFuZ2xlO1xuXG4gICAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cbiAgICAgICAgdGhpcy5fc2V0KE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCwgTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFF1YWRyYW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy54ID49IDAgPyB0aGlzLnkgPj0gMCA/IDEgOiA0IDogdGhpcy55ID49IDAgPyAyIDogMztcbiAgICB9XG4gIH0sIHtcbiAgICBiZWFuczogZmFsc2UsXG4gICAgZ2V0RGlyZWN0ZWRBbmdsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5jcm9zcyhwb2ludCksIHRoaXMuZG90KHBvaW50KSkgKiAxODAgLyBNYXRoLlBJO1xuICAgIH0sXG4gICAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHBvaW50ID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICB4ID0gcG9pbnQueCAtIHRoaXMueCxcbiAgICAgICAgICB5ID0gcG9pbnQueSAtIHRoaXMueSxcbiAgICAgICAgICBkID0geCAqIHggKyB5ICogeSxcbiAgICAgICAgICBzcXVhcmVkID0gQmFzZS5yZWFkKGFyZ3MpO1xuICAgICAgcmV0dXJuIHNxdWFyZWQgPyBkIDogTWF0aC5zcXJ0KGQpO1xuICAgIH0sXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIGxlbmd0aCA9IDE7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0TGVuZ3RoKCksXG4gICAgICAgICAgc2NhbGUgPSBjdXJyZW50ICE9PSAwID8gbGVuZ3RoIC8gY3VycmVudCA6IDAsXG4gICAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQodGhpcy54ICogc2NhbGUsIHRoaXMueSAqIHNjYWxlKTtcbiAgICAgIGlmIChzY2FsZSA+PSAwKSBwb2ludC5fYW5nbGUgPSB0aGlzLl9hbmdsZTtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9LFxuICAgIHJvdGF0ZTogZnVuY3Rpb24gKGFuZ2xlLCBjZW50ZXIpIHtcbiAgICAgIGlmIChhbmdsZSA9PT0gMCkgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgdmFyIHBvaW50ID0gY2VudGVyID8gdGhpcy5zdWJ0cmFjdChjZW50ZXIpIDogdGhpcyxcbiAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgcG9pbnQgPSBuZXcgUG9pbnQocG9pbnQueCAqIGNvcyAtIHBvaW50LnkgKiBzaW4sIHBvaW50LnggKiBzaW4gKyBwb2ludC55ICogY29zKTtcbiAgICAgIHJldHVybiBjZW50ZXIgPyBwb2ludC5hZGQoY2VudGVyKSA6IHBvaW50O1xuICAgIH0sXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICByZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh0aGlzKSA6IHRoaXM7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgcG9pbnQueCwgdGhpcy55ICsgcG9pbnQueSk7XG4gICAgfSxcbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBwb2ludC54LCB0aGlzLnkgLSBwb2ludC55KTtcbiAgICB9LFxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xuICAgIH0sXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xuICAgIH0sXG4gICAgbW9kdWxvOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAlIHBvaW50LngsIHRoaXMueSAlIHBvaW50LnkpO1xuICAgIH0sXG4gICAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KC10aGlzLngsIC10aGlzLnkpO1xuICAgIH0sXG4gICAgaXNJbnNpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMpO1xuICAgIH0sXG4gICAgaXNDbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgIHRvbGVyYW5jZSA9IEJhc2UucmVhZChhcmdzKTtcbiAgICAgIHJldHVybiB0aGlzLmdldERpc3RhbmNlKHBvaW50KSA8PSB0b2xlcmFuY2U7XG4gICAgfSxcbiAgICBpc0NvbGxpbmVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIFBvaW50LmlzQ29sbGluZWFyKHRoaXMueCwgdGhpcy55LCBwb2ludC54LCBwb2ludC55KTtcbiAgICB9LFxuICAgIGlzQ29saW5lYXI6ICcjaXNDb2xsaW5lYXInLFxuICAgIGlzT3J0aG9nb25hbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIFBvaW50LmlzT3J0aG9nb25hbCh0aGlzLngsIHRoaXMueSwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgfSxcbiAgICBpc1plcm86IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuICAgICAgcmV0dXJuIGlzWmVybyh0aGlzLngpICYmIGlzWmVybyh0aGlzLnkpO1xuICAgIH0sXG4gICAgaXNOYU46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpc05hTih0aGlzLngpIHx8IGlzTmFOKHRoaXMueSk7XG4gICAgfSxcbiAgICBpc0luUXVhZHJhbnQ6IGZ1bmN0aW9uIChxKSB7XG4gICAgICByZXR1cm4gdGhpcy54ICogKHEgPiAxICYmIHEgPCA0ID8gLTEgOiAxKSA+PSAwICYmIHRoaXMueSAqIChxID4gMiA/IC0xIDogMSkgPj0gMDtcbiAgICB9LFxuICAgIGRvdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMueCAqIHBvaW50LnggKyB0aGlzLnkgKiBwb2ludC55O1xuICAgIH0sXG4gICAgY3Jvc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzLnggKiBwb2ludC55IC0gdGhpcy55ICogcG9pbnQueDtcbiAgICB9LFxuICAgIHByb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICBzY2FsZSA9IHBvaW50LmlzWmVybygpID8gMCA6IHRoaXMuZG90KHBvaW50KSAvIHBvaW50LmRvdChwb2ludCk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHBvaW50LnggKiBzY2FsZSwgcG9pbnQueSAqIHNjYWxlKTtcbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIG1pbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIHBvaW50MSA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICBwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWluKHBvaW50MS54LCBwb2ludDIueCksIE1hdGgubWluKHBvaW50MS55LCBwb2ludDIueSkpO1xuICAgICAgfSxcbiAgICAgIG1heDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIHBvaW50MSA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICBwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWF4KHBvaW50MS54LCBwb2ludDIueCksIE1hdGgubWF4KHBvaW50MS55LCBwb2ludDIueSkpO1xuICAgICAgfSxcbiAgICAgIHJhbmRvbTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuICAgICAgfSxcbiAgICAgIGlzQ29sbGluZWFyOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHgxICogeTIgLSB5MSAqIHgyKSA8PSBNYXRoLnNxcnQoKHgxICogeDEgKyB5MSAqIHkxKSAqICh4MiAqIHgyICsgeTIgKiB5MikpICogMWUtODtcbiAgICAgIH0sXG4gICAgICBpc09ydGhvZ29uYWw6IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoeDEgKiB4MiArIHkxICogeTIpIDw9IE1hdGguc3FydCgoeDEgKiB4MSArIHkxICogeTEpICogKHgyICogeDIgKyB5MiAqIHkyKSkgKiAxZS04O1xuICAgICAgfVxuICAgIH1cbiAgfSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBvcCA9IE1hdGhba2V5XTtcblxuICAgIHRoaXNba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQob3AodGhpcy54KSwgb3AodGhpcy55KSk7XG4gICAgfTtcbiAgfSwge30pKTtcbiAgdmFyIExpbmtlZFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludCh4LCB5LCBvd25lciwgc2V0dGVyKSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy5fb3duZXIgPSBvd25lcjtcbiAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlcjtcbiAgICB9LFxuICAgIF9zZXQ6IGZ1bmN0aW9uICh4LCB5LCBfZG9udE5vdGlmeSkge1xuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIGlmICghX2RvbnROb3RpZnkpIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldFg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH0sXG4gICAgc2V0WDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuXG4gICAgICB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0WTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfSxcbiAgICBzZXRZOiBmdW5jdGlvbiAoeSkge1xuICAgICAgdGhpcy5feSA9IHk7XG5cbiAgICAgIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgfSxcbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISEodGhpcy5fb3duZXIuX3NlbGVjdGlvbiAmIHRoaXMuX2dldFNlbGVjdGlvbigpKTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGVkOiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuX293bmVyLl9jaGFuZ2VTZWxlY3Rpb24odGhpcy5fZ2V0U2VsZWN0aW9uKCksIHNlbGVjdGVkKTtcbiAgICB9LFxuICAgIF9nZXRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXR0ZXIgPT09ICdzZXRQb3NpdGlvbicgPyA0IDogMDtcbiAgICB9XG4gIH0pO1xuICB2YXIgU2l6ZSA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdTaXplJyxcbiAgICBfcmVhZEluZGV4OiB0cnVlLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUoYXJnMCwgYXJnMSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnMCxcbiAgICAgICAgICByZWFkaW5nID0gdGhpcy5fX3JlYWQsXG4gICAgICAgICAgcmVhZCA9IDA7XG5cbiAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgaGFzSGVpZ2h0ID0gdHlwZW9mIGFyZzEgPT09ICdudW1iZXInO1xuXG4gICAgICAgIHRoaXMuX3NldChhcmcwLCBoYXNIZWlnaHQgPyBhcmcxIDogYXJnMCk7XG5cbiAgICAgICAgaWYgKHJlYWRpbmcpIHJlYWQgPSBoYXNIZWlnaHQgPyAyIDogMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9zZXQoMCwgMCk7XG5cbiAgICAgICAgaWYgKHJlYWRpbmcpIHJlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2JqID0gdHlwZSA9PT0gJ3N0cmluZycgPyBhcmcwLnNwbGl0KC9bXFxzLF0rLykgfHwgW10gOiBhcmcwO1xuICAgICAgICByZWFkID0gMTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgdGhpcy5fc2V0KCtvYmpbMF0sICsob2JqLmxlbmd0aCA+IDEgPyBvYmpbMV0gOiBvYmpbMF0pKTtcbiAgICAgICAgfSBlbHNlIGlmICgnd2lkdGgnIGluIG9iaikge1xuICAgICAgICAgIHRoaXMuX3NldChvYmoud2lkdGggfHwgMCwgb2JqLmhlaWdodCB8fCAwKTtcbiAgICAgICAgfSBlbHNlIGlmICgneCcgaW4gb2JqKSB7XG4gICAgICAgICAgdGhpcy5fc2V0KG9iai54IHx8IDAsIG9iai55IHx8IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldCgwLCAwKTtcblxuICAgICAgICAgIHJlYWQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWFkaW5nKSB0aGlzLl9fcmVhZCA9IHJlYWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNldDogJyNpbml0aWFsaXplJyxcbiAgICBfc2V0OiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIHJldHVybiBzaXplID09PSB0aGlzIHx8IHNpemUgJiYgKHRoaXMud2lkdGggPT09IHNpemUud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0IHx8IEFycmF5LmlzQXJyYXkoc2l6ZSkgJiYgdGhpcy53aWR0aCA9PT0gc2l6ZVswXSAmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZVsxXSkgfHwgZmFsc2U7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcbiAgICAgIHJldHVybiAneyB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpICsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpICsgJyB9JztcbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuICAgICAgcmV0dXJuIFtmLm51bWJlcih0aGlzLndpZHRoKSwgZi5udW1iZXIodGhpcy5oZWlnaHQpXTtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICsgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKyBzaXplLmhlaWdodCk7XG4gICAgfSxcbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoIC0gc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLSBzaXplLmhlaWdodCk7XG4gICAgfSxcbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICogc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKiBzaXplLmhlaWdodCk7XG4gICAgfSxcbiAgICBkaXZpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAvIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuICAgIH0sXG4gICAgbW9kdWxvOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggJSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAlIHNpemUuaGVpZ2h0KTtcbiAgICB9LFxuICAgIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTaXplKC10aGlzLndpZHRoLCAtdGhpcy5oZWlnaHQpO1xuICAgIH0sXG4gICAgaXNaZXJvOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcbiAgICAgIHJldHVybiBpc1plcm8odGhpcy53aWR0aCkgJiYgaXNaZXJvKHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuICAgIGlzTmFOOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXNOYU4odGhpcy53aWR0aCkgfHwgaXNOYU4odGhpcy5oZWlnaHQpO1xuICAgIH0sXG4gICAgc3RhdGljczoge1xuICAgICAgbWluOiBmdW5jdGlvbiAoc2l6ZTEsIHNpemUyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZShNYXRoLm1pbihzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLCBNYXRoLm1pbihzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuICAgICAgfSxcbiAgICAgIG1heDogZnVuY3Rpb24gKHNpemUxLCBzaXplMikge1xuICAgICAgICByZXR1cm4gbmV3IFNpemUoTWF0aC5tYXgoc2l6ZTEud2lkdGgsIHNpemUyLndpZHRoKSwgTWF0aC5tYXgoc2l6ZTEuaGVpZ2h0LCBzaXplMi5oZWlnaHQpKTtcbiAgICAgIH0sXG4gICAgICByYW5kb206IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaXplKE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBvcCA9IE1hdGhba2V5XTtcblxuICAgIHRoaXNba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2l6ZShvcCh0aGlzLndpZHRoKSwgb3AodGhpcy5oZWlnaHQpKTtcbiAgICB9O1xuICB9LCB7fSkpO1xuICB2YXIgTGlua2VkU2l6ZSA9IFNpemUuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLl9vd25lciA9IG93bmVyO1xuICAgICAgdGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuICAgIH0sXG4gICAgX3NldDogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgaWYgKCFfZG9udE5vdGlmeSkgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9LFxuICAgIHNldFdpZHRoOiBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cbiAgICAgIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgfSxcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfSxcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgUmVjdGFuZ2xlID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1JlY3RhbmdsZScsXG4gICAgX3JlYWRJbmRleDogdHJ1ZSxcbiAgICBiZWFuczogdHJ1ZSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBSZWN0YW5nbGUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgdHlwZSA9IHR5cGVvZiBhcmcwLFxuICAgICAgICAgIHJlYWQ7XG5cbiAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLl9zZXQoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG5cbiAgICAgICAgcmVhZCA9IDQ7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2V0KDAsIDAsIDAsIDApO1xuXG4gICAgICAgIHJlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG4gICAgICAgICAgdGhpcy5fc2V0LmFwcGx5KHRoaXMsIGFyZzApO1xuXG4gICAgICAgICAgcmVhZCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnMC54ICE9PSB1bmRlZmluZWQgfHwgYXJnMC53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fc2V0KGFyZzAueCB8fCAwLCBhcmcwLnkgfHwgMCwgYXJnMC53aWR0aCB8fCAwLCBhcmcwLmhlaWdodCB8fCAwKTtcblxuICAgICAgICAgIHJlYWQgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZzAuZnJvbSA9PT0gdW5kZWZpbmVkICYmIGFyZzAudG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3NldCgwLCAwLCAwLCAwKTtcblxuICAgICAgICAgIGlmIChCYXNlLnJlYWRTdXBwb3J0ZWQoYXJncywgdGhpcykpIHtcbiAgICAgICAgICAgIHJlYWQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVhZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmcm0gPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2Zyb20nKSxcbiAgICAgICAgICAgIG5leHQgPSBCYXNlLnBlZWsoYXJncyksXG4gICAgICAgICAgICB4ID0gZnJtLngsXG4gICAgICAgICAgICB5ID0gZnJtLnksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDtcblxuICAgICAgICBpZiAobmV4dCAmJiBuZXh0LnggIT09IHVuZGVmaW5lZCB8fCBCYXNlLmhhc05hbWVkKGFyZ3MsICd0bycpKSB7XG4gICAgICAgICAgdmFyIHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICd0bycpO1xuICAgICAgICAgIHdpZHRoID0gdG8ueCAtIHg7XG4gICAgICAgICAgaGVpZ2h0ID0gdG8ueSAtIHk7XG5cbiAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICB4ID0gdG8ueDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICB5ID0gdG8ueTtcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3MpO1xuICAgICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICByZWFkID0gYXJncy5fX2luZGV4O1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlsdGVyZWQgPSBhcmdzLl9fZmlsdGVyZWQ7XG4gICAgICBpZiAoZmlsdGVyZWQpIHRoaXMuX19maWx0ZXJlZCA9IGZpbHRlcmVkO1xuICAgICAgaWYgKHRoaXMuX19yZWFkKSB0aGlzLl9fcmVhZCA9IHJlYWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNldDogJyNpbml0aWFsaXplJyxcbiAgICBfc2V0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICB2YXIgcnQgPSBCYXNlLmlzUGxhaW5WYWx1ZShyZWN0KSA/IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykgOiByZWN0O1xuICAgICAgcmV0dXJuIHJ0ID09PSB0aGlzIHx8IHJ0ICYmIHRoaXMueCA9PT0gcnQueCAmJiB0aGlzLnkgPT09IHJ0LnkgJiYgdGhpcy53aWR0aCA9PT0gcnQud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHJ0LmhlaWdodCB8fCBmYWxzZTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcbiAgICAgIHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KSArICcsIHk6ICcgKyBmLm51bWJlcih0aGlzLnkpICsgJywgd2lkdGg6ICcgKyBmLm51bWJlcih0aGlzLndpZHRoKSArICcsIGhlaWdodDogJyArIGYubnVtYmVyKHRoaXMuaGVpZ2h0KSArICcgfSc7XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcbiAgICAgIHJldHVybiBbZi5udW1iZXIodGhpcy54KSwgZi5udW1iZXIodGhpcy55KSwgZi5udW1iZXIodGhpcy53aWR0aCksIGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG4gICAgfSxcbiAgICBnZXRQb2ludDogZnVuY3Rpb24gKF9kb250TGluaykge1xuICAgICAgdmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuICAgICAgcmV0dXJuIG5ldyBjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLCAnc2V0UG9pbnQnKTtcbiAgICB9LFxuICAgIHNldFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnggPSBwb2ludC54O1xuICAgICAgdGhpcy55ID0gcG9pbnQueTtcbiAgICB9LFxuICAgIGdldFNpemU6IGZ1bmN0aW9uIChfZG9udExpbmspIHtcbiAgICAgIHZhciBjdG9yID0gX2RvbnRMaW5rID8gU2l6ZSA6IExpbmtlZFNpemU7XG4gICAgICByZXR1cm4gbmV3IGN0b3IodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG4gICAgfSxcbiAgICBfZnc6IDEsXG4gICAgX2ZoOiAxLFxuICAgIHNldFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgc3ggPSB0aGlzLl9zeCxcbiAgICAgICAgICBzeSA9IHRoaXMuX3N5LFxuICAgICAgICAgIHcgPSBzaXplLndpZHRoLFxuICAgICAgICAgIGggPSBzaXplLmhlaWdodDtcblxuICAgICAgaWYgKHN4KSB7XG4gICAgICAgIHRoaXMueCArPSAodGhpcy53aWR0aCAtIHcpICogc3g7XG4gICAgICB9XG5cbiAgICAgIGlmIChzeSkge1xuICAgICAgICB0aGlzLnkgKz0gKHRoaXMuaGVpZ2h0IC0gaCkgKiBzeTtcbiAgICAgIH1cblxuICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgICB0aGlzLl9mdyA9IHRoaXMuX2ZoID0gMTtcbiAgICB9LFxuICAgIGdldExlZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLng7XG4gICAgfSxcbiAgICBzZXRMZWZ0OiBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgaWYgKCF0aGlzLl9mdykge1xuICAgICAgICB2YXIgYW1vdW50ID0gbGVmdCAtIHRoaXMueDtcbiAgICAgICAgdGhpcy53aWR0aCAtPSB0aGlzLl9zeCA9PT0gMC41ID8gYW1vdW50ICogMiA6IGFtb3VudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy54ID0gbGVmdDtcbiAgICAgIHRoaXMuX3N4ID0gdGhpcy5fZncgPSAwO1xuICAgIH0sXG4gICAgZ2V0VG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy55O1xuICAgIH0sXG4gICAgc2V0VG9wOiBmdW5jdGlvbiAodG9wKSB7XG4gICAgICBpZiAoIXRoaXMuX2ZoKSB7XG4gICAgICAgIHZhciBhbW91bnQgPSB0b3AgLSB0aGlzLnk7XG4gICAgICAgIHRoaXMuaGVpZ2h0IC09IHRoaXMuX3N5ID09PSAwLjUgPyBhbW91bnQgKiAyIDogYW1vdW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnkgPSB0b3A7XG4gICAgICB0aGlzLl9zeSA9IHRoaXMuX2ZoID0gMDtcbiAgICB9LFxuICAgIGdldFJpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICB9LFxuICAgIHNldFJpZ2h0OiBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICAgIGlmICghdGhpcy5fZncpIHtcbiAgICAgICAgdmFyIGFtb3VudCA9IHJpZ2h0IC0gdGhpcy54O1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5fc3ggPT09IDAuNSA/IGFtb3VudCAqIDIgOiBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueCA9IHJpZ2h0IC0gdGhpcy53aWR0aDtcbiAgICAgIHRoaXMuX3N4ID0gMTtcbiAgICAgIHRoaXMuX2Z3ID0gMDtcbiAgICB9LFxuICAgIGdldEJvdHRvbTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0Qm90dG9tOiBmdW5jdGlvbiAoYm90dG9tKSB7XG4gICAgICBpZiAoIXRoaXMuX2ZoKSB7XG4gICAgICAgIHZhciBhbW91bnQgPSBib3R0b20gLSB0aGlzLnk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fc3kgPT09IDAuNSA/IGFtb3VudCAqIDIgOiBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueSA9IGJvdHRvbSAtIHRoaXMuaGVpZ2h0O1xuICAgICAgdGhpcy5fc3kgPSAxO1xuICAgICAgdGhpcy5fZmggPSAwO1xuICAgIH0sXG4gICAgZ2V0Q2VudGVyWDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGggLyAyO1xuICAgIH0sXG4gICAgc2V0Q2VudGVyWDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9mdyB8fCB0aGlzLl9zeCA9PT0gMC41KSB7XG4gICAgICAgIHRoaXMueCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9zeCkge1xuICAgICAgICAgIHRoaXMueCArPSAoeCAtIHRoaXMueCkgKiAyICogdGhpcy5fc3g7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndpZHRoID0gKHggLSB0aGlzLngpICogMjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3ggPSAwLjU7XG4gICAgICB0aGlzLl9mdyA9IDA7XG4gICAgfSxcbiAgICBnZXRDZW50ZXJZOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyO1xuICAgIH0sXG4gICAgc2V0Q2VudGVyWTogZnVuY3Rpb24gKHkpIHtcbiAgICAgIGlmICh0aGlzLl9maCB8fCB0aGlzLl9zeSA9PT0gMC41KSB7XG4gICAgICAgIHRoaXMueSA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fc3kpIHtcbiAgICAgICAgICB0aGlzLnkgKz0gKHkgLSB0aGlzLnkpICogMiAqIHRoaXMuX3N5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAoeSAtIHRoaXMueSkgKiAyO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zeSA9IDAuNTtcbiAgICAgIHRoaXMuX2ZoID0gMDtcbiAgICB9LFxuICAgIGdldENlbnRlcjogZnVuY3Rpb24gKF9kb250TGluaykge1xuICAgICAgdmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuICAgICAgcmV0dXJuIG5ldyBjdG9yKHRoaXMuZ2V0Q2VudGVyWCgpLCB0aGlzLmdldENlbnRlclkoKSwgdGhpcywgJ3NldENlbnRlcicpO1xuICAgIH0sXG4gICAgc2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnNldENlbnRlclgocG9pbnQueCk7XG4gICAgICB0aGlzLnNldENlbnRlclkocG9pbnQueSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldEFyZWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gMCB8fCB0aGlzLmhlaWdodCA9PT0gMDtcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnICYmIGFyZy53aWR0aCAhPT0gdW5kZWZpbmVkIHx8IChBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpLmxlbmd0aCA9PT0gNCA/IHRoaXMuX2NvbnRhaW5zUmVjdGFuZ2xlKFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykpIDogdGhpcy5fY29udGFpbnNQb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgX2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICAgIHkgPSBwb2ludC55O1xuICAgICAgcmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55ICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgX2NvbnRhaW5zUmVjdGFuZ2xlOiBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgdmFyIHggPSByZWN0LngsXG4gICAgICAgICAgeSA9IHJlY3QueTtcbiAgICAgIHJldHVybiB4ID49IHRoaXMueCAmJiB5ID49IHRoaXMueSAmJiB4ICsgcmVjdC53aWR0aCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmIHkgKyByZWN0LmhlaWdodCA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9LFxuICAgIGludGVyc2VjdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICBlcHNpbG9uID0gQmFzZS5yZWFkKGFyZ3VtZW50cykgfHwgMDtcbiAgICAgIHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID4gdGhpcy54IC0gZXBzaWxvbiAmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+IHRoaXMueSAtIGVwc2lsb24gJiYgcmVjdC54IDwgdGhpcy54ICsgdGhpcy53aWR0aCArIGVwc2lsb24gJiYgcmVjdC55IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQgKyBlcHNpbG9uO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgeDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3QueCksXG4gICAgICAgICAgeTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3QueSksXG4gICAgICAgICAgeDIgPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKSxcbiAgICAgICAgICB5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG4gICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgIH0sXG4gICAgdW5pdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICB4MSA9IE1hdGgubWluKHRoaXMueCwgcmVjdC54KSxcbiAgICAgICAgICB5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdC55KSxcbiAgICAgICAgICB4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuICAgICAgICAgIHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG4gICAgfSxcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgeDEgPSBNYXRoLm1pbih0aGlzLngsIHBvaW50LngpLFxuICAgICAgICAgIHkxID0gTWF0aC5taW4odGhpcy55LCBwb2ludC55KSxcbiAgICAgICAgICB4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHBvaW50LngpLFxuICAgICAgICAgIHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHBvaW50LnkpO1xuICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICB9LFxuICAgIGV4cGFuZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFtb3VudCA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIGhvciA9IGFtb3VudC53aWR0aCxcbiAgICAgICAgICB2ZXIgPSBhbW91bnQuaGVpZ2h0O1xuICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54IC0gaG9yIC8gMiwgdGhpcy55IC0gdmVyIC8gMiwgdGhpcy53aWR0aCArIGhvciwgdGhpcy5oZWlnaHQgKyB2ZXIpO1xuICAgIH0sXG4gICAgc2NhbGU6IGZ1bmN0aW9uIChob3IsIHZlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMud2lkdGggKiBob3IgLSB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCAqICh2ZXIgPT09IHVuZGVmaW5lZCA/IGhvciA6IHZlcikgLSB0aGlzLmhlaWdodCk7XG4gICAgfVxuICB9LCBCYXNlLmVhY2goW1snVG9wJywgJ0xlZnQnXSwgWydUb3AnLCAnUmlnaHQnXSwgWydCb3R0b20nLCAnTGVmdCddLCBbJ0JvdHRvbScsICdSaWdodCddLCBbJ0xlZnQnLCAnQ2VudGVyJ10sIFsnVG9wJywgJ0NlbnRlciddLCBbJ1JpZ2h0JywgJ0NlbnRlciddLCBbJ0JvdHRvbScsICdDZW50ZXInXV0sIGZ1bmN0aW9uIChwYXJ0cywgaW5kZXgpIHtcbiAgICB2YXIgcGFydCA9IHBhcnRzLmpvaW4oJycpLFxuICAgICAgICB4Rmlyc3QgPSAvXltSTF0vLnRlc3QocGFydCk7XG4gICAgaWYgKGluZGV4ID49IDQpIHBhcnRzWzFdICs9IHhGaXJzdCA/ICdZJyA6ICdYJztcbiAgICB2YXIgeCA9IHBhcnRzW3hGaXJzdCA/IDAgOiAxXSxcbiAgICAgICAgeSA9IHBhcnRzW3hGaXJzdCA/IDEgOiAwXSxcbiAgICAgICAgZ2V0WCA9ICdnZXQnICsgeCxcbiAgICAgICAgZ2V0WSA9ICdnZXQnICsgeSxcbiAgICAgICAgc2V0WCA9ICdzZXQnICsgeCxcbiAgICAgICAgc2V0WSA9ICdzZXQnICsgeSxcbiAgICAgICAgZ2V0ID0gJ2dldCcgKyBwYXJ0LFxuICAgICAgICBzZXQgPSAnc2V0JyArIHBhcnQ7XG5cbiAgICB0aGlzW2dldF0gPSBmdW5jdGlvbiAoX2RvbnRMaW5rKSB7XG4gICAgICB2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG4gICAgICByZXR1cm4gbmV3IGN0b3IodGhpc1tnZXRYXSgpLCB0aGlzW2dldFldKCksIHRoaXMsIHNldCk7XG4gICAgfTtcblxuICAgIHRoaXNbc2V0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHRoaXNbc2V0WF0ocG9pbnQueCk7XG4gICAgICB0aGlzW3NldFldKHBvaW50LnkpO1xuICAgIH07XG4gIH0sIHtcbiAgICBiZWFuczogdHJ1ZVxuICB9KSk7XG4gIHZhciBMaW5rZWRSZWN0YW5nbGUgPSBSZWN0YW5nbGUuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3duZXIsIHNldHRlcikge1xuICAgICAgdGhpcy5fc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuXG4gICAgICB0aGlzLl9vd25lciA9IG93bmVyO1xuICAgICAgdGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuICAgIH0sXG4gICAgX3NldDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgIGlmICghX2RvbnROb3RpZnkpIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3RvID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcbiAgICByZXR1cm4gQmFzZS5lYWNoKFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuICAgICAgICAgIGludGVybmFsID0gJ18nICsga2V5O1xuXG4gICAgICB0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2ludGVybmFsXTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzW2ludGVybmFsXSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMuX2RvbnROb3RpZnkpIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgICB9O1xuICAgIH0sIEJhc2UuZWFjaChbJ1BvaW50JywgJ1NpemUnLCAnQ2VudGVyJywgJ0xlZnQnLCAnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdDZW50ZXJYJywgJ0NlbnRlclknLCAnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21MZWZ0JywgJ0JvdHRvbVJpZ2h0JywgJ0xlZnRDZW50ZXInLCAnVG9wQ2VudGVyJywgJ1JpZ2h0Q2VudGVyJywgJ0JvdHRvbUNlbnRlciddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbmFtZSA9ICdzZXQnICsga2V5O1xuXG4gICAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kb250Tm90aWZ5ID0gdHJ1ZTtcbiAgICAgICAgcHJvdG9bbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fZG9udE5vdGlmeSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgICB9O1xuICAgIH0sIHtcbiAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX293bmVyLl9zZWxlY3Rpb24gJiAyKTtcbiAgICAgIH0sXG4gICAgICBzZXRTZWxlY3RlZDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICAgIHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXG4gICAgICAgIGlmIChvd25lci5fY2hhbmdlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgb3duZXIuX2NoYW5nZVNlbGVjdGlvbigyLCBzZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSk7XG4gIH0oKSk7XG4gIHZhciBNYXRyaXggPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnTWF0cml4JyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBNYXRyaXgoYXJnLCBfZG9udE5vdGlmeSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgY291bnQgPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBvayA9IHRydWU7XG5cbiAgICAgIGlmIChjb3VudCA+PSA2KSB7XG4gICAgICAgIHRoaXMuX3NldC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEgfHwgY291bnQgPT09IDIpIHtcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgIHRoaXMuX3NldChhcmcuX2EsIGFyZy5fYiwgYXJnLl9jLCBhcmcuX2QsIGFyZy5fdHgsIGFyZy5fdHksIF9kb250Tm90aWZ5KTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICB0aGlzLl9zZXQuYXBwbHkodGhpcywgX2RvbnROb3RpZnkgPyBhcmcuY29uY2F0KFtfZG9udE5vdGlmeV0pIDogYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFjb3VudCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbWF0cml4IHBhcmFtZXRlcnMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXQ6ICcjaW5pdGlhbGl6ZScsXG4gICAgX3NldDogZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHR4LCB0eSwgX2RvbnROb3RpZnkpIHtcbiAgICAgIHRoaXMuX2EgPSBhO1xuICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgdGhpcy5fdHggPSB0eDtcbiAgICAgIHRoaXMuX3R5ID0gdHk7XG4gICAgICBpZiAoIV9kb250Tm90aWZ5KSB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5nZXRWYWx1ZXMoKSwgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBpZiAob3duZXIuX2FwcGx5TWF0cml4KSB7XG4gICAgICAgICAgb3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG93bmVyLl9jaGFuZ2VkKDI1KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgTWF0cml4KHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSk7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChteCkge1xuICAgICAgcmV0dXJuIG14ID09PSB0aGlzIHx8IG14ICYmIHRoaXMuX2EgPT09IG14Ll9hICYmIHRoaXMuX2IgPT09IG14Ll9iICYmIHRoaXMuX2MgPT09IG14Ll9jICYmIHRoaXMuX2QgPT09IG14Ll9kICYmIHRoaXMuX3R4ID09PSBteC5fdHggJiYgdGhpcy5fdHkgPT09IG14Ll90eTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcbiAgICAgIHJldHVybiAnW1snICsgW2YubnVtYmVyKHRoaXMuX2EpLCBmLm51bWJlcih0aGlzLl9jKSwgZi5udW1iZXIodGhpcy5fdHgpXS5qb2luKCcsICcpICsgJ10sIFsnICsgW2YubnVtYmVyKHRoaXMuX2IpLCBmLm51bWJlcih0aGlzLl9kKSwgZi5udW1iZXIodGhpcy5fdHkpXS5qb2luKCcsICcpICsgJ11dJztcbiAgICB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoX2RvbnROb3RpZnkpIHtcbiAgICAgIHRoaXMuX2EgPSB0aGlzLl9kID0gMTtcbiAgICAgIHRoaXMuX2IgPSB0aGlzLl9jID0gdGhpcy5fdHggPSB0aGlzLl90eSA9IDA7XG4gICAgICBpZiAoIV9kb250Tm90aWZ5KSB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiAocmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkge1xuICAgICAgdmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBvd25lci50cmFuc2Zvcm0obnVsbCwgQmFzZS5waWNrKHJlY3Vyc2l2ZWx5LCB0cnVlKSwgX3NldEFwcGx5TWF0cml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJZGVudGl0eSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgIHRoaXMuX3R4ICs9IHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2M7XG4gICAgICB0aGlzLl90eSArPSB4ICogdGhpcy5fYiArIHkgKiB0aGlzLl9kO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHNjYWxlID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3MsIDAsIHtcbiAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGNlbnRlcikgdGhpcy50cmFuc2xhdGUoY2VudGVyKTtcbiAgICAgIHRoaXMuX2EgKj0gc2NhbGUueDtcbiAgICAgIHRoaXMuX2IgKj0gc2NhbGUueDtcbiAgICAgIHRoaXMuX2MgKj0gc2NhbGUueTtcbiAgICAgIHRoaXMuX2QgKj0gc2NhbGUueTtcbiAgICAgIGlmIChjZW50ZXIpIHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByb3RhdGU6IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgYW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcbiAgICAgIHZhciBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgeCA9IGNlbnRlci54LFxuICAgICAgICAgIHkgPSBjZW50ZXIueSxcbiAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgIHR4ID0geCAtIHggKiBjb3MgKyB5ICogc2luLFxuICAgICAgICAgIHR5ID0geSAtIHggKiBzaW4gLSB5ICogY29zLFxuICAgICAgICAgIGEgPSB0aGlzLl9hLFxuICAgICAgICAgIGIgPSB0aGlzLl9iLFxuICAgICAgICAgIGMgPSB0aGlzLl9jLFxuICAgICAgICAgIGQgPSB0aGlzLl9kO1xuICAgICAgdGhpcy5fYSA9IGNvcyAqIGEgKyBzaW4gKiBjO1xuICAgICAgdGhpcy5fYiA9IGNvcyAqIGIgKyBzaW4gKiBkO1xuICAgICAgdGhpcy5fYyA9IC1zaW4gKiBhICsgY29zICogYztcbiAgICAgIHRoaXMuX2QgPSAtc2luICogYiArIGNvcyAqIGQ7XG4gICAgICB0aGlzLl90eCArPSB0eCAqIGEgKyB0eSAqIGM7XG4gICAgICB0aGlzLl90eSArPSB0eCAqIGIgKyB0eSAqIGQ7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzaGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc2hlYXIgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWQoYXJncywgMCwge1xuICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoY2VudGVyKSB0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuICAgICAgdmFyIGEgPSB0aGlzLl9hLFxuICAgICAgICAgIGIgPSB0aGlzLl9iO1xuICAgICAgdGhpcy5fYSArPSBzaGVhci55ICogdGhpcy5fYztcbiAgICAgIHRoaXMuX2IgKz0gc2hlYXIueSAqIHRoaXMuX2Q7XG4gICAgICB0aGlzLl9jICs9IHNoZWFyLnggKiBhO1xuICAgICAgdGhpcy5fZCArPSBzaGVhci54ICogYjtcbiAgICAgIGlmIChjZW50ZXIpIHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBza2V3OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBza2V3ID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3MsIDAsIHtcbiAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgIH0pLFxuICAgICAgICAgIHRvUmFkaWFucyA9IE1hdGguUEkgLyAxODAsXG4gICAgICAgICAgc2hlYXIgPSBuZXcgUG9pbnQoTWF0aC50YW4oc2tldy54ICogdG9SYWRpYW5zKSwgTWF0aC50YW4oc2tldy55ICogdG9SYWRpYW5zKSk7XG4gICAgICByZXR1cm4gdGhpcy5zaGVhcihzaGVhciwgY2VudGVyKTtcbiAgICB9LFxuICAgIGFwcGVuZDogZnVuY3Rpb24gKG14LCBfZG9udE5vdGlmeSkge1xuICAgICAgaWYgKG14KSB7XG4gICAgICAgIHZhciBhMSA9IHRoaXMuX2EsXG4gICAgICAgICAgICBiMSA9IHRoaXMuX2IsXG4gICAgICAgICAgICBjMSA9IHRoaXMuX2MsXG4gICAgICAgICAgICBkMSA9IHRoaXMuX2QsXG4gICAgICAgICAgICBhMiA9IG14Ll9hLFxuICAgICAgICAgICAgYjIgPSBteC5fYyxcbiAgICAgICAgICAgIGMyID0gbXguX2IsXG4gICAgICAgICAgICBkMiA9IG14Ll9kLFxuICAgICAgICAgICAgdHgyID0gbXguX3R4LFxuICAgICAgICAgICAgdHkyID0gbXguX3R5O1xuICAgICAgICB0aGlzLl9hID0gYTIgKiBhMSArIGMyICogYzE7XG4gICAgICAgIHRoaXMuX2MgPSBiMiAqIGExICsgZDIgKiBjMTtcbiAgICAgICAgdGhpcy5fYiA9IGEyICogYjEgKyBjMiAqIGQxO1xuICAgICAgICB0aGlzLl9kID0gYjIgKiBiMSArIGQyICogZDE7XG4gICAgICAgIHRoaXMuX3R4ICs9IHR4MiAqIGExICsgdHkyICogYzE7XG4gICAgICAgIHRoaXMuX3R5ICs9IHR4MiAqIGIxICsgdHkyICogZDE7XG4gICAgICAgIGlmICghX2RvbnROb3RpZnkpIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwcmVwZW5kOiBmdW5jdGlvbiAobXgsIF9kb250Tm90aWZ5KSB7XG4gICAgICBpZiAobXgpIHtcbiAgICAgICAgdmFyIGExID0gdGhpcy5fYSxcbiAgICAgICAgICAgIGIxID0gdGhpcy5fYixcbiAgICAgICAgICAgIGMxID0gdGhpcy5fYyxcbiAgICAgICAgICAgIGQxID0gdGhpcy5fZCxcbiAgICAgICAgICAgIHR4MSA9IHRoaXMuX3R4LFxuICAgICAgICAgICAgdHkxID0gdGhpcy5fdHksXG4gICAgICAgICAgICBhMiA9IG14Ll9hLFxuICAgICAgICAgICAgYjIgPSBteC5fYyxcbiAgICAgICAgICAgIGMyID0gbXguX2IsXG4gICAgICAgICAgICBkMiA9IG14Ll9kLFxuICAgICAgICAgICAgdHgyID0gbXguX3R4LFxuICAgICAgICAgICAgdHkyID0gbXguX3R5O1xuICAgICAgICB0aGlzLl9hID0gYTIgKiBhMSArIGIyICogYjE7XG4gICAgICAgIHRoaXMuX2MgPSBhMiAqIGMxICsgYjIgKiBkMTtcbiAgICAgICAgdGhpcy5fYiA9IGMyICogYTEgKyBkMiAqIGIxO1xuICAgICAgICB0aGlzLl9kID0gYzIgKiBjMSArIGQyICogZDE7XG4gICAgICAgIHRoaXMuX3R4ID0gYTIgKiB0eDEgKyBiMiAqIHR5MSArIHR4MjtcbiAgICAgICAgdGhpcy5fdHkgPSBjMiAqIHR4MSArIGQyICogdHkxICsgdHkyO1xuICAgICAgICBpZiAoIV9kb250Tm90aWZ5KSB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYXBwZW5kZWQ6IGZ1bmN0aW9uIChteCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5hcHBlbmQobXgpO1xuICAgIH0sXG4gICAgcHJlcGVuZGVkOiBmdW5jdGlvbiAobXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkucHJlcGVuZChteCk7XG4gICAgfSxcbiAgICBpbnZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhID0gdGhpcy5fYSxcbiAgICAgICAgICBiID0gdGhpcy5fYixcbiAgICAgICAgICBjID0gdGhpcy5fYyxcbiAgICAgICAgICBkID0gdGhpcy5fZCxcbiAgICAgICAgICB0eCA9IHRoaXMuX3R4LFxuICAgICAgICAgIHR5ID0gdGhpcy5fdHksXG4gICAgICAgICAgZGV0ID0gYSAqIGQgLSBiICogYyxcbiAgICAgICAgICByZXMgPSBudWxsO1xuXG4gICAgICBpZiAoZGV0ICYmICFpc05hTihkZXQpICYmIGlzRmluaXRlKHR4KSAmJiBpc0Zpbml0ZSh0eSkpIHtcbiAgICAgICAgdGhpcy5fYSA9IGQgLyBkZXQ7XG4gICAgICAgIHRoaXMuX2IgPSAtYiAvIGRldDtcbiAgICAgICAgdGhpcy5fYyA9IC1jIC8gZGV0O1xuICAgICAgICB0aGlzLl9kID0gYSAvIGRldDtcbiAgICAgICAgdGhpcy5fdHggPSAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldDtcbiAgICAgICAgdGhpcy5fdHkgPSAoYiAqIHR4IC0gYSAqIHR5KSAvIGRldDtcbiAgICAgICAgcmVzID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGludmVydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmludmVydCgpO1xuICAgIH0sXG4gICAgY29uY2F0ZW5hdGU6ICcjYXBwZW5kJyxcbiAgICBwcmVDb25jYXRlbmF0ZTogJyNwcmVwZW5kJyxcbiAgICBjaGFpbjogJyNhcHBlbmRlZCcsXG4gICAgX3NoaWZ0bGVzczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYywgdGhpcy5fZCwgMCwgMCk7XG4gICAgfSxcbiAgICBfb3JOdWxsSWZJZGVudGl0eTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNJZGVudGl0eSgpID8gbnVsbCA6IHRoaXM7XG4gICAgfSxcbiAgICBpc0lkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYSA9PT0gMSAmJiB0aGlzLl9iID09PSAwICYmIHRoaXMuX2MgPT09IDAgJiYgdGhpcy5fZCA9PT0gMSAmJiB0aGlzLl90eCA9PT0gMCAmJiB0aGlzLl90eSA9PT0gMDtcbiAgICB9LFxuICAgIGlzSW52ZXJ0aWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRldCA9IHRoaXMuX2EgKiB0aGlzLl9kIC0gdGhpcy5fYyAqIHRoaXMuX2I7XG4gICAgICByZXR1cm4gZGV0ICYmICFpc05hTihkZXQpICYmIGlzRmluaXRlKHRoaXMuX3R4KSAmJiBpc0Zpbml0ZSh0aGlzLl90eSk7XG4gICAgfSxcbiAgICBpc1Npbmd1bGFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaXNJbnZlcnRpYmxlKCk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChzcmMsIGRzdCwgY291bnQpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRoaXMuX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgOiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhzcmMsIGRzdCwgY291bnQpO1xuICAgIH0sXG4gICAgX3RyYW5zZm9ybVBvaW50OiBmdW5jdGlvbiAocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG4gICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgICBpZiAoIWRlc3QpIGRlc3QgPSBuZXcgUG9pbnQoKTtcbiAgICAgIHJldHVybiBkZXN0Ll9zZXQoeCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYyArIHRoaXMuX3R4LCB4ICogdGhpcy5fYiArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHksIF9kb250Tm90aWZ5KTtcbiAgICB9LFxuICAgIF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24gKHNyYywgZHN0LCBjb3VudCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IDIgKiBjb3VudDsgaSA8IG1heDsgaSArPSAyKSB7XG4gICAgICAgIHZhciB4ID0gc3JjW2ldLFxuICAgICAgICAgICAgeSA9IHNyY1tpICsgMV07XG4gICAgICAgIGRzdFtpXSA9IHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2MgKyB0aGlzLl90eDtcbiAgICAgICAgZHN0W2kgKyAxXSA9IHggKiB0aGlzLl9iICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRzdDtcbiAgICB9LFxuICAgIF90cmFuc2Zvcm1Db3JuZXJzOiBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgdmFyIHgxID0gcmVjdC54LFxuICAgICAgICAgIHkxID0gcmVjdC55LFxuICAgICAgICAgIHgyID0geDEgKyByZWN0LndpZHRoLFxuICAgICAgICAgIHkyID0geTEgKyByZWN0LmhlaWdodCxcbiAgICAgICAgICBjb29yZHMgPSBbeDEsIHkxLCB4MiwgeTEsIHgyLCB5MiwgeDEsIHkyXTtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIGNvb3JkcywgNCk7XG4gICAgfSxcbiAgICBfdHJhbnNmb3JtQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBkZXN0LCBfZG9udE5vdGlmeSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX3RyYW5zZm9ybUNvcm5lcnMoYm91bmRzKSxcbiAgICAgICAgICBtaW4gPSBjb29yZHMuc2xpY2UoMCwgMiksXG4gICAgICAgICAgbWF4ID0gbWluLnNsaWNlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIHZhciB2YWwgPSBjb29yZHNbaV0sXG4gICAgICAgICAgICBqID0gaSAmIDE7XG5cbiAgICAgICAgaWYgKHZhbCA8IG1pbltqXSkge1xuICAgICAgICAgIG1pbltqXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPiBtYXhbal0pIHtcbiAgICAgICAgICBtYXhbal0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFkZXN0KSBkZXN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgICAgcmV0dXJuIGRlc3QuX3NldChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0sIF9kb250Tm90aWZ5KTtcbiAgICB9LFxuICAgIGludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBfaW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuICAgICAgdmFyIGEgPSB0aGlzLl9hLFxuICAgICAgICAgIGIgPSB0aGlzLl9iLFxuICAgICAgICAgIGMgPSB0aGlzLl9jLFxuICAgICAgICAgIGQgPSB0aGlzLl9kLFxuICAgICAgICAgIHR4ID0gdGhpcy5fdHgsXG4gICAgICAgICAgdHkgPSB0aGlzLl90eSxcbiAgICAgICAgICBkZXQgPSBhICogZCAtIGIgKiBjLFxuICAgICAgICAgIHJlcyA9IG51bGw7XG5cbiAgICAgIGlmIChkZXQgJiYgIWlzTmFOKGRldCkgJiYgaXNGaW5pdGUodHgpICYmIGlzRmluaXRlKHR5KSkge1xuICAgICAgICB2YXIgeCA9IHBvaW50LnggLSB0aGlzLl90eCxcbiAgICAgICAgICAgIHkgPSBwb2ludC55IC0gdGhpcy5fdHk7XG4gICAgICAgIGlmICghZGVzdCkgZGVzdCA9IG5ldyBQb2ludCgpO1xuICAgICAgICByZXMgPSBkZXN0Ll9zZXQoKHggKiBkIC0geSAqIGMpIC8gZGV0LCAoeSAqIGEgLSB4ICogYikgLyBkZXQsIF9kb250Tm90aWZ5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29tcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGEgPSB0aGlzLl9hLFxuICAgICAgICAgIGIgPSB0aGlzLl9iLFxuICAgICAgICAgIGMgPSB0aGlzLl9jLFxuICAgICAgICAgIGQgPSB0aGlzLl9kLFxuICAgICAgICAgIGRldCA9IGEgKiBkIC0gYiAqIGMsXG4gICAgICAgICAgc3FydCA9IE1hdGguc3FydCxcbiAgICAgICAgICBhdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgICAgICAgZGVncmVlcyA9IDE4MCAvIE1hdGguUEksXG4gICAgICAgICAgcm90YXRlLFxuICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgIHNrZXc7XG5cbiAgICAgIGlmIChhICE9PSAwIHx8IGIgIT09IDApIHtcbiAgICAgICAgdmFyIHIgPSBzcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgICByb3RhdGUgPSBNYXRoLmFjb3MoYSAvIHIpICogKGIgPiAwID8gMSA6IC0xKTtcbiAgICAgICAgc2NhbGUgPSBbciwgZGV0IC8gcl07XG4gICAgICAgIHNrZXcgPSBbYXRhbjIoYSAqIGMgKyBiICogZCwgciAqIHIpLCAwXTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gMCB8fCBkICE9PSAwKSB7XG4gICAgICAgIHZhciBzID0gc3FydChjICogYyArIGQgKiBkKTtcbiAgICAgICAgcm90YXRlID0gTWF0aC5hc2luKGMgLyBzKSAqIChkID4gMCA/IDEgOiAtMSk7XG4gICAgICAgIHNjYWxlID0gW2RldCAvIHMsIHNdO1xuICAgICAgICBza2V3ID0gWzAsIGF0YW4yKGEgKiBjICsgYiAqIGQsIHMgKiBzKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3RhdGUgPSAwO1xuICAgICAgICBza2V3ID0gc2NhbGUgPSBbMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLmdldFRyYW5zbGF0aW9uKCksXG4gICAgICAgIHJvdGF0aW9uOiByb3RhdGUgKiBkZWdyZWVzLFxuICAgICAgICBzY2FsaW5nOiBuZXcgUG9pbnQoc2NhbGUpLFxuICAgICAgICBza2V3aW5nOiBuZXcgUG9pbnQoc2tld1swXSAqIGRlZ3JlZXMsIHNrZXdbMV0gKiBkZWdyZWVzKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFZhbHVlczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLl9hLCB0aGlzLl9iLCB0aGlzLl9jLCB0aGlzLl9kLCB0aGlzLl90eCwgdGhpcy5fdHldO1xuICAgIH0sXG4gICAgZ2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5fdHgsIHRoaXMuX3R5KTtcbiAgICB9LFxuICAgIGdldFNjYWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY29tcG9zZSgpLnNjYWxpbmc7XG4gICAgfSxcbiAgICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb21wb3NlKCkucm90YXRpb247XG4gICAgfSxcbiAgICBhcHBseVRvQ29udGV4dDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmlzSWRlbnRpdHkoKSkge1xuICAgICAgICBjdHgudHJhbnNmb3JtKHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBCYXNlLmVhY2goWydhJywgJ2InLCAnYycsICdkJywgJ3R4JywgJ3R5J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuICAgICAgICBwcm9wID0gJ18nICsga2V5O1xuXG4gICAgdGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXNbcHJvcF07XG4gICAgfTtcblxuICAgIHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpc1twcm9wXSA9IHZhbHVlO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfTtcbiAgfSwge30pKTtcbiAgdmFyIExpbmUgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnTGluZScsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gTGluZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICB2YXIgYXNWZWN0b3IgPSBmYWxzZTtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkge1xuICAgICAgICB0aGlzLl9weCA9IGFyZzA7XG4gICAgICAgIHRoaXMuX3B5ID0gYXJnMTtcbiAgICAgICAgdGhpcy5fdnggPSBhcmcyO1xuICAgICAgICB0aGlzLl92eSA9IGFyZzM7XG4gICAgICAgIGFzVmVjdG9yID0gYXJnNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3B4ID0gYXJnMC54O1xuICAgICAgICB0aGlzLl9weSA9IGFyZzAueTtcbiAgICAgICAgdGhpcy5fdnggPSBhcmcxLng7XG4gICAgICAgIHRoaXMuX3Z5ID0gYXJnMS55O1xuICAgICAgICBhc1ZlY3RvciA9IGFyZzI7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXNWZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fdnggLT0gdGhpcy5fcHg7XG4gICAgICAgIHRoaXMuX3Z5IC09IHRoaXMuX3B5O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5fcHgsIHRoaXMuX3B5KTtcbiAgICB9LFxuICAgIGdldFZlY3RvcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl92eCwgdGhpcy5fdnkpO1xuICAgIH0sXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWZWN0b3IoKS5nZXRMZW5ndGgoKTtcbiAgICB9LFxuICAgIGludGVyc2VjdDogZnVuY3Rpb24gKGxpbmUsIGlzSW5maW5pdGUpIHtcbiAgICAgIHJldHVybiBMaW5lLmludGVyc2VjdCh0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSwgbGluZS5fcHgsIGxpbmUuX3B5LCBsaW5lLl92eCwgbGluZS5fdnksIHRydWUsIGlzSW5maW5pdGUpO1xuICAgIH0sXG4gICAgZ2V0U2lkZTogZnVuY3Rpb24gKHBvaW50LCBpc0luZmluaXRlKSB7XG4gICAgICByZXR1cm4gTGluZS5nZXRTaWRlKHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LCBwb2ludC54LCBwb2ludC55LCB0cnVlLCBpc0luZmluaXRlKTtcbiAgICB9LFxuICAgIGdldERpc3RhbmNlOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmdldFNpZ25lZERpc3RhbmNlKHBvaW50KSk7XG4gICAgfSxcbiAgICBnZXRTaWduZWREaXN0YW5jZTogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gTGluZS5nZXRTaWduZWREaXN0YW5jZSh0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSwgcG9pbnQueCwgcG9pbnQueSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBpc0NvbGxpbmVhcjogZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHJldHVybiBQb2ludC5pc0NvbGxpbmVhcih0aGlzLl92eCwgdGhpcy5fdnksIGxpbmUuX3Z4LCBsaW5lLl92eSk7XG4gICAgfSxcbiAgICBpc09ydGhvZ29uYWw6IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICByZXR1cm4gUG9pbnQuaXNPcnRob2dvbmFsKHRoaXMuX3Z4LCB0aGlzLl92eSwgbGluZS5fdngsIGxpbmUuX3Z5KTtcbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKHAxeCwgcDF5LCB2MXgsIHYxeSwgcDJ4LCBwMnksIHYyeCwgdjJ5LCBhc1ZlY3RvciwgaXNJbmZpbml0ZSkge1xuICAgICAgICBpZiAoIWFzVmVjdG9yKSB7XG4gICAgICAgICAgdjF4IC09IHAxeDtcbiAgICAgICAgICB2MXkgLT0gcDF5O1xuICAgICAgICAgIHYyeCAtPSBwMng7XG4gICAgICAgICAgdjJ5IC09IHAyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjcm9zcyA9IHYxeCAqIHYyeSAtIHYxeSAqIHYyeDtcblxuICAgICAgICBpZiAoIU51bWVyaWNhbC5pc01hY2hpbmVaZXJvKGNyb3NzKSkge1xuICAgICAgICAgIHZhciBkeCA9IHAxeCAtIHAyeCxcbiAgICAgICAgICAgICAgZHkgPSBwMXkgLSBwMnksXG4gICAgICAgICAgICAgIHUxID0gKHYyeCAqIGR5IC0gdjJ5ICogZHgpIC8gY3Jvc3MsXG4gICAgICAgICAgICAgIHUyID0gKHYxeCAqIGR5IC0gdjF5ICogZHgpIC8gY3Jvc3MsXG4gICAgICAgICAgICAgIGVwc2lsb24gPSAxZS0xMixcbiAgICAgICAgICAgICAgdU1pbiA9IC1lcHNpbG9uLFxuICAgICAgICAgICAgICB1TWF4ID0gMSArIGVwc2lsb247XG5cbiAgICAgICAgICBpZiAoaXNJbmZpbml0ZSB8fCB1TWluIDwgdTEgJiYgdTEgPCB1TWF4ICYmIHVNaW4gPCB1MiAmJiB1MiA8IHVNYXgpIHtcbiAgICAgICAgICAgIGlmICghaXNJbmZpbml0ZSkge1xuICAgICAgICAgICAgICB1MSA9IHUxIDw9IDAgPyAwIDogdTEgPj0gMSA/IDEgOiB1MTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMXggKyB1MSAqIHYxeCwgcDF5ICsgdTEgKiB2MXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldFNpZGU6IGZ1bmN0aW9uIChweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IsIGlzSW5maW5pdGUpIHtcbiAgICAgICAgaWYgKCFhc1ZlY3Rvcikge1xuICAgICAgICAgIHZ4IC09IHB4O1xuICAgICAgICAgIHZ5IC09IHB5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHYyeCA9IHggLSBweCxcbiAgICAgICAgICAgIHYyeSA9IHkgLSBweSxcbiAgICAgICAgICAgIGNjdyA9IHYyeCAqIHZ5IC0gdjJ5ICogdng7XG5cbiAgICAgICAgaWYgKCFpc0luZmluaXRlICYmIE51bWVyaWNhbC5pc01hY2hpbmVaZXJvKGNjdykpIHtcbiAgICAgICAgICBjY3cgPSAodjJ4ICogdnggKyB2MnggKiB2eCkgLyAodnggKiB2eCArIHZ5ICogdnkpO1xuICAgICAgICAgIGlmIChjY3cgPj0gMCAmJiBjY3cgPD0gMSkgY2N3ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjY3cgPCAwID8gLTEgOiBjY3cgPiAwID8gMSA6IDA7XG4gICAgICB9LFxuICAgICAgZ2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uIChweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcbiAgICAgICAgaWYgKCFhc1ZlY3Rvcikge1xuICAgICAgICAgIHZ4IC09IHB4O1xuICAgICAgICAgIHZ5IC09IHB5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZ4ID09PSAwID8gdnkgPiAwID8geCAtIHB4IDogcHggLSB4IDogdnkgPT09IDAgPyB2eCA8IDAgPyB5IC0gcHkgOiBweSAtIHkgOiAoKHggLSBweCkgKiB2eSAtICh5IC0gcHkpICogdngpIC8gKHZ5ID4gdnggPyB2eSAqIE1hdGguc3FydCgxICsgdnggKiB2eCAvICh2eSAqIHZ5KSkgOiB2eCAqIE1hdGguc3FydCgxICsgdnkgKiB2eSAvICh2eCAqIHZ4KSkpO1xuICAgICAgfSxcbiAgICAgIGdldERpc3RhbmNlOiBmdW5jdGlvbiAocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhMaW5lLmdldFNpZ25lZERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3RvcikpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBQcm9qZWN0ID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdQcm9qZWN0JyxcbiAgICBfbGlzdDogJ3Byb2plY3RzJyxcbiAgICBfcmVmZXJlbmNlOiAncHJvamVjdCcsXG4gICAgX2NvbXBhY3RTZXJpYWxpemU6IHRydWUsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUHJvamVjdChlbGVtZW50KSB7XG4gICAgICBQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMsIHRydWUpO1xuICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgIHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcbiAgICAgIHRoaXMuX2FjdGl2ZUxheWVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2N1cnJlbnRTdHlsZSA9IG5ldyBTdHlsZShudWxsLCBudWxsLCB0aGlzKTtcbiAgICAgIHRoaXMuX3ZpZXcgPSBWaWV3LmNyZWF0ZSh0aGlzLCBlbGVtZW50IHx8IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcygxLCAxKSk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25JdGVtcyA9IHt9O1xuICAgICAgdGhpcy5fc2VsZWN0aW9uQ291bnQgPSAwO1xuICAgICAgdGhpcy5fdXBkYXRlVmVyc2lvbiA9IDA7XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuX2NoaWxkcmVuLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiAoZmxhZ3MsIGl0ZW0pIHtcbiAgICAgIGlmIChmbGFncyAmIDEpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl92aWV3O1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgdmlldy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGlmICghdmlldy5fcmVxdWVzdGVkICYmIHZpZXcuX2F1dG9VcGRhdGUpIHZpZXcucmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlcztcblxuICAgICAgaWYgKGNoYW5nZXMgJiYgaXRlbSkge1xuICAgICAgICB2YXIgY2hhbmdlc0J5SWQgPSB0aGlzLl9jaGFuZ2VzQnlJZCxcbiAgICAgICAgICAgIGlkID0gaXRlbS5faWQsXG4gICAgICAgICAgICBlbnRyeSA9IGNoYW5nZXNCeUlkW2lkXTtcblxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5mbGFncyB8PSBmbGFncztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlc0J5SWRbaWRdID0ge1xuICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgIGZsYWdzOiBmbGFnc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgY2hpbGRyZW5baV0ucmVtb3ZlKCk7XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgaWYgKCFyZW1vdmUuYmFzZS5jYWxsKHRoaXMpKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGhpcy5fdmlldykgdGhpcy5fdmlldy5yZW1vdmUoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0VmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG4gICAgfSxcbiAgICBnZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3R5bGU7XG4gICAgfSxcbiAgICBzZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgdGhpcy5fY3VycmVudFN0eWxlLnNldChzdHlsZSk7XG4gICAgfSxcbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlLnNldHRpbmdzO1xuICAgIH0sXG4gICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgfSxcbiAgICBnZXRBY3RpdmVMYXllcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUxheWVyIHx8IG5ldyBMYXllcih7XG4gICAgICAgIHByb2plY3Q6IHRoaXMsXG4gICAgICAgIGluc2VydDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRTeW1ib2xEZWZpbml0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRlZmluaXRpb25zID0gW10sXG4gICAgICAgICAgaWRzID0ge307XG4gICAgICB0aGlzLmdldEl0ZW1zKHtcbiAgICAgICAgY2xhc3M6IFN5bWJvbEl0ZW0sXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gaXRlbS5fZGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgaWQgPSBkZWZpbml0aW9uLl9pZDtcblxuICAgICAgICAgIGlmICghaWRzW2lkXSkge1xuICAgICAgICAgICAgaWRzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICBkZWZpbml0aW9ucy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGVmaW5pdGlvbnM7XG4gICAgfSxcbiAgICBnZXRTeW1ib2xzOiAnZ2V0U3ltYm9sRGVmaW5pdGlvbnMnLFxuICAgIGdldFNlbGVjdGVkSXRlbXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25JdGVtcyA9IHRoaXMuX3NlbGVjdGlvbkl0ZW1zLFxuICAgICAgICAgIGl0ZW1zID0gW107XG5cbiAgICAgIGZvciAodmFyIGlkIGluIHNlbGVjdGlvbkl0ZW1zKSB7XG4gICAgICAgIHZhciBpdGVtID0gc2VsZWN0aW9uSXRlbXNbaWRdLFxuICAgICAgICAgICAgc2VsZWN0aW9uID0gaXRlbS5fc2VsZWN0aW9uO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiAxICYmIGl0ZW0uaXNJbnNlcnRlZCgpKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0aW9uKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuICAgIF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgaWQgPSBpdGVtLl9pZCxcbiAgICAgICAgICBzZWxlY3Rpb25JdGVtcyA9IHRoaXMuX3NlbGVjdGlvbkl0ZW1zO1xuXG4gICAgICBpZiAoaXRlbS5fc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb25JdGVtc1tpZF0gIT09IGl0ZW0pIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25Db3VudCsrO1xuICAgICAgICAgIHNlbGVjdGlvbkl0ZW1zW2lkXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uSXRlbXNbaWRdID09PSBpdGVtKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbkNvdW50LS07XG4gICAgICAgIGRlbGV0ZSBzZWxlY3Rpb25JdGVtc1tpZF07XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgY2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZCh0cnVlKTtcbiAgICB9LFxuICAgIGRlc2VsZWN0QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uSXRlbXMgPSB0aGlzLl9zZWxlY3Rpb25JdGVtcztcblxuICAgICAgZm9yICh2YXIgaSBpbiBzZWxlY3Rpb25JdGVtcykgc2VsZWN0aW9uSXRlbXNbaV0uc2V0RnVsbHlTZWxlY3RlZChmYWxzZSk7XG4gICAgfSxcbiAgICBhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnRMYXllcih1bmRlZmluZWQsIGxheWVyKTtcbiAgICB9LFxuICAgIGluc2VydExheWVyOiBmdW5jdGlvbiAoaW5kZXgsIGxheWVyKSB7XG4gICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikge1xuICAgICAgICBsYXllci5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgW2xheWVyXSwgaW5kZXgsIDApO1xuXG4gICAgICAgIGxheWVyLl9zZXRQcm9qZWN0KHRoaXMsIHRydWUpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbGF5ZXIuX25hbWU7XG4gICAgICAgIGlmIChuYW1lKSBsYXllci5zZXROYW1lKG5hbWUpO1xuICAgICAgICBpZiAodGhpcy5fY2hhbmdlcykgbGF5ZXIuX2NoYW5nZWQoNSk7XG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlTGF5ZXIpIHRoaXMuX2FjdGl2ZUxheWVyID0gbGF5ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXllciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXllcjtcbiAgICB9LFxuICAgIF9pbnNlcnRJdGVtOiBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0sIF9jcmVhdGVkKSB7XG4gICAgICBpdGVtID0gdGhpcy5pbnNlcnRMYXllcihpbmRleCwgaXRlbSkgfHwgKHRoaXMuX2FjdGl2ZUxheWVyIHx8IHRoaXMuX2luc2VydEl0ZW0odW5kZWZpbmVkLCBuZXcgTGF5ZXIoSXRlbS5OT19JTlNFUlQpLCB0cnVlKSkuaW5zZXJ0Q2hpbGQoaW5kZXgsIGl0ZW0pO1xuICAgICAgaWYgKF9jcmVhdGVkICYmIGl0ZW0uYWN0aXZhdGUpIGl0ZW0uYWN0aXZhdGUoKTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0sXG4gICAgZ2V0SXRlbXM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcywgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBnZXRJdGVtOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMsIG9wdGlvbnMsIG51bGwsIG51bGwsIHRydWUpWzBdIHx8IG51bGw7XG4gICAgfSxcbiAgICBpbXBvcnRKU09OOiBmdW5jdGlvbiAoanNvbikge1xuICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5fYWN0aXZlTGF5ZXI7XG4gICAgICByZXR1cm4gQmFzZS5pbXBvcnRKU09OKGpzb24sIGxheWVyICYmIGxheWVyLmlzRW1wdHkoKSAmJiBsYXllcik7XG4gICAgfSxcbiAgICByZW1vdmVPbjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBzZXRzID0gdGhpcy5fcmVtb3ZlU2V0cztcblxuICAgICAgaWYgKHNldHMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZXVwJykgc2V0cy5tb3VzZWRyYWcgPSBudWxsO1xuICAgICAgICB2YXIgc2V0ID0gc2V0c1t0eXBlXTtcblxuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaWQgaW4gc2V0KSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHNldFtpZF07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzZXRzKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlciA9IHNldHNba2V5XTtcbiAgICAgICAgICAgICAgaWYgKG90aGVyICYmIG90aGVyICE9IHNldCkgZGVsZXRlIG90aGVyW2l0ZW0uX2lkXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRzW3R5cGVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gKGN0eCwgbWF0cml4LCBwaXhlbFJhdGlvKSB7XG4gICAgICB0aGlzLl91cGRhdGVWZXJzaW9uKys7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgbWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICBwYXJhbSA9IG5ldyBCYXNlKHtcbiAgICAgICAgb2Zmc2V0OiBuZXcgUG9pbnQoMCwgMCksXG4gICAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW8sXG4gICAgICAgIHZpZXdNYXRyaXg6IG1hdHJpeC5pc0lkZW50aXR5KCkgPyBudWxsIDogbWF0cml4LFxuICAgICAgICBtYXRyaWNlczogW25ldyBNYXRyaXgoKV0sXG4gICAgICAgIHVwZGF0ZU1hdHJpeDogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLmRyYXcoY3R4LCBwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25Db3VudCA+IDApIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnN0cm9rZVdpZHRoID0gMTtcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5fc2VsZWN0aW9uSXRlbXMsXG4gICAgICAgICAgICBzaXplID0gdGhpcy5fc2NvcGUuc2V0dGluZ3MuaGFuZGxlU2l6ZSxcbiAgICAgICAgICAgIHZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIGl0ZW1zKSB7XG4gICAgICAgICAgaXRlbXNbaWRdLl9kcmF3U2VsZWN0aW9uKGN0eCwgbWF0cml4LCBzaXplLCBpdGVtcywgdmVyc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBJdGVtID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuICAgIHN0YXRpY3M6IHtcbiAgICAgIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKHNyYykge1xuICAgICAgICBpZiAoc3JjLl9zZXJpYWxpemVGaWVsZHMpIHNyYy5fc2VyaWFsaXplRmllbGRzID0gQmFzZS5zZXQoe30sIHRoaXMucHJvdG90eXBlLl9zZXJpYWxpemVGaWVsZHMsIHNyYy5fc2VyaWFsaXplRmllbGRzKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgTk9fSU5TRVJUOiB7XG4gICAgICAgIGluc2VydDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jbGFzczogJ0l0ZW0nLFxuICAgIF9uYW1lOiBudWxsLFxuICAgIF9hcHBseU1hdHJpeDogdHJ1ZSxcbiAgICBfY2FuQXBwbHlNYXRyaXg6IHRydWUsXG4gICAgX2NhblNjYWxlU3Ryb2tlOiBmYWxzZSxcbiAgICBfcGl2b3Q6IG51bGwsXG4gICAgX3Zpc2libGU6IHRydWUsXG4gICAgX2JsZW5kTW9kZTogJ25vcm1hbCcsXG4gICAgX29wYWNpdHk6IDEsXG4gICAgX2xvY2tlZDogZmFsc2UsXG4gICAgX2d1aWRlOiBmYWxzZSxcbiAgICBfY2xpcE1hc2s6IGZhbHNlLFxuICAgIF9zZWxlY3Rpb246IDAsXG4gICAgX3NlbGVjdEJvdW5kczogdHJ1ZSxcbiAgICBfc2VsZWN0Q2hpbGRyZW46IGZhbHNlLFxuICAgIF9zZXJpYWxpemVGaWVsZHM6IHtcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICBhcHBseU1hdHJpeDogbnVsbCxcbiAgICAgIG1hdHJpeDogbmV3IE1hdHJpeCgpLFxuICAgICAgcGl2b3Q6IG51bGwsXG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgYmxlbmRNb2RlOiAnbm9ybWFsJyxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBsb2NrZWQ6IGZhbHNlLFxuICAgICAgZ3VpZGU6IGZhbHNlLFxuICAgICAgY2xpcE1hc2s6IGZhbHNlLFxuICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgZGF0YToge31cbiAgICB9LFxuICAgIF9wcmlvcml0aXplOiBbJ2FwcGx5TWF0cml4J11cbiAgfSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBbJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbkNsaWNrJywgJ29uRG91YmxlQ2xpY2snLCAnb25Nb3VzZU1vdmUnLCAnb25Nb3VzZUVudGVyJywgJ29uTW91c2VMZWF2ZSddO1xuICAgIHJldHVybiBCYXNlLmVhY2goaGFuZGxlcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSB7XG4gICAgICAgIGluc3RhbGw6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdGhpcy5nZXRWaWV3KCkuX2NvdW50SXRlbUV2ZW50KHR5cGUsIDEpO1xuICAgICAgICB9LFxuICAgICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdGhpcy5nZXRWaWV3KCkuX2NvdW50SXRlbUV2ZW50KHR5cGUsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCB7XG4gICAgICBfZXZlbnRzOiB7XG4gICAgICAgIG9uRnJhbWU6IHtcbiAgICAgICAgICBpbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmdldFZpZXcoKS5fYW5pbWF0ZUl0ZW0odGhpcywgdHJ1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkxvYWQ6IHt9LFxuICAgICAgICBvbkVycm9yOiB7fVxuICAgICAgfSxcbiAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgX2l0ZW1IYW5kbGVyczogaGFuZGxlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfSgpLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gSXRlbSgpIHt9LFxuICAgIF9pbml0aWFsaXplOiBmdW5jdGlvbiAocHJvcHMsIHBvaW50KSB7XG4gICAgICB2YXIgaGFzUHJvcHMgPSBwcm9wcyAmJiBCYXNlLmlzUGxhaW5PYmplY3QocHJvcHMpLFxuICAgICAgICAgIGludGVybmFsID0gaGFzUHJvcHMgJiYgcHJvcHMuaW50ZXJuYWwgPT09IHRydWUsXG4gICAgICAgICAgbWF0cml4ID0gdGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuICAgICAgICAgIHByb2plY3QgPSBoYXNQcm9wcyAmJiBwcm9wcy5wcm9qZWN0IHx8IHBhcGVyLnByb2plY3QsXG4gICAgICAgICAgc2V0dGluZ3MgPSBwYXBlci5zZXR0aW5ncztcbiAgICAgIHRoaXMuX2lkID0gaW50ZXJuYWwgPyBudWxsIDogVUlELmdldCgpO1xuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5faW5kZXggPSBudWxsO1xuICAgICAgdGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiBzZXR0aW5ncy5hcHBseU1hdHJpeDtcbiAgICAgIGlmIChwb2ludCkgbWF0cml4LnRyYW5zbGF0ZShwb2ludCk7XG4gICAgICBtYXRyaXguX293bmVyID0gdGhpcztcbiAgICAgIHRoaXMuX3N0eWxlID0gbmV3IFN0eWxlKHByb2plY3QuX2N1cnJlbnRTdHlsZSwgdGhpcywgcHJvamVjdCk7XG5cbiAgICAgIGlmIChpbnRlcm5hbCB8fCBoYXNQcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT0gZmFsc2UgfHwgIXNldHRpbmdzLmluc2VydEl0ZW1zICYmICEoaGFzUHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSB0cnVlKSkge1xuICAgICAgICB0aGlzLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGhhc1Byb3BzICYmIHByb3BzLnBhcmVudCB8fCBwcm9qZWN0KS5faW5zZXJ0SXRlbSh1bmRlZmluZWQsIHRoaXMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzUHJvcHMgJiYgcHJvcHMgIT09IEl0ZW0uTk9fSU5TRVJUKSB7XG4gICAgICAgIHRoaXMuc2V0KHByb3BzLCB7XG4gICAgICAgICAgaW50ZXJuYWw6IHRydWUsXG4gICAgICAgICAgaW5zZXJ0OiB0cnVlLFxuICAgICAgICAgIHByb2plY3Q6IHRydWUsXG4gICAgICAgICAgcGFyZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzUHJvcHM7XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgdmFyIHByb3BzID0ge30sXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZShmaWVsZHMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGZpZWxkcykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoYXRba2V5XTtcblxuICAgICAgICAgIGlmICghQmFzZS5lcXVhbHModmFsdWUsIGtleSA9PT0gJ2xlYWRpbmcnID8gZmllbGRzLmZvbnRTaXplICogMS4yIDogZmllbGRzW2tleV0pKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0gQmFzZS5zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMsIGtleSAhPT0gJ2RhdGEnLCBkaWN0aW9uYXJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VyaWFsaXplKHRoaXMuX3NlcmlhbGl6ZUZpZWxkcyk7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR3JvdXApKSBzZXJpYWxpemUodGhpcy5fc3R5bGUuX2RlZmF1bHRzKTtcbiAgICAgIHJldHVybiBbdGhpcy5fY2xhc3MsIHByb3BzXTtcbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgIHZhciBzeW1ib2wgPSB0aGlzLl9zeW1ib2wsXG4gICAgICAgICAgY2FjaGVQYXJlbnQgPSB0aGlzLl9wYXJlbnQgfHwgc3ltYm9sLFxuICAgICAgICAgIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXG4gICAgICBpZiAoZmxhZ3MgJiA4KSB7XG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsYWdzICYgMTYpIHtcbiAgICAgICAgdGhpcy5fZ2xvYmFsTWF0cml4ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FjaGVQYXJlbnQgJiYgZmxhZ3MgJiA3Mikge1xuICAgICAgICBJdGVtLl9jbGVhckJvdW5kc0NhY2hlKGNhY2hlUGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsYWdzICYgMikge1xuICAgICAgICBJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvamVjdCkgcHJvamVjdC5fY2hhbmdlZChmbGFncywgdGhpcyk7XG4gICAgICBpZiAoc3ltYm9sKSBzeW1ib2wuX2NoYW5nZWQoZmxhZ3MpO1xuICAgIH0sXG4gICAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9LFxuICAgIGdldE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH0sXG4gICAgc2V0TmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLl9uYW1lKSB0aGlzLl9yZW1vdmVOYW1lZCgpO1xuICAgICAgaWYgKG5hbWUgPT09ICtuYW1lICsgJycpIHRocm93IG5ldyBFcnJvcignTmFtZXMgY29uc2lzdGluZyBvbmx5IG9mIG51bWJlcnMgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG5cbiAgICAgIHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cbiAgICAgIGlmIChuYW1lICYmIG93bmVyKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG93bmVyLl9jaGlsZHJlbixcbiAgICAgICAgICAgIG5hbWVkQ2hpbGRyZW4gPSBvd25lci5fbmFtZWRDaGlsZHJlbjtcbiAgICAgICAgKG5hbWVkQ2hpbGRyZW5bbmFtZV0gPSBuYW1lZENoaWxkcmVuW25hbWVdIHx8IFtdKS5wdXNoKHRoaXMpO1xuICAgICAgICBpZiAoIShuYW1lIGluIGNoaWxkcmVuKSkgY2hpbGRyZW5bbmFtZV0gPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9uYW1lID0gbmFtZSB8fCB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoMjU2KTtcbiAgICB9LFxuICAgIGdldFN0eWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgfSxcbiAgICBzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICB0aGlzLmdldFN0eWxlKCkuc2V0KHN0eWxlKTtcbiAgICB9XG4gIH0sIEJhc2UuZWFjaChbJ2xvY2tlZCcsICd2aXNpYmxlJywgJ2JsZW5kTW9kZScsICdvcGFjaXR5JywgJ2d1aWRlJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG4gICAgICAgIGtleSA9ICdfJyArIG5hbWUsXG4gICAgICAgIGZsYWdzID0ge1xuICAgICAgbG9ja2VkOiAyNTYsXG4gICAgICB2aXNpYmxlOiAyNjVcbiAgICB9O1xuXG4gICAgdGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXNba2V5XTtcbiAgICB9O1xuXG4gICAgdGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT0gdGhpc1trZXldKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoZmxhZ3NbbmFtZV0gfHwgMjU3KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCB7fSksIHtcbiAgICBiZWFuczogdHJ1ZSxcbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb247XG4gICAgfSxcbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgIGlmIChzZWxlY3Rpb24gIT09IHRoaXMuX3NlbGVjdGlvbikge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblxuICAgICAgICBpZiAocHJvamVjdCkge1xuICAgICAgICAgIHByb2plY3QuX3VwZGF0ZVNlbGVjdGlvbih0aGlzKTtcblxuICAgICAgICAgIHRoaXMuX2NoYW5nZWQoMjU3KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX2NoYW5nZVNlbGVjdGlvbjogZnVuY3Rpb24gKGZsYWcsIHNlbGVjdGVkKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0ZWQgPyBzZWxlY3Rpb24gfCBmbGFnIDogc2VsZWN0aW9uICYgfmZsYWcpO1xuICAgIH0sXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBpZiAoY2hpbGRyZW5baV0uaXNTZWxlY3RlZCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICEhKHRoaXMuX3NlbGVjdGlvbiAmIDEpO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgaWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBjaGlsZHJlbltpXS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoYW5nZVNlbGVjdGlvbigxLCBzZWxlY3RlZCk7XG4gICAgfSxcbiAgICBpc0Z1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgIHNlbGVjdGVkID0gISEodGhpcy5fc2VsZWN0aW9uICYgMSk7XG5cbiAgICAgIGlmIChjaGlsZHJlbiAmJiBzZWxlY3RlZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgaWYgKCFjaGlsZHJlbltpXS5pc0Z1bGx5U2VsZWN0ZWQoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfSxcbiAgICBzZXRGdWxseVNlbGVjdGVkOiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGNoaWxkcmVuW2ldLnNldEZ1bGx5U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGFuZ2VTZWxlY3Rpb24oMSwgc2VsZWN0ZWQpO1xuICAgIH0sXG4gICAgaXNDbGlwTWFzazogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NsaXBNYXNrO1xuICAgIH0sXG4gICAgc2V0Q2xpcE1hc2s6IGZ1bmN0aW9uIChjbGlwTWFzaykge1xuICAgICAgaWYgKHRoaXMuX2NsaXBNYXNrICE9IChjbGlwTWFzayA9ICEhY2xpcE1hc2spKSB7XG4gICAgICAgIHRoaXMuX2NsaXBNYXNrID0gY2xpcE1hc2s7XG5cbiAgICAgICAgaWYgKGNsaXBNYXNrKSB7XG4gICAgICAgICAgdGhpcy5zZXRGaWxsQ29sb3IobnVsbCk7XG4gICAgICAgICAgdGhpcy5zZXRTdHJva2VDb2xvcihudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoMjU3KTtcblxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB0aGlzLl9wYXJlbnQuX2NoYW5nZWQoMjA0OCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2RhdGEpIHRoaXMuX2RhdGEgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH0sXG4gICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIH0sXG4gICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uIChfZG9udExpbmspIHtcbiAgICAgIHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblxuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gfHwgKHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb25Gcm9tQm91bmRzKCkpO1xuXG4gICAgICByZXR1cm4gbmV3IGN0b3IocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdGhpcywgJ3NldFBvc2l0aW9uJyk7XG4gICAgfSxcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFuc2xhdGUoUG9pbnQucmVhZChhcmd1bWVudHMpLnN1YnRyYWN0KHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcbiAgICB9LFxuICAgIF9nZXRQb3NpdGlvbkZyb21Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9waXZvdCA/IHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQodGhpcy5fcGl2b3QpIDogKGJvdW5kcyB8fCB0aGlzLmdldEJvdW5kcygpKS5nZXRDZW50ZXIodHJ1ZSk7XG4gICAgfSxcbiAgICBnZXRQaXZvdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG4gICAgICByZXR1cm4gcGl2b3QgPyBuZXcgTGlua2VkUG9pbnQocGl2b3QueCwgcGl2b3QueSwgdGhpcywgJ3NldFBpdm90JykgOiBudWxsO1xuICAgIH0sXG4gICAgc2V0UGl2b3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3Bpdm90ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHtcbiAgICAgICAgY2xvbmU6IHRydWUsXG4gICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwgQmFzZS5lYWNoKHtcbiAgICBnZXRTdHJva2VCb3VuZHM6IHtcbiAgICAgIHN0cm9rZTogdHJ1ZVxuICAgIH0sXG4gICAgZ2V0SGFuZGxlQm91bmRzOiB7XG4gICAgICBoYW5kbGU6IHRydWVcbiAgICB9LFxuICAgIGdldEludGVybmFsQm91bmRzOiB7XG4gICAgICBpbnRlcm5hbDogdHJ1ZVxuICAgIH1cbiAgfSwgZnVuY3Rpb24gKG9wdGlvbnMsIGtleSkge1xuICAgIHRoaXNba2V5XSA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcyhtYXRyaXgsIG9wdGlvbnMpO1xuICAgIH07XG4gIH0sIHtcbiAgICBiZWFuczogdHJ1ZSxcbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uIChtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBoYXNNYXRyaXggPSBvcHRpb25zIHx8IG1hdHJpeCBpbnN0YW5jZW9mIE1hdHJpeCxcbiAgICAgICAgICBvcHRzID0gQmFzZS5zZXQoe30sIGhhc01hdHJpeCA/IG9wdGlvbnMgOiBtYXRyaXgsIHRoaXMuX2JvdW5kc09wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRzLnN0cm9rZSB8fCB0aGlzLmdldFN0cm9rZVNjYWxpbmcoKSkgb3B0cy5jYWNoZUl0ZW0gPSB0aGlzO1xuXG4gICAgICB2YXIgcmVjdCA9IHRoaXMuX2dldENhY2hlZEJvdW5kcyhoYXNNYXRyaXggJiYgbWF0cml4LCBvcHRzKS5yZWN0O1xuXG4gICAgICByZXR1cm4gIWFyZ3VtZW50cy5sZW5ndGggPyBuZXcgTGlua2VkUmVjdGFuZ2xlKHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCwgdGhpcywgJ3NldEJvdW5kcycpIDogcmVjdDtcbiAgICB9LFxuICAgIHNldEJvdW5kczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG4gICAgICAgICAgX21hdHJpeCA9IHRoaXMuX21hdHJpeCxcbiAgICAgICAgICBtYXRyaXggPSBuZXcgTWF0cml4KCksXG4gICAgICAgICAgY2VudGVyID0gcmVjdC5nZXRDZW50ZXIoKTtcbiAgICAgIG1hdHJpeC50cmFuc2xhdGUoY2VudGVyKTtcblxuICAgICAgaWYgKHJlY3Qud2lkdGggIT0gYm91bmRzLndpZHRoIHx8IHJlY3QuaGVpZ2h0ICE9IGJvdW5kcy5oZWlnaHQpIHtcbiAgICAgICAgaWYgKCFfbWF0cml4LmlzSW52ZXJ0aWJsZSgpKSB7XG4gICAgICAgICAgX21hdHJpeC5zZXQoX21hdHJpeC5fYmFja3VwIHx8IG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpKSk7XG5cbiAgICAgICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0cml4LnNjYWxlKGJvdW5kcy53aWR0aCAhPT0gMCA/IHJlY3Qud2lkdGggLyBib3VuZHMud2lkdGggOiAwLCBib3VuZHMuaGVpZ2h0ICE9PSAwID8gcmVjdC5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0IDogMCk7XG4gICAgICB9XG5cbiAgICAgIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcbiAgICAgIG1hdHJpeC50cmFuc2xhdGUoLWNlbnRlci54LCAtY2VudGVyLnkpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0obWF0cml4KTtcbiAgICB9LFxuICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uIChtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSByZXR1cm4gbmV3IFJlY3RhbmdsZSgpO1xuXG4gICAgICBJdGVtLl91cGRhdGVCb3VuZHNDYWNoZSh0aGlzLCBvcHRpb25zLmNhY2hlSXRlbSk7XG5cbiAgICAgIHJldHVybiBJdGVtLl9nZXRCb3VuZHMoY2hpbGRyZW4sIG1hdHJpeCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBfZ2V0Qm91bmRzQ2FjaGVLZXk6IGZ1bmN0aW9uIChvcHRpb25zLCBpbnRlcm5hbCkge1xuICAgICAgcmV0dXJuIFtvcHRpb25zLnN0cm9rZSA/IDEgOiAwLCBvcHRpb25zLmhhbmRsZSA/IDEgOiAwLCBpbnRlcm5hbCA/IDEgOiAwXS5qb2luKCcnKTtcbiAgICB9LFxuICAgIF9nZXRDYWNoZWRCb3VuZHM6IGZ1bmN0aW9uIChtYXRyaXgsIG9wdGlvbnMsIG5vSW50ZXJuYWwpIHtcbiAgICAgIG1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguX29yTnVsbElmSWRlbnRpdHkoKTtcblxuICAgICAgdmFyIGludGVybmFsID0gb3B0aW9ucy5pbnRlcm5hbCAmJiAhbm9JbnRlcm5hbCxcbiAgICAgICAgICBjYWNoZUl0ZW0gPSBvcHRpb25zLmNhY2hlSXRlbSxcbiAgICAgICAgICBfbWF0cml4ID0gaW50ZXJuYWwgPyBudWxsIDogdGhpcy5fbWF0cml4Ll9vck51bGxJZklkZW50aXR5KCksXG4gICAgICAgICAgY2FjaGVLZXkgPSBjYWNoZUl0ZW0gJiYgKCFtYXRyaXggfHwgbWF0cml4LmVxdWFscyhfbWF0cml4KSkgJiYgdGhpcy5fZ2V0Qm91bmRzQ2FjaGVLZXkob3B0aW9ucywgaW50ZXJuYWwpLFxuICAgICAgICAgIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblxuICAgICAgSXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcy5fcGFyZW50IHx8IHRoaXMuX3N5bWJvbCwgY2FjaGVJdGVtKTtcblxuICAgICAgaWYgKGNhY2hlS2V5ICYmIGJvdW5kcyAmJiBjYWNoZUtleSBpbiBib3VuZHMpIHtcbiAgICAgICAgdmFyIGNhY2hlZCA9IGJvdW5kc1tjYWNoZUtleV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVjdDogY2FjaGVkLnJlY3QuY2xvbmUoKSxcbiAgICAgICAgICBub25zY2FsaW5nOiBjYWNoZWQubm9uc2NhbGluZ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0gdGhpcy5fZ2V0Qm91bmRzKG1hdHJpeCB8fCBfbWF0cml4LCBvcHRpb25zKSxcbiAgICAgICAgICByZWN0ID0gcmVzLnJlY3QgfHwgcmVzLFxuICAgICAgICAgIHN0eWxlID0gdGhpcy5fc3R5bGUsXG4gICAgICAgICAgbm9uc2NhbGluZyA9IHJlcy5ub25zY2FsaW5nIHx8IHN0eWxlLmhhc1N0cm9rZSgpICYmICFzdHlsZS5nZXRTdHJva2VTY2FsaW5nKCk7XG5cbiAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICAgIHRoaXMuX2JvdW5kcyA9IGJvdW5kcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhY2hlZCA9IGJvdW5kc1tjYWNoZUtleV0gPSB7XG4gICAgICAgICAgcmVjdDogcmVjdC5jbG9uZSgpLFxuICAgICAgICAgIG5vbnNjYWxpbmc6IG5vbnNjYWxpbmcsXG4gICAgICAgICAgaW50ZXJuYWw6IGludGVybmFsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlY3Q6IHJlY3QsXG4gICAgICAgIG5vbnNjYWxpbmc6IG5vbnNjYWxpbmdcbiAgICAgIH07XG4gICAgfSxcbiAgICBfZ2V0U3Ryb2tlTWF0cml4OiBmdW5jdGlvbiAobWF0cml4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRTdHJva2VTY2FsaW5nKCkgPyBudWxsIDogb3B0aW9ucyAmJiBvcHRpb25zLmludGVybmFsID8gdGhpcyA6IHRoaXMuX3BhcmVudCB8fCB0aGlzLl9zeW1ib2wgJiYgdGhpcy5fc3ltYm9sLl9pdGVtLFxuICAgICAgICAgIG14ID0gcGFyZW50ID8gcGFyZW50LmdldFZpZXdNYXRyaXgoKS5pbnZlcnQoKSA6IG1hdHJpeDtcbiAgICAgIHJldHVybiBteCAmJiBteC5fc2hpZnRsZXNzKCk7XG4gICAgfSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBfdXBkYXRlQm91bmRzQ2FjaGU6IGZ1bmN0aW9uIChwYXJlbnQsIGl0ZW0pIHtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBpdGVtKSB7XG4gICAgICAgICAgdmFyIGlkID0gaXRlbS5faWQsXG4gICAgICAgICAgICAgIHJlZiA9IHBhcmVudC5fYm91bmRzQ2FjaGUgPSBwYXJlbnQuX2JvdW5kc0NhY2hlIHx8IHtcbiAgICAgICAgICAgIGlkczoge30sXG4gICAgICAgICAgICBsaXN0OiBbXVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoIXJlZi5pZHNbaWRdKSB7XG4gICAgICAgICAgICByZWYubGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcmVmLmlkc1tpZF0gPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jbGVhckJvdW5kc0NhY2hlOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBpdGVtLl9ib3VuZHNDYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBpdGVtLl9ib3VuZHMgPSBpdGVtLl9wb3NpdGlvbiA9IGl0ZW0uX2JvdW5kc0NhY2hlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBjYWNoZS5saXN0LCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGxpc3RbaV07XG5cbiAgICAgICAgICAgIGlmIChvdGhlciAhPT0gaXRlbSkge1xuICAgICAgICAgICAgICBvdGhlci5fYm91bmRzID0gb3RoZXIuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBpZiAob3RoZXIuX2JvdW5kc0NhY2hlKSBJdGVtLl9jbGVhckJvdW5kc0NhY2hlKG90aGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbiAoaXRlbXMsIG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgeDEgPSBJbmZpbml0eSxcbiAgICAgICAgICAgIHgyID0gLXgxLFxuICAgICAgICAgICAgeTEgPSB4MSxcbiAgICAgICAgICAgIHkyID0geDIsXG4gICAgICAgICAgICBub25zY2FsaW5nID0gZmFsc2U7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICAgIGlmIChpdGVtLl92aXNpYmxlICYmICFpdGVtLmlzRW1wdHkodHJ1ZSkpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBpdGVtLl9nZXRDYWNoZWRCb3VuZHMobWF0cml4ICYmIG1hdHJpeC5hcHBlbmRlZChpdGVtLl9tYXRyaXgpLCBvcHRpb25zLCB0cnVlKSxcbiAgICAgICAgICAgICAgICByZWN0ID0gYm91bmRzLnJlY3Q7XG5cbiAgICAgICAgICAgIHgxID0gTWF0aC5taW4ocmVjdC54LCB4MSk7XG4gICAgICAgICAgICB5MSA9IE1hdGgubWluKHJlY3QueSwgeTEpO1xuICAgICAgICAgICAgeDIgPSBNYXRoLm1heChyZWN0LnggKyByZWN0LndpZHRoLCB4Mik7XG4gICAgICAgICAgICB5MiA9IE1hdGgubWF4KHJlY3QueSArIHJlY3QuaGVpZ2h0LCB5Mik7XG4gICAgICAgICAgICBpZiAoYm91bmRzLm5vbnNjYWxpbmcpIG5vbnNjYWxpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVjdDogaXNGaW5pdGUoeDEpID8gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpIDogbmV3IFJlY3RhbmdsZSgpLFxuICAgICAgICAgIG5vbnNjYWxpbmc6IG5vbnNjYWxpbmdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCB7XG4gICAgYmVhbnM6IHRydWUsXG4gICAgX2RlY29tcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TWF0cml4ID8gbnVsbCA6IHRoaXMuX2RlY29tcG9zZWQgfHwgKHRoaXMuX2RlY29tcG9zZWQgPSB0aGlzLl9tYXRyaXguZGVjb21wb3NlKCkpO1xuICAgIH0sXG4gICAgZ2V0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlKCk7XG5cbiAgICAgIHJldHVybiBkZWNvbXBvc2VkID8gZGVjb21wb3NlZC5yb3RhdGlvbiA6IDA7XG4gICAgfSxcbiAgICBzZXRSb3RhdGlvbjogZnVuY3Rpb24gKHJvdGF0aW9uKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0Um90YXRpb24oKTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiByb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZDtcbiAgICAgICAgdGhpcy5yb3RhdGUocm90YXRpb24gLSBjdXJyZW50KTtcblxuICAgICAgICBpZiAoZGVjb21wb3NlZCkge1xuICAgICAgICAgIGRlY29tcG9zZWQucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgICAgICB0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0U2NhbGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2UoKSxcbiAgICAgICAgICBzID0gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnNjYWxpbmc7XG5cbiAgICAgIHJldHVybiBuZXcgTGlua2VkUG9pbnQocyA/IHMueCA6IDEsIHMgPyBzLnkgOiAxLCB0aGlzLCAnc2V0U2NhbGluZycpO1xuICAgIH0sXG4gICAgc2V0U2NhbGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFNjYWxpbmcoKSxcbiAgICAgICAgICBzY2FsaW5nID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHtcbiAgICAgICAgY2xvbmU6IHRydWUsXG4gICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGN1cnJlbnQgJiYgc2NhbGluZyAmJiAhY3VycmVudC5lcXVhbHMoc2NhbGluZykpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgICAgICAgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQsXG4gICAgICAgICAgICBtYXRyaXggPSBuZXcgTWF0cml4KCksXG4gICAgICAgICAgICBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXG4gICAgICAgIGlmIChpc1plcm8oY3VycmVudC54KSB8fCBpc1plcm8oY3VycmVudC55KSkge1xuICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUoZGVjb21wb3NlZC50cmFuc2xhdGlvbik7XG5cbiAgICAgICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgICAgIG1hdHJpeC5yb3RhdGUocm90YXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hdHJpeC5zY2FsZShzY2FsaW5nLngsIHNjYWxpbmcueSk7XG5cbiAgICAgICAgICB0aGlzLl9tYXRyaXguc2V0KG1hdHJpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSk7XG4gICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShjZW50ZXIpO1xuICAgICAgICAgIGlmIChyb3RhdGlvbikgbWF0cml4LnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICAgICAgbWF0cml4LnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcbiAgICAgICAgICBpZiAocm90YXRpb24pIG1hdHJpeC5yb3RhdGUoLXJvdGF0aW9uKTtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm0obWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWNvbXBvc2VkKSB7XG4gICAgICAgICAgZGVjb21wb3NlZC5zY2FsaW5nID0gc2NhbGluZztcbiAgICAgICAgICB0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TWF0cml4OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF0cml4O1xuICAgIH0sXG4gICAgc2V0TWF0cml4OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuICAgICAgbWF0cml4LnNldC5hcHBseShtYXRyaXgsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRHbG9iYWxNYXRyaXg6IGZ1bmN0aW9uIChfZG9udENsb25lKSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4O1xuXG4gICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnRzID0gW107XG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgIGlmICghcGFyZW50Ll9nbG9iYWxNYXRyaXgpIHtcbiAgICAgICAgICAgIG1hdHJpeCA9IG51bGw7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFyZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgcGFyZW50c1tpXS5fZ2xvYmFsTWF0cml4ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRyaXgpIHtcbiAgICAgICAgbWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIG1hdHJpeC5wcmVwZW5kKHBhcmVudC5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2RvbnRDbG9uZSA/IG1hdHJpeCA6IG1hdHJpeC5jbG9uZSgpO1xuICAgIH0sXG4gICAgZ2V0Vmlld01hdHJpeDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KCkucHJlcGVuZCh0aGlzLmdldFZpZXcoKS5fbWF0cml4KTtcbiAgICB9LFxuICAgIGdldEFwcGx5TWF0cml4OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlNYXRyaXg7XG4gICAgfSxcbiAgICBzZXRBcHBseU1hdHJpeDogZnVuY3Rpb24gKGFwcGx5KSB7XG4gICAgICBpZiAodGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiAhIWFwcGx5KSB0aGlzLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldFRyYW5zZm9ybUNvbnRlbnQ6ICcjZ2V0QXBwbHlNYXRyaXgnLFxuICAgIHNldFRyYW5zZm9ybUNvbnRlbnQ6ICcjc2V0QXBwbHlNYXRyaXgnXG4gIH0sIHtcbiAgICBnZXRQcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvamVjdDtcbiAgICB9LFxuICAgIF9zZXRQcm9qZWN0OiBmdW5jdGlvbiAocHJvamVjdCwgaW5zdGFsbEV2ZW50cykge1xuICAgICAgaWYgKHRoaXMuX3Byb2plY3QgIT09IHByb2plY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2plY3QpIHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuICAgICAgICB0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIGNoaWxkcmVuW2ldLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXG4gICAgICAgIGluc3RhbGxFdmVudHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdGFsbEV2ZW50cykgdGhpcy5faW5zdGFsbEV2ZW50cyh0cnVlKTtcbiAgICB9LFxuICAgIGdldFZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0Ll92aWV3O1xuICAgIH0sXG4gICAgX2luc3RhbGxFdmVudHM6IGZ1bmN0aW9uIF9pbnN0YWxsRXZlbnRzKGluc3RhbGwpIHtcbiAgICAgIF9pbnN0YWxsRXZlbnRzLmJhc2UuY2FsbCh0aGlzLCBpbnN0YWxsKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBjaGlsZHJlbltpXS5faW5zdGFsbEV2ZW50cyhpbnN0YWxsKTtcbiAgICB9LFxuICAgIGdldExheWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBMYXllcikgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBnZXRQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfSxcbiAgICBzZXRQYXJlbnQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5hZGRDaGlsZCh0aGlzKTtcbiAgICB9LFxuICAgIF9nZXRPd25lcjogJyNnZXRQYXJlbnQnLFxuICAgIGdldENoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgfSxcbiAgICBzZXRDaGlsZHJlbjogZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgICB0aGlzLmFkZENoaWxkcmVuKGl0ZW1zKTtcbiAgICB9LFxuICAgIGdldEZpcnN0Q2hpbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblswXSB8fCBudWxsO1xuICAgIH0sXG4gICAgZ2V0TGFzdENoaWxkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9LFxuICAgIGdldE5leHRTaWJsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXG4gICAgICByZXR1cm4gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcbiAgICB9LFxuICAgIGdldFByZXZpb3VzU2libGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblxuICAgICAgcmV0dXJuIG93bmVyICYmIG93bmVyLl9jaGlsZHJlblt0aGlzLl9pbmRleCAtIDFdIHx8IG51bGw7XG4gICAgfSxcbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gPT09IHRoaXMgfHwgaXRlbSAmJiB0aGlzLl9jbGFzcyA9PT0gaXRlbS5fY2xhc3MgJiYgdGhpcy5fc3R5bGUuZXF1YWxzKGl0ZW0uX3N0eWxlKSAmJiB0aGlzLl9tYXRyaXguZXF1YWxzKGl0ZW0uX21hdHJpeCkgJiYgdGhpcy5fbG9ja2VkID09PSBpdGVtLl9sb2NrZWQgJiYgdGhpcy5fdmlzaWJsZSA9PT0gaXRlbS5fdmlzaWJsZSAmJiB0aGlzLl9ibGVuZE1vZGUgPT09IGl0ZW0uX2JsZW5kTW9kZSAmJiB0aGlzLl9vcGFjaXR5ID09PSBpdGVtLl9vcGFjaXR5ICYmIHRoaXMuX2NsaXBNYXNrID09PSBpdGVtLl9jbGlwTWFzayAmJiB0aGlzLl9ndWlkZSA9PT0gaXRlbS5fZ3VpZGUgJiYgdGhpcy5fZXF1YWxzKGl0ZW0pIHx8IGZhbHNlO1xuICAgIH0sXG4gICAgX2VxdWFsczogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBCYXNlLmVxdWFscyh0aGlzLl9jaGlsZHJlbiwgaXRlbS5fY2hpbGRyZW4pO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgY29weSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKEl0ZW0uTk9fSU5TRVJUKSxcbiAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgIGluc2VydCA9IEJhc2UucGljayhvcHRpb25zID8gb3B0aW9ucy5pbnNlcnQgOiB1bmRlZmluZWQsIG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zID09PSB0cnVlKSxcbiAgICAgICAgICBkZWVwID0gQmFzZS5waWNrKG9wdGlvbnMgPyBvcHRpb25zLmRlZXAgOiB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgaWYgKGNoaWxkcmVuKSBjb3B5LmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuICAgICAgaWYgKCFjaGlsZHJlbiB8fCBkZWVwKSBjb3B5LmNvcHlDb250ZW50KHRoaXMpO1xuICAgICAgaWYgKCFjaGlsZHJlbikgY29weS5jb3B5QXR0cmlidXRlcyh0aGlzKTtcbiAgICAgIGlmIChpbnNlcnQpIGNvcHkuaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXG4gICAgICBpZiAobmFtZSAmJiBwYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcbiAgICAgICAgICAgIG9yaWcgPSBuYW1lLFxuICAgICAgICAgICAgaSA9IDE7XG5cbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuW25hbWVdKSBuYW1lID0gb3JpZyArICcgJyArIGkrKztcblxuICAgICAgICBpZiAobmFtZSAhPT0gb3JpZykgY29weS5zZXROYW1lKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29weTtcbiAgICB9LFxuICAgIGNvcHlDb250ZW50OiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBzb3VyY2UuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkcmVuW2ldLmNsb25lKGZhbHNlKSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb3B5QXR0cmlidXRlczogZnVuY3Rpb24gKHNvdXJjZSwgZXhjbHVkZU1hdHJpeCkge1xuICAgICAgdGhpcy5zZXRTdHlsZShzb3VyY2UuX3N0eWxlKTtcbiAgICAgIHZhciBrZXlzID0gWydfbG9ja2VkJywgJ192aXNpYmxlJywgJ19ibGVuZE1vZGUnLCAnX29wYWNpdHknLCAnX2NsaXBNYXNrJywgJ19ndWlkZSddO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHRoaXNba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWV4Y2x1ZGVNYXRyaXgpIHRoaXMuX21hdHJpeC5zZXQoc291cmNlLl9tYXRyaXgsIHRydWUpO1xuICAgICAgdGhpcy5zZXRBcHBseU1hdHJpeChzb3VyY2UuX2FwcGx5TWF0cml4KTtcbiAgICAgIHRoaXMuc2V0UGl2b3Qoc291cmNlLl9waXZvdCk7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbihzb3VyY2UuX3NlbGVjdGlvbik7XG4gICAgICB2YXIgZGF0YSA9IHNvdXJjZS5fZGF0YSxcbiAgICAgICAgICBuYW1lID0gc291cmNlLl9uYW1lO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGEgPyBCYXNlLmNsb25lKGRhdGEpIDogbnVsbDtcbiAgICAgIGlmIChuYW1lKSB0aGlzLnNldE5hbWUobmFtZSk7XG4gICAgfSxcbiAgICByYXN0ZXJpemU6IGZ1bmN0aW9uIChyZXNvbHV0aW9uLCBpbnNlcnQpIHtcbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcygpLFxuICAgICAgICAgIHNjYWxlID0gKHJlc29sdXRpb24gfHwgdGhpcy5nZXRWaWV3KCkuZ2V0UmVzb2x1dGlvbigpKSAvIDcyLFxuICAgICAgICAgIHRvcExlZnQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCksXG4gICAgICAgICAgYm90dG9tUmlnaHQgPSBib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKS5jZWlsKCksXG4gICAgICAgICAgc2l6ZSA9IG5ldyBTaXplKGJvdHRvbVJpZ2h0LnN1YnRyYWN0KHRvcExlZnQpKSxcbiAgICAgICAgICByYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblxuICAgICAgaWYgKCFzaXplLmlzWmVybygpKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZS5tdWx0aXBseShzY2FsZSkpLFxuICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgICBtYXRyaXggPSBuZXcgTWF0cml4KCkuc2NhbGUoc2NhbGUpLnRyYW5zbGF0ZSh0b3BMZWZ0Lm5lZ2F0ZSgpKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgbWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG4gICAgICAgIHRoaXMuZHJhdyhjdHgsIG5ldyBCYXNlKHtcbiAgICAgICAgICBtYXRyaWNlczogW21hdHJpeF1cbiAgICAgICAgfSkpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByYXN0ZXIuc2V0Q2FudmFzKGNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIHJhc3Rlci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZSh0b3BMZWZ0LmFkZChzaXplLmRpdmlkZSgyKSkpLnNjYWxlKDEgLyBzY2FsZSkpO1xuICAgICAgaWYgKGluc2VydCA9PT0gdW5kZWZpbmVkIHx8IGluc2VydCkgcmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuICAgICAgcmV0dXJuIHJhc3RlcjtcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuICAgICAgcmV0dXJuIG1hdHJpeC5pc0ludmVydGlibGUoKSAmJiAhIXRoaXMuX2NvbnRhaW5zKG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpKTtcbiAgICB9LFxuICAgIF9jb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5jb250YWlucyhwb2ludCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnQuaXNJbnNpZGUodGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcbiAgICB9LFxuICAgIGlzSW5zaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzLmdldEJvdW5kcygpKTtcbiAgICB9LFxuICAgIF9hc1BhdGhJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBhdGguUmVjdGFuZ2xlKHtcbiAgICAgICAgcmVjdGFuZ2xlOiB0aGlzLmdldEludGVybmFsQm91bmRzKCksXG4gICAgICAgIG1hdHJpeDogdGhpcy5fbWF0cml4LFxuICAgICAgICBpbnNlcnQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGludGVyc2VjdHM6IGZ1bmN0aW9uIChpdGVtLCBfbWF0cml4KSB7XG4gICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgSXRlbSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLl9hc1BhdGhJdGVtKCkuZ2V0SW50ZXJzZWN0aW9ucyhpdGVtLl9hc1BhdGhJdGVtKCksIG51bGwsIF9tYXRyaXgsIHRydWUpLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9LCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGhpdFRlc3QoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiB0aGlzLl9oaXRUZXN0KFBvaW50LnJlYWQoYXJncyksIEhpdFJlc3VsdC5nZXRPcHRpb25zKGFyZ3MpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoaXRUZXN0QWxsKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgIG9wdGlvbnMgPSBIaXRSZXN1bHQuZ2V0T3B0aW9ucyhhcmdzKSxcbiAgICAgICAgICBhbGwgPSBbXTtcblxuICAgICAgdGhpcy5faGl0VGVzdChwb2ludCwgbmV3IEJhc2Uoe1xuICAgICAgICBhbGw6IGFsbFxuICAgICAgfSwgb3B0aW9ucykpO1xuXG4gICAgICByZXR1cm4gYWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhpdFRlc3RDaGlsZHJlbihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCwgX2V4Y2x1ZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgICB2YXIgcmVzID0gY2hpbGQgIT09IF9leGNsdWRlICYmIGNoaWxkLl9oaXRUZXN0KHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4KTtcblxuICAgICAgICAgIGlmIChyZXMgJiYgIW9wdGlvbnMuYWxsKSByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIFByb2plY3QuaW5qZWN0KHtcbiAgICAgIGhpdFRlc3Q6IGhpdFRlc3QsXG4gICAgICBoaXRUZXN0QWxsOiBoaXRUZXN0QWxsLFxuICAgICAgX2hpdFRlc3Q6IGhpdFRlc3RDaGlsZHJlblxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBoaXRUZXN0OiBoaXRUZXN0LFxuICAgICAgaGl0VGVzdEFsbDogaGl0VGVzdEFsbCxcbiAgICAgIF9oaXRUZXN0Q2hpbGRyZW46IGhpdFRlc3RDaGlsZHJlblxuICAgIH07XG4gIH0oKSwge1xuICAgIF9oaXRUZXN0OiBmdW5jdGlvbiAocG9pbnQsIG9wdGlvbnMsIHBhcmVudFZpZXdNYXRyaXgpIHtcbiAgICAgIGlmICh0aGlzLl9sb2NrZWQgfHwgIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fZ3VpZGUgJiYgIW9wdGlvbnMuZ3VpZGVzIHx8IHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuICAgICAgICAgIHZpZXdNYXRyaXggPSBwYXJlbnRWaWV3TWF0cml4ID8gcGFyZW50Vmlld01hdHJpeC5hcHBlbmRlZChtYXRyaXgpIDogdGhpcy5nZXRHbG9iYWxNYXRyaXgoKS5wcmVwZW5kKHRoaXMuZ2V0VmlldygpLl9tYXRyaXgpLFxuICAgICAgICAgIHRvbGVyYW5jZSA9IE1hdGgubWF4KG9wdGlvbnMudG9sZXJhbmNlLCAxZS0xMiksXG4gICAgICAgICAgdG9sZXJhbmNlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcgPSBuZXcgU2l6ZShQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHRvbGVyYW5jZSwgbWF0cml4Ll9zaGlmdGxlc3MoKS5pbnZlcnQoKSkpO1xuICAgICAgcG9pbnQgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0ocG9pbnQpO1xuXG4gICAgICBpZiAoIXBvaW50IHx8ICF0aGlzLl9jaGlsZHJlbiAmJiAhdGhpcy5nZXRCb3VuZHMoe1xuICAgICAgICBpbnRlcm5hbDogdHJ1ZSxcbiAgICAgICAgc3Ryb2tlOiB0cnVlLFxuICAgICAgICBoYW5kbGU6IHRydWVcbiAgICAgIH0pLmV4cGFuZCh0b2xlcmFuY2VQYWRkaW5nLm11bHRpcGx5KDIpKS5fY29udGFpbnNQb2ludChwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGVja1NlbGYgPSAhKG9wdGlvbnMuZ3VpZGVzICYmICF0aGlzLl9ndWlkZSB8fCBvcHRpb25zLnNlbGVjdGVkICYmICF0aGlzLmlzU2VsZWN0ZWQoKSB8fCBvcHRpb25zLnR5cGUgJiYgb3B0aW9ucy50eXBlICE9PSBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcykgfHwgb3B0aW9ucy5jbGFzcyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBvcHRpb25zLmNsYXNzKSksXG4gICAgICAgICAgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGJvdW5kcyxcbiAgICAgICAgICByZXM7XG5cbiAgICAgIGZ1bmN0aW9uIGZpbHRlcihoaXQpIHtcbiAgICAgICAgaWYgKGhpdCAmJiBtYXRjaCAmJiAhbWF0Y2goaGl0KSkgaGl0ID0gbnVsbDtcbiAgICAgICAgaWYgKGhpdCAmJiBvcHRpb25zLmFsbCkgb3B0aW9ucy5hbGwucHVzaChoaXQpO1xuICAgICAgICByZXR1cm4gaGl0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1BvaW50KHR5cGUsIHBhcnQpIHtcbiAgICAgICAgdmFyIHB0ID0gcGFydCA/IGJvdW5kc1snZ2V0JyArIHBhcnRdKCkgOiB0aGF0LmdldFBvc2l0aW9uKCk7XG5cbiAgICAgICAgaWYgKHBvaW50LnN1YnRyYWN0KHB0KS5kaXZpZGUodG9sZXJhbmNlUGFkZGluZykubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEhpdFJlc3VsdCh0eXBlLCB0aGF0LCB7XG4gICAgICAgICAgICBuYW1lOiBwYXJ0ID8gQmFzZS5oeXBoZW5hdGUocGFydCkgOiB0eXBlLFxuICAgICAgICAgICAgcG9pbnQ6IHB0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNoZWNrUG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uLFxuICAgICAgICAgIGNoZWNrQ2VudGVyID0gb3B0aW9ucy5jZW50ZXIsXG4gICAgICAgICAgY2hlY2tCb3VuZHMgPSBvcHRpb25zLmJvdW5kcztcblxuICAgICAgaWYgKGNoZWNrU2VsZiAmJiB0aGlzLl9wYXJlbnQgJiYgKGNoZWNrUG9zaXRpb24gfHwgY2hlY2tDZW50ZXIgfHwgY2hlY2tCb3VuZHMpKSB7XG4gICAgICAgIGlmIChjaGVja0NlbnRlciB8fCBjaGVja0JvdW5kcykge1xuICAgICAgICAgIGJvdW5kcyA9IHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyA9IGNoZWNrUG9zaXRpb24gJiYgY2hlY2tQb2ludCgncG9zaXRpb24nKSB8fCBjaGVja0NlbnRlciAmJiBjaGVja1BvaW50KCdjZW50ZXInLCAnQ2VudGVyJyk7XG5cbiAgICAgICAgaWYgKCFyZXMgJiYgY2hlY2tCb3VuZHMpIHtcbiAgICAgICAgICB2YXIgcG9pbnRzID0gWydUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLCAnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDggJiYgIXJlczsgaSsrKSB7XG4gICAgICAgICAgICByZXMgPSBjaGVja1BvaW50KCdib3VuZHMnLCBwb2ludHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyA9IGZpbHRlcihyZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlcykge1xuICAgICAgICByZXMgPSB0aGlzLl9oaXRUZXN0Q2hpbGRyZW4ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpIHx8IGNoZWNrU2VsZiAmJiBmaWx0ZXIodGhpcy5faGl0VGVzdFNlbGYocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgsIHRoaXMuZ2V0U3Ryb2tlU2NhbGluZygpID8gbnVsbCA6IHZpZXdNYXRyaXguX3NoaWZ0bGVzcygpLmludmVydCgpKSkgfHwgbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcyAmJiByZXMucG9pbnQpIHtcbiAgICAgICAgcmVzLnBvaW50ID0gbWF0cml4LnRyYW5zZm9ybShyZXMucG9pbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgX2hpdFRlc3RTZWxmOiBmdW5jdGlvbiAocG9pbnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmZpbGwgJiYgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpKSByZXR1cm4gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpO1xuICAgIH0sXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gKG5hbWUsIGNvbXBhcmUpIHtcbiAgICAgIGZ1bmN0aW9uIG1hdGNoT2JqZWN0KG9iajEsIG9iajIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBvYmoxKSB7XG4gICAgICAgICAgaWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHZhciB2YWwxID0gb2JqMVtpXSxcbiAgICAgICAgICAgICAgICB2YWwyID0gb2JqMltpXTtcblxuICAgICAgICAgICAgaWYgKEJhc2UuaXNQbGFpbk9iamVjdCh2YWwxKSAmJiBCYXNlLmlzUGxhaW5PYmplY3QodmFsMikpIHtcbiAgICAgICAgICAgICAgaWYgKCFtYXRjaE9iamVjdCh2YWwxLCB2YWwyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsMSwgdmFsMikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBuYW1lO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF0aGlzLm1hdGNoZXMoa2V5LCBuYW1lW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmFtZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ21hdGNoJykge1xuICAgICAgICByZXR1cm4gY29tcGFyZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IC9eKGVtcHR5fGVkaXRhYmxlKSQvLnRlc3QobmFtZSkgPyB0aGlzWydpcycgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldKCkgOiBuYW1lID09PSAndHlwZScgPyBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcykgOiB0aGlzW25hbWVdO1xuXG4gICAgICAgIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGNvbXBhcmU7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9jbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiAhIWNvbXBhcmUodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmUpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZS50ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZS50ZXN0KHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChjb21wYXJlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoT2JqZWN0KGNvbXBhcmUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQmFzZS5lcXVhbHModmFsdWUsIGNvbXBhcmUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0SXRlbXM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcywgb3B0aW9ucywgdGhpcy5fbWF0cml4KTtcbiAgICB9LFxuICAgIGdldEl0ZW06IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcywgb3B0aW9ucywgdGhpcy5fbWF0cml4LCBudWxsLCB0cnVlKVswXSB8fCBudWxsO1xuICAgIH0sXG4gICAgc3RhdGljczoge1xuICAgICAgX2dldEl0ZW1zOiBmdW5jdGlvbiBfZ2V0SXRlbXMoaXRlbSwgb3B0aW9ucywgbWF0cml4LCBwYXJhbSwgZmlyc3RPbmx5KSB7XG4gICAgICAgIGlmICghcGFyYW0pIHtcbiAgICAgICAgICB2YXIgb2JqID0gdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMsXG4gICAgICAgICAgICAgIG92ZXJsYXBwaW5nID0gb2JqICYmIG9iai5vdmVybGFwcGluZyxcbiAgICAgICAgICAgICAgaW5zaWRlID0gb2JqICYmIG9iai5pbnNpZGUsXG4gICAgICAgICAgICAgIGJvdW5kcyA9IG92ZXJsYXBwaW5nIHx8IGluc2lkZSxcbiAgICAgICAgICAgICAgcmVjdCA9IGJvdW5kcyAmJiBSZWN0YW5nbGUucmVhZChbYm91bmRzXSk7XG4gICAgICAgICAgcGFyYW0gPSB7XG4gICAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgICByZWN1cnNpdmU6IG9iaiAmJiBvYmoucmVjdXJzaXZlICE9PSBmYWxzZSxcbiAgICAgICAgICAgIGluc2lkZTogISFpbnNpZGUsXG4gICAgICAgICAgICBvdmVybGFwcGluZzogISFvdmVybGFwcGluZyxcbiAgICAgICAgICAgIHJlY3Q6IHJlY3QsXG4gICAgICAgICAgICBwYXRoOiBvdmVybGFwcGluZyAmJiBuZXcgUGF0aC5SZWN0YW5nbGUoe1xuICAgICAgICAgICAgICByZWN0YW5nbGU6IHJlY3QsXG4gICAgICAgICAgICAgIGluc2VydDogZmFsc2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBCYXNlLmZpbHRlcih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgICAgICAgICAgIGluc2lkZTogdHJ1ZSxcbiAgICAgICAgICAgICAgb3ZlcmxhcHBpbmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGl0ZW0uX2NoaWxkcmVuLFxuICAgICAgICAgICAgaXRlbXMgPSBwYXJhbS5pdGVtcyxcbiAgICAgICAgICAgIHJlY3QgPSBwYXJhbS5yZWN0O1xuICAgICAgICBtYXRyaXggPSByZWN0ICYmIChtYXRyaXggfHwgbmV3IE1hdHJpeCgpKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgICBjaGlsZE1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguYXBwZW5kZWQoY2hpbGQuX21hdHJpeCksXG4gICAgICAgICAgICAgIGFkZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGNoaWxkLmdldEJvdW5kcyhjaGlsZE1hdHJpeCk7XG4gICAgICAgICAgICBpZiAoIXJlY3QuaW50ZXJzZWN0cyhib3VuZHMpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghKHJlY3QuY29udGFpbnMoYm91bmRzKSB8fCBwYXJhbS5vdmVybGFwcGluZyAmJiAoYm91bmRzLmNvbnRhaW5zKHJlY3QpIHx8IHBhcmFtLnBhdGguaW50ZXJzZWN0cyhjaGlsZCwgY2hpbGRNYXRyaXgpKSkpIGFkZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhZGQgJiYgY2hpbGQubWF0Y2hlcyhvcHRpb25zKSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RPbmx5KSBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyYW0ucmVjdXJzaXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgX2dldEl0ZW1zKGNoaWxkLCBvcHRpb25zLCBjaGlsZE1hdHJpeCwgcGFyYW0sIGZpcnN0T25seSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpcnN0T25seSAmJiBpdGVtcy5sZW5ndGggPiAwKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBpbXBvcnRKU09OOiBmdW5jdGlvbiAoanNvbikge1xuICAgICAgdmFyIHJlcyA9IEJhc2UuaW1wb3J0SlNPTihqc29uLCB0aGlzKTtcbiAgICAgIHJldHVybiByZXMgIT09IHRoaXMgPyB0aGlzLmFkZENoaWxkKHJlcykgOiByZXM7XG4gICAgfSxcbiAgICBhZGRDaGlsZDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydENoaWxkKHVuZGVmaW5lZCwgaXRlbSk7XG4gICAgfSxcbiAgICBpbnNlcnRDaGlsZDogZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG4gICAgICB2YXIgcmVzID0gaXRlbSA/IHRoaXMuaW5zZXJ0Q2hpbGRyZW4oaW5kZXgsIFtpdGVtXSkgOiBudWxsO1xuICAgICAgcmV0dXJuIHJlcyAmJiByZXNbMF07XG4gICAgfSxcbiAgICBhZGRDaGlsZHJlbjogZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnRDaGlsZHJlbih0aGlzLl9jaGlsZHJlbi5sZW5ndGgsIGl0ZW1zKTtcbiAgICB9LFxuICAgIGluc2VydENoaWxkcmVuOiBmdW5jdGlvbiAoaW5kZXgsIGl0ZW1zKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICYmIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaXRlbXMgPSBCYXNlLnNsaWNlKGl0ZW1zKTtcbiAgICAgICAgdmFyIGluc2VydGVkID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXSxcbiAgICAgICAgICAgICAgaWQgPSBpdGVtICYmIGl0ZW0uX2lkO1xuXG4gICAgICAgICAgaWYgKCFpdGVtIHx8IGluc2VydGVkW2lkXSkge1xuICAgICAgICAgICAgaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLl9yZW1vdmUoZmFsc2UsIHRydWUpO1xuXG4gICAgICAgICAgICBpbnNlcnRlZFtpZF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEJhc2Uuc3BsaWNlKGNoaWxkcmVuLCBpdGVtcywgaW5kZXgsIDApO1xuICAgICAgICB2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG4gICAgICAgICAgICBub3RpZnlTZWxmID0gcHJvamVjdC5fY2hhbmdlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV0sXG4gICAgICAgICAgICAgIG5hbWUgPSBpdGVtLl9uYW1lO1xuICAgICAgICAgIGl0ZW0uX3BhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgICBpdGVtLl9zZXRQcm9qZWN0KHByb2plY3QsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKG5hbWUpIGl0ZW0uc2V0TmFtZShuYW1lKTtcbiAgICAgICAgICBpZiAobm90aWZ5U2VsZikgaXRlbS5fY2hhbmdlZCg1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoMTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcbiAgICBfaW5zZXJ0SXRlbTogJyNpbnNlcnRDaGlsZCcsXG4gICAgX2luc2VydEF0OiBmdW5jdGlvbiAoaXRlbSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgb3duZXIgPSBpdGVtICYmIGl0ZW0uX2dldE93bmVyKCksXG4gICAgICAgICAgcmVzID0gaXRlbSAhPT0gdGhpcyAmJiBvd25lciA/IHRoaXMgOiBudWxsO1xuXG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHJlcy5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICBvd25lci5faW5zZXJ0SXRlbShpdGVtLl9pbmRleCArIG9mZnNldCwgcmVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGluc2VydEFib3ZlOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luc2VydEF0KGl0ZW0sIDEpO1xuICAgIH0sXG4gICAgaW5zZXJ0QmVsb3c6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5zZXJ0QXQoaXRlbSwgMCk7XG4gICAgfSxcbiAgICBzZW5kVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXG4gICAgICByZXR1cm4gb3duZXIgPyBvd25lci5faW5zZXJ0SXRlbSgwLCB0aGlzKSA6IG51bGw7XG4gICAgfSxcbiAgICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cbiAgICAgIHJldHVybiBvd25lciA/IG93bmVyLl9pbnNlcnRJdGVtKHVuZGVmaW5lZCwgdGhpcykgOiBudWxsO1xuICAgIH0sXG4gICAgYXBwZW5kVG9wOiAnI2FkZENoaWxkJyxcbiAgICBhcHBlbmRCb3R0b206IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnRDaGlsZCgwLCBpdGVtKTtcbiAgICB9LFxuICAgIG1vdmVBYm92ZTogJyNpbnNlcnRBYm92ZScsXG4gICAgbW92ZUJlbG93OiAnI2luc2VydEJlbG93JyxcbiAgICBhZGRUbzogZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgICByZXR1cm4gb3duZXIuX2luc2VydEl0ZW0odW5kZWZpbmVkLCB0aGlzKTtcbiAgICB9LFxuICAgIGNvcHlUbzogZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZShmYWxzZSkuYWRkVG8ob3duZXIpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bMF0ucmVkdWNlKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICBjaGlsZC5pbnNlcnRBYm92ZSh0aGlzKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIF9yZW1vdmVOYW1lZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblxuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG93bmVyLl9jaGlsZHJlbixcbiAgICAgICAgICAgIG5hbWVkQ2hpbGRyZW4gPSBvd25lci5fbmFtZWRDaGlsZHJlbixcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgICAgICAgbmFtZWRBcnJheSA9IG5hbWVkQ2hpbGRyZW5bbmFtZV0sXG4gICAgICAgICAgICBpbmRleCA9IG5hbWVkQXJyYXkgPyBuYW1lZEFycmF5LmluZGV4T2YodGhpcykgOiAtMTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuW25hbWVdID09IHRoaXMpIGRlbGV0ZSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICBuYW1lZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICBpZiAobmFtZWRBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuW25hbWVdID0gbmFtZWRBcnJheVswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG5hbWVkQ2hpbGRyZW5bbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfcmVtb3ZlOiBmdW5jdGlvbiAobm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpLFxuICAgICAgICAgIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuICAgICAgICAgIGluZGV4ID0gdGhpcy5faW5kZXg7XG5cbiAgICAgIGlmICh0aGlzLl9zdHlsZSkgdGhpcy5fc3R5bGUuX2Rpc3Bvc2UoKTtcblxuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9uYW1lKSB0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHByb2plY3QuX2FjdGl2ZUxheWVyID09PSB0aGlzKSBwcm9qZWN0Ll9hY3RpdmVMYXllciA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKSB8fCB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgICAgIEJhc2Uuc3BsaWNlKG93bmVyLl9jaGlsZHJlbiwgbnVsbCwgaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cbiAgICAgICAgaWYgKG5vdGlmeVNlbGYgJiYgcHJvamVjdC5fY2hhbmdlcykgdGhpcy5fY2hhbmdlZCg1KTtcbiAgICAgICAgaWYgKG5vdGlmeVBhcmVudCkgb3duZXIuX2NoYW5nZWQoMTEsIHRoaXMpO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKHRydWUsIHRydWUpO1xuICAgIH0sXG4gICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgb2sgPSBpdGVtICYmIGl0ZW0uaW5zZXJ0QmVsb3codGhpcyk7XG4gICAgICBpZiAob2spIHRoaXMucmVtb3ZlKCk7XG4gICAgICByZXR1cm4gb2s7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghdGhpcy5fY2hpbGRyZW4pIHJldHVybiBudWxsO1xuICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgZW5kID0gQmFzZS5waWNrKGVuZCwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgIHZhciByZW1vdmVkID0gQmFzZS5zcGxpY2UodGhpcy5fY2hpbGRyZW4sIG51bGwsIHN0YXJ0LCBlbmQgLSBzdGFydCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSByZW1vdmVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlbW92ZWRbaV0uX3JlbW92ZSh0cnVlLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1vdmVkLmxlbmd0aCA+IDApIHRoaXMuX2NoYW5nZWQoMTEpO1xuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcbiAgICBjbGVhcjogJyNyZW1vdmVDaGlsZHJlbicsXG4gICAgcmV2ZXJzZUNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4ucmV2ZXJzZSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB0aGlzLl9jaGlsZHJlbltpXS5faW5kZXggPSBpO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoMTEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKHJlY3Vyc2l2ZWx5KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgIHZhciBudW1DaGlsZHJlbiA9IGNoaWxkcmVuID8gY2hpbGRyZW4ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hpbGRyZW47IGkrKykge1xuICAgICAgICAgIGlmICghY2hpbGRyZW5baV0uaXNFbXB0eShyZWN1cnNpdmVseSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFudW1DaGlsZHJlbjtcbiAgICB9LFxuICAgIGlzRWRpdGFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpdGVtID0gdGhpcztcblxuICAgICAgd2hpbGUgKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtLl92aXNpYmxlIHx8IGl0ZW0uX2xvY2tlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpdGVtID0gaXRlbS5fcGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzRmlsbCgpO1xuICAgIH0sXG4gICAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1N0cm9rZSgpO1xuICAgIH0sXG4gICAgaGFzU2hhZG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1NoYWRvdygpO1xuICAgIH0sXG4gICAgX2dldE9yZGVyOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgZnVuY3Rpb24gZ2V0TGlzdChpdGVtKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGxpc3QudW5zaGlmdChpdGVtKTtcbiAgICAgICAgfSB3aGlsZSAoaXRlbSA9IGl0ZW0uX3BhcmVudCk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaXN0MSA9IGdldExpc3QodGhpcyksXG4gICAgICAgICAgbGlzdDIgPSBnZXRMaXN0KGl0ZW0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGxpc3QxLmxlbmd0aCwgbGlzdDIubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAobGlzdDFbaV0gIT0gbGlzdDJbaV0pIHtcbiAgICAgICAgICByZXR1cm4gbGlzdDFbaV0uX2luZGV4IDwgbGlzdDJbaV0uX2luZGV4ID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgaGFzQ2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPiAwO1xuICAgIH0sXG4gICAgaXNJbnNlcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pc0luc2VydGVkKCkgOiBmYWxzZTtcbiAgICB9LFxuICAgIGlzQWJvdmU6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IC0xO1xuICAgIH0sXG4gICAgaXNCZWxvdzogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRPcmRlcihpdGVtKSA9PT0gMTtcbiAgICB9LFxuICAgIGlzUGFyZW50OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA9PT0gaXRlbTtcbiAgICB9LFxuICAgIGlzQ2hpbGQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSAmJiBpdGVtLl9wYXJlbnQgPT09IHRoaXM7XG4gICAgfSxcbiAgICBpc0Rlc2NlbmRhbnQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IGl0ZW0pIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBpc0FuY2VzdG9yOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlzRGVzY2VuZGFudCh0aGlzKSA6IGZhbHNlO1xuICAgIH0sXG4gICAgaXNTaWJsaW5nOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA9PT0gaXRlbS5fcGFyZW50O1xuICAgIH0sXG4gICAgaXNHcm91cGVkV2l0aDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5fcGFyZW50ICYmIC9eKEdyb3VwfExheWVyfENvbXBvdW5kUGF0aCkkLy50ZXN0KHBhcmVudC5fY2xhc3MpICYmIGl0ZW0uaXNEZXNjZW5kYW50KHBhcmVudCkpIHJldHVybiB0cnVlO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgQmFzZS5lYWNoKFsncm90YXRlJywgJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByb3RhdGUgPSBrZXkgPT09ICdyb3RhdGUnO1xuXG4gICAgdGhpc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgdmFsdWUgPSAocm90YXRlID8gQmFzZSA6IFBvaW50KS5yZWFkKGFyZ3MpLFxuICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWQoYXJncywgMCwge1xuICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpW2tleV0odmFsdWUsIGNlbnRlciB8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG4gICAgfTtcbiAgfSwge1xuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG14ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG14LnRyYW5zbGF0ZS5hcHBseShteCwgYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXgsIF9hcHBseVJlY3Vyc2l2ZWx5LCBfc2V0QXBwbHlNYXRyaXgpIHtcbiAgICAgIHZhciBfbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IG1hdHJpeCAmJiAhbWF0cml4LmlzSWRlbnRpdHkoKSxcbiAgICAgICAgICBhcHBseU1hdHJpeCA9IF9zZXRBcHBseU1hdHJpeCAmJiB0aGlzLl9jYW5BcHBseU1hdHJpeCB8fCB0aGlzLl9hcHBseU1hdHJpeCAmJiAodHJhbnNmb3JtTWF0cml4IHx8ICFfbWF0cml4LmlzSWRlbnRpdHkoKSB8fCBfYXBwbHlSZWN1cnNpdmVseSAmJiB0aGlzLl9jaGlsZHJlbik7XG4gICAgICBpZiAoIXRyYW5zZm9ybU1hdHJpeCAmJiAhYXBwbHlNYXRyaXgpIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAodHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIGlmICghbWF0cml4LmlzSW52ZXJ0aWJsZSgpICYmIF9tYXRyaXguaXNJbnZlcnRpYmxlKCkpIF9tYXRyaXguX2JhY2t1cCA9IF9tYXRyaXguZ2V0VmFsdWVzKCk7XG5cbiAgICAgICAgX21hdHJpeC5wcmVwZW5kKG1hdHJpeCwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG4gICAgICAgICAgICBmaWxsQ29sb3IgPSBzdHlsZS5nZXRGaWxsQ29sb3IodHJ1ZSksXG4gICAgICAgICAgICBzdHJva2VDb2xvciA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKHRydWUpO1xuICAgICAgICBpZiAoZmlsbENvbG9yKSBmaWxsQ29sb3IudHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgICAgIGlmIChzdHJva2VDb2xvcikgc3Ryb2tlQ29sb3IudHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcHBseU1hdHJpeCAmJiAoYXBwbHlNYXRyaXggPSB0aGlzLl90cmFuc2Zvcm1Db250ZW50KF9tYXRyaXgsIF9hcHBseVJlY3Vyc2l2ZWx5LCBfc2V0QXBwbHlNYXRyaXgpKSkge1xuICAgICAgICB2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcbiAgICAgICAgaWYgKHBpdm90KSBfbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwaXZvdCwgcGl2b3QsIHRydWUpO1xuXG4gICAgICAgIF9tYXRyaXgucmVzZXQodHJ1ZSk7XG5cbiAgICAgICAgaWYgKF9zZXRBcHBseU1hdHJpeCAmJiB0aGlzLl9jYW5BcHBseU1hdHJpeCkgdGhpcy5fYXBwbHlNYXRyaXggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzLFxuICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG5cbiAgICAgIGlmICh0cmFuc2Zvcm1NYXRyaXggfHwgYXBwbHlNYXRyaXgpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgyNSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWNvbXAgPSB0cmFuc2Zvcm1NYXRyaXggJiYgYm91bmRzICYmIG1hdHJpeC5kZWNvbXBvc2UoKTtcblxuICAgICAgaWYgKGRlY29tcCAmJiBkZWNvbXAuc2tld2luZy5pc1plcm8oKSAmJiBkZWNvbXAucm90YXRpb24gJSA5MCA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYm91bmRzKSB7XG4gICAgICAgICAgdmFyIGNhY2hlID0gYm91bmRzW2tleV07XG5cbiAgICAgICAgICBpZiAoY2FjaGUubm9uc2NhbGluZykge1xuICAgICAgICAgICAgZGVsZXRlIGJvdW5kc1trZXldO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXBwbHlNYXRyaXggfHwgIWNhY2hlLmludGVybmFsKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGNhY2hlLnJlY3Q7XG5cbiAgICAgICAgICAgIG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QsIHJlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IGJvdW5kcztcblxuICAgICAgICB2YXIgY2FjaGVkID0gYm91bmRzW3RoaXMuX2dldEJvdW5kc0NhY2hlS2V5KHRoaXMuX2JvdW5kc09wdGlvbnMgfHwge30pXTtcblxuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbkZyb21Cb3VuZHMoY2FjaGVkLnJlY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybU1hdHJpeCAmJiBwb3NpdGlvbiAmJiB0aGlzLl9waXZvdCkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9zaXRpb24sIHBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24gKG1hdHJpeCwgYXBwbHlSZWN1cnNpdmVseSwgc2V0QXBwbHlNYXRyaXgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS50cmFuc2Zvcm0obWF0cml4LCBhcHBseVJlY3Vyc2l2ZWx5LCBzZXRBcHBseU1hdHJpeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgbG9jYWxUb0dsb2JhbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpLl90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgcGFyZW50VG9Mb2NhbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgbG9jYWxUb1BhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGZpdEJvdW5kczogZnVuY3Rpb24gKHJlY3RhbmdsZSwgZmlsbCkge1xuICAgICAgcmVjdGFuZ2xlID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuICAgICAgICAgIGl0ZW1SYXRpbyA9IGJvdW5kcy5oZWlnaHQgLyBib3VuZHMud2lkdGgsXG4gICAgICAgICAgcmVjdFJhdGlvID0gcmVjdGFuZ2xlLmhlaWdodCAvIHJlY3RhbmdsZS53aWR0aCxcbiAgICAgICAgICBzY2FsZSA9IChmaWxsID8gaXRlbVJhdGlvID4gcmVjdFJhdGlvIDogaXRlbVJhdGlvIDwgcmVjdFJhdGlvKSA/IHJlY3RhbmdsZS53aWR0aCAvIGJvdW5kcy53aWR0aCA6IHJlY3RhbmdsZS5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgIG5ld0JvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksIG5ldyBTaXplKGJvdW5kcy53aWR0aCAqIHNjYWxlLCBib3VuZHMuaGVpZ2h0ICogc2NhbGUpKTtcbiAgICAgIG5ld0JvdW5kcy5zZXRDZW50ZXIocmVjdGFuZ2xlLmdldENlbnRlcigpKTtcbiAgICAgIHRoaXMuc2V0Qm91bmRzKG5ld0JvdW5kcyk7XG4gICAgfVxuICB9KSwge1xuICAgIF9zZXRTdHlsZXM6IGZ1bmN0aW9uIChjdHgsIHBhcmFtLCB2aWV3TWF0cml4KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG5cbiAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmdldEZpbGxDb2xvcigpLnRvQ2FudmFzU3R5bGUoY3R4LCBtYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IoKS50b0NhbnZhc1N0eWxlKGN0eCwgbWF0cml4KTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCk7XG4gICAgICAgIHZhciBzdHJva2VKb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuICAgICAgICAgICAgc3Ryb2tlQ2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG4gICAgICAgICAgICBtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgICBpZiAoc3Ryb2tlSm9pbikgY3R4LmxpbmVKb2luID0gc3Ryb2tlSm9pbjtcbiAgICAgICAgaWYgKHN0cm9rZUNhcCkgY3R4LmxpbmVDYXAgPSBzdHJva2VDYXA7XG4gICAgICAgIGlmIChtaXRlckxpbWl0KSBjdHgubWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG5cbiAgICAgICAgaWYgKHBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCkge1xuICAgICAgICAgIHZhciBkYXNoQXJyYXkgPSBzdHlsZS5nZXREYXNoQXJyYXkoKSxcbiAgICAgICAgICAgICAgZGFzaE9mZnNldCA9IHN0eWxlLmdldERhc2hPZmZzZXQoKTtcblxuICAgICAgICAgIGlmIChkYXNoQXJyYXkgJiYgZGFzaEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCdzZXRMaW5lRGFzaCcgaW4gY3R4KSB7XG4gICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4Lm1vekRhc2ggPSBkYXNoQXJyYXk7XG4gICAgICAgICAgICAgIGN0eC5tb3pEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlLmhhc1NoYWRvdygpKSB7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gcGFyYW0ucGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICAgICAgbXggPSB2aWV3TWF0cml4Ll9zaGlmdGxlc3MoKS5wcmVwZW5kKG5ldyBNYXRyaXgoKS5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKSksXG4gICAgICAgICAgICBibHVyID0gbXgudHJhbnNmb3JtKG5ldyBQb2ludChzdHlsZS5nZXRTaGFkb3dCbHVyKCksIDApKSxcbiAgICAgICAgICAgIG9mZnNldCA9IG14LnRyYW5zZm9ybSh0aGlzLmdldFNoYWRvd09mZnNldCgpKTtcblxuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBzdHlsZS5nZXRTaGFkb3dDb2xvcigpLnRvQ2FudmFzU3R5bGUoY3R4KTtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBibHVyLmdldExlbmd0aCgpO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IG9mZnNldC54O1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IG9mZnNldC55O1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gKGN0eCwgcGFyYW0sIHBhcmVudFN0cm9rZU1hdHJpeCkge1xuICAgICAgdmFyIHVwZGF0ZVZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uID0gdGhpcy5fcHJvamVjdC5fdXBkYXRlVmVyc2lvbjtcbiAgICAgIGlmICghdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9vcGFjaXR5ID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgbWF0cmljZXMgPSBwYXJhbS5tYXRyaWNlcyxcbiAgICAgICAgICB2aWV3TWF0cml4ID0gcGFyYW0udmlld01hdHJpeCxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG4gICAgICAgICAgZ2xvYmFsTWF0cml4ID0gbWF0cmljZXNbbWF0cmljZXMubGVuZ3RoIC0gMV0uYXBwZW5kZWQobWF0cml4KTtcbiAgICAgIGlmICghZ2xvYmFsTWF0cml4LmlzSW52ZXJ0aWJsZSgpKSByZXR1cm47XG4gICAgICB2aWV3TWF0cml4ID0gdmlld01hdHJpeCA/IHZpZXdNYXRyaXguYXBwZW5kZWQoZ2xvYmFsTWF0cml4KSA6IGdsb2JhbE1hdHJpeDtcbiAgICAgIG1hdHJpY2VzLnB1c2goZ2xvYmFsTWF0cml4KTtcblxuICAgICAgaWYgKHBhcmFtLnVwZGF0ZU1hdHJpeCkge1xuICAgICAgICB0aGlzLl9nbG9iYWxNYXRyaXggPSBnbG9iYWxNYXRyaXg7XG4gICAgICB9XG5cbiAgICAgIHZhciBibGVuZE1vZGUgPSB0aGlzLl9ibGVuZE1vZGUsXG4gICAgICAgICAgb3BhY2l0eSA9IE51bWVyaWNhbC5jbGFtcCh0aGlzLl9vcGFjaXR5LCAwLCAxKSxcbiAgICAgICAgICBub3JtYWxCbGVuZCA9IGJsZW5kTW9kZSA9PT0gJ25vcm1hbCcsXG4gICAgICAgICAgbmF0aXZlQmxlbmQgPSBCbGVuZE1vZGUubmF0aXZlTW9kZXNbYmxlbmRNb2RlXSxcbiAgICAgICAgICBkaXJlY3QgPSBub3JtYWxCbGVuZCAmJiBvcGFjaXR5ID09PSAxIHx8IHBhcmFtLmRvbnRTdGFydCB8fCBwYXJhbS5jbGlwIHx8IChuYXRpdmVCbGVuZCB8fCBub3JtYWxCbGVuZCAmJiBvcGFjaXR5IDwgMSkgJiYgdGhpcy5fY2FuQ29tcG9zaXRlKCksXG4gICAgICAgICAgcGl4ZWxSYXRpbyA9IHBhcmFtLnBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgICBtYWluQ3R4LFxuICAgICAgICAgIGl0ZW1PZmZzZXQsXG4gICAgICAgICAgcHJldk9mZnNldDtcblxuICAgICAgaWYgKCFkaXJlY3QpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKHZpZXdNYXRyaXgpO1xuXG4gICAgICAgIGlmICghYm91bmRzLndpZHRoIHx8ICFib3VuZHMuaGVpZ2h0KSB7XG4gICAgICAgICAgbWF0cmljZXMucG9wKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldk9mZnNldCA9IHBhcmFtLm9mZnNldDtcbiAgICAgICAgaXRlbU9mZnNldCA9IHBhcmFtLm9mZnNldCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKTtcbiAgICAgICAgbWFpbkN0eCA9IGN0eDtcbiAgICAgICAgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChib3VuZHMuZ2V0U2l6ZSgpLmNlaWwoKS5hZGQoMSkubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSkgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIHN0cm9rZU1hdHJpeCA9IHBhcmVudFN0cm9rZU1hdHJpeCA/IHBhcmVudFN0cm9rZU1hdHJpeC5hcHBlbmRlZChtYXRyaXgpIDogdGhpcy5fY2FuU2NhbGVTdHJva2UgJiYgIXRoaXMuZ2V0U3Ryb2tlU2NhbGluZyh0cnVlKSAmJiB2aWV3TWF0cml4LFxuICAgICAgICAgIGNsaXAgPSAhZGlyZWN0ICYmIHBhcmFtLmNsaXBJdGVtLFxuICAgICAgICAgIHRyYW5zZm9ybSA9ICFzdHJva2VNYXRyaXggfHwgY2xpcDtcblxuICAgICAgaWYgKGRpcmVjdCkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgICBpZiAobmF0aXZlQmxlbmQpIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjdHgudHJhbnNsYXRlKC1pdGVtT2Zmc2V0LngsIC1pdGVtT2Zmc2V0LnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIChkaXJlY3QgPyBtYXRyaXggOiB2aWV3TWF0cml4KS5hcHBseVRvQ29udGV4dChjdHgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xpcCkge1xuICAgICAgICBwYXJhbS5jbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHtcbiAgICAgICAgICBjbGlwOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cm9rZU1hdHJpeCkge1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuICAgICAgICBpZiAob2Zmc2V0KSBjdHgudHJhbnNsYXRlKC1vZmZzZXQueCwgLW9mZnNldC55KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZHJhdyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgbWF0cmljZXMucG9wKCk7XG5cbiAgICAgIGlmIChwYXJhbS5jbGlwICYmICFwYXJhbS5kb250RmluaXNoKSB7XG4gICAgICAgIGN0eC5jbGlwKHRoaXMuZ2V0RmlsbFJ1bGUoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlyZWN0KSB7XG4gICAgICAgIEJsZW5kTW9kZS5wcm9jZXNzKGJsZW5kTW9kZSwgY3R4LCBtYWluQ3R4LCBvcGFjaXR5LCBpdGVtT2Zmc2V0LnN1YnRyYWN0KHByZXZPZmZzZXQpLm11bHRpcGx5KHBpeGVsUmF0aW8pKTtcbiAgICAgICAgQ2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuICAgICAgICBwYXJhbS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xuICAgICAgfVxuICAgIH0sXG4gICAgX2lzVXBkYXRlZDogZnVuY3Rpb24gKHVwZGF0ZVZlcnNpb24pIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSByZXR1cm4gcGFyZW50Ll9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbik7XG4gICAgICB2YXIgdXBkYXRlZCA9IHRoaXMuX3VwZGF0ZVZlcnNpb24gPT09IHVwZGF0ZVZlcnNpb247XG5cbiAgICAgIGlmICghdXBkYXRlZCAmJiBwYXJlbnQgJiYgcGFyZW50Ll92aXNpYmxlICYmIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSxcbiAgICBfZHJhd1NlbGVjdGlvbjogZnVuY3Rpb24gKGN0eCwgbWF0cml4LCBzaXplLCBzZWxlY3Rpb25JdGVtcywgdXBkYXRlVmVyc2lvbikge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbixcbiAgICAgICAgICBpdGVtU2VsZWN0ZWQgPSBzZWxlY3Rpb24gJiAxLFxuICAgICAgICAgIGJvdW5kc1NlbGVjdGVkID0gc2VsZWN0aW9uICYgMiB8fCBpdGVtU2VsZWN0ZWQgJiYgdGhpcy5fc2VsZWN0Qm91bmRzLFxuICAgICAgICAgIHBvc2l0aW9uU2VsZWN0ZWQgPSBzZWxlY3Rpb24gJiA0O1xuICAgICAgaWYgKCF0aGlzLl9kcmF3U2VsZWN0ZWQpIGl0ZW1TZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoKGl0ZW1TZWxlY3RlZCB8fCBib3VuZHNTZWxlY3RlZCB8fCBwb3NpdGlvblNlbGVjdGVkKSAmJiB0aGlzLl9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgdmFyIGxheWVyLFxuICAgICAgICAgICAgY29sb3IgPSB0aGlzLmdldFNlbGVjdGVkQ29sb3IodHJ1ZSkgfHwgKGxheWVyID0gdGhpcy5nZXRMYXllcigpKSAmJiBsYXllci5nZXRTZWxlY3RlZENvbG9yKHRydWUpLFxuICAgICAgICAgICAgbXggPSBtYXRyaXguYXBwZW5kZWQodGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkpLFxuICAgICAgICAgICAgaGFsZiA9IHNpemUgLyAyO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gY29sb3IgPyBjb2xvci50b0NhbnZhc1N0eWxlKGN0eCkgOiAnIzAwOWRlYyc7XG4gICAgICAgIGlmIChpdGVtU2VsZWN0ZWQpIHRoaXMuX2RyYXdTZWxlY3RlZChjdHgsIG14LCBzZWxlY3Rpb25JdGVtcyk7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uU2VsZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKSxcbiAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5fcGFyZW50LFxuICAgICAgICAgICAgICBwb2ludCA9IHBhcmVudCA/IHBhcmVudC5sb2NhbFRvR2xvYmFsKHBvcykgOiBwb3MsXG4gICAgICAgICAgICAgIHggPSBwb2ludC54LFxuICAgICAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4LmFyYyh4LCB5LCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIHZhciBkZWx0YXMgPSBbWzAsIC0xXSwgWzEsIDBdLCBbMCwgMV0sIFstMSwgMF1dLFxuICAgICAgICAgICAgICBzdGFydCA9IGhhbGYsXG4gICAgICAgICAgICAgIGVuZCA9IHNpemUgKyAxO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGRlbHRhc1tpXSxcbiAgICAgICAgICAgICAgICBkeCA9IGRlbHRhWzBdLFxuICAgICAgICAgICAgICAgIGR5ID0gZGVsdGFbMV07XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBkeCAqIHN0YXJ0LCB5ICsgZHkgKiBzdGFydCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBkeCAqIGVuZCwgeSArIGR5ICogZW5kKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm91bmRzU2VsZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgY29vcmRzID0gbXguX3RyYW5zZm9ybUNvcm5lcnModGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBjdHhbIWkgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShjb29yZHNbaV0sIGNvb3Jkc1srK2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChjb29yZHNbaV0gLSBoYWxmLCBjb29yZHNbKytpXSAtIGhhbGYsIHNpemUsIHNpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgQmFzZS5lYWNoKFsnZG93bicsICdkcmFnJywgJ3VwJywgJ21vdmUnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHRoaXNbJ3JlbW92ZU9uJyArIEJhc2UuY2FwaXRhbGl6ZShrZXkpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoYXNoID0ge307XG4gICAgICBoYXNoW2tleV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlT24oaGFzaCk7XG4gICAgfTtcbiAgfSwge1xuICAgIHJlbW92ZU9uOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG9iaikge1xuICAgICAgICBpZiAob2JqW25hbWVdKSB7XG4gICAgICAgICAgdmFyIGtleSA9ICdtb3VzZScgKyBuYW1lLFxuICAgICAgICAgICAgICBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcbiAgICAgICAgICAgICAgc2V0cyA9IHByb2plY3QuX3JlbW92ZVNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzIHx8IHt9O1xuICAgICAgICAgIHNldHNba2V5XSA9IHNldHNba2V5XSB8fCB7fTtcbiAgICAgICAgICBzZXRzW2tleV1bdGhpcy5faWRdID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pLCB7XG4gICAgdHdlZW46IGZ1bmN0aW9uIChmcm9tLCB0bywgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0bztcbiAgICAgICAgdG8gPSBmcm9tO1xuICAgICAgICBmcm9tID0gbnVsbDtcblxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICBvcHRpb25zID0gdG87XG4gICAgICAgICAgdG8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlYXNpbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuZWFzaW5nLFxuICAgICAgICAgIHN0YXJ0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnN0YXJ0LFxuICAgICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucyAhPSBudWxsICYmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgPyBvcHRpb25zIDogb3B0aW9ucy5kdXJhdGlvbiksXG4gICAgICAgICAgdHdlZW4gPSBuZXcgVHdlZW4odGhpcywgZnJvbSwgdG8sIGR1cmF0aW9uLCBlYXNpbmcsIHN0YXJ0KTtcblxuICAgICAgZnVuY3Rpb24gb25GcmFtZShldmVudCkge1xuICAgICAgICB0d2Vlbi5faGFuZGxlRnJhbWUoZXZlbnQudGltZSAqIDEwMDApO1xuXG4gICAgICAgIGlmICghdHdlZW4ucnVubmluZykge1xuICAgICAgICAgIHRoaXMub2ZmKCdmcmFtZScsIG9uRnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICB0aGlzLm9uKCdmcmFtZScsIG9uRnJhbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHdlZW47XG4gICAgfSxcbiAgICB0d2VlblRvOiBmdW5jdGlvbiAodG8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnR3ZWVuKG51bGwsIHRvLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIHR3ZWVuRnJvbTogZnVuY3Rpb24gKGZyb20sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnR3ZWVuKGZyb20sIG51bGwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBHcm91cCA9IEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdHcm91cCcsXG4gICAgX3NlbGVjdEJvdW5kczogZmFsc2UsXG4gICAgX3NlbGVjdENoaWxkcmVuOiB0cnVlLFxuICAgIF9zZXJpYWxpemVGaWVsZHM6IHtcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JvdXAoYXJnKSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpIHRoaXMuYWRkQ2hpbGRyZW4oQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuICAgICAgX2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblxuICAgICAgaWYgKGZsYWdzICYgMjA1MCkge1xuICAgICAgICB0aGlzLl9jbGlwSXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRDbGlwSXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNsaXBJdGVtID0gdGhpcy5fY2xpcEl0ZW07XG5cbiAgICAgIGlmIChjbGlwSXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsaXBJdGVtID0gbnVsbDtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5baV0uX2NsaXBNYXNrKSB7XG4gICAgICAgICAgICBjbGlwSXRlbSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2xpcEl0ZW0gPSBjbGlwSXRlbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsaXBJdGVtO1xuICAgIH0sXG4gICAgaXNDbGlwcGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9nZXRDbGlwSXRlbSgpO1xuICAgIH0sXG4gICAgc2V0Q2xpcHBlZDogZnVuY3Rpb24gKGNsaXBwZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKGNoaWxkKSBjaGlsZC5zZXRDbGlwTWFzayhjbGlwcGVkKTtcbiAgICB9LFxuICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uIF9nZXRCb3VuZHMobWF0cml4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2xpcEl0ZW0gPSB0aGlzLl9nZXRDbGlwSXRlbSgpO1xuXG4gICAgICByZXR1cm4gY2xpcEl0ZW0gPyBjbGlwSXRlbS5fZ2V0Q2FjaGVkQm91bmRzKGNsaXBJdGVtLl9tYXRyaXgucHJlcGVuZGVkKG1hdHJpeCksIEJhc2Uuc2V0KHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHN0cm9rZTogZmFsc2VcbiAgICAgIH0pKSA6IF9nZXRCb3VuZHMuYmFzZS5jYWxsKHRoaXMsIG1hdHJpeCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBfaGl0VGVzdENoaWxkcmVuOiBmdW5jdGlvbiBfaGl0VGVzdENoaWxkcmVuKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4KSB7XG4gICAgICB2YXIgY2xpcEl0ZW0gPSB0aGlzLl9nZXRDbGlwSXRlbSgpO1xuXG4gICAgICByZXR1cm4gKCFjbGlwSXRlbSB8fCBjbGlwSXRlbS5jb250YWlucyhwb2ludCkpICYmIF9oaXRUZXN0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LCBjbGlwSXRlbSk7XG4gICAgfSxcbiAgICBfZHJhdzogZnVuY3Rpb24gKGN0eCwgcGFyYW0pIHtcbiAgICAgIHZhciBjbGlwID0gcGFyYW0uY2xpcCxcbiAgICAgICAgICBjbGlwSXRlbSA9ICFjbGlwICYmIHRoaXMuX2dldENsaXBJdGVtKCk7XG5cbiAgICAgIHBhcmFtID0gcGFyYW0uZXh0ZW5kKHtcbiAgICAgICAgY2xpcEl0ZW06IGNsaXBJdGVtLFxuICAgICAgICBjbGlwOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgcGFyYW0uZG9udFN0YXJ0ID0gcGFyYW0uZG9udEZpbmlzaCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNsaXBJdGVtKSB7XG4gICAgICAgIGNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoe1xuICAgICAgICAgIGNsaXA6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGl0ZW0gIT09IGNsaXBJdGVtKSBpdGVtLmRyYXcoY3R4LCBwYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIExheWVyID0gR3JvdXAuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdMYXllcicsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gTGF5ZXIoKSB7XG4gICAgICBHcm91cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgX2dldE93bmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuX2luZGV4ICE9IG51bGwgJiYgdGhpcy5fcHJvamVjdDtcbiAgICB9LFxuICAgIGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uIGlzSW5zZXJ0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gaXNJbnNlcnRlZC5iYXNlLmNhbGwodGhpcykgOiB0aGlzLl9pbmRleCAhPSBudWxsO1xuICAgIH0sXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3Byb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcztcbiAgICB9LFxuICAgIF9oaXRUZXN0U2VsZjogZnVuY3Rpb24gKCkge31cbiAgfSk7XG4gIHZhciBTaGFwZSA9IEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdTaGFwZScsXG4gICAgX2FwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuICAgIF9jYW5TY2FsZVN0cm9rZTogdHJ1ZSxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgc2l6ZTogbnVsbCxcbiAgICAgIHJhZGl1czogbnVsbFxuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gU2hhcGUocHJvcHMsIHBvaW50KSB7XG4gICAgICB0aGlzLl9pbml0aWFsaXplKHByb3BzLCBwb2ludCk7XG4gICAgfSxcbiAgICBfZXF1YWxzOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3R5cGUgPT09IGl0ZW0uX3R5cGUgJiYgdGhpcy5fc2l6ZS5lcXVhbHMoaXRlbS5fc2l6ZSkgJiYgQmFzZS5lcXVhbHModGhpcy5fcmFkaXVzLCBpdGVtLl9yYWRpdXMpO1xuICAgIH0sXG4gICAgY29weUNvbnRlbnQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc2V0VHlwZShzb3VyY2UuX3R5cGUpO1xuICAgICAgdGhpcy5zZXRTaXplKHNvdXJjZS5fc2l6ZSk7XG4gICAgICB0aGlzLnNldFJhZGl1cyhzb3VyY2UuX3JhZGl1cyk7XG4gICAgfSxcbiAgICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9LFxuICAgIHNldFR5cGU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICB9LFxuICAgIGdldFNoYXBlOiAnI2dldFR5cGUnLFxuICAgIHNldFNoYXBlOiAnI3NldFR5cGUnLFxuICAgIGdldFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICAgIHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcbiAgICB9LFxuICAgIHNldFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICghdGhpcy5fc2l6ZSkge1xuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fc2l6ZS5lcXVhbHMoc2l6ZSkpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuICAgICAgICAgICAgd2lkdGggPSBzaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG4gICAgICAgICAgdGhpcy5fcmFkaXVzLnNldChTaXplLm1pbih0aGlzLl9yYWRpdXMsIHNpemUuZGl2aWRlKDIpLmFicygpKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICB3aWR0aCA9IGhlaWdodCA9ICh3aWR0aCArIGhlaWdodCkgLyAyO1xuICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHdpZHRoIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcbiAgICAgICAgICB0aGlzLl9yYWRpdXMuX3NldCh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2l6ZS5fc2V0KHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoOSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByYWQgPSB0aGlzLl9yYWRpdXM7XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZSA9PT0gJ2NpcmNsZScgPyByYWQgOiBuZXcgTGlua2VkU2l6ZShyYWQud2lkdGgsIHJhZC5oZWlnaHQsIHRoaXMsICdzZXRSYWRpdXMnKTtcbiAgICB9LFxuICAgIHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgaWYgKHJhZGl1cyA9PT0gdGhpcy5fcmFkaXVzKSByZXR1cm47XG4gICAgICAgIHZhciBzaXplID0gcmFkaXVzICogMjtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXG4gICAgICAgIHRoaXMuX3NpemUuX3NldChzaXplLCBzaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhZGl1cyA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmFkaXVzKSB7XG4gICAgICAgICAgdGhpcy5fcmFkaXVzID0gcmFkaXVzLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JhZGl1cy5lcXVhbHMocmFkaXVzKSkgcmV0dXJuO1xuXG4gICAgICAgICAgdGhpcy5fcmFkaXVzLnNldChyYWRpdXMpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IFNpemUubWF4KHRoaXMuX3NpemUsIHJhZGl1cy5tdWx0aXBseSgyKSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3NpemUuc2V0KHNpemUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG4gICAgICAgICAgICB0aGlzLl9zaXplLl9zZXQocmFkaXVzLndpZHRoICogMiwgcmFkaXVzLmhlaWdodCAqIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGFuZ2VkKDkpO1xuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgdG9QYXRoOiBmdW5jdGlvbiAoaW5zZXJ0KSB7XG4gICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoW0Jhc2UuY2FwaXRhbGl6ZSh0aGlzLl90eXBlKV0oe1xuICAgICAgICBjZW50ZXI6IG5ldyBQb2ludCgpLFxuICAgICAgICBzaXplOiB0aGlzLl9zaXplLFxuICAgICAgICByYWRpdXM6IHRoaXMuX3JhZGl1cyxcbiAgICAgICAgaW5zZXJ0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBwYXRoLmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuICAgICAgaWYgKHBhcGVyLnNldHRpbmdzLmFwcGx5TWF0cml4KSBwYXRoLnNldEFwcGx5TWF0cml4KHRydWUpO1xuICAgICAgaWYgKGluc2VydCA9PT0gdW5kZWZpbmVkIHx8IGluc2VydCkgcGF0aC5pbnNlcnRBYm92ZSh0aGlzKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG4gICAgdG9TaGFwZTogJyNjbG9uZScsXG4gICAgX2FzUGF0aEl0ZW06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvUGF0aChmYWxzZSk7XG4gICAgfSxcbiAgICBfZHJhdzogZnVuY3Rpb24gKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG4gICAgICAgICAgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcbiAgICAgICAgICBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcbiAgICAgICAgICBkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG4gICAgICAgICAgdW50cmFuc2Zvcm1lZCA9ICFzdHJva2VNYXRyaXg7XG5cbiAgICAgIGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSB8fCBkb250UGFpbnQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuICAgICAgICAgICAgcmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuICAgICAgICAgICAgaXNDaXJjbGUgPSB0eXBlID09PSAnY2lyY2xlJztcbiAgICAgICAgaWYgKCFwYXJhbS5kb250U3RhcnQpIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBpZiAodW50cmFuc2Zvcm1lZCAmJiBpc0NpcmNsZSkge1xuICAgICAgICAgIGN0eC5hcmMoMCwgMCwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJ4ID0gaXNDaXJjbGUgPyByYWRpdXMgOiByYWRpdXMud2lkdGgsXG4gICAgICAgICAgICAgIHJ5ID0gaXNDaXJjbGUgPyByYWRpdXMgOiByYWRpdXMuaGVpZ2h0LFxuICAgICAgICAgICAgICBzaXplID0gdGhpcy5fc2l6ZSxcbiAgICAgICAgICAgICAgd2lkdGggPSBzaXplLndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQgPSBzaXplLmhlaWdodDtcblxuICAgICAgICAgIGlmICh1bnRyYW5zZm9ybWVkICYmIHR5cGUgPT09ICdyZWN0YW5nbGUnICYmIHJ4ID09PSAwICYmIHJ5ID09PSAwKSB7XG4gICAgICAgICAgICBjdHgucmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB4ID0gd2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIHkgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgICAgIGthcHBhID0gMSAtIDAuNTUyMjg0NzQ5ODMwNzkzNixcbiAgICAgICAgICAgICAgICBjeCA9IHJ4ICoga2FwcGEsXG4gICAgICAgICAgICAgICAgY3kgPSByeSAqIGthcHBhLFxuICAgICAgICAgICAgICAgIGMgPSBbLXgsIC15ICsgcnksIC14LCAteSArIGN5LCAteCArIGN4LCAteSwgLXggKyByeCwgLXksIHggLSByeCwgLXksIHggLSBjeCwgLXksIHgsIC15ICsgY3ksIHgsIC15ICsgcnksIHgsIHkgLSByeSwgeCwgeSAtIGN5LCB4IC0gY3gsIHksIHggLSByeCwgeSwgLXggKyByeCwgeSwgLXggKyBjeCwgeSwgLXgsIHkgLSBjeSwgLXgsIHkgLSByeV07XG4gICAgICAgICAgICBpZiAoc3Ryb2tlTWF0cml4KSBzdHJva2VNYXRyaXgudHJhbnNmb3JtKGMsIGMsIDMyKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY1swXSwgY1sxXSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjWzJdLCBjWzNdLCBjWzRdLCBjWzVdLCBjWzZdLCBjWzddKTtcbiAgICAgICAgICAgIGlmICh4ICE9PSByeCkgY3R4LmxpbmVUbyhjWzhdLCBjWzldKTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNbMTBdLCBjWzExXSwgY1sxMl0sIGNbMTNdLCBjWzE0XSwgY1sxNV0pO1xuICAgICAgICAgICAgaWYgKHkgIT09IHJ5KSBjdHgubGluZVRvKGNbMTZdLCBjWzE3XSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjWzE4XSwgY1sxOV0sIGNbMjBdLCBjWzIxXSwgY1syMl0sIGNbMjNdKTtcbiAgICAgICAgICAgIGlmICh4ICE9PSByeCkgY3R4LmxpbmVUbyhjWzI0XSwgY1syNV0pO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY1syNl0sIGNbMjddLCBjWzI4XSwgY1syOV0sIGNbMzBdLCBjWzMxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblxuICAgICAgICBpZiAoaGFzRmlsbCkge1xuICAgICAgICAgIGN0eC5maWxsKHN0eWxlLmdldEZpbGxSdWxlKCkpO1xuICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTdHJva2UpIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkpO1xuICAgIH0sXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24gKG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcbiAgICAgICAgICBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKCkgJiYgc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKTtcbiAgICAgIGlmIChtYXRyaXgpIHJlY3QgPSBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KTtcbiAgICAgIHJldHVybiBzdHJva2VXaWR0aCA/IHJlY3QuZXhwYW5kKFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlV2lkdGgsIHRoaXMuX2dldFN0cm9rZU1hdHJpeChtYXRyaXgsIG9wdGlvbnMpKSkgOiByZWN0O1xuICAgIH1cbiAgfSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDb3JuZXJDZW50ZXIodGhhdCwgcG9pbnQsIGV4cGFuZCkge1xuICAgICAgdmFyIHJhZGl1cyA9IHRoYXQuX3JhZGl1cztcblxuICAgICAgaWYgKCFyYWRpdXMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIGhhbGZTaXplID0gdGhhdC5fc2l6ZS5kaXZpZGUoMik7XG5cbiAgICAgICAgZm9yICh2YXIgcSA9IDE7IHEgPD0gNDsgcSsrKSB7XG4gICAgICAgICAgdmFyIGRpciA9IG5ldyBQb2ludChxID4gMSAmJiBxIDwgNCA/IC0xIDogMSwgcSA+IDIgPyAtMSA6IDEpLFxuICAgICAgICAgICAgICBjb3JuZXIgPSBkaXIubXVsdGlwbHkoaGFsZlNpemUpLFxuICAgICAgICAgICAgICBjZW50ZXIgPSBjb3JuZXIuc3VidHJhY3QoZGlyLm11bHRpcGx5KHJhZGl1cykpLFxuICAgICAgICAgICAgICByZWN0ID0gbmV3IFJlY3RhbmdsZShleHBhbmQgPyBjb3JuZXIuYWRkKGRpci5tdWx0aXBseShleHBhbmQpKSA6IGNvcm5lciwgY2VudGVyKTtcbiAgICAgICAgICBpZiAocmVjdC5jb250YWlucyhwb2ludCkpIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogY2VudGVyLFxuICAgICAgICAgICAgcXVhZHJhbnQ6IHFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPbkVsbGlwc2VTdHJva2UocG9pbnQsIHJhZGl1cywgcGFkZGluZywgcXVhZHJhbnQpIHtcbiAgICAgIHZhciB2ZWN0b3IgPSBwb2ludC5kaXZpZGUocmFkaXVzKTtcbiAgICAgIHJldHVybiAoIXF1YWRyYW50IHx8IHZlY3Rvci5pc0luUXVhZHJhbnQocXVhZHJhbnQpKSAmJiB2ZWN0b3Iuc3VidHJhY3QodmVjdG9yLm5vcm1hbGl6ZSgpKS5tdWx0aXBseShyYWRpdXMpLmRpdmlkZShwYWRkaW5nKS5sZW5ndGggPD0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgX2NvbnRhaW5zOiBmdW5jdGlvbiBfY29udGFpbnMocG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG4gICAgICAgICAgdmFyIGNlbnRlciA9IGdldENvcm5lckNlbnRlcih0aGlzLCBwb2ludCk7XG4gICAgICAgICAgcmV0dXJuIGNlbnRlciA/IHBvaW50LnN1YnRyYWN0KGNlbnRlci5wb2ludCkuZGl2aWRlKHRoaXMuX3JhZGl1cykuZ2V0TGVuZ3RoKCkgPD0gMSA6IF9jb250YWlucy5iYXNlLmNhbGwodGhpcywgcG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwb2ludC5kaXZpZGUodGhpcy5zaXplKS5nZXRMZW5ndGgoKSA8PSAwLjU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uIF9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG4gICAgICAgIHZhciBoaXQgPSBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlID0gdGhpcy5fc3R5bGUsXG4gICAgICAgICAgICBoaXRTdHJva2UgPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSxcbiAgICAgICAgICAgIGhpdEZpbGwgPSBvcHRpb25zLmZpbGwgJiYgc3R5bGUuaGFzRmlsbCgpO1xuXG4gICAgICAgIGlmIChoaXRTdHJva2UgfHwgaGl0RmlsbCkge1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZSxcbiAgICAgICAgICAgICAgcmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuICAgICAgICAgICAgICBzdHJva2VSYWRpdXMgPSBoaXRTdHJva2UgPyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMiA6IDAsXG4gICAgICAgICAgICAgIHN0cm9rZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nLmFkZChQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVJhZGl1cywgIXN0eWxlLmdldFN0cm9rZVNjYWxpbmcoKSAmJiBzdHJva2VNYXRyaXgpKTtcblxuICAgICAgICAgIGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBzdHJva2VQYWRkaW5nLm11bHRpcGx5KDIpLFxuICAgICAgICAgICAgICAgIGNlbnRlciA9IGdldENvcm5lckNlbnRlcih0aGlzLCBwb2ludCwgcGFkZGluZyk7XG5cbiAgICAgICAgICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgICAgICAgaGl0ID0gaXNPbkVsbGlwc2VTdHJva2UocG9pbnQuc3VidHJhY3QoY2VudGVyLnBvaW50KSwgcmFkaXVzLCBzdHJva2VQYWRkaW5nLCBjZW50ZXIucXVhZHJhbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcbiAgICAgICAgICAgICAgICAgIG91dGVyID0gcmVjdC5leHBhbmQocGFkZGluZyksXG4gICAgICAgICAgICAgICAgICBpbm5lciA9IHJlY3QuZXhwYW5kKHBhZGRpbmcubmVnYXRlKCkpO1xuICAgICAgICAgICAgICBoaXQgPSBvdXRlci5fY29udGFpbnNQb2ludChwb2ludCkgJiYgIWlubmVyLl9jb250YWluc1BvaW50KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGl0ID0gaXNPbkVsbGlwc2VTdHJva2UocG9pbnQsIHJhZGl1cywgc3Ryb2tlUGFkZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhpdCA/IG5ldyBIaXRSZXN1bHQoaGl0U3Ryb2tlID8gJ3N0cm9rZScgOiAnZmlsbCcsIHRoaXMpIDogX2hpdFRlc3RTZWxmLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCksIHtcbiAgICBzdGF0aWNzOiBuZXcgZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gY3JlYXRlU2hhcGUodHlwZSwgcG9pbnQsIHNpemUsIHJhZGl1cywgYXJncykge1xuICAgICAgICB2YXIgaXRlbSA9IEJhc2UuY3JlYXRlKFNoYXBlLnByb3RvdHlwZSk7XG4gICAgICAgIGl0ZW0uX3R5cGUgPSB0eXBlO1xuICAgICAgICBpdGVtLl9zaXplID0gc2l6ZTtcbiAgICAgICAgaXRlbS5fcmFkaXVzID0gcmFkaXVzO1xuXG4gICAgICAgIGl0ZW0uX2luaXRpYWxpemUoQmFzZS5nZXROYW1lZChhcmdzKSwgcG9pbnQpO1xuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBDaXJjbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdjZW50ZXInKSxcbiAgICAgICAgICAgICAgcmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVTaGFwZSgnY2lyY2xlJywgY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMgKiAyKSwgcmFkaXVzLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgUmVjdGFuZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3MsICdyZWN0YW5nbGUnKSxcbiAgICAgICAgICAgICAgcmFkaXVzID0gU2l6ZS5taW4oU2l6ZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycpLCByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlU2hhcGUoJ3JlY3RhbmdsZScsIHJlY3QuZ2V0Q2VudGVyKHRydWUpLCByZWN0LmdldFNpemUodHJ1ZSksIHJhZGl1cywgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIEVsbGlwc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmdzKSxcbiAgICAgICAgICAgICAgcmFkaXVzID0gZWxsaXBzZS5yYWRpdXM7XG5cbiAgICAgICAgICByZXR1cm4gY3JlYXRlU2hhcGUoJ2VsbGlwc2UnLCBlbGxpcHNlLmNlbnRlciwgcmFkaXVzLm11bHRpcGx5KDIpLCByYWRpdXMsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBfcmVhZEVsbGlwc2U6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgdmFyIGNlbnRlciwgcmFkaXVzO1xuXG4gICAgICAgICAgaWYgKEJhc2UuaGFzTmFtZWQoYXJncywgJ3JhZGl1cycpKSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpO1xuICAgICAgICAgICAgcmFkaXVzID0gU2l6ZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJncywgJ3JlY3RhbmdsZScpO1xuICAgICAgICAgICAgY2VudGVyID0gcmVjdC5nZXRDZW50ZXIodHJ1ZSk7XG4gICAgICAgICAgICByYWRpdXMgPSByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgICAgIHJhZGl1czogcmFkaXVzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KClcbiAgfSk7XG4gIHZhciBSYXN0ZXIgPSBJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUmFzdGVyJyxcbiAgICBfYXBwbHlNYXRyaXg6IGZhbHNlLFxuICAgIF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX2JvdW5kc09wdGlvbnM6IHtcbiAgICAgIHN0cm9rZTogZmFsc2UsXG4gICAgICBoYW5kbGU6IGZhbHNlXG4gICAgfSxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICBjcm9zc09yaWdpbjogbnVsbCxcbiAgICAgIHNvdXJjZTogbnVsbFxuICAgIH0sXG4gICAgX3ByaW9yaXRpemU6IFsnY3Jvc3NPcmlnaW4nXSxcbiAgICBfc21vb3RoaW5nOiB0cnVlLFxuICAgIGJlYW5zOiB0cnVlLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFJhc3Rlcihzb3VyY2UsIHBvc2l0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemUoc291cmNlLCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzKSkpIHtcbiAgICAgICAgdmFyIGltYWdlLFxuICAgICAgICAgICAgdHlwZSA9IHR5cGVvZiBzb3VyY2UsXG4gICAgICAgICAgICBvYmplY3QgPSB0eXBlID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNvdXJjZSkgOiB0eXBlID09PSAnb2JqZWN0JyA/IHNvdXJjZSA6IG51bGw7XG5cbiAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3QgIT09IEl0ZW0uTk9fSU5TRVJUKSB7XG4gICAgICAgICAgaWYgKG9iamVjdC5nZXRDb250ZXh0IHx8IG9iamVjdC5uYXR1cmFsSGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGltYWdlID0gb2JqZWN0O1xuICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAoIXNpemUuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgaW1hZ2UgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgdGhpcy5zZXRJbWFnZShpbWFnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX3NpemUpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG5ldyBTaXplKCk7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2VxdWFsczogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNvdXJjZSgpID09PSBpdGVtLmdldFNvdXJjZSgpO1xuICAgIH0sXG4gICAgY29weUNvbnRlbnQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHZhciBpbWFnZSA9IHNvdXJjZS5faW1hZ2UsXG4gICAgICAgICAgY2FudmFzID0gc291cmNlLl9jYW52YXM7XG5cbiAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICB0aGlzLl9zZXRJbWFnZShpbWFnZSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbnZhcykge1xuICAgICAgICB2YXIgY29weUNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzb3VyY2UuX3NpemUpO1xuICAgICAgICBjb3B5Q2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG5cbiAgICAgICAgdGhpcy5fc2V0SW1hZ2UoY29weUNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Nyb3NzT3JpZ2luID0gc291cmNlLl9jcm9zc09yaWdpbjtcbiAgICB9LFxuICAgIGdldFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICAgIHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplID8gc2l6ZS53aWR0aCA6IDAsIHNpemUgPyBzaXplLmhlaWdodCA6IDAsIHRoaXMsICdzZXRTaXplJyk7XG4gICAgfSxcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXG4gICAgICBpZiAoIXNpemUuZXF1YWxzKHRoaXMuX3NpemUpKSB7XG4gICAgICAgIGlmIChzaXplLndpZHRoID4gMCAmJiBzaXplLmhlaWdodCA+IDApIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXG4gICAgICAgICAgdGhpcy5fc2V0SW1hZ2UoQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpKTtcblxuICAgICAgICAgIGlmIChlbGVtZW50KSB0aGlzLmdldENvbnRleHQodHJ1ZSkuZHJhd0ltYWdlKGVsZW1lbnQsIDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2FudmFzKSBDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG4gICAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemUuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaXplID8gdGhpcy5fc2l6ZS53aWR0aCA6IDA7XG4gICAgfSxcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgICB0aGlzLnNldFNpemUod2lkdGgsIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgIH0sXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUuaGVpZ2h0IDogMDtcbiAgICB9LFxuICAgIHNldEhlaWdodDogZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgdGhpcy5zZXRTaXplKHRoaXMuZ2V0V2lkdGgoKSwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGdldExvYWRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZDtcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICAgIHJldHVybiAhc2l6ZSB8fCBzaXplLndpZHRoID09PSAwICYmIHNpemUuaGVpZ2h0ID09PSAwO1xuICAgIH0sXG4gICAgZ2V0UmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcbiAgICAgICAgICBvcmlnID0gbmV3IFBvaW50KDAsIDApLnRyYW5zZm9ybShtYXRyaXgpLFxuICAgICAgICAgIHUgPSBuZXcgUG9pbnQoMSwgMCkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyksXG4gICAgICAgICAgdiA9IG5ldyBQb2ludCgwLCAxKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKTtcbiAgICAgIHJldHVybiBuZXcgU2l6ZSg3MiAvIHUuZ2V0TGVuZ3RoKCksIDcyIC8gdi5nZXRMZW5ndGgoKSk7XG4gICAgfSxcbiAgICBnZXRQcGk6ICcjZ2V0UmVzb2x1dGlvbicsXG4gICAgZ2V0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbWFnZTtcbiAgICB9LFxuICAgIHNldEltYWdlOiBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICB2YXIgdmlldyA9IHRoYXQuZ2V0VmlldygpLFxuICAgICAgICAgICAgdHlwZSA9IGV2ZW50ICYmIGV2ZW50LnR5cGUgfHwgJ2xvYWQnO1xuXG4gICAgICAgIGlmICh2aWV3ICYmIHRoYXQucmVzcG9uZHModHlwZSkpIHtcbiAgICAgICAgICBwYXBlciA9IHZpZXcuX3Njb3BlO1xuICAgICAgICAgIHRoYXQuZW1pdCh0eXBlLCBuZXcgRXZlbnQoZXZlbnQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRJbWFnZShpbWFnZSk7XG5cbiAgICAgIGlmICh0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgc2V0VGltZW91dChlbWl0LCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoaW1hZ2UpIHtcbiAgICAgICAgRG9tRXZlbnQuYWRkKGltYWdlLCB7XG4gICAgICAgICAgbG9hZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGF0Ll9zZXRJbWFnZShpbWFnZSk7XG5cbiAgICAgICAgICAgIGVtaXQoZXZlbnQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IGVtaXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfc2V0SW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgaWYgKHRoaXMuX2NhbnZhcykgQ2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuXG4gICAgICBpZiAoaW1hZ2UgJiYgaW1hZ2UuZ2V0Q29udGV4dCkge1xuICAgICAgICB0aGlzLl9pbWFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGltYWdlO1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbG9hZGVkID0gISEoaW1hZ2UgJiYgaW1hZ2Uuc3JjICYmIGltYWdlLmNvbXBsZXRlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2l6ZSA9IG5ldyBTaXplKGltYWdlID8gaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLndpZHRoIDogMCwgaW1hZ2UgPyBpbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IGltYWdlLmhlaWdodCA6IDApO1xuICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoMTAzMyk7XG4gICAgfSxcbiAgICBnZXRDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fY2FudmFzKSB7XG4gICAgICAgIHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHRoaXMuX3NpemUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2ltYWdlKSBjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwKTtcbiAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjdHguY2FudmFzO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgQ2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfSxcbiAgICBzZXRDYW52YXM6ICcjc2V0SW1hZ2UnLFxuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uIChfY2hhbmdlKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbnRleHQpIHRoaXMuX2NvbnRleHQgPSB0aGlzLmdldENhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIGlmIChfY2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2ltYWdlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKDEwMjUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgICB9LFxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9LFxuICAgIGdldFNvdXJjZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5faW1hZ2U7XG4gICAgICByZXR1cm4gaW1hZ2UgJiYgaW1hZ2Uuc3JjIHx8IHRoaXMudG9EYXRhVVJMKCk7XG4gICAgfSxcbiAgICBzZXRTb3VyY2U6IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgIHZhciBpbWFnZSA9IG5ldyBzZWxmLkltYWdlKCksXG4gICAgICAgICAgY3Jvc3NPcmlnaW4gPSB0aGlzLl9jcm9zc09yaWdpbjtcbiAgICAgIGlmIChjcm9zc09yaWdpbikgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgIGlmIChzcmMpIGltYWdlLnNyYyA9IHNyYztcbiAgICAgIHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuICAgIH0sXG4gICAgZ2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlO1xuICAgICAgcmV0dXJuIGltYWdlICYmIGltYWdlLmNyb3NzT3JpZ2luIHx8IHRoaXMuX2Nyb3NzT3JpZ2luIHx8ICcnO1xuICAgIH0sXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uIChjcm9zc09yaWdpbikge1xuICAgICAgdGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlO1xuICAgICAgaWYgKGltYWdlKSBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgIH0sXG4gICAgZ2V0U21vb3RoaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc21vb3RoaW5nO1xuICAgIH0sXG4gICAgc2V0U21vb3RoaW5nOiBmdW5jdGlvbiAoc21vb3RoaW5nKSB7XG4gICAgICB0aGlzLl9zbW9vdGhpbmcgPSBzbW9vdGhpbmc7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoMjU3KTtcbiAgICB9LFxuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYW52YXMgfHwgdGhpcy5fbG9hZGVkICYmIHRoaXMuX2ltYWdlO1xuICAgIH1cbiAgfSwge1xuICAgIGJlYW5zOiBmYWxzZSxcbiAgICBnZXRTdWJDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHJlY3QuZ2V0U2l6ZSgpKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5nZXRDYW52YXMoKSwgcmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICByZXR1cm4gY3R4LmNhbnZhcztcbiAgICB9LFxuICAgIGdldFN1YlJhc3RlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXG4gICAgICByYXN0ZXIuX3NldEltYWdlKHRoaXMuZ2V0U3ViQ2FudmFzKHJlY3QpKTtcblxuICAgICAgcmFzdGVyLnRyYW5zbGF0ZShyZWN0LmdldENlbnRlcigpLnN1YnRyYWN0KHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZSgyKSkpO1xuXG4gICAgICByYXN0ZXIuX21hdHJpeC5wcmVwZW5kKHRoaXMuX21hdHJpeCk7XG5cbiAgICAgIHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcbiAgICAgIHJldHVybiByYXN0ZXI7XG4gICAgfSxcbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxuICAgICAgICAgIHNyYyA9IGltYWdlICYmIGltYWdlLnNyYztcbiAgICAgIGlmICgvXmRhdGE6Ly50ZXN0KHNyYykpIHJldHVybiBzcmM7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICAgIHJldHVybiBjYW52YXMgPyBjYW52YXMudG9EYXRhVVJMLmFwcGx5KGNhbnZhcywgYXJndW1lbnRzKSA6IG51bGw7XG4gICAgfSxcbiAgICBkcmF3SW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpO1xuICAgICAgdGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShpbWFnZSwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgfSxcbiAgICBnZXRBdmVyYWdlQ29sb3I6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHZhciBib3VuZHMsIHBhdGg7XG5cbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFBhdGhJdGVtKSB7XG4gICAgICAgIHBhdGggPSBvYmplY3Q7XG4gICAgICAgIGJvdW5kcyA9IG9iamVjdC5nZXRCb3VuZHMoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKCd3aWR0aCcgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgYm91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKCd4JyBpbiBvYmplY3QpIHtcbiAgICAgICAgICBib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdC54IC0gMC41LCBvYmplY3QueSAtIDAuNSwgMSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFib3VuZHMpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHNhbXBsZVNpemUgPSAzMixcbiAgICAgICAgICB3aWR0aCA9IE1hdGgubWluKGJvdW5kcy53aWR0aCwgc2FtcGxlU2l6ZSksXG4gICAgICAgICAgaGVpZ2h0ID0gTWF0aC5taW4oYm91bmRzLmhlaWdodCwgc2FtcGxlU2l6ZSk7XG4gICAgICB2YXIgY3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0O1xuXG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICBjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQgPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KG5ldyBTaXplKHNhbXBsZVNpemUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgc2FtcGxlU2l6ZSArIDEsIHNhbXBsZVNpemUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KCkuc2NhbGUod2lkdGggLyBib3VuZHMud2lkdGgsIGhlaWdodCAvIGJvdW5kcy5oZWlnaHQpLnRyYW5zbGF0ZSgtYm91bmRzLngsIC1ib3VuZHMueSk7XG4gICAgICBtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcbiAgICAgIGlmIChwYXRoKSBwYXRoLmRyYXcoY3R4LCBuZXcgQmFzZSh7XG4gICAgICAgIGNsaXA6IHRydWUsXG4gICAgICAgIG1hdHJpY2VzOiBbbWF0cml4XVxuICAgICAgfSkpO1xuXG4gICAgICB0aGlzLl9tYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblxuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKSxcbiAgICAgICAgICBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICAgIGlmIChlbGVtZW50KSBjdHguZHJhd0ltYWdlKGVsZW1lbnQsIC1zaXplLndpZHRoIC8gMiwgLXNpemUuaGVpZ2h0IC8gMik7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdmFyIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMC41LCAwLjUsIE1hdGguY2VpbCh3aWR0aCksIE1hdGguY2VpbChoZWlnaHQpKS5kYXRhLFxuICAgICAgICAgIGNoYW5uZWxzID0gWzAsIDAsIDBdLFxuICAgICAgICAgIHRvdGFsID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwaXhlbHMubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICAgIHZhciBhbHBoYSA9IHBpeGVsc1tpICsgM107XG4gICAgICAgIHRvdGFsICs9IGFscGhhO1xuICAgICAgICBhbHBoYSAvPSAyNTU7XG4gICAgICAgIGNoYW5uZWxzWzBdICs9IHBpeGVsc1tpXSAqIGFscGhhO1xuICAgICAgICBjaGFubmVsc1sxXSArPSBwaXhlbHNbaSArIDFdICogYWxwaGE7XG4gICAgICAgIGNoYW5uZWxzWzJdICs9IHBpeGVsc1tpICsgMl0gKiBhbHBoYTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIGNoYW5uZWxzW2ldIC89IHRvdGFsO1xuXG4gICAgICByZXR1cm4gdG90YWwgPyBDb2xvci5yZWFkKGNoYW5uZWxzKSA6IG51bGw7XG4gICAgfSxcbiAgICBnZXRQaXhlbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocG9pbnQueCwgcG9pbnQueSwgMSwgMSkuZGF0YTtcbiAgICAgIHJldHVybiBuZXcgQ29sb3IoJ3JnYicsIFtkYXRhWzBdIC8gMjU1LCBkYXRhWzFdIC8gMjU1LCBkYXRhWzJdIC8gMjU1XSwgZGF0YVszXSAvIDI1NSk7XG4gICAgfSxcbiAgICBzZXRQaXhlbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgIGNvbG9yID0gQ29sb3IucmVhZChhcmdzKSxcbiAgICAgICAgICBjb21wb25lbnRzID0gY29sb3IuX2NvbnZlcnQoJ3JnYicpLFxuICAgICAgICAgIGFscGhhID0gY29sb3IuX2FscGhhLFxuICAgICAgICAgIGN0eCA9IHRoaXMuZ2V0Q29udGV4dCh0cnVlKSxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKDEsIDEpLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblxuICAgICAgZGF0YVswXSA9IGNvbXBvbmVudHNbMF0gKiAyNTU7XG4gICAgICBkYXRhWzFdID0gY29tcG9uZW50c1sxXSAqIDI1NTtcbiAgICAgIGRhdGFbMl0gPSBjb21wb25lbnRzWzJdICogMjU1O1xuICAgICAgZGF0YVszXSA9IGFscGhhICE9IG51bGwgPyBhbHBoYSAqIDI1NSA6IDI1NTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCBwb2ludC54LCBwb2ludC55KTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgICB0aGlzLmdldENvbnRleHQodHJ1ZSkuY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGggKyAxLCBzaXplLmhlaWdodCArIDEpO1xuICAgIH0sXG4gICAgY3JlYXRlSW1hZ2VEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmNyZWF0ZUltYWdlRGF0YShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgfSxcbiAgICBnZXRJbWFnZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZWN0LmlzRW1wdHkoKSkgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgfSxcbiAgICBzZXRJbWFnZURhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG4gICAgICB0aGlzLmdldENvbnRleHQodHJ1ZSkucHV0SW1hZ2VEYXRhKGRhdGEsIHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24gKG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKTtcbiAgICAgIHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG4gICAgfSxcbiAgICBfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgaWYgKHRoaXMuX2NvbnRhaW5zKHBvaW50KSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGl0UmVzdWx0KCdwaXhlbCcsIHRoYXQsIHtcbiAgICAgICAgICBvZmZzZXQ6IHBvaW50LmFkZCh0aGF0Ll9zaXplLmRpdmlkZSgyKSkucm91bmQoKSxcbiAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGF0LmdldFBpeGVsKHRoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2RyYXc6IGZ1bmN0aW9uIChjdHgsIHBhcmFtLCB2aWV3TWF0cml4KSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXG4gICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LndpZHRoID4gMCAmJiBlbGVtZW50LmhlaWdodCA+IDApIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gTnVtZXJpY2FsLmNsYW1wKHRoaXMuX29wYWNpdHksIDAsIDEpO1xuXG4gICAgICAgIHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblxuICAgICAgICBEb21FbGVtZW50LnNldFByZWZpeGVkKGN0eCwgJ2ltYWdlU21vb3RoaW5nRW5hYmxlZCcsIHRoaXMuX3Ntb290aGluZyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoZWxlbWVudCwgLXRoaXMuX3NpemUud2lkdGggLyAyLCAtdGhpcy5fc2l6ZS5oZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBTeW1ib2xJdGVtID0gSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1N5bWJvbEl0ZW0nLFxuICAgIF9hcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfYm91bmRzT3B0aW9uczoge1xuICAgICAgc3Ryb2tlOiB0cnVlXG4gICAgfSxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICBzeW1ib2w6IG51bGxcbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbEl0ZW0oYXJnMCwgYXJnMSkge1xuICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZzAsIGFyZzEgIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSkpKSB0aGlzLnNldERlZmluaXRpb24oYXJnMCBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb24gPyBhcmcwIDogbmV3IFN5bWJvbERlZmluaXRpb24oYXJnMCkpO1xuICAgIH0sXG4gICAgX2VxdWFsczogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uID09PSBpdGVtLl9kZWZpbml0aW9uO1xuICAgIH0sXG4gICAgY29weUNvbnRlbnQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc2V0RGVmaW5pdGlvbihzb3VyY2UuX2RlZmluaXRpb24pO1xuICAgIH0sXG4gICAgZ2V0RGVmaW5pdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb247XG4gICAgfSxcbiAgICBzZXREZWZpbml0aW9uOiBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgdGhpcy5fZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoOSk7XG4gICAgfSxcbiAgICBnZXRTeW1ib2w6ICcjZ2V0RGVmaW5pdGlvbicsXG4gICAgc2V0U3ltYm9sOiAnI3NldERlZmluaXRpb24nLFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uLl9pdGVtLmlzRW1wdHkoKTtcbiAgICB9LFxuICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uIChtYXRyaXgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBpdGVtID0gdGhpcy5fZGVmaW5pdGlvbi5faXRlbTtcbiAgICAgIHJldHVybiBpdGVtLl9nZXRDYWNoZWRCb3VuZHMoaXRlbS5fbWF0cml4LnByZXBlbmRlZChtYXRyaXgpLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIF9oaXRUZXN0U2VsZjogZnVuY3Rpb24gKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4KSB7XG4gICAgICB2YXIgb3B0cyA9IG9wdGlvbnMuZXh0ZW5kKHtcbiAgICAgICAgYWxsOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIHZhciByZXMgPSB0aGlzLl9kZWZpbml0aW9uLl9pdGVtLl9oaXRUZXN0KHBvaW50LCBvcHRzLCB2aWV3TWF0cml4KTtcblxuICAgICAgaWYgKHJlcykgcmVzLml0ZW0gPSB0aGlzO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIF9kcmF3OiBmdW5jdGlvbiAoY3R4LCBwYXJhbSkge1xuICAgICAgdGhpcy5fZGVmaW5pdGlvbi5faXRlbS5kcmF3KGN0eCwgcGFyYW0pO1xuICAgIH1cbiAgfSk7XG4gIHZhciBTeW1ib2xEZWZpbml0aW9uID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1N5bWJvbERlZmluaXRpb24nLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbERlZmluaXRpb24oaXRlbSwgZG9udENlbnRlcikge1xuICAgICAgdGhpcy5faWQgPSBVSUQuZ2V0KCk7XG4gICAgICB0aGlzLnByb2plY3QgPSBwYXBlci5wcm9qZWN0O1xuICAgICAgaWYgKGl0ZW0pIHRoaXMuc2V0SXRlbShpdGVtLCBkb250Q2VudGVyKTtcbiAgICB9LFxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICByZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NsYXNzLCB0aGlzLl9pdGVtXSwgb3B0aW9ucywgZmFsc2UsIGRpY3Rpb25hcnkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gKGZsYWdzKSB7XG4gICAgICBpZiAoZmxhZ3MgJiA4KSBJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuICAgICAgaWYgKGZsYWdzICYgMSkgdGhpcy5wcm9qZWN0Ll9jaGFuZ2VkKGZsYWdzKTtcbiAgICB9LFxuICAgIGdldEl0ZW06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVtO1xuICAgIH0sXG4gICAgc2V0SXRlbTogZnVuY3Rpb24gKGl0ZW0sIF9kb250Q2VudGVyKSB7XG4gICAgICBpZiAoaXRlbS5fc3ltYm9sKSBpdGVtID0gaXRlbS5jbG9uZSgpO1xuICAgICAgaWYgKHRoaXMuX2l0ZW0pIHRoaXMuX2l0ZW0uX3N5bWJvbCA9IG51bGw7XG4gICAgICB0aGlzLl9pdGVtID0gaXRlbTtcbiAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICBpdGVtLnNldFNlbGVjdGVkKGZhbHNlKTtcbiAgICAgIGlmICghX2RvbnRDZW50ZXIpIGl0ZW0uc2V0UG9zaXRpb24obmV3IFBvaW50KCkpO1xuICAgICAgaXRlbS5fc3ltYm9sID0gdGhpcztcblxuICAgICAgdGhpcy5fY2hhbmdlZCg5KTtcbiAgICB9LFxuICAgIGdldERlZmluaXRpb246ICcjZ2V0SXRlbScsXG4gICAgc2V0RGVmaW5pdGlvbjogJyNzZXRJdGVtJyxcbiAgICBwbGFjZTogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gbmV3IFN5bWJvbEl0ZW0odGhpcywgcG9zaXRpb24pO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU3ltYm9sRGVmaW5pdGlvbih0aGlzLl9pdGVtLmNsb25lKGZhbHNlKSk7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgIHJldHVybiBzeW1ib2wgPT09IHRoaXMgfHwgc3ltYm9sICYmIHRoaXMuX2l0ZW0uZXF1YWxzKHN5bWJvbC5faXRlbSkgfHwgZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgdmFyIEhpdFJlc3VsdCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdIaXRSZXN1bHQnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEhpdFJlc3VsdCh0eXBlLCBpdGVtLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLml0ZW0gPSBpdGVtO1xuICAgICAgaWYgKHZhbHVlcykgdGhpcy5pbmplY3QodmFsdWVzKTtcbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJncyAmJiBCYXNlLnJlYWQoYXJncyk7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZSh7XG4gICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICB0b2xlcmFuY2U6IHBhcGVyLnNldHRpbmdzLmhpdFRvbGVyYW5jZSxcbiAgICAgICAgICBmaWxsOiAhb3B0aW9ucyxcbiAgICAgICAgICBzdHJva2U6ICFvcHRpb25zLFxuICAgICAgICAgIHNlZ21lbnRzOiAhb3B0aW9ucyxcbiAgICAgICAgICBoYW5kbGVzOiBmYWxzZSxcbiAgICAgICAgICBlbmRzOiBmYWxzZSxcbiAgICAgICAgICBwb3NpdGlvbjogZmFsc2UsXG4gICAgICAgICAgY2VudGVyOiBmYWxzZSxcbiAgICAgICAgICBib3VuZHM6IGZhbHNlLFxuICAgICAgICAgIGd1aWRlczogZmFsc2UsXG4gICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBTZWdtZW50ID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1NlZ21lbnQnLFxuICAgIGJlYW5zOiB0cnVlLFxuICAgIF9zZWxlY3Rpb246IDAsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gICAgICB2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIHBvaW50LFxuICAgICAgICAgIGhhbmRsZUluLFxuICAgICAgICAgIGhhbmRsZU91dCxcbiAgICAgICAgICBzZWxlY3Rpb247XG5cbiAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgaWYgKGFyZzAgPT0gbnVsbCB8fCB0eXBlb2YgYXJnMCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAoY291bnQgPT09IDEgJiYgYXJnMCAmJiAncG9pbnQnIGluIGFyZzApIHtcbiAgICAgICAgICAgIHBvaW50ID0gYXJnMC5wb2ludDtcbiAgICAgICAgICAgIGhhbmRsZUluID0gYXJnMC5oYW5kbGVJbjtcbiAgICAgICAgICAgIGhhbmRsZU91dCA9IGFyZzAuaGFuZGxlT3V0O1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gYXJnMC5zZWxlY3Rpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50ID0gYXJnMDtcbiAgICAgICAgICAgIGhhbmRsZUluID0gYXJnMTtcbiAgICAgICAgICAgIGhhbmRsZU91dCA9IGFyZzI7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBhcmczO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludCA9IFthcmcwLCBhcmcxXTtcbiAgICAgICAgICBoYW5kbGVJbiA9IGFyZzIgIT09IHVuZGVmaW5lZCA/IFthcmcyLCBhcmczXSA6IG51bGw7XG4gICAgICAgICAgaGFuZGxlT3V0ID0gYXJnNCAhPT0gdW5kZWZpbmVkID8gW2FyZzQsIGFyZzVdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXcgU2VnbWVudFBvaW50KHBvaW50LCB0aGlzLCAnX3BvaW50Jyk7XG4gICAgICBuZXcgU2VnbWVudFBvaW50KGhhbmRsZUluLCB0aGlzLCAnX2hhbmRsZUluJyk7XG4gICAgICBuZXcgU2VnbWVudFBvaW50KGhhbmRsZU91dCwgdGhpcywgJ19oYW5kbGVPdXQnKTtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5fcG9pbnQsXG4gICAgICAgICAgc2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uLFxuICAgICAgICAgIG9iaiA9IHNlbGVjdGlvbiB8fCB0aGlzLmhhc0hhbmRsZXMoKSA/IFtwb2ludCwgdGhpcy5faGFuZGxlSW4sIHRoaXMuX2hhbmRsZU91dF0gOiBwb2ludDtcbiAgICAgIGlmIChzZWxlY3Rpb24pIG9iai5wdXNoKHNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUob2JqLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcbiAgICB9LFxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgIGlmICghcGF0aCkgcmV0dXJuO1xuICAgICAgdmFyIGN1cnZlcyA9IHBhdGguX2N1cnZlcyxcbiAgICAgICAgICBpbmRleCA9IHRoaXMuX2luZGV4LFxuICAgICAgICAgIGN1cnZlO1xuXG4gICAgICBpZiAoY3VydmVzKSB7XG4gICAgICAgIGlmICgoIXBvaW50IHx8IHBvaW50ID09PSB0aGlzLl9wb2ludCB8fCBwb2ludCA9PT0gdGhpcy5faGFuZGxlSW4pICYmIChjdXJ2ZSA9IGluZGV4ID4gMCA/IGN1cnZlc1tpbmRleCAtIDFdIDogcGF0aC5fY2xvc2VkID8gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSA6IG51bGwpKSBjdXJ2ZS5fY2hhbmdlZCgpO1xuICAgICAgICBpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dCkgJiYgKGN1cnZlID0gY3VydmVzW2luZGV4XSkpIGN1cnZlLl9jaGFuZ2VkKCk7XG4gICAgICB9XG5cbiAgICAgIHBhdGguX2NoYW5nZWQoNDEpO1xuICAgIH0sXG4gICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb2ludDtcbiAgICB9LFxuICAgIHNldFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9wb2ludC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGdldEhhbmRsZUluOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlSW47XG4gICAgfSxcbiAgICBzZXRIYW5kbGVJbjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5faGFuZGxlSW4uc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBnZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVPdXQ7XG4gICAgfSxcbiAgICBzZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2hhbmRsZU91dC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGhhc0hhbmRsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkgfHwgIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKTtcbiAgICB9LFxuICAgIGlzU21vb3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGFuZGxlSW4gPSB0aGlzLl9oYW5kbGVJbixcbiAgICAgICAgICBoYW5kbGVPdXQgPSB0aGlzLl9oYW5kbGVPdXQ7XG4gICAgICByZXR1cm4gIWhhbmRsZUluLmlzWmVybygpICYmICFoYW5kbGVPdXQuaXNaZXJvKCkgJiYgaGFuZGxlSW4uaXNDb2xsaW5lYXIoaGFuZGxlT3V0KTtcbiAgICB9LFxuICAgIGNsZWFySGFuZGxlczogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5faGFuZGxlSW4uX3NldCgwLCAwKTtcblxuICAgICAgdGhpcy5faGFuZGxlT3V0Ll9zZXQoMCwgMCk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb247XG4gICAgfSxcbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgIHZhciBvbGRTZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb24sXG4gICAgICAgICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICB0aGlzLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgMDtcblxuICAgICAgaWYgKHBhdGggJiYgc2VsZWN0aW9uICE9PSBvbGRTZWxlY3Rpb24pIHtcbiAgICAgICAgcGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFNlbGVjdGlvbiwgc2VsZWN0aW9uKTtcblxuICAgICAgICBwYXRoLl9jaGFuZ2VkKDI1Nyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2hhbmdlU2VsZWN0aW9uOiBmdW5jdGlvbiAoZmxhZywgc2VsZWN0ZWQpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb247XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3RlZCA/IHNlbGVjdGlvbiB8IGZsYWcgOiBzZWxlY3Rpb24gJiB+ZmxhZyk7XG4gICAgfSxcbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISEodGhpcy5fc2VsZWN0aW9uICYgNyk7XG4gICAgfSxcbiAgICBzZXRTZWxlY3RlZDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VTZWxlY3Rpb24oNywgc2VsZWN0ZWQpO1xuICAgIH0sXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmRleCAhPT0gdW5kZWZpbmVkID8gdGhpcy5faW5kZXggOiBudWxsO1xuICAgIH0sXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhdGggfHwgbnVsbDtcbiAgICB9LFxuICAgIGdldEN1cnZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG4gICAgICAgICAgaW5kZXggPSB0aGlzLl9pbmRleDtcblxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgaWYgKGluZGV4ID4gMCAmJiAhcGF0aC5fY2xvc2VkICYmIGluZGV4ID09PSBwYXRoLl9zZWdtZW50cy5sZW5ndGggLSAxKSBpbmRleC0tO1xuICAgICAgICByZXR1cm4gcGF0aC5nZXRDdXJ2ZXMoKVtpbmRleF0gfHwgbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuICAgICAgcmV0dXJuIGN1cnZlID8gbmV3IEN1cnZlTG9jYXRpb24oY3VydmUsIHRoaXMgPT09IGN1cnZlLl9zZWdtZW50MSA/IDAgOiAxKSA6IG51bGw7XG4gICAgfSxcbiAgICBnZXROZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX3NlZ21lbnRzO1xuICAgICAgcmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCArIDFdIHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1swXSkgfHwgbnVsbDtcbiAgICB9LFxuICAgIHNtb290aDogZnVuY3Rpb24gKG9wdGlvbnMsIF9maXJzdCwgX2xhc3QpIHtcbiAgICAgIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICB0eXBlID0gb3B0cy50eXBlLFxuICAgICAgICAgIGZhY3RvciA9IG9wdHMuZmFjdG9yLFxuICAgICAgICAgIHByZXYgPSB0aGlzLmdldFByZXZpb3VzKCksXG4gICAgICAgICAgbmV4dCA9IHRoaXMuZ2V0TmV4dCgpLFxuICAgICAgICAgIHAwID0gKHByZXYgfHwgdGhpcykuX3BvaW50LFxuICAgICAgICAgIHAxID0gdGhpcy5fcG9pbnQsXG4gICAgICAgICAgcDIgPSAobmV4dCB8fCB0aGlzKS5fcG9pbnQsXG4gICAgICAgICAgZDEgPSBwMC5nZXREaXN0YW5jZShwMSksXG4gICAgICAgICAgZDIgPSBwMS5nZXREaXN0YW5jZShwMik7XG5cbiAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAnY2F0bXVsbC1yb20nKSB7XG4gICAgICAgIHZhciBhID0gZmFjdG9yID09PSB1bmRlZmluZWQgPyAwLjUgOiBmYWN0b3IsXG4gICAgICAgICAgICBkMV9hID0gTWF0aC5wb3coZDEsIGEpLFxuICAgICAgICAgICAgZDFfMmEgPSBkMV9hICogZDFfYSxcbiAgICAgICAgICAgIGQyX2EgPSBNYXRoLnBvdyhkMiwgYSksXG4gICAgICAgICAgICBkMl8yYSA9IGQyX2EgKiBkMl9hO1xuXG4gICAgICAgIGlmICghX2ZpcnN0ICYmIHByZXYpIHtcbiAgICAgICAgICB2YXIgQSA9IDIgKiBkMl8yYSArIDMgKiBkMl9hICogZDFfYSArIGQxXzJhLFxuICAgICAgICAgICAgICBOID0gMyAqIGQyX2EgKiAoZDJfYSArIGQxX2EpO1xuICAgICAgICAgIHRoaXMuc2V0SGFuZGxlSW4oTiAhPT0gMCA/IG5ldyBQb2ludCgoZDJfMmEgKiBwMC5feCArIEEgKiBwMS5feCAtIGQxXzJhICogcDIuX3gpIC8gTiAtIHAxLl94LCAoZDJfMmEgKiBwMC5feSArIEEgKiBwMS5feSAtIGQxXzJhICogcDIuX3kpIC8gTiAtIHAxLl95KSA6IG5ldyBQb2ludCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX2xhc3QgJiYgbmV4dCkge1xuICAgICAgICAgIHZhciBBID0gMiAqIGQxXzJhICsgMyAqIGQxX2EgKiBkMl9hICsgZDJfMmEsXG4gICAgICAgICAgICAgIE4gPSAzICogZDFfYSAqIChkMV9hICsgZDJfYSk7XG4gICAgICAgICAgdGhpcy5zZXRIYW5kbGVPdXQoTiAhPT0gMCA/IG5ldyBQb2ludCgoZDFfMmEgKiBwMi5feCArIEEgKiBwMS5feCAtIGQyXzJhICogcDAuX3gpIC8gTiAtIHAxLl94LCAoZDFfMmEgKiBwMi5feSArIEEgKiBwMS5feSAtIGQyXzJhICogcDAuX3kpIC8gTiAtIHAxLl95KSA6IG5ldyBQb2ludCgpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZ2VvbWV0cmljJykge1xuICAgICAgICBpZiAocHJldiAmJiBuZXh0KSB7XG4gICAgICAgICAgdmFyIHZlY3RvciA9IHAwLnN1YnRyYWN0KHAyKSxcbiAgICAgICAgICAgICAgdCA9IGZhY3RvciA9PT0gdW5kZWZpbmVkID8gMC40IDogZmFjdG9yLFxuICAgICAgICAgICAgICBrID0gdCAqIGQxIC8gKGQxICsgZDIpO1xuICAgICAgICAgIGlmICghX2ZpcnN0KSB0aGlzLnNldEhhbmRsZUluKHZlY3Rvci5tdWx0aXBseShrKSk7XG4gICAgICAgICAgaWYgKCFfbGFzdCkgdGhpcy5zZXRIYW5kbGVPdXQodmVjdG9yLm11bHRpcGx5KGsgLSB0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU21vb3RoaW5nIG1ldGhvZCBcXCcnICsgdHlwZSArICdcXCcgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX3NlZ21lbnRzO1xuICAgICAgcmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCAtIDFdIHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSkgfHwgbnVsbDtcbiAgICB9LFxuICAgIGlzRmlyc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5faW5kZXg7XG4gICAgfSxcbiAgICBpc0xhc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgIHJldHVybiBwYXRoICYmIHRoaXMuX2luZGV4ID09PSBwYXRoLl9zZWdtZW50cy5sZW5ndGggLSAxIHx8IGZhbHNlO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhhbmRsZUluID0gdGhpcy5faGFuZGxlSW4sXG4gICAgICAgICAgaGFuZGxlT3V0ID0gdGhpcy5faGFuZGxlT3V0LFxuICAgICAgICAgIHRtcCA9IGhhbmRsZUluLmNsb25lKCk7XG4gICAgICBoYW5kbGVJbi5zZXQoaGFuZGxlT3V0KTtcbiAgICAgIGhhbmRsZU91dC5zZXQodG1wKTtcbiAgICB9LFxuICAgIHJldmVyc2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZU91dCwgdGhpcy5faGFuZGxlSW4pO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGF0aCA/ICEhdGhpcy5fcGF0aC5yZW1vdmVTZWdtZW50KHRoaXMuX2luZGV4KSA6IGZhbHNlO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlSW4sIHRoaXMuX2hhbmRsZU91dCk7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICByZXR1cm4gc2VnbWVudCA9PT0gdGhpcyB8fCBzZWdtZW50ICYmIHRoaXMuX2NsYXNzID09PSBzZWdtZW50Ll9jbGFzcyAmJiB0aGlzLl9wb2ludC5lcXVhbHMoc2VnbWVudC5fcG9pbnQpICYmIHRoaXMuX2hhbmRsZUluLmVxdWFscyhzZWdtZW50Ll9oYW5kbGVJbikgJiYgdGhpcy5faGFuZGxlT3V0LmVxdWFscyhzZWdtZW50Ll9oYW5kbGVPdXQpIHx8IGZhbHNlO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFsncG9pbnQ6ICcgKyB0aGlzLl9wb2ludF07XG4gICAgICBpZiAoIXRoaXMuX2hhbmRsZUluLmlzWmVybygpKSBwYXJ0cy5wdXNoKCdoYW5kbGVJbjogJyArIHRoaXMuX2hhbmRsZUluKTtcbiAgICAgIGlmICghdGhpcy5faGFuZGxlT3V0LmlzWmVybygpKSBwYXJ0cy5wdXNoKCdoYW5kbGVPdXQ6ICcgKyB0aGlzLl9oYW5kbGVPdXQpO1xuICAgICAgcmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9JztcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBuZXcgQXJyYXkoNiksIHRydWUpO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfSxcbiAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICAgIHZhciB1ID0gMSAtIGZhY3RvcixcbiAgICAgICAgICB2ID0gZmFjdG9yLFxuICAgICAgICAgIHBvaW50MSA9IGZyb20uX3BvaW50LFxuICAgICAgICAgIHBvaW50MiA9IHRvLl9wb2ludCxcbiAgICAgICAgICBoYW5kbGVJbjEgPSBmcm9tLl9oYW5kbGVJbixcbiAgICAgICAgICBoYW5kbGVJbjIgPSB0by5faGFuZGxlSW4sXG4gICAgICAgICAgaGFuZGxlT3V0MiA9IHRvLl9oYW5kbGVPdXQsXG4gICAgICAgICAgaGFuZGxlT3V0MSA9IGZyb20uX2hhbmRsZU91dDtcblxuICAgICAgdGhpcy5fcG9pbnQuX3NldCh1ICogcG9pbnQxLl94ICsgdiAqIHBvaW50Mi5feCwgdSAqIHBvaW50MS5feSArIHYgKiBwb2ludDIuX3ksIHRydWUpO1xuXG4gICAgICB0aGlzLl9oYW5kbGVJbi5fc2V0KHUgKiBoYW5kbGVJbjEuX3ggKyB2ICogaGFuZGxlSW4yLl94LCB1ICogaGFuZGxlSW4xLl95ICsgdiAqIGhhbmRsZUluMi5feSwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuX2hhbmRsZU91dC5fc2V0KHUgKiBoYW5kbGVPdXQxLl94ICsgdiAqIGhhbmRsZU91dDIuX3gsIHUgKiBoYW5kbGVPdXQxLl95ICsgdiAqIGhhbmRsZU91dDIuX3ksIHRydWUpO1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfSxcbiAgICBfdHJhbnNmb3JtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uIChtYXRyaXgsIGNvb3JkcywgY2hhbmdlKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLl9wb2ludCxcbiAgICAgICAgICBoYW5kbGVJbiA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZUluLmlzWmVybygpID8gdGhpcy5faGFuZGxlSW4gOiBudWxsLFxuICAgICAgICAgIGhhbmRsZU91dCA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKSA/IHRoaXMuX2hhbmRsZU91dCA6IG51bGwsXG4gICAgICAgICAgeCA9IHBvaW50Ll94LFxuICAgICAgICAgIHkgPSBwb2ludC5feSxcbiAgICAgICAgICBpID0gMjtcbiAgICAgIGNvb3Jkc1swXSA9IHg7XG4gICAgICBjb29yZHNbMV0gPSB5O1xuXG4gICAgICBpZiAoaGFuZGxlSW4pIHtcbiAgICAgICAgY29vcmRzW2krK10gPSBoYW5kbGVJbi5feCArIHg7XG4gICAgICAgIGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3kgKyB5O1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFuZGxlT3V0KSB7XG4gICAgICAgIGNvb3Jkc1tpKytdID0gaGFuZGxlT3V0Ll94ICsgeDtcbiAgICAgICAgY29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3kgKyB5O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgIG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIGkgLyAyKTtcblxuICAgICAgICB4ID0gY29vcmRzWzBdO1xuICAgICAgICB5ID0gY29vcmRzWzFdO1xuXG4gICAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgICBwb2ludC5feCA9IHg7XG4gICAgICAgICAgcG9pbnQuX3kgPSB5O1xuICAgICAgICAgIGkgPSAyO1xuXG4gICAgICAgICAgaWYgKGhhbmRsZUluKSB7XG4gICAgICAgICAgICBoYW5kbGVJbi5feCA9IGNvb3Jkc1tpKytdIC0geDtcbiAgICAgICAgICAgIGhhbmRsZUluLl95ID0gY29vcmRzW2krK10gLSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVPdXQpIHtcbiAgICAgICAgICAgIGhhbmRsZU91dC5feCA9IGNvb3Jkc1tpKytdIC0geDtcbiAgICAgICAgICAgIGhhbmRsZU91dC5feSA9IGNvb3Jkc1tpKytdIC0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFoYW5kbGVJbikge1xuICAgICAgICAgICAgY29vcmRzW2krK10gPSB4O1xuICAgICAgICAgICAgY29vcmRzW2krK10gPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaGFuZGxlT3V0KSB7XG4gICAgICAgICAgICBjb29yZHNbaSsrXSA9IHg7XG4gICAgICAgICAgICBjb29yZHNbaSsrXSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfVxuICB9KTtcbiAgdmFyIFNlZ21lbnRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudFBvaW50KHBvaW50LCBvd25lciwga2V5KSB7XG4gICAgICB2YXIgeCwgeSwgc2VsZWN0ZWQ7XG5cbiAgICAgIGlmICghcG9pbnQpIHtcbiAgICAgICAgeCA9IHkgPSAwO1xuICAgICAgfSBlbHNlIGlmICgoeCA9IHBvaW50WzBdKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHkgPSBwb2ludFsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwdCA9IHBvaW50O1xuXG4gICAgICAgIGlmICgoeCA9IHB0LngpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgICB4ID0gcHQueDtcbiAgICAgICAgfVxuXG4gICAgICAgIHkgPSBwdC55O1xuICAgICAgICBzZWxlY3RlZCA9IHB0LnNlbGVjdGVkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy5fb3duZXIgPSBvd25lcjtcbiAgICAgIG93bmVyW2tleV0gPSB0aGlzO1xuICAgICAgaWYgKHNlbGVjdGVkKSB0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuICAgIH0sXG4gICAgX3NldDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG5cbiAgICAgIHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldFg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH0sXG4gICAgc2V0WDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuXG4gICAgICB0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcbiAgICB9LFxuICAgIGdldFk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH0sXG4gICAgc2V0WTogZnVuY3Rpb24gKHkpIHtcbiAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICB0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcbiAgICB9LFxuICAgIGlzWmVybzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG4gICAgICByZXR1cm4gaXNaZXJvKHRoaXMuX3gpICYmIGlzWmVybyh0aGlzLl95KTtcbiAgICB9LFxuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLl9vd25lci5fc2VsZWN0aW9uICYgdGhpcy5fZ2V0U2VsZWN0aW9uKCkpO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgdGhpcy5fb3duZXIuX2NoYW5nZVNlbGVjdGlvbih0aGlzLl9nZXRTZWxlY3Rpb24oKSwgc2VsZWN0ZWQpO1xuICAgIH0sXG4gICAgX2dldFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG4gICAgICByZXR1cm4gdGhpcyA9PT0gb3duZXIuX3BvaW50ID8gMSA6IHRoaXMgPT09IG93bmVyLl9oYW5kbGVJbiA/IDIgOiB0aGlzID09PSBvd25lci5faGFuZGxlT3V0ID8gNCA6IDA7XG4gICAgfVxuICB9KTtcbiAgdmFyIEN1cnZlID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0N1cnZlJyxcbiAgICBiZWFuczogdHJ1ZSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBDdXJ2ZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2LCBhcmc3KSB7XG4gICAgICB2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIHNlZzEsXG4gICAgICAgICAgc2VnMixcbiAgICAgICAgICBwb2ludDEsXG4gICAgICAgICAgcG9pbnQyLFxuICAgICAgICAgIGhhbmRsZTEsXG4gICAgICAgICAgaGFuZGxlMjtcblxuICAgICAgaWYgKGNvdW50ID09PSAzKSB7XG4gICAgICAgIHRoaXMuX3BhdGggPSBhcmcwO1xuICAgICAgICBzZWcxID0gYXJnMTtcbiAgICAgICAgc2VnMiA9IGFyZzI7XG4gICAgICB9IGVsc2UgaWYgKCFjb3VudCkge1xuICAgICAgICBzZWcxID0gbmV3IFNlZ21lbnQoKTtcbiAgICAgICAgc2VnMiA9IG5ldyBTZWdtZW50KCk7XG4gICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgIGlmICgnc2VnbWVudDEnIGluIGFyZzApIHtcbiAgICAgICAgICBzZWcxID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50MSk7XG4gICAgICAgICAgc2VnMiA9IG5ldyBTZWdtZW50KGFyZzAuc2VnbWVudDIpO1xuICAgICAgICB9IGVsc2UgaWYgKCdwb2ludDEnIGluIGFyZzApIHtcbiAgICAgICAgICBwb2ludDEgPSBhcmcwLnBvaW50MTtcbiAgICAgICAgICBoYW5kbGUxID0gYXJnMC5oYW5kbGUxO1xuICAgICAgICAgIGhhbmRsZTIgPSBhcmcwLmhhbmRsZTI7XG4gICAgICAgICAgcG9pbnQyID0gYXJnMC5wb2ludDI7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuICAgICAgICAgIHBvaW50MSA9IFthcmcwWzBdLCBhcmcwWzFdXTtcbiAgICAgICAgICBwb2ludDIgPSBbYXJnMFs2XSwgYXJnMFs3XV07XG4gICAgICAgICAgaGFuZGxlMSA9IFthcmcwWzJdIC0gYXJnMFswXSwgYXJnMFszXSAtIGFyZzBbMV1dO1xuICAgICAgICAgIGhhbmRsZTIgPSBbYXJnMFs0XSAtIGFyZzBbNl0sIGFyZzBbNV0gLSBhcmcwWzddXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMikge1xuICAgICAgICBzZWcxID0gbmV3IFNlZ21lbnQoYXJnMCk7XG4gICAgICAgIHNlZzIgPSBuZXcgU2VnbWVudChhcmcxKTtcbiAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDQpIHtcbiAgICAgICAgcG9pbnQxID0gYXJnMDtcbiAgICAgICAgaGFuZGxlMSA9IGFyZzE7XG4gICAgICAgIGhhbmRsZTIgPSBhcmcyO1xuICAgICAgICBwb2ludDIgPSBhcmczO1xuICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gOCkge1xuICAgICAgICBwb2ludDEgPSBbYXJnMCwgYXJnMV07XG4gICAgICAgIHBvaW50MiA9IFthcmc2LCBhcmc3XTtcbiAgICAgICAgaGFuZGxlMSA9IFthcmcyIC0gYXJnMCwgYXJnMyAtIGFyZzFdO1xuICAgICAgICBoYW5kbGUyID0gW2FyZzQgLSBhcmc2LCBhcmc1IC0gYXJnN107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NlZ21lbnQxID0gc2VnMSB8fCBuZXcgU2VnbWVudChwb2ludDEsIG51bGwsIGhhbmRsZTEpO1xuICAgICAgdGhpcy5fc2VnbWVudDIgPSBzZWcyIHx8IG5ldyBTZWdtZW50KHBvaW50MiwgaGFuZGxlMiwgbnVsbCk7XG4gICAgfSxcbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuaGFzSGFuZGxlcygpID8gW3RoaXMuZ2V0UG9pbnQxKCksIHRoaXMuZ2V0SGFuZGxlMSgpLCB0aGlzLmdldEhhbmRsZTIoKSwgdGhpcy5nZXRQb2ludDIoKV0gOiBbdGhpcy5nZXRQb2ludDEoKSwgdGhpcy5nZXRQb2ludDIoKV0sIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2xlbmd0aCA9IHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Mik7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcnRzID0gWydwb2ludDE6ICcgKyB0aGlzLl9zZWdtZW50MS5fcG9pbnRdO1xuICAgICAgaWYgKCF0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LmlzWmVybygpKSBwYXJ0cy5wdXNoKCdoYW5kbGUxOiAnICsgdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dCk7XG4gICAgICBpZiAoIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKSkgcGFydHMucHVzaCgnaGFuZGxlMjogJyArIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbik7XG4gICAgICBwYXJ0cy5wdXNoKCdwb2ludDI6ICcgKyB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuICAgICAgcmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9JztcbiAgICB9LFxuICAgIGNsYXNzaWZ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gQ3VydmUuY2xhc3NpZnkodGhpcy5nZXRWYWx1ZXMoKSk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZW1vdmVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLl9wYXRoKSB7XG4gICAgICAgIHZhciBzZWdtZW50MiA9IHRoaXMuX3NlZ21lbnQyLFxuICAgICAgICAgICAgaGFuZGxlT3V0ID0gc2VnbWVudDIuX2hhbmRsZU91dDtcbiAgICAgICAgcmVtb3ZlZCA9IHNlZ21lbnQyLnJlbW92ZSgpO1xuICAgICAgICBpZiAocmVtb3ZlZCkgdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQoaGFuZGxlT3V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcbiAgICBnZXRQb2ludDE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50MS5fcG9pbnQ7XG4gICAgfSxcbiAgICBzZXRQb2ludDE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3NlZ21lbnQxLl9wb2ludC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGdldFBvaW50MjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9wb2ludDtcbiAgICB9LFxuICAgIHNldFBvaW50MjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc2VnbWVudDIuX3BvaW50LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZ2V0SGFuZGxlMTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQ7XG4gICAgfSxcbiAgICBzZXRIYW5kbGUxOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZ2V0SGFuZGxlMjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbjtcbiAgICB9LFxuICAgIHNldEhhbmRsZTI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGdldFNlZ21lbnQxOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VnbWVudDE7XG4gICAgfSxcbiAgICBnZXRTZWdtZW50MjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQyO1xuICAgIH0sXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgfSxcbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9pbmRleDtcbiAgICB9LFxuICAgIGdldE5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX2N1cnZlcztcbiAgICAgIHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggKyAxXSB8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzWzBdKSB8fCBudWxsO1xuICAgIH0sXG4gICAgZ2V0UHJldmlvdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX2N1cnZlcztcbiAgICAgIHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggLSAxXSB8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSkgfHwgbnVsbDtcbiAgICB9LFxuICAgIGlzRmlyc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5fc2VnbWVudDEuX2luZGV4O1xuICAgIH0sXG4gICAgaXNMYXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICByZXR1cm4gcGF0aCAmJiB0aGlzLl9zZWdtZW50MS5faW5kZXggPT09IHBhdGguX2N1cnZlcy5sZW5ndGggLSAxIHx8IGZhbHNlO1xuICAgIH0sXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnQxKCkuaXNTZWxlY3RlZCgpICYmIHRoaXMuZ2V0SGFuZGxlMSgpLmlzU2VsZWN0ZWQoKSAmJiB0aGlzLmdldEhhbmRsZTIoKS5pc1NlbGVjdGVkKCkgJiYgdGhpcy5nZXRQb2ludDIoKS5pc1NlbGVjdGVkKCk7XG4gICAgfSxcbiAgICBzZXRTZWxlY3RlZDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICB0aGlzLmdldFBvaW50MSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICAgIHRoaXMuZ2V0SGFuZGxlMSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICAgIHRoaXMuZ2V0SGFuZGxlMigpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICAgIHRoaXMuZ2V0UG9pbnQyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuICAgIH0sXG4gICAgZ2V0VmFsdWVzOiBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICByZXR1cm4gQ3VydmUuZ2V0VmFsdWVzKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50MiwgbWF0cml4KTtcbiAgICB9LFxuICAgIGdldFBvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG4gICAgICAgICAgcG9pbnRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKSBwb2ludHMucHVzaChuZXcgUG9pbnQoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdKSk7XG5cbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICB9LCB7XG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpIHRoaXMuX2xlbmd0aCA9IEN1cnZlLmdldExlbmd0aCh0aGlzLmdldFZhbHVlcygpLCAwLCAxKTtcbiAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgfSxcbiAgICBnZXRBcmVhOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gQ3VydmUuZ2V0QXJlYSh0aGlzLmdldFZhbHVlcygpKTtcbiAgICB9LFxuICAgIGdldExpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLl9zZWdtZW50MS5fcG9pbnQsIHRoaXMuX3NlZ21lbnQyLl9wb2ludCk7XG4gICAgfSxcbiAgICBnZXRQYXJ0OiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBuZXcgQ3VydmUoQ3VydmUuZ2V0UGFydCh0aGlzLmdldFZhbHVlcygpLCBmcm9tLCB0bykpO1xuICAgIH0sXG4gICAgZ2V0UGFydExlbmd0aDogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKTtcbiAgICB9LFxuICAgIGRpdmlkZUF0OiBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdmlkZUF0VGltZShsb2NhdGlvbiAmJiBsb2NhdGlvbi5jdXJ2ZSA9PT0gdGhpcyA/IGxvY2F0aW9uLnRpbWUgOiB0aGlzLmdldFRpbWVBdChsb2NhdGlvbikpO1xuICAgIH0sXG4gICAgZGl2aWRlQXRUaW1lOiBmdW5jdGlvbiAodGltZSwgX3NldEhhbmRsZXMpIHtcbiAgICAgIHZhciB0TWluID0gMWUtOCxcbiAgICAgICAgICB0TWF4ID0gMSAtIHRNaW4sXG4gICAgICAgICAgcmVzID0gbnVsbDtcblxuICAgICAgaWYgKHRpbWUgPj0gdE1pbiAmJiB0aW1lIDw9IHRNYXgpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHRoaXMuZ2V0VmFsdWVzKCksIHRpbWUpLFxuICAgICAgICAgICAgbGVmdCA9IHBhcnRzWzBdLFxuICAgICAgICAgICAgcmlnaHQgPSBwYXJ0c1sxXSxcbiAgICAgICAgICAgIHNldEhhbmRsZXMgPSBfc2V0SGFuZGxlcyB8fCB0aGlzLmhhc0hhbmRsZXMoKSxcbiAgICAgICAgICAgIHNlZzEgPSB0aGlzLl9zZWdtZW50MSxcbiAgICAgICAgICAgIHNlZzIgPSB0aGlzLl9zZWdtZW50MixcbiAgICAgICAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuXG4gICAgICAgIGlmIChzZXRIYW5kbGVzKSB7XG4gICAgICAgICAgc2VnMS5faGFuZGxlT3V0Ll9zZXQobGVmdFsyXSAtIGxlZnRbMF0sIGxlZnRbM10gLSBsZWZ0WzFdKTtcblxuICAgICAgICAgIHNlZzIuX2hhbmRsZUluLl9zZXQocmlnaHRbNF0gLSByaWdodFs2XSwgcmlnaHRbNV0gLSByaWdodFs3XSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IGxlZnRbNl0sXG4gICAgICAgICAgICB5ID0gbGVmdFs3XSxcbiAgICAgICAgICAgIHNlZ21lbnQgPSBuZXcgU2VnbWVudChuZXcgUG9pbnQoeCwgeSksIHNldEhhbmRsZXMgJiYgbmV3IFBvaW50KGxlZnRbNF0gLSB4LCBsZWZ0WzVdIC0geSksIHNldEhhbmRsZXMgJiYgbmV3IFBvaW50KHJpZ2h0WzJdIC0geCwgcmlnaHRbM10gLSB5KSk7XG5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICBwYXRoLmluc2VydChzZWcxLl9pbmRleCArIDEsIHNlZ21lbnQpO1xuICAgICAgICAgIHJlcyA9IHRoaXMuZ2V0TmV4dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NlZ21lbnQyID0gc2VnbWVudDtcblxuICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcblxuICAgICAgICAgIHJlcyA9IG5ldyBDdXJ2ZShzZWdtZW50LCBzZWcyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgc3BsaXRBdDogZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICByZXR1cm4gcGF0aCA/IHBhdGguc3BsaXRBdChsb2NhdGlvbikgOiBudWxsO1xuICAgIH0sXG4gICAgc3BsaXRBdFRpbWU6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpdEF0KHRoaXMuZ2V0TG9jYXRpb25BdFRpbWUodGltZSkpO1xuICAgIH0sXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAob2Zmc2V0LCBpc1RpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdmlkZUF0VGltZShvZmZzZXQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IGlzVGltZSA/IG9mZnNldCA6IHRoaXMuZ2V0VGltZUF0KG9mZnNldCkpO1xuICAgIH0sXG4gICAgc3BsaXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGlzVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaXRBdFRpbWUob2Zmc2V0ID09PSB1bmRlZmluZWQgPyAwLjUgOiBpc1RpbWUgPyBvZmZzZXQgOiB0aGlzLmdldFRpbWVBdChvZmZzZXQpKTtcbiAgICB9LFxuICAgIHJldmVyc2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQyLnJldmVyc2VkKCksIHRoaXMuX3NlZ21lbnQxLnJldmVyc2VkKCkpO1xuICAgIH0sXG4gICAgY2xlYXJIYW5kbGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0Ll9zZXQoMCwgMCk7XG5cbiAgICAgIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5fc2V0KDAsIDApO1xuICAgIH0sXG4gICAgc3RhdGljczoge1xuICAgICAgZ2V0VmFsdWVzOiBmdW5jdGlvbiAoc2VnbWVudDEsIHNlZ21lbnQyLCBtYXRyaXgsIHN0cmFpZ2h0KSB7XG4gICAgICAgIHZhciBwMSA9IHNlZ21lbnQxLl9wb2ludCxcbiAgICAgICAgICAgIGgxID0gc2VnbWVudDEuX2hhbmRsZU91dCxcbiAgICAgICAgICAgIGgyID0gc2VnbWVudDIuX2hhbmRsZUluLFxuICAgICAgICAgICAgcDIgPSBzZWdtZW50Mi5fcG9pbnQsXG4gICAgICAgICAgICB4MSA9IHAxLngsXG4gICAgICAgICAgICB5MSA9IHAxLnksXG4gICAgICAgICAgICB4MiA9IHAyLngsXG4gICAgICAgICAgICB5MiA9IHAyLnksXG4gICAgICAgICAgICB2YWx1ZXMgPSBzdHJhaWdodCA/IFt4MSwgeTEsIHgxLCB5MSwgeDIsIHkyLCB4MiwgeTJdIDogW3gxLCB5MSwgeDEgKyBoMS5feCwgeTEgKyBoMS5feSwgeDIgKyBoMi5feCwgeTIgKyBoMi5feSwgeDIsIHkyXTtcbiAgICAgICAgaWYgKG1hdHJpeCkgbWF0cml4Ll90cmFuc2Zvcm1Db29yZGluYXRlcyh2YWx1ZXMsIHZhbHVlcywgNCk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9LFxuICAgICAgc3ViZGl2aWRlOiBmdW5jdGlvbiAodiwgdCkge1xuICAgICAgICB2YXIgeDAgPSB2WzBdLFxuICAgICAgICAgICAgeTAgPSB2WzFdLFxuICAgICAgICAgICAgeDEgPSB2WzJdLFxuICAgICAgICAgICAgeTEgPSB2WzNdLFxuICAgICAgICAgICAgeDIgPSB2WzRdLFxuICAgICAgICAgICAgeTIgPSB2WzVdLFxuICAgICAgICAgICAgeDMgPSB2WzZdLFxuICAgICAgICAgICAgeTMgPSB2WzddO1xuICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB0ID0gMC41O1xuICAgICAgICB2YXIgdSA9IDEgLSB0LFxuICAgICAgICAgICAgeDQgPSB1ICogeDAgKyB0ICogeDEsXG4gICAgICAgICAgICB5NCA9IHUgKiB5MCArIHQgKiB5MSxcbiAgICAgICAgICAgIHg1ID0gdSAqIHgxICsgdCAqIHgyLFxuICAgICAgICAgICAgeTUgPSB1ICogeTEgKyB0ICogeTIsXG4gICAgICAgICAgICB4NiA9IHUgKiB4MiArIHQgKiB4MyxcbiAgICAgICAgICAgIHk2ID0gdSAqIHkyICsgdCAqIHkzLFxuICAgICAgICAgICAgeDcgPSB1ICogeDQgKyB0ICogeDUsXG4gICAgICAgICAgICB5NyA9IHUgKiB5NCArIHQgKiB5NSxcbiAgICAgICAgICAgIHg4ID0gdSAqIHg1ICsgdCAqIHg2LFxuICAgICAgICAgICAgeTggPSB1ICogeTUgKyB0ICogeTYsXG4gICAgICAgICAgICB4OSA9IHUgKiB4NyArIHQgKiB4OCxcbiAgICAgICAgICAgIHk5ID0gdSAqIHk3ICsgdCAqIHk4O1xuICAgICAgICByZXR1cm4gW1t4MCwgeTAsIHg0LCB5NCwgeDcsIHk3LCB4OSwgeTldLCBbeDksIHk5LCB4OCwgeTgsIHg2LCB5NiwgeDMsIHkzXV07XG4gICAgICB9LFxuICAgICAgZ2V0TW9ub0N1cnZlczogZnVuY3Rpb24gKHYsIGRpcikge1xuICAgICAgICB2YXIgY3VydmVzID0gW10sXG4gICAgICAgICAgICBpbyA9IGRpciA/IDAgOiAxLFxuICAgICAgICAgICAgbzAgPSB2W2lvICsgMF0sXG4gICAgICAgICAgICBvMSA9IHZbaW8gKyAyXSxcbiAgICAgICAgICAgIG8yID0gdltpbyArIDRdLFxuICAgICAgICAgICAgbzMgPSB2W2lvICsgNl07XG5cbiAgICAgICAgaWYgKG8wID49IG8xID09PSBvMSA+PSBvMiAmJiBvMSA+PSBvMiA9PT0gbzIgPj0gbzMgfHwgQ3VydmUuaXNTdHJhaWdodCh2KSkge1xuICAgICAgICAgIGN1cnZlcy5wdXNoKHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhID0gMyAqIChvMSAtIG8yKSAtIG8wICsgbzMsXG4gICAgICAgICAgICAgIGIgPSAyICogKG8wICsgbzIpIC0gNCAqIG8xLFxuICAgICAgICAgICAgICBjID0gbzEgLSBvMCxcbiAgICAgICAgICAgICAgdE1pbiA9IDFlLTgsXG4gICAgICAgICAgICAgIHRNYXggPSAxIC0gdE1pbixcbiAgICAgICAgICAgICAgcm9vdHMgPSBbXSxcbiAgICAgICAgICAgICAgbiA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cywgdE1pbiwgdE1heCk7XG5cbiAgICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICAgIGN1cnZlcy5wdXNoKHYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290cy5zb3J0KCk7XG4gICAgICAgICAgICB2YXIgdCA9IHJvb3RzWzBdLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYsIHQpO1xuICAgICAgICAgICAgY3VydmVzLnB1c2gocGFydHNbMF0pO1xuXG4gICAgICAgICAgICBpZiAobiA+IDEpIHtcbiAgICAgICAgICAgICAgdCA9IChyb290c1sxXSAtIHQpIC8gKDEgLSB0KTtcbiAgICAgICAgICAgICAgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUocGFydHNbMV0sIHQpO1xuICAgICAgICAgICAgICBjdXJ2ZXMucHVzaChwYXJ0c1swXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnZlcy5wdXNoKHBhcnRzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VydmVzO1xuICAgICAgfSxcbiAgICAgIHNvbHZlQ3ViaWM6IGZ1bmN0aW9uICh2LCBjb29yZCwgdmFsLCByb290cywgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHYwID0gdltjb29yZF0sXG4gICAgICAgICAgICB2MSA9IHZbY29vcmQgKyAyXSxcbiAgICAgICAgICAgIHYyID0gdltjb29yZCArIDRdLFxuICAgICAgICAgICAgdjMgPSB2W2Nvb3JkICsgNl0sXG4gICAgICAgICAgICByZXMgPSAwO1xuXG4gICAgICAgIGlmICghKHYwIDwgdmFsICYmIHYzIDwgdmFsICYmIHYxIDwgdmFsICYmIHYyIDwgdmFsIHx8IHYwID4gdmFsICYmIHYzID4gdmFsICYmIHYxID4gdmFsICYmIHYyID4gdmFsKSkge1xuICAgICAgICAgIHZhciBjID0gMyAqICh2MSAtIHYwKSxcbiAgICAgICAgICAgICAgYiA9IDMgKiAodjIgLSB2MSkgLSBjLFxuICAgICAgICAgICAgICBhID0gdjMgLSB2MCAtIGMgLSBiO1xuICAgICAgICAgIHJlcyA9IE51bWVyaWNhbC5zb2x2ZUN1YmljKGEsIGIsIGMsIHYwIC0gdmFsLCByb290cywgbWluLCBtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0sXG4gICAgICBnZXRUaW1lT2Y6IGZ1bmN0aW9uICh2LCBwb2ludCkge1xuICAgICAgICB2YXIgcDAgPSBuZXcgUG9pbnQodlswXSwgdlsxXSksXG4gICAgICAgICAgICBwMyA9IG5ldyBQb2ludCh2WzZdLCB2WzddKSxcbiAgICAgICAgICAgIGVwc2lsb24gPSAxZS0xMixcbiAgICAgICAgICAgIGdlb21FcHNpbG9uID0gMWUtNyxcbiAgICAgICAgICAgIHQgPSBwb2ludC5pc0Nsb3NlKHAwLCBlcHNpbG9uKSA/IDAgOiBwb2ludC5pc0Nsb3NlKHAzLCBlcHNpbG9uKSA/IDEgOiBudWxsO1xuXG4gICAgICAgIGlmICh0ID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGNvb3JkcyA9IFtwb2ludC54LCBwb2ludC55XSxcbiAgICAgICAgICAgICAgcm9vdHMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgMjsgYysrKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBDdXJ2ZS5zb2x2ZUN1YmljKHYsIGMsIGNvb3Jkc1tjXSwgcm9vdHMsIDAsIDEpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSByb290c1tpXTtcbiAgICAgICAgICAgICAgaWYgKHBvaW50LmlzQ2xvc2UoQ3VydmUuZ2V0UG9pbnQodiwgdSksIGdlb21FcHNpbG9uKSkgcmV0dXJuIHU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvaW50LmlzQ2xvc2UocDAsIGdlb21FcHNpbG9uKSA/IDAgOiBwb2ludC5pc0Nsb3NlKHAzLCBnZW9tRXBzaWxvbikgPyAxIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBnZXROZWFyZXN0VGltZTogZnVuY3Rpb24gKHYsIHBvaW50KSB7XG4gICAgICAgIGlmIChDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG4gICAgICAgICAgdmFyIHgwID0gdlswXSxcbiAgICAgICAgICAgICAgeTAgPSB2WzFdLFxuICAgICAgICAgICAgICB4MyA9IHZbNl0sXG4gICAgICAgICAgICAgIHkzID0gdls3XSxcbiAgICAgICAgICAgICAgdnggPSB4MyAtIHgwLFxuICAgICAgICAgICAgICB2eSA9IHkzIC0geTAsXG4gICAgICAgICAgICAgIGRldCA9IHZ4ICogdnggKyB2eSAqIHZ5O1xuICAgICAgICAgIGlmIChkZXQgPT09IDApIHJldHVybiAwO1xuICAgICAgICAgIHZhciB1ID0gKChwb2ludC54IC0geDApICogdnggKyAocG9pbnQueSAtIHkwKSAqIHZ5KSAvIGRldDtcbiAgICAgICAgICByZXR1cm4gdSA8IDFlLTEyID8gMCA6IHUgPiAwLjk5OTk5OTk5OTk5OSA/IDEgOiBDdXJ2ZS5nZXRUaW1lT2YodiwgbmV3IFBvaW50KHgwICsgdSAqIHZ4LCB5MCArIHUgKiB2eSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvdW50ID0gMTAwLFxuICAgICAgICAgICAgbWluRGlzdCA9IEluZmluaXR5LFxuICAgICAgICAgICAgbWluVCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVmaW5lKHQpIHtcbiAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBwb2ludC5nZXREaXN0YW5jZShDdXJ2ZS5nZXRQb2ludCh2LCB0KSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgbWluVCA9IHQ7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspIHJlZmluZShpIC8gY291bnQpO1xuXG4gICAgICAgIHZhciBzdGVwID0gMSAvIChjb3VudCAqIDIpO1xuXG4gICAgICAgIHdoaWxlIChzdGVwID4gMWUtOCkge1xuICAgICAgICAgIGlmICghcmVmaW5lKG1pblQgLSBzdGVwKSAmJiAhcmVmaW5lKG1pblQgKyBzdGVwKSkgc3RlcCAvPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pblQ7XG4gICAgICB9LFxuICAgICAgZ2V0UGFydDogZnVuY3Rpb24gKHYsIGZyb20sIHRvKSB7XG4gICAgICAgIHZhciBmbGlwID0gZnJvbSA+IHRvO1xuXG4gICAgICAgIGlmIChmbGlwKSB7XG4gICAgICAgICAgdmFyIHRtcCA9IGZyb207XG4gICAgICAgICAgZnJvbSA9IHRvO1xuICAgICAgICAgIHRvID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPiAwKSB2ID0gQ3VydmUuc3ViZGl2aWRlKHYsIGZyb20pWzFdO1xuICAgICAgICBpZiAodG8gPCAxKSB2ID0gQ3VydmUuc3ViZGl2aWRlKHYsICh0byAtIGZyb20pIC8gKDEgLSBmcm9tKSlbMF07XG4gICAgICAgIHJldHVybiBmbGlwID8gW3ZbNl0sIHZbN10sIHZbNF0sIHZbNV0sIHZbMl0sIHZbM10sIHZbMF0sIHZbMV1dIDogdjtcbiAgICAgIH0sXG4gICAgICBpc0ZsYXRFbm91Z2g6IGZ1bmN0aW9uICh2LCBmbGF0bmVzcykge1xuICAgICAgICB2YXIgeDAgPSB2WzBdLFxuICAgICAgICAgICAgeTAgPSB2WzFdLFxuICAgICAgICAgICAgeDEgPSB2WzJdLFxuICAgICAgICAgICAgeTEgPSB2WzNdLFxuICAgICAgICAgICAgeDIgPSB2WzRdLFxuICAgICAgICAgICAgeTIgPSB2WzVdLFxuICAgICAgICAgICAgeDMgPSB2WzZdLFxuICAgICAgICAgICAgeTMgPSB2WzddLFxuICAgICAgICAgICAgdXggPSAzICogeDEgLSAyICogeDAgLSB4MyxcbiAgICAgICAgICAgIHV5ID0gMyAqIHkxIC0gMiAqIHkwIC0geTMsXG4gICAgICAgICAgICB2eCA9IDMgKiB4MiAtIDIgKiB4MyAtIHgwLFxuICAgICAgICAgICAgdnkgPSAzICogeTIgLSAyICogeTMgLSB5MDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHV4ICogdXgsIHZ4ICogdngpICsgTWF0aC5tYXgodXkgKiB1eSwgdnkgKiB2eSkgPD0gMTYgKiBmbGF0bmVzcyAqIGZsYXRuZXNzO1xuICAgICAgfSxcbiAgICAgIGdldEFyZWE6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciB4MCA9IHZbMF0sXG4gICAgICAgICAgICB5MCA9IHZbMV0sXG4gICAgICAgICAgICB4MSA9IHZbMl0sXG4gICAgICAgICAgICB5MSA9IHZbM10sXG4gICAgICAgICAgICB4MiA9IHZbNF0sXG4gICAgICAgICAgICB5MiA9IHZbNV0sXG4gICAgICAgICAgICB4MyA9IHZbNl0sXG4gICAgICAgICAgICB5MyA9IHZbN107XG4gICAgICAgIHJldHVybiAzICogKCh5MyAtIHkwKSAqICh4MSArIHgyKSAtICh4MyAtIHgwKSAqICh5MSArIHkyKSArIHkxICogKHgwIC0geDIpIC0geDEgKiAoeTAgLSB5MikgKyB5MyAqICh4MiArIHgwIC8gMykgLSB4MyAqICh5MiArIHkwIC8gMykpIC8gMjA7XG4gICAgICB9LFxuICAgICAgZ2V0Qm91bmRzOiBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbWluID0gdi5zbGljZSgwLCAyKSxcbiAgICAgICAgICAgIG1heCA9IG1pbi5zbGljZSgpLFxuICAgICAgICAgICAgcm9vdHMgPSBbMCwgMF07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIEN1cnZlLl9hZGRCb3VuZHModltpXSwgdltpICsgMl0sIHZbaSArIDRdLCB2W2kgKyA2XSwgaSwgMCwgbWluLCBtYXgsIHJvb3RzKTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuICAgICAgfSxcbiAgICAgIF9hZGRCb3VuZHM6IGZ1bmN0aW9uICh2MCwgdjEsIHYyLCB2MywgY29vcmQsIHBhZGRpbmcsIG1pbiwgbWF4LCByb290cykge1xuICAgICAgICBmdW5jdGlvbiBhZGQodmFsdWUsIHBhZGRpbmcpIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IHZhbHVlIC0gcGFkZGluZyxcbiAgICAgICAgICAgICAgcmlnaHQgPSB2YWx1ZSArIHBhZGRpbmc7XG4gICAgICAgICAgaWYgKGxlZnQgPCBtaW5bY29vcmRdKSBtaW5bY29vcmRdID0gbGVmdDtcbiAgICAgICAgICBpZiAocmlnaHQgPiBtYXhbY29vcmRdKSBtYXhbY29vcmRdID0gcmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYWRkaW5nIC89IDI7XG4gICAgICAgIHZhciBtaW5QYWQgPSBtaW5bY29vcmRdICsgcGFkZGluZyxcbiAgICAgICAgICAgIG1heFBhZCA9IG1heFtjb29yZF0gLSBwYWRkaW5nO1xuXG4gICAgICAgIGlmICh2MCA8IG1pblBhZCB8fCB2MSA8IG1pblBhZCB8fCB2MiA8IG1pblBhZCB8fCB2MyA8IG1pblBhZCB8fCB2MCA+IG1heFBhZCB8fCB2MSA+IG1heFBhZCB8fCB2MiA+IG1heFBhZCB8fCB2MyA+IG1heFBhZCkge1xuICAgICAgICAgIGlmICh2MSA8IHYwICE9IHYxIDwgdjMgJiYgdjIgPCB2MCAhPSB2MiA8IHYzKSB7XG4gICAgICAgICAgICBhZGQodjAsIDApO1xuICAgICAgICAgICAgYWRkKHYzLCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGEgPSAzICogKHYxIC0gdjIpIC0gdjAgKyB2MyxcbiAgICAgICAgICAgICAgICBiID0gMiAqICh2MCArIHYyKSAtIDQgKiB2MSxcbiAgICAgICAgICAgICAgICBjID0gdjEgLSB2MCxcbiAgICAgICAgICAgICAgICBjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cyksXG4gICAgICAgICAgICAgICAgdE1pbiA9IDFlLTgsXG4gICAgICAgICAgICAgICAgdE1heCA9IDEgLSB0TWluO1xuICAgICAgICAgICAgYWRkKHYzLCAwKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gcm9vdHNbaV0sXG4gICAgICAgICAgICAgICAgICB1ID0gMSAtIHQ7XG4gICAgICAgICAgICAgIGlmICh0TWluIDw9IHQgJiYgdCA8PSB0TWF4KSBhZGQodSAqIHUgKiB1ICogdjAgKyAzICogdSAqIHUgKiB0ICogdjEgKyAzICogdSAqIHQgKiB0ICogdjIgKyB0ICogdCAqIHQgKiB2MywgcGFkZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBCYXNlLmVhY2goWydnZXRCb3VuZHMnLCAnZ2V0U3Ryb2tlQm91bmRzJywgJ2dldEhhbmRsZUJvdW5kcyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2JvdW5kcykgdGhpcy5fYm91bmRzID0ge307XG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdO1xuXG4gICAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICBib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV0gPSBQYXRoW25hbWVdKFt0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDJdLCBmYWxzZSwgdGhpcy5fcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBib3VuZHMuY2xvbmUoKTtcbiAgICB9O1xuICB9LCB7fSksIEJhc2UuZWFjaCh7XG4gICAgaXNTdHJhaWdodDogZnVuY3Rpb24gKHAxLCBoMSwgaDIsIHAyKSB7XG4gICAgICBpZiAoaDEuaXNaZXJvKCkgJiYgaDIuaXNaZXJvKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdiA9IHAyLnN1YnRyYWN0KHAxKTtcblxuICAgICAgICBpZiAodi5pc1plcm8oKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh2LmlzQ29sbGluZWFyKGgxKSAmJiB2LmlzQ29sbGluZWFyKGgyKSkge1xuICAgICAgICAgIHZhciBsID0gbmV3IExpbmUocDEsIHAyKSxcbiAgICAgICAgICAgICAgZXBzaWxvbiA9IDFlLTc7XG5cbiAgICAgICAgICBpZiAobC5nZXREaXN0YW5jZShwMS5hZGQoaDEpKSA8IGVwc2lsb24gJiYgbC5nZXREaXN0YW5jZShwMi5hZGQoaDIpKSA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHZhciBkaXYgPSB2LmRvdCh2KSxcbiAgICAgICAgICAgICAgICBzMSA9IHYuZG90KGgxKSAvIGRpdixcbiAgICAgICAgICAgICAgICBzMiA9IHYuZG90KGgyKSAvIGRpdjtcbiAgICAgICAgICAgIHJldHVybiBzMSA+PSAwICYmIHMxIDw9IDEgJiYgczIgPD0gMCAmJiBzMiA+PSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNMaW5lYXI6IGZ1bmN0aW9uIChwMSwgaDEsIGgyLCBwMikge1xuICAgICAgdmFyIHRoaXJkID0gcDIuc3VidHJhY3QocDEpLmRpdmlkZSgzKTtcbiAgICAgIHJldHVybiBoMS5lcXVhbHModGhpcmQpICYmIGgyLm5lZ2F0ZSgpLmVxdWFscyh0aGlyZCk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAodGVzdCwgbmFtZSkge1xuICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoZXBzaWxvbikge1xuICAgICAgdmFyIHNlZzEgPSB0aGlzLl9zZWdtZW50MSxcbiAgICAgICAgICBzZWcyID0gdGhpcy5fc2VnbWVudDI7XG4gICAgICByZXR1cm4gdGVzdChzZWcxLl9wb2ludCwgc2VnMS5faGFuZGxlT3V0LCBzZWcyLl9oYW5kbGVJbiwgc2VnMi5fcG9pbnQsIGVwc2lsb24pO1xuICAgIH07XG5cbiAgICB0aGlzLnN0YXRpY3NbbmFtZV0gPSBmdW5jdGlvbiAodiwgZXBzaWxvbikge1xuICAgICAgdmFyIHgwID0gdlswXSxcbiAgICAgICAgICB5MCA9IHZbMV0sXG4gICAgICAgICAgeDMgPSB2WzZdLFxuICAgICAgICAgIHkzID0gdls3XTtcbiAgICAgIHJldHVybiB0ZXN0KG5ldyBQb2ludCh4MCwgeTApLCBuZXcgUG9pbnQodlsyXSAtIHgwLCB2WzNdIC0geTApLCBuZXcgUG9pbnQodls0XSAtIHgzLCB2WzVdIC0geTMpLCBuZXcgUG9pbnQoeDMsIHkzKSwgZXBzaWxvbik7XG4gICAgfTtcbiAgfSwge1xuICAgIHN0YXRpY3M6IHt9LFxuICAgIGhhc0hhbmRsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKSB8fCAhdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLmlzWmVybygpO1xuICAgIH0sXG4gICAgaGFzTGVuZ3RoOiBmdW5jdGlvbiAoZXBzaWxvbikge1xuICAgICAgcmV0dXJuICghdGhpcy5nZXRQb2ludDEoKS5lcXVhbHModGhpcy5nZXRQb2ludDIoKSkgfHwgdGhpcy5oYXNIYW5kbGVzKCkpICYmIHRoaXMuZ2V0TGVuZ3RoKCkgPiAoZXBzaWxvbiB8fCAwKTtcbiAgICB9LFxuICAgIGlzQ29sbGluZWFyOiBmdW5jdGlvbiAoY3VydmUpIHtcbiAgICAgIHJldHVybiBjdXJ2ZSAmJiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBjdXJ2ZS5pc1N0cmFpZ2h0KCkgJiYgdGhpcy5nZXRMaW5lKCkuaXNDb2xsaW5lYXIoY3VydmUuZ2V0TGluZSgpKTtcbiAgICB9LFxuICAgIGlzSG9yaXpvbnRhbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTdHJhaWdodCgpICYmIE1hdGguYWJzKHRoaXMuZ2V0VGFuZ2VudEF0VGltZSgwLjUpLnkpIDwgMWUtODtcbiAgICB9LFxuICAgIGlzVmVydGljYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBNYXRoLmFicyh0aGlzLmdldFRhbmdlbnRBdFRpbWUoMC41KS54KSA8IDFlLTg7XG4gICAgfVxuICB9KSwge1xuICAgIGJlYW5zOiBmYWxzZSxcbiAgICBnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbiAob2Zmc2V0LCBfaXNUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMb2NhdGlvbkF0VGltZShfaXNUaW1lID8gb2Zmc2V0IDogdGhpcy5nZXRUaW1lQXQob2Zmc2V0KSk7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbkF0VGltZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0ICE9IG51bGwgJiYgdCA+PSAwICYmIHQgPD0gMSA/IG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIHQpIDogbnVsbDtcbiAgICB9LFxuICAgIGdldFRpbWVBdDogZnVuY3Rpb24gKG9mZnNldCwgc3RhcnQpIHtcbiAgICAgIHJldHVybiBDdXJ2ZS5nZXRUaW1lQXQodGhpcy5nZXRWYWx1ZXMoKSwgb2Zmc2V0LCBzdGFydCk7XG4gICAgfSxcbiAgICBnZXRQYXJhbWV0ZXJBdDogJyNnZXRUaW1lQXQnLFxuICAgIGdldFRpbWVzV2l0aFRhbmdlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0YW5nZW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRhbmdlbnQuaXNaZXJvKCkgPyBbXSA6IEN1cnZlLmdldFRpbWVzV2l0aFRhbmdlbnQodGhpcy5nZXRWYWx1ZXMoKSwgdGFuZ2VudCk7XG4gICAgfSxcbiAgICBnZXRPZmZzZXRBdFRpbWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQYXJ0TGVuZ3RoKDAsIHQpO1xuICAgIH0sXG4gICAgZ2V0TG9jYXRpb25PZjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9jYXRpb25BdFRpbWUodGhpcy5nZXRUaW1lT2YoUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG4gICAgfSxcbiAgICBnZXRPZmZzZXRPZjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG4gICAgfSxcbiAgICBnZXRUaW1lT2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBDdXJ2ZS5nZXRUaW1lT2YodGhpcy5nZXRWYWx1ZXMoKSwgUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGdldFBhcmFtZXRlck9mOiAnI2dldFRpbWVPZicsXG4gICAgZ2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKSxcbiAgICAgICAgICB0ID0gQ3VydmUuZ2V0TmVhcmVzdFRpbWUodmFsdWVzLCBwb2ludCksXG4gICAgICAgICAgcHQgPSBDdXJ2ZS5nZXRQb2ludCh2YWx1ZXMsIHQpO1xuICAgICAgcmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIHQsIHB0LCBudWxsLCBwb2ludC5nZXREaXN0YW5jZShwdCkpO1xuICAgIH0sXG4gICAgZ2V0TmVhcmVzdFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBsb2MgPyBsb2MuZ2V0UG9pbnQoKSA6IGxvYztcbiAgICB9XG4gIH0sIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1ldGhvZHMgPSBbJ2dldFBvaW50JywgJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldFdlaWdodGVkVGFuZ2VudCcsICdnZXRXZWlnaHRlZE5vcm1hbCcsICdnZXRDdXJ2YXR1cmUnXTtcbiAgICByZXR1cm4gQmFzZS5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgX2lzVGltZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKTtcbiAgICAgICAgcmV0dXJuIEN1cnZlW25hbWVdKHZhbHVlcywgX2lzVGltZSA/IGxvY2F0aW9uIDogQ3VydmUuZ2V0VGltZUF0KHZhbHVlcywgbG9jYXRpb24pKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXNbbmFtZSArICdBdFRpbWUnXSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHJldHVybiBDdXJ2ZVtuYW1lXSh0aGlzLmdldFZhbHVlcygpLCB0aW1lKTtcbiAgICAgIH07XG4gICAgfSwge1xuICAgICAgc3RhdGljczoge1xuICAgICAgICBfZXZhbHVhdGVNZXRob2RzOiBtZXRob2RzXG4gICAgICB9XG4gICAgfSk7XG4gIH0oKSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRMZW5ndGhJbnRlZ3JhbmQodikge1xuICAgICAgdmFyIHgwID0gdlswXSxcbiAgICAgICAgICB5MCA9IHZbMV0sXG4gICAgICAgICAgeDEgPSB2WzJdLFxuICAgICAgICAgIHkxID0gdlszXSxcbiAgICAgICAgICB4MiA9IHZbNF0sXG4gICAgICAgICAgeTIgPSB2WzVdLFxuICAgICAgICAgIHgzID0gdls2XSxcbiAgICAgICAgICB5MyA9IHZbN10sXG4gICAgICAgICAgYXggPSA5ICogKHgxIC0geDIpICsgMyAqICh4MyAtIHgwKSxcbiAgICAgICAgICBieCA9IDYgKiAoeDAgKyB4MikgLSAxMiAqIHgxLFxuICAgICAgICAgIGN4ID0gMyAqICh4MSAtIHgwKSxcbiAgICAgICAgICBheSA9IDkgKiAoeTEgLSB5MikgKyAzICogKHkzIC0geTApLFxuICAgICAgICAgIGJ5ID0gNiAqICh5MCArIHkyKSAtIDEyICogeTEsXG4gICAgICAgICAgY3kgPSAzICogKHkxIC0geTApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBkeCA9IChheCAqIHQgKyBieCkgKiB0ICsgY3gsXG4gICAgICAgICAgICBkeSA9IChheSAqIHQgKyBieSkgKiB0ICsgY3k7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRpb25zKGEsIGIpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgyLCBNYXRoLm1pbigxNiwgTWF0aC5jZWlsKE1hdGguYWJzKGIgLSBhKSAqIDMyKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV2YWx1YXRlKHYsIHQsIHR5cGUsIG5vcm1hbGl6ZWQpIHtcbiAgICAgIGlmICh0ID09IG51bGwgfHwgdCA8IDAgfHwgdCA+IDEpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHgwID0gdlswXSxcbiAgICAgICAgICB5MCA9IHZbMV0sXG4gICAgICAgICAgeDEgPSB2WzJdLFxuICAgICAgICAgIHkxID0gdlszXSxcbiAgICAgICAgICB4MiA9IHZbNF0sXG4gICAgICAgICAgeTIgPSB2WzVdLFxuICAgICAgICAgIHgzID0gdls2XSxcbiAgICAgICAgICB5MyA9IHZbN10sXG4gICAgICAgICAgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblxuICAgICAgaWYgKGlzWmVybyh4MSAtIHgwKSAmJiBpc1plcm8oeTEgLSB5MCkpIHtcbiAgICAgICAgeDEgPSB4MDtcbiAgICAgICAgeTEgPSB5MDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzWmVybyh4MiAtIHgzKSAmJiBpc1plcm8oeTIgLSB5MykpIHtcbiAgICAgICAgeDIgPSB4MztcbiAgICAgICAgeTIgPSB5MztcbiAgICAgIH1cblxuICAgICAgdmFyIGN4ID0gMyAqICh4MSAtIHgwKSxcbiAgICAgICAgICBieCA9IDMgKiAoeDIgLSB4MSkgLSBjeCxcbiAgICAgICAgICBheCA9IHgzIC0geDAgLSBjeCAtIGJ4LFxuICAgICAgICAgIGN5ID0gMyAqICh5MSAtIHkwKSxcbiAgICAgICAgICBieSA9IDMgKiAoeTIgLSB5MSkgLSBjeSxcbiAgICAgICAgICBheSA9IHkzIC0geTAgLSBjeSAtIGJ5LFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeTtcblxuICAgICAgaWYgKHR5cGUgPT09IDApIHtcbiAgICAgICAgeCA9IHQgPT09IDAgPyB4MCA6IHQgPT09IDEgPyB4MyA6ICgoYXggKiB0ICsgYngpICogdCArIGN4KSAqIHQgKyB4MDtcbiAgICAgICAgeSA9IHQgPT09IDAgPyB5MCA6IHQgPT09IDEgPyB5MyA6ICgoYXkgKiB0ICsgYnkpICogdCArIGN5KSAqIHQgKyB5MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0TWluID0gMWUtOCxcbiAgICAgICAgICAgIHRNYXggPSAxIC0gdE1pbjtcblxuICAgICAgICBpZiAodCA8IHRNaW4pIHtcbiAgICAgICAgICB4ID0gY3g7XG4gICAgICAgICAgeSA9IGN5O1xuICAgICAgICB9IGVsc2UgaWYgKHQgPiB0TWF4KSB7XG4gICAgICAgICAgeCA9IDMgKiAoeDMgLSB4Mik7XG4gICAgICAgICAgeSA9IDMgKiAoeTMgLSB5Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9ICgzICogYXggKiB0ICsgMiAqIGJ4KSAqIHQgKyBjeDtcbiAgICAgICAgICB5ID0gKDMgKiBheSAqIHQgKyAyICogYnkpICogdCArIGN5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwICYmICh0IDwgdE1pbiB8fCB0ID4gdE1heCkpIHtcbiAgICAgICAgICAgIHggPSB4MiAtIHgxO1xuICAgICAgICAgICAgeSA9IHkyIC0geTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblxuICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgIHggLz0gbGVuO1xuICAgICAgICAgICAgeSAvPSBsZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IDMpIHtcbiAgICAgICAgICB2YXIgeDIgPSA2ICogYXggKiB0ICsgMiAqIGJ4LFxuICAgICAgICAgICAgICB5MiA9IDYgKiBheSAqIHQgKyAyICogYnksXG4gICAgICAgICAgICAgIGQgPSBNYXRoLnBvdyh4ICogeCArIHkgKiB5LCAzIC8gMik7XG4gICAgICAgICAgeCA9IGQgIT09IDAgPyAoeCAqIHkyIC0geSAqIHgyKSAvIGQgOiAwO1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlID09PSAyID8gbmV3IFBvaW50KHksIC14KSA6IG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGljczoge1xuICAgICAgICBjbGFzc2lmeTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICB2YXIgeDAgPSB2WzBdLFxuICAgICAgICAgICAgICB5MCA9IHZbMV0sXG4gICAgICAgICAgICAgIHgxID0gdlsyXSxcbiAgICAgICAgICAgICAgeTEgPSB2WzNdLFxuICAgICAgICAgICAgICB4MiA9IHZbNF0sXG4gICAgICAgICAgICAgIHkyID0gdls1XSxcbiAgICAgICAgICAgICAgeDMgPSB2WzZdLFxuICAgICAgICAgICAgICB5MyA9IHZbN10sXG4gICAgICAgICAgICAgIGExID0geDAgKiAoeTMgLSB5MikgKyB5MCAqICh4MiAtIHgzKSArIHgzICogeTIgLSB5MyAqIHgyLFxuICAgICAgICAgICAgICBhMiA9IHgxICogKHkwIC0geTMpICsgeTEgKiAoeDMgLSB4MCkgKyB4MCAqIHkzIC0geTAgKiB4MyxcbiAgICAgICAgICAgICAgYTMgPSB4MiAqICh5MSAtIHkwKSArIHkyICogKHgwIC0geDEpICsgeDEgKiB5MCAtIHkxICogeDAsXG4gICAgICAgICAgICAgIGQzID0gMyAqIGEzLFxuICAgICAgICAgICAgICBkMiA9IGQzIC0gYTIsXG4gICAgICAgICAgICAgIGQxID0gZDIgLSBhMiArIGExLFxuICAgICAgICAgICAgICBsID0gTWF0aC5zcXJ0KGQxICogZDEgKyBkMiAqIGQyICsgZDMgKiBkMyksXG4gICAgICAgICAgICAgIHMgPSBsICE9PSAwID8gMSAvIGwgOiAwLFxuICAgICAgICAgICAgICBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvLFxuICAgICAgICAgICAgICBzZXJwZW50aW5lID0gJ3NlcnBlbnRpbmUnO1xuICAgICAgICAgIGQxICo9IHM7XG4gICAgICAgICAgZDIgKj0gcztcbiAgICAgICAgICBkMyAqPSBzO1xuXG4gICAgICAgICAgZnVuY3Rpb24gdHlwZSh0eXBlLCB0MSwgdDIpIHtcbiAgICAgICAgICAgIHZhciBoYXNSb290cyA9IHQxICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdDFPayA9IGhhc1Jvb3RzICYmIHQxID4gMCAmJiB0MSA8IDEsXG4gICAgICAgICAgICAgICAgdDJPayA9IGhhc1Jvb3RzICYmIHQyID4gMCAmJiB0MiA8IDE7XG5cbiAgICAgICAgICAgIGlmIChoYXNSb290cyAmJiAoISh0MU9rIHx8IHQyT2spIHx8IHR5cGUgPT09ICdsb29wJyAmJiAhKHQxT2sgJiYgdDJPaykpKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSAnYXJjaCc7XG4gICAgICAgICAgICAgIHQxT2sgPSB0Mk9rID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIHJvb3RzOiB0MU9rIHx8IHQyT2sgPyB0MU9rICYmIHQyT2sgPyB0MSA8IHQyID8gW3QxLCB0Ml0gOiBbdDIsIHQxXSA6IFt0MU9rID8gdDEgOiB0Ml0gOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1plcm8oZDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNaZXJvKGQyKSA/IHR5cGUoaXNaZXJvKGQzKSA/ICdsaW5lJyA6ICdxdWFkcmF0aWMnKSA6IHR5cGUoc2VycGVudGluZSwgZDMgLyAoMyAqIGQyKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGQgPSAzICogZDIgKiBkMiAtIDQgKiBkMSAqIGQzO1xuXG4gICAgICAgICAgaWYgKGlzWmVybyhkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUoJ2N1c3AnLCBkMiAvICgyICogZDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZjEgPSBkID4gMCA/IE1hdGguc3FydChkIC8gMykgOiBNYXRoLnNxcnQoLWQpLFxuICAgICAgICAgICAgICBmMiA9IDIgKiBkMTtcbiAgICAgICAgICByZXR1cm4gdHlwZShkID4gMCA/IHNlcnBlbnRpbmUgOiAnbG9vcCcsIChkMiArIGYxKSAvIGYyLCAoZDIgLSBmMSkgLyBmMik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldExlbmd0aDogZnVuY3Rpb24gKHYsIGEsIGIsIGRzKSB7XG4gICAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgYSA9IDA7XG4gICAgICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkgYiA9IDE7XG5cbiAgICAgICAgICBpZiAoQ3VydmUuaXNTdHJhaWdodCh2KSkge1xuICAgICAgICAgICAgdmFyIGMgPSB2O1xuXG4gICAgICAgICAgICBpZiAoYiA8IDEpIHtcbiAgICAgICAgICAgICAgYyA9IEN1cnZlLnN1YmRpdmlkZShjLCBiKVswXTtcbiAgICAgICAgICAgICAgYSAvPSBiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYSA+IDApIHtcbiAgICAgICAgICAgICAgYyA9IEN1cnZlLnN1YmRpdmlkZShjLCBhKVsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGR4ID0gY1s2XSAtIGNbMF0sXG4gICAgICAgICAgICAgICAgZHkgPSBjWzddIC0gY1sxXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBOdW1lcmljYWwuaW50ZWdyYXRlKGRzIHx8IGdldExlbmd0aEludGVncmFuZCh2KSwgYSwgYiwgZ2V0SXRlcmF0aW9ucyhhLCBiKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRpbWVBdDogZnVuY3Rpb24gKHYsIG9mZnNldCwgc3RhcnQpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgc3RhcnQgPSBvZmZzZXQgPCAwID8gMSA6IDA7XG4gICAgICAgICAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIHN0YXJ0O1xuICAgICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICAgICAgZXBzaWxvbiA9IDFlLTEyLFxuICAgICAgICAgICAgICBmb3J3YXJkID0gb2Zmc2V0ID4gMCxcbiAgICAgICAgICAgICAgYSA9IGZvcndhcmQgPyBzdGFydCA6IDAsXG4gICAgICAgICAgICAgIGIgPSBmb3J3YXJkID8gMSA6IHN0YXJ0LFxuICAgICAgICAgICAgICBkcyA9IGdldExlbmd0aEludGVncmFuZCh2KSxcbiAgICAgICAgICAgICAgcmFuZ2VMZW5ndGggPSBDdXJ2ZS5nZXRMZW5ndGgodiwgYSwgYiwgZHMpLFxuICAgICAgICAgICAgICBkaWZmID0gYWJzKG9mZnNldCkgLSByYW5nZUxlbmd0aDtcblxuICAgICAgICAgIGlmIChhYnMoZGlmZikgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9yd2FyZCA/IGIgOiBhO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBndWVzcyA9IG9mZnNldCAvIHJhbmdlTGVuZ3RoLFxuICAgICAgICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZih0KSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gTnVtZXJpY2FsLmludGVncmF0ZShkcywgc3RhcnQsIHQsIGdldEl0ZXJhdGlvbnMoc3RhcnQsIHQpKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gdDtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcywgc3RhcnQgKyBndWVzcywgYSwgYiwgMzIsIDFlLTEyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uICh2LCB0KSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKHYsIHQsIDAsIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VGFuZ2VudDogZnVuY3Rpb24gKHYsIHQpIHtcbiAgICAgICAgICByZXR1cm4gZXZhbHVhdGUodiwgdCwgMSwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFdlaWdodGVkVGFuZ2VudDogZnVuY3Rpb24gKHYsIHQpIHtcbiAgICAgICAgICByZXR1cm4gZXZhbHVhdGUodiwgdCwgMSwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBnZXROb3JtYWw6IGZ1bmN0aW9uICh2LCB0KSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKHYsIHQsIDIsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXZWlnaHRlZE5vcm1hbDogZnVuY3Rpb24gKHYsIHQpIHtcbiAgICAgICAgICByZXR1cm4gZXZhbHVhdGUodiwgdCwgMiwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDdXJ2YXR1cmU6IGZ1bmN0aW9uICh2LCB0KSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWx1YXRlKHYsIHQsIDMsIGZhbHNlKS54O1xuICAgICAgICB9LFxuICAgICAgICBnZXRQZWFrczogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICB2YXIgeDAgPSB2WzBdLFxuICAgICAgICAgICAgICB5MCA9IHZbMV0sXG4gICAgICAgICAgICAgIHgxID0gdlsyXSxcbiAgICAgICAgICAgICAgeTEgPSB2WzNdLFxuICAgICAgICAgICAgICB4MiA9IHZbNF0sXG4gICAgICAgICAgICAgIHkyID0gdls1XSxcbiAgICAgICAgICAgICAgeDMgPSB2WzZdLFxuICAgICAgICAgICAgICB5MyA9IHZbN10sXG4gICAgICAgICAgICAgIGF4ID0gLXgwICsgMyAqIHgxIC0gMyAqIHgyICsgeDMsXG4gICAgICAgICAgICAgIGJ4ID0gMyAqIHgwIC0gNiAqIHgxICsgMyAqIHgyLFxuICAgICAgICAgICAgICBjeCA9IC0zICogeDAgKyAzICogeDEsXG4gICAgICAgICAgICAgIGF5ID0gLXkwICsgMyAqIHkxIC0gMyAqIHkyICsgeTMsXG4gICAgICAgICAgICAgIGJ5ID0gMyAqIHkwIC0gNiAqIHkxICsgMyAqIHkyLFxuICAgICAgICAgICAgICBjeSA9IC0zICogeTAgKyAzICogeTEsXG4gICAgICAgICAgICAgIHRNaW4gPSAxZS04LFxuICAgICAgICAgICAgICB0TWF4ID0gMSAtIHRNaW4sXG4gICAgICAgICAgICAgIHJvb3RzID0gW107XG4gICAgICAgICAgTnVtZXJpY2FsLnNvbHZlQ3ViaWMoOSAqIChheCAqIGF4ICsgYXkgKiBheSksIDkgKiAoYXggKiBieCArIGJ5ICogYXkpLCAyICogKGJ4ICogYnggKyBieSAqIGJ5KSArIDMgKiAoY3ggKiBheCArIGN5ICogYXkpLCBjeCAqIGJ4ICsgYnkgKiBjeSwgcm9vdHMsIHRNaW4sIHRNYXgpO1xuICAgICAgICAgIHJldHVybiByb290cy5zb3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KCksIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgdDEsIGMyLCB0Miwgb3ZlcmxhcCkge1xuICAgICAgdmFyIGV4Y2x1ZGVTdGFydCA9ICFvdmVybGFwICYmIGMxLmdldFByZXZpb3VzKCkgPT09IGMyLFxuICAgICAgICAgIGV4Y2x1ZGVFbmQgPSAhb3ZlcmxhcCAmJiBjMSAhPT0gYzIgJiYgYzEuZ2V0TmV4dCgpID09PSBjMixcbiAgICAgICAgICB0TWluID0gMWUtOCxcbiAgICAgICAgICB0TWF4ID0gMSAtIHRNaW47XG5cbiAgICAgIGlmICh0MSAhPT0gbnVsbCAmJiB0MSA+PSAoZXhjbHVkZVN0YXJ0ID8gdE1pbiA6IDApICYmIHQxIDw9IChleGNsdWRlRW5kID8gdE1heCA6IDEpKSB7XG4gICAgICAgIGlmICh0MiAhPT0gbnVsbCAmJiB0MiA+PSAoZXhjbHVkZUVuZCA/IHRNaW4gOiAwKSAmJiB0MiA8PSAoZXhjbHVkZVN0YXJ0ID8gdE1heCA6IDEpKSB7XG4gICAgICAgICAgdmFyIGxvYzEgPSBuZXcgQ3VydmVMb2NhdGlvbihjMSwgdDEsIG51bGwsIG92ZXJsYXApLFxuICAgICAgICAgICAgICBsb2MyID0gbmV3IEN1cnZlTG9jYXRpb24oYzIsIHQyLCBudWxsLCBvdmVybGFwKTtcbiAgICAgICAgICBsb2MxLl9pbnRlcnNlY3Rpb24gPSBsb2MyO1xuICAgICAgICAgIGxvYzIuX2ludGVyc2VjdGlvbiA9IGxvYzE7XG5cbiAgICAgICAgICBpZiAoIWluY2x1ZGUgfHwgaW5jbHVkZShsb2MxKSkge1xuICAgICAgICAgICAgQ3VydmVMb2NhdGlvbi5pbnNlcnQobG9jYXRpb25zLCBsb2MxLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCwgcmVjdXJzaW9uLCBjYWxscywgdE1pbiwgdE1heCwgdU1pbiwgdU1heCkge1xuICAgICAgaWYgKCsrY2FsbHMgPj0gNDA5NiB8fCArK3JlY3Vyc2lvbiA+PSA0MCkgcmV0dXJuIGNhbGxzO1xuICAgICAgdmFyIGZhdExpbmVFcHNpbG9uID0gMWUtOSxcbiAgICAgICAgICBxMHggPSB2MlswXSxcbiAgICAgICAgICBxMHkgPSB2MlsxXSxcbiAgICAgICAgICBxM3ggPSB2Mls2XSxcbiAgICAgICAgICBxM3kgPSB2Mls3XSxcbiAgICAgICAgICBnZXRTaWduZWREaXN0YW5jZSA9IExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UsXG4gICAgICAgICAgZDEgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzJdLCB2MlszXSksXG4gICAgICAgICAgZDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzRdLCB2Mls1XSksXG4gICAgICAgICAgZmFjdG9yID0gZDEgKiBkMiA+IDAgPyAzIC8gNCA6IDQgLyA5LFxuICAgICAgICAgIGRNaW4gPSBmYWN0b3IgKiBNYXRoLm1pbigwLCBkMSwgZDIpLFxuICAgICAgICAgIGRNYXggPSBmYWN0b3IgKiBNYXRoLm1heCgwLCBkMSwgZDIpLFxuICAgICAgICAgIGRwMCA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbMF0sIHYxWzFdKSxcbiAgICAgICAgICBkcDEgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzJdLCB2MVszXSksXG4gICAgICAgICAgZHAyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs0XSwgdjFbNV0pLFxuICAgICAgICAgIGRwMyA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbNl0sIHYxWzddKSxcbiAgICAgICAgICBodWxsID0gZ2V0Q29udmV4SHVsbChkcDAsIGRwMSwgZHAyLCBkcDMpLFxuICAgICAgICAgIHRvcCA9IGh1bGxbMF0sXG4gICAgICAgICAgYm90dG9tID0gaHVsbFsxXSxcbiAgICAgICAgICB0TWluQ2xpcCxcbiAgICAgICAgICB0TWF4Q2xpcDtcbiAgICAgIGlmIChkMSA9PT0gMCAmJiBkMiA9PT0gMCAmJiBkcDAgPT09IDAgJiYgZHAxID09PSAwICYmIGRwMiA9PT0gMCAmJiBkcDMgPT09IDAgfHwgKHRNaW5DbGlwID0gY2xpcENvbnZleEh1bGwodG9wLCBib3R0b20sIGRNaW4sIGRNYXgpKSA9PSBudWxsIHx8ICh0TWF4Q2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcC5yZXZlcnNlKCksIGJvdHRvbS5yZXZlcnNlKCksIGRNaW4sIGRNYXgpKSA9PSBudWxsKSByZXR1cm4gY2FsbHM7XG4gICAgICB2YXIgdE1pbk5ldyA9IHRNaW4gKyAodE1heCAtIHRNaW4pICogdE1pbkNsaXAsXG4gICAgICAgICAgdE1heE5ldyA9IHRNaW4gKyAodE1heCAtIHRNaW4pICogdE1heENsaXA7XG5cbiAgICAgIGlmIChNYXRoLm1heCh1TWF4IC0gdU1pbiwgdE1heE5ldyAtIHRNaW5OZXcpIDwgZmF0TGluZUVwc2lsb24pIHtcbiAgICAgICAgdmFyIHQgPSAodE1pbk5ldyArIHRNYXhOZXcpIC8gMixcbiAgICAgICAgICAgIHUgPSAodU1pbiArIHVNYXgpIC8gMjtcbiAgICAgICAgYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBmbGlwID8gYzIgOiBjMSwgZmxpcCA/IHUgOiB0LCBmbGlwID8gYzEgOiBjMiwgZmxpcCA/IHQgOiB1KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYxID0gQ3VydmUuZ2V0UGFydCh2MSwgdE1pbkNsaXAsIHRNYXhDbGlwKTtcbiAgICAgICAgdmFyIHVEaWZmID0gdU1heCAtIHVNaW47XG5cbiAgICAgICAgaWYgKHRNYXhDbGlwIC0gdE1pbkNsaXAgPiAwLjgpIHtcbiAgICAgICAgICBpZiAodE1heE5ldyAtIHRNaW5OZXcgPiB1RGlmZikge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYxLCAwLjUpLFxuICAgICAgICAgICAgICAgIHQgPSAodE1pbk5ldyArIHRNYXhOZXcpIC8gMjtcbiAgICAgICAgICAgIGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYyLCBwYXJ0c1swXSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLCByZWN1cnNpb24sIGNhbGxzLCB1TWluLCB1TWF4LCB0TWluTmV3LCB0KTtcbiAgICAgICAgICAgIGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYyLCBwYXJ0c1sxXSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLCByZWN1cnNpb24sIGNhbGxzLCB1TWluLCB1TWF4LCB0LCB0TWF4TmV3KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYyLCAwLjUpLFxuICAgICAgICAgICAgICAgIHUgPSAodU1pbiArIHVNYXgpIC8gMjtcbiAgICAgICAgICAgIGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHBhcnRzWzBdLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLCByZWN1cnNpb24sIGNhbGxzLCB1TWluLCB1LCB0TWluTmV3LCB0TWF4TmV3KTtcbiAgICAgICAgICAgIGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHBhcnRzWzFdLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLCByZWN1cnNpb24sIGNhbGxzLCB1LCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHVEaWZmID09PSAwIHx8IHVEaWZmID49IGZhdExpbmVFcHNpbG9uKSB7XG4gICAgICAgICAgICBjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MiwgdjEsIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCwgcmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdU1heCwgdE1pbk5ldywgdE1heE5ldyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUsIGZsaXAsIHJlY3Vyc2lvbiwgY2FsbHMsIHRNaW5OZXcsIHRNYXhOZXcsIHVNaW4sIHVNYXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29udmV4SHVsbChkcTAsIGRxMSwgZHEyLCBkcTMpIHtcbiAgICAgIHZhciBwMCA9IFswLCBkcTBdLFxuICAgICAgICAgIHAxID0gWzEgLyAzLCBkcTFdLFxuICAgICAgICAgIHAyID0gWzIgLyAzLCBkcTJdLFxuICAgICAgICAgIHAzID0gWzEsIGRxM10sXG4gICAgICAgICAgZGlzdDEgPSBkcTEgLSAoMiAqIGRxMCArIGRxMykgLyAzLFxuICAgICAgICAgIGRpc3QyID0gZHEyIC0gKGRxMCArIDIgKiBkcTMpIC8gMyxcbiAgICAgICAgICBodWxsO1xuXG4gICAgICBpZiAoZGlzdDEgKiBkaXN0MiA8IDApIHtcbiAgICAgICAgaHVsbCA9IFtbcDAsIHAxLCBwM10sIFtwMCwgcDIsIHAzXV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlzdFJhdGlvID0gZGlzdDEgLyBkaXN0MjtcbiAgICAgICAgaHVsbCA9IFtkaXN0UmF0aW8gPj0gMiA/IFtwMCwgcDEsIHAzXSA6IGRpc3RSYXRpbyA8PSAwLjUgPyBbcDAsIHAyLCBwM10gOiBbcDAsIHAxLCBwMiwgcDNdLCBbcDAsIHAzXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoZGlzdDEgfHwgZGlzdDIpIDwgMCA/IGh1bGwucmV2ZXJzZSgpIDogaHVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGlwQ29udmV4SHVsbChodWxsVG9wLCBodWxsQm90dG9tLCBkTWluLCBkTWF4KSB7XG4gICAgICBpZiAoaHVsbFRvcFswXVsxXSA8IGRNaW4pIHtcbiAgICAgICAgcmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsVG9wLCB0cnVlLCBkTWluKTtcbiAgICAgIH0gZWxzZSBpZiAoaHVsbEJvdHRvbVswXVsxXSA+IGRNYXgpIHtcbiAgICAgICAgcmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsQm90dG9tLCBmYWxzZSwgZE1heCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaHVsbFRvcFswXVswXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGlwQ29udmV4SHVsbFBhcnQocGFydCwgdG9wLCB0aHJlc2hvbGQpIHtcbiAgICAgIHZhciBweCA9IHBhcnRbMF1bMF0sXG4gICAgICAgICAgcHkgPSBwYXJ0WzBdWzFdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBhcnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBxeCA9IHBhcnRbaV1bMF0sXG4gICAgICAgICAgICBxeSA9IHBhcnRbaV1bMV07XG5cbiAgICAgICAgaWYgKHRvcCA/IHF5ID49IHRocmVzaG9sZCA6IHF5IDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybiBxeSA9PT0gdGhyZXNob2xkID8gcXggOiBweCArICh0aHJlc2hvbGQgLSBweSkgKiAocXggLSBweCkgLyAocXkgLSBweSk7XG4gICAgICAgIH1cblxuICAgICAgICBweCA9IHF4O1xuICAgICAgICBweSA9IHF5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYsIHB4LCBweSwgdngsIHZ5KSB7XG4gICAgICB2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblxuICAgICAgaWYgKGlzWmVybyh2eCkgJiYgaXNaZXJvKHZ5KSkge1xuICAgICAgICB2YXIgdCA9IEN1cnZlLmdldFRpbWVPZih2LCBuZXcgUG9pbnQocHgsIHB5KSk7XG4gICAgICAgIHJldHVybiB0ID09PSBudWxsID8gW10gOiBbdF07XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoLXZ5LCB2eCksXG4gICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICBydiA9IFtdLFxuICAgICAgICAgIHJvb3RzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG4gICAgICAgIHZhciB4ID0gdltpXSAtIHB4LFxuICAgICAgICAgICAgeSA9IHZbaSArIDFdIC0gcHk7XG4gICAgICAgIHJ2LnB1c2goeCAqIGNvcyAtIHkgKiBzaW4sIHggKiBzaW4gKyB5ICogY29zKTtcbiAgICAgIH1cblxuICAgICAgQ3VydmUuc29sdmVDdWJpYyhydiwgMSwgMCwgcm9vdHMsIDAsIDEpO1xuICAgICAgcmV0dXJuIHJvb3RzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCkge1xuICAgICAgdmFyIHgxID0gdjJbMF0sXG4gICAgICAgICAgeTEgPSB2MlsxXSxcbiAgICAgICAgICB4MiA9IHYyWzZdLFxuICAgICAgICAgIHkyID0gdjJbN10sXG4gICAgICAgICAgcm9vdHMgPSBnZXRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgdDEgPSByb290c1tpXSxcbiAgICAgICAgICAgIHAxID0gQ3VydmUuZ2V0UG9pbnQodjEsIHQxKSxcbiAgICAgICAgICAgIHQyID0gQ3VydmUuZ2V0VGltZU9mKHYyLCBwMSk7XG5cbiAgICAgICAgaWYgKHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBmbGlwID8gYzIgOiBjMSwgZmxpcCA/IHQyIDogdDEsIGZsaXAgPyBjMSA6IGMyLCBmbGlwID8gdDEgOiB0Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRMaW5lSW50ZXJzZWN0aW9uKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcbiAgICAgIHZhciBwdCA9IExpbmUuaW50ZXJzZWN0KHYxWzBdLCB2MVsxXSwgdjFbNl0sIHYxWzddLCB2MlswXSwgdjJbMV0sIHYyWzZdLCB2Mls3XSk7XG5cbiAgICAgIGlmIChwdCkge1xuICAgICAgICBhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGMxLCBDdXJ2ZS5nZXRUaW1lT2YodjEsIHB0KSwgYzIsIEN1cnZlLmdldFRpbWVPZih2MiwgcHQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuICAgICAgdmFyIGVwc2lsb24gPSAxZS0xMixcbiAgICAgICAgICBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgICBtYXggPSBNYXRoLm1heDtcblxuICAgICAgaWYgKG1heCh2MVswXSwgdjFbMl0sIHYxWzRdLCB2MVs2XSkgKyBlcHNpbG9uID4gbWluKHYyWzBdLCB2MlsyXSwgdjJbNF0sIHYyWzZdKSAmJiBtaW4odjFbMF0sIHYxWzJdLCB2MVs0XSwgdjFbNl0pIC0gZXBzaWxvbiA8IG1heCh2MlswXSwgdjJbMl0sIHYyWzRdLCB2Mls2XSkgJiYgbWF4KHYxWzFdLCB2MVszXSwgdjFbNV0sIHYxWzddKSArIGVwc2lsb24gPiBtaW4odjJbMV0sIHYyWzNdLCB2Mls1XSwgdjJbN10pICYmIG1pbih2MVsxXSwgdjFbM10sIHYxWzVdLCB2MVs3XSkgLSBlcHNpbG9uIDwgbWF4KHYyWzFdLCB2MlszXSwgdjJbNV0sIHYyWzddKSkge1xuICAgICAgICB2YXIgb3ZlcmxhcHMgPSBnZXRPdmVybGFwcyh2MSwgdjIpO1xuXG4gICAgICAgIGlmIChvdmVybGFwcykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcCA9IG92ZXJsYXBzW2ldO1xuICAgICAgICAgICAgYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgb3ZlcmxhcFswXSwgYzIsIG92ZXJsYXBbMV0sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RyYWlnaHQxID0gQ3VydmUuaXNTdHJhaWdodCh2MSksXG4gICAgICAgICAgICAgIHN0cmFpZ2h0MiA9IEN1cnZlLmlzU3RyYWlnaHQodjIpLFxuICAgICAgICAgICAgICBzdHJhaWdodCA9IHN0cmFpZ2h0MSAmJiBzdHJhaWdodDIsXG4gICAgICAgICAgICAgIGZsaXAgPSBzdHJhaWdodDEgJiYgIXN0cmFpZ2h0MixcbiAgICAgICAgICAgICAgYmVmb3JlID0gbG9jYXRpb25zLmxlbmd0aDtcbiAgICAgICAgICAoc3RyYWlnaHQgPyBhZGRMaW5lSW50ZXJzZWN0aW9uIDogc3RyYWlnaHQxIHx8IHN0cmFpZ2h0MiA/IGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnMgOiBhZGRDdXJ2ZUludGVyc2VjdGlvbnMpKGZsaXAgPyB2MiA6IHYxLCBmbGlwID8gdjEgOiB2MiwgZmxpcCA/IGMyIDogYzEsIGZsaXAgPyBjMSA6IGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUsIGZsaXAsIDAsIDAsIDAsIDEsIDAsIDEpO1xuXG4gICAgICAgICAgaWYgKCFzdHJhaWdodCB8fCBsb2NhdGlvbnMubGVuZ3RoID09PSBiZWZvcmUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciB0MSA9IGkgPj4gMSxcbiAgICAgICAgICAgICAgICAgIHQyID0gaSAmIDEsXG4gICAgICAgICAgICAgICAgICBpMSA9IHQxICogNixcbiAgICAgICAgICAgICAgICAgIGkyID0gdDIgKiA2LFxuICAgICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQodjFbaTFdLCB2MVtpMSArIDFdKSxcbiAgICAgICAgICAgICAgICAgIHAyID0gbmV3IFBvaW50KHYyW2kyXSwgdjJbaTIgKyAxXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHAxLmlzQ2xvc2UocDIsIGVwc2lsb24pKSB7XG4gICAgICAgICAgICAgICAgYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgdDEsIGMyLCB0Mik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvY2F0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZWxmSW50ZXJzZWN0aW9uKHYxLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG4gICAgICB2YXIgaW5mbyA9IEN1cnZlLmNsYXNzaWZ5KHYxKTtcblxuICAgICAgaWYgKGluZm8udHlwZSA9PT0gJ2xvb3AnKSB7XG4gICAgICAgIHZhciByb290cyA9IGluZm8ucm9vdHM7XG4gICAgICAgIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgYzEsIHJvb3RzWzBdLCBjMSwgcm9vdHNbMV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9jYXRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbnMoY3VydmVzMSwgY3VydmVzMiwgaW5jbHVkZSwgbWF0cml4MSwgbWF0cml4MiwgX3JldHVybkZpcnN0KSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IDFlLTcsXG4gICAgICAgICAgc2VsZiA9ICFjdXJ2ZXMyO1xuICAgICAgaWYgKHNlbGYpIGN1cnZlczIgPSBjdXJ2ZXMxO1xuICAgICAgdmFyIGxlbmd0aDEgPSBjdXJ2ZXMxLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGgyID0gY3VydmVzMi5sZW5ndGgsXG4gICAgICAgICAgdmFsdWVzMSA9IG5ldyBBcnJheShsZW5ndGgxKSxcbiAgICAgICAgICB2YWx1ZXMyID0gc2VsZiA/IHZhbHVlczEgOiBuZXcgQXJyYXkobGVuZ3RoMiksXG4gICAgICAgICAgbG9jYXRpb25zID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIHZhbHVlczFbaV0gPSBjdXJ2ZXMxW2ldLmdldFZhbHVlcyhtYXRyaXgxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgdmFsdWVzMltpXSA9IGN1cnZlczJbaV0uZ2V0VmFsdWVzKG1hdHJpeDIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBib3VuZHNDb2xsaXNpb25zID0gQ29sbGlzaW9uRGV0ZWN0aW9uLmZpbmRDdXJ2ZUJvdW5kc0NvbGxpc2lvbnModmFsdWVzMSwgdmFsdWVzMiwgZXBzaWxvbik7XG5cbiAgICAgIGZvciAodmFyIGluZGV4MSA9IDA7IGluZGV4MSA8IGxlbmd0aDE7IGluZGV4MSsrKSB7XG4gICAgICAgIHZhciBjdXJ2ZTEgPSBjdXJ2ZXMxW2luZGV4MV0sXG4gICAgICAgICAgICB2MSA9IHZhbHVlczFbaW5kZXgxXTtcblxuICAgICAgICBpZiAoc2VsZikge1xuICAgICAgICAgIGdldFNlbGZJbnRlcnNlY3Rpb24odjEsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xsaXNpb25zMSA9IGJvdW5kc0NvbGxpc2lvbnNbaW5kZXgxXTtcblxuICAgICAgICBpZiAoY29sbGlzaW9uczEpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbGxpc2lvbnMxLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoX3JldHVybkZpcnN0ICYmIGxvY2F0aW9ucy5sZW5ndGgpIHJldHVybiBsb2NhdGlvbnM7XG4gICAgICAgICAgICB2YXIgaW5kZXgyID0gY29sbGlzaW9uczFbal07XG5cbiAgICAgICAgICAgIGlmICghc2VsZiB8fCBpbmRleDIgPiBpbmRleDEpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnZlMiA9IGN1cnZlczJbaW5kZXgyXSxcbiAgICAgICAgICAgICAgICAgIHYyID0gdmFsdWVzMltpbmRleDJdO1xuICAgICAgICAgICAgICBnZXRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLCBpbmNsdWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvY2F0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRPdmVybGFwcyh2MSwgdjIpIHtcbiAgICAgIGZ1bmN0aW9uIGdldFNxdWFyZWRMaW5lTGVuZ3RoKHYpIHtcbiAgICAgICAgdmFyIHggPSB2WzZdIC0gdlswXSxcbiAgICAgICAgICAgIHkgPSB2WzddIC0gdlsxXTtcbiAgICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICBnZXREaXN0YW5jZSA9IExpbmUuZ2V0RGlzdGFuY2UsXG4gICAgICAgICAgdGltZUVwc2lsb24gPSAxZS04LFxuICAgICAgICAgIGdlb21FcHNpbG9uID0gMWUtNyxcbiAgICAgICAgICBzdHJhaWdodDEgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYxKSxcbiAgICAgICAgICBzdHJhaWdodDIgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYyKSxcbiAgICAgICAgICBzdHJhaWdodEJvdGggPSBzdHJhaWdodDEgJiYgc3RyYWlnaHQyLFxuICAgICAgICAgIGZsaXAgPSBnZXRTcXVhcmVkTGluZUxlbmd0aCh2MSkgPCBnZXRTcXVhcmVkTGluZUxlbmd0aCh2MiksXG4gICAgICAgICAgbDEgPSBmbGlwID8gdjIgOiB2MSxcbiAgICAgICAgICBsMiA9IGZsaXAgPyB2MSA6IHYyLFxuICAgICAgICAgIHB4ID0gbDFbMF0sXG4gICAgICAgICAgcHkgPSBsMVsxXSxcbiAgICAgICAgICB2eCA9IGwxWzZdIC0gcHgsXG4gICAgICAgICAgdnkgPSBsMVs3XSAtIHB5O1xuXG4gICAgICBpZiAoZ2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzBdLCBsMlsxXSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbiAmJiBnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDJbNl0sIGwyWzddLCB0cnVlKSA8IGdlb21FcHNpbG9uKSB7XG4gICAgICAgIGlmICghc3RyYWlnaHRCb3RoICYmIGdldERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCBsMVsyXSwgbDFbM10sIHRydWUpIDwgZ2VvbUVwc2lsb24gJiYgZ2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwxWzRdLCBsMVs1XSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbiAmJiBnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDJbMl0sIGwyWzNdLCB0cnVlKSA8IGdlb21FcHNpbG9uICYmIGdldERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCBsMls0XSwgbDJbNV0sIHRydWUpIDwgZ2VvbUVwc2lsb24pIHtcbiAgICAgICAgICBzdHJhaWdodDEgPSBzdHJhaWdodDIgPSBzdHJhaWdodEJvdGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmFpZ2h0Qm90aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmFpZ2h0MSBeIHN0cmFpZ2h0Mikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHYgPSBbdjEsIHYyXSxcbiAgICAgICAgICBwYWlycyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgcGFpcnMubGVuZ3RoIDwgMjsgaSsrKSB7XG4gICAgICAgIHZhciBpMSA9IGkgJiAxLFxuICAgICAgICAgICAgaTIgPSBpMSBeIDEsXG4gICAgICAgICAgICB0MSA9IGkgPj4gMSxcbiAgICAgICAgICAgIHQyID0gQ3VydmUuZ2V0VGltZU9mKHZbaTFdLCBuZXcgUG9pbnQodltpMl1bdDEgPyA2IDogMF0sIHZbaTJdW3QxID8gNyA6IDFdKSk7XG5cbiAgICAgICAgaWYgKHQyICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IGkxID8gW3QxLCB0Ml0gOiBbdDIsIHQxXTtcblxuICAgICAgICAgIGlmICghcGFpcnMubGVuZ3RoIHx8IGFicyhwYWlyWzBdIC0gcGFpcnNbMF1bMF0pID4gdGltZUVwc2lsb24gJiYgYWJzKHBhaXJbMV0gLSBwYWlyc1swXVsxXSkgPiB0aW1lRXBzaWxvbikge1xuICAgICAgICAgICAgcGFpcnMucHVzaChwYWlyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA+IDIgJiYgIXBhaXJzLmxlbmd0aCkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWlycy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcGFpcnMgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghc3RyYWlnaHRCb3RoKSB7XG4gICAgICAgIHZhciBvMSA9IEN1cnZlLmdldFBhcnQodjEsIHBhaXJzWzBdWzBdLCBwYWlyc1sxXVswXSksXG4gICAgICAgICAgICBvMiA9IEN1cnZlLmdldFBhcnQodjIsIHBhaXJzWzBdWzFdLCBwYWlyc1sxXVsxXSk7XG4gICAgICAgIGlmIChhYnMobzJbMl0gLSBvMVsyXSkgPiBnZW9tRXBzaWxvbiB8fCBhYnMobzJbM10gLSBvMVszXSkgPiBnZW9tRXBzaWxvbiB8fCBhYnMobzJbNF0gLSBvMVs0XSkgPiBnZW9tRXBzaWxvbiB8fCBhYnMobzJbNV0gLSBvMVs1XSkgPiBnZW9tRXBzaWxvbikgcGFpcnMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFpcnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGltZXNXaXRoVGFuZ2VudCh2LCB0YW5nZW50KSB7XG4gICAgICB2YXIgeDAgPSB2WzBdLFxuICAgICAgICAgIHkwID0gdlsxXSxcbiAgICAgICAgICB4MSA9IHZbMl0sXG4gICAgICAgICAgeTEgPSB2WzNdLFxuICAgICAgICAgIHgyID0gdls0XSxcbiAgICAgICAgICB5MiA9IHZbNV0sXG4gICAgICAgICAgeDMgPSB2WzZdLFxuICAgICAgICAgIHkzID0gdls3XSxcbiAgICAgICAgICBub3JtYWxpemVkID0gdGFuZ2VudC5ub3JtYWxpemUoKSxcbiAgICAgICAgICB0eCA9IG5vcm1hbGl6ZWQueCxcbiAgICAgICAgICB0eSA9IG5vcm1hbGl6ZWQueSxcbiAgICAgICAgICBheCA9IDMgKiB4MyAtIDkgKiB4MiArIDkgKiB4MSAtIDMgKiB4MCxcbiAgICAgICAgICBheSA9IDMgKiB5MyAtIDkgKiB5MiArIDkgKiB5MSAtIDMgKiB5MCxcbiAgICAgICAgICBieCA9IDYgKiB4MiAtIDEyICogeDEgKyA2ICogeDAsXG4gICAgICAgICAgYnkgPSA2ICogeTIgLSAxMiAqIHkxICsgNiAqIHkwLFxuICAgICAgICAgIGN4ID0gMyAqIHgxIC0gMyAqIHgwLFxuICAgICAgICAgIGN5ID0gMyAqIHkxIC0gMyAqIHkwLFxuICAgICAgICAgIGRlbiA9IDIgKiBheCAqIHR5IC0gMiAqIGF5ICogdHgsXG4gICAgICAgICAgdGltZXMgPSBbXTtcblxuICAgICAgaWYgKE1hdGguYWJzKGRlbikgPCBOdW1lcmljYWwuQ1VSVkVUSU1FX0VQU0lMT04pIHtcbiAgICAgICAgdmFyIG51bSA9IGF4ICogY3kgLSBheSAqIGN4LFxuICAgICAgICAgICAgZGVuID0gYXggKiBieSAtIGF5ICogYng7XG5cbiAgICAgICAgaWYgKGRlbiAhPSAwKSB7XG4gICAgICAgICAgdmFyIHQgPSAtbnVtIC8gZGVuO1xuICAgICAgICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB0aW1lcy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVsdGEgPSAoYnggKiBieCAtIDQgKiBheCAqIGN4KSAqIHR5ICogdHkgKyAoLTIgKiBieCAqIGJ5ICsgNCAqIGF5ICogY3ggKyA0ICogYXggKiBjeSkgKiB0eCAqIHR5ICsgKGJ5ICogYnkgLSA0ICogYXkgKiBjeSkgKiB0eCAqIHR4LFxuICAgICAgICAgICAgayA9IGJ4ICogdHkgLSBieSAqIHR4O1xuXG4gICAgICAgIGlmIChkZWx0YSA+PSAwICYmIGRlbiAhPSAwKSB7XG4gICAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoZGVsdGEpLFxuICAgICAgICAgICAgICB0MCA9IC0oayArIGQpIC8gZGVuLFxuICAgICAgICAgICAgICB0MSA9ICgtayArIGQpIC8gZGVuO1xuICAgICAgICAgIGlmICh0MCA+PSAwICYmIHQwIDw9IDEpIHRpbWVzLnB1c2godDApO1xuICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHRpbWVzLnB1c2godDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aW1lcztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24gKGN1cnZlKSB7XG4gICAgICAgIHZhciB2MSA9IHRoaXMuZ2V0VmFsdWVzKCksXG4gICAgICAgICAgICB2MiA9IGN1cnZlICYmIGN1cnZlICE9PSB0aGlzICYmIGN1cnZlLmdldFZhbHVlcygpO1xuICAgICAgICByZXR1cm4gdjIgPyBnZXRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCB0aGlzLCBjdXJ2ZSwgW10pIDogZ2V0U2VsZkludGVyc2VjdGlvbih2MSwgdGhpcywgW10pO1xuICAgICAgfSxcbiAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgZ2V0T3ZlcmxhcHM6IGdldE92ZXJsYXBzLFxuICAgICAgICBnZXRJbnRlcnNlY3Rpb25zOiBnZXRJbnRlcnNlY3Rpb25zLFxuICAgICAgICBnZXRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zOiBnZXRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zLFxuICAgICAgICBnZXRUaW1lc1dpdGhUYW5nZW50OiBnZXRUaW1lc1dpdGhUYW5nZW50XG4gICAgICB9XG4gICAgfTtcbiAgfSgpKTtcbiAgdmFyIEN1cnZlTG9jYXRpb24gPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnQ3VydmVMb2NhdGlvbicsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmVMb2NhdGlvbihjdXJ2ZSwgdGltZSwgcG9pbnQsIF9vdmVybGFwLCBfZGlzdGFuY2UpIHtcbiAgICAgIGlmICh0aW1lID49IDAuOTk5OTk5OTkpIHtcbiAgICAgICAgdmFyIG5leHQgPSBjdXJ2ZS5nZXROZXh0KCk7XG5cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICB0aW1lID0gMDtcbiAgICAgICAgICBjdXJ2ZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0Q3VydmUoY3VydmUpO1xuXG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICAgIHRoaXMuX3BvaW50ID0gcG9pbnQgfHwgY3VydmUuZ2V0UG9pbnRBdFRpbWUodGltZSk7XG4gICAgICB0aGlzLl9vdmVybGFwID0gX292ZXJsYXA7XG4gICAgICB0aGlzLl9kaXN0YW5jZSA9IF9kaXN0YW5jZTtcbiAgICAgIHRoaXMuX2ludGVyc2VjdGlvbiA9IHRoaXMuX25leHQgPSB0aGlzLl9wcmV2aW91cyA9IG51bGw7XG4gICAgfSxcbiAgICBfc2V0UGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgICAgdGhpcy5fdmVyc2lvbiA9IHBhdGggPyBwYXRoLl92ZXJzaW9uIDogMDtcbiAgICB9LFxuICAgIF9zZXRDdXJ2ZTogZnVuY3Rpb24gKGN1cnZlKSB7XG4gICAgICB0aGlzLl9zZXRQYXRoKGN1cnZlLl9wYXRoKTtcblxuICAgICAgdGhpcy5fY3VydmUgPSBjdXJ2ZTtcbiAgICAgIHRoaXMuX3NlZ21lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fc2VnbWVudDEgPSBjdXJ2ZS5fc2VnbWVudDE7XG4gICAgICB0aGlzLl9zZWdtZW50MiA9IGN1cnZlLl9zZWdtZW50MjtcbiAgICB9LFxuICAgIF9zZXRTZWdtZW50OiBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgdmFyIGN1cnZlID0gc2VnbWVudC5nZXRDdXJ2ZSgpO1xuXG4gICAgICBpZiAoY3VydmUpIHtcbiAgICAgICAgdGhpcy5fc2V0Q3VydmUoY3VydmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0UGF0aChzZWdtZW50Ll9wYXRoKTtcblxuICAgICAgICB0aGlzLl9zZWdtZW50MSA9IHNlZ21lbnQ7XG4gICAgICAgIHRoaXMuX3NlZ21lbnQyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICB0aGlzLl90aW1lID0gc2VnbWVudCA9PT0gdGhpcy5fc2VnbWVudDEgPyAwIDogMTtcbiAgICAgIHRoaXMuX3BvaW50ID0gc2VnbWVudC5fcG9pbnQuY2xvbmUoKTtcbiAgICB9LFxuICAgIGdldFNlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudDtcblxuICAgICAgaWYgKCFzZWdtZW50KSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcbiAgICAgICAgICAgIHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblxuICAgICAgICBpZiAodGltZSA9PT0gMCkge1xuICAgICAgICAgIHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZSA9PT0gMSkge1xuICAgICAgICAgIHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDI7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZSAhPSBudWxsKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgdGltZSkgPCBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKHRpbWUsIDEpID8gY3VydmUuX3NlZ21lbnQxIDogY3VydmUuX3NlZ21lbnQyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIH0sXG4gICAgZ2V0Q3VydmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aCxcbiAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgaWYgKHBhdGggJiYgcGF0aC5fdmVyc2lvbiAhPT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgICB0aGlzLl90aW1lID0gdGhpcy5fb2Zmc2V0ID0gdGhpcy5fY3VydmVPZmZzZXQgPSB0aGlzLl9jdXJ2ZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyeVNlZ21lbnQoc2VnbWVudCkge1xuICAgICAgICB2YXIgY3VydmUgPSBzZWdtZW50ICYmIHNlZ21lbnQuZ2V0Q3VydmUoKTtcblxuICAgICAgICBpZiAoY3VydmUgJiYgKHRoYXQuX3RpbWUgPSBjdXJ2ZS5nZXRUaW1lT2YodGhhdC5fcG9pbnQpKSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhhdC5fc2V0Q3VydmUoY3VydmUpO1xuXG4gICAgICAgICAgcmV0dXJuIGN1cnZlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jdXJ2ZSB8fCB0cnlTZWdtZW50KHRoaXMuX3NlZ21lbnQpIHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudDEpIHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudDIuZ2V0UHJldmlvdXMoKSk7XG4gICAgfSxcbiAgICBnZXRQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG4gICAgICByZXR1cm4gY3VydmUgJiYgY3VydmUuX3BhdGg7XG4gICAgfSxcbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuICAgICAgcmV0dXJuIGN1cnZlICYmIGN1cnZlLmdldEluZGV4KCk7XG4gICAgfSxcbiAgICBnZXRUaW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG4gICAgICAgICAgdGltZSA9IHRoaXMuX3RpbWU7XG4gICAgICByZXR1cm4gY3VydmUgJiYgdGltZSA9PSBudWxsID8gdGhpcy5fdGltZSA9IGN1cnZlLmdldFRpbWVPZih0aGlzLl9wb2ludCkgOiB0aW1lO1xuICAgIH0sXG4gICAgZ2V0UGFyYW1ldGVyOiAnI2dldFRpbWUnLFxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9pbnQ7XG4gICAgfSxcbiAgICBnZXRPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG5cbiAgICAgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuZ2V0UGF0aCgpLFxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG5cbiAgICAgICAgaWYgKHBhdGggJiYgaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBjdXJ2ZXMgPSBwYXRoLmdldEN1cnZlcygpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSBvZmZzZXQgKz0gY3VydmVzW2ldLmdldExlbmd0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0ICs9IHRoaXMuZ2V0Q3VydmVPZmZzZXQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9LFxuICAgIGdldEN1cnZlT2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fY3VydmVPZmZzZXQ7XG5cbiAgICAgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG4gICAgICAgICAgICB0aW1lID0gdGhpcy5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMuX2N1cnZlT2Zmc2V0ID0gb2Zmc2V0ID0gdGltZSAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgdGltZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSxcbiAgICBnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3Rpb247XG4gICAgfSxcbiAgICBnZXREaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlO1xuICAgIH0sXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG4gICAgICAgICAgcmVzID0gY3VydmUgJiYgY3VydmUuZGl2aWRlQXRUaW1lKHRoaXMuZ2V0VGltZSgpKTtcblxuICAgICAgaWYgKHJlcykge1xuICAgICAgICB0aGlzLl9zZXRTZWdtZW50KHJlcy5fc2VnbWVudDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgc3BsaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcbiAgICAgICAgICBwYXRoID0gY3VydmUuX3BhdGgsXG4gICAgICAgICAgcmVzID0gY3VydmUgJiYgY3VydmUuc3BsaXRBdFRpbWUodGhpcy5nZXRUaW1lKCkpO1xuXG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHRoaXMuX3NldFNlZ21lbnQocGF0aC5nZXRMYXN0U2VnbWVudCgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKGxvYywgX2lnbm9yZU90aGVyKSB7XG4gICAgICB2YXIgcmVzID0gdGhpcyA9PT0gbG9jO1xuXG4gICAgICBpZiAoIXJlcyAmJiBsb2MgaW5zdGFuY2VvZiBDdXJ2ZUxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBjMSA9IHRoaXMuZ2V0Q3VydmUoKSxcbiAgICAgICAgICAgIGMyID0gbG9jLmdldEN1cnZlKCksXG4gICAgICAgICAgICBwMSA9IGMxLl9wYXRoLFxuICAgICAgICAgICAgcDIgPSBjMi5fcGF0aDtcblxuICAgICAgICBpZiAocDEgPT09IHAyKSB7XG4gICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgICBlcHNpbG9uID0gMWUtNyxcbiAgICAgICAgICAgICAgZGlmZiA9IGFicyh0aGlzLmdldE9mZnNldCgpIC0gbG9jLmdldE9mZnNldCgpKSxcbiAgICAgICAgICAgICAgaTEgPSAhX2lnbm9yZU90aGVyICYmIHRoaXMuX2ludGVyc2VjdGlvbixcbiAgICAgICAgICAgICAgaTIgPSAhX2lnbm9yZU90aGVyICYmIGxvYy5faW50ZXJzZWN0aW9uO1xuICAgICAgICAgIHJlcyA9IChkaWZmIDwgZXBzaWxvbiB8fCBwMSAmJiBhYnMocDEuZ2V0TGVuZ3RoKCkgLSBkaWZmKSA8IGVwc2lsb24pICYmICghaTEgJiYgIWkyIHx8IGkxICYmIGkyICYmIGkxLmVxdWFscyhpMiwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcnRzID0gW10sXG4gICAgICAgICAgcG9pbnQgPSB0aGlzLmdldFBvaW50KCksXG4gICAgICAgICAgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcbiAgICAgIGlmIChwb2ludCkgcGFydHMucHVzaCgncG9pbnQ6ICcgKyBwb2ludCk7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG4gICAgICBpZiAoaW5kZXggIT0gbnVsbCkgcGFydHMucHVzaCgnaW5kZXg6ICcgKyBpbmRleCk7XG4gICAgICB2YXIgdGltZSA9IHRoaXMuZ2V0VGltZSgpO1xuICAgICAgaWYgKHRpbWUgIT0gbnVsbCkgcGFydHMucHVzaCgndGltZTogJyArIGYubnVtYmVyKHRpbWUpKTtcbiAgICAgIGlmICh0aGlzLl9kaXN0YW5jZSAhPSBudWxsKSBwYXJ0cy5wdXNoKCdkaXN0YW5jZTogJyArIGYubnVtYmVyKHRoaXMuX2Rpc3RhbmNlKSk7XG4gICAgICByZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH0sXG4gICAgaXNUb3VjaGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGludGVyID0gdGhpcy5faW50ZXJzZWN0aW9uO1xuXG4gICAgICBpZiAoaW50ZXIgJiYgdGhpcy5nZXRUYW5nZW50KCkuaXNDb2xsaW5lYXIoaW50ZXIuZ2V0VGFuZ2VudCgpKSkge1xuICAgICAgICB2YXIgY3VydmUxID0gdGhpcy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgICAgY3VydmUyID0gaW50ZXIuZ2V0Q3VydmUoKTtcbiAgICAgICAgcmV0dXJuICEoY3VydmUxLmlzU3RyYWlnaHQoKSAmJiBjdXJ2ZTIuaXNTdHJhaWdodCgpICYmIGN1cnZlMS5nZXRMaW5lKCkuaW50ZXJzZWN0KGN1cnZlMi5nZXRMaW5lKCkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNDcm9zc2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGludGVyID0gdGhpcy5faW50ZXJzZWN0aW9uO1xuICAgICAgaWYgKCFpbnRlcikgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHQxID0gdGhpcy5nZXRUaW1lKCksXG4gICAgICAgICAgdDIgPSBpbnRlci5nZXRUaW1lKCksXG4gICAgICAgICAgdE1pbiA9IDFlLTgsXG4gICAgICAgICAgdE1heCA9IDEgLSB0TWluLFxuICAgICAgICAgIHQxSW5zaWRlID0gdDEgPj0gdE1pbiAmJiB0MSA8PSB0TWF4LFxuICAgICAgICAgIHQySW5zaWRlID0gdDIgPj0gdE1pbiAmJiB0MiA8PSB0TWF4O1xuICAgICAgaWYgKHQxSW5zaWRlICYmIHQySW5zaWRlKSByZXR1cm4gIXRoaXMuaXNUb3VjaGluZygpO1xuICAgICAgdmFyIGMyID0gdGhpcy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgIGMxID0gYzIgJiYgdDEgPCB0TWluID8gYzIuZ2V0UHJldmlvdXMoKSA6IGMyLFxuICAgICAgICAgIGM0ID0gaW50ZXIuZ2V0Q3VydmUoKSxcbiAgICAgICAgICBjMyA9IGM0ICYmIHQyIDwgdE1pbiA/IGM0LmdldFByZXZpb3VzKCkgOiBjNDtcbiAgICAgIGlmICh0MSA+IHRNYXgpIGMyID0gYzIuZ2V0TmV4dCgpO1xuICAgICAgaWYgKHQyID4gdE1heCkgYzQgPSBjNC5nZXROZXh0KCk7XG4gICAgICBpZiAoIWMxIHx8ICFjMiB8fCAhYzMgfHwgIWM0KSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBhZGRPZmZzZXRzKGN1cnZlLCBlbmQpIHtcbiAgICAgICAgdmFyIHYgPSBjdXJ2ZS5nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAgIHJvb3RzID0gQ3VydmUuY2xhc3NpZnkodikucm9vdHMgfHwgQ3VydmUuZ2V0UGVha3ModiksXG4gICAgICAgICAgICBjb3VudCA9IHJvb3RzLmxlbmd0aCxcbiAgICAgICAgICAgIG9mZnNldCA9IEN1cnZlLmdldExlbmd0aCh2LCBlbmQgJiYgY291bnQgPyByb290c1tjb3VudCAtIDFdIDogMCwgIWVuZCAmJiBjb3VudCA/IHJvb3RzWzBdIDogMSk7XG4gICAgICAgIG9mZnNldHMucHVzaChjb3VudCA/IG9mZnNldCA6IG9mZnNldCAvIDMyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNJblJhbmdlKGFuZ2xlLCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gbWluIDwgbWF4ID8gYW5nbGUgPiBtaW4gJiYgYW5nbGUgPCBtYXggOiBhbmdsZSA+IG1pbiB8fCBhbmdsZSA8IG1heDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0MUluc2lkZSkge1xuICAgICAgICBhZGRPZmZzZXRzKGMxLCB0cnVlKTtcbiAgICAgICAgYWRkT2Zmc2V0cyhjMiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXQySW5zaWRlKSB7XG4gICAgICAgIGFkZE9mZnNldHMoYzMsIHRydWUpO1xuICAgICAgICBhZGRPZmZzZXRzKGM0LCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwdCA9IHRoaXMuZ2V0UG9pbnQoKSxcbiAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBvZmZzZXRzKSxcbiAgICAgICAgICB2MiA9IHQxSW5zaWRlID8gYzIuZ2V0VGFuZ2VudEF0VGltZSh0MSkgOiBjMi5nZXRQb2ludEF0KG9mZnNldCkuc3VidHJhY3QocHQpLFxuICAgICAgICAgIHYxID0gdDFJbnNpZGUgPyB2Mi5uZWdhdGUoKSA6IGMxLmdldFBvaW50QXQoLW9mZnNldCkuc3VidHJhY3QocHQpLFxuICAgICAgICAgIHY0ID0gdDJJbnNpZGUgPyBjNC5nZXRUYW5nZW50QXRUaW1lKHQyKSA6IGM0LmdldFBvaW50QXQob2Zmc2V0KS5zdWJ0cmFjdChwdCksXG4gICAgICAgICAgdjMgPSB0Mkluc2lkZSA/IHY0Lm5lZ2F0ZSgpIDogYzMuZ2V0UG9pbnRBdCgtb2Zmc2V0KS5zdWJ0cmFjdChwdCksXG4gICAgICAgICAgYTEgPSB2MS5nZXRBbmdsZSgpLFxuICAgICAgICAgIGEyID0gdjIuZ2V0QW5nbGUoKSxcbiAgICAgICAgICBhMyA9IHYzLmdldEFuZ2xlKCksXG4gICAgICAgICAgYTQgPSB2NC5nZXRBbmdsZSgpO1xuICAgICAgcmV0dXJuICEhKHQxSW5zaWRlID8gaXNJblJhbmdlKGExLCBhMywgYTQpIF4gaXNJblJhbmdlKGEyLCBhMywgYTQpICYmIGlzSW5SYW5nZShhMSwgYTQsIGEzKSBeIGlzSW5SYW5nZShhMiwgYTQsIGEzKSA6IGlzSW5SYW5nZShhMywgYTEsIGEyKSBeIGlzSW5SYW5nZShhNCwgYTEsIGEyKSAmJiBpc0luUmFuZ2UoYTMsIGEyLCBhMSkgXiBpc0luUmFuZ2UoYTQsIGEyLCBhMSkpO1xuICAgIH0sXG4gICAgaGFzT3ZlcmxhcDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fb3ZlcmxhcDtcbiAgICB9XG4gIH0sIEJhc2UuZWFjaChDdXJ2ZS5fZXZhbHVhdGVNZXRob2RzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBnZXQgPSBuYW1lICsgJ0F0JztcblxuICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG4gICAgICAgICAgdGltZSA9IHRoaXMuZ2V0VGltZSgpO1xuICAgICAgcmV0dXJuIHRpbWUgIT0gbnVsbCAmJiBjdXJ2ZSAmJiBjdXJ2ZVtnZXRdKHRpbWUsIHRydWUpO1xuICAgIH07XG4gIH0sIHtcbiAgICBwcmVzZXJ2ZTogdHJ1ZVxuICB9KSwgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBpbnNlcnQobG9jYXRpb25zLCBsb2MsIG1lcmdlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gbG9jYXRpb25zLmxlbmd0aCxcbiAgICAgICAgICBsID0gMCxcbiAgICAgICAgICByID0gbGVuZ3RoIC0gMTtcblxuICAgICAgZnVuY3Rpb24gc2VhcmNoKGluZGV4LCBkaXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgZGlyOyBpID49IC0xICYmIGkgPD0gbGVuZ3RoOyBpICs9IGRpcikge1xuICAgICAgICAgIHZhciBsb2MyID0gbG9jYXRpb25zWyhpICUgbGVuZ3RoICsgbGVuZ3RoKSAlIGxlbmd0aF07XG4gICAgICAgICAgaWYgKCFsb2MuZ2V0UG9pbnQoKS5pc0Nsb3NlKGxvYzIuZ2V0UG9pbnQoKSwgMWUtNykpIGJyZWFrO1xuICAgICAgICAgIGlmIChsb2MuZXF1YWxzKGxvYzIpKSByZXR1cm4gbG9jMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobCA8PSByKSB7XG4gICAgICAgIHZhciBtID0gbCArIHIgPj4+IDEsXG4gICAgICAgICAgICBsb2MyID0gbG9jYXRpb25zW21dLFxuICAgICAgICAgICAgZm91bmQ7XG5cbiAgICAgICAgaWYgKG1lcmdlICYmIChmb3VuZCA9IGxvYy5lcXVhbHMobG9jMikgPyBsb2MyIDogc2VhcmNoKG0sIC0xKSB8fCBzZWFyY2gobSwgMSkpKSB7XG4gICAgICAgICAgaWYgKGxvYy5fb3ZlcmxhcCkge1xuICAgICAgICAgICAgZm91bmQuX292ZXJsYXAgPSBmb3VuZC5faW50ZXJzZWN0aW9uLl9vdmVybGFwID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aDEgPSBsb2MuZ2V0UGF0aCgpLFxuICAgICAgICAgICAgcGF0aDIgPSBsb2MyLmdldFBhdGgoKSxcbiAgICAgICAgICAgIGRpZmYgPSBwYXRoMSAhPT0gcGF0aDIgPyBwYXRoMS5faWQgLSBwYXRoMi5faWQgOiBsb2MuZ2V0SW5kZXgoKSArIGxvYy5nZXRUaW1lKCkgLSAobG9jMi5nZXRJbmRleCgpICsgbG9jMi5nZXRUaW1lKCkpO1xuXG4gICAgICAgIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgIHIgPSBtIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsID0gbSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbG9jYXRpb25zLnNwbGljZShsLCAwLCBsb2MpO1xuICAgICAgcmV0dXJuIGxvYztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGljczoge1xuICAgICAgICBpbnNlcnQ6IGluc2VydCxcbiAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiAobG9jYXRpb25zKSB7XG4gICAgICAgICAgdmFyIGV4cGFuZGVkID0gbG9jYXRpb25zLnNsaWNlKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gbG9jYXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpbnNlcnQoZXhwYW5kZWQsIGxvY2F0aW9uc1tpXS5faW50ZXJzZWN0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSgpKTtcbiAgdmFyIFBhdGhJdGVtID0gSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1BhdGhJdGVtJyxcbiAgICBfc2VsZWN0Qm91bmRzOiBmYWxzZSxcbiAgICBfY2FuU2NhbGVTdHJva2U6IHRydWUsXG4gICAgYmVhbnM6IHRydWUsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUGF0aEl0ZW0oKSB7fSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIGRhdGEsIHNlZ21lbnRzLCBjb21wb3VuZDtcblxuICAgICAgICBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGFyZykpIHtcbiAgICAgICAgICBzZWdtZW50cyA9IGFyZy5zZWdtZW50cztcbiAgICAgICAgICBkYXRhID0gYXJnLnBhdGhEYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgIHNlZ21lbnRzID0gYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZGF0YSA9IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICAgIHZhciBmaXJzdCA9IHNlZ21lbnRzWzBdO1xuICAgICAgICAgIGNvbXBvdW5kID0gZmlyc3QgJiYgQXJyYXkuaXNBcnJheShmaXJzdFswXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAgIGNvbXBvdW5kID0gKGRhdGEubWF0Y2goL20vZ2kpIHx8IFtdKS5sZW5ndGggPiAxIHx8IC96XFxzKlxcUysvaS50ZXN0KGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN0b3IgPSBjb21wb3VuZCA/IENvbXBvdW5kUGF0aCA6IFBhdGg7XG4gICAgICAgIHJldHVybiBuZXcgY3RvcihhcmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FzUGF0aEl0ZW06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaXNDbG9ja3dpc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEFyZWEoKSA+PSAwO1xuICAgIH0sXG4gICAgc2V0Q2xvY2t3aXNlOiBmdW5jdGlvbiAoY2xvY2t3aXNlKSB7XG4gICAgICBpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9IChjbG9ja3dpc2UgPSAhIWNsb2Nrd2lzZSkpIHRoaXMucmV2ZXJzZSgpO1xuICAgIH0sXG4gICAgc2V0UGF0aERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgcGFydHMgPSBkYXRhICYmIGRhdGEubWF0Y2goL1ttbGh2Y3NxdGF6XVtebWxodmNzcXRhel0qL2lnKSxcbiAgICAgICAgICBjb29yZHMsXG4gICAgICAgICAgcmVsYXRpdmUgPSBmYWxzZSxcbiAgICAgICAgICBwcmV2aW91cyxcbiAgICAgICAgICBjb250cm9sLFxuICAgICAgICAgIGN1cnJlbnQgPSBuZXcgUG9pbnQoKSxcbiAgICAgICAgICBzdGFydCA9IG5ldyBQb2ludCgpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRDb29yZChpbmRleCwgY29vcmQpIHtcbiAgICAgICAgdmFyIHZhbCA9ICtjb29yZHNbaW5kZXhdO1xuICAgICAgICBpZiAocmVsYXRpdmUpIHZhbCArPSBjdXJyZW50W2Nvb3JkXTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UG9pbnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChnZXRDb29yZChpbmRleCwgJ3gnKSwgZ2V0Q29vcmQoaW5kZXggKyAxLCAneScpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzICYmIHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldLFxuICAgICAgICAgICAgY29tbWFuZCA9IHBhcnRbMF0sXG4gICAgICAgICAgICBsb3dlciA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29vcmRzID0gcGFydC5tYXRjaCgvWystXT8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8vZyk7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb29yZHMgJiYgY29vcmRzLmxlbmd0aDtcbiAgICAgICAgcmVsYXRpdmUgPSBjb21tYW5kID09PSBsb3dlcjtcbiAgICAgICAgaWYgKHByZXZpb3VzID09PSAneicgJiYgIS9bbXpdLy50ZXN0KGxvd2VyKSkgdGhpcy5tb3ZlVG8oY3VycmVudCk7XG5cbiAgICAgICAgc3dpdGNoIChsb3dlcikge1xuICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgdmFyIG1vdmUgPSBsb3dlciA9PT0gJ20nO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgIHRoaXNbbW92ZSA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGN1cnJlbnQgPSBnZXRQb2ludChqKSk7XG5cbiAgICAgICAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgbW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRyb2wgPSBjdXJyZW50O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgIHZhciBjb29yZCA9IGxvd2VyID09PSAnaCcgPyAneCcgOiAneSc7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jbG9uZSgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRbY29vcmRdID0gZ2V0Q29vcmQoaiwgY29vcmQpO1xuICAgICAgICAgICAgICB0aGlzLmxpbmVUbyhjdXJyZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udHJvbCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNikge1xuICAgICAgICAgICAgICB0aGlzLmN1YmljQ3VydmVUbyhnZXRQb2ludChqKSwgY29udHJvbCA9IGdldFBvaW50KGogKyAyKSwgY3VycmVudCA9IGdldFBvaW50KGogKyA0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA0KSB7XG4gICAgICAgICAgICAgIHRoaXMuY3ViaWNDdXJ2ZVRvKC9bY3NdLy50ZXN0KHByZXZpb3VzKSA/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbCkgOiBjdXJyZW50LCBjb250cm9sID0gZ2V0UG9pbnQoaiksIGN1cnJlbnQgPSBnZXRQb2ludChqICsgMikpO1xuICAgICAgICAgICAgICBwcmV2aW91cyA9IGxvd2VyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuICAgICAgICAgICAgICB0aGlzLnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbCA9IGdldFBvaW50KGopLCBjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2wgPSAvW3F0XS8udGVzdChwcmV2aW91cykgPyBjdXJyZW50Lm11bHRpcGx5KDIpLnN1YnRyYWN0KGNvbnRyb2wpIDogY3VycmVudCwgY3VycmVudCA9IGdldFBvaW50KGopKTtcbiAgICAgICAgICAgICAgcHJldmlvdXMgPSBsb3dlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDcpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcmNUbyhjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDUpLCBuZXcgU2l6ZSgrY29vcmRzW2pdLCArY29vcmRzW2ogKyAxXSksICtjb29yZHNbaiArIDJdLCArY29vcmRzW2ogKyA0XSwgK2Nvb3Jkc1tqICsgM10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgdGhpcy5jbG9zZVBhdGgoMWUtMTIpO1xuICAgICAgICAgICAgY3VycmVudCA9IHN0YXJ0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91cyA9IGxvd2VyO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG4gICAgfSxcbiAgICBfY29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIHdpbmRpbmcgPSBwb2ludC5pc0luc2lkZSh0aGlzLmdldEJvdW5kcyh7XG4gICAgICAgIGludGVybmFsOiB0cnVlLFxuICAgICAgICBoYW5kbGU6IHRydWVcbiAgICAgIH0pKSA/IHRoaXMuX2dldFdpbmRpbmcocG9pbnQpIDoge307XG4gICAgICByZXR1cm4gd2luZGluZy5vblBhdGggfHwgISEodGhpcy5nZXRGaWxsUnVsZSgpID09PSAnZXZlbm9kZCcgPyB3aW5kaW5nLndpbmRpbmdMICYgMSB8fCB3aW5kaW5nLndpbmRpbmdSICYgMSA6IHdpbmRpbmcud2luZGluZyk7XG4gICAgfSxcbiAgICBnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbiAocGF0aCwgaW5jbHVkZSwgX21hdHJpeCwgX3JldHVybkZpcnN0KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgPT09IHBhdGggfHwgIXBhdGgsXG4gICAgICAgICAgbWF0cml4MSA9IHRoaXMuX21hdHJpeC5fb3JOdWxsSWZJZGVudGl0eSgpLFxuICAgICAgICAgIG1hdHJpeDIgPSBzZWxmID8gbWF0cml4MSA6IChfbWF0cml4IHx8IHBhdGguX21hdHJpeCkuX29yTnVsbElmSWRlbnRpdHkoKTtcblxuICAgICAgcmV0dXJuIHNlbGYgfHwgdGhpcy5nZXRCb3VuZHMobWF0cml4MSkuaW50ZXJzZWN0cyhwYXRoLmdldEJvdW5kcyhtYXRyaXgyKSwgMWUtMTIpID8gQ3VydmUuZ2V0SW50ZXJzZWN0aW9ucyh0aGlzLmdldEN1cnZlcygpLCAhc2VsZiAmJiBwYXRoLmdldEN1cnZlcygpLCBpbmNsdWRlLCBtYXRyaXgxLCBtYXRyaXgyLCBfcmV0dXJuRmlyc3QpIDogW107XG4gICAgfSxcbiAgICBnZXRDcm9zc2luZ3M6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnRlcnNlY3Rpb25zKHBhdGgsIGZ1bmN0aW9uIChpbnRlcikge1xuICAgICAgICByZXR1cm4gaW50ZXIuaXNDcm9zc2luZygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuICAgICAgICAgIG1pbkRpc3QgPSBJbmZpbml0eSxcbiAgICAgICAgICBtaW5Mb2MgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGxvYyA9IGN1cnZlc1tpXS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXG4gICAgICAgIGlmIChsb2MuX2Rpc3RhbmNlIDwgbWluRGlzdCkge1xuICAgICAgICAgIG1pbkRpc3QgPSBsb2MuX2Rpc3RhbmNlO1xuICAgICAgICAgIG1pbkxvYyA9IGxvYztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWluTG9jO1xuICAgIH0sXG4gICAgZ2V0TmVhcmVzdFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBsb2MgPyBsb2MuZ2V0UG9pbnQoKSA6IGxvYztcbiAgICB9LFxuICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgICAgdmFyIGlzUGF0aCA9ICF0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICBuYW1lID0gaXNQYXRoID8gJ19zZWdtZW50cycgOiAnX2NoaWxkcmVuJyxcbiAgICAgICAgICBpdGVtc0Zyb20gPSBmcm9tW25hbWVdLFxuICAgICAgICAgIGl0ZW1zVG8gPSB0b1tuYW1lXSxcbiAgICAgICAgICBpdGVtcyA9IHRoaXNbbmFtZV07XG5cbiAgICAgIGlmICghaXRlbXNGcm9tIHx8ICFpdGVtc1RvIHx8IGl0ZW1zRnJvbS5sZW5ndGggIT09IGl0ZW1zVG8ubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcGVyYW5kcyBpbiBpbnRlcnBvbGF0ZSgpIGNhbGw6ICcgKyBmcm9tICsgJywgJyArIHRvKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnQgPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaXRlbXNUby5sZW5ndGg7XG5cbiAgICAgIGlmIChjdXJyZW50IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdG9yID0gaXNQYXRoID8gU2VnbWVudCA6IFBhdGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGN1cnJlbnQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYWRkKG5ldyBjdG9yKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhpc1tpc1BhdGggPyAncmVtb3ZlU2VnbWVudHMnIDogJ3JlbW92ZUNoaWxkcmVuJ10obGVuZ3RoLCBjdXJyZW50KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtc1tpXS5pbnRlcnBvbGF0ZShpdGVtc0Zyb21baV0sIGl0ZW1zVG9baV0sIGZhY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1BhdGgpIHtcbiAgICAgICAgdGhpcy5zZXRDbG9zZWQoZnJvbS5fY2xvc2VkKTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKDkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tcGFyZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHZhciBvayA9IGZhbHNlO1xuXG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB2YXIgcGF0aHMxID0gdGhpcy5fY2hpbGRyZW4gfHwgW3RoaXNdLFxuICAgICAgICAgICAgcGF0aHMyID0gcGF0aC5fY2hpbGRyZW4gPyBwYXRoLl9jaGlsZHJlbi5zbGljZSgpIDogW3BhdGhdLFxuICAgICAgICAgICAgbGVuZ3RoMSA9IHBhdGhzMS5sZW5ndGgsXG4gICAgICAgICAgICBsZW5ndGgyID0gcGF0aHMyLmxlbmd0aCxcbiAgICAgICAgICAgIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICB2YXIgYm91bmRzT3ZlcmxhcHMgPSBDb2xsaXNpb25EZXRlY3Rpb24uZmluZEl0ZW1Cb3VuZHNDb2xsaXNpb25zKHBhdGhzMSwgcGF0aHMyLCBOdW1lcmljYWwuR0VPTUVUUklDX0VQU0lMT04pO1xuXG4gICAgICAgIGZvciAodmFyIGkxID0gbGVuZ3RoMSAtIDE7IGkxID49IDAgJiYgb2s7IGkxLS0pIHtcbiAgICAgICAgICB2YXIgcGF0aDEgPSBwYXRoczFbaTFdO1xuICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHBhdGhCb3VuZHNPdmVybGFwcyA9IGJvdW5kc092ZXJsYXBzW2kxXTtcblxuICAgICAgICAgIGlmIChwYXRoQm91bmRzT3ZlcmxhcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkyID0gcGF0aEJvdW5kc092ZXJsYXBzLmxlbmd0aCAtIDE7IGkyID49IDAgJiYgIW9rOyBpMi0tKSB7XG4gICAgICAgICAgICAgIGlmIChwYXRoMS5jb21wYXJlKHBhdGhzMltwYXRoQm91bmRzT3ZlcmxhcHNbaTJdXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRbcGF0aEJvdW5kc092ZXJsYXBzW2kyXV0pIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZWRbcGF0aEJvdW5kc092ZXJsYXBzW2kyXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvayA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvayA9IG9rICYmIGNvdW50ID09PSBsZW5ndGgyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2s7XG4gICAgfVxuICB9KTtcbiAgdmFyIFBhdGggPSBQYXRoSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1BhdGgnLFxuICAgIF9zZXJpYWxpemVGaWVsZHM6IHtcbiAgICAgIHNlZ21lbnRzOiBbXSxcbiAgICAgIGNsb3NlZDogZmFsc2VcbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGgoYXJnKSB7XG4gICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NlZ21lbnRzID0gW107XG4gICAgICB0aGlzLl92ZXJzaW9uID0gMDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHNlZ21lbnRzID0gQXJyYXkuaXNBcnJheShhcmcpID8gdHlwZW9mIGFyZ1swXSA9PT0gJ29iamVjdCcgPyBhcmcgOiBhcmdzIDogYXJnICYmIGFyZy5zaXplID09PSB1bmRlZmluZWQgJiYgKGFyZy54ICE9PSB1bmRlZmluZWQgfHwgYXJnLnBvaW50ICE9PSB1bmRlZmluZWQpID8gYXJncyA6IG51bGw7XG5cbiAgICAgIGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3VydmVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zZWdtZW50U2VsZWN0aW9uID0gMDtcblxuICAgICAgICBpZiAoIXNlZ21lbnRzICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5zZXRQYXRoRGF0YShhcmcpO1xuICAgICAgICAgIGFyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdGlhbGl6ZSghc2VnbWVudHMgJiYgYXJnKTtcbiAgICB9LFxuICAgIF9lcXVhbHM6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xvc2VkID09PSBpdGVtLl9jbG9zZWQgJiYgQmFzZS5lcXVhbHModGhpcy5fc2VnbWVudHMsIGl0ZW0uX3NlZ21lbnRzKTtcbiAgICB9LFxuICAgIGNvcHlDb250ZW50OiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICB0aGlzLnNldFNlZ21lbnRzKHNvdXJjZS5fc2VnbWVudHMpO1xuICAgICAgdGhpcy5fY2xvc2VkID0gc291cmNlLl9jbG9zZWQ7XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gX2NoYW5nZWQoZmxhZ3MpIHtcbiAgICAgIF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cbiAgICAgIGlmIChmbGFncyAmIDgpIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5fYXJlYSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZmxhZ3MgJiAzMikge1xuICAgICAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jdXJ2ZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2N1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHRoaXMuX2N1cnZlc1tpXS5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZsYWdzICYgNjQpIHtcbiAgICAgICAgdGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICByZXR1cm4gKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCA/IHBhcmVudCA6IHRoaXMpLl9zdHlsZTtcbiAgICB9LFxuICAgIGdldFNlZ21lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VnbWVudHM7XG4gICAgfSxcbiAgICBzZXRTZWdtZW50czogZnVuY3Rpb24gKHNlZ21lbnRzKSB7XG4gICAgICB2YXIgZnVsbHlTZWxlY3RlZCA9IHRoaXMuaXNGdWxseVNlbGVjdGVkKCksXG4gICAgICAgICAgbGVuZ3RoID0gc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoO1xuICAgICAgdGhpcy5fc2VnbWVudHMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX3NlZ21lbnRTZWxlY3Rpb24gPSAwO1xuICAgICAgdGhpcy5fY3VydmVzID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBsYXN0ID0gc2VnbWVudHNbbGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsYXN0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aGlzLnNldENsb3NlZChsYXN0KTtcbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KHNlZ21lbnRzLCAwLCB7fSwgbGVuZ3RoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmdWxseVNlbGVjdGVkKSB0aGlzLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG4gICAgfSxcbiAgICBnZXRGaXJzdFNlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50c1swXTtcbiAgICB9LFxuICAgIGdldExhc3RTZWdtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VnbWVudHNbdGhpcy5fc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgfSxcbiAgICBnZXRDdXJ2ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG4gICAgICAgICAgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblxuICAgICAgaWYgKCFjdXJ2ZXMpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cbiAgICAgICAgY3VydmVzID0gdGhpcy5fY3VydmVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgY3VydmVzW2ldID0gbmV3IEN1cnZlKHRoaXMsIHNlZ21lbnRzW2ldLCBzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VydmVzO1xuICAgIH0sXG4gICAgZ2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VydmVzKClbMF07XG4gICAgfSxcbiAgICBnZXRMYXN0Q3VydmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuICAgICAgcmV0dXJuIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV07XG4gICAgfSxcbiAgICBpc0Nsb3NlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICB9LFxuICAgIHNldENsb3NlZDogZnVuY3Rpb24gKGNsb3NlZCkge1xuICAgICAgaWYgKHRoaXMuX2Nsb3NlZCAhPSAoY2xvc2VkID0gISFjbG9zZWQpKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGNsb3NlZDtcblxuICAgICAgICBpZiAodGhpcy5fY3VydmVzKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuX2N1cnZlcy5sZW5ndGggPSB0aGlzLl9jb3VudEN1cnZlcygpO1xuXG4gICAgICAgICAgaWYgKGNsb3NlZCkgdGhpcy5fY3VydmVzW2xlbmd0aCAtIDFdID0gbmV3IEN1cnZlKHRoaXMsIHRoaXMuX3NlZ21lbnRzW2xlbmd0aCAtIDFdLCB0aGlzLl9zZWdtZW50c1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKDQxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBiZWFuczogdHJ1ZSxcbiAgICBnZXRQYXRoRGF0YTogZnVuY3Rpb24gKF9tYXRyaXgsIF9wcmVjaXNpb24pIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICBmID0gbmV3IEZvcm1hdHRlcihfcHJlY2lzaW9uKSxcbiAgICAgICAgICBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG4gICAgICAgICAgZmlyc3QgPSB0cnVlLFxuICAgICAgICAgIGN1clgsXG4gICAgICAgICAgY3VyWSxcbiAgICAgICAgICBwcmV2WCxcbiAgICAgICAgICBwcmV2WSxcbiAgICAgICAgICBpblgsXG4gICAgICAgICAgaW5ZLFxuICAgICAgICAgIG91dFgsXG4gICAgICAgICAgb3V0WSxcbiAgICAgICAgICBwYXJ0cyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBhZGRTZWdtZW50KHNlZ21lbnQsIHNraXBMaW5lKSB7XG4gICAgICAgIHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKF9tYXRyaXgsIGNvb3Jkcyk7XG5cbiAgICAgICAgY3VyWCA9IGNvb3Jkc1swXTtcbiAgICAgICAgY3VyWSA9IGNvb3Jkc1sxXTtcblxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKCdNJyArIGYucGFpcihjdXJYLCBjdXJZKSk7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpblggPSBjb29yZHNbMl07XG4gICAgICAgICAgaW5ZID0gY29vcmRzWzNdO1xuXG4gICAgICAgICAgaWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1clkgJiYgb3V0WCA9PT0gcHJldlggJiYgb3V0WSA9PT0gcHJldlkpIHtcbiAgICAgICAgICAgIGlmICghc2tpcExpbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGR4ID0gY3VyWCAtIHByZXZYLFxuICAgICAgICAgICAgICAgICAgZHkgPSBjdXJZIC0gcHJldlk7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goZHggPT09IDAgPyAndicgKyBmLm51bWJlcihkeSkgOiBkeSA9PT0gMCA/ICdoJyArIGYubnVtYmVyKGR4KSA6ICdsJyArIGYucGFpcihkeCwgZHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFydHMucHVzaCgnYycgKyBmLnBhaXIob3V0WCAtIHByZXZYLCBvdXRZIC0gcHJldlkpICsgJyAnICsgZi5wYWlyKGluWCAtIHByZXZYLCBpblkgLSBwcmV2WSkgKyAnICcgKyBmLnBhaXIoY3VyWCAtIHByZXZYLCBjdXJZIC0gcHJldlkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2WCA9IGN1clg7XG4gICAgICAgIHByZXZZID0gY3VyWTtcbiAgICAgICAgb3V0WCA9IGNvb3Jkc1s0XTtcbiAgICAgICAgb3V0WSA9IGNvb3Jkc1s1XTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsZW5ndGgpIHJldHVybiAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYWRkU2VnbWVudChzZWdtZW50c1tpXSk7XG5cbiAgICAgIGlmICh0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCkge1xuICAgICAgICBhZGRTZWdtZW50KHNlZ21lbnRzWzBdLCB0cnVlKTtcbiAgICAgICAgcGFydHMucHVzaCgneicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcbiAgICB9LFxuICAgIF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICBjb29yZHMgPSBuZXcgQXJyYXkoNik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSBzZWdtZW50c1tpXS5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIHRydWUpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIF9hZGQ6IGZ1bmN0aW9uIChzZWdzLCBpbmRleCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuICAgICAgICAgIGFtb3VudCA9IHNlZ3MubGVuZ3RoLFxuICAgICAgICAgIGFwcGVuZCA9IGluZGV4ID09IG51bGwsXG4gICAgICAgICAgaW5kZXggPSBhcHBlbmQgPyBzZWdtZW50cy5sZW5ndGggOiBpbmRleDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ3NbaV07XG4gICAgICAgIGlmIChzZWdtZW50Ll9wYXRoKSBzZWdtZW50ID0gc2Vnc1tpXSA9IHNlZ21lbnQuY2xvbmUoKTtcbiAgICAgICAgc2VnbWVudC5fcGF0aCA9IHRoaXM7XG4gICAgICAgIHNlZ21lbnQuX2luZGV4ID0gaW5kZXggKyBpO1xuICAgICAgICBpZiAoc2VnbWVudC5fc2VsZWN0aW9uKSB0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgMCwgc2VnbWVudC5fc2VsZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFwcGVuZCkge1xuICAgICAgICBCYXNlLnB1c2goc2VnbWVudHMsIHNlZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VnbWVudHMuc3BsaWNlLmFwcGx5KHNlZ21lbnRzLCBbaW5kZXgsIDBdLmNvbmNhdChzZWdzKSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgYW1vdW50LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSBzZWdtZW50c1tpXS5faW5kZXggPSBpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VydmVzKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuX2NvdW50Q3VydmVzKCksXG4gICAgICAgICAgICBzdGFydCA9IGluZGV4ID4gMCAmJiBpbmRleCArIGFtb3VudCAtIDEgPT09IHRvdGFsID8gaW5kZXggLSAxIDogaW5kZXgsXG4gICAgICAgICAgICBpbnNlcnQgPSBzdGFydCxcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgYW1vdW50LCB0b3RhbCk7XG5cbiAgICAgICAgaWYgKHNlZ3MuX2N1cnZlcykge1xuICAgICAgICAgIGN1cnZlcy5zcGxpY2UuYXBwbHkoY3VydmVzLCBbc3RhcnQsIDBdLmNvbmNhdChzZWdzLl9jdXJ2ZXMpKTtcbiAgICAgICAgICBpbnNlcnQgKz0gc2Vncy5fY3VydmVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBpbnNlcnQ7IGkgPCBlbmQ7IGkrKykgY3VydmVzLnNwbGljZShpLCAwLCBuZXcgQ3VydmUodGhpcywgbnVsbCwgbnVsbCkpO1xuXG4gICAgICAgIHRoaXMuX2FkanVzdEN1cnZlcyhzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hhbmdlZCg0MSk7XG5cbiAgICAgIHJldHVybiBzZWdzO1xuICAgIH0sXG4gICAgX2FkanVzdEN1cnZlczogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgIGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcbiAgICAgICAgICBjdXJ2ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgY3VydmUgPSBjdXJ2ZXNbaV07XG4gICAgICAgIGN1cnZlLl9wYXRoID0gdGhpcztcbiAgICAgICAgY3VydmUuX3NlZ21lbnQxID0gc2VnbWVudHNbaV07XG4gICAgICAgIGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXTtcblxuICAgICAgICBjdXJ2ZS5fY2hhbmdlZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VydmUgPSBjdXJ2ZXNbdGhpcy5fY2xvc2VkICYmICFzdGFydCA/IHNlZ21lbnRzLmxlbmd0aCAtIDEgOiBzdGFydCAtIDFdKSB7XG4gICAgICAgIGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW3N0YXJ0XSB8fCBzZWdtZW50c1swXTtcblxuICAgICAgICBjdXJ2ZS5fY2hhbmdlZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VydmUgPSBjdXJ2ZXNbZW5kXSkge1xuICAgICAgICBjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1tlbmRdO1xuXG4gICAgICAgIGN1cnZlLl9jaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY291bnRDdXJ2ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG4gICAgICByZXR1cm4gIXRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwID8gbGVuZ3RoIC0gMSA6IGxlbmd0aDtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gKHNlZ21lbnQxKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIHNlZ21lbnQxICE9PSAnbnVtYmVyJyA/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KGFyZ3MpKSA6IHRoaXMuX2FkZChbU2VnbWVudC5yZWFkKGFyZ3MpXSlbMF07XG4gICAgfSxcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIChpbmRleCwgc2VnbWVudDEpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoID4gMiAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInID8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3QoYXJncywgMSksIGluZGV4KSA6IHRoaXMuX2FkZChbU2VnbWVudC5yZWFkKGFyZ3MsIDEpXSwgaW5kZXgpWzBdO1xuICAgIH0sXG4gICAgYWRkU2VnbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZChbU2VnbWVudC5yZWFkKGFyZ3VtZW50cyldKVswXTtcbiAgICB9LFxuICAgIGluc2VydFNlZ21lbnQ6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZChbU2VnbWVudC5yZWFkKGFyZ3VtZW50cywgMSldLCBpbmRleClbMF07XG4gICAgfSxcbiAgICBhZGRTZWdtZW50czogZnVuY3Rpb24gKHNlZ21lbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3Qoc2VnbWVudHMpKTtcbiAgICB9LFxuICAgIGluc2VydFNlZ21lbnRzOiBmdW5jdGlvbiAoaW5kZXgsIHNlZ21lbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3Qoc2VnbWVudHMpLCBpbmRleCk7XG4gICAgfSxcbiAgICByZW1vdmVTZWdtZW50OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCBpbmRleCArIDEpWzBdIHx8IG51bGw7XG4gICAgfSxcbiAgICByZW1vdmVTZWdtZW50czogZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIF9pbmNsdWRlQ3VydmVzKSB7XG4gICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICBlbmQgPSBCYXNlLnBpY2soZW5kLCB0aGlzLl9zZWdtZW50cy5sZW5ndGgpO1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuICAgICAgICAgIGNvdW50ID0gc2VnbWVudHMubGVuZ3RoLFxuICAgICAgICAgIHJlbW92ZWQgPSBzZWdtZW50cy5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KSxcbiAgICAgICAgICBhbW91bnQgPSByZW1vdmVkLmxlbmd0aDtcbiAgICAgIGlmICghYW1vdW50KSByZXR1cm4gcmVtb3ZlZDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHJlbW92ZWRbaV07XG4gICAgICAgIGlmIChzZWdtZW50Ll9zZWxlY3Rpb24pIHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCBzZWdtZW50Ll9zZWxlY3Rpb24sIDApO1xuICAgICAgICBzZWdtZW50Ll9pbmRleCA9IHNlZ21lbnQuX3BhdGggPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cbiAgICAgIGlmIChjdXJ2ZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhcnQgPiAwICYmIGVuZCA9PT0gY291bnQgKyAodGhpcy5fY2xvc2VkID8gMSA6IDApID8gc3RhcnQgLSAxIDogc3RhcnQsXG4gICAgICAgICAgICBjdXJ2ZXMgPSBjdXJ2ZXMuc3BsaWNlKGluZGV4LCBhbW91bnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBjdXJ2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGN1cnZlc1tpXS5fcGF0aCA9IG51bGw7XG5cbiAgICAgICAgaWYgKF9pbmNsdWRlQ3VydmVzKSByZW1vdmVkLl9jdXJ2ZXMgPSBjdXJ2ZXMuc2xpY2UoMSk7XG5cbiAgICAgICAgdGhpcy5fYWRqdXN0Q3VydmVzKGluZGV4LCBpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoNDEpO1xuXG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuICAgIGNsZWFyOiAnI3JlbW92ZVNlZ21lbnRzJyxcbiAgICBoYXNIYW5kbGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHNlZ21lbnRzW2ldLmhhc0hhbmRsZXMoKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGNsZWFySGFuZGxlczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSBzZWdtZW50c1tpXS5jbGVhckhhbmRsZXMoKTtcbiAgICB9LFxuICAgIGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuICAgICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIGxlbmd0aCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgIH0sXG4gICAgZ2V0QXJlYTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZWEgPSB0aGlzLl9hcmVhO1xuXG4gICAgICBpZiAoYXJlYSA9PSBudWxsKSB7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgICAgY2xvc2VkID0gdGhpcy5fY2xvc2VkO1xuICAgICAgICBhcmVhID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBsYXN0ID0gaSArIDEgPT09IGw7XG4gICAgICAgICAgYXJlYSArPSBDdXJ2ZS5nZXRBcmVhKEN1cnZlLmdldFZhbHVlcyhzZWdtZW50c1tpXSwgc2VnbWVudHNbbGFzdCA/IDAgOiBpICsgMV0sIG51bGwsIGxhc3QgJiYgIWNsb3NlZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXJlYSA9IGFyZWE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH0sXG4gICAgaXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXMuaXNTZWxlY3RlZCgpICYmIGxlbmd0aCA+IDAgJiYgdGhpcy5fc2VnbWVudFNlbGVjdGlvbiA9PT0gbGVuZ3RoICogNztcbiAgICB9LFxuICAgIHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgaWYgKHNlbGVjdGVkKSB0aGlzLl9zZWxlY3RTZWdtZW50cyh0cnVlKTtcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoIShzZWxlY3Rpb24gJiAxKSkgdGhpcy5fc2VsZWN0U2VnbWVudHMoZmFsc2UpO1xuICAgICAgc2V0U2VsZWN0aW9uLmJhc2UuY2FsbCh0aGlzLCBzZWxlY3Rpb24pO1xuICAgIH0sXG4gICAgX3NlbGVjdFNlZ21lbnRzOiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3RlZCA/IDcgOiAwO1xuICAgICAgdGhpcy5fc2VnbWVudFNlbGVjdGlvbiA9IHNlbGVjdGlvbiAqIGxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgc2VnbWVudHNbaV0uX3NlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICB9LFxuICAgIF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uIChzZWdtZW50LCBvbGRTZWxlY3Rpb24sIG5ld1NlbGVjdGlvbikge1xuICAgICAgc2VnbWVudC5fc2VsZWN0aW9uID0gbmV3U2VsZWN0aW9uO1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuX3NlZ21lbnRTZWxlY3Rpb24gKz0gbmV3U2VsZWN0aW9uIC0gb2xkU2VsZWN0aW9uO1xuICAgICAgaWYgKHNlbGVjdGlvbiA+IDApIHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG4gICAgfSxcbiAgICBkaXZpZGVBdDogZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KGxvY2F0aW9uKSxcbiAgICAgICAgICBjdXJ2ZTtcbiAgICAgIHJldHVybiBsb2MgJiYgKGN1cnZlID0gbG9jLmdldEN1cnZlKCkuZGl2aWRlQXQobG9jLmdldEN1cnZlT2Zmc2V0KCkpKSA/IGN1cnZlLl9zZWdtZW50MSA6IG51bGw7XG4gICAgfSxcbiAgICBzcGxpdEF0OiBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uQXQobG9jYXRpb24pLFxuICAgICAgICAgIGluZGV4ID0gbG9jICYmIGxvYy5pbmRleCxcbiAgICAgICAgICB0aW1lID0gbG9jICYmIGxvYy50aW1lLFxuICAgICAgICAgIHRNaW4gPSAxZS04LFxuICAgICAgICAgIHRNYXggPSAxIC0gdE1pbjtcblxuICAgICAgaWYgKHRpbWUgPiB0TWF4KSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHRpbWUgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblxuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBjdXJ2ZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aW1lID49IHRNaW4pIHtcbiAgICAgICAgICBjdXJ2ZXNbaW5kZXgrK10uZGl2aWRlQXRUaW1lKHRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCB0aGlzLl9zZWdtZW50cy5sZW5ndGgsIHRydWUpLFxuICAgICAgICAgICAgcGF0aDtcblxuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgdGhpcy5zZXRDbG9zZWQoZmFsc2UpO1xuICAgICAgICAgIHBhdGggPSB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG4gICAgICAgICAgcGF0aC5pbnNlcnRBYm92ZSh0aGlzKTtcbiAgICAgICAgICBwYXRoLmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aC5fYWRkKHNlZ3MsIDApO1xuXG4gICAgICAgIHRoaXMuYWRkU2VnbWVudChzZWdzWzBdKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgc3BsaXQ6IGZ1bmN0aW9uIChpbmRleCwgdGltZSkge1xuICAgICAgdmFyIGN1cnZlLFxuICAgICAgICAgIGxvY2F0aW9uID0gdGltZSA9PT0gdW5kZWZpbmVkID8gaW5kZXggOiAoY3VydmUgPSB0aGlzLmdldEN1cnZlcygpW2luZGV4XSkgJiYgY3VydmUuZ2V0TG9jYXRpb25BdFRpbWUodGltZSk7XG4gICAgICByZXR1cm4gbG9jYXRpb24gIT0gbnVsbCA/IHRoaXMuc3BsaXRBdChsb2NhdGlvbikgOiBudWxsO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gKHBhdGgsIHRvbGVyYW5jZSkge1xuICAgICAgdmFyIGVwc2lsb24gPSB0b2xlcmFuY2UgfHwgMDtcblxuICAgICAgaWYgKHBhdGggJiYgcGF0aCAhPT0gdGhpcykge1xuICAgICAgICB2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcbiAgICAgICAgICAgIGxhc3QxID0gdGhpcy5nZXRMYXN0U2VnbWVudCgpLFxuICAgICAgICAgICAgbGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG4gICAgICAgIGlmICghbGFzdDIpIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobGFzdDEgJiYgbGFzdDEuX3BvaW50LmlzQ2xvc2UobGFzdDIuX3BvaW50LCBlcHNpbG9uKSkgcGF0aC5yZXZlcnNlKCk7XG4gICAgICAgIHZhciBmaXJzdDIgPSBwYXRoLmdldEZpcnN0U2VnbWVudCgpO1xuXG4gICAgICAgIGlmIChsYXN0MSAmJiBsYXN0MS5fcG9pbnQuaXNDbG9zZShmaXJzdDIuX3BvaW50LCBlcHNpbG9uKSkge1xuICAgICAgICAgIGxhc3QxLnNldEhhbmRsZU91dChmaXJzdDIuX2hhbmRsZU91dCk7XG5cbiAgICAgICAgICB0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmaXJzdDEgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpO1xuICAgICAgICAgIGlmIChmaXJzdDEgJiYgZmlyc3QxLl9wb2ludC5pc0Nsb3NlKGZpcnN0Mi5fcG9pbnQsIGVwc2lsb24pKSBwYXRoLnJldmVyc2UoKTtcbiAgICAgICAgICBsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcblxuICAgICAgICAgIGlmIChmaXJzdDEgJiYgZmlyc3QxLl9wb2ludC5pc0Nsb3NlKGxhc3QyLl9wb2ludCwgZXBzaWxvbikpIHtcbiAgICAgICAgICAgIGZpcnN0MS5zZXRIYW5kbGVJbihsYXN0Mi5faGFuZGxlSW4pO1xuXG4gICAgICAgICAgICB0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMCwgc2VnbWVudHMubGVuZ3RoIC0gMSksIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGguX2Nsb3NlZCkgdGhpcy5fYWRkKFtzZWdtZW50c1swXV0pO1xuICAgICAgICBwYXRoLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpLFxuICAgICAgICAgIGxhc3QgPSB0aGlzLmdldExhc3RTZWdtZW50KCk7XG5cbiAgICAgIGlmIChmaXJzdCAhPT0gbGFzdCAmJiBmaXJzdC5fcG9pbnQuaXNDbG9zZShsYXN0Ll9wb2ludCwgZXBzaWxvbikpIHtcbiAgICAgICAgZmlyc3Quc2V0SGFuZGxlSW4obGFzdC5faGFuZGxlSW4pO1xuICAgICAgICBsYXN0LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNldENsb3NlZCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcbiAgICAgICAgICBzaW1wbGlmeSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaW1wbGlmeSxcbiAgICAgICAgICB0b2xlcmFuY2UgPSBzaW1wbGlmeSA/IDFlLTcgOiAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IGN1cnZlc1tpXTtcbiAgICAgICAgaWYgKCFjdXJ2ZS5oYXNIYW5kbGVzKCkgJiYgKCFjdXJ2ZS5oYXNMZW5ndGgodG9sZXJhbmNlKSB8fCBzaW1wbGlmeSAmJiBjdXJ2ZS5pc0NvbGxpbmVhcihjdXJ2ZS5nZXROZXh0KCkpKSkgY3VydmUucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc2VnbWVudHMucmV2ZXJzZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuICAgICAgICB2YXIgaGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVJbjtcbiAgICAgICAgc2VnbWVudC5faGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG4gICAgICAgIHNlZ21lbnQuX2hhbmRsZU91dCA9IGhhbmRsZUluO1xuICAgICAgICBzZWdtZW50Ll9pbmRleCA9IGk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2N1cnZlcyA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoOSk7XG4gICAgfSxcbiAgICBmbGF0dGVuOiBmdW5jdGlvbiAoZmxhdG5lc3MpIHtcbiAgICAgIHZhciBmbGF0dGVuZXIgPSBuZXcgUGF0aEZsYXR0ZW5lcih0aGlzLCBmbGF0bmVzcyB8fCAwLjI1LCAyNTYsIHRydWUpLFxuICAgICAgICAgIHBhcnRzID0gZmxhdHRlbmVyLnBhcnRzLFxuICAgICAgICAgIGxlbmd0aCA9IHBhcnRzLmxlbmd0aCxcbiAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocGFydHNbaV0uY3VydmUuc2xpY2UoMCwgMikpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHBhcnRzW2xlbmd0aCAtIDFdLmN1cnZlLnNsaWNlKDYpKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuICAgIH0sXG4gICAgc2ltcGxpZnk6IGZ1bmN0aW9uICh0b2xlcmFuY2UpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IG5ldyBQYXRoRml0dGVyKHRoaXMpLmZpdCh0b2xlcmFuY2UgfHwgMi41KTtcbiAgICAgIGlmIChzZWdtZW50cykgdGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG4gICAgICByZXR1cm4gISFzZWdtZW50cztcbiAgICB9LFxuICAgIHNtb290aDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBvcHRzID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICB0eXBlID0gb3B0cy50eXBlIHx8ICdhc3ltbWV0cmljJyxcbiAgICAgICAgICBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICBjbG9zZWQgPSB0aGlzLl9jbG9zZWQ7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEluZGV4KHZhbHVlLCBfZGVmYXVsdCkge1xuICAgICAgICB2YXIgaW5kZXggPSB2YWx1ZSAmJiB2YWx1ZS5pbmRleDtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBwYXRoID0gdmFsdWUucGF0aDtcbiAgICAgICAgICBpZiAocGF0aCAmJiBwYXRoICE9PSB0aGF0KSB0aHJvdyBuZXcgRXJyb3IodmFsdWUuX2NsYXNzICsgJyAnICsgaW5kZXggKyAnIG9mICcgKyBwYXRoICsgJyBpcyBub3QgcGFydCBvZiAnICsgdGhhdCk7XG4gICAgICAgICAgaWYgKF9kZWZhdWx0ICYmIHZhbHVlIGluc3RhbmNlb2YgQ3VydmUpIGluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXggPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBfZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihpbmRleCA8IDAgJiYgY2xvc2VkID8gaW5kZXggJSBsZW5ndGggOiBpbmRleCA8IDAgPyBpbmRleCArIGxlbmd0aCA6IGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxvb3AgPSBjbG9zZWQgJiYgb3B0cy5mcm9tID09PSB1bmRlZmluZWQgJiYgb3B0cy50byA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgIGZyb20gPSBnZXRJbmRleChvcHRzLmZyb20sIDApLFxuICAgICAgICAgIHRvID0gZ2V0SW5kZXgob3B0cy50bywgbGVuZ3RoIC0gMSk7XG5cbiAgICAgIGlmIChmcm9tID4gdG8pIHtcbiAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgIGZyb20gLT0gbGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0bXAgPSBmcm9tO1xuICAgICAgICAgIGZyb20gPSB0bztcbiAgICAgICAgICB0byA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoL14oPzphc3ltbWV0cmljfGNvbnRpbnVvdXMpJC8udGVzdCh0eXBlKSkge1xuICAgICAgICB2YXIgYXN5bW1ldHJpYyA9IHR5cGUgPT09ICdhc3ltbWV0cmljJyxcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluLFxuICAgICAgICAgICAgYW1vdW50ID0gdG8gLSBmcm9tICsgMSxcbiAgICAgICAgICAgIG4gPSBhbW91bnQgLSAxLFxuICAgICAgICAgICAgcGFkZGluZyA9IGxvb3AgPyBtaW4oYW1vdW50LCA0KSA6IDEsXG4gICAgICAgICAgICBwYWRkaW5nTGVmdCA9IHBhZGRpbmcsXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBwYWRkaW5nLFxuICAgICAgICAgICAga25vdHMgPSBbXTtcblxuICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gbWluKDEsIGZyb20pO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IG1pbigxLCBsZW5ndGggLSB0byAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbiArPSBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodDtcbiAgICAgICAgaWYgKG4gPD0gMSkgcmV0dXJuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gZnJvbSAtIHBhZGRpbmdMZWZ0OyBpIDw9IG47IGkrKywgaisrKSB7XG4gICAgICAgICAga25vdHNbaV0gPSBzZWdtZW50c1soaiA8IDAgPyBqICsgbGVuZ3RoIDogaikgJSBsZW5ndGhdLl9wb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0ga25vdHNbMF0uX3ggKyAyICoga25vdHNbMV0uX3gsXG4gICAgICAgICAgICB5ID0ga25vdHNbMF0uX3kgKyAyICoga25vdHNbMV0uX3ksXG4gICAgICAgICAgICBmID0gMixcbiAgICAgICAgICAgIG5fMSA9IG4gLSAxLFxuICAgICAgICAgICAgcnggPSBbeF0sXG4gICAgICAgICAgICByeSA9IFt5XSxcbiAgICAgICAgICAgIHJmID0gW2ZdLFxuICAgICAgICAgICAgcHggPSBbXSxcbiAgICAgICAgICAgIHB5ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICB2YXIgaW50ZXJuYWwgPSBpIDwgbl8xLFxuICAgICAgICAgICAgICBhID0gaW50ZXJuYWwgPyAxIDogYXN5bW1ldHJpYyA/IDEgOiAyLFxuICAgICAgICAgICAgICBiID0gaW50ZXJuYWwgPyA0IDogYXN5bW1ldHJpYyA/IDIgOiA3LFxuICAgICAgICAgICAgICB1ID0gaW50ZXJuYWwgPyA0IDogYXN5bW1ldHJpYyA/IDMgOiA4LFxuICAgICAgICAgICAgICB2ID0gaW50ZXJuYWwgPyAyIDogYXN5bW1ldHJpYyA/IDAgOiAxLFxuICAgICAgICAgICAgICBtID0gYSAvIGY7XG4gICAgICAgICAgZiA9IHJmW2ldID0gYiAtIG07XG4gICAgICAgICAgeCA9IHJ4W2ldID0gdSAqIGtub3RzW2ldLl94ICsgdiAqIGtub3RzW2kgKyAxXS5feCAtIG0gKiB4O1xuICAgICAgICAgIHkgPSByeVtpXSA9IHUgKiBrbm90c1tpXS5feSArIHYgKiBrbm90c1tpICsgMV0uX3kgLSBtICogeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB4W25fMV0gPSByeFtuXzFdIC8gcmZbbl8xXTtcbiAgICAgICAgcHlbbl8xXSA9IHJ5W25fMV0gLyByZltuXzFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBuIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBweFtpXSA9IChyeFtpXSAtIHB4W2kgKyAxXSkgLyByZltpXTtcbiAgICAgICAgICBweVtpXSA9IChyeVtpXSAtIHB5W2kgKyAxXSkgLyByZltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB4W25dID0gKDMgKiBrbm90c1tuXS5feCAtIHB4W25fMV0pIC8gMjtcbiAgICAgICAgcHlbbl0gPSAoMyAqIGtub3RzW25dLl95IC0gcHlbbl8xXSkgLyAyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBwYWRkaW5nTGVmdCwgbWF4ID0gbiAtIHBhZGRpbmdSaWdodCwgaiA9IGZyb207IGkgPD0gbWF4OyBpKyssIGorKykge1xuICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaiA8IDAgPyBqICsgbGVuZ3RoIDogal0sXG4gICAgICAgICAgICAgIHB0ID0gc2VnbWVudC5fcG9pbnQsXG4gICAgICAgICAgICAgIGh4ID0gcHhbaV0gLSBwdC5feCxcbiAgICAgICAgICAgICAgaHkgPSBweVtpXSAtIHB0Ll95O1xuICAgICAgICAgIGlmIChsb29wIHx8IGkgPCBtYXgpIHNlZ21lbnQuc2V0SGFuZGxlT3V0KGh4LCBoeSk7XG4gICAgICAgICAgaWYgKGxvb3AgfHwgaSA+IHBhZGRpbmdMZWZ0KSBzZWdtZW50LnNldEhhbmRsZUluKC1oeCwgLWh5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb207IGkgPD0gdG87IGkrKykge1xuICAgICAgICAgIHNlZ21lbnRzW2kgPCAwID8gaSArIGxlbmd0aCA6IGldLnNtb290aChvcHRzLCAhbG9vcCAmJiBpID09PSBmcm9tLCAhbG9vcCAmJiBpID09PSB0byk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHRvU2hhcGU6IGZ1bmN0aW9uIChpbnNlcnQpIHtcbiAgICAgIGlmICghdGhpcy5fY2xvc2VkKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgdG9wQ2VudGVyO1xuXG4gICAgICBmdW5jdGlvbiBpc0NvbGxpbmVhcihpLCBqKSB7XG4gICAgICAgIHZhciBzZWcxID0gc2VnbWVudHNbaV0sXG4gICAgICAgICAgICBzZWcyID0gc2VnMS5nZXROZXh0KCksXG4gICAgICAgICAgICBzZWczID0gc2VnbWVudHNbal0sXG4gICAgICAgICAgICBzZWc0ID0gc2VnMy5nZXROZXh0KCk7XG4gICAgICAgIHJldHVybiBzZWcxLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMi5faGFuZGxlSW4uaXNaZXJvKCkgJiYgc2VnMy5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzQuX2hhbmRsZUluLmlzWmVybygpICYmIHNlZzIuX3BvaW50LnN1YnRyYWN0KHNlZzEuX3BvaW50KS5pc0NvbGxpbmVhcihzZWc0Ll9wb2ludC5zdWJ0cmFjdChzZWczLl9wb2ludCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc09ydGhvZ29uYWwoaSkge1xuICAgICAgICB2YXIgc2VnMiA9IHNlZ21lbnRzW2ldLFxuICAgICAgICAgICAgc2VnMSA9IHNlZzIuZ2V0UHJldmlvdXMoKSxcbiAgICAgICAgICAgIHNlZzMgPSBzZWcyLmdldE5leHQoKTtcbiAgICAgICAgcmV0dXJuIHNlZzEuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWcyLl9oYW5kbGVJbi5pc1plcm8oKSAmJiBzZWcyLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMy5faGFuZGxlSW4uaXNaZXJvKCkgJiYgc2VnMi5fcG9pbnQuc3VidHJhY3Qoc2VnMS5fcG9pbnQpLmlzT3J0aG9nb25hbChzZWczLl9wb2ludC5zdWJ0cmFjdChzZWcyLl9wb2ludCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0FyYyhpKSB7XG4gICAgICAgIHZhciBzZWcxID0gc2VnbWVudHNbaV0sXG4gICAgICAgICAgICBzZWcyID0gc2VnMS5nZXROZXh0KCksXG4gICAgICAgICAgICBoYW5kbGUxID0gc2VnMS5faGFuZGxlT3V0LFxuICAgICAgICAgICAgaGFuZGxlMiA9IHNlZzIuX2hhbmRsZUluLFxuICAgICAgICAgICAga2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzY7XG5cbiAgICAgICAgaWYgKGhhbmRsZTEuaXNPcnRob2dvbmFsKGhhbmRsZTIpKSB7XG4gICAgICAgICAgdmFyIHB0MSA9IHNlZzEuX3BvaW50LFxuICAgICAgICAgICAgICBwdDIgPSBzZWcyLl9wb2ludCxcbiAgICAgICAgICAgICAgY29ybmVyID0gbmV3IExpbmUocHQxLCBoYW5kbGUxLCB0cnVlKS5pbnRlcnNlY3QobmV3IExpbmUocHQyLCBoYW5kbGUyLCB0cnVlKSwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIGNvcm5lciAmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTEuZ2V0TGVuZ3RoKCkgLyBjb3JuZXIuc3VidHJhY3QocHQxKS5nZXRMZW5ndGgoKSAtIGthcHBhKSAmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTIuZ2V0TGVuZ3RoKCkgLyBjb3JuZXIuc3VidHJhY3QocHQyKS5nZXRMZW5ndGgoKSAtIGthcHBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0RGlzdGFuY2UoaSwgaikge1xuICAgICAgICByZXR1cm4gc2VnbWVudHNbaV0uX3BvaW50LmdldERpc3RhbmNlKHNlZ21lbnRzW2pdLl9wb2ludCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oYXNIYW5kbGVzKCkgJiYgc2VnbWVudHMubGVuZ3RoID09PSA0ICYmIGlzQ29sbGluZWFyKDAsIDIpICYmIGlzQ29sbGluZWFyKDEsIDMpICYmIGlzT3J0aG9nb25hbCgxKSkge1xuICAgICAgICB0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuICAgICAgICBzaXplID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMCwgMyksIGdldERpc3RhbmNlKDAsIDEpKTtcbiAgICAgICAgdG9wQ2VudGVyID0gc2VnbWVudHNbMV0uX3BvaW50LmFkZChzZWdtZW50c1syXS5fcG9pbnQpLmRpdmlkZSgyKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA4ICYmIGlzQXJjKDApICYmIGlzQXJjKDIpICYmIGlzQXJjKDQpICYmIGlzQXJjKDYpICYmIGlzQ29sbGluZWFyKDEsIDUpICYmIGlzQ29sbGluZWFyKDMsIDcpKSB7XG4gICAgICAgIHR5cGUgPSBTaGFwZS5SZWN0YW5nbGU7XG4gICAgICAgIHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgxLCA2KSwgZ2V0RGlzdGFuY2UoMCwgMykpO1xuICAgICAgICByYWRpdXMgPSBzaXplLnN1YnRyYWN0KG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDcpLCBnZXREaXN0YW5jZSgxLCAyKSkpLmRpdmlkZSgyKTtcbiAgICAgICAgdG9wQ2VudGVyID0gc2VnbWVudHNbM10uX3BvaW50LmFkZChzZWdtZW50c1s0XS5fcG9pbnQpLmRpdmlkZSgyKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA0ICYmIGlzQXJjKDApICYmIGlzQXJjKDEpICYmIGlzQXJjKDIpICYmIGlzQXJjKDMpKSB7XG4gICAgICAgIGlmIChOdW1lcmljYWwuaXNaZXJvKGdldERpc3RhbmNlKDAsIDIpIC0gZ2V0RGlzdGFuY2UoMSwgMykpKSB7XG4gICAgICAgICAgdHlwZSA9IFNoYXBlLkNpcmNsZTtcbiAgICAgICAgICByYWRpdXMgPSBnZXREaXN0YW5jZSgwLCAyKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IFNoYXBlLkVsbGlwc2U7XG4gICAgICAgICAgcmFkaXVzID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMiwgMCkgLyAyLCBnZXREaXN0YW5jZSgzLCAxKSAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9wQ2VudGVyID0gc2VnbWVudHNbMV0uX3BvaW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSkge1xuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKSxcbiAgICAgICAgICAgIHNoYXBlID0gbmV3IHR5cGUoe1xuICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgaW5zZXJ0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgc2hhcGUuY29weUF0dHJpYnV0ZXModGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgc2hhcGUuX21hdHJpeC5wcmVwZW5kKHRoaXMuX21hdHJpeCk7XG5cbiAgICAgICAgc2hhcGUucm90YXRlKHRvcENlbnRlci5zdWJ0cmFjdChjZW50ZXIpLmdldEFuZ2xlKCkgKyA5MCk7XG4gICAgICAgIGlmIChpbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBpbnNlcnQpIHNoYXBlLmluc2VydEFib3ZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgdG9QYXRoOiAnI2Nsb25lJyxcbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKHBhdGgpIHtcbiAgICAgIGlmICghcGF0aCB8fCBwYXRoIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSByZXR1cm4gY29tcGFyZS5iYXNlLmNhbGwodGhpcywgcGF0aCk7XG4gICAgICB2YXIgY3VydmVzMSA9IHRoaXMuZ2V0Q3VydmVzKCksXG4gICAgICAgICAgY3VydmVzMiA9IHBhdGguZ2V0Q3VydmVzKCksXG4gICAgICAgICAgbGVuZ3RoMSA9IGN1cnZlczEubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aDIgPSBjdXJ2ZXMyLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgxIHx8ICFsZW5ndGgyKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGgxID09IGxlbmd0aDI7XG4gICAgICB9XG5cbiAgICAgIHZhciB2MSA9IGN1cnZlczFbMF0uZ2V0VmFsdWVzKCksXG4gICAgICAgICAgdmFsdWVzMiA9IFtdLFxuICAgICAgICAgIHBvczEgPSAwLFxuICAgICAgICAgIHBvczIsXG4gICAgICAgICAgZW5kMSA9IDAsXG4gICAgICAgICAgZW5kMjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgdmFyIHYyID0gY3VydmVzMltpXS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFsdWVzMi5wdXNoKHYyKTtcbiAgICAgICAgdmFyIG92ZXJsYXBzID0gQ3VydmUuZ2V0T3ZlcmxhcHModjEsIHYyKTtcblxuICAgICAgICBpZiAob3ZlcmxhcHMpIHtcbiAgICAgICAgICBwb3MyID0gIWkgJiYgb3ZlcmxhcHNbMF1bMF0gPiAwID8gbGVuZ3RoMiAtIDEgOiBpO1xuICAgICAgICAgIGVuZDIgPSBvdmVybGFwc1swXVsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgZXBzaWxvbiA9IDFlLTgsXG4gICAgICAgICAgdjIgPSB2YWx1ZXMyW3BvczJdLFxuICAgICAgICAgIHN0YXJ0MjtcblxuICAgICAgd2hpbGUgKHYxICYmIHYyKSB7XG4gICAgICAgIHZhciBvdmVybGFwcyA9IEN1cnZlLmdldE92ZXJsYXBzKHYxLCB2Mik7XG5cbiAgICAgICAgaWYgKG92ZXJsYXBzKSB7XG4gICAgICAgICAgdmFyIHQxID0gb3ZlcmxhcHNbMF1bMF07XG5cbiAgICAgICAgICBpZiAoYWJzKHQxIC0gZW5kMSkgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICBlbmQxID0gb3ZlcmxhcHNbMV1bMF07XG5cbiAgICAgICAgICAgIGlmIChlbmQxID09PSAxKSB7XG4gICAgICAgICAgICAgIHYxID0gKytwb3MxIDwgbGVuZ3RoMSA/IGN1cnZlczFbcG9zMV0uZ2V0VmFsdWVzKCkgOiBudWxsO1xuICAgICAgICAgICAgICBlbmQxID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHQyID0gb3ZlcmxhcHNbMF1bMV07XG5cbiAgICAgICAgICAgIGlmIChhYnModDIgLSBlbmQyKSA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFzdGFydDIpIHN0YXJ0MiA9IFtwb3MyLCB0Ml07XG4gICAgICAgICAgICAgIGVuZDIgPSBvdmVybGFwc1sxXVsxXTtcblxuICAgICAgICAgICAgICBpZiAoZW5kMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICgrK3BvczIgPj0gbGVuZ3RoMikgcG9zMiA9IDA7XG4gICAgICAgICAgICAgICAgdjIgPSB2YWx1ZXMyW3BvczJdIHx8IGN1cnZlczJbcG9zMl0uZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgZW5kMiA9IDA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXYxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0MlswXSA9PT0gcG9zMiAmJiBzdGFydDJbMV0gPT09IGVuZDI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgX2hpdFRlc3RTZWxmOiBmdW5jdGlvbiAocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuICAgICAgICAgIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgY2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuICAgICAgICAgIHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nLFxuICAgICAgICAgIHN0cm9rZVBhZGRpbmcgPSB0b2xlcmFuY2VQYWRkaW5nLFxuICAgICAgICAgIGpvaW4sXG4gICAgICAgICAgY2FwLFxuICAgICAgICAgIG1pdGVyTGltaXQsXG4gICAgICAgICAgYXJlYSxcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgcmVzLFxuICAgICAgICAgIGhpdFN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuICAgICAgICAgIGhpdEZpbGwgPSBvcHRpb25zLmZpbGwgJiYgc3R5bGUuaGFzRmlsbCgpLFxuICAgICAgICAgIGhpdEN1cnZlcyA9IG9wdGlvbnMuY3VydmVzLFxuICAgICAgICAgIHN0cm9rZVJhZGl1cyA9IGhpdFN0cm9rZSA/IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyIDogaGl0RmlsbCAmJiBvcHRpb25zLnRvbGVyYW5jZSA+IDAgfHwgaGl0Q3VydmVzID8gMCA6IG51bGw7XG5cbiAgICAgIGlmIChzdHJva2VSYWRpdXMgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cm9rZVJhZGl1cyA+IDApIHtcbiAgICAgICAgICBqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpO1xuICAgICAgICAgIGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpO1xuICAgICAgICAgIG1pdGVyTGltaXQgPSBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgICAgc3Ryb2tlUGFkZGluZyA9IHN0cm9rZVBhZGRpbmcuYWRkKFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlUmFkaXVzLCBzdHJva2VNYXRyaXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqb2luID0gY2FwID0gJ3JvdW5kJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0Nsb3NlRW5vdWdoKHB0LCBwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiBwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHBhZGRpbmcpLmxlbmd0aCA8PSAxO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHB0LCBuYW1lKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5zZWxlY3RlZCB8fCBwdC5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICB2YXIgYW5jaG9yID0gc2VnLl9wb2ludDtcbiAgICAgICAgICBpZiAocHQgIT09IGFuY2hvcikgcHQgPSBwdC5hZGQoYW5jaG9yKTtcblxuICAgICAgICAgIGlmIChpc0Nsb3NlRW5vdWdoKHB0LCBzdHJva2VQYWRkaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXRSZXN1bHQobmFtZSwgdGhhdCwge1xuICAgICAgICAgICAgICBzZWdtZW50OiBzZWcsXG4gICAgICAgICAgICAgIHBvaW50OiBwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50cyhzZWcsIGVuZHMpIHtcbiAgICAgICAgcmV0dXJuIChlbmRzIHx8IG9wdGlvbnMuc2VnbWVudHMpICYmIGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9wb2ludCwgJ3NlZ21lbnQnKSB8fCAhZW5kcyAmJiBvcHRpb25zLmhhbmRsZXMgJiYgKGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVJbiwgJ2hhbmRsZS1pbicpIHx8IGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVPdXQsICdoYW5kbGUtb3V0JykpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRUb0FyZWEocG9pbnQpIHtcbiAgICAgICAgYXJlYS5hZGQocG9pbnQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkge1xuICAgICAgICB2YXIgaXNKb2luID0gY2xvc2VkIHx8IHNlZ21lbnQuX2luZGV4ID4gMCAmJiBzZWdtZW50Ll9pbmRleCA8IG51bVNlZ21lbnRzIC0gMTtcblxuICAgICAgICBpZiAoKGlzSm9pbiA/IGpvaW4gOiBjYXApID09PSAncm91bmQnKSB7XG4gICAgICAgICAgcmV0dXJuIGlzQ2xvc2VFbm91Z2goc2VnbWVudC5fcG9pbnQsIHN0cm9rZVBhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZWEgPSBuZXcgUGF0aCh7XG4gICAgICAgICAgICBpbnRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgIGNsb3NlZDogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGlzSm9pbikge1xuICAgICAgICAgICAgaWYgKCFzZWdtZW50LmlzU21vb3RoKCkpIHtcbiAgICAgICAgICAgICAgUGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHN0cm9rZVJhZGl1cywgbWl0ZXJMaW1pdCwgbnVsbCwgc3Ryb2tlTWF0cml4LCBhZGRUb0FyZWEsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY2FwID09PSAnc3F1YXJlJykge1xuICAgICAgICAgICAgUGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgc3Ryb2tlUmFkaXVzLCBudWxsLCBzdHJva2VNYXRyaXgsIGFkZFRvQXJlYSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhcmVhLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIGxvYztcbiAgICAgICAgICAgIHJldHVybiBhcmVhLmNvbnRhaW5zKHBvaW50KSB8fCAobG9jID0gYXJlYS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpKSAmJiBpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCB0b2xlcmFuY2VQYWRkaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZW5kcyAmJiAhb3B0aW9ucy5zZWdtZW50cyAmJiAhY2xvc2VkKSB7XG4gICAgICAgIGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbMF0sIHRydWUpIHx8IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLCB0cnVlKSkgcmV0dXJuIHJlcztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZWdtZW50cyB8fCBvcHRpb25zLmhhbmRsZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSBpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW2ldKSkgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cm9rZVJhZGl1cyAhPT0gbnVsbCkge1xuICAgICAgICBsb2MgPSB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cbiAgICAgICAgaWYgKGxvYykge1xuICAgICAgICAgIHZhciB0aW1lID0gbG9jLmdldFRpbWUoKTtcblxuICAgICAgICAgIGlmICh0aW1lID09PSAwIHx8IHRpbWUgPT09IDEgJiYgbnVtU2VnbWVudHMgPiAxKSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrU2VnbWVudFN0cm9rZShsb2MuZ2V0U2VnbWVudCgpKSkgbG9jID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCBzdHJva2VQYWRkaW5nKSkge1xuICAgICAgICAgICAgbG9jID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxvYyAmJiBqb2luID09PSAnbWl0ZXInICYmIG51bVNlZ21lbnRzID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKHBvaW50LmdldERpc3RhbmNlKHNlZ21lbnQuX3BvaW50KSA8PSBtaXRlckxpbWl0ICogc3Ryb2tlUmFkaXVzICYmIGNoZWNrU2VnbWVudFN0cm9rZShzZWdtZW50KSkge1xuICAgICAgICAgICAgICBsb2MgPSBzZWdtZW50LmdldExvY2F0aW9uKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gIWxvYyAmJiBoaXRGaWxsICYmIHRoaXMuX2NvbnRhaW5zKHBvaW50KSB8fCBsb2MgJiYgIWhpdFN0cm9rZSAmJiAhaGl0Q3VydmVzID8gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpIDogbG9jID8gbmV3IEhpdFJlc3VsdChoaXRTdHJva2UgPyAnc3Ryb2tlJyA6ICdjdXJ2ZScsIHRoaXMsIHtcbiAgICAgICAgbG9jYXRpb246IGxvYyxcbiAgICAgICAgcG9pbnQ6IGxvYy5nZXRQb2ludCgpXG4gICAgICB9KSA6IG51bGw7XG4gICAgfVxuICB9LCBCYXNlLmVhY2goQ3VydmUuX2V2YWx1YXRlTWV0aG9kcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uQXQob2Zmc2V0KTtcbiAgICAgIHJldHVybiBsb2MgJiYgbG9jW25hbWVdKCk7XG4gICAgfTtcbiAgfSwge1xuICAgIGJlYW5zOiBmYWxzZSxcbiAgICBnZXRMb2NhdGlvbk9mOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TG9jYXRpb25PZihwb2ludCk7XG4gICAgICAgIGlmIChsb2MpIHJldHVybiBsb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0T2Zmc2V0T2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uT2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuICAgIH0sXG4gICAgZ2V0TG9jYXRpb25BdDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuICAgICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBsZW5ndGgsXG4gICAgICAgICAgICAgIGN1cnZlID0gY3VydmVzW2ldO1xuICAgICAgICAgIGxlbmd0aCArPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblxuICAgICAgICAgIGlmIChsZW5ndGggPiBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJ2ZS5nZXRMb2NhdGlvbkF0KG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VydmVzLmxlbmd0aCA+IDAgJiYgb2Zmc2V0IDw9IHRoaXMuZ2V0TGVuZ3RoKCkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24oY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ICYmIG9mZnNldC5nZXRQYXRoICYmIG9mZnNldC5nZXRQYXRoKCkgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBnZXRPZmZzZXRzV2l0aFRhbmdlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0YW5nZW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXG4gICAgICBpZiAodGFuZ2VudC5pc1plcm8oKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXRzID0gW107XG4gICAgICB2YXIgY3VydmVTdGFydCA9IDA7XG4gICAgICB2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IGN1cnZlc1tpXTtcbiAgICAgICAgdmFyIGN1cnZlVGltZXMgPSBjdXJ2ZS5nZXRUaW1lc1dpdGhUYW5nZW50KHRhbmdlbnQpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBtID0gY3VydmVUaW1lcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gY3VydmVTdGFydCArIGN1cnZlLmdldE9mZnNldEF0VGltZShjdXJ2ZVRpbWVzW2pdKTtcblxuICAgICAgICAgIGlmIChvZmZzZXRzLmluZGV4T2Yob2Zmc2V0KSA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnZlU3RhcnQgKz0gY3VydmUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0cztcbiAgICB9XG4gIH0pLCBuZXcgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRyYXdIYW5kbGVzKGN0eCwgc2VnbWVudHMsIG1hdHJpeCwgc2l6ZSkge1xuICAgICAgaWYgKHNpemUgPD0gMCkgcmV0dXJuO1xuICAgICAgdmFyIGhhbGYgPSBzaXplIC8gMixcbiAgICAgICAgICBtaW5pU2l6ZSA9IHNpemUgLSAyLFxuICAgICAgICAgIG1pbmlIYWxmID0gaGFsZiAtIDEsXG4gICAgICAgICAgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuICAgICAgICAgIHBYLFxuICAgICAgICAgIHBZO1xuXG4gICAgICBmdW5jdGlvbiBkcmF3SGFuZGxlKGluZGV4KSB7XG4gICAgICAgIHZhciBoWCA9IGNvb3Jkc1tpbmRleF0sXG4gICAgICAgICAgICBoWSA9IGNvb3Jkc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChwWCAhPSBoWCB8fCBwWSAhPSBoWSkge1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHBYLCBwWSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhoWCwgaFkpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4LmFyYyhoWCwgaFksIGhhbGYsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV0sXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBzZWdtZW50Ll9zZWxlY3Rpb247XG5cbiAgICAgICAgc2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMpO1xuXG4gICAgICAgIHBYID0gY29vcmRzWzBdO1xuICAgICAgICBwWSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmIDIpIGRyYXdIYW5kbGUoMik7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiA0KSBkcmF3SGFuZGxlKDQpO1xuICAgICAgICBjdHguZmlsbFJlY3QocFggLSBoYWxmLCBwWSAtIGhhbGYsIHNpemUsIHNpemUpO1xuXG4gICAgICAgIGlmIChtaW5pU2l6ZSA+IDAgJiYgIShzZWxlY3Rpb24gJiAxKSkge1xuICAgICAgICAgIHZhciBmaWxsU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmZmZmZic7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHBYIC0gbWluaUhhbGYsIHBZIC0gbWluaUhhbGYsIG1pbmlTaXplLCBtaW5pU2l6ZSk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdTZWdtZW50cyhjdHgsIHBhdGgsIG1hdHJpeCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuICAgICAgICAgIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcbiAgICAgICAgICBmaXJzdCA9IHRydWUsXG4gICAgICAgICAgY3VyWCxcbiAgICAgICAgICBjdXJZLFxuICAgICAgICAgIHByZXZYLFxuICAgICAgICAgIHByZXZZLFxuICAgICAgICAgIGluWCxcbiAgICAgICAgICBpblksXG4gICAgICAgICAgb3V0WCxcbiAgICAgICAgICBvdXRZO1xuXG4gICAgICBmdW5jdGlvbiBkcmF3U2VnbWVudChzZWdtZW50KSB7XG4gICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICBzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3Jkcyk7XG5cbiAgICAgICAgICBjdXJYID0gY29vcmRzWzBdO1xuICAgICAgICAgIGN1clkgPSBjb29yZHNbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gc2VnbWVudC5fcG9pbnQ7XG4gICAgICAgICAgY3VyWCA9IHBvaW50Ll94O1xuICAgICAgICAgIGN1clkgPSBwb2ludC5feTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIGN0eC5tb3ZlVG8oY3VyWCwgY3VyWSk7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICBpblggPSBjb29yZHNbMl07XG4gICAgICAgICAgICBpblkgPSBjb29yZHNbM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVJbjtcbiAgICAgICAgICAgIGluWCA9IGN1clggKyBoYW5kbGUuX3g7XG4gICAgICAgICAgICBpblkgPSBjdXJZICsgaGFuZGxlLl95O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpblggPT09IGN1clggJiYgaW5ZID09PSBjdXJZICYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGN1clgsIGN1clkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhvdXRYLCBvdXRZLCBpblgsIGluWSwgY3VyWCwgY3VyWSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJldlggPSBjdXJYO1xuICAgICAgICBwcmV2WSA9IGN1clk7XG5cbiAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgIG91dFggPSBjb29yZHNbNF07XG4gICAgICAgICAgb3V0WSA9IGNvb3Jkc1s1XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlT3V0O1xuICAgICAgICAgIG91dFggPSBwcmV2WCArIGhhbmRsZS5feDtcbiAgICAgICAgICBvdXRZID0gcHJldlkgKyBoYW5kbGUuX3k7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgZHJhd1NlZ21lbnQoc2VnbWVudHNbaV0pO1xuXG4gICAgICBpZiAocGF0aC5fY2xvc2VkICYmIGxlbmd0aCA+IDApIGRyYXdTZWdtZW50KHNlZ21lbnRzWzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgX2RyYXc6IGZ1bmN0aW9uIChjdHgsIHBhcmFtLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcbiAgICAgICAgdmFyIGRvbnRTdGFydCA9IHBhcmFtLmRvbnRTdGFydCxcbiAgICAgICAgICAgIGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcCxcbiAgICAgICAgICAgIHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuICAgICAgICAgICAgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcbiAgICAgICAgICAgIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpLFxuICAgICAgICAgICAgZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG4gICAgICAgICAgICBkYXNoTGVuZ3RoID0gIXBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCAmJiBoYXNTdHJva2UgJiYgZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGg7XG4gICAgICAgIGlmICghZG9udFN0YXJ0KSBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgaWYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlICYmICFkYXNoTGVuZ3RoIHx8IGRvbnRQYWludCkge1xuICAgICAgICAgIGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIHN0cm9rZU1hdHJpeCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0T2Zmc2V0KGkpIHtcbiAgICAgICAgICByZXR1cm4gZGFzaEFycmF5WyhpICUgZGFzaExlbmd0aCArIGRhc2hMZW5ndGgpICUgZGFzaExlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG4gICAgICAgICAgdGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXG4gICAgICAgICAgaWYgKGhhc0ZpbGwpIHtcbiAgICAgICAgICAgIGN0eC5maWxsKHN0eWxlLmdldEZpbGxSdWxlKCkpO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNTdHJva2UpIHtcbiAgICAgICAgICAgIGlmIChkYXNoTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmICghZG9udFN0YXJ0KSBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIHZhciBmbGF0dGVuZXIgPSBuZXcgUGF0aEZsYXR0ZW5lcih0aGlzLCAwLjI1LCAzMiwgZmFsc2UsIHN0cm9rZU1hdHJpeCksXG4gICAgICAgICAgICAgICAgICBsZW5ndGggPSBmbGF0dGVuZXIubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgZnJvbSA9IC1zdHlsZS5nZXREYXNoT2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChmcm9tID4gMCkge1xuICAgICAgICAgICAgICAgIGZyb20gLT0gZ2V0T2Zmc2V0KGktLSkgKyBnZXRPZmZzZXQoaS0tKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHdoaWxlIChmcm9tIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgZ2V0T2Zmc2V0KGkrKyk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiAwIHx8IHRvID4gMCkgZmxhdHRlbmVyLmRyYXdQYXJ0KGN0eCwgTWF0aC5tYXgoZnJvbSwgMCksIE1hdGgubWF4KHRvLCAwKSk7XG4gICAgICAgICAgICAgICAgZnJvbSA9IHRvICsgZ2V0T2Zmc2V0KGkrKyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uIChjdHgsIG1hdHJpeCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIG1hdHJpeCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgZHJhd0hhbmRsZXMoY3R4LCB0aGlzLl9zZWdtZW50cywgbWF0cml4LCBwYXBlci5zZXR0aW5ncy5oYW5kbGVTaXplKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCksIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFNlZ21lbnQodGhhdCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhhdC5fc2VnbWVudHM7XG4gICAgICBpZiAoIXNlZ21lbnRzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG4gICAgICByZXR1cm4gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1vdmVUbzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMSkgdGhpcy5yZW1vdmVTZWdtZW50KDApO1xuICAgICAgICBpZiAoIXNlZ21lbnRzLmxlbmd0aCkgdGhpcy5fYWRkKFtuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpXSk7XG4gICAgICB9LFxuICAgICAgbW92ZUJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW92ZUJ5KCkgaXMgdW5zdXBwb3J0ZWQgb24gUGF0aCBpdGVtcy4nKTtcbiAgICAgIH0sXG4gICAgICBsaW5lVG86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWRkKFtuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpXSk7XG4gICAgICB9LFxuICAgICAgY3ViaWNDdXJ2ZVRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaGFuZGxlMSA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICBoYW5kbGUyID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHRvID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKTtcbiAgICAgICAgY3VycmVudC5zZXRIYW5kbGVPdXQoaGFuZGxlMS5zdWJ0cmFjdChjdXJyZW50Ll9wb2ludCkpO1xuXG4gICAgICAgIHRoaXMuX2FkZChbbmV3IFNlZ21lbnQodG8sIGhhbmRsZTIuc3VidHJhY3QodG8pKV0pO1xuICAgICAgfSxcbiAgICAgIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblxuICAgICAgICB0aGlzLmN1YmljQ3VydmVUbyhoYW5kbGUuYWRkKGN1cnJlbnQuc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLCBoYW5kbGUuYWRkKHRvLnN1YnRyYWN0KGhhbmRsZSkubXVsdGlwbHkoMSAvIDMpKSwgdG8pO1xuICAgICAgfSxcbiAgICAgIGN1cnZlVG86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICB0aHJvdWdoID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHRvID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHQgPSBCYXNlLnBpY2soQmFzZS5yZWFkKGFyZ3MpLCAwLjUpLFxuICAgICAgICAgICAgdDEgPSAxIC0gdCxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG4gICAgICAgICAgICBoYW5kbGUgPSB0aHJvdWdoLnN1YnRyYWN0KGN1cnJlbnQubXVsdGlwbHkodDEgKiB0MSkpLnN1YnRyYWN0KHRvLm11bHRpcGx5KHQgKiB0KSkuZGl2aWRlKDIgKiB0ICogdDEpO1xuXG4gICAgICAgIGlmIChoYW5kbGUuaXNOYU4oKSkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcHV0IGEgY3VydmUgdGhyb3VnaCBwb2ludHMgd2l0aCBwYXJhbWV0ZXIgPSAnICsgdCk7XG4gICAgICAgIHRoaXMucXVhZHJhdGljQ3VydmVUbyhoYW5kbGUsIHRvKTtcbiAgICAgIH0sXG4gICAgICBhcmNUbzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgc3FydCA9IE1hdGguc3FydCxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKSxcbiAgICAgICAgICAgIGZyb20gPSBjdXJyZW50Ll9wb2ludCxcbiAgICAgICAgICAgIHRvID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHRocm91Z2gsXG4gICAgICAgICAgICBwZWVrID0gQmFzZS5wZWVrKGFyZ3MpLFxuICAgICAgICAgICAgY2xvY2t3aXNlID0gQmFzZS5waWNrKHBlZWssIHRydWUpLFxuICAgICAgICAgICAgY2VudGVyLFxuICAgICAgICAgICAgZXh0ZW50LFxuICAgICAgICAgICAgdmVjdG9yLFxuICAgICAgICAgICAgbWF0cml4O1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2xvY2t3aXNlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB2YXIgbWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcbiAgICAgICAgICAgICAgdGhyb3VnaCA9IG1pZGRsZS5hZGQobWlkZGxlLnN1YnRyYWN0KGZyb20pLnJvdGF0ZShjbG9ja3dpc2UgPyAtOTAgOiA5MCkpO1xuICAgICAgICB9IGVsc2UgaWYgKEJhc2UucmVtYWluKGFyZ3MpIDw9IDIpIHtcbiAgICAgICAgICB0aHJvdWdoID0gdG87XG4gICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKCFmcm9tLmVxdWFscyh0bykpIHtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgICBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuICAgICAgICAgIGlmIChpc1plcm8ocmFkaXVzLndpZHRoKSB8fCBpc1plcm8ocmFkaXVzLmhlaWdodCkpIHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG4gICAgICAgICAgdmFyIHJvdGF0aW9uID0gQmFzZS5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgICBjbG9ja3dpc2UgPSAhIUJhc2UucmVhZChhcmdzKSxcbiAgICAgICAgICAgICAgbGFyZ2UgPSAhIUJhc2UucmVhZChhcmdzKSxcbiAgICAgICAgICAgICAgbWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcbiAgICAgICAgICAgICAgcHQgPSBmcm9tLnN1YnRyYWN0KG1pZGRsZSkucm90YXRlKC1yb3RhdGlvbiksXG4gICAgICAgICAgICAgIHggPSBwdC54LFxuICAgICAgICAgICAgICB5ID0gcHQueSxcbiAgICAgICAgICAgICAgcnggPSBhYnMocmFkaXVzLndpZHRoKSxcbiAgICAgICAgICAgICAgcnkgPSBhYnMocmFkaXVzLmhlaWdodCksXG4gICAgICAgICAgICAgIHJ4U3EgPSByeCAqIHJ4LFxuICAgICAgICAgICAgICByeVNxID0gcnkgKiByeSxcbiAgICAgICAgICAgICAgeFNxID0geCAqIHgsXG4gICAgICAgICAgICAgIHlTcSA9IHkgKiB5O1xuICAgICAgICAgIHZhciBmYWN0b3IgPSBzcXJ0KHhTcSAvIHJ4U3EgKyB5U3EgLyByeVNxKTtcblxuICAgICAgICAgIGlmIChmYWN0b3IgPiAxKSB7XG4gICAgICAgICAgICByeCAqPSBmYWN0b3I7XG4gICAgICAgICAgICByeSAqPSBmYWN0b3I7XG4gICAgICAgICAgICByeFNxID0gcnggKiByeDtcbiAgICAgICAgICAgIHJ5U3EgPSByeSAqIHJ5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZhY3RvciA9IChyeFNxICogcnlTcSAtIHJ4U3EgKiB5U3EgLSByeVNxICogeFNxKSAvIChyeFNxICogeVNxICsgcnlTcSAqIHhTcSk7XG4gICAgICAgICAgaWYgKGFicyhmYWN0b3IpIDwgMWUtMTIpIGZhY3RvciA9IDA7XG4gICAgICAgICAgaWYgKGZhY3RvciA8IDApIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBhbiBhcmMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzJyk7XG4gICAgICAgICAgY2VudGVyID0gbmV3IFBvaW50KHJ4ICogeSAvIHJ5LCAtcnkgKiB4IC8gcngpLm11bHRpcGx5KChsYXJnZSA9PT0gY2xvY2t3aXNlID8gLTEgOiAxKSAqIHNxcnQoZmFjdG9yKSkucm90YXRlKHJvdGF0aW9uKS5hZGQobWlkZGxlKTtcbiAgICAgICAgICBtYXRyaXggPSBuZXcgTWF0cml4KCkudHJhbnNsYXRlKGNlbnRlcikucm90YXRlKHJvdGF0aW9uKS5zY2FsZShyeCwgcnkpO1xuICAgICAgICAgIHZlY3RvciA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShmcm9tKTtcbiAgICAgICAgICBleHRlbnQgPSB2ZWN0b3IuZ2V0RGlyZWN0ZWRBbmdsZShtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0odG8pKTtcbiAgICAgICAgICBpZiAoIWNsb2Nrd2lzZSAmJiBleHRlbnQgPiAwKSBleHRlbnQgLT0gMzYwO2Vsc2UgaWYgKGNsb2Nrd2lzZSAmJiBleHRlbnQgPCAwKSBleHRlbnQgKz0gMzYwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRocm91Z2gpIHtcbiAgICAgICAgICB2YXIgbDEgPSBuZXcgTGluZShmcm9tLmFkZCh0aHJvdWdoKS5kaXZpZGUoMiksIHRocm91Z2guc3VidHJhY3QoZnJvbSkucm90YXRlKDkwKSwgdHJ1ZSksXG4gICAgICAgICAgICAgIGwyID0gbmV3IExpbmUodGhyb3VnaC5hZGQodG8pLmRpdmlkZSgyKSwgdG8uc3VidHJhY3QodGhyb3VnaCkucm90YXRlKDkwKSwgdHJ1ZSksXG4gICAgICAgICAgICAgIGxpbmUgPSBuZXcgTGluZShmcm9tLCB0byksXG4gICAgICAgICAgICAgIHRocm91Z2hTaWRlID0gbGluZS5nZXRTaWRlKHRocm91Z2gpO1xuICAgICAgICAgIGNlbnRlciA9IGwxLmludGVyc2VjdChsMiwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoIWNlbnRlcikge1xuICAgICAgICAgICAgaWYgKCF0aHJvdWdoU2lkZSkgcmV0dXJuIHRoaXMubGluZVRvKHRvKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBhbiBhcmMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmVjdG9yID0gZnJvbS5zdWJ0cmFjdChjZW50ZXIpO1xuICAgICAgICAgIGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKHRvLnN1YnRyYWN0KGNlbnRlcikpO1xuICAgICAgICAgIHZhciBjZW50ZXJTaWRlID0gbGluZS5nZXRTaWRlKGNlbnRlciwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoY2VudGVyU2lkZSA9PT0gMCkge1xuICAgICAgICAgICAgZXh0ZW50ID0gdGhyb3VnaFNpZGUgKiBhYnMoZXh0ZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRocm91Z2hTaWRlID09PSBjZW50ZXJTaWRlKSB7XG4gICAgICAgICAgICBleHRlbnQgKz0gZXh0ZW50IDwgMCA/IDM2MCA6IC0zNjA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dGVudCkge1xuICAgICAgICAgIHZhciBlcHNpbG9uID0gMWUtNyxcbiAgICAgICAgICAgICAgZXh0ID0gYWJzKGV4dGVudCksXG4gICAgICAgICAgICAgIGNvdW50ID0gZXh0ID49IDM2MCA/IDQgOiBNYXRoLmNlaWwoKGV4dCAtIGVwc2lsb24pIC8gOTApLFxuICAgICAgICAgICAgICBpbmMgPSBleHRlbnQgLyBjb3VudCxcbiAgICAgICAgICAgICAgaGFsZiA9IGluYyAqIE1hdGguUEkgLyAzNjAsXG4gICAgICAgICAgICAgIHogPSA0IC8gMyAqIE1hdGguc2luKGhhbGYpIC8gKDEgKyBNYXRoLmNvcyhoYWxmKSksXG4gICAgICAgICAgICAgIHNlZ21lbnRzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHQgPSB0byxcbiAgICAgICAgICAgICAgICBvdXQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICAgIG91dCA9IHZlY3Rvci5yb3RhdGUoOTApLm11bHRpcGx5KHopO1xuXG4gICAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBwdCA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yKTtcbiAgICAgICAgICAgICAgICBvdXQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQob3V0KSkuc3VidHJhY3QocHQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB0ID0gY2VudGVyLmFkZCh2ZWN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICBjdXJyZW50LnNldEhhbmRsZU91dChvdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbiA9IHZlY3Rvci5yb3RhdGUoLTkwKS5tdWx0aXBseSh6KTtcblxuICAgICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgX2luID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKF9pbikpLnN1YnRyYWN0KHB0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocHQsIF9pbiwgb3V0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlY3RvciA9IHZlY3Rvci5yb3RhdGUoaW5jKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9hZGQoc2VnbWVudHMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGluZUJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cbiAgICAgICAgdGhpcy5saW5lVG8oY3VycmVudC5hZGQodG8pKTtcbiAgICAgIH0sXG4gICAgICBjdXJ2ZUJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICBwYXJhbWV0ZXIgPSBCYXNlLnJlYWQoYXJncyksXG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXG4gICAgICAgIHRoaXMuY3VydmVUbyhjdXJyZW50LmFkZCh0aHJvdWdoKSwgY3VycmVudC5hZGQodG8pLCBwYXJhbWV0ZXIpO1xuICAgICAgfSxcbiAgICAgIGN1YmljQ3VydmVCeTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3MpLFxuICAgICAgICAgICAgaGFuZGxlMiA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJncyksXG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXG4gICAgICAgIHRoaXMuY3ViaWNDdXJ2ZVRvKGN1cnJlbnQuYWRkKGhhbmRsZTEpLCBjdXJyZW50LmFkZChoYW5kbGUyKSwgY3VycmVudC5hZGQodG8pKTtcbiAgICAgIH0sXG4gICAgICBxdWFkcmF0aWNDdXJ2ZUJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaGFuZGxlID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIHRvID0gUG9pbnQucmVhZChhcmdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cbiAgICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnJlbnQuYWRkKGhhbmRsZSksIGN1cnJlbnQuYWRkKHRvKSk7XG4gICAgICB9LFxuICAgICAgYXJjQnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50LFxuICAgICAgICAgICAgcG9pbnQgPSBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3MpKSxcbiAgICAgICAgICAgIGNsb2Nrd2lzZSA9IEJhc2UucGljayhCYXNlLnBlZWsoYXJncyksIHRydWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2xvY2t3aXNlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aGlzLmFyY1RvKHBvaW50LCBjbG9ja3dpc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXJjVG8ocG9pbnQsIGN1cnJlbnQuYWRkKFBvaW50LnJlYWQoYXJncykpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNsb3NlUGF0aDogZnVuY3Rpb24gKHRvbGVyYW5jZSkge1xuICAgICAgICB0aGlzLnNldENsb3NlZCh0cnVlKTtcbiAgICAgICAgdGhpcy5qb2luKHRoaXMsIHRvbGVyYW5jZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpLCB7XG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24gKG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMuaGFuZGxlID8gJ2dldEhhbmRsZUJvdW5kcycgOiBvcHRpb25zLnN0cm9rZSA/ICdnZXRTdHJva2VCb3VuZHMnIDogJ2dldEJvdW5kcyc7XG4gICAgICByZXR1cm4gUGF0aFttZXRob2RdKHRoaXMuX3NlZ21lbnRzLCB0aGlzLl9jbG9zZWQsIHRoaXMsIG1hdHJpeCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uIChzZWdtZW50cywgY2xvc2VkLCBwYXRoLCBtYXRyaXgsIG9wdGlvbnMsIHN0cm9rZVBhZGRpbmcpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gc2VnbWVudHNbMF07XG4gICAgICAgIGlmICghZmlyc3QpIHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcbiAgICAgICAgICAgIHByZXZDb29yZHMgPSBmaXJzdC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBuZXcgQXJyYXkoNikpLFxuICAgICAgICAgICAgbWluID0gcHJldkNvb3Jkcy5zbGljZSgwLCAyKSxcbiAgICAgICAgICAgIG1heCA9IG1pbi5zbGljZSgpLFxuICAgICAgICAgICAgcm9vdHMgPSBuZXcgQXJyYXkoMik7XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnQoc2VnbWVudCkge1xuICAgICAgICAgIHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICBDdXJ2ZS5fYWRkQm91bmRzKHByZXZDb29yZHNbaV0sIHByZXZDb29yZHNbaSArIDRdLCBjb29yZHNbaSArIDJdLCBjb29yZHNbaV0sIGksIHN0cm9rZVBhZGRpbmcgPyBzdHJva2VQYWRkaW5nW2ldIDogMCwgbWluLCBtYXgsIHJvb3RzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdG1wID0gcHJldkNvb3JkcztcbiAgICAgICAgICBwcmV2Q29vcmRzID0gY29vcmRzO1xuICAgICAgICAgIGNvb3JkcyA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSBwcm9jZXNzU2VnbWVudChzZWdtZW50c1tpXSk7XG5cbiAgICAgICAgaWYgKGNsb3NlZCkgcHJvY2Vzc1NlZ21lbnQoZmlyc3QpO1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuICAgICAgfSxcbiAgICAgIGdldFN0cm9rZUJvdW5kczogZnVuY3Rpb24gKHNlZ21lbnRzLCBjbG9zZWQsIHBhdGgsIG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgc3R5bGUgPSBwYXRoLmdldFN0eWxlKCksXG4gICAgICAgICAgICBzdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSxcbiAgICAgICAgICAgIHN0cm9rZU1hdHJpeCA9IHN0cm9rZSAmJiBwYXRoLl9nZXRTdHJva2VNYXRyaXgobWF0cml4LCBvcHRpb25zKSxcbiAgICAgICAgICAgIHN0cm9rZVBhZGRpbmcgPSBzdHJva2UgJiYgUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VXaWR0aCwgc3Ryb2tlTWF0cml4KSxcbiAgICAgICAgICAgIGJvdW5kcyA9IFBhdGguZ2V0Qm91bmRzKHNlZ21lbnRzLCBjbG9zZWQsIHBhdGgsIG1hdHJpeCwgb3B0aW9ucywgc3Ryb2tlUGFkZGluZyk7XG5cbiAgICAgICAgaWYgKCFzdHJva2UpIHJldHVybiBib3VuZHM7XG4gICAgICAgIHZhciBzdHJva2VSYWRpdXMgPSBzdHJva2VXaWR0aCAvIDIsXG4gICAgICAgICAgICBqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuICAgICAgICAgICAgY2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG4gICAgICAgICAgICBtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpLFxuICAgICAgICAgICAgam9pbkJvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFNpemUoc3Ryb2tlUGFkZGluZykpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFBvaW50KHBvaW50KSB7XG4gICAgICAgICAgYm91bmRzID0gYm91bmRzLmluY2x1ZGUocG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkUm91bmQoc2VnbWVudCkge1xuICAgICAgICAgIGJvdW5kcyA9IGJvdW5kcy51bml0ZShqb2luQm91bmRzLnNldENlbnRlcihzZWdtZW50Ll9wb2ludC50cmFuc2Zvcm0obWF0cml4KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkSm9pbihzZWdtZW50LCBqb2luKSB7XG4gICAgICAgICAgaWYgKGpvaW4gPT09ICdyb3VuZCcgfHwgc2VnbWVudC5pc1Ntb290aCgpKSB7XG4gICAgICAgICAgICBhZGRSb3VuZChzZWdtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHN0cm9rZVJhZGl1cywgbWl0ZXJMaW1pdCwgbWF0cml4LCBzdHJva2VNYXRyaXgsIGFkZFBvaW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDYXAoc2VnbWVudCwgY2FwKSB7XG4gICAgICAgICAgaWYgKGNhcCA9PT0gJ3JvdW5kJykge1xuICAgICAgICAgICAgYWRkUm91bmQoc2VnbWVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFBhdGguX2FkZFNxdWFyZUNhcChzZWdtZW50LCBjYXAsIHN0cm9rZVJhZGl1cywgbWF0cml4LCBzdHJva2VNYXRyaXgsIGFkZFBvaW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoIC0gKGNsb3NlZCA/IDAgOiAxKTtcblxuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFkZEpvaW4oc2VnbWVudHNbaV0sIGpvaW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICAgIGFkZEpvaW4oc2VnbWVudHNbMF0sIGpvaW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRDYXAoc2VnbWVudHNbMF0sIGNhcCk7XG4gICAgICAgICAgICBhZGRDYXAoc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0sIGNhcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH0sXG4gICAgICBfZ2V0U3Ryb2tlUGFkZGluZzogZnVuY3Rpb24gKHJhZGl1cywgbWF0cml4KSB7XG4gICAgICAgIGlmICghbWF0cml4KSByZXR1cm4gW3JhZGl1cywgcmFkaXVzXTtcbiAgICAgICAgdmFyIGhvciA9IG5ldyBQb2ludChyYWRpdXMsIDApLnRyYW5zZm9ybShtYXRyaXgpLFxuICAgICAgICAgICAgdmVyID0gbmV3IFBvaW50KDAsIHJhZGl1cykudHJhbnNmb3JtKG1hdHJpeCksXG4gICAgICAgICAgICBwaGkgPSBob3IuZ2V0QW5nbGVJblJhZGlhbnMoKSxcbiAgICAgICAgICAgIGEgPSBob3IuZ2V0TGVuZ3RoKCksXG4gICAgICAgICAgICBiID0gdmVyLmdldExlbmd0aCgpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4ocGhpKSxcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKHBoaSksXG4gICAgICAgICAgICB0YW4gPSBNYXRoLnRhbihwaGkpLFxuICAgICAgICAgICAgdHggPSBNYXRoLmF0YW4yKGIgKiB0YW4sIGEpLFxuICAgICAgICAgICAgdHkgPSBNYXRoLmF0YW4yKGIsIHRhbiAqIGEpO1xuICAgICAgICByZXR1cm4gW01hdGguYWJzKGEgKiBNYXRoLmNvcyh0eCkgKiBjb3MgKyBiICogTWF0aC5zaW4odHgpICogc2luKSwgTWF0aC5hYnMoYiAqIE1hdGguc2luKHR5KSAqIGNvcyArIGEgKiBNYXRoLmNvcyh0eSkgKiBzaW4pXTtcbiAgICAgIH0sXG4gICAgICBfYWRkQmV2ZWxKb2luOiBmdW5jdGlvbiAoc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBtYXRyaXgsIHN0cm9rZU1hdHJpeCwgYWRkUG9pbnQsIGlzQXJlYSkge1xuICAgICAgICB2YXIgY3VydmUyID0gc2VnbWVudC5nZXRDdXJ2ZSgpLFxuICAgICAgICAgICAgY3VydmUxID0gY3VydmUyLmdldFByZXZpb3VzKCksXG4gICAgICAgICAgICBwb2ludCA9IGN1cnZlMi5nZXRQb2ludDEoKS50cmFuc2Zvcm0obWF0cml4KSxcbiAgICAgICAgICAgIG5vcm1hbDEgPSBjdXJ2ZTEuZ2V0Tm9ybWFsQXRUaW1lKDEpLm11bHRpcGx5KHJhZGl1cykudHJhbnNmb3JtKHN0cm9rZU1hdHJpeCksXG4gICAgICAgICAgICBub3JtYWwyID0gY3VydmUyLmdldE5vcm1hbEF0VGltZSgwKS5tdWx0aXBseShyYWRpdXMpLnRyYW5zZm9ybShzdHJva2VNYXRyaXgpLFxuICAgICAgICAgICAgYW5nbGUgPSBub3JtYWwxLmdldERpcmVjdGVkQW5nbGUobm9ybWFsMik7XG5cbiAgICAgICAgaWYgKGFuZ2xlIDwgMCB8fCBhbmdsZSA+PSAxODApIHtcbiAgICAgICAgICBub3JtYWwxID0gbm9ybWFsMS5uZWdhdGUoKTtcbiAgICAgICAgICBub3JtYWwyID0gbm9ybWFsMi5uZWdhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FyZWEpIGFkZFBvaW50KHBvaW50KTtcbiAgICAgICAgYWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblxuICAgICAgICBpZiAoam9pbiA9PT0gJ21pdGVyJykge1xuICAgICAgICAgIHZhciBjb3JuZXIgPSBuZXcgTGluZShwb2ludC5hZGQobm9ybWFsMSksIG5ldyBQb2ludCgtbm9ybWFsMS55LCBub3JtYWwxLngpLCB0cnVlKS5pbnRlcnNlY3QobmV3IExpbmUocG9pbnQuYWRkKG5vcm1hbDIpLCBuZXcgUG9pbnQoLW5vcm1hbDIueSwgbm9ybWFsMi54KSwgdHJ1ZSksIHRydWUpO1xuXG4gICAgICAgICAgaWYgKGNvcm5lciAmJiBwb2ludC5nZXREaXN0YW5jZShjb3JuZXIpIDw9IG1pdGVyTGltaXQgKiByYWRpdXMpIHtcbiAgICAgICAgICAgIGFkZFBvaW50KGNvcm5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDIpKTtcbiAgICAgIH0sXG4gICAgICBfYWRkU3F1YXJlQ2FwOiBmdW5jdGlvbiAoc2VnbWVudCwgY2FwLCByYWRpdXMsIG1hdHJpeCwgc3Ryb2tlTWF0cml4LCBhZGRQb2ludCwgaXNBcmVhKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50LnRyYW5zZm9ybShtYXRyaXgpLFxuICAgICAgICAgICAgbG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpLFxuICAgICAgICAgICAgbm9ybWFsID0gbG9jLmdldE5vcm1hbCgpLm11bHRpcGx5KGxvYy5nZXRUaW1lKCkgPT09IDAgPyByYWRpdXMgOiAtcmFkaXVzKS50cmFuc2Zvcm0oc3Ryb2tlTWF0cml4KTtcblxuICAgICAgICBpZiAoY2FwID09PSAnc3F1YXJlJykge1xuICAgICAgICAgIGlmIChpc0FyZWEpIHtcbiAgICAgICAgICAgIGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuICAgICAgICAgICAgYWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvaW50ID0gcG9pbnQuYWRkKG5vcm1hbC5yb3RhdGUoLTkwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG4gICAgICAgIGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuICAgICAgfSxcbiAgICAgIGdldEhhbmRsZUJvdW5kczogZnVuY3Rpb24gKHNlZ21lbnRzLCBjbG9zZWQsIHBhdGgsIG1hdHJpeCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgc3R5bGUgPSBwYXRoLmdldFN0eWxlKCksXG4gICAgICAgICAgICBzdHJva2UgPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSxcbiAgICAgICAgICAgIHN0cm9rZVBhZGRpbmcsXG4gICAgICAgICAgICBqb2luUGFkZGluZztcblxuICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgdmFyIHN0cm9rZU1hdHJpeCA9IHBhdGguX2dldFN0cm9rZU1hdHJpeChtYXRyaXgsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICBzdHJva2VSYWRpdXMgPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMixcbiAgICAgICAgICAgICAgam9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cztcblxuICAgICAgICAgIGlmIChzdHlsZS5nZXRTdHJva2VKb2luKCkgPT09ICdtaXRlcicpIGpvaW5SYWRpdXMgPSBzdHJva2VSYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgICAgaWYgKHN0eWxlLmdldFN0cm9rZUNhcCgpID09PSAnc3F1YXJlJykgam9pblJhZGl1cyA9IE1hdGgubWF4KGpvaW5SYWRpdXMsIHN0cm9rZVJhZGl1cyAqIE1hdGguU1FSVDIpO1xuICAgICAgICAgIHN0cm9rZVBhZGRpbmcgPSBQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVJhZGl1cywgc3Ryb2tlTWF0cml4KTtcbiAgICAgICAgICBqb2luUGFkZGluZyA9IFBhdGguX2dldFN0cm9rZVBhZGRpbmcoam9pblJhZGl1cywgc3Ryb2tlTWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG4gICAgICAgICAgICB4MSA9IEluZmluaXR5LFxuICAgICAgICAgICAgeDIgPSAteDEsXG4gICAgICAgICAgICB5MSA9IHgxLFxuICAgICAgICAgICAgeTIgPSB4MjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cbiAgICAgICAgICBzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3Jkcyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDY7IGogKz0gMikge1xuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSAhaiA/IGpvaW5QYWRkaW5nIDogc3Ryb2tlUGFkZGluZyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nWCA9IHBhZGRpbmcgPyBwYWRkaW5nWzBdIDogMCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nWSA9IHBhZGRpbmcgPyBwYWRkaW5nWzFdIDogMCxcbiAgICAgICAgICAgICAgICB4ID0gY29vcmRzW2pdLFxuICAgICAgICAgICAgICAgIHkgPSBjb29yZHNbaiArIDFdLFxuICAgICAgICAgICAgICAgIHhuID0geCAtIHBhZGRpbmdYLFxuICAgICAgICAgICAgICAgIHh4ID0geCArIHBhZGRpbmdYLFxuICAgICAgICAgICAgICAgIHluID0geSAtIHBhZGRpbmdZLFxuICAgICAgICAgICAgICAgIHl4ID0geSArIHBhZGRpbmdZO1xuICAgICAgICAgICAgaWYgKHhuIDwgeDEpIHgxID0geG47XG4gICAgICAgICAgICBpZiAoeHggPiB4MikgeDIgPSB4eDtcbiAgICAgICAgICAgIGlmICh5biA8IHkxKSB5MSA9IHluO1xuICAgICAgICAgICAgaWYgKHl4ID4geTIpIHkyID0geXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBQYXRoLmluamVjdCh7XG4gICAgc3RhdGljczogbmV3IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNixcbiAgICAgICAgICBlbGxpcHNlU2VnbWVudHMgPSBbbmV3IFNlZ21lbnQoWy0xLCAwXSwgWzAsIGthcHBhXSwgWzAsIC1rYXBwYV0pLCBuZXcgU2VnbWVudChbMCwgLTFdLCBbLWthcHBhLCAwXSwgW2thcHBhLCAwXSksIG5ldyBTZWdtZW50KFsxLCAwXSwgWzAsIC1rYXBwYV0sIFswLCBrYXBwYV0pLCBuZXcgU2VnbWVudChbMCwgMV0sIFtrYXBwYSwgMF0sIFsta2FwcGEsIDBdKV07XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGgoc2VnbWVudHMsIGNsb3NlZCwgYXJncykge1xuICAgICAgICB2YXIgcHJvcHMgPSBCYXNlLmdldE5hbWVkKGFyZ3MpLFxuICAgICAgICAgICAgcGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PSBmYWxzZSAmJiBJdGVtLk5PX0lOU0VSVCk7XG5cbiAgICAgICAgcGF0aC5fYWRkKHNlZ21lbnRzKTtcblxuICAgICAgICBwYXRoLl9jbG9zZWQgPSBjbG9zZWQ7XG4gICAgICAgIHJldHVybiBwYXRoLnNldChwcm9wcywge1xuICAgICAgICAgIGluc2VydDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlRWxsaXBzZShjZW50ZXIsIHJhZGl1cywgYXJncykge1xuICAgICAgICB2YXIgc2VnbWVudHMgPSBuZXcgQXJyYXkoNCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IGVsbGlwc2VTZWdtZW50c1tpXTtcbiAgICAgICAgICBzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KHNlZ21lbnQuX3BvaW50Lm11bHRpcGx5KHJhZGl1cykuYWRkKGNlbnRlciksIHNlZ21lbnQuX2hhbmRsZUluLm11bHRpcGx5KHJhZGl1cyksIHNlZ21lbnQuX2hhbmRsZU91dC5tdWx0aXBseShyYWRpdXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgTGluZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVQYXRoKFtuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJncywgJ2Zyb20nKSksIG5ldyBTZWdtZW50KFBvaW50LnJlYWROYW1lZChhcmdzLCAndG8nKSldLCBmYWxzZSwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIENpcmNsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpLFxuICAgICAgICAgICAgICByYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMpLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgUmVjdGFuZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3MsICdyZWN0YW5nbGUnKSxcbiAgICAgICAgICAgICAgcmFkaXVzID0gU2l6ZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycsIDAsIHtcbiAgICAgICAgICAgIHJlYWROdWxsOiB0cnVlXG4gICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGJsID0gcmVjdC5nZXRCb3R0b21MZWZ0KHRydWUpLFxuICAgICAgICAgICAgICB0bCA9IHJlY3QuZ2V0VG9wTGVmdCh0cnVlKSxcbiAgICAgICAgICAgICAgdHIgPSByZWN0LmdldFRvcFJpZ2h0KHRydWUpLFxuICAgICAgICAgICAgICBiciA9IHJlY3QuZ2V0Qm90dG9tUmlnaHQodHJ1ZSksXG4gICAgICAgICAgICAgIHNlZ21lbnRzO1xuXG4gICAgICAgICAgaWYgKCFyYWRpdXMgfHwgcmFkaXVzLmlzWmVybygpKSB7XG4gICAgICAgICAgICBzZWdtZW50cyA9IFtuZXcgU2VnbWVudChibCksIG5ldyBTZWdtZW50KHRsKSwgbmV3IFNlZ21lbnQodHIpLCBuZXcgU2VnbWVudChicildO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYWRpdXMgPSBTaXplLm1pbihyYWRpdXMsIHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuICAgICAgICAgICAgdmFyIHJ4ID0gcmFkaXVzLndpZHRoLFxuICAgICAgICAgICAgICAgIHJ5ID0gcmFkaXVzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBoeCA9IHJ4ICoga2FwcGEsXG4gICAgICAgICAgICAgICAgaHkgPSByeSAqIGthcHBhO1xuICAgICAgICAgICAgc2VnbWVudHMgPSBbbmV3IFNlZ21lbnQoYmwuYWRkKHJ4LCAwKSwgbnVsbCwgWy1oeCwgMF0pLCBuZXcgU2VnbWVudChibC5zdWJ0cmFjdCgwLCByeSksIFswLCBoeV0pLCBuZXcgU2VnbWVudCh0bC5hZGQoMCwgcnkpLCBudWxsLCBbMCwgLWh5XSksIG5ldyBTZWdtZW50KHRsLmFkZChyeCwgMCksIFstaHgsIDBdLCBudWxsKSwgbmV3IFNlZ21lbnQodHIuc3VidHJhY3QocngsIDApLCBudWxsLCBbaHgsIDBdKSwgbmV3IFNlZ21lbnQodHIuYWRkKDAsIHJ5KSwgWzAsIC1oeV0sIG51bGwpLCBuZXcgU2VnbWVudChici5zdWJ0cmFjdCgwLCByeSksIG51bGwsIFswLCBoeV0pLCBuZXcgU2VnbWVudChici5zdWJ0cmFjdChyeCwgMCksIFtoeCwgMF0pXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJvdW5kUmVjdGFuZ2xlOiAnI1JlY3RhbmdsZScsXG4gICAgICAgIEVsbGlwc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmdzKTtcblxuICAgICAgICAgIHJldHVybiBjcmVhdGVFbGxpcHNlKGVsbGlwc2UuY2VudGVyLCBlbGxpcHNlLnJhZGl1cywgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIE92YWw6ICcjRWxsaXBzZScsXG4gICAgICAgIEFyYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBmcm9tID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdmcm9tJyksXG4gICAgICAgICAgICAgIHRocm91Z2ggPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ3Rocm91Z2gnKSxcbiAgICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ3RvJyksXG4gICAgICAgICAgICAgIHByb3BzID0gQmFzZS5nZXROYW1lZChhcmdzKSxcbiAgICAgICAgICAgICAgcGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PSBmYWxzZSAmJiBJdGVtLk5PX0lOU0VSVCk7XG4gICAgICAgICAgcGF0aC5tb3ZlVG8oZnJvbSk7XG4gICAgICAgICAgcGF0aC5hcmNUbyh0aHJvdWdoLCB0byk7XG4gICAgICAgICAgcmV0dXJuIHBhdGguc2V0KHByb3BzKTtcbiAgICAgICAgfSxcbiAgICAgICAgUmVndWxhclBvbHlnb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdjZW50ZXInKSxcbiAgICAgICAgICAgICAgc2lkZXMgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAnc2lkZXMnKSxcbiAgICAgICAgICAgICAgcmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycpLFxuICAgICAgICAgICAgICBzdGVwID0gMzYwIC8gc2lkZXMsXG4gICAgICAgICAgICAgIHRocmVlID0gc2lkZXMgJSAzID09PSAwLFxuICAgICAgICAgICAgICB2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgdGhyZWUgPyAtcmFkaXVzIDogcmFkaXVzKSxcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhyZWUgPyAtMSA6IDAuNSxcbiAgICAgICAgICAgICAgc2VnbWVudHMgPSBuZXcgQXJyYXkoc2lkZXMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSBzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQodmVjdG9yLnJvdGF0ZSgoaSArIG9mZnNldCkgKiBzdGVwKSkpO1xuXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBTdGFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyksXG4gICAgICAgICAgICAgIHBvaW50cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdwb2ludHMnKSAqIDIsXG4gICAgICAgICAgICAgIHJhZGl1czEgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncmFkaXVzMScpLFxuICAgICAgICAgICAgICByYWRpdXMyID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1czInKSxcbiAgICAgICAgICAgICAgc3RlcCA9IDM2MCAvIHBvaW50cyxcbiAgICAgICAgICAgICAgdmVjdG9yID0gbmV3IFBvaW50KDAsIC0xKSxcbiAgICAgICAgICAgICAgc2VnbWVudHMgPSBuZXcgQXJyYXkocG9pbnRzKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzOyBpKyspIHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZCh2ZWN0b3Iucm90YXRlKHN0ZXAgKiBpKS5tdWx0aXBseShpICUgMiA/IHJhZGl1czIgOiByYWRpdXMxKSkpO1xuXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKVxuICB9KTtcbiAgdmFyIENvbXBvdW5kUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnQ29tcG91bmRQYXRoJyxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9LFxuICAgIGJlYW5zOiB0cnVlLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbXBvdW5kUGF0aChhcmcpIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICB0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cbiAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGluc2VydENoaWxkcmVuOiBmdW5jdGlvbiBpbnNlcnRDaGlsZHJlbihpbmRleCwgaXRlbXMpIHtcbiAgICAgIHZhciBsaXN0ID0gaXRlbXMsXG4gICAgICAgICAgZmlyc3QgPSBsaXN0WzBdO1xuICAgICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdFswXSA9PT0gJ251bWJlcicpIGxpc3QgPSBbbGlzdF07XG5cbiAgICAgIGZvciAodmFyIGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChsaXN0ID09PSBpdGVtcyAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBQYXRoKSkgbGlzdCA9IEJhc2Uuc2xpY2UobGlzdCk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICBsaXN0W2ldID0gbmV3IFBhdGgoe1xuICAgICAgICAgICAgc2VnbWVudHM6IGl0ZW0sXG4gICAgICAgICAgICBpbnNlcnQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkge1xuICAgICAgICAgIGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIFtpLCAxXS5jb25jYXQoaXRlbS5yZW1vdmVDaGlsZHJlbigpKSk7XG4gICAgICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zZXJ0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIGluZGV4LCBsaXN0KTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHBhdGggPSBjaGlsZHJlbltpXS5yZWR1Y2Uob3B0aW9ucyk7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkgcGF0aC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG4gICAgICAgIHBhdGguY29weUF0dHJpYnV0ZXModGhpcyk7XG4gICAgICAgIHBhdGguaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVkdWNlLmJhc2UuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIGlzQ2xvc2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKCFjaGlsZHJlbltpXS5fY2xvc2VkKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgc2V0Q2xvc2VkOiBmdW5jdGlvbiAoY2xvc2VkKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2hpbGRyZW5baV0uc2V0Q2xvc2VkKGNsb3NlZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRGaXJzdFNlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0U2VnbWVudCgpO1xuICAgIH0sXG4gICAgZ2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgIHJldHVybiBsYXN0ICYmIGxhc3QuZ2V0TGFzdFNlZ21lbnQoKTtcbiAgICB9LFxuICAgIGdldEN1cnZlczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgY3VydmVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIEJhc2UucHVzaChjdXJ2ZXMsIGNoaWxkcmVuW2ldLmdldEN1cnZlcygpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnZlcztcbiAgICB9LFxuICAgIGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0Q3VydmUoKTtcbiAgICB9LFxuICAgIGdldExhc3RDdXJ2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhc3QgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuICAgICAgcmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0Q3VydmUoKTtcbiAgICB9LFxuICAgIGdldEFyZWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgIGFyZWEgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgYXJlYSArPSBjaGlsZHJlbltpXS5nZXRBcmVhKCk7XG5cbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH0sXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgbGVuZ3RoICs9IGNoaWxkcmVuW2ldLmdldExlbmd0aCgpO1xuXG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH0sXG4gICAgZ2V0UGF0aERhdGE6IGZ1bmN0aW9uIChfbWF0cml4LCBfcHJlY2lzaW9uKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICBwYXRocyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcbiAgICAgICAgICAgIG14ID0gY2hpbGQuX21hdHJpeDtcbiAgICAgICAgcGF0aHMucHVzaChjaGlsZC5nZXRQYXRoRGF0YShfbWF0cml4ICYmICFteC5pc0lkZW50aXR5KCkgPyBfbWF0cml4LmFwcGVuZGVkKG14KSA6IF9tYXRyaXgsIF9wcmVjaXNpb24pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhzLmpvaW4oJycpO1xuICAgIH0sXG4gICAgX2hpdFRlc3RDaGlsZHJlbjogZnVuY3Rpb24gX2hpdFRlc3RDaGlsZHJlbihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCkge1xuICAgICAgcmV0dXJuIF9oaXRUZXN0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIHBvaW50LCBvcHRpb25zLmNsYXNzID09PSBQYXRoIHx8IG9wdGlvbnMudHlwZSA9PT0gJ3BhdGgnID8gb3B0aW9ucyA6IEJhc2Uuc2V0KHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGZpbGw6IGZhbHNlXG4gICAgICB9KSwgdmlld01hdHJpeCk7XG4gICAgfSxcbiAgICBfZHJhdzogZnVuY3Rpb24gKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgcGFyYW0gPSBwYXJhbS5leHRlbmQoe1xuICAgICAgICBkb250U3RhcnQ6IHRydWUsXG4gICAgICAgIGRvbnRGaW5pc2g6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgY2hpbGRyZW5baV0uZHJhdyhjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpO1xuXG4gICAgICBpZiAoIXBhcmFtLmNsaXApIHtcbiAgICAgICAgdGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuXG4gICAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICBjdHguZmlsbChzdHlsZS5nZXRGaWxsUnVsZSgpKTtcbiAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uIChjdHgsIG1hdHJpeCwgc2VsZWN0aW9uSXRlbXMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcbiAgICAgICAgICAgIG14ID0gY2hpbGQuX21hdHJpeDtcblxuICAgICAgICBpZiAoIXNlbGVjdGlvbkl0ZW1zW2NoaWxkLl9pZF0pIHtcbiAgICAgICAgICBjaGlsZC5fZHJhd1NlbGVjdGVkKGN0eCwgbXguaXNJZGVudGl0eSgpID8gbWF0cml4IDogbWF0cml4LmFwcGVuZGVkKG14KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFBhdGgodGhhdCwgY2hlY2spIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoYXQuX2NoaWxkcmVuO1xuICAgICAgaWYgKGNoZWNrICYmICFjaGlsZHJlbi5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBCYXNlLmVhY2goWydsaW5lVG8nLCAnY3ViaWNDdXJ2ZVRvJywgJ3F1YWRyYXRpY0N1cnZlVG8nLCAnY3VydmVUbycsICdhcmNUbycsICdsaW5lQnknLCAnY3ViaWNDdXJ2ZUJ5JywgJ3F1YWRyYXRpY0N1cnZlQnknLCAnY3VydmVCeScsICdhcmNCeSddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB0aGlzW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXRoID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSk7XG4gICAgICAgIHBhdGhba2V5XS5hcHBseShwYXRoLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9LCB7XG4gICAgICBtb3ZlVG86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzKSxcbiAgICAgICAgICAgIHBhdGggPSBjdXJyZW50ICYmIGN1cnJlbnQuaXNFbXB0eSgpID8gY3VycmVudCA6IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcbiAgICAgICAgaWYgKHBhdGggIT09IGN1cnJlbnQpIHRoaXMuYWRkQ2hpbGQocGF0aCk7XG4gICAgICAgIHBhdGgubW92ZVRvLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgbW92ZUJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSksXG4gICAgICAgICAgICBsYXN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldExhc3RTZWdtZW50KCksXG4gICAgICAgICAgICBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tb3ZlVG8obGFzdCA/IHBvaW50LmFkZChsYXN0Ll9wb2ludCkgOiBwb2ludCk7XG4gICAgICB9LFxuICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAodG9sZXJhbmNlKSB7XG4gICAgICAgIGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLmNsb3NlUGF0aCh0b2xlcmFuY2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KCksIEJhc2UuZWFjaChbJ3JldmVyc2UnLCAnZmxhdHRlbicsICdzaW1wbGlmeScsICdzbW9vdGgnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHRoaXNba2V5XSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG4gICAgICAgICAgcmVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXMgPSBjaGlsZHJlbltpXVtrZXldKHBhcmFtKSB8fCByZXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgfSwge30pKTtcbiAgUGF0aEl0ZW0uaW5qZWN0KG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluLFxuICAgICAgICBtYXggPSBNYXRoLm1heCxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgIG9wZXJhdG9ycyA9IHtcbiAgICAgIHVuaXRlOiB7XG4gICAgICAgICcxJzogdHJ1ZSxcbiAgICAgICAgJzInOiB0cnVlXG4gICAgICB9LFxuICAgICAgaW50ZXJzZWN0OiB7XG4gICAgICAgICcyJzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHN1YnRyYWN0OiB7XG4gICAgICAgICcxJzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGV4Y2x1ZGU6IHtcbiAgICAgICAgJzEnOiB0cnVlLFxuICAgICAgICAnLTEnOiB0cnVlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFBhdGhzKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLl9jaGlsZHJlbiB8fCBbcGF0aF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZVBhdGgocGF0aCwgcmVzb2x2ZSkge1xuICAgICAgdmFyIHJlcyA9IHBhdGguY2xvbmUoZmFsc2UpLnJlZHVjZSh7XG4gICAgICAgIHNpbXBsaWZ5OiB0cnVlXG4gICAgICB9KS50cmFuc2Zvcm0obnVsbCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciBwYXRocyA9IGdldFBhdGhzKHJlcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2ldO1xuXG4gICAgICAgICAgaWYgKCFwYXRoLl9jbG9zZWQgJiYgIXBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgxZS0xMik7XG4gICAgICAgICAgICBwYXRoLmdldEZpcnN0U2VnbWVudCgpLnNldEhhbmRsZUluKDAsIDApO1xuICAgICAgICAgICAgcGF0aC5nZXRMYXN0U2VnbWVudCgpLnNldEhhbmRsZU91dCgwLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXMgPSByZXMucmVzb2x2ZUNyb3NzaW5ncygpLnJlb3JpZW50KHJlcy5nZXRGaWxsUnVsZSgpID09PSAnbm9uemVybycsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3VsdChwYXRocywgc2ltcGxpZnksIHBhdGgxLCBwYXRoMiwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDb21wb3VuZFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuICAgICAgcmVzdWx0LmFkZENoaWxkcmVuKHBhdGhzLCB0cnVlKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZWR1Y2Uoe1xuICAgICAgICBzaW1wbGlmeTogc2ltcGxpZnlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuaW5zZXJ0ID09IGZhbHNlKSkge1xuICAgICAgICByZXN1bHQuaW5zZXJ0QWJvdmUocGF0aDIgJiYgcGF0aDEuaXNTaWJsaW5nKHBhdGgyKSAmJiBwYXRoMS5nZXRJbmRleCgpIDwgcGF0aDIuZ2V0SW5kZXgoKSA/IHBhdGgyIDogcGF0aDEpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQuY29weUF0dHJpYnV0ZXMocGF0aDEsIHRydWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJJbnRlcnNlY3Rpb24oaW50ZXIpIHtcbiAgICAgIHJldHVybiBpbnRlci5oYXNPdmVybGFwKCkgfHwgaW50ZXIuaXNDcm9zc2luZygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWNlQm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMudHJhY2UgPT0gZmFsc2UgfHwgb3B0aW9ucy5zdHJva2UpICYmIC9eKHN1YnRyYWN0fGludGVyc2VjdCkkLy50ZXN0KG9wZXJhdGlvbikpIHJldHVybiBzcGxpdEJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pO1xuXG4gICAgICB2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEsIHRydWUpLFxuICAgICAgICAgIF9wYXRoMiA9IHBhdGgyICYmIHBhdGgxICE9PSBwYXRoMiAmJiBwcmVwYXJlUGF0aChwYXRoMiwgdHJ1ZSksXG4gICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvcnNbb3BlcmF0aW9uXTtcblxuICAgICAgb3BlcmF0b3Jbb3BlcmF0aW9uXSA9IHRydWU7XG4gICAgICBpZiAoX3BhdGgyICYmIChvcGVyYXRvci5zdWJ0cmFjdCB8fCBvcGVyYXRvci5leGNsdWRlKSBeIChfcGF0aDIuaXNDbG9ja3dpc2UoKSBeIF9wYXRoMS5pc0Nsb2Nrd2lzZSgpKSkgX3BhdGgyLnJldmVyc2UoKTtcblxuICAgICAgdmFyIGNyb3NzaW5ncyA9IGRpdmlkZUxvY2F0aW9ucyhDdXJ2ZUxvY2F0aW9uLmV4cGFuZChfcGF0aDEuZ2V0SW50ZXJzZWN0aW9ucyhfcGF0aDIsIGZpbHRlckludGVyc2VjdGlvbikpKSxcbiAgICAgICAgICBwYXRoczEgPSBnZXRQYXRocyhfcGF0aDEpLFxuICAgICAgICAgIHBhdGhzMiA9IF9wYXRoMiAmJiBnZXRQYXRocyhfcGF0aDIpLFxuICAgICAgICAgIHNlZ21lbnRzID0gW10sXG4gICAgICAgICAgY3VydmVzID0gW10sXG4gICAgICAgICAgcGF0aHM7XG5cbiAgICAgIGZ1bmN0aW9uIGNvbGxlY3RQYXRocyhwYXRocykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBwYXRoID0gcGF0aHNbaV07XG4gICAgICAgICAgQmFzZS5wdXNoKHNlZ21lbnRzLCBwYXRoLl9zZWdtZW50cyk7XG4gICAgICAgICAgQmFzZS5wdXNoKGN1cnZlcywgcGF0aC5nZXRDdXJ2ZXMoKSk7XG4gICAgICAgICAgcGF0aC5fb3ZlcmxhcHNPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRDdXJ2ZXMoaW5kaWNlcykge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kaWNlcyAmJiBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGxpc3QucHVzaChjdXJ2ZXNbaW5kaWNlc1tpXV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChjcm9zc2luZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbGxlY3RQYXRocyhwYXRoczEpO1xuICAgICAgICBpZiAocGF0aHMyKSBjb2xsZWN0UGF0aHMocGF0aHMyKTtcbiAgICAgICAgdmFyIGN1cnZlc1ZhbHVlcyA9IG5ldyBBcnJheShjdXJ2ZXMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjdXJ2ZXNWYWx1ZXNbaV0gPSBjdXJ2ZXNbaV0uZ2V0VmFsdWVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VydmVDb2xsaXNpb25zID0gQ29sbGlzaW9uRGV0ZWN0aW9uLmZpbmRDdXJ2ZUJvdW5kc0NvbGxpc2lvbnMoY3VydmVzVmFsdWVzLCBjdXJ2ZXNWYWx1ZXMsIDAsIHRydWUpO1xuICAgICAgICB2YXIgY3VydmVDb2xsaXNpb25zTWFwID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VydmUgPSBjdXJ2ZXNbaV0sXG4gICAgICAgICAgICAgIGlkID0gY3VydmUuX3BhdGguX2lkLFxuICAgICAgICAgICAgICBtYXAgPSBjdXJ2ZUNvbGxpc2lvbnNNYXBbaWRdID0gY3VydmVDb2xsaXNpb25zTWFwW2lkXSB8fCB7fTtcbiAgICAgICAgICBtYXBbY3VydmUuZ2V0SW5kZXgoKV0gPSB7XG4gICAgICAgICAgICBob3I6IGdldEN1cnZlcyhjdXJ2ZUNvbGxpc2lvbnNbaV0uaG9yKSxcbiAgICAgICAgICAgIHZlcjogZ2V0Q3VydmVzKGN1cnZlQ29sbGlzaW9uc1tpXS52ZXIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3Jvc3NpbmdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHByb3BhZ2F0ZVdpbmRpbmcoY3Jvc3NpbmdzW2ldLl9zZWdtZW50LCBfcGF0aDEsIF9wYXRoMiwgY3VydmVDb2xsaXNpb25zTWFwLCBvcGVyYXRvcik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV0sXG4gICAgICAgICAgICAgIGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uO1xuXG4gICAgICAgICAgaWYgKCFzZWdtZW50Ll93aW5kaW5nKSB7XG4gICAgICAgICAgICBwcm9wYWdhdGVXaW5kaW5nKHNlZ21lbnQsIF9wYXRoMSwgX3BhdGgyLCBjdXJ2ZUNvbGxpc2lvbnNNYXAsIG9wZXJhdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIShpbnRlciAmJiBpbnRlci5fb3ZlcmxhcCkpIHNlZ21lbnQuX3BhdGguX292ZXJsYXBzT25seSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aHMgPSB0cmFjZVBhdGhzKHNlZ21lbnRzLCBvcGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRocyA9IHJlb3JpZW50UGF0aHMocGF0aHMyID8gcGF0aHMxLmNvbmNhdChwYXRoczIpIDogcGF0aHMxLnNsaWNlKCksIGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgcmV0dXJuICEhb3BlcmF0b3Jbd107XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlUmVzdWx0KHBhdGhzLCB0cnVlLCBwYXRoMSwgcGF0aDIsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNwbGl0Qm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdGlvbikge1xuICAgICAgdmFyIF9wYXRoMSA9IHByZXBhcmVQYXRoKHBhdGgxKSxcbiAgICAgICAgICBfcGF0aDIgPSBwcmVwYXJlUGF0aChwYXRoMiksXG4gICAgICAgICAgY3Jvc3NpbmdzID0gX3BhdGgxLmdldEludGVyc2VjdGlvbnMoX3BhdGgyLCBmaWx0ZXJJbnRlcnNlY3Rpb24pLFxuICAgICAgICAgIHN1YnRyYWN0ID0gb3BlcmF0aW9uID09PSAnc3VidHJhY3QnLFxuICAgICAgICAgIGRpdmlkZSA9IG9wZXJhdGlvbiA9PT0gJ2RpdmlkZScsXG4gICAgICAgICAgYWRkZWQgPSB7fSxcbiAgICAgICAgICBwYXRocyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBhZGRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKCFhZGRlZFtwYXRoLl9pZF0gJiYgKGRpdmlkZSB8fCBfcGF0aDIuY29udGFpbnMocGF0aC5nZXRQb2ludEF0KHBhdGguZ2V0TGVuZ3RoKCkgLyAyKSkgXiBzdWJ0cmFjdCkpIHtcbiAgICAgICAgICBwYXRocy51bnNoaWZ0KHBhdGgpO1xuICAgICAgICAgIHJldHVybiBhZGRlZFtwYXRoLl9pZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBjcm9zc2luZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHBhdGggPSBjcm9zc2luZ3NbaV0uc3BsaXQoKTtcblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIGlmIChhZGRQYXRoKHBhdGgpKSBwYXRoLmdldEZpcnN0U2VnbWVudCgpLnNldEhhbmRsZUluKDAsIDApO1xuXG4gICAgICAgICAgX3BhdGgxLmdldExhc3RTZWdtZW50KCkuc2V0SGFuZGxlT3V0KDAsIDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFkZFBhdGgoX3BhdGgxKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXN1bHQocGF0aHMsIGZhbHNlLCBwYXRoMSwgcGF0aDIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmtJbnRlcnNlY3Rpb25zKGZyb20sIHRvKSB7XG4gICAgICB2YXIgcHJldiA9IGZyb207XG5cbiAgICAgIHdoaWxlIChwcmV2KSB7XG4gICAgICAgIGlmIChwcmV2ID09PSB0bykgcmV0dXJuO1xuICAgICAgICBwcmV2ID0gcHJldi5fcHJldmlvdXM7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChmcm9tLl9uZXh0ICYmIGZyb20uX25leHQgIT09IHRvKSBmcm9tID0gZnJvbS5fbmV4dDtcblxuICAgICAgaWYgKCFmcm9tLl9uZXh0KSB7XG4gICAgICAgIHdoaWxlICh0by5fcHJldmlvdXMpIHRvID0gdG8uX3ByZXZpb3VzO1xuXG4gICAgICAgIGZyb20uX25leHQgPSB0bztcbiAgICAgICAgdG8uX3ByZXZpb3VzID0gZnJvbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckN1cnZlSGFuZGxlcyhjdXJ2ZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSBjdXJ2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGN1cnZlc1tpXS5jbGVhckhhbmRsZXMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW9yaWVudFBhdGhzKHBhdGhzLCBpc0luc2lkZSwgY2xvY2t3aXNlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMgJiYgcGF0aHMubGVuZ3RoO1xuXG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBCYXNlLmVhY2gocGF0aHMsIGZ1bmN0aW9uIChwYXRoLCBpKSB7XG4gICAgICAgICAgdGhpc1twYXRoLl9pZF0gPSB7XG4gICAgICAgICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICAgICAgICB3aW5kaW5nOiBwYXRoLmlzQ2xvY2t3aXNlKCkgPyAxIDogLTEsXG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9KSxcbiAgICAgICAgICAgIHNvcnRlZCA9IHBhdGhzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhYnMoYi5nZXRBcmVhKCkpIC0gYWJzKGEuZ2V0QXJlYSgpKTtcbiAgICAgICAgfSksXG4gICAgICAgICAgICBmaXJzdCA9IHNvcnRlZFswXTtcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBDb2xsaXNpb25EZXRlY3Rpb24uZmluZEl0ZW1Cb3VuZHNDb2xsaXNpb25zKHNvcnRlZCwgbnVsbCwgTnVtZXJpY2FsLkdFT01FVFJJQ19FUFNJTE9OKTtcbiAgICAgICAgaWYgKGNsb2Nrd2lzZSA9PSBudWxsKSBjbG9ja3dpc2UgPSBmaXJzdC5pc0Nsb2Nrd2lzZSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGF0aDEgPSBzb3J0ZWRbaV0sXG4gICAgICAgICAgICAgIGVudHJ5MSA9IGxvb2t1cFtwYXRoMS5faWRdLFxuICAgICAgICAgICAgICBjb250YWluZXJXaW5kaW5nID0gMCxcbiAgICAgICAgICAgICAgaW5kaWNlcyA9IGNvbGxpc2lvbnNbaV07XG5cbiAgICAgICAgICBpZiAoaW5kaWNlcykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gbnVsbDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGluZGljZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgaWYgKGluZGljZXNbal0gPCBpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludCB8fCBwYXRoMS5nZXRJbnRlcmlvclBvaW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGgyID0gc29ydGVkW2luZGljZXNbal1dO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhdGgyLmNvbnRhaW5zKHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5MiA9IGxvb2t1cFtwYXRoMi5faWRdO1xuICAgICAgICAgICAgICAgICAgY29udGFpbmVyV2luZGluZyA9IGVudHJ5Mi53aW5kaW5nO1xuICAgICAgICAgICAgICAgICAgZW50cnkxLndpbmRpbmcgKz0gY29udGFpbmVyV2luZGluZztcbiAgICAgICAgICAgICAgICAgIGVudHJ5MS5jb250YWluZXIgPSBlbnRyeTIuZXhjbHVkZSA/IGVudHJ5Mi5jb250YWluZXIgOiBwYXRoMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0luc2lkZShlbnRyeTEud2luZGluZykgPT09IGlzSW5zaWRlKGNvbnRhaW5lcldpbmRpbmcpKSB7XG4gICAgICAgICAgICBlbnRyeTEuZXhjbHVkZSA9IHRydWU7XG4gICAgICAgICAgICBwYXRoc1tlbnRyeTEuaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGVudHJ5MS5jb250YWluZXI7XG4gICAgICAgICAgICBwYXRoMS5zZXRDbG9ja3dpc2UoY29udGFpbmVyID8gIWNvbnRhaW5lci5pc0Nsb2Nrd2lzZSgpIDogY2xvY2t3aXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpdmlkZUxvY2F0aW9ucyhsb2NhdGlvbnMsIGluY2x1ZGUsIGNsZWFyTGF0ZXIpIHtcbiAgICAgIHZhciByZXN1bHRzID0gaW5jbHVkZSAmJiBbXSxcbiAgICAgICAgICB0TWluID0gMWUtOCxcbiAgICAgICAgICB0TWF4ID0gMSAtIHRNaW4sXG4gICAgICAgICAgY2xlYXJIYW5kbGVzID0gZmFsc2UsXG4gICAgICAgICAgY2xlYXJDdXJ2ZXMgPSBjbGVhckxhdGVyIHx8IFtdLFxuICAgICAgICAgIGNsZWFyTG9va3VwID0gY2xlYXJMYXRlciAmJiB7fSxcbiAgICAgICAgICByZW5vcm1hbGl6ZUxvY3MsXG4gICAgICAgICAgcHJldkN1cnZlLFxuICAgICAgICAgIHByZXZUaW1lO1xuXG4gICAgICBmdW5jdGlvbiBnZXRJZChjdXJ2ZSkge1xuICAgICAgICByZXR1cm4gY3VydmUuX3BhdGguX2lkICsgJy4nICsgY3VydmUuX3NlZ21lbnQxLl9pbmRleDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IChjbGVhckxhdGVyICYmIGNsZWFyTGF0ZXIubGVuZ3RoKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IGNsZWFyTGF0ZXJbaV07XG4gICAgICAgIGlmIChjdXJ2ZS5fcGF0aCkgY2xlYXJMb29rdXBbZ2V0SWQoY3VydmUpXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBsb2NhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGxvYyA9IGxvY2F0aW9uc1tpXSxcbiAgICAgICAgICAgIHRpbWUgPSBsb2MuX3RpbWUsXG4gICAgICAgICAgICBvcmlnVGltZSA9IHRpbWUsXG4gICAgICAgICAgICBleGNsdWRlID0gaW5jbHVkZSAmJiAhaW5jbHVkZShsb2MpLFxuICAgICAgICAgICAgY3VydmUgPSBsb2MuX2N1cnZlLFxuICAgICAgICAgICAgc2VnbWVudDtcblxuICAgICAgICBpZiAoY3VydmUpIHtcbiAgICAgICAgICBpZiAoY3VydmUgIT09IHByZXZDdXJ2ZSkge1xuICAgICAgICAgICAgY2xlYXJIYW5kbGVzID0gIWN1cnZlLmhhc0hhbmRsZXMoKSB8fCBjbGVhckxvb2t1cCAmJiBjbGVhckxvb2t1cFtnZXRJZChjdXJ2ZSldO1xuICAgICAgICAgICAgcmVub3JtYWxpemVMb2NzID0gW107XG4gICAgICAgICAgICBwcmV2VGltZSA9IG51bGw7XG4gICAgICAgICAgICBwcmV2Q3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZUaW1lID49IHRNaW4pIHtcbiAgICAgICAgICAgIHRpbWUgLz0gcHJldlRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4Y2x1ZGUpIHtcbiAgICAgICAgICBpZiAocmVub3JtYWxpemVMb2NzKSByZW5vcm1hbGl6ZUxvY3MucHVzaChsb2MpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICByZXN1bHRzLnVuc2hpZnQobG9jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZUaW1lID0gb3JpZ1RpbWU7XG5cbiAgICAgICAgaWYgKHRpbWUgPCB0TWluKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGN1cnZlLl9zZWdtZW50MTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lID4gdE1heCkge1xuICAgICAgICAgIHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld0N1cnZlID0gY3VydmUuZGl2aWRlQXRUaW1lKHRpbWUsIHRydWUpO1xuICAgICAgICAgIGlmIChjbGVhckhhbmRsZXMpIGNsZWFyQ3VydmVzLnB1c2goY3VydmUsIG5ld0N1cnZlKTtcbiAgICAgICAgICBzZWdtZW50ID0gbmV3Q3VydmUuX3NlZ21lbnQxO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IHJlbm9ybWFsaXplTG9jcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgdmFyIGwgPSByZW5vcm1hbGl6ZUxvY3Nbal07XG4gICAgICAgICAgICBsLl90aW1lID0gKGwuX3RpbWUgLSB0aW1lKSAvICgxIC0gdGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9jLl9zZXRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgICAgIHZhciBpbnRlciA9IHNlZ21lbnQuX2ludGVyc2VjdGlvbixcbiAgICAgICAgICAgIGRlc3QgPSBsb2MuX2ludGVyc2VjdGlvbjtcblxuICAgICAgICBpZiAoaW50ZXIpIHtcbiAgICAgICAgICBsaW5rSW50ZXJzZWN0aW9ucyhpbnRlciwgZGVzdCk7XG4gICAgICAgICAgdmFyIG90aGVyID0gaW50ZXI7XG5cbiAgICAgICAgICB3aGlsZSAob3RoZXIpIHtcbiAgICAgICAgICAgIGxpbmtJbnRlcnNlY3Rpb25zKG90aGVyLl9pbnRlcnNlY3Rpb24sIGludGVyKTtcbiAgICAgICAgICAgIG90aGVyID0gb3RoZXIuX25leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZ21lbnQuX2ludGVyc2VjdGlvbiA9IGRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFjbGVhckxhdGVyKSBjbGVhckN1cnZlSGFuZGxlcyhjbGVhckN1cnZlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0cyB8fCBsb2NhdGlvbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2luZGluZyhwb2ludCwgY3VydmVzLCBkaXIsIGNsb3NlZCwgZG9udEZsaXApIHtcbiAgICAgIHZhciBjdXJ2ZXNMaXN0ID0gQXJyYXkuaXNBcnJheShjdXJ2ZXMpID8gY3VydmVzIDogY3VydmVzW2RpciA/ICdob3InIDogJ3ZlciddO1xuICAgICAgdmFyIGlhID0gZGlyID8gMSA6IDAsXG4gICAgICAgICAgaW8gPSBpYSBeIDEsXG4gICAgICAgICAgcHYgPSBbcG9pbnQueCwgcG9pbnQueV0sXG4gICAgICAgICAgcGEgPSBwdltpYV0sXG4gICAgICAgICAgcG8gPSBwdltpb10sXG4gICAgICAgICAgd2luZGluZ0Vwc2lsb24gPSAxZS05LFxuICAgICAgICAgIHF1YWxpdHlFcHNpbG9uID0gMWUtNixcbiAgICAgICAgICBwYUwgPSBwYSAtIHdpbmRpbmdFcHNpbG9uLFxuICAgICAgICAgIHBhUiA9IHBhICsgd2luZGluZ0Vwc2lsb24sXG4gICAgICAgICAgd2luZGluZ0wgPSAwLFxuICAgICAgICAgIHdpbmRpbmdSID0gMCxcbiAgICAgICAgICBwYXRoV2luZGluZ0wgPSAwLFxuICAgICAgICAgIHBhdGhXaW5kaW5nUiA9IDAsXG4gICAgICAgICAgb25QYXRoID0gZmFsc2UsXG4gICAgICAgICAgb25BbnlQYXRoID0gZmFsc2UsXG4gICAgICAgICAgcXVhbGl0eSA9IDEsXG4gICAgICAgICAgcm9vdHMgPSBbXSxcbiAgICAgICAgICB2UHJldixcbiAgICAgICAgICB2Q2xvc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFdpbmRpbmcodikge1xuICAgICAgICB2YXIgbzAgPSB2W2lvICsgMF0sXG4gICAgICAgICAgICBvMyA9IHZbaW8gKyA2XTtcblxuICAgICAgICBpZiAocG8gPCBtaW4obzAsIG8zKSB8fCBwbyA+IG1heChvMCwgbzMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEwID0gdltpYSArIDBdLFxuICAgICAgICAgICAgYTEgPSB2W2lhICsgMl0sXG4gICAgICAgICAgICBhMiA9IHZbaWEgKyA0XSxcbiAgICAgICAgICAgIGEzID0gdltpYSArIDZdO1xuXG4gICAgICAgIGlmIChvMCA9PT0gbzMpIHtcbiAgICAgICAgICBpZiAoYTAgPCBwYVIgJiYgYTMgPiBwYUwgfHwgYTMgPCBwYVIgJiYgYTAgPiBwYUwpIHtcbiAgICAgICAgICAgIG9uUGF0aCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBwbyA9PT0gbzAgPyAwIDogcG8gPT09IG8zID8gMSA6IHBhTCA+IG1heChhMCwgYTEsIGEyLCBhMykgfHwgcGFSIDwgbWluKGEwLCBhMSwgYTIsIGEzKSA/IDEgOiBDdXJ2ZS5zb2x2ZUN1YmljKHYsIGlvLCBwbywgcm9vdHMsIDAsIDEpID4gMCA/IHJvb3RzWzBdIDogMSxcbiAgICAgICAgICAgIGEgPSB0ID09PSAwID8gYTAgOiB0ID09PSAxID8gYTMgOiBDdXJ2ZS5nZXRQb2ludCh2LCB0KVtkaXIgPyAneScgOiAneCddLFxuICAgICAgICAgICAgd2luZGluZyA9IG8wID4gbzMgPyAxIDogLTEsXG4gICAgICAgICAgICB3aW5kaW5nUHJldiA9IHZQcmV2W2lvXSA+IHZQcmV2W2lvICsgNl0gPyAxIDogLTEsXG4gICAgICAgICAgICBhM1ByZXYgPSB2UHJldltpYSArIDZdO1xuXG4gICAgICAgIGlmIChwbyAhPT0gbzApIHtcbiAgICAgICAgICBpZiAoYSA8IHBhTCkge1xuICAgICAgICAgICAgcGF0aFdpbmRpbmdMICs9IHdpbmRpbmc7XG4gICAgICAgICAgfSBlbHNlIGlmIChhID4gcGFSKSB7XG4gICAgICAgICAgICBwYXRoV2luZGluZ1IgKz0gd2luZGluZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25QYXRoID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYSA+IHBhIC0gcXVhbGl0eUVwc2lsb24gJiYgYSA8IHBhICsgcXVhbGl0eUVwc2lsb24pIHF1YWxpdHkgLz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAod2luZGluZyAhPT0gd2luZGluZ1ByZXYpIHtcbiAgICAgICAgICAgIGlmIChhMCA8IHBhTCkge1xuICAgICAgICAgICAgICBwYXRoV2luZGluZ0wgKz0gd2luZGluZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYTAgPiBwYVIpIHtcbiAgICAgICAgICAgICAgcGF0aFdpbmRpbmdSICs9IHdpbmRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhMCAhPSBhM1ByZXYpIHtcbiAgICAgICAgICAgIGlmIChhM1ByZXYgPCBwYVIgJiYgYSA+IHBhUikge1xuICAgICAgICAgICAgICBwYXRoV2luZGluZ1IgKz0gd2luZGluZztcbiAgICAgICAgICAgICAgb25QYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYTNQcmV2ID4gcGFMICYmIGEgPCBwYUwpIHtcbiAgICAgICAgICAgICAgcGF0aFdpbmRpbmdMICs9IHdpbmRpbmc7XG4gICAgICAgICAgICAgIG9uUGF0aCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcXVhbGl0eSAvPSA0O1xuICAgICAgICB9XG5cbiAgICAgICAgdlByZXYgPSB2O1xuICAgICAgICByZXR1cm4gIWRvbnRGbGlwICYmIGEgPiBwYUwgJiYgYSA8IHBhUiAmJiBDdXJ2ZS5nZXRUYW5nZW50KHYsIHQpW2RpciA/ICd4JyA6ICd5J10gPT09IDAgJiYgZ2V0V2luZGluZyhwb2ludCwgY3VydmVzLCAhZGlyLCBjbG9zZWQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVDdXJ2ZSh2KSB7XG4gICAgICAgIHZhciBvMCA9IHZbaW8gKyAwXSxcbiAgICAgICAgICAgIG8xID0gdltpbyArIDJdLFxuICAgICAgICAgICAgbzIgPSB2W2lvICsgNF0sXG4gICAgICAgICAgICBvMyA9IHZbaW8gKyA2XTtcblxuICAgICAgICBpZiAocG8gPD0gbWF4KG8wLCBvMSwgbzIsIG8zKSAmJiBwbyA+PSBtaW4obzAsIG8xLCBvMiwgbzMpKSB7XG4gICAgICAgICAgdmFyIGEwID0gdltpYSArIDBdLFxuICAgICAgICAgICAgICBhMSA9IHZbaWEgKyAyXSxcbiAgICAgICAgICAgICAgYTIgPSB2W2lhICsgNF0sXG4gICAgICAgICAgICAgIGEzID0gdltpYSArIDZdLFxuICAgICAgICAgICAgICBtb25vQ3VydmVzID0gcGFMID4gbWF4KGEwLCBhMSwgYTIsIGEzKSB8fCBwYVIgPCBtaW4oYTAsIGExLCBhMiwgYTMpID8gW3ZdIDogQ3VydmUuZ2V0TW9ub0N1cnZlcyh2LCBkaXIpLFxuICAgICAgICAgICAgICByZXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG1vbm9DdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVzID0gYWRkV2luZGluZyhtb25vQ3VydmVzW2ldKSkgcmV0dXJuIHJlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXNMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY3VydmUgPSBjdXJ2ZXNMaXN0W2ldLFxuICAgICAgICAgICAgcGF0aCA9IGN1cnZlLl9wYXRoLFxuICAgICAgICAgICAgdiA9IGN1cnZlLmdldFZhbHVlcygpLFxuICAgICAgICAgICAgcmVzO1xuXG4gICAgICAgIGlmICghaSB8fCBjdXJ2ZXNMaXN0W2kgLSAxXS5fcGF0aCAhPT0gcGF0aCkge1xuICAgICAgICAgIHZQcmV2ID0gbnVsbDtcblxuICAgICAgICAgIGlmICghcGF0aC5fY2xvc2VkKSB7XG4gICAgICAgICAgICB2Q2xvc2UgPSBDdXJ2ZS5nZXRWYWx1ZXMocGF0aC5nZXRMYXN0Q3VydmUoKS5nZXRTZWdtZW50MigpLCBjdXJ2ZS5nZXRTZWdtZW50MSgpLCBudWxsLCAhY2xvc2VkKTtcblxuICAgICAgICAgICAgaWYgKHZDbG9zZVtpb10gIT09IHZDbG9zZVtpbyArIDZdKSB7XG4gICAgICAgICAgICAgIHZQcmV2ID0gdkNsb3NlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdlByZXYpIHtcbiAgICAgICAgICAgIHZQcmV2ID0gdjtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gcGF0aC5nZXRMYXN0Q3VydmUoKTtcblxuICAgICAgICAgICAgd2hpbGUgKHByZXYgJiYgcHJldiAhPT0gY3VydmUpIHtcbiAgICAgICAgICAgICAgdmFyIHYyID0gcHJldi5nZXRWYWx1ZXMoKTtcblxuICAgICAgICAgICAgICBpZiAodjJbaW9dICE9PSB2MltpbyArIDZdKSB7XG4gICAgICAgICAgICAgICAgdlByZXYgPSB2MjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHByZXYgPSBwcmV2LmdldFByZXZpb3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcyA9IGhhbmRsZUN1cnZlKHYpKSByZXR1cm4gcmVzO1xuXG4gICAgICAgIGlmIChpICsgMSA9PT0gbCB8fCBjdXJ2ZXNMaXN0W2kgKyAxXS5fcGF0aCAhPT0gcGF0aCkge1xuICAgICAgICAgIGlmICh2Q2xvc2UgJiYgKHJlcyA9IGhhbmRsZUN1cnZlKHZDbG9zZSkpKSByZXR1cm4gcmVzO1xuXG4gICAgICAgICAgaWYgKG9uUGF0aCAmJiAhcGF0aFdpbmRpbmdMICYmICFwYXRoV2luZGluZ1IpIHtcbiAgICAgICAgICAgIHBhdGhXaW5kaW5nTCA9IHBhdGhXaW5kaW5nUiA9IHBhdGguaXNDbG9ja3dpc2UoY2xvc2VkKSBeIGRpciA/IDEgOiAtMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aW5kaW5nTCArPSBwYXRoV2luZGluZ0w7XG4gICAgICAgICAgd2luZGluZ1IgKz0gcGF0aFdpbmRpbmdSO1xuICAgICAgICAgIHBhdGhXaW5kaW5nTCA9IHBhdGhXaW5kaW5nUiA9IDA7XG5cbiAgICAgICAgICBpZiAob25QYXRoKSB7XG4gICAgICAgICAgICBvbkFueVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgb25QYXRoID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdkNsb3NlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aW5kaW5nTCA9IGFicyh3aW5kaW5nTCk7XG4gICAgICB3aW5kaW5nUiA9IGFicyh3aW5kaW5nUik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aW5kaW5nOiBtYXgod2luZGluZ0wsIHdpbmRpbmdSKSxcbiAgICAgICAgd2luZGluZ0w6IHdpbmRpbmdMLFxuICAgICAgICB3aW5kaW5nUjogd2luZGluZ1IsXG4gICAgICAgIHF1YWxpdHk6IHF1YWxpdHksXG4gICAgICAgIG9uUGF0aDogb25BbnlQYXRoXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVdpbmRpbmcoc2VnbWVudCwgcGF0aDEsIHBhdGgyLCBjdXJ2ZUNvbGxpc2lvbnNNYXAsIG9wZXJhdG9yKSB7XG4gICAgICB2YXIgY2hhaW4gPSBbXSxcbiAgICAgICAgICBzdGFydCA9IHNlZ21lbnQsXG4gICAgICAgICAgdG90YWxMZW5ndGggPSAwLFxuICAgICAgICAgIHdpbmRpbmc7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGN1cnZlID0gc2VnbWVudC5nZXRDdXJ2ZSgpO1xuXG4gICAgICAgIGlmIChjdXJ2ZSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcbiAgICAgICAgICBjaGFpbi5wdXNoKHtcbiAgICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnQsXG4gICAgICAgICAgICBjdXJ2ZTogY3VydmUsXG4gICAgICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LmdldE5leHQoKTtcbiAgICAgIH0gd2hpbGUgKHNlZ21lbnQgJiYgIXNlZ21lbnQuX2ludGVyc2VjdGlvbiAmJiBzZWdtZW50ICE9PSBzdGFydCk7XG5cbiAgICAgIHZhciBvZmZzZXRzID0gWzAuNSwgMC4yNSwgMC43NV0sXG4gICAgICAgICAgd2luZGluZyA9IHtcbiAgICAgICAgd2luZGluZzogMCxcbiAgICAgICAgcXVhbGl0eTogLTFcbiAgICAgIH0sXG4gICAgICAgICAgdE1pbiA9IDFlLTMsXG4gICAgICAgICAgdE1heCA9IDEgLSB0TWluO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoICYmIHdpbmRpbmcucXVhbGl0eSA8IDAuNTsgaSsrKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0b3RhbExlbmd0aCAqIG9mZnNldHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBjaGFpbi5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBjaGFpbltqXSxcbiAgICAgICAgICAgICAgY3VydmVMZW5ndGggPSBlbnRyeS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoIDw9IGN1cnZlTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY3VydmUgPSBlbnRyeS5jdXJ2ZSxcbiAgICAgICAgICAgICAgICBwYXRoID0gY3VydmUuX3BhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGF0aC5fcGFyZW50LFxuICAgICAgICAgICAgICAgIG9wZXJhbmQgPSBwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGggPyBwYXJlbnQgOiBwYXRoLFxuICAgICAgICAgICAgICAgIHQgPSBOdW1lcmljYWwuY2xhbXAoY3VydmUuZ2V0VGltZUF0KGxlbmd0aCksIHRNaW4sIHRNYXgpLFxuICAgICAgICAgICAgICAgIHB0ID0gY3VydmUuZ2V0UG9pbnRBdFRpbWUodCksXG4gICAgICAgICAgICAgICAgZGlyID0gYWJzKGN1cnZlLmdldFRhbmdlbnRBdFRpbWUodCkueSkgPCBNYXRoLlNRUlQxXzI7XG4gICAgICAgICAgICB2YXIgd2luZCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRvci5zdWJ0cmFjdCAmJiBwYXRoMikge1xuICAgICAgICAgICAgICB2YXIgb3RoZXJQYXRoID0gb3BlcmFuZCA9PT0gcGF0aDEgPyBwYXRoMiA6IHBhdGgxLFxuICAgICAgICAgICAgICAgICAgcGF0aFdpbmRpbmcgPSBvdGhlclBhdGguX2dldFdpbmRpbmcocHQsIGRpciwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKG9wZXJhbmQgPT09IHBhdGgxICYmIHBhdGhXaW5kaW5nLndpbmRpbmcgfHwgb3BlcmFuZCA9PT0gcGF0aDIgJiYgIXBhdGhXaW5kaW5nLndpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aFdpbmRpbmcucXVhbGl0eSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB3aW5kID0ge1xuICAgICAgICAgICAgICAgICAgICB3aW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICBxdWFsaXR5OiAxXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aW5kID0gd2luZCB8fCBnZXRXaW5kaW5nKHB0LCBjdXJ2ZUNvbGxpc2lvbnNNYXBbcGF0aC5faWRdW2N1cnZlLmdldEluZGV4KCldLCBkaXIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHdpbmQucXVhbGl0eSA+IHdpbmRpbmcucXVhbGl0eSkgd2luZGluZyA9IHdpbmQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZW5ndGggLT0gY3VydmVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IGNoYWluLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGNoYWluW2pdLnNlZ21lbnQuX3dpbmRpbmcgPSB3aW5kaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKSB7XG4gICAgICB2YXIgcGF0aHMgPSBbXSxcbiAgICAgICAgICBzdGFydHM7XG5cbiAgICAgIGZ1bmN0aW9uIGlzVmFsaWQoc2VnKSB7XG4gICAgICAgIHZhciB3aW5kaW5nO1xuICAgICAgICByZXR1cm4gISEoc2VnICYmICFzZWcuX3Zpc2l0ZWQgJiYgKCFvcGVyYXRvciB8fCBvcGVyYXRvclsod2luZGluZyA9IHNlZy5fd2luZGluZyB8fCB7fSkud2luZGluZ10gJiYgIShvcGVyYXRvci51bml0ZSAmJiB3aW5kaW5nLndpbmRpbmcgPT09IDIgJiYgd2luZGluZy53aW5kaW5nTCAmJiB3aW5kaW5nLndpbmRpbmdSKSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1N0YXJ0KHNlZykge1xuICAgICAgICBpZiAoc2VnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VnID09PSBzdGFydHNbaV0pIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmlzaXRQYXRoKHBhdGgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBzZWdtZW50c1tpXS5fdmlzaXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Q3Jvc3NpbmdTZWdtZW50cyhzZWdtZW50LCBjb2xsZWN0U3RhcnRzKSB7XG4gICAgICAgIHZhciBpbnRlciA9IHNlZ21lbnQuX2ludGVyc2VjdGlvbixcbiAgICAgICAgICAgIHN0YXJ0ID0gaW50ZXIsXG4gICAgICAgICAgICBjcm9zc2luZ3MgPSBbXTtcbiAgICAgICAgaWYgKGNvbGxlY3RTdGFydHMpIHN0YXJ0cyA9IFtzZWdtZW50XTtcblxuICAgICAgICBmdW5jdGlvbiBjb2xsZWN0KGludGVyLCBlbmQpIHtcbiAgICAgICAgICB3aGlsZSAoaW50ZXIgJiYgaW50ZXIgIT09IGVuZCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gaW50ZXIuX3NlZ21lbnQsXG4gICAgICAgICAgICAgICAgcGF0aCA9IG90aGVyICYmIG90aGVyLl9wYXRoO1xuXG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICB2YXIgbmV4dCA9IG90aGVyLmdldE5leHQoKSB8fCBwYXRoLmdldEZpcnN0U2VnbWVudCgpLFxuICAgICAgICAgICAgICAgICAgbmV4dEludGVyID0gbmV4dC5faW50ZXJzZWN0aW9uO1xuXG4gICAgICAgICAgICAgIGlmIChvdGhlciAhPT0gc2VnbWVudCAmJiAoaXNTdGFydChvdGhlcikgfHwgaXNTdGFydChuZXh0KSB8fCBuZXh0ICYmIGlzVmFsaWQob3RoZXIpICYmIChpc1ZhbGlkKG5leHQpIHx8IG5leHRJbnRlciAmJiBpc1ZhbGlkKG5leHRJbnRlci5fc2VnbWVudCkpKSkge1xuICAgICAgICAgICAgICAgIGNyb3NzaW5ncy5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb2xsZWN0U3RhcnRzKSBzdGFydHMucHVzaChvdGhlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGludGVyID0gaW50ZXIuX25leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVyKSB7XG4gICAgICAgICAgY29sbGVjdChpbnRlcik7XG5cbiAgICAgICAgICB3aGlsZSAoaW50ZXIgJiYgaW50ZXIuX3ByZXZpb3VzKSBpbnRlciA9IGludGVyLl9wcmV2aW91cztcblxuICAgICAgICAgIGNvbGxlY3QoaW50ZXIsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcm9zc2luZ3M7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnRzLnNvcnQoZnVuY3Rpb24gKHNlZzEsIHNlZzIpIHtcbiAgICAgICAgdmFyIGludGVyMSA9IHNlZzEuX2ludGVyc2VjdGlvbixcbiAgICAgICAgICAgIGludGVyMiA9IHNlZzIuX2ludGVyc2VjdGlvbixcbiAgICAgICAgICAgIG92ZXIxID0gISEoaW50ZXIxICYmIGludGVyMS5fb3ZlcmxhcCksXG4gICAgICAgICAgICBvdmVyMiA9ICEhKGludGVyMiAmJiBpbnRlcjIuX292ZXJsYXApLFxuICAgICAgICAgICAgcGF0aDEgPSBzZWcxLl9wYXRoLFxuICAgICAgICAgICAgcGF0aDIgPSBzZWcyLl9wYXRoO1xuICAgICAgICByZXR1cm4gb3ZlcjEgXiBvdmVyMiA/IG92ZXIxID8gMSA6IC0xIDogIWludGVyMSBeICFpbnRlcjIgPyBpbnRlcjEgPyAxIDogLTEgOiBwYXRoMSAhPT0gcGF0aDIgPyBwYXRoMS5faWQgLSBwYXRoMi5faWQgOiBzZWcxLl9pbmRleCAtIHNlZzIuX2luZGV4O1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWcgPSBzZWdtZW50c1tpXSxcbiAgICAgICAgICAgIHZhbGlkID0gaXNWYWxpZChzZWcpLFxuICAgICAgICAgICAgcGF0aCA9IG51bGwsXG4gICAgICAgICAgICBmaW5pc2hlZCA9IGZhbHNlLFxuICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZSxcbiAgICAgICAgICAgIGJyYW5jaGVzID0gW10sXG4gICAgICAgICAgICBicmFuY2gsXG4gICAgICAgICAgICB2aXNpdGVkLFxuICAgICAgICAgICAgaGFuZGxlSW47XG5cbiAgICAgICAgaWYgKHZhbGlkICYmIHNlZy5fcGF0aC5fb3ZlcmxhcHNPbmx5KSB7XG4gICAgICAgICAgdmFyIHBhdGgxID0gc2VnLl9wYXRoLFxuICAgICAgICAgICAgICBwYXRoMiA9IHNlZy5faW50ZXJzZWN0aW9uLl9zZWdtZW50Ll9wYXRoO1xuXG4gICAgICAgICAgaWYgKHBhdGgxLmNvbXBhcmUocGF0aDIpKSB7XG4gICAgICAgICAgICBpZiAocGF0aDEuZ2V0QXJlYSgpKSBwYXRocy5wdXNoKHBhdGgxLmNsb25lKGZhbHNlKSk7XG4gICAgICAgICAgICB2aXNpdFBhdGgocGF0aDEpO1xuICAgICAgICAgICAgdmlzaXRQYXRoKHBhdGgyKTtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHZhbGlkKSB7XG4gICAgICAgICAgdmFyIGZpcnN0ID0gIXBhdGgsXG4gICAgICAgICAgICAgIGNyb3NzaW5ncyA9IGdldENyb3NzaW5nU2VnbWVudHMoc2VnLCBmaXJzdCksXG4gICAgICAgICAgICAgIG90aGVyID0gY3Jvc3NpbmdzLnNoaWZ0KCksXG4gICAgICAgICAgICAgIGZpbmlzaGVkID0gIWZpcnN0ICYmIChpc1N0YXJ0KHNlZykgfHwgaXNTdGFydChvdGhlcikpLFxuICAgICAgICAgICAgICBjcm9zcyA9ICFmaW5pc2hlZCAmJiBvdGhlcjtcblxuICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgcGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcbiAgICAgICAgICAgIGJyYW5jaCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICBpZiAoc2VnLmlzRmlyc3QoKSB8fCBzZWcuaXNMYXN0KCkpIGNsb3NlZCA9IHNlZy5fcGF0aC5fY2xvc2VkO1xuICAgICAgICAgICAgc2VnLl92aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjcm9zcyAmJiBicmFuY2gpIHtcbiAgICAgICAgICAgIGJyYW5jaGVzLnB1c2goYnJhbmNoKTtcbiAgICAgICAgICAgIGJyYW5jaCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFicmFuY2gpIHtcbiAgICAgICAgICAgIGlmIChjcm9zcykgY3Jvc3NpbmdzLnB1c2goc2VnKTtcbiAgICAgICAgICAgIGJyYW5jaCA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IHBhdGguX3NlZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgY3Jvc3NpbmdzOiBjcm9zc2luZ3MsXG4gICAgICAgICAgICAgIHZpc2l0ZWQ6IHZpc2l0ZWQgPSBbXSxcbiAgICAgICAgICAgICAgaGFuZGxlSW46IGhhbmRsZUluXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjcm9zcykgc2VnID0gb3RoZXI7XG5cbiAgICAgICAgICBpZiAoIWlzVmFsaWQoc2VnKSkge1xuICAgICAgICAgICAgcGF0aC5yZW1vdmVTZWdtZW50cyhicmFuY2guc3RhcnQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHZpc2l0ZWQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgIHZpc2l0ZWRbal0uX3Zpc2l0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlzaXRlZC5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHNlZyA9IGJyYW5jaCAmJiBicmFuY2guY3Jvc3NpbmdzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgaWYgKCFzZWcgfHwgIXNlZy5fcGF0aCkge1xuICAgICAgICAgICAgICAgIHNlZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJhbmNoID0gYnJhbmNoZXMucG9wKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgICB2aXNpdGVkID0gYnJhbmNoLnZpc2l0ZWQ7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVJbiA9IGJyYW5jaC5oYW5kbGVJbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGJyYW5jaCAmJiAhaXNWYWxpZChzZWcpKTtcblxuICAgICAgICAgICAgaWYgKCFzZWcpIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXh0ID0gc2VnLmdldE5leHQoKTtcbiAgICAgICAgICBwYXRoLmFkZChuZXcgU2VnbWVudChzZWcuX3BvaW50LCBoYW5kbGVJbiwgbmV4dCAmJiBzZWcuX2hhbmRsZU91dCkpO1xuICAgICAgICAgIHNlZy5fdmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgdmlzaXRlZC5wdXNoKHNlZyk7XG4gICAgICAgICAgc2VnID0gbmV4dCB8fCBzZWcuX3BhdGguZ2V0Rmlyc3RTZWdtZW50KCk7XG4gICAgICAgICAgaGFuZGxlSW4gPSBuZXh0ICYmIG5leHQuX2hhbmRsZUluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgcGF0aC5nZXRGaXJzdFNlZ21lbnQoKS5zZXRIYW5kbGVJbihoYW5kbGVJbik7XG4gICAgICAgICAgICBwYXRoLnNldENsb3NlZChjbG9zZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXRoLmdldEFyZWEoKSAhPT0gMCkge1xuICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBfZ2V0V2luZGluZzogZnVuY3Rpb24gKHBvaW50LCBkaXIsIGNsb3NlZCkge1xuICAgICAgICByZXR1cm4gZ2V0V2luZGluZyhwb2ludCwgdGhpcy5nZXRDdXJ2ZXMoKSwgZGlyLCBjbG9zZWQpO1xuICAgICAgfSxcbiAgICAgIHVuaXRlOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHJhY2VCb29sZWFuKHRoaXMsIHBhdGgsICd1bml0ZScsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlQm9vbGVhbih0aGlzLCBwYXRoLCAnaW50ZXJzZWN0Jywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgc3VidHJhY3Q6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0cmFjZUJvb2xlYW4odGhpcywgcGF0aCwgJ3N1YnRyYWN0Jywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgZXhjbHVkZTogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlQm9vbGVhbih0aGlzLCBwYXRoLCAnZXhjbHVkZScsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIGRpdmlkZTogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMgJiYgKG9wdGlvbnMudHJhY2UgPT0gZmFsc2UgfHwgb3B0aW9ucy5zdHJva2UpID8gc3BsaXRCb29sZWFuKHRoaXMsIHBhdGgsICdkaXZpZGUnKSA6IGNyZWF0ZVJlc3VsdChbdGhpcy5zdWJ0cmFjdChwYXRoLCBvcHRpb25zKSwgdGhpcy5pbnRlcnNlY3QocGF0aCwgb3B0aW9ucyldLCB0cnVlLCB0aGlzLCBwYXRoLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICByZXNvbHZlQ3Jvc3NpbmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuICAgICAgICAgICAgcGF0aHMgPSBjaGlsZHJlbiB8fCBbdGhpc107XG5cbiAgICAgICAgZnVuY3Rpb24gaGFzT3ZlcmxhcChzZWcsIHBhdGgpIHtcbiAgICAgICAgICB2YXIgaW50ZXIgPSBzZWcgJiYgc2VnLl9pbnRlcnNlY3Rpb247XG4gICAgICAgICAgcmV0dXJuIGludGVyICYmIGludGVyLl9vdmVybGFwICYmIGludGVyLl9wYXRoID09PSBwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhc092ZXJsYXBzID0gZmFsc2UsXG4gICAgICAgICAgICBoYXNDcm9zc2luZ3MgPSBmYWxzZSxcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnMgPSB0aGlzLmdldEludGVyc2VjdGlvbnMobnVsbCwgZnVuY3Rpb24gKGludGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyLmhhc092ZXJsYXAoKSAmJiAoaGFzT3ZlcmxhcHMgPSB0cnVlKSB8fCBpbnRlci5pc0Nyb3NzaW5nKCkgJiYgKGhhc0Nyb3NzaW5ncyA9IHRydWUpO1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIGNsZWFyQ3VydmVzID0gaGFzT3ZlcmxhcHMgJiYgaGFzQ3Jvc3NpbmdzICYmIFtdO1xuICAgICAgICBpbnRlcnNlY3Rpb25zID0gQ3VydmVMb2NhdGlvbi5leHBhbmQoaW50ZXJzZWN0aW9ucyk7XG5cbiAgICAgICAgaWYgKGhhc092ZXJsYXBzKSB7XG4gICAgICAgICAgdmFyIG92ZXJsYXBzID0gZGl2aWRlTG9jYXRpb25zKGludGVyc2VjdGlvbnMsIGZ1bmN0aW9uIChpbnRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyLmhhc092ZXJsYXAoKTtcbiAgICAgICAgICB9LCBjbGVhckN1cnZlcyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gb3ZlcmxhcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBvdmVybGFwID0gb3ZlcmxhcHNbaV0sXG4gICAgICAgICAgICAgICAgcGF0aCA9IG92ZXJsYXAuX3BhdGgsXG4gICAgICAgICAgICAgICAgc2VnID0gb3ZlcmxhcC5fc2VnbWVudCxcbiAgICAgICAgICAgICAgICBwcmV2ID0gc2VnLmdldFByZXZpb3VzKCksXG4gICAgICAgICAgICAgICAgbmV4dCA9IHNlZy5nZXROZXh0KCk7XG5cbiAgICAgICAgICAgIGlmIChoYXNPdmVybGFwKHByZXYsIHBhdGgpICYmIGhhc092ZXJsYXAobmV4dCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgc2VnLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgIHByZXYuX2hhbmRsZU91dC5fc2V0KDAsIDApO1xuXG4gICAgICAgICAgICAgIG5leHQuX2hhbmRsZUluLl9zZXQoMCwgMCk7XG5cbiAgICAgICAgICAgICAgaWYgKHByZXYgIT09IHNlZyAmJiAhcHJldi5nZXRDdXJ2ZSgpLmhhc0xlbmd0aCgpKSB7XG4gICAgICAgICAgICAgICAgbmV4dC5faGFuZGxlSW4uc2V0KHByZXYuX2hhbmRsZUluKTtcblxuICAgICAgICAgICAgICAgIHByZXYucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzQ3Jvc3NpbmdzKSB7XG4gICAgICAgICAgZGl2aWRlTG9jYXRpb25zKGludGVyc2VjdGlvbnMsIGhhc092ZXJsYXBzICYmIGZ1bmN0aW9uIChpbnRlcikge1xuICAgICAgICAgICAgdmFyIGN1cnZlMSA9IGludGVyLmdldEN1cnZlKCksXG4gICAgICAgICAgICAgICAgc2VnMSA9IGludGVyLmdldFNlZ21lbnQoKSxcbiAgICAgICAgICAgICAgICBvdGhlciA9IGludGVyLl9pbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICAgICAgY3VydmUyID0gb3RoZXIuX2N1cnZlLFxuICAgICAgICAgICAgICAgIHNlZzIgPSBvdGhlci5fc2VnbWVudDtcbiAgICAgICAgICAgIGlmIChjdXJ2ZTEgJiYgY3VydmUyICYmIGN1cnZlMS5fcGF0aCAmJiBjdXJ2ZTIuX3BhdGgpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHNlZzEpIHNlZzEuX2ludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2VnMikgc2VnMi5faW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICB9LCBjbGVhckN1cnZlcyk7XG4gICAgICAgICAgaWYgKGNsZWFyQ3VydmVzKSBjbGVhckN1cnZlSGFuZGxlcyhjbGVhckN1cnZlcyk7XG4gICAgICAgICAgcGF0aHMgPSB0cmFjZVBhdGhzKEJhc2UuZWFjaChwYXRocywgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIEJhc2UucHVzaCh0aGlzLCBwYXRoLl9zZWdtZW50cyk7XG4gICAgICAgICAgfSwgW10pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgIGlmIChsZW5ndGggPiAxICYmIGNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKHBhdGhzICE9PSBjaGlsZHJlbikgdGhpcy5zZXRDaGlsZHJlbihwYXRocyk7XG4gICAgICAgICAgaXRlbSA9IHRoaXM7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSAxICYmICFjaGlsZHJlbikge1xuICAgICAgICAgIGlmIChwYXRoc1swXSAhPT0gdGhpcykgdGhpcy5zZXRTZWdtZW50cyhwYXRoc1swXS5yZW1vdmVTZWdtZW50cygpKTtcbiAgICAgICAgICBpdGVtID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgIGl0ZW0gPSBuZXcgQ29tcG91bmRQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcbiAgICAgICAgICBpdGVtLmFkZENoaWxkcmVuKHBhdGhzKTtcbiAgICAgICAgICBpdGVtID0gaXRlbS5yZWR1Y2UoKTtcbiAgICAgICAgICBpdGVtLmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGgoaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0sXG4gICAgICByZW9yaWVudDogZnVuY3Rpb24gKG5vblplcm8sIGNsb2Nrd2lzZSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5zZXRDaGlsZHJlbihyZW9yaWVudFBhdGhzKHRoaXMucmVtb3ZlQ2hpbGRyZW4oKSwgZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIHJldHVybiAhIShub25aZXJvID8gdyA6IHcgJiAxKTtcbiAgICAgICAgICB9LCBjbG9ja3dpc2UpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuc2V0Q2xvY2t3aXNlKGNsb2Nrd2lzZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBnZXRJbnRlcmlvclBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuICAgICAgICAgICAgcG9pbnQgPSBib3VuZHMuZ2V0Q2VudGVyKHRydWUpO1xuXG4gICAgICAgIGlmICghdGhpcy5jb250YWlucyhwb2ludCkpIHtcbiAgICAgICAgICB2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcbiAgICAgICAgICAgICAgeSA9IHBvaW50LnksXG4gICAgICAgICAgICAgIGludGVyY2VwdHMgPSBbXSxcbiAgICAgICAgICAgICAgcm9vdHMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHYgPSBjdXJ2ZXNbaV0uZ2V0VmFsdWVzKCksXG4gICAgICAgICAgICAgICAgbzAgPSB2WzFdLFxuICAgICAgICAgICAgICAgIG8xID0gdlszXSxcbiAgICAgICAgICAgICAgICBvMiA9IHZbNV0sXG4gICAgICAgICAgICAgICAgbzMgPSB2WzddO1xuXG4gICAgICAgICAgICBpZiAoeSA+PSBtaW4obzAsIG8xLCBvMiwgbzMpICYmIHkgPD0gbWF4KG8wLCBvMSwgbzIsIG8zKSkge1xuICAgICAgICAgICAgICB2YXIgbW9ub0N1cnZlcyA9IEN1cnZlLmdldE1vbm9DdXJ2ZXModik7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBtb25vQ3VydmVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBtdiA9IG1vbm9DdXJ2ZXNbal0sXG4gICAgICAgICAgICAgICAgICAgIG1vMCA9IG12WzFdLFxuICAgICAgICAgICAgICAgICAgICBtbzMgPSBtdls3XTtcblxuICAgICAgICAgICAgICAgIGlmIChtbzAgIT09IG1vMyAmJiAoeSA+PSBtbzAgJiYgeSA8PSBtbzMgfHwgeSA+PSBtbzMgJiYgeSA8PSBtbzApKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgeCA9IHkgPT09IG1vMCA/IG12WzBdIDogeSA9PT0gbW8zID8gbXZbNl0gOiBDdXJ2ZS5zb2x2ZUN1YmljKG12LCAxLCB5LCByb290cywgMCwgMSkgPT09IDEgPyBDdXJ2ZS5nZXRQb2ludChtdiwgcm9vdHNbMF0pLnggOiAobXZbMF0gKyBtdls2XSkgLyAyO1xuICAgICAgICAgICAgICAgICAgaW50ZXJjZXB0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnRlcmNlcHRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGludGVyY2VwdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvaW50LnggPSAoaW50ZXJjZXB0c1swXSArIGludGVyY2VwdHNbMV0pIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpKTtcbiAgdmFyIFBhdGhGbGF0dGVuZXIgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUGF0aEZsYXR0ZW5lcicsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHBhdGgsIGZsYXRuZXNzLCBtYXhSZWN1cnNpb24sIGlnbm9yZVN0cmFpZ2h0LCBtYXRyaXgpIHtcbiAgICAgIHZhciBjdXJ2ZXMgPSBbXSxcbiAgICAgICAgICBwYXJ0cyA9IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgICAgbWluU3BhbiA9IDEgLyAobWF4UmVjdXJzaW9uIHx8IDMyKSxcbiAgICAgICAgICBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuICAgICAgICAgIHNlZ21lbnQxID0gc2VnbWVudHNbMF0sXG4gICAgICAgICAgc2VnbWVudDI7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mikge1xuICAgICAgICB2YXIgY3VydmUgPSBDdXJ2ZS5nZXRWYWx1ZXMoc2VnbWVudDEsIHNlZ21lbnQyLCBtYXRyaXgpO1xuICAgICAgICBjdXJ2ZXMucHVzaChjdXJ2ZSk7XG4gICAgICAgIGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgc2VnbWVudDEuX2luZGV4LCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcHV0ZVBhcnRzKGN1cnZlLCBpbmRleCwgdDEsIHQyKSB7XG4gICAgICAgIGlmICh0MiAtIHQxID4gbWluU3BhbiAmJiAhKGlnbm9yZVN0cmFpZ2h0ICYmIEN1cnZlLmlzU3RyYWlnaHQoY3VydmUpKSAmJiAhQ3VydmUuaXNGbGF0RW5vdWdoKGN1cnZlLCBmbGF0bmVzcyB8fCAwLjI1KSkge1xuICAgICAgICAgIHZhciBoYWx2ZXMgPSBDdXJ2ZS5zdWJkaXZpZGUoY3VydmUsIDAuNSksXG4gICAgICAgICAgICAgIHRNaWQgPSAodDEgKyB0MikgLyAyO1xuICAgICAgICAgIGNvbXB1dGVQYXJ0cyhoYWx2ZXNbMF0sIGluZGV4LCB0MSwgdE1pZCk7XG4gICAgICAgICAgY29tcHV0ZVBhcnRzKGhhbHZlc1sxXSwgaW5kZXgsIHRNaWQsIHQyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZHggPSBjdXJ2ZVs2XSAtIGN1cnZlWzBdLFxuICAgICAgICAgICAgICBkeSA9IGN1cnZlWzddIC0gY3VydmVbMV0sXG4gICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gZGlzdDtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICBvZmZzZXQ6IGxlbmd0aCxcbiAgICAgICAgICAgICAgY3VydmU6IGN1cnZlLFxuICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIHRpbWU6IHQyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc2VnbWVudDIgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgYWRkQ3VydmUoc2VnbWVudDEsIHNlZ21lbnQyKTtcbiAgICAgICAgc2VnbWVudDEgPSBzZWdtZW50MjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGguX2Nsb3NlZCkgYWRkQ3VydmUoc2VnbWVudDIgfHwgc2VnbWVudDEsIHNlZ21lbnRzWzBdKTtcbiAgICAgIHRoaXMuY3VydmVzID0gY3VydmVzO1xuICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9LFxuICAgIF9nZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIHZhciBwYXJ0cyA9IHRoaXMucGFydHMsXG4gICAgICAgICAgbGVuZ3RoID0gcGFydHMubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGksXG4gICAgICAgICAgaiA9IHRoaXMuaW5kZXg7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaSA9IGo7XG4gICAgICAgIGlmICghaiB8fCBwYXJ0c1stLWpdLm9mZnNldCA8IG9mZnNldCkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICBpZiAocGFydC5vZmZzZXQgPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgdmFyIHByZXYgPSBwYXJ0c1tpIC0gMV0sXG4gICAgICAgICAgICAgIHByZXZUaW1lID0gcHJldiAmJiBwcmV2LmluZGV4ID09PSBwYXJ0LmluZGV4ID8gcHJldi50aW1lIDogMCxcbiAgICAgICAgICAgICAgcHJldk9mZnNldCA9IHByZXYgPyBwcmV2Lm9mZnNldCA6IDA7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4OiBwYXJ0LmluZGV4LFxuICAgICAgICAgICAgdGltZTogcHJldlRpbWUgKyAocGFydC50aW1lIC0gcHJldlRpbWUpICogKG9mZnNldCAtIHByZXZPZmZzZXQpIC8gKHBhcnQub2Zmc2V0IC0gcHJldk9mZnNldClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4OiBwYXJ0c1tsZW5ndGggLSAxXS5pbmRleCxcbiAgICAgICAgdGltZTogMVxuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXdQYXJ0OiBmdW5jdGlvbiAoY3R4LCBmcm9tLCB0bykge1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fZ2V0KGZyb20pLFxuICAgICAgICAgIGVuZCA9IHRoaXMuX2dldCh0byk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydC5pbmRleCwgbCA9IGVuZC5pbmRleDsgaSA8PSBsOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnZlID0gQ3VydmUuZ2V0UGFydCh0aGlzLmN1cnZlc1tpXSwgaSA9PT0gc3RhcnQuaW5kZXggPyBzdGFydC50aW1lIDogMCwgaSA9PT0gZW5kLmluZGV4ID8gZW5kLnRpbWUgOiAxKTtcbiAgICAgICAgaWYgKGkgPT09IHN0YXJ0LmluZGV4KSBjdHgubW92ZVRvKGN1cnZlWzBdLCBjdXJ2ZVsxXSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgY3VydmUuc2xpY2UoMikpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgQmFzZS5lYWNoKEN1cnZlLl9ldmFsdWF0ZU1ldGhvZHMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICB2YXIgcGFyYW0gPSB0aGlzLl9nZXQob2Zmc2V0KTtcblxuICAgICAgcmV0dXJuIEN1cnZlW25hbWVdKHRoaXMuY3VydmVzW3BhcmFtLmluZGV4XSwgcGFyYW0udGltZSk7XG4gICAgfTtcbiAgfSwge30pKTtcbiAgdmFyIFBhdGhGaXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyA9IFtdLFxuICAgICAgICAgIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG4gICAgICAgICAgY2xvc2VkID0gcGF0aC5fY2xvc2VkO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgcHJldiwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcG9pbnQgPSBzZWdtZW50c1tpXS5wb2ludDtcblxuICAgICAgICBpZiAoIXByZXYgfHwgIXByZXYuZXF1YWxzKHBvaW50KSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHByZXYgPSBwb2ludC5jbG9uZSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgIHBvaW50cy51bnNoaWZ0KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICBwb2ludHMucHVzaChwb2ludHNbMV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsb3NlZCA9IGNsb3NlZDtcbiAgICB9LFxuICAgIGZpdDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICBzZWdtZW50cyA9IG51bGw7XG5cbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIHNlZ21lbnRzID0gW25ldyBTZWdtZW50KHBvaW50c1swXSldO1xuXG4gICAgICAgIGlmIChsZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5maXRDdWJpYyhzZWdtZW50cywgZXJyb3IsIDAsIGxlbmd0aCAtIDEsIHBvaW50c1sxXS5zdWJ0cmFjdChwb2ludHNbMF0pLCBwb2ludHNbbGVuZ3RoIC0gMl0uc3VidHJhY3QocG9pbnRzW2xlbmd0aCAtIDFdKSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlZ21lbnRzO1xuICAgIH0sXG4gICAgZml0Q3ViaWM6IGZ1bmN0aW9uIChzZWdtZW50cywgZXJyb3IsIGZpcnN0LCBsYXN0LCB0YW4xLCB0YW4yKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cbiAgICAgIGlmIChsYXN0IC0gZmlyc3QgPT09IDEpIHtcbiAgICAgICAgdmFyIHB0MSA9IHBvaW50c1tmaXJzdF0sXG4gICAgICAgICAgICBwdDIgPSBwb2ludHNbbGFzdF0sXG4gICAgICAgICAgICBkaXN0ID0gcHQxLmdldERpc3RhbmNlKHB0MikgLyAzO1xuICAgICAgICB0aGlzLmFkZEN1cnZlKHNlZ21lbnRzLCBbcHQxLCBwdDEuYWRkKHRhbjEubm9ybWFsaXplKGRpc3QpKSwgcHQyLmFkZCh0YW4yLm5vcm1hbGl6ZShkaXN0KSksIHB0Ml0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB1UHJpbWUgPSB0aGlzLmNob3JkTGVuZ3RoUGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0KSxcbiAgICAgICAgICBtYXhFcnJvciA9IE1hdGgubWF4KGVycm9yLCBlcnJvciAqIGVycm9yKSxcbiAgICAgICAgICBzcGxpdCxcbiAgICAgICAgICBwYXJhbWV0ZXJzSW5PcmRlciA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDQ7IGkrKykge1xuICAgICAgICB2YXIgY3VydmUgPSB0aGlzLmdlbmVyYXRlQmV6aWVyKGZpcnN0LCBsYXN0LCB1UHJpbWUsIHRhbjEsIHRhbjIpO1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5maW5kTWF4RXJyb3IoZmlyc3QsIGxhc3QsIGN1cnZlLCB1UHJpbWUpO1xuXG4gICAgICAgIGlmIChtYXguZXJyb3IgPCBlcnJvciAmJiBwYXJhbWV0ZXJzSW5PcmRlcikge1xuICAgICAgICAgIHRoaXMuYWRkQ3VydmUoc2VnbWVudHMsIGN1cnZlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzcGxpdCA9IG1heC5pbmRleDtcbiAgICAgICAgaWYgKG1heC5lcnJvciA+PSBtYXhFcnJvcikgYnJlYWs7XG4gICAgICAgIHBhcmFtZXRlcnNJbk9yZGVyID0gdGhpcy5yZXBhcmFtZXRlcml6ZShmaXJzdCwgbGFzdCwgdVByaW1lLCBjdXJ2ZSk7XG4gICAgICAgIG1heEVycm9yID0gbWF4LmVycm9yO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFuQ2VudGVyID0gcG9pbnRzW3NwbGl0IC0gMV0uc3VidHJhY3QocG9pbnRzW3NwbGl0ICsgMV0pO1xuICAgICAgdGhpcy5maXRDdWJpYyhzZWdtZW50cywgZXJyb3IsIGZpcnN0LCBzcGxpdCwgdGFuMSwgdGFuQ2VudGVyKTtcbiAgICAgIHRoaXMuZml0Q3ViaWMoc2VnbWVudHMsIGVycm9yLCBzcGxpdCwgbGFzdCwgdGFuQ2VudGVyLm5lZ2F0ZSgpLCB0YW4yKTtcbiAgICB9LFxuICAgIGFkZEN1cnZlOiBmdW5jdGlvbiAoc2VnbWVudHMsIGN1cnZlKSB7XG4gICAgICB2YXIgcHJldiA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgcHJldi5zZXRIYW5kbGVPdXQoY3VydmVbMV0uc3VidHJhY3QoY3VydmVbMF0pKTtcbiAgICAgIHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQoY3VydmVbM10sIGN1cnZlWzJdLnN1YnRyYWN0KGN1cnZlWzNdKSkpO1xuICAgIH0sXG4gICAgZ2VuZXJhdGVCZXppZXI6IGZ1bmN0aW9uIChmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IDFlLTEyLFxuICAgICAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgIHB0MSA9IHBvaW50c1tmaXJzdF0sXG4gICAgICAgICAgcHQyID0gcG9pbnRzW2xhc3RdLFxuICAgICAgICAgIEMgPSBbWzAsIDBdLCBbMCwgMF1dLFxuICAgICAgICAgIFggPSBbMCwgMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGFzdCAtIGZpcnN0ICsgMTsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgdSA9IHVQcmltZVtpXSxcbiAgICAgICAgICAgIHQgPSAxIC0gdSxcbiAgICAgICAgICAgIGIgPSAzICogdSAqIHQsXG4gICAgICAgICAgICBiMCA9IHQgKiB0ICogdCxcbiAgICAgICAgICAgIGIxID0gYiAqIHQsXG4gICAgICAgICAgICBiMiA9IGIgKiB1LFxuICAgICAgICAgICAgYjMgPSB1ICogdSAqIHUsXG4gICAgICAgICAgICBhMSA9IHRhbjEubm9ybWFsaXplKGIxKSxcbiAgICAgICAgICAgIGEyID0gdGFuMi5ub3JtYWxpemUoYjIpLFxuICAgICAgICAgICAgdG1wID0gcG9pbnRzW2ZpcnN0ICsgaV0uc3VidHJhY3QocHQxLm11bHRpcGx5KGIwICsgYjEpKS5zdWJ0cmFjdChwdDIubXVsdGlwbHkoYjIgKyBiMykpO1xuICAgICAgICBDWzBdWzBdICs9IGExLmRvdChhMSk7XG4gICAgICAgIENbMF1bMV0gKz0gYTEuZG90KGEyKTtcbiAgICAgICAgQ1sxXVswXSA9IENbMF1bMV07XG4gICAgICAgIENbMV1bMV0gKz0gYTIuZG90KGEyKTtcbiAgICAgICAgWFswXSArPSBhMS5kb3QodG1wKTtcbiAgICAgICAgWFsxXSArPSBhMi5kb3QodG1wKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRldEMwQzEgPSBDWzBdWzBdICogQ1sxXVsxXSAtIENbMV1bMF0gKiBDWzBdWzFdLFxuICAgICAgICAgIGFscGhhMSxcbiAgICAgICAgICBhbHBoYTI7XG5cbiAgICAgIGlmIChhYnMoZGV0QzBDMSkgPiBlcHNpbG9uKSB7XG4gICAgICAgIHZhciBkZXRDMFggPSBDWzBdWzBdICogWFsxXSAtIENbMV1bMF0gKiBYWzBdLFxuICAgICAgICAgICAgZGV0WEMxID0gWFswXSAqIENbMV1bMV0gLSBYWzFdICogQ1swXVsxXTtcbiAgICAgICAgYWxwaGExID0gZGV0WEMxIC8gZGV0QzBDMTtcbiAgICAgICAgYWxwaGEyID0gZGV0QzBYIC8gZGV0QzBDMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjMCA9IENbMF1bMF0gKyBDWzBdWzFdLFxuICAgICAgICAgICAgYzEgPSBDWzFdWzBdICsgQ1sxXVsxXTtcbiAgICAgICAgYWxwaGExID0gYWxwaGEyID0gYWJzKGMwKSA+IGVwc2lsb24gPyBYWzBdIC8gYzAgOiBhYnMoYzEpID4gZXBzaWxvbiA/IFhbMV0gLyBjMSA6IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdMZW5ndGggPSBwdDIuZ2V0RGlzdGFuY2UocHQxKSxcbiAgICAgICAgICBlcHMgPSBlcHNpbG9uICogc2VnTGVuZ3RoLFxuICAgICAgICAgIGhhbmRsZTEsXG4gICAgICAgICAgaGFuZGxlMjtcblxuICAgICAgaWYgKGFscGhhMSA8IGVwcyB8fCBhbHBoYTIgPCBlcHMpIHtcbiAgICAgICAgYWxwaGExID0gYWxwaGEyID0gc2VnTGVuZ3RoIC8gMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsaW5lID0gcHQyLnN1YnRyYWN0KHB0MSk7XG4gICAgICAgIGhhbmRsZTEgPSB0YW4xLm5vcm1hbGl6ZShhbHBoYTEpO1xuICAgICAgICBoYW5kbGUyID0gdGFuMi5ub3JtYWxpemUoYWxwaGEyKTtcblxuICAgICAgICBpZiAoaGFuZGxlMS5kb3QobGluZSkgLSBoYW5kbGUyLmRvdChsaW5lKSA+IHNlZ0xlbmd0aCAqIHNlZ0xlbmd0aCkge1xuICAgICAgICAgIGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG4gICAgICAgICAgaGFuZGxlMSA9IGhhbmRsZTIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbcHQxLCBwdDEuYWRkKGhhbmRsZTEgfHwgdGFuMS5ub3JtYWxpemUoYWxwaGExKSksIHB0Mi5hZGQoaGFuZGxlMiB8fCB0YW4yLm5vcm1hbGl6ZShhbHBoYTIpKSwgcHQyXTtcbiAgICB9LFxuICAgIHJlcGFyYW1ldGVyaXplOiBmdW5jdGlvbiAoZmlyc3QsIGxhc3QsIHUsIGN1cnZlKSB7XG4gICAgICBmb3IgKHZhciBpID0gZmlyc3Q7IGkgPD0gbGFzdDsgaSsrKSB7XG4gICAgICAgIHVbaSAtIGZpcnN0XSA9IHRoaXMuZmluZFJvb3QoY3VydmUsIHRoaXMucG9pbnRzW2ldLCB1W2kgLSBmaXJzdF0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICh1W2ldIDw9IHVbaSAtIDFdKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZmluZFJvb3Q6IGZ1bmN0aW9uIChjdXJ2ZSwgcG9pbnQsIHUpIHtcbiAgICAgIHZhciBjdXJ2ZTEgPSBbXSxcbiAgICAgICAgICBjdXJ2ZTIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMjsgaSsrKSB7XG4gICAgICAgIGN1cnZlMVtpXSA9IGN1cnZlW2kgKyAxXS5zdWJ0cmFjdChjdXJ2ZVtpXSkubXVsdGlwbHkoMyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDE7IGkrKykge1xuICAgICAgICBjdXJ2ZTJbaV0gPSBjdXJ2ZTFbaSArIDFdLnN1YnRyYWN0KGN1cnZlMVtpXSkubXVsdGlwbHkoMik7XG4gICAgICB9XG5cbiAgICAgIHZhciBwdCA9IHRoaXMuZXZhbHVhdGUoMywgY3VydmUsIHUpLFxuICAgICAgICAgIHB0MSA9IHRoaXMuZXZhbHVhdGUoMiwgY3VydmUxLCB1KSxcbiAgICAgICAgICBwdDIgPSB0aGlzLmV2YWx1YXRlKDEsIGN1cnZlMiwgdSksXG4gICAgICAgICAgZGlmZiA9IHB0LnN1YnRyYWN0KHBvaW50KSxcbiAgICAgICAgICBkZiA9IHB0MS5kb3QocHQxKSArIGRpZmYuZG90KHB0Mik7XG4gICAgICByZXR1cm4gTnVtZXJpY2FsLmlzTWFjaGluZVplcm8oZGYpID8gdSA6IHUgLSBkaWZmLmRvdChwdDEpIC8gZGY7XG4gICAgfSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24gKGRlZ3JlZSwgY3VydmUsIHQpIHtcbiAgICAgIHZhciB0bXAgPSBjdXJ2ZS5zbGljZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBkZWdyZWUgLSBpOyBqKyspIHtcbiAgICAgICAgICB0bXBbal0gPSB0bXBbal0ubXVsdGlwbHkoMSAtIHQpLmFkZCh0bXBbaiArIDFdLm11bHRpcGx5KHQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG1wWzBdO1xuICAgIH0sXG4gICAgY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemU6IGZ1bmN0aW9uIChmaXJzdCwgbGFzdCkge1xuICAgICAgdmFyIHUgPSBbMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdDsgaSsrKSB7XG4gICAgICAgIHVbaSAtIGZpcnN0XSA9IHVbaSAtIGZpcnN0IC0gMV0gKyB0aGlzLnBvaW50c1tpXS5nZXREaXN0YW5jZSh0aGlzLnBvaW50c1tpIC0gMV0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbSA9IGxhc3QgLSBmaXJzdDsgaSA8PSBtOyBpKyspIHtcbiAgICAgICAgdVtpXSAvPSB1W21dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdTtcbiAgICB9LFxuICAgIGZpbmRNYXhFcnJvcjogZnVuY3Rpb24gKGZpcnN0LCBsYXN0LCBjdXJ2ZSwgdSkge1xuICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcigobGFzdCAtIGZpcnN0ICsgMSkgLyAyKSxcbiAgICAgICAgICBtYXhEaXN0ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICB2YXIgUCA9IHRoaXMuZXZhbHVhdGUoMywgY3VydmUsIHVbaSAtIGZpcnN0XSk7XG4gICAgICAgIHZhciB2ID0gUC5zdWJ0cmFjdCh0aGlzLnBvaW50c1tpXSk7XG4gICAgICAgIHZhciBkaXN0ID0gdi54ICogdi54ICsgdi55ICogdi55O1xuXG4gICAgICAgIGlmIChkaXN0ID49IG1heERpc3QpIHtcbiAgICAgICAgICBtYXhEaXN0ID0gZGlzdDtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IG1heERpc3QsXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICB2YXIgVGV4dEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnVGV4dEl0ZW0nLFxuICAgIF9hcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICBjb250ZW50OiBudWxsXG4gICAgfSxcbiAgICBfYm91bmRzT3B0aW9uczoge1xuICAgICAgc3Ryb2tlOiBmYWxzZSxcbiAgICAgIGhhbmRsZTogZmFsc2VcbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFRleHRJdGVtKGFyZykge1xuICAgICAgdGhpcy5fY29udGVudCA9ICcnO1xuICAgICAgdGhpcy5fbGluZXMgPSBbXTtcbiAgICAgIHZhciBoYXNQcm9wcyA9IGFyZyAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKSAmJiBhcmcueCA9PT0gdW5kZWZpbmVkICYmIGFyZy55ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuX2luaXRpYWxpemUoaGFzUHJvcHMgJiYgYXJnLCAhaGFzUHJvcHMgJiYgUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIF9lcXVhbHM6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudCA9PT0gaXRlbS5fY29udGVudDtcbiAgICB9LFxuICAgIGNvcHlDb250ZW50OiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICB0aGlzLnNldENvbnRlbnQoc291cmNlLl9jb250ZW50KTtcbiAgICB9LFxuICAgIGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH0sXG4gICAgc2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQgPSAnJyArIGNvbnRlbnQ7XG4gICAgICB0aGlzLl9saW5lcyA9IHRoaXMuX2NvbnRlbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL21nKTtcblxuICAgICAgdGhpcy5fY2hhbmdlZCg1MjEpO1xuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9jb250ZW50O1xuICAgIH0sXG4gICAgZ2V0Q2hhcmFjdGVyU3R5bGU6ICcjZ2V0U3R5bGUnLFxuICAgIHNldENoYXJhY3RlclN0eWxlOiAnI3NldFN0eWxlJyxcbiAgICBnZXRQYXJhZ3JhcGhTdHlsZTogJyNnZXRTdHlsZScsXG4gICAgc2V0UGFyYWdyYXBoU3R5bGU6ICcjc2V0U3R5bGUnXG4gIH0pO1xuICB2YXIgUG9pbnRUZXh0ID0gVGV4dEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdQb2ludFRleHQnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50VGV4dCgpIHtcbiAgICAgIFRleHRJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cbiAgICAgIHJldHVybiBuZXcgTGlua2VkUG9pbnQocG9pbnQueCwgcG9pbnQueSwgdGhpcywgJ3NldFBvaW50Jyk7XG4gICAgfSxcbiAgICBzZXRQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgdGhpcy50cmFuc2xhdGUocG9pbnQuc3VidHJhY3QodGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCkpKTtcbiAgICB9LFxuICAgIF9kcmF3OiBmdW5jdGlvbiAoY3R4LCBwYXJhbSwgdmlld01hdHJpeCkge1xuICAgICAgaWYgKCF0aGlzLl9jb250ZW50KSByZXR1cm47XG5cbiAgICAgIHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblxuICAgICAgdmFyIGxpbmVzID0gdGhpcy5fbGluZXMsXG4gICAgICAgICAgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuICAgICAgICAgIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpLFxuICAgICAgICAgIGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG4gICAgICAgICAgc2hhZG93Q29sb3IgPSBjdHguc2hhZG93Q29sb3I7XG4gICAgICBjdHguZm9udCA9IHN0eWxlLmdldEZvbnRTdHlsZSgpO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHN0eWxlLmdldEp1c3RpZmljYXRpb24oKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3I7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKGhhc0ZpbGwpIHtcbiAgICAgICAgICBjdHguZmlsbFRleHQobGluZSwgMCwgMCk7XG4gICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1N0cm9rZSkgY3R4LnN0cm9rZVRleHQobGluZSwgMCwgMCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoMCwgbGVhZGluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbiAobWF0cml4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICBsaW5lcyA9IHRoaXMuX2xpbmVzLFxuICAgICAgICAgIG51bUxpbmVzID0gbGluZXMubGVuZ3RoLFxuICAgICAgICAgIGp1c3RpZmljYXRpb24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCksXG4gICAgICAgICAgbGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcbiAgICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0VmlldygpLmdldFRleHRXaWR0aChzdHlsZS5nZXRGb250U3R5bGUoKSwgbGluZXMpLFxuICAgICAgICAgIHggPSAwO1xuICAgICAgaWYgKGp1c3RpZmljYXRpb24gIT09ICdsZWZ0JykgeCAtPSB3aWR0aCAvIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJyA/IDIgOiAxKTtcbiAgICAgIHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh4LCBudW1MaW5lcyA/IC0wLjc1ICogbGVhZGluZyA6IDAsIHdpZHRoLCBudW1MaW5lcyAqIGxlYWRpbmcpO1xuICAgICAgcmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QsIHJlY3QpIDogcmVjdDtcbiAgICB9XG4gIH0pO1xuICB2YXIgQ29sb3IgPSBCYXNlLmV4dGVuZChuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlcyA9IHtcbiAgICAgIGdyYXk6IFsnZ3JheSddLFxuICAgICAgcmdiOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ10sXG4gICAgICBoc2I6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnYnJpZ2h0bmVzcyddLFxuICAgICAgaHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuICAgICAgZ3JhZGllbnQ6IFsnZ3JhZGllbnQnLCAnb3JpZ2luJywgJ2Rlc3RpbmF0aW9uJywgJ2hpZ2hsaWdodCddXG4gICAgfTtcbiAgICB2YXIgY29tcG9uZW50UGFyc2VycyA9IHt9LFxuICAgICAgICBuYW1lZENvbG9ycyA9IHtcbiAgICAgIHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgICAgICBjb2xvckN0eDtcblxuICAgIGZ1bmN0aW9uIGZyb21DU1Moc3RyaW5nKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL14jKFtcXGRhLWZdezJ9KShbXFxkYS1mXXsyfSkoW1xcZGEtZl17Mn0pKFtcXGRhLWZdezJ9KT8kL2kpIHx8IHN0cmluZy5tYXRjaCgvXiMoW1xcZGEtZl0pKFtcXGRhLWZdKShbXFxkYS1mXSkoW1xcZGEtZl0pPyQvaSksXG4gICAgICAgICAgdHlwZSA9ICdyZ2InLFxuICAgICAgICAgIGNvbXBvbmVudHM7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgYW1vdW50ID0gbWF0Y2hbNF0gPyA0IDogMztcbiAgICAgICAgY29tcG9uZW50cyA9IG5ldyBBcnJheShhbW91bnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBtYXRjaFtpICsgMV07XG4gICAgICAgICAgY29tcG9uZW50c1tpXSA9IHBhcnNlSW50KHZhbHVlLmxlbmd0aCA9PSAxID8gdmFsdWUgKyB2YWx1ZSA6IHZhbHVlLCAxNikgLyAyNTU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL14ocmdifGhzbClhP1xcKCguKilcXCkkLykpIHtcbiAgICAgICAgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICBjb21wb25lbnRzID0gbWF0Y2hbMl0udHJpbSgpLnNwbGl0KC9bLFxcc10rL2cpO1xuICAgICAgICB2YXIgaXNIU0wgPSB0eXBlID09PSAnaHNsJztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGNvbXBvbmVudHMubGVuZ3RoLCA0KTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQoY29tcG9uZW50KTtcblxuICAgICAgICAgIGlmIChpc0hTTCkge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgdmFyIHVuaXQgPSBjb21wb25lbnQubWF0Y2goLyhbYS16XSopJC8pWzFdO1xuICAgICAgICAgICAgICB2YWx1ZSAqPSB7XG4gICAgICAgICAgICAgICAgdHVybjogMzYwLFxuICAgICAgICAgICAgICAgIHJhZDogMTgwIC8gTWF0aC5QSSxcbiAgICAgICAgICAgICAgICBncmFkOiAwLjlcbiAgICAgICAgICAgICAgfVt1bml0XSB8fCAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgMykge1xuICAgICAgICAgICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpIDwgMykge1xuICAgICAgICAgICAgdmFsdWUgLz0gLyUkLy50ZXN0KGNvbXBvbmVudCkgPyAxMDAgOiAyNTU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tcG9uZW50c1tpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29sb3IgPSBuYW1lZENvbG9yc1tzdHJpbmddO1xuXG4gICAgICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgICBpZiAod2luZG93KSB7XG4gICAgICAgICAgICBpZiAoIWNvbG9yQ3R4KSB7XG4gICAgICAgICAgICAgIGNvbG9yQ3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcbiAgICAgICAgICAgICAgY29sb3JDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2xvckN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgICAgICBjb2xvckN0eC5maWxsU3R5bGUgPSBzdHJpbmc7XG4gICAgICAgICAgICBjb2xvckN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gY29sb3JDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG4gICAgICAgICAgICBjb2xvciA9IG5hbWVkQ29sb3JzW3N0cmluZ10gPSBbZGF0YVswXSAvIDI1NSwgZGF0YVsxXSAvIDI1NSwgZGF0YVsyXSAvIDI1NV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbG9yID0gWzAsIDAsIDBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudHMgPSBjb2xvci5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3R5cGUsIGNvbXBvbmVudHNdO1xuICAgIH1cblxuICAgIHZhciBoc2JJbmRpY2VzID0gW1swLCAzLCAxXSwgWzIsIDAsIDFdLCBbMSwgMCwgM10sIFsxLCAyLCAwXSwgWzMsIDEsIDBdLCBbMCwgMSwgMl1dO1xuICAgIHZhciBjb252ZXJ0ZXJzID0ge1xuICAgICAgJ3JnYi1oc2InOiBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgICAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgICAgICAgaCA9IGRlbHRhID09PSAwID8gMCA6IChtYXggPT0gciA/IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKSA6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMiA6IChyIC0gZykgLyBkZWx0YSArIDQpICogNjA7XG4gICAgICAgIHJldHVybiBbaCwgbWF4ID09PSAwID8gMCA6IGRlbHRhIC8gbWF4LCBtYXhdO1xuICAgICAgfSxcbiAgICAgICdoc2ItcmdiJzogZnVuY3Rpb24gKGgsIHMsIGIpIHtcbiAgICAgICAgaCA9IChoIC8gNjAgJSA2ICsgNikgJSA2O1xuICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoaCksXG4gICAgICAgICAgICBmID0gaCAtIGksXG4gICAgICAgICAgICBpID0gaHNiSW5kaWNlc1tpXSxcbiAgICAgICAgICAgIHYgPSBbYiwgYiAqICgxIC0gcyksIGIgKiAoMSAtIHMgKiBmKSwgYiAqICgxIC0gcyAqICgxIC0gZikpXTtcbiAgICAgICAgcmV0dXJuIFt2W2lbMF1dLCB2W2lbMV1dLCB2W2lbMl1dXTtcbiAgICAgIH0sXG4gICAgICAncmdiLWhzbCc6IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICAgICAgICBhY2hyb21hdGljID0gZGVsdGEgPT09IDAsXG4gICAgICAgICAgICBoID0gYWNocm9tYXRpYyA/IDAgOiAobWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMCkgOiBtYXggPT0gZyA/IChiIC0gcikgLyBkZWx0YSArIDIgOiAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwLFxuICAgICAgICAgICAgbCA9IChtYXggKyBtaW4pIC8gMixcbiAgICAgICAgICAgIHMgPSBhY2hyb21hdGljID8gMCA6IGwgPCAwLjUgPyBkZWx0YSAvIChtYXggKyBtaW4pIDogZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG4gICAgICAgIHJldHVybiBbaCwgcywgbF07XG4gICAgICB9LFxuICAgICAgJ2hzbC1yZ2InOiBmdW5jdGlvbiAoaCwgcywgbCkge1xuICAgICAgICBoID0gKGggLyAzNjAgJSAxICsgMSkgJSAxO1xuICAgICAgICBpZiAocyA9PT0gMCkgcmV0dXJuIFtsLCBsLCBsXTtcbiAgICAgICAgdmFyIHQzcyA9IFtoICsgMSAvIDMsIGgsIGggLSAxIC8gM10sXG4gICAgICAgICAgICB0MiA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgICAgICB0MSA9IDIgKiBsIC0gdDIsXG4gICAgICAgICAgICBjID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB2YXIgdDMgPSB0M3NbaV07XG4gICAgICAgICAgaWYgKHQzIDwgMCkgdDMgKz0gMTtcbiAgICAgICAgICBpZiAodDMgPiAxKSB0MyAtPSAxO1xuICAgICAgICAgIGNbaV0gPSA2ICogdDMgPCAxID8gdDEgKyAodDIgLSB0MSkgKiA2ICogdDMgOiAyICogdDMgPCAxID8gdDIgOiAzICogdDMgPCAyID8gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2IDogdDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0sXG4gICAgICAncmdiLWdyYXknOiBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgICByZXR1cm4gW3IgKiAwLjI5ODkgKyBnICogMC41ODcgKyBiICogMC4xMTRdO1xuICAgICAgfSxcbiAgICAgICdncmF5LXJnYic6IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHJldHVybiBbZywgZywgZ107XG4gICAgICB9LFxuICAgICAgJ2dyYXktaHNiJzogZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgcmV0dXJuIFswLCAwLCBnXTtcbiAgICAgIH0sXG4gICAgICAnZ3JheS1oc2wnOiBmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gWzAsIDAsIGddO1xuICAgICAgfSxcbiAgICAgICdncmFkaWVudC1yZ2InOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG4gICAgICAncmdiLWdyYWRpZW50JzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZS5lYWNoKHR5cGVzLCBmdW5jdGlvbiAocHJvcGVydGllcywgdHlwZSkge1xuICAgICAgY29tcG9uZW50UGFyc2Vyc1t0eXBlXSA9IFtdO1xuICAgICAgQmFzZS5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICAgICAgICB2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcbiAgICAgICAgICAgIGhhc092ZXJsYXAgPSAvXihodWV8c2F0dXJhdGlvbikkLy50ZXN0KG5hbWUpLFxuICAgICAgICAgICAgcGFyc2VyID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXVtpbmRleF0gPSB0eXBlID09PSAnZ3JhZGllbnQnID8gbmFtZSA9PT0gJ2dyYWRpZW50JyA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY29tcG9uZW50c1swXTtcbiAgICAgICAgICB2YWx1ZSA9IEdyYWRpZW50LnJlYWQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IGFyZ3VtZW50cywgMCwge1xuICAgICAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIGN1cnJlbnQuX3JlbW92ZU93bmVyKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB2YWx1ZS5fYWRkT3duZXIodGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwge1xuICAgICAgICAgICAgcmVhZE51bGw6IG5hbWUgPT09ICdoaWdobGlnaHQnLFxuICAgICAgICAgICAgY2xvbmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IGlzTmFOKHZhbHVlKSA/IDAgOiArdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlIHx8IGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpID8gdGhpcy5fY29tcG9uZW50c1tpbmRleF0gOiB0aGlzLl9jb252ZXJ0KHR5cGUpW2luZGV4XTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fdHlwZSAhPT0gdHlwZSAmJiAhKGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpKSkge1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlKTtcblxuICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIHtcbiAgICAgIF9jbGFzczogJ0NvbG9yJyxcbiAgICAgIF9yZWFkSW5kZXg6IHRydWUsXG4gICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBDb2xvcihhcmcpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICByZWFkaW5nID0gdGhpcy5fX3JlYWQsXG4gICAgICAgICAgICByZWFkID0gMCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBjb21wb25lbnRzLFxuICAgICAgICAgICAgYWxwaGEsXG4gICAgICAgICAgICB2YWx1ZXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgIGFyZ3MgPSBhcmc7XG4gICAgICAgICAgYXJnID0gYXJnc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdUeXBlID0gYXJnICE9IG51bGwgJiYgdHlwZW9mIGFyZztcblxuICAgICAgICBpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgJiYgYXJnIGluIHR5cGVzKSB7XG4gICAgICAgICAgdHlwZSA9IGFyZztcbiAgICAgICAgICBhcmcgPSBhcmdzWzFdO1xuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgY29tcG9uZW50cyA9IGFyZztcbiAgICAgICAgICAgIGFscGhhID0gYXJnc1syXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHJlYWQgPSAxO1xuICAgICAgICAgICAgYXJncyA9IEJhc2Uuc2xpY2UoYXJncywgMSk7XG4gICAgICAgICAgICBhcmdUeXBlID0gdHlwZW9mIGFyZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbXBvbmVudHMpIHtcbiAgICAgICAgICB2YWx1ZXMgPSBhcmdUeXBlID09PSAnbnVtYmVyJyA/IGFyZ3MgOiBhcmdUeXBlID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoICE9IG51bGwgPyBhcmcgOiBudWxsO1xuXG4gICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB0eXBlID0gdmFsdWVzLmxlbmd0aCA+PSAzID8gJ3JnYicgOiAnZ3JheSc7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdHlwZXNbdHlwZV0ubGVuZ3RoO1xuICAgICAgICAgICAgYWxwaGEgPSB2YWx1ZXNbbGVuZ3RoXTtcblxuICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgICAgICAgcmVhZCArPSB2YWx1ZXMgPT09IGFyZ3VtZW50cyA/IGxlbmd0aCArIChhbHBoYSAhPSBudWxsID8gMSA6IDApIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiBsZW5ndGgpIHZhbHVlcyA9IEJhc2Uuc2xpY2UodmFsdWVzLCAwLCBsZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZWQgPSBmcm9tQ1NTKGFyZyk7XG4gICAgICAgICAgICB0eXBlID0gY29udmVydGVkWzBdO1xuICAgICAgICAgICAgY29tcG9uZW50cyA9IGNvbnZlcnRlZFsxXTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgIGFscGhhID0gY29tcG9uZW50c1szXTtcbiAgICAgICAgICAgICAgY29tcG9uZW50cy5sZW5ndGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuICAgICAgICAgICAgICB0eXBlID0gYXJnLl90eXBlO1xuICAgICAgICAgICAgICBjb21wb25lbnRzID0gYXJnLl9jb21wb25lbnRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgIGFscGhhID0gYXJnLl9hbHBoYTtcblxuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAocG9pbnQpIGNvbXBvbmVudHNbaV0gPSBwb2ludC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcuY29uc3RydWN0b3IgPT09IEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgIHR5cGUgPSAnZ3JhZGllbnQnO1xuICAgICAgICAgICAgICB2YWx1ZXMgPSBhcmdzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZSA9ICdodWUnIGluIGFyZyA/ICdsaWdodG5lc3MnIGluIGFyZyA/ICdoc2wnIDogJ2hzYicgOiAnZ3JhZGllbnQnIGluIGFyZyB8fCAnc3RvcHMnIGluIGFyZyB8fCAncmFkaWFsJyBpbiBhcmcgPyAnZ3JhZGllbnQnIDogJ2dyYXknIGluIGFyZyA/ICdncmF5JyA6ICdyZ2InO1xuICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdLFxuICAgICAgICAgICAgICAgICAgcGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV07XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFyZ1twcm9wZXJ0aWVzW2ldXTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFpICYmIHR5cGUgPT09ICdncmFkaWVudCcgJiYgJ3N0b3BzJyBpbiBhcmcpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdG9wczogYXJnLnN0b3BzLFxuICAgICAgICAgICAgICAgICAgICByYWRpYWw6IGFyZy5yYWRpYWxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSBjb21wb25lbnRzW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhbHBoYSA9IGFyZy5hbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVhZGluZyAmJiB0eXBlKSByZWFkID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlIHx8ICdyZ2InO1xuXG4gICAgICAgIGlmICghY29tcG9uZW50cykge1xuICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG4gICAgICAgICAgdmFyIHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3RoaXMuX3R5cGVdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2Vyc1tpXS5jYWxsKHRoaXMsIHZhbHVlcyAmJiB2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3RoaXMuX3R5cGVdO1xuICAgICAgICB0aGlzLl9hbHBoYSA9IGFscGhhO1xuICAgICAgICBpZiAocmVhZGluZykgdGhpcy5fX3JlYWQgPSByZWFkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBzZXQ6ICcjaW5pdGlhbGl6ZScsXG4gICAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuZ2V0Q29tcG9uZW50cygpO1xuICAgICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUoL14oZ3JheXxyZ2IpJC8udGVzdCh0aGlzLl90eXBlKSA/IGNvbXBvbmVudHMgOiBbdGhpcy5fdHlwZV0uY29uY2F0KGNvbXBvbmVudHMpLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcbiAgICAgIH0sXG4gICAgICBfY2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYW52YXNTdHlsZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX293bmVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3NldHRlcikge1xuICAgICAgICAgICAgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb3duZXIuX2NoYW5nZWQoMTI5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY29udmVydDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGUgPyB0aGlzLl9jb21wb25lbnRzLnNsaWNlKCkgOiAoY29udmVydGVyID0gY29udmVydGVyc1t0aGlzLl90eXBlICsgJy0nICsgdHlwZV0pID8gY29udmVydGVyLmFwcGx5KHRoaXMsIHRoaXMuX2NvbXBvbmVudHMpIDogY29udmVydGVyc1sncmdiLScgKyB0eXBlXS5hcHBseSh0aGlzLCBjb252ZXJ0ZXJzW3RoaXMuX3R5cGUgKyAnLXJnYiddLmFwcGx5KHRoaXMsIHRoaXMuX2NvbXBvbmVudHMpKTtcbiAgICAgIH0sXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKHR5cGUsIHRoaXMuX2NvbnZlcnQodHlwZSksIHRoaXMuX2FscGhhKTtcbiAgICAgIH0sXG4gICAgICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgICAgfSxcbiAgICAgIHNldFR5cGU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgfSxcbiAgICAgIGdldENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLnNsaWNlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FscGhhICE9IG51bGwpIGNvbXBvbmVudHMucHVzaCh0aGlzLl9hbHBoYSk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgICAgfSxcbiAgICAgIGdldEFscGhhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsID8gdGhpcy5fYWxwaGEgOiAxO1xuICAgICAgfSxcbiAgICAgIHNldEFscGhhOiBmdW5jdGlvbiAoYWxwaGEpIHtcbiAgICAgICAgdGhpcy5fYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gbnVsbCA6IE1hdGgubWluKE1hdGgubWF4KGFscGhhLCAwKSwgMSk7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgfSxcbiAgICAgIGhhc0FscGhhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGVxdWFsczogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHZhciBjb2wgPSBCYXNlLmlzUGxhaW5WYWx1ZShjb2xvciwgdHJ1ZSkgPyBDb2xvci5yZWFkKGFyZ3VtZW50cykgOiBjb2xvcjtcbiAgICAgICAgcmV0dXJuIGNvbCA9PT0gdGhpcyB8fCBjb2wgJiYgdGhpcy5fY2xhc3MgPT09IGNvbC5fY2xhc3MgJiYgdGhpcy5fdHlwZSA9PT0gY29sLl90eXBlICYmIHRoaXMuZ2V0QWxwaGEoKSA9PT0gY29sLmdldEFscGhhKCkgJiYgQmFzZS5lcXVhbHModGhpcy5fY29tcG9uZW50cywgY29sLl9jb21wb25lbnRzKSB8fCBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3Byb3BlcnRpZXMsXG4gICAgICAgICAgICBwYXJ0cyA9IFtdLFxuICAgICAgICAgICAgaXNHcmFkaWVudCA9IHRoaXMuX3R5cGUgPT09ICdncmFkaWVudCcsXG4gICAgICAgICAgICBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9jb21wb25lbnRzW2ldO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSBwYXJ0cy5wdXNoKHByb3BlcnRpZXNbaV0gKyAnOiAnICsgKGlzR3JhZGllbnQgPyB2YWx1ZSA6IGYubnVtYmVyKHZhbHVlKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2FscGhhICE9IG51bGwpIHBhcnRzLnB1c2goJ2FscGhhOiAnICsgZi5udW1iZXIodGhpcy5fYWxwaGEpKTtcbiAgICAgICAgcmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9JztcbiAgICAgIH0sXG4gICAgICB0b0NTUzogZnVuY3Rpb24gKGhleCkge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQoJ3JnYicpLFxuICAgICAgICAgICAgYWxwaGEgPSBoZXggfHwgdGhpcy5fYWxwaGEgPT0gbnVsbCA/IDEgOiB0aGlzLl9hbHBoYTtcblxuICAgICAgICBmdW5jdGlvbiBjb252ZXJ0KHZhbCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh2YWwgPCAwID8gMCA6IHZhbCA+IDEgPyAxIDogdmFsKSAqIDI1NSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnRzID0gW2NvbnZlcnQoY29tcG9uZW50c1swXSksIGNvbnZlcnQoY29tcG9uZW50c1sxXSksIGNvbnZlcnQoY29tcG9uZW50c1syXSldO1xuICAgICAgICBpZiAoYWxwaGEgPCAxKSBjb21wb25lbnRzLnB1c2goYWxwaGEgPCAwID8gMCA6IGFscGhhKTtcbiAgICAgICAgcmV0dXJuIGhleCA/ICcjJyArICgoMSA8PCAyNCkgKyAoY29tcG9uZW50c1swXSA8PCAxNikgKyAoY29tcG9uZW50c1sxXSA8PCA4KSArIGNvbXBvbmVudHNbMl0pLnRvU3RyaW5nKDE2KS5zbGljZSgxKSA6IChjb21wb25lbnRzLmxlbmd0aCA9PSA0ID8gJ3JnYmEoJyA6ICdyZ2IoJykgKyBjb21wb25lbnRzLmpvaW4oJywnKSArICcpJztcbiAgICAgIH0sXG4gICAgICB0b0NhbnZhc1N0eWxlOiBmdW5jdGlvbiAoY3R4LCBtYXRyaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhc1N0eWxlKSByZXR1cm4gdGhpcy5fY2FudmFzU3R5bGU7XG4gICAgICAgIGlmICh0aGlzLl90eXBlICE9PSAnZ3JhZGllbnQnKSByZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSB0aGlzLnRvQ1NTKCk7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cyxcbiAgICAgICAgICAgIGdyYWRpZW50ID0gY29tcG9uZW50c1swXSxcbiAgICAgICAgICAgIHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzLFxuICAgICAgICAgICAgb3JpZ2luID0gY29tcG9uZW50c1sxXSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gY29tcG9uZW50c1syXSxcbiAgICAgICAgICAgIGhpZ2hsaWdodCA9IGNvbXBvbmVudHNbM10sXG4gICAgICAgICAgICBpbnZlcnNlID0gbWF0cml4ICYmIG1hdHJpeC5pbnZlcnRlZCgpLFxuICAgICAgICAgICAgY2FudmFzR3JhZGllbnQ7XG5cbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICBvcmlnaW4gPSBpbnZlcnNlLl90cmFuc2Zvcm1Qb2ludChvcmlnaW4pO1xuICAgICAgICAgIGRlc3RpbmF0aW9uID0gaW52ZXJzZS5fdHJhbnNmb3JtUG9pbnQoZGVzdGluYXRpb24pO1xuICAgICAgICAgIGlmIChoaWdobGlnaHQpIGhpZ2hsaWdodCA9IGludmVyc2UuX3RyYW5zZm9ybVBvaW50KGhpZ2hsaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JhZGllbnQuX3JhZGlhbCkge1xuICAgICAgICAgIHZhciByYWRpdXMgPSBkZXN0aW5hdGlvbi5nZXREaXN0YW5jZShvcmlnaW4pO1xuXG4gICAgICAgICAgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgICAgICAgdmFyIHZlY3RvciA9IGhpZ2hsaWdodC5zdWJ0cmFjdChvcmlnaW4pO1xuICAgICAgICAgICAgaWYgKHZlY3Rvci5nZXRMZW5ndGgoKSA+IHJhZGl1cykgaGlnaGxpZ2h0ID0gb3JpZ2luLmFkZCh2ZWN0b3Iubm9ybWFsaXplKHJhZGl1cyAtIDAuMSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydCA9IGhpZ2hsaWdodCB8fCBvcmlnaW47XG4gICAgICAgICAgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoc3RhcnQueCwgc3RhcnQueSwgMCwgb3JpZ2luLngsIG9yaWdpbi55LCByYWRpdXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KG9yaWdpbi54LCBvcmlnaW4ueSwgZGVzdGluYXRpb24ueCwgZGVzdGluYXRpb24ueSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV0sXG4gICAgICAgICAgICAgIG9mZnNldCA9IHN0b3AuX29mZnNldDtcbiAgICAgICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3Aob2Zmc2V0ID09IG51bGwgPyBpIC8gKGwgLSAxKSA6IG9mZnNldCwgc3RvcC5fY29sb3IudG9DYW52YXNTdHlsZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IGNhbnZhc0dyYWRpZW50O1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuICAgICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cztcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG5cbiAgICAgICAgICAgIG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50LCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdGF0aWNzOiB7XG4gICAgICAgIF90eXBlczogdHlwZXMsXG4gICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHJhbmRvbSgpLCByYW5kb20oKSwgcmFuZG9tKCkpO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0T3duZXI6IGZ1bmN0aW9uIChjb2xvciwgb3duZXIsIHNldHRlcikge1xuICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgaWYgKGNvbG9yLl9vd25lciAmJiBvd25lciAmJiBjb2xvci5fb3duZXIgIT09IG93bmVyKSB7XG4gICAgICAgICAgICAgIGNvbG9yID0gY29sb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjb2xvci5fb3duZXIgXiAhb3duZXIpIHtcbiAgICAgICAgICAgICAgY29sb3IuX293bmVyID0gb3duZXIgfHwgbnVsbDtcbiAgICAgICAgICAgICAgY29sb3IuX3NldHRlciA9IHNldHRlciB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KCksIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wZXJhdG9ycyA9IHtcbiAgICAgIGFkZDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgfSxcbiAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9LFxuICAgICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICogYjtcbiAgICAgIH0sXG4gICAgICBkaXZpZGU6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC8gYjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCYXNlLmVhY2gob3BlcmF0b3JzLCBmdW5jdGlvbiAob3BlcmF0b3IsIG5hbWUpIHtcbiAgICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgY29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuICAgICAgICAgICAgY29tcG9uZW50czEgPSB0aGlzLl9jb21wb25lbnRzLFxuICAgICAgICAgICAgY29tcG9uZW50czIgPSBjb2xvci5fY29udmVydCh0eXBlKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMxLmxlbmd0aDsgaSA8IGw7IGkrKykgY29tcG9uZW50czJbaV0gPSBvcGVyYXRvcihjb21wb25lbnRzMVtpXSwgY29tcG9uZW50czJbaV0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IodHlwZSwgY29tcG9uZW50czIsIHRoaXMuX2FscGhhICE9IG51bGwgPyBvcGVyYXRvcih0aGlzLl9hbHBoYSwgY29sb3IuZ2V0QWxwaGEoKSkgOiBudWxsKTtcbiAgICAgIH07XG4gICAgfSwge30pO1xuICB9KCkpO1xuICB2YXIgR3JhZGllbnQgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnR3JhZGllbnQnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50KHN0b3BzLCByYWRpYWwpIHtcbiAgICAgIHRoaXMuX2lkID0gVUlELmdldCgpO1xuXG4gICAgICBpZiAoc3RvcHMgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHN0b3BzKSkge1xuICAgICAgICB0aGlzLnNldChzdG9wcyk7XG4gICAgICAgIHN0b3BzID0gcmFkaWFsID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0b3BzID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZXRTdG9wcyhzdG9wcyB8fCBbJ3doaXRlJywgJ2JsYWNrJ10pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmFkaWFsID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZXRSYWRpYWwodHlwZW9mIHJhZGlhbCA9PT0gJ3N0cmluZycgJiYgcmFkaWFsID09PSAncmFkaWFsJyB8fCByYWRpYWwgfHwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcbiAgICAgIHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fc3RvcHMsIHRoaXMuX3JhZGlhbF0sIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9vd25lcnMgJiYgdGhpcy5fb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLl9vd25lcnNbaV0uX2NoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9hZGRPd25lcjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICBpZiAoIXRoaXMuX293bmVycykgdGhpcy5fb3duZXJzID0gW107XG5cbiAgICAgIHRoaXMuX293bmVycy5wdXNoKGNvbG9yKTtcbiAgICB9LFxuICAgIF9yZW1vdmVPd25lcjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9vd25lcnMgPyB0aGlzLl9vd25lcnMuaW5kZXhPZihjb2xvcikgOiAtMTtcblxuICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIHRoaXMuX293bmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgIGlmICghdGhpcy5fb3duZXJzLmxlbmd0aCkgdGhpcy5fb3duZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdG9wcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzdG9wc1tpXSA9IHRoaXMuX3N0b3BzW2ldLmNsb25lKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgR3JhZGllbnQoc3RvcHMsIHRoaXMuX3JhZGlhbCk7XG4gICAgfSxcbiAgICBnZXRTdG9wczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3BzO1xuICAgIH0sXG4gICAgc2V0U3RvcHM6IGZ1bmN0aW9uIChzdG9wcykge1xuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHcmFkaWVudCBzdG9wIGxpc3QgbmVlZHMgdG8gY29udGFpbiBhdCBsZWFzdCB0d28gc3RvcHMuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfc3RvcHMgPSB0aGlzLl9zdG9wcztcblxuICAgICAgaWYgKF9zdG9wcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIF9zdG9wc1tpXS5fb3duZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIF9zdG9wcyA9IHRoaXMuX3N0b3BzID0gR3JhZGllbnRTdG9wLnJlYWRMaXN0KHN0b3BzLCAwLCB7XG4gICAgICAgIGNsb25lOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSBfc3RvcHNbaV0uX293bmVyID0gdGhpcztcblxuICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH0sXG4gICAgZ2V0UmFkaWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmFkaWFsO1xuICAgIH0sXG4gICAgc2V0UmFkaWFsOiBmdW5jdGlvbiAocmFkaWFsKSB7XG4gICAgICB0aGlzLl9yYWRpYWwgPSByYWRpYWw7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKGdyYWRpZW50KSB7XG4gICAgICBpZiAoZ3JhZGllbnQgPT09IHRoaXMpIHJldHVybiB0cnVlO1xuXG4gICAgICBpZiAoZ3JhZGllbnQgJiYgdGhpcy5fY2xhc3MgPT09IGdyYWRpZW50Ll9jbGFzcykge1xuICAgICAgICB2YXIgc3RvcHMxID0gdGhpcy5fc3RvcHMsXG4gICAgICAgICAgICBzdG9wczIgPSBncmFkaWVudC5fc3RvcHMsXG4gICAgICAgICAgICBsZW5ndGggPSBzdG9wczEubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGggPT09IHN0b3BzMi5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXN0b3BzMVtpXS5lcXVhbHMoc3RvcHMyW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgR3JhZGllbnRTdG9wID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0dyYWRpZW50U3RvcCcsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnRTdG9wKGFyZzAsIGFyZzEpIHtcbiAgICAgIHZhciBjb2xvciA9IGFyZzAsXG4gICAgICAgICAgb2Zmc2V0ID0gYXJnMTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiBhcmcxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkgJiYgdHlwZW9mIGFyZzBbMF0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29sb3IgPSBhcmcwWzBdO1xuICAgICAgICAgIG9mZnNldCA9IGFyZzBbMV07XG4gICAgICAgIH0gZWxzZSBpZiAoJ2NvbG9yJyBpbiBhcmcwIHx8ICdvZmZzZXQnIGluIGFyZzAgfHwgJ3JhbXBQb2ludCcgaW4gYXJnMCkge1xuICAgICAgICAgIGNvbG9yID0gYXJnMC5jb2xvcjtcbiAgICAgICAgICBvZmZzZXQgPSBhcmcwLm9mZnNldCB8fCBhcmcwLnJhbXBQb2ludCB8fCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0Q29sb3IoY29sb3IpO1xuICAgICAgdGhpcy5zZXRPZmZzZXQob2Zmc2V0KTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEdyYWRpZW50U3RvcCh0aGlzLl9jb2xvci5jbG9uZSgpLCB0aGlzLl9vZmZzZXQpO1xuICAgIH0sXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcbiAgICAgIHZhciBjb2xvciA9IHRoaXMuX2NvbG9yLFxuICAgICAgICAgIG9mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHJldHVybiBCYXNlLnNlcmlhbGl6ZShvZmZzZXQgPT0gbnVsbCA/IFtjb2xvcl0gOiBbY29sb3IsIG9mZnNldF0sIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9vd25lcikgdGhpcy5fb3duZXIuX2NoYW5nZWQoMTI5KTtcbiAgICB9LFxuICAgIGdldE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICB9LFxuICAgIHNldE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfSxcbiAgICBnZXRSYW1wUG9pbnQ6ICcjZ2V0T2Zmc2V0JyxcbiAgICBzZXRSYW1wUG9pbnQ6ICcjc2V0T2Zmc2V0JyxcbiAgICBnZXRDb2xvcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgIH0sXG4gICAgc2V0Q29sb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIENvbG9yLl9zZXRPd25lcih0aGlzLl9jb2xvciwgbnVsbCk7XG5cbiAgICAgIHRoaXMuX2NvbG9yID0gQ29sb3IuX3NldE93bmVyKENvbG9yLnJlYWQoYXJndW1lbnRzLCAwKSwgdGhpcywgJ3NldENvbG9yJyk7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgIHJldHVybiBzdG9wID09PSB0aGlzIHx8IHN0b3AgJiYgdGhpcy5fY2xhc3MgPT09IHN0b3AuX2NsYXNzICYmIHRoaXMuX2NvbG9yLmVxdWFscyhzdG9wLl9jb2xvcikgJiYgdGhpcy5fb2Zmc2V0ID09IHN0b3AuX29mZnNldCB8fCBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgU3R5bGUgPSBCYXNlLmV4dGVuZChuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpdGVtRGVmYXVsdHMgPSB7XG4gICAgICBmaWxsQ29sb3I6IG51bGwsXG4gICAgICBmaWxsUnVsZTogJ25vbnplcm8nLFxuICAgICAgc3Ryb2tlQ29sb3I6IG51bGwsXG4gICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgIHN0cm9rZUNhcDogJ2J1dHQnLFxuICAgICAgc3Ryb2tlSm9pbjogJ21pdGVyJyxcbiAgICAgIHN0cm9rZVNjYWxpbmc6IHRydWUsXG4gICAgICBtaXRlckxpbWl0OiAxMCxcbiAgICAgIGRhc2hPZmZzZXQ6IDAsXG4gICAgICBkYXNoQXJyYXk6IFtdLFxuICAgICAgc2hhZG93Q29sb3I6IG51bGwsXG4gICAgICBzaGFkb3dCbHVyOiAwLFxuICAgICAgc2hhZG93T2Zmc2V0OiBuZXcgUG9pbnQoKSxcbiAgICAgIHNlbGVjdGVkQ29sb3I6IG51bGxcbiAgICB9LFxuICAgICAgICBncm91cERlZmF1bHRzID0gQmFzZS5zZXQoe30sIGl0ZW1EZWZhdWx0cywge1xuICAgICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICBmb250U2l6ZTogMTIsXG4gICAgICBsZWFkaW5nOiBudWxsLFxuICAgICAganVzdGlmaWNhdGlvbjogJ2xlZnQnXG4gICAgfSksXG4gICAgICAgIHRleHREZWZhdWx0cyA9IEJhc2Uuc2V0KHt9LCBncm91cERlZmF1bHRzLCB7XG4gICAgICBmaWxsQ29sb3I6IG5ldyBDb2xvcigpXG4gICAgfSksXG4gICAgICAgIGZsYWdzID0ge1xuICAgICAgc3Ryb2tlV2lkdGg6IDE5MyxcbiAgICAgIHN0cm9rZUNhcDogMTkzLFxuICAgICAgc3Ryb2tlSm9pbjogMTkzLFxuICAgICAgc3Ryb2tlU2NhbGluZzogMjAxLFxuICAgICAgbWl0ZXJMaW1pdDogMTkzLFxuICAgICAgZm9udEZhbWlseTogOSxcbiAgICAgIGZvbnRXZWlnaHQ6IDksXG4gICAgICBmb250U2l6ZTogOSxcbiAgICAgIGZvbnQ6IDksXG4gICAgICBsZWFkaW5nOiA5LFxuICAgICAganVzdGlmaWNhdGlvbjogOVxuICAgIH0sXG4gICAgICAgIGl0ZW0gPSB7XG4gICAgICBiZWFuczogdHJ1ZVxuICAgIH0sXG4gICAgICAgIGZpZWxkcyA9IHtcbiAgICAgIF9jbGFzczogJ1N0eWxlJyxcbiAgICAgIGJlYW5zOiB0cnVlLFxuICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gU3R5bGUoc3R5bGUsIF9vd25lciwgX3Byb2plY3QpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX293bmVyID0gX293bmVyO1xuICAgICAgICB0aGlzLl9wcm9qZWN0ID0gX293bmVyICYmIF9vd25lci5fcHJvamVjdCB8fCBfcHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuICAgICAgICB0aGlzLl9kZWZhdWx0cyA9ICFfb3duZXIgfHwgX293bmVyIGluc3RhbmNlb2YgR3JvdXAgPyBncm91cERlZmF1bHRzIDogX293bmVyIGluc3RhbmNlb2YgVGV4dEl0ZW0gPyB0ZXh0RGVmYXVsdHMgOiBpdGVtRGVmYXVsdHM7XG4gICAgICAgIGlmIChzdHlsZSkgdGhpcy5zZXQoc3R5bGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgQmFzZS5lYWNoKGdyb3VwRGVmYXVsdHMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YXIgaXNDb2xvciA9IC9Db2xvciQvLnRlc3Qoa2V5KSxcbiAgICAgICAgICBpc1BvaW50ID0ga2V5ID09PSAnc2hhZG93T2Zmc2V0JyxcbiAgICAgICAgICBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG4gICAgICAgICAgZmxhZyA9IGZsYWdzW2tleV0sXG4gICAgICAgICAgc2V0ID0gJ3NldCcgKyBwYXJ0LFxuICAgICAgICAgIGdldCA9ICdnZXQnICsgcGFydDtcblxuICAgICAgZmllbGRzW3NldF0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG4gICAgICAgICAgICBjaGlsZHJlbiA9IG93bmVyICYmIG93bmVyLl9jaGlsZHJlbixcbiAgICAgICAgICAgIGFwcGx5VG9DaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgIShvd25lciBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCk7XG5cbiAgICAgICAgaWYgKGFwcGx5VG9DaGlsZHJlbikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSBjaGlsZHJlbltpXS5fc3R5bGVbc2V0XSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGtleSA9PT0gJ3NlbGVjdGVkQ29sb3InIHx8ICFhcHBseVRvQ2hpbGRyZW4pICYmIGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuICAgICAgICAgIHZhciBvbGQgPSB0aGlzLl92YWx1ZXNba2V5XTtcblxuICAgICAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNDb2xvcikge1xuICAgICAgICAgICAgICBpZiAob2xkKSB7XG4gICAgICAgICAgICAgICAgQ29sb3IuX3NldE93bmVyKG9sZCwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICBvbGQuX2NhbnZhc1N0eWxlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IENvbG9yLl9zZXRPd25lcih2YWx1ZSwgb3duZXIsIGFwcGx5VG9DaGlsZHJlbiAmJiBzZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAob3duZXIpIG93bmVyLl9jaGFuZ2VkKGZsYWcgfHwgMTI5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpZWxkc1tnZXRdID0gZnVuY3Rpb24gKF9kb250TWVyZ2UpIHtcbiAgICAgICAgdmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG4gICAgICAgICAgICBjaGlsZHJlbiA9IG93bmVyICYmIG93bmVyLl9jaGlsZHJlbixcbiAgICAgICAgICAgIGFwcGx5VG9DaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgIShvd25lciBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCksXG4gICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICBpZiAoYXBwbHlUb0NoaWxkcmVuICYmICFfZG9udE1lcmdlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFZhbHVlID0gY2hpbGRyZW5baV0uX3N0eWxlW2dldF0oKTtcblxuICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjaGlsZFZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZXNba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2RlZmF1bHRzW2tleV07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jbG9uZSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjdG9yID0gaXNDb2xvciA/IENvbG9yIDogaXNQb2ludCA/IFBvaW50IDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKGN0b3IgJiYgISh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gY3RvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZSA9IGN0b3IucmVhZChbdmFsdWVdLCAwLCB7XG4gICAgICAgICAgICAgICAgcmVhZE51bGw6IHRydWUsXG4gICAgICAgICAgICAgICAgY2xvbmU6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIGlzQ29sb3IpIHtcbiAgICAgICAgICB2YWx1ZSA9IENvbG9yLl9zZXRPd25lcih2YWx1ZSwgb3duZXIsIGFwcGx5VG9DaGlsZHJlbiAmJiBzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcblxuICAgICAgaXRlbVtnZXRdID0gZnVuY3Rpb24gKF9kb250TWVyZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlW2dldF0oX2RvbnRNZXJnZSk7XG4gICAgICB9O1xuXG4gICAgICBpdGVtW3NldF0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3R5bGVbc2V0XSh2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIEJhc2UuZWFjaCh7XG4gICAgICBGb250OiAnRm9udEZhbWlseScsXG4gICAgICBXaW5kaW5nUnVsZTogJ0ZpbGxSdWxlJ1xuICAgIH0sIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YXIgZ2V0ID0gJ2dldCcgKyBrZXksXG4gICAgICAgICAgc2V0ID0gJ3NldCcgKyBrZXk7XG4gICAgICBmaWVsZHNbZ2V0XSA9IGl0ZW1bZ2V0XSA9ICcjZ2V0JyArIHZhbHVlO1xuICAgICAgZmllbGRzW3NldF0gPSBpdGVtW3NldF0gPSAnI3NldCcgKyB2YWx1ZTtcbiAgICB9KTtcbiAgICBJdGVtLmluamVjdChpdGVtKTtcbiAgICByZXR1cm4gZmllbGRzO1xuICB9KCksIHtcbiAgICBzZXQ6IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgdmFyIGlzU3R5bGUgPSBzdHlsZSBpbnN0YW5jZW9mIFN0eWxlLFxuICAgICAgICAgIHZhbHVlcyA9IGlzU3R5bGUgPyBzdHlsZS5fdmFsdWVzIDogc3R5bGU7XG5cbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlcykge1xuICAgICAgICAgIGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWUgJiYgaXNTdHlsZSAmJiB2YWx1ZS5jbG9uZSA/IHZhbHVlLmNsb25lKCkgOiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBmdW5jdGlvbiBjb21wYXJlKHN0eWxlMSwgc3R5bGUyLCBzZWNvbmRhcnkpIHtcbiAgICAgICAgdmFyIHZhbHVlczEgPSBzdHlsZTEuX3ZhbHVlcyxcbiAgICAgICAgICAgIHZhbHVlczIgPSBzdHlsZTIuX3ZhbHVlcyxcbiAgICAgICAgICAgIGRlZmF1bHRzMiA9IHN0eWxlMi5fZGVmYXVsdHM7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlczEpIHtcbiAgICAgICAgICB2YXIgdmFsdWUxID0gdmFsdWVzMVtrZXldLFxuICAgICAgICAgICAgICB2YWx1ZTIgPSB2YWx1ZXMyW2tleV07XG4gICAgICAgICAgaWYgKCEoc2Vjb25kYXJ5ICYmIGtleSBpbiB2YWx1ZXMyKSAmJiAhQmFzZS5lcXVhbHModmFsdWUxLCB2YWx1ZTIgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRzMltrZXldIDogdmFsdWUyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZSA9PT0gdGhpcyB8fCBzdHlsZSAmJiB0aGlzLl9jbGFzcyA9PT0gc3R5bGUuX2NsYXNzICYmIGNvbXBhcmUodGhpcywgc3R5bGUpICYmIGNvbXBhcmUoc3R5bGUsIHRoaXMsIHRydWUpIHx8IGZhbHNlO1xuICAgIH0sXG4gICAgX2Rpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb2xvcjtcbiAgICAgIGNvbG9yID0gdGhpcy5nZXRGaWxsQ29sb3IoKTtcbiAgICAgIGlmIChjb2xvcikgY29sb3IuX2NhbnZhc1N0eWxlID0gbnVsbDtcbiAgICAgIGNvbG9yID0gdGhpcy5nZXRTdHJva2VDb2xvcigpO1xuICAgICAgaWYgKGNvbG9yKSBjb2xvci5fY2FudmFzU3R5bGUgPSBudWxsO1xuICAgICAgY29sb3IgPSB0aGlzLmdldFNoYWRvd0NvbG9yKCk7XG4gICAgICBpZiAoY29sb3IpIGNvbG9yLl9jYW52YXNTdHlsZSA9IG51bGw7XG4gICAgfSxcbiAgICBoYXNGaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmdldEZpbGxDb2xvcigpO1xuICAgICAgcmV0dXJuICEhY29sb3IgJiYgY29sb3IuYWxwaGEgPiAwO1xuICAgIH0sXG4gICAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmdldFN0cm9rZUNvbG9yKCk7XG4gICAgICByZXR1cm4gISFjb2xvciAmJiBjb2xvci5hbHBoYSA+IDAgJiYgdGhpcy5nZXRTdHJva2VXaWR0aCgpID4gMDtcbiAgICB9LFxuICAgIGhhc1NoYWRvdzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5nZXRTaGFkb3dDb2xvcigpO1xuICAgICAgcmV0dXJuICEhY29sb3IgJiYgY29sb3IuYWxwaGEgPiAwICYmICh0aGlzLmdldFNoYWRvd0JsdXIoKSA+IDAgfHwgIXRoaXMuZ2V0U2hhZG93T2Zmc2V0KCkuaXNaZXJvKCkpO1xuICAgIH0sXG4gICAgZ2V0VmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3QuX3ZpZXc7XG4gICAgfSxcbiAgICBnZXRGb250U3R5bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICAgIHJldHVybiB0aGlzLmdldEZvbnRXZWlnaHQoKSArICcgJyArIGZvbnRTaXplICsgKC9bYS16XS9pLnRlc3QoZm9udFNpemUgKyAnJykgPyAnICcgOiAncHggJykgKyB0aGlzLmdldEZvbnRGYW1pbHkoKTtcbiAgICB9LFxuICAgIGdldEZvbnQ6ICcjZ2V0Rm9udEZhbWlseScsXG4gICAgc2V0Rm9udDogJyNzZXRGb250RmFtaWx5JyxcbiAgICBnZXRMZWFkaW5nOiBmdW5jdGlvbiBnZXRMZWFkaW5nKCkge1xuICAgICAgdmFyIGxlYWRpbmcgPSBnZXRMZWFkaW5nLmJhc2UuY2FsbCh0aGlzKSxcbiAgICAgICAgICBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICAgIGlmICgvcHR8ZW18JXxweC8udGVzdChmb250U2l6ZSkpIGZvbnRTaXplID0gdGhpcy5nZXRWaWV3KCkuZ2V0UGl4ZWxTaXplKGZvbnRTaXplKTtcbiAgICAgIHJldHVybiBsZWFkaW5nICE9IG51bGwgPyBsZWFkaW5nIDogZm9udFNpemUgKiAxLjI7XG4gICAgfVxuICB9KTtcbiAgdmFyIERvbUVsZW1lbnQgPSBuZXcgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGhhbmRsZVByZWZpeChlbCwgbmFtZSwgc2V0LCB2YWx1ZSkge1xuICAgICAgdmFyIHByZWZpeGVzID0gWycnLCAnd2Via2l0JywgJ21veicsICdNb3onLCAnbXMnLCAnbyddLFxuICAgICAgICAgIHN1ZmZpeCA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV0sXG4gICAgICAgICAgICBrZXkgPSBwcmVmaXggPyBwcmVmaXggKyBzdWZmaXggOiBuYW1lO1xuXG4gICAgICAgIGlmIChrZXkgaW4gZWwpIHtcbiAgICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgICBlbFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbFtrZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFN0eWxlczogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBkb2MgPSBlbCAmJiBlbC5ub2RlVHlwZSAhPT0gOSA/IGVsLm93bmVyRG9jdW1lbnQgOiBlbCxcbiAgICAgICAgICAgIHZpZXcgPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3O1xuICAgICAgICByZXR1cm4gdmlldyAmJiB2aWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcbiAgICAgIH0sXG4gICAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uIChlbCwgdmlld3BvcnQpIHtcbiAgICAgICAgdmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICBib2R5ID0gZG9jLmJvZHksXG4gICAgICAgICAgICBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgIHJlY3Q7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gcmVjdC5sZWZ0IC0gKGh0bWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCksXG4gICAgICAgICAgICB5ID0gcmVjdC50b3AgLSAoaHRtbC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCk7XG5cbiAgICAgICAgaWYgKCF2aWV3cG9ydCkge1xuICAgICAgICAgIHZhciB2aWV3ID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgICAgICAgIHggKz0gdmlldy5wYWdlWE9mZnNldCB8fCBodG1sLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICAgIHkgKz0gdmlldy5wYWdlWU9mZnNldCB8fCBodG1sLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICBnZXRWaWV3cG9ydEJvdW5kczogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgdmlldyA9IGRvYy5kZWZhdWx0VmlldyxcbiAgICAgICAgICAgIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLCB2aWV3LmlubmVyV2lkdGggfHwgaHRtbC5jbGllbnRXaWR0aCwgdmlldy5pbm5lckhlaWdodCB8fCBodG1sLmNsaWVudEhlaWdodCk7XG4gICAgICB9LFxuICAgICAgZ2V0T2Zmc2V0OiBmdW5jdGlvbiAoZWwsIHZpZXdwb3J0KSB7XG4gICAgICAgIHJldHVybiBEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdmlld3BvcnQpLmdldFBvaW50KCk7XG4gICAgICB9LFxuICAgICAgZ2V0U2l6ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkuZ2V0U2l6ZSgpO1xuICAgICAgfSxcbiAgICAgIGlzSW52aXNpYmxlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIERvbUVsZW1lbnQuZ2V0U2l6ZShlbCkuZXF1YWxzKG5ldyBTaXplKDAsIDApKTtcbiAgICAgIH0sXG4gICAgICBpc0luVmlldzogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiAhRG9tRWxlbWVudC5pc0ludmlzaWJsZShlbCkgJiYgRG9tRWxlbWVudC5nZXRWaWV3cG9ydEJvdW5kcyhlbCkuaW50ZXJzZWN0cyhEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkpO1xuICAgICAgfSxcbiAgICAgIGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5jb250YWlucyhlbCk7XG4gICAgICB9LFxuICAgICAgZ2V0UHJlZml4ZWQ6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZWwgJiYgaGFuZGxlUHJlZml4KGVsLCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICBzZXRQcmVmaXhlZDogZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIGhhbmRsZVByZWZpeChlbCwga2V5LCB0cnVlLCBuYW1lW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZVByZWZpeChlbCwgbmFtZSwgdHJ1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuICB2YXIgRG9tRXZlbnQgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoZWwsIGV2ZW50cykge1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG4gICAgICAgICAgICAgIHBhcnRzID0gdHlwZS5zcGxpdCgvW1xccyxdKy9nKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBlbCA9PT0gZG9jdW1lbnQgJiYgKG5hbWUgPT09ICd0b3VjaHN0YXJ0JyB8fCBuYW1lID09PSAndG91Y2htb3ZlJykgPyB7XG4gICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgICB9IDogZmFsc2U7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmMsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWwsIGV2ZW50cykge1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG4gICAgICAgICAgICAgIHBhcnRzID0gdHlwZS5zcGxpdCgvW1xccyxdKy9nKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHBhcnRzW2ldLCBmdW5jLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBwb3MgPSBldmVudC50YXJnZXRUb3VjaGVzID8gZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPyBldmVudC50YXJnZXRUb3VjaGVzWzBdIDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudDtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQocG9zLnBhZ2VYIHx8IHBvcy5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsIHBvcy5wYWdlWSB8fCBwb3MuY2xpZW50WSArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApO1xuICAgIH0sXG4gICAgZ2V0VGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudDtcbiAgICB9LFxuICAgIGdldFJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudG9FbGVtZW50O1xuICAgIH0sXG4gICAgZ2V0T2Zmc2V0OiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCkge1xuICAgICAgcmV0dXJuIERvbUV2ZW50LmdldFBvaW50KGV2ZW50KS5zdWJ0cmFjdChEb21FbGVtZW50LmdldE9mZnNldCh0YXJnZXQgfHwgRG9tRXZlbnQuZ2V0VGFyZ2V0KGV2ZW50KSkpO1xuICAgIH1cbiAgfTtcbiAgRG9tRXZlbnQucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmF0aXZlUmVxdWVzdCA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQod2luZG93LCAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyksXG4gICAgICAgIHJlcXVlc3RlZCA9IGZhbHNlLFxuICAgICAgICBjYWxsYmFja3MgPSBbXSxcbiAgICAgICAgdGltZXI7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVDYWxsYmFja3MoKSB7XG4gICAgICB2YXIgZnVuY3Rpb25zID0gY2FsbGJhY2tzO1xuICAgICAgY2FsbGJhY2tzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZnVuY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykgZnVuY3Rpb25zW2ldKCk7XG5cbiAgICAgIHJlcXVlc3RlZCA9IG5hdGl2ZVJlcXVlc3QgJiYgY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgIGlmIChyZXF1ZXN0ZWQpIG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cbiAgICAgIGlmIChuYXRpdmVSZXF1ZXN0KSB7XG4gICAgICAgIGlmICghcmVxdWVzdGVkKSB7XG4gICAgICAgICAgbmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuICAgICAgICAgIHJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVyKSB7XG4gICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoaGFuZGxlQ2FsbGJhY2tzLCAxMDAwIC8gNjApO1xuICAgICAgfVxuICAgIH07XG4gIH0oKTtcbiAgdmFyIFZpZXcgPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG4gICAgX2NsYXNzOiAnVmlldycsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gVmlldyhwcm9qZWN0LCBlbGVtZW50KSB7XG4gICAgICBmdW5jdGlvbiBnZXRTaXplKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRbbmFtZV0gfHwgcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSksIDEwKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Q2FudmFzU2l6ZSgpIHtcbiAgICAgICAgdmFyIHNpemUgPSBEb21FbGVtZW50LmdldFNpemUoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBzaXplLmlzTmFOKCkgfHwgc2l6ZS5pc1plcm8oKSA/IG5ldyBTaXplKGdldFNpemUoJ3dpZHRoJyksIGdldFNpemUoJ2hlaWdodCcpKSA6IHNpemU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplO1xuXG4gICAgICBpZiAod2luZG93ICYmIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5faWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgaWYgKHRoaXMuX2lkID09IG51bGwpIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuX2lkID0gJ3BhcGVyLXZpZXctJyArIFZpZXcuX2lkKyspO1xuICAgICAgICBEb21FdmVudC5hZGQoZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG4gICAgICAgIHZhciBub25lID0gJ25vbmUnO1xuICAgICAgICBEb21FbGVtZW50LnNldFByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIHtcbiAgICAgICAgICB1c2VyRHJhZzogbm9uZSxcbiAgICAgICAgICB1c2VyU2VsZWN0OiBub25lLFxuICAgICAgICAgIHRvdWNoQ2FsbG91dDogbm9uZSxcbiAgICAgICAgICBjb250ZW50Wm9vbWluZzogbm9uZSxcbiAgICAgICAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAncmVzaXplJykpIHtcbiAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgRG9tRXZlbnQuYWRkKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzID0ge1xuICAgICAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRoYXQuc2V0Vmlld1NpemUoZ2V0Q2FudmFzU2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpemUgPSBnZXRDYW52YXNTaXplKCk7XG5cbiAgICAgICAgaWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdzdGF0cycpICYmIHR5cGVvZiBTdGF0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLl9zdGF0cyA9IG5ldyBTdGF0cygpO1xuICAgICAgICAgIHZhciBzdGF0cyA9IHRoaXMuX3N0YXRzLmRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgIHN0eWxlID0gc3RhdHMuc3R5bGUsXG4gICAgICAgICAgICAgIG9mZnNldCA9IERvbUVsZW1lbnQuZ2V0T2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gb2Zmc2V0LnggKyAncHgnO1xuICAgICAgICAgIHN0eWxlLnRvcCA9IG9mZnNldC55ICsgJ3B4JztcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5ldyBTaXplKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJvamVjdCA9IHByb2plY3Q7XG4gICAgICB0aGlzLl9zY29wZSA9IHByb2plY3QuX3Njb3BlO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICBpZiAoIXRoaXMuX3BpeGVsUmF0aW8pIHRoaXMuX3BpeGVsUmF0aW8gPSB3aW5kb3cgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgICAgdGhpcy5fc2V0RWxlbWVudFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXG4gICAgICB0aGlzLl92aWV3U2l6ZSA9IHNpemU7XG5cbiAgICAgIFZpZXcuX3ZpZXdzLnB1c2godGhpcyk7XG5cbiAgICAgIFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF0gPSB0aGlzO1xuICAgICAgKHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSkuX293bmVyID0gdGhpcztcbiAgICAgIGlmICghVmlldy5fZm9jdXNlZCkgVmlldy5fZm9jdXNlZCA9IHRoaXM7XG4gICAgICB0aGlzLl9mcmFtZUl0ZW1zID0ge307XG4gICAgICB0aGlzLl9mcmFtZUl0ZW1Db3VudCA9IDA7XG4gICAgICB0aGlzLl9pdGVtRXZlbnRzID0ge1xuICAgICAgICBuYXRpdmU6IHt9LFxuICAgICAgICB2aXJ0dWFsOiB7fVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2F1dG9VcGRhdGUgPSAhcGFwZXIuYWdlbnQubm9kZTtcbiAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fcHJvamVjdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKFZpZXcuX2ZvY3VzZWQgPT09IHRoaXMpIFZpZXcuX2ZvY3VzZWQgPSBudWxsO1xuXG4gICAgICBWaWV3Ll92aWV3cy5zcGxpY2UoVmlldy5fdmlld3MuaW5kZXhPZih0aGlzKSwgMSk7XG5cbiAgICAgIGRlbGV0ZSBWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdO1xuICAgICAgdmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuICAgICAgaWYgKHByb2plY3QuX3ZpZXcgPT09IHRoaXMpIHByb2plY3QuX3ZpZXcgPSBudWxsO1xuICAgICAgRG9tRXZlbnQucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3ZpZXdFdmVudHMpO1xuICAgICAgRG9tRXZlbnQucmVtb3ZlKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9wcm9qZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMub2ZmKCdmcmFtZScpO1xuICAgICAgdGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fZnJhbWVJdGVtcyA9IHt9O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBfZXZlbnRzOiBCYXNlLmVhY2goSXRlbS5faXRlbUhhbmRsZXJzLmNvbmNhdChbJ29uUmVzaXplJywgJ29uS2V5RG93bicsICdvbktleVVwJ10pLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdGhpc1tuYW1lXSA9IHt9O1xuICAgIH0sIHtcbiAgICAgIG9uRnJhbWU6IHtcbiAgICAgICAgaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9LFxuICAgICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICBfYW5pbWF0ZTogZmFsc2UsXG4gICAgX3RpbWU6IDAsXG4gICAgX2NvdW50OiAwLFxuICAgIGdldEF1dG9VcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hdXRvVXBkYXRlO1xuICAgIH0sXG4gICAgc2V0QXV0b1VwZGF0ZTogZnVuY3Rpb24gKGF1dG9VcGRhdGUpIHtcbiAgICAgIHRoaXMuX2F1dG9VcGRhdGUgPSBhdXRvVXBkYXRlO1xuICAgICAgaWYgKGF1dG9VcGRhdGUpIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBkcmF3OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgcmVxdWVzdFVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBEb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuX3JlcXVlc3RlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHRoYXQuX2FuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoYXQucmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGF0Ll9lbGVtZW50O1xuXG4gICAgICAgICAgICBpZiAoKCFEb21FbGVtZW50LmdldFByZWZpeGVkKGRvY3VtZW50LCAnaGlkZGVuJykgfHwgUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2tlZXBhbGl2ZScpID09PSAndHJ1ZScpICYmIERvbUVsZW1lbnQuaXNJblZpZXcoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgdGhhdC5faGFuZGxlRnJhbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhhdC5fYXV0b1VwZGF0ZSkgdGhhdC51cGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBwbGF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hbmltYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICAgIH0sXG4gICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcbiAgICB9LFxuICAgIF9oYW5kbGVGcmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgcGFwZXIgPSB0aGlzLl9zY29wZTtcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpIC8gMTAwMCxcbiAgICAgICAgICBkZWx0YSA9IHRoaXMuX2xhc3QgPyBub3cgLSB0aGlzLl9sYXN0IDogMDtcbiAgICAgIHRoaXMuX2xhc3QgPSBub3c7XG4gICAgICB0aGlzLmVtaXQoJ2ZyYW1lJywgbmV3IEJhc2Uoe1xuICAgICAgICBkZWx0YTogZGVsdGEsXG4gICAgICAgIHRpbWU6IHRoaXMuX3RpbWUgKz0gZGVsdGEsXG4gICAgICAgIGNvdW50OiB0aGlzLl9jb3VudCsrXG4gICAgICB9KSk7XG4gICAgICBpZiAodGhpcy5fc3RhdHMpIHRoaXMuX3N0YXRzLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgX2FuaW1hdGVJdGVtOiBmdW5jdGlvbiAoaXRlbSwgYW5pbWF0ZSkge1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5fZnJhbWVJdGVtcztcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgaXRlbXNbaXRlbS5faWRdID0ge1xuICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICBjb3VudDogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAoKyt0aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMSkgdGhpcy5vbignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBpdGVtc1tpdGVtLl9pZF07XG5cbiAgICAgICAgaWYgKC0tdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLm9mZignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX2hhbmRsZUZyYW1lSXRlbXM6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9mcmFtZUl0ZW1zKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX2ZyYW1lSXRlbXNbaV07XG4gICAgICAgIGVudHJ5Lml0ZW0uZW1pdCgnZnJhbWUnLCBuZXcgQmFzZShldmVudCwge1xuICAgICAgICAgIHRpbWU6IGVudHJ5LnRpbWUgKz0gZXZlbnQuZGVsdGEsXG4gICAgICAgICAgY291bnQ6IGVudHJ5LmNvdW50KytcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3Byb2plY3QuX2NoYW5nZWQoNDA5Nyk7XG5cbiAgICAgIHRoaXMuX2JvdW5kcyA9IHRoaXMuX2RlY29tcG9zZWQgPSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICB9LFxuICAgIGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9waXhlbFJhdGlvO1xuICAgIH0sXG4gICAgZ2V0UmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BpeGVsUmF0aW8gKiA3MjtcbiAgICB9LFxuICAgIGdldFZpZXdTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuICAgICAgcmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0Vmlld1NpemUnKTtcbiAgICB9LFxuICAgIHNldFZpZXdTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgIGRlbHRhID0gc2l6ZS5zdWJ0cmFjdCh0aGlzLl92aWV3U2l6ZSk7XG4gICAgICBpZiAoZGVsdGEuaXNaZXJvKCkpIHJldHVybjtcblxuICAgICAgdGhpcy5fc2V0RWxlbWVudFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXG4gICAgICB0aGlzLl92aWV3U2l6ZS5zZXQoc2l6ZSk7XG5cbiAgICAgIHRoaXMuX2NoYW5nZWQoKTtcblxuICAgICAgdGhpcy5lbWl0KCdyZXNpemUnLCB7XG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIGRlbHRhOiBkZWx0YVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfc2V0RWxlbWVudFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50LndpZHRoICE9PSB3aWR0aCkgZWxlbWVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgICBpZiAoZWxlbWVudC5oZWlnaHQgIT09IGhlaWdodCkgZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fYm91bmRzKSB0aGlzLl9ib3VuZHMgPSB0aGlzLl9tYXRyaXguaW52ZXJ0ZWQoKS5fdHJhbnNmb3JtQm91bmRzKG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksIHRoaXMuX3ZpZXdTaXplKSk7XG4gICAgICByZXR1cm4gdGhpcy5fYm91bmRzO1xuICAgIH0sXG4gICAgZ2V0U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0U2l6ZSgpO1xuICAgIH0sXG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRG9tRWxlbWVudC5pc0luVmlldyh0aGlzLl9lbGVtZW50KTtcbiAgICB9LFxuICAgIGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBEb21FbGVtZW50LmlzSW5zZXJ0ZWQodGhpcy5fZWxlbWVudCk7XG4gICAgfSxcbiAgICBnZXRQaXhlbFNpemU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgcGl4ZWxzO1xuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0ZW1wLnN0eWxlLmZvbnRTaXplID0gc2l6ZTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRlbXApO1xuICAgICAgICBwaXhlbHMgPSBwYXJzZUZsb2F0KERvbUVsZW1lbnQuZ2V0U3R5bGVzKHRlbXApLmZvbnRTaXplKTtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRlbXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl4ZWxzID0gcGFyc2VGbG9hdChwaXhlbHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGl4ZWxzO1xuICAgIH0sXG4gICAgZ2V0VGV4dFdpZHRoOiBmdW5jdGlvbiAoZm9udCwgbGluZXMpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwgQmFzZS5lYWNoKFsncm90YXRlJywgJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByb3RhdGUgPSBrZXkgPT09ICdyb3RhdGUnO1xuXG4gICAgdGhpc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgdmFsdWUgPSAocm90YXRlID8gQmFzZSA6IFBvaW50KS5yZWFkKGFyZ3MpLFxuICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWQoYXJncywgMCwge1xuICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpW2tleV0odmFsdWUsIGNlbnRlciB8fCB0aGlzLmdldENlbnRlcih0cnVlKSkpO1xuICAgIH07XG4gIH0sIHtcbiAgICBfZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVjb21wb3NlZCB8fCAodGhpcy5fZGVjb21wb3NlZCA9IHRoaXMuX21hdHJpeC5kZWNvbXBvc2UoKSk7XG4gICAgfSxcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBteCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShteC50cmFuc2xhdGUuYXBwbHkobXgsIGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcbiAgICB9LFxuICAgIHNldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudHJhbnNsYXRlKHRoaXMuZ2V0Q2VudGVyKCkuc3VidHJhY3QoY2VudGVyKSk7XG4gICAgfSxcbiAgICBnZXRab29tOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2NhbGluZyA9IHRoaXMuX2RlY29tcG9zZSgpLnNjYWxpbmc7XG5cbiAgICAgIHJldHVybiAoc2NhbGluZy54ICsgc2NhbGluZy55KSAvIDI7XG4gICAgfSxcbiAgICBzZXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnNjYWxlKHpvb20gLyB0aGlzLmdldFpvb20oKSwgdGhpcy5nZXRDZW50ZXIoKSkpO1xuICAgIH0sXG4gICAgZ2V0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvbXBvc2UoKS5yb3RhdGlvbjtcbiAgICB9LFxuICAgIHNldFJvdGF0aW9uOiBmdW5jdGlvbiAocm90YXRpb24pIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXG4gICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIHJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yb3RhdGUocm90YXRpb24gLSBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFNjYWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzY2FsaW5nID0gdGhpcy5fZGVjb21wb3NlKCkuc2NhbGluZztcblxuICAgICAgcmV0dXJuIG5ldyBMaW5rZWRQb2ludChzY2FsaW5nLngsIHNjYWxpbmcueSwgdGhpcywgJ3NldFNjYWxpbmcnKTtcbiAgICB9LFxuICAgIHNldFNjYWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRTY2FsaW5nKCksXG4gICAgICAgICAgc2NhbGluZyA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7XG4gICAgICAgIGNsb25lOiB0cnVlLFxuICAgICAgICByZWFkTnVsbDogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjdXJyZW50ICYmIHNjYWxpbmcpIHtcbiAgICAgICAgdGhpcy5zY2FsZShzY2FsaW5nLnggLyBjdXJyZW50LngsIHNjYWxpbmcueSAvIGN1cnJlbnQueSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXRyaXg7XG4gICAgfSxcbiAgICBzZXRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG4gICAgICBtYXRyaXguc2V0LmFwcGx5KG1hdHJpeCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgdGhpcy5fbWF0cml4LmFwcGVuZChtYXRyaXgpO1xuICAgIH0sXG4gICAgc2Nyb2xsQnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5uZWdhdGUoKSk7XG4gICAgfVxuICB9KSwge1xuICAgIHByb2plY3RUb1ZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICB2aWV3VG9Qcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBnZXRFdmVudFBvaW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdUb1Byb2plY3QoRG9tRXZlbnQuZ2V0T2Zmc2V0KGV2ZW50LCB0aGlzLl9lbGVtZW50KSk7XG4gICAgfVxuICB9LCB7XG4gICAgc3RhdGljczoge1xuICAgICAgX3ZpZXdzOiBbXSxcbiAgICAgIF92aWV3c0J5SWQ6IHt9LFxuICAgICAgX2lkOiAwLFxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiAocHJvamVjdCwgZWxlbWVudCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCk7XG4gICAgICAgIHZhciBjdG9yID0gd2luZG93ID8gQ2FudmFzVmlldyA6IFZpZXc7XG4gICAgICAgIHJldHVybiBuZXcgY3Rvcihwcm9qZWN0LCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF3aW5kb3cpIHJldHVybjtcbiAgICB2YXIgcHJldkZvY3VzLFxuICAgICAgICB0ZW1wRm9jdXMsXG4gICAgICAgIGRyYWdnaW5nID0gZmFsc2UsXG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhldmVudCkge1xuICAgICAgdmFyIHRhcmdldCA9IERvbUV2ZW50LmdldFRhcmdldChldmVudCk7XG4gICAgICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBWaWV3Ll92aWV3c0J5SWRbdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaWQnKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlRm9jdXMoKSB7XG4gICAgICB2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cbiAgICAgIGlmICghdmlldyB8fCAhdmlldy5pc1Zpc2libGUoKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IFZpZXcuX3ZpZXdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmICgodmlldyA9IFZpZXcuX3ZpZXdzW2ldKS5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgVmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHZpZXc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQsIHBvaW50KSB7XG4gICAgICB2aWV3Ll9oYW5kbGVNb3VzZUV2ZW50KCdtb3VzZW1vdmUnLCBldmVudCwgcG9pbnQpO1xuICAgIH1cblxuICAgIHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuICAgICAgICBtb3VzZWRvd24sXG4gICAgICAgIG1vdXNlbW92ZSxcbiAgICAgICAgbW91c2V1cDtcblxuICAgIGlmIChuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcbiAgICAgIG1vdXNlZG93biA9ICdwb2ludGVyZG93biBNU1BvaW50ZXJEb3duJztcbiAgICAgIG1vdXNlbW92ZSA9ICdwb2ludGVybW92ZSBNU1BvaW50ZXJNb3ZlJztcbiAgICAgIG1vdXNldXAgPSAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbiAgICB9IGVsc2Uge1xuICAgICAgbW91c2Vkb3duID0gJ3RvdWNoc3RhcnQnO1xuICAgICAgbW91c2Vtb3ZlID0gJ3RvdWNobW92ZSc7XG4gICAgICBtb3VzZXVwID0gJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuICAgICAgaWYgKCEoJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZHxzaWxrL2kpKSkge1xuICAgICAgICBtb3VzZWRvd24gKz0gJyBtb3VzZWRvd24nO1xuICAgICAgICBtb3VzZW1vdmUgKz0gJyBtb3VzZW1vdmUnO1xuICAgICAgICBtb3VzZXVwICs9ICcgbW91c2V1cCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZpZXdFdmVudHMgPSB7fSxcbiAgICAgICAgZG9jRXZlbnRzID0ge1xuICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQsXG4gICAgICAgICAgICB0YXJnZXQgPSBEb21FdmVudC5nZXRSZWxhdGVkVGFyZ2V0KGV2ZW50KTtcblxuICAgICAgICBpZiAodmlldyAmJiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gRG9tRXZlbnQuZ2V0T2Zmc2V0KGV2ZW50LCB2aWV3Ll9lbGVtZW50KSxcbiAgICAgICAgICAgICAgeCA9IG9mZnNldC54LFxuICAgICAgICAgICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICAgICAgYXggPSBhYnMoeCksXG4gICAgICAgICAgICAgIG1heCA9IDEgPDwgMjUsXG4gICAgICAgICAgICAgIGRpZmYgPSBheCAtIG1heDtcbiAgICAgICAgICBvZmZzZXQueCA9IGFicyhkaWZmKSA8IGF4ID8gZGlmZiAqICh4IDwgMCA/IC0xIDogMSkgOiB4O1xuICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCwgdmlldy52aWV3VG9Qcm9qZWN0KG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2Nyb2xsOiB1cGRhdGVGb2N1c1xuICAgIH07XG5cbiAgICB2aWV3RXZlbnRzW21vdXNlZG93bl0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZCA9IGdldFZpZXcoZXZlbnQpO1xuXG4gICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgIGRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICB2aWV3Ll9oYW5kbGVNb3VzZUV2ZW50KCdtb3VzZWRvd24nLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvY0V2ZW50c1ttb3VzZW1vdmVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cbiAgICAgIGlmICghbW91c2VEb3duKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBnZXRWaWV3KGV2ZW50KTtcblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKHZpZXcgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHZpZXcpIGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXByZXZGb2N1cykgcHJldkZvY3VzID0gdmlldztcbiAgICAgICAgICAgIHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdGFyZ2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wRm9jdXMgJiYgdGVtcEZvY3VzID09PSB2aWV3KSB7XG4gICAgICAgICAgaWYgKHByZXZGb2N1cyAmJiAhcHJldkZvY3VzLmlzSW5zZXJ0ZWQoKSkgcHJldkZvY3VzID0gbnVsbDtcbiAgICAgICAgICB2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHByZXZGb2N1cztcbiAgICAgICAgICBwcmV2Rm9jdXMgPSBudWxsO1xuICAgICAgICAgIHVwZGF0ZUZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZpZXcpIGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCk7XG4gICAgfTtcblxuICAgIGRvY0V2ZW50c1ttb3VzZWRvd25dID0gZnVuY3Rpb24gKCkge1xuICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZG9jRXZlbnRzW21vdXNldXBdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG4gICAgICBpZiAodmlldyAmJiBkcmFnZ2luZykgdmlldy5faGFuZGxlTW91c2VFdmVudCgnbW91c2V1cCcsIGV2ZW50KTtcbiAgICAgIG1vdXNlRG93biA9IGRyYWdnaW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIERvbUV2ZW50LmFkZChkb2N1bWVudCwgZG9jRXZlbnRzKTtcbiAgICBEb21FdmVudC5hZGQod2luZG93LCB7XG4gICAgICBsb2FkOiB1cGRhdGVGb2N1c1xuICAgIH0pO1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZSxcbiAgICAgICAgcHJldmVudGVkID0gZmFsc2UsXG4gICAgICAgIGZhbGxiYWNrcyA9IHtcbiAgICAgIGRvdWJsZWNsaWNrOiAnY2xpY2snLFxuICAgICAgbW91c2VkcmFnOiAnbW91c2Vtb3ZlJ1xuICAgIH0sXG4gICAgICAgIHdhc0luVmlldyA9IGZhbHNlLFxuICAgICAgICBvdmVyVmlldyxcbiAgICAgICAgZG93blBvaW50LFxuICAgICAgICBsYXN0UG9pbnQsXG4gICAgICAgIGRvd25JdGVtLFxuICAgICAgICBvdmVySXRlbSxcbiAgICAgICAgZHJhZ0l0ZW0sXG4gICAgICAgIGNsaWNrSXRlbSxcbiAgICAgICAgY2xpY2tUaW1lLFxuICAgICAgICBkYmxDbGljaztcblxuICAgIGZ1bmN0aW9uIGVtaXRNb3VzZUV2ZW50KG9iaiwgdGFyZ2V0LCB0eXBlLCBldmVudCwgcG9pbnQsIHByZXZQb2ludCwgc3RvcEl0ZW0pIHtcbiAgICAgIHZhciBzdG9wcGVkID0gZmFsc2UsXG4gICAgICAgICAgbW91c2VFdmVudDtcblxuICAgICAgZnVuY3Rpb24gZW1pdChvYmosIHR5cGUpIHtcbiAgICAgICAgaWYgKG9iai5yZXNwb25kcyh0eXBlKSkge1xuICAgICAgICAgIGlmICghbW91c2VFdmVudCkge1xuICAgICAgICAgICAgbW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0IHx8IG9iaiwgcHJldlBvaW50ID8gcG9pbnQuc3VidHJhY3QocHJldlBvaW50KSA6IG51bGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvYmouZW1pdCh0eXBlLCBtb3VzZUV2ZW50KSkge1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChtb3VzZUV2ZW50LnByZXZlbnRlZCkgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChtb3VzZUV2ZW50LnN0b3BwZWQpIHJldHVybiBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZhbGxiYWNrID0gZmFsbGJhY2tzW3R5cGVdO1xuICAgICAgICAgIGlmIChmYWxsYmFjaykgcmV0dXJuIGVtaXQob2JqLCBmYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG9iaiAmJiBvYmogIT09IHN0b3BJdGVtKSB7XG4gICAgICAgIGlmIChlbWl0KG9iaiwgdHlwZSkpIGJyZWFrO1xuICAgICAgICBvYmogPSBvYmouX3BhcmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3BwZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdE1vdXNlRXZlbnRzKHZpZXcsIGhpdEl0ZW0sIHR5cGUsIGV2ZW50LCBwb2ludCwgcHJldlBvaW50KSB7XG4gICAgICB2aWV3Ll9wcm9qZWN0LnJlbW92ZU9uKHR5cGUpO1xuXG4gICAgICBwcmV2ZW50ZWQgPSBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBkcmFnSXRlbSAmJiBlbWl0TW91c2VFdmVudChkcmFnSXRlbSwgbnVsbCwgdHlwZSwgZXZlbnQsIHBvaW50LCBwcmV2UG9pbnQpIHx8IGhpdEl0ZW0gJiYgaGl0SXRlbSAhPT0gZHJhZ0l0ZW0gJiYgIWhpdEl0ZW0uaXNEZXNjZW5kYW50KGRyYWdJdGVtKSAmJiBlbWl0TW91c2VFdmVudChoaXRJdGVtLCBudWxsLCB0eXBlID09PSAnbW91c2VkcmFnJyA/ICdtb3VzZW1vdmUnIDogdHlwZSwgZXZlbnQsIHBvaW50LCBwcmV2UG9pbnQsIGRyYWdJdGVtKSB8fCBlbWl0TW91c2VFdmVudCh2aWV3LCBkcmFnSXRlbSB8fCBoaXRJdGVtIHx8IHZpZXcsIHR5cGUsIGV2ZW50LCBwb2ludCwgcHJldlBvaW50KTtcbiAgICB9XG5cbiAgICB2YXIgaXRlbUV2ZW50c01hcCA9IHtcbiAgICAgIG1vdXNlZG93bjoge1xuICAgICAgICBtb3VzZWRvd246IDEsXG4gICAgICAgIG1vdXNlZHJhZzogMSxcbiAgICAgICAgY2xpY2s6IDEsXG4gICAgICAgIGRvdWJsZWNsaWNrOiAxXG4gICAgICB9LFxuICAgICAgbW91c2V1cDoge1xuICAgICAgICBtb3VzZXVwOiAxLFxuICAgICAgICBtb3VzZWRyYWc6IDEsXG4gICAgICAgIGNsaWNrOiAxLFxuICAgICAgICBkb3VibGVjbGljazogMVxuICAgICAgfSxcbiAgICAgIG1vdXNlbW92ZToge1xuICAgICAgICBtb3VzZWRyYWc6IDEsXG4gICAgICAgIG1vdXNlbW92ZTogMSxcbiAgICAgICAgbW91c2VlbnRlcjogMSxcbiAgICAgICAgbW91c2VsZWF2ZTogMVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIF92aWV3RXZlbnRzOiB2aWV3RXZlbnRzLFxuICAgICAgX2hhbmRsZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBldmVudCwgcG9pbnQpIHtcbiAgICAgICAgdmFyIGl0ZW1FdmVudHMgPSB0aGlzLl9pdGVtRXZlbnRzLFxuICAgICAgICAgICAgaGl0SXRlbXMgPSBpdGVtRXZlbnRzLm5hdGl2ZVt0eXBlXSxcbiAgICAgICAgICAgIG5hdGl2ZU1vdmUgPSB0eXBlID09PSAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgIHRvb2wgPSB0aGlzLl9zY29wZS50b29sLFxuICAgICAgICAgICAgdmlldyA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzcG9uZHModHlwZSkge1xuICAgICAgICAgIHJldHVybiBpdGVtRXZlbnRzLnZpcnR1YWxbdHlwZV0gfHwgdmlldy5yZXNwb25kcyh0eXBlKSB8fCB0b29sICYmIHRvb2wucmVzcG9uZHModHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmF0aXZlTW92ZSAmJiBkcmFnZ2luZyAmJiByZXNwb25kcygnbW91c2VkcmFnJykpIHR5cGUgPSAnbW91c2VkcmFnJztcbiAgICAgICAgaWYgKCFwb2ludCkgcG9pbnQgPSB0aGlzLmdldEV2ZW50UG9pbnQoZXZlbnQpO1xuXG4gICAgICAgIHZhciBpblZpZXcgPSB0aGlzLmdldEJvdW5kcygpLmNvbnRhaW5zKHBvaW50KSxcbiAgICAgICAgICAgIGhpdCA9IGhpdEl0ZW1zICYmIGluVmlldyAmJiB2aWV3Ll9wcm9qZWN0LmhpdFRlc3QocG9pbnQsIHtcbiAgICAgICAgICB0b2xlcmFuY2U6IDAsXG4gICAgICAgICAgZmlsbDogdHJ1ZSxcbiAgICAgICAgICBzdHJva2U6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgICAgICBoaXRJdGVtID0gaGl0ICYmIGhpdC5pdGVtIHx8IG51bGwsXG4gICAgICAgICAgICBoYW5kbGUgPSBmYWxzZSxcbiAgICAgICAgICAgIG1vdXNlID0ge307XG5cbiAgICAgICAgbW91c2VbdHlwZS5zdWJzdHIoNSldID0gdHJ1ZTtcblxuICAgICAgICBpZiAoaGl0SXRlbXMgJiYgaGl0SXRlbSAhPT0gb3Zlckl0ZW0pIHtcbiAgICAgICAgICBpZiAob3Zlckl0ZW0pIHtcbiAgICAgICAgICAgIGVtaXRNb3VzZUV2ZW50KG92ZXJJdGVtLCBudWxsLCAnbW91c2VsZWF2ZScsIGV2ZW50LCBwb2ludCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhpdEl0ZW0pIHtcbiAgICAgICAgICAgIGVtaXRNb3VzZUV2ZW50KGhpdEl0ZW0sIG51bGwsICdtb3VzZWVudGVyJywgZXZlbnQsIHBvaW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdmVySXRlbSA9IGhpdEl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2FzSW5WaWV3IF4gaW5WaWV3KSB7XG4gICAgICAgICAgZW1pdE1vdXNlRXZlbnQodGhpcywgbnVsbCwgaW5WaWV3ID8gJ21vdXNlZW50ZXInIDogJ21vdXNlbGVhdmUnLCBldmVudCwgcG9pbnQpO1xuICAgICAgICAgIG92ZXJWaWV3ID0gaW5WaWV3ID8gdGhpcyA6IG51bGw7XG4gICAgICAgICAgaGFuZGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoaW5WaWV3IHx8IG1vdXNlLmRyYWcpICYmICFwb2ludC5lcXVhbHMobGFzdFBvaW50KSkge1xuICAgICAgICAgIGVtaXRNb3VzZUV2ZW50cyh0aGlzLCBoaXRJdGVtLCBuYXRpdmVNb3ZlID8gdHlwZSA6ICdtb3VzZW1vdmUnLCBldmVudCwgcG9pbnQsIGxhc3RQb2ludCk7XG4gICAgICAgICAgaGFuZGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhc0luVmlldyA9IGluVmlldztcblxuICAgICAgICBpZiAobW91c2UuZG93biAmJiBpblZpZXcgfHwgbW91c2UudXAgJiYgZG93blBvaW50KSB7XG4gICAgICAgICAgZW1pdE1vdXNlRXZlbnRzKHRoaXMsIGhpdEl0ZW0sIHR5cGUsIGV2ZW50LCBwb2ludCwgZG93blBvaW50KTtcblxuICAgICAgICAgIGlmIChtb3VzZS5kb3duKSB7XG4gICAgICAgICAgICBkYmxDbGljayA9IGhpdEl0ZW0gPT09IGNsaWNrSXRlbSAmJiBEYXRlLm5vdygpIC0gY2xpY2tUaW1lIDwgMzAwO1xuICAgICAgICAgICAgZG93bkl0ZW0gPSBjbGlja0l0ZW0gPSBoaXRJdGVtO1xuXG4gICAgICAgICAgICBpZiAoIXByZXZlbnRlZCAmJiBoaXRJdGVtKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0gaGl0SXRlbTtcblxuICAgICAgICAgICAgICB3aGlsZSAoaXRlbSAmJiAhaXRlbS5yZXNwb25kcygnbW91c2VkcmFnJykpIGl0ZW0gPSBpdGVtLl9wYXJlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKGl0ZW0pIGRyYWdJdGVtID0gaGl0SXRlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG93blBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChtb3VzZS51cCkge1xuICAgICAgICAgICAgaWYgKCFwcmV2ZW50ZWQgJiYgaGl0SXRlbSA9PT0gZG93bkl0ZW0pIHtcbiAgICAgICAgICAgICAgY2xpY2tUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgZW1pdE1vdXNlRXZlbnRzKHRoaXMsIGhpdEl0ZW0sIGRibENsaWNrID8gJ2RvdWJsZWNsaWNrJyA6ICdjbGljaycsIGV2ZW50LCBwb2ludCwgZG93blBvaW50KTtcbiAgICAgICAgICAgICAgZGJsQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG93bkl0ZW0gPSBkcmFnSXRlbSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2FzSW5WaWV3ID0gZmFsc2U7XG4gICAgICAgICAgaGFuZGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuXG4gICAgICAgIGlmIChoYW5kbGUgJiYgdG9vbCkge1xuICAgICAgICAgIGNhbGxlZCA9IHRvb2wuX2hhbmRsZU1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCBtb3VzZSkgfHwgY2FsbGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlICYmIChjYWxsZWQgJiYgIW1vdXNlLm1vdmUgfHwgbW91c2UuZG93biAmJiByZXNwb25kcygnbW91c2V1cCcpKSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfaGFuZGxlS2V5RXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBldmVudCwga2V5LCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5fc2NvcGUsXG4gICAgICAgICAgICB0b29sID0gc2NvcGUudG9vbCxcbiAgICAgICAgICAgIGtleUV2ZW50O1xuXG4gICAgICAgIGZ1bmN0aW9uIGVtaXQob2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5yZXNwb25kcyh0eXBlKSkge1xuICAgICAgICAgICAgcGFwZXIgPSBzY29wZTtcbiAgICAgICAgICAgIG9iai5lbWl0KHR5cGUsIGtleUV2ZW50ID0ga2V5RXZlbnQgfHwgbmV3IEtleUV2ZW50KHR5cGUsIGV2ZW50LCBrZXksIGNoYXJhY3RlcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgZW1pdCh0aGlzKTtcbiAgICAgICAgICBpZiAodG9vbCAmJiB0b29sLnJlc3BvbmRzKHR5cGUpKSBlbWl0KHRvb2wpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2NvdW50SXRlbUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgc2lnbikge1xuICAgICAgICB2YXIgaXRlbUV2ZW50cyA9IHRoaXMuX2l0ZW1FdmVudHMsXG4gICAgICAgICAgICBuYXRpdmUgPSBpdGVtRXZlbnRzLm5hdGl2ZSxcbiAgICAgICAgICAgIHZpcnR1YWwgPSBpdGVtRXZlbnRzLnZpcnR1YWw7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGl0ZW1FdmVudHNNYXApIHtcbiAgICAgICAgICBuYXRpdmVba2V5XSA9IChuYXRpdmVba2V5XSB8fCAwKSArIChpdGVtRXZlbnRzTWFwW2tleV1bdHlwZV0gfHwgMCkgKiBzaWduO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlydHVhbFt0eXBlXSA9ICh2aXJ0dWFsW3R5cGVdIHx8IDApICsgc2lnbjtcbiAgICAgIH0sXG4gICAgICBzdGF0aWNzOiB7XG4gICAgICAgIHVwZGF0ZUZvY3VzOiB1cGRhdGVGb2N1cyxcbiAgICAgICAgX3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkcmFnZ2luZyA9IG1vdXNlRG93biA9IGNhbGxlZCA9IHdhc0luVmlldyA9IGZhbHNlO1xuICAgICAgICAgIHByZXZGb2N1cyA9IHRlbXBGb2N1cyA9IG92ZXJWaWV3ID0gZG93blBvaW50ID0gbGFzdFBvaW50ID0gZG93bkl0ZW0gPSBvdmVySXRlbSA9IGRyYWdJdGVtID0gY2xpY2tJdGVtID0gY2xpY2tUaW1lID0gZGJsQ2xpY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSgpKTtcbiAgdmFyIENhbnZhc1ZpZXcgPSBWaWV3LmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnQ2FudmFzVmlldycsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gQ2FudmFzVmlldyhwcm9qZWN0LCBjYW52YXMpIHtcbiAgICAgIGlmICghKGNhbnZhcyBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCkpIHtcbiAgICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaWYgKHNpemUuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBDYW52YXNWaWV3IHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50OiAnICsgQmFzZS5zbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgY2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5fY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3BpeGVsUmF0aW8gPSAxO1xuXG4gICAgICBpZiAoIS9eb2ZmfGZhbHNlJC8udGVzdChQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShjYW52YXMsICdoaWRwaScpKSkge1xuICAgICAgICB2YXIgZGV2aWNlUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICAgICAgYmFja2luZ1N0b3JlUmF0aW8gPSBEb21FbGVtZW50LmdldFByZWZpeGVkKGN0eCwgJ2JhY2tpbmdTdG9yZVBpeGVsUmF0aW8nKSB8fCAxO1xuICAgICAgICB0aGlzLl9waXhlbFJhdGlvID0gZGV2aWNlUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcbiAgICAgIH1cblxuICAgICAgVmlldy5jYWxsKHRoaXMsIHByb2plY3QsIGNhbnZhcyk7XG4gICAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICByZXR1cm4gcmVtb3ZlLmJhc2UuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIF9zZXRFbGVtZW50U2l6ZTogZnVuY3Rpb24gX3NldEVsZW1lbnRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5fcGl4ZWxSYXRpbztcblxuICAgICAgX3NldEVsZW1lbnRTaXplLmJhc2UuY2FsbCh0aGlzLCB3aWR0aCAqIHBpeGVsUmF0aW8sIGhlaWdodCAqIHBpeGVsUmF0aW8pO1xuXG4gICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgICAgIGlmICghUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3Jlc2l6ZScpKSB7XG4gICAgICAgICAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICAgICAgICBzdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gICAgfSxcbiAgICBnZXRQaXhlbFNpemU6IGZ1bmN0aW9uIGdldFBpeGVsU2l6ZShzaXplKSB7XG4gICAgICB2YXIgYWdlbnQgPSBwYXBlci5hZ2VudCxcbiAgICAgICAgICBwaXhlbHM7XG5cbiAgICAgIGlmIChhZ2VudCAmJiBhZ2VudC5maXJlZm94KSB7XG4gICAgICAgIHBpeGVscyA9IGdldFBpeGVsU2l6ZS5iYXNlLmNhbGwodGhpcywgc2l6ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcbiAgICAgICAgICAgIHByZXZGb250ID0gY3R4LmZvbnQ7XG4gICAgICAgIGN0eC5mb250ID0gc2l6ZSArICcgc2VyaWYnO1xuICAgICAgICBwaXhlbHMgPSBwYXJzZUZsb2F0KGN0eC5mb250KTtcbiAgICAgICAgY3R4LmZvbnQgPSBwcmV2Rm9udDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBpeGVscztcbiAgICB9LFxuICAgIGdldFRleHRXaWR0aDogZnVuY3Rpb24gKGZvbnQsIGxpbmVzKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcbiAgICAgICAgICBwcmV2Rm9udCA9IGN0eC5mb250LFxuICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgIGN0eC5mb250ID0gZm9udDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGgpO1xuXG4gICAgICBjdHguZm9udCA9IHByZXZGb250O1xuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX25lZWRzVXBkYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG4gICAgICAgICAgY3R4ID0gdGhpcy5fY29udGV4dCxcbiAgICAgICAgICBzaXplID0gdGhpcy5fdmlld1NpemU7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGggKyAxLCBzaXplLmhlaWdodCArIDEpO1xuICAgICAgaWYgKHByb2plY3QpIHByb2plY3QuZHJhdyhjdHgsIHRoaXMuX21hdHJpeCwgdGhpcy5fcGl4ZWxSYXRpbyk7XG4gICAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgdmFyIEV2ZW50ID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0V2ZW50JyxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBFdmVudChldmVudCkge1xuICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgdGhpcy50eXBlID0gZXZlbnQgJiYgZXZlbnQudHlwZTtcbiAgICB9LFxuICAgIHByZXZlbnRlZDogZmFsc2UsXG4gICAgc3RvcHBlZDogZmFsc2UsXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG4gICAgZ2V0VGltZVN0YW1wOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudC50aW1lU3RhbXA7XG4gICAgfSxcbiAgICBnZXRNb2RpZmllcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBLZXkubW9kaWZpZXJzO1xuICAgIH1cbiAgfSk7XG4gIHZhciBLZXlFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnS2V5RXZlbnQnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEtleUV2ZW50KHR5cGUsIGV2ZW50LCBrZXksIGNoYXJhY3Rlcikge1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBjaGFyYWN0ZXI7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwieyB0eXBlOiAnXCIgKyB0aGlzLnR5cGUgKyBcIicsIGtleTogJ1wiICsgdGhpcy5rZXkgKyBcIicsIGNoYXJhY3RlcjogJ1wiICsgdGhpcy5jaGFyYWN0ZXIgKyBcIicsIG1vZGlmaWVyczogXCIgKyB0aGlzLmdldE1vZGlmaWVycygpICsgXCIgfVwiO1xuICAgIH1cbiAgfSk7XG4gIHZhciBLZXkgPSBuZXcgZnVuY3Rpb24gKCkge1xuICAgIHZhciBrZXlMb29rdXAgPSB7XG4gICAgICAnXFx0JzogJ3RhYicsXG4gICAgICAnICc6ICdzcGFjZScsXG4gICAgICAnXFxiJzogJ2JhY2tzcGFjZScsXG4gICAgICAnXFx4N2YnOiAnZGVsZXRlJyxcbiAgICAgICdTcGFjZWJhcic6ICdzcGFjZScsXG4gICAgICAnRGVsJzogJ2RlbGV0ZScsXG4gICAgICAnV2luJzogJ21ldGEnLFxuICAgICAgJ0VzYyc6ICdlc2NhcGUnXG4gICAgfSxcbiAgICAgICAgY2hhckxvb2t1cCA9IHtcbiAgICAgICd0YWInOiAnXFx0JyxcbiAgICAgICdzcGFjZSc6ICcgJyxcbiAgICAgICdlbnRlcic6ICdcXHInXG4gICAgfSxcbiAgICAgICAga2V5TWFwID0ge30sXG4gICAgICAgIGNoYXJNYXAgPSB7fSxcbiAgICAgICAgbWV0YUZpeE1hcCxcbiAgICAgICAgZG93bktleSxcbiAgICAgICAgbW9kaWZpZXJzID0gbmV3IEJhc2Uoe1xuICAgICAgc2hpZnQ6IGZhbHNlLFxuICAgICAgY29udHJvbDogZmFsc2UsXG4gICAgICBhbHQ6IGZhbHNlLFxuICAgICAgbWV0YTogZmFsc2UsXG4gICAgICBjYXBzTG9jazogZmFsc2UsXG4gICAgICBzcGFjZTogZmFsc2VcbiAgICB9KS5pbmplY3Qoe1xuICAgICAgb3B0aW9uOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFsdDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbW1hbmQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFnZW50ID0gcGFwZXIgJiYgcGFwZXIuYWdlbnQ7XG4gICAgICAgICAgcmV0dXJuIGFnZW50ICYmIGFnZW50Lm1hYyA/IHRoaXMubWV0YSA6IHRoaXMuY29udHJvbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0S2V5KGV2ZW50KSB7XG4gICAgICB2YXIga2V5ID0gZXZlbnQua2V5IHx8IGV2ZW50LmtleUlkZW50aWZpZXI7XG4gICAgICBrZXkgPSAvXlVcXCsvLnRlc3Qoa2V5KSA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoa2V5LnN1YnN0cigyKSwgMTYpKSA6IC9eQXJyb3dbQS1aXS8udGVzdChrZXkpID8ga2V5LnN1YnN0cig1KSA6IGtleSA9PT0gJ1VuaWRlbnRpZmllZCcgfHwga2V5ID09PSB1bmRlZmluZWQgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmtleUNvZGUpIDoga2V5O1xuICAgICAgcmV0dXJuIGtleUxvb2t1cFtrZXldIHx8IChrZXkubGVuZ3RoID4gMSA/IEJhc2UuaHlwaGVuYXRlKGtleSkgOiBrZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5KGRvd24sIGtleSwgY2hhcmFjdGVyLCBldmVudCkge1xuICAgICAgdmFyIHR5cGUgPSBkb3duID8gJ2tleWRvd24nIDogJ2tleXVwJyxcbiAgICAgICAgICB2aWV3ID0gVmlldy5fZm9jdXNlZCxcbiAgICAgICAgICBuYW1lO1xuICAgICAga2V5TWFwW2tleV0gPSBkb3duO1xuXG4gICAgICBpZiAoZG93bikge1xuICAgICAgICBjaGFyTWFwW2tleV0gPSBjaGFyYWN0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgY2hhck1hcFtrZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5Lmxlbmd0aCA+IDEgJiYgKG5hbWUgPSBCYXNlLmNhbWVsaXplKGtleSkpIGluIG1vZGlmaWVycykge1xuICAgICAgICBtb2RpZmllcnNbbmFtZV0gPSBkb3duO1xuICAgICAgICB2YXIgYWdlbnQgPSBwYXBlciAmJiBwYXBlci5hZ2VudDtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ21ldGEnICYmIGFnZW50ICYmIGFnZW50Lm1hYykge1xuICAgICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgICBtZXRhRml4TWFwID0ge307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbWV0YUZpeE1hcCkge1xuICAgICAgICAgICAgICBpZiAoayBpbiBjaGFyTWFwKSBoYW5kbGVLZXkoZmFsc2UsIGssIG1ldGFGaXhNYXBba10sIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWV0YUZpeE1hcCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRvd24gJiYgbWV0YUZpeE1hcCkge1xuICAgICAgICBtZXRhRml4TWFwW2tleV0gPSBjaGFyYWN0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgIHZpZXcuX2hhbmRsZUtleUV2ZW50KGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnLCBldmVudCwga2V5LCBjaGFyYWN0ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIERvbUV2ZW50LmFkZChkb2N1bWVudCwge1xuICAgICAga2V5ZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBnZXRLZXkoZXZlbnQpLFxuICAgICAgICAgICAgYWdlbnQgPSBwYXBlciAmJiBwYXBlci5hZ2VudDtcblxuICAgICAgICBpZiAoa2V5Lmxlbmd0aCA+IDEgfHwgYWdlbnQgJiYgYWdlbnQuY2hyb21lICYmIChldmVudC5hbHRLZXkgfHwgYWdlbnQubWFjICYmIGV2ZW50Lm1ldGFLZXkgfHwgIWFnZW50Lm1hYyAmJiBldmVudC5jdHJsS2V5KSkge1xuICAgICAgICAgIGhhbmRsZUtleSh0cnVlLCBrZXksIGNoYXJMb29rdXBba2V5XSB8fCAoa2V5Lmxlbmd0aCA+IDEgPyAnJyA6IGtleSksIGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb3duS2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAga2V5cHJlc3M6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZG93bktleSkge1xuICAgICAgICAgIHZhciBrZXkgPSBnZXRLZXkoZXZlbnQpLFxuICAgICAgICAgICAgICBjb2RlID0gZXZlbnQuY2hhckNvZGUsXG4gICAgICAgICAgICAgIGNoYXJhY3RlciA9IGNvZGUgPj0gMzIgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIDoga2V5Lmxlbmd0aCA+IDEgPyAnJyA6IGtleTtcblxuICAgICAgICAgIGlmIChrZXkgIT09IGRvd25LZXkpIHtcbiAgICAgICAgICAgIGtleSA9IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZUtleSh0cnVlLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpO1xuICAgICAgICAgIGRvd25LZXkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAga2V5dXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIga2V5ID0gZ2V0S2V5KGV2ZW50KTtcbiAgICAgICAgaWYgKGtleSBpbiBjaGFyTWFwKSBoYW5kbGVLZXkoZmFsc2UsIGtleSwgY2hhck1hcFtrZXldLCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgRG9tRXZlbnQuYWRkKHdpbmRvdywge1xuICAgICAgYmx1cjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjaGFyTWFwKSBoYW5kbGVLZXkoZmFsc2UsIGtleSwgY2hhck1hcFtrZXldLCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgaXNEb3duOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWtleU1hcFtrZXldO1xuICAgICAgfVxuICAgIH07XG4gIH0oKTtcbiAgdmFyIE1vdXNlRXZlbnQgPSBFdmVudC5leHRlbmQoe1xuICAgIF9jbGFzczogJ01vdXNlRXZlbnQnLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIE1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsIGRlbHRhKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgdGhpcy5wb2ludCA9IHBvaW50O1xuICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICB0aGlzLmRlbHRhID0gZGVsdGE7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwieyB0eXBlOiAnXCIgKyB0aGlzLnR5cGUgKyBcIicsIHBvaW50OiBcIiArIHRoaXMucG9pbnQgKyAnLCB0YXJnZXQ6ICcgKyB0aGlzLnRhcmdldCArICh0aGlzLmRlbHRhID8gJywgZGVsdGE6ICcgKyB0aGlzLmRlbHRhIDogJycpICsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKSArICcgfSc7XG4gICAgfVxuICB9KTtcbiAgdmFyIFRvb2xFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnVG9vbEV2ZW50JyxcbiAgICBfaXRlbTogbnVsbCxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBUb29sRXZlbnQodG9vbCwgdHlwZSwgZXZlbnQpIHtcbiAgICAgIHRoaXMudG9vbCA9IHRvb2w7XG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgIH0sXG4gICAgX2Nob29zZVBvaW50OiBmdW5jdGlvbiAocG9pbnQsIHRvb2xQb2ludCkge1xuICAgICAgcmV0dXJuIHBvaW50ID8gcG9pbnQgOiB0b29sUG9pbnQgPyB0b29sUG9pbnQuY2xvbmUoKSA6IG51bGw7XG4gICAgfSxcbiAgICBnZXRQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX3BvaW50LCB0aGlzLnRvb2wuX3BvaW50KTtcbiAgICB9LFxuICAgIHNldFBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHRoaXMuX3BvaW50ID0gcG9pbnQ7XG4gICAgfSxcbiAgICBnZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9sYXN0UG9pbnQsIHRoaXMudG9vbC5fbGFzdFBvaW50KTtcbiAgICB9LFxuICAgIHNldExhc3RQb2ludDogZnVuY3Rpb24gKGxhc3RQb2ludCkge1xuICAgICAgdGhpcy5fbGFzdFBvaW50ID0gbGFzdFBvaW50O1xuICAgIH0sXG4gICAgZ2V0RG93blBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fZG93blBvaW50LCB0aGlzLnRvb2wuX2Rvd25Qb2ludCk7XG4gICAgfSxcbiAgICBzZXREb3duUG9pbnQ6IGZ1bmN0aW9uIChkb3duUG9pbnQpIHtcbiAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IGRvd25Qb2ludDtcbiAgICB9LFxuICAgIGdldE1pZGRsZVBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX21pZGRsZVBvaW50ICYmIHRoaXMudG9vbC5fbGFzdFBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvb2wuX3BvaW50LmFkZCh0aGlzLnRvb2wuX2xhc3RQb2ludCkuZGl2aWRlKDIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fbWlkZGxlUG9pbnQ7XG4gICAgfSxcbiAgICBzZXRNaWRkbGVQb2ludDogZnVuY3Rpb24gKG1pZGRsZVBvaW50KSB7XG4gICAgICB0aGlzLl9taWRkbGVQb2ludCA9IG1pZGRsZVBvaW50O1xuICAgIH0sXG4gICAgZ2V0RGVsdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5fZGVsdGEgJiYgdGhpcy50b29sLl9sYXN0UG9pbnQgPyB0aGlzLnRvb2wuX3BvaW50LnN1YnRyYWN0KHRoaXMudG9vbC5fbGFzdFBvaW50KSA6IHRoaXMuX2RlbHRhO1xuICAgIH0sXG4gICAgc2V0RGVsdGE6IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgdGhpcy5fZGVsdGEgPSBkZWx0YTtcbiAgICB9LFxuICAgIGdldENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b29sWy9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSkgPyAnX2Rvd25Db3VudCcgOiAnX21vdmVDb3VudCddO1xuICAgIH0sXG4gICAgc2V0Q291bnQ6IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgdGhpcy50b29sWy9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSkgPyAnZG93bkNvdW50JyA6ICdjb3VudCddID0gY291bnQ7XG4gICAgfSxcbiAgICBnZXRJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2l0ZW0pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudG9vbC5fc2NvcGUucHJvamVjdC5oaXRUZXN0KHRoaXMuZ2V0UG9pbnQoKSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHZhciBpdGVtID0gcmVzdWx0Lml0ZW0sXG4gICAgICAgICAgICAgIHBhcmVudCA9IGl0ZW0uX3BhcmVudDtcblxuICAgICAgICAgIHdoaWxlICgvXihHcm91cHxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKSkge1xuICAgICAgICAgICAgaXRlbSA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2l0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9pdGVtO1xuICAgIH0sXG4gICAgc2V0SXRlbTogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHRoaXMuX2l0ZW0gPSBpdGVtO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAneyB0eXBlOiAnICsgdGhpcy50eXBlICsgJywgcG9pbnQ6ICcgKyB0aGlzLmdldFBvaW50KCkgKyAnLCBjb3VudDogJyArIHRoaXMuZ2V0Q291bnQoKSArICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKCkgKyAnIH0nO1xuICAgIH1cbiAgfSk7XG4gIHZhciBUb29sID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdUb29sJyxcbiAgICBfbGlzdDogJ3Rvb2xzJyxcbiAgICBfcmVmZXJlbmNlOiAndG9vbCcsXG4gICAgX2V2ZW50czogWydvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25Nb3VzZU1vdmUnLCAnb25BY3RpdmF0ZScsICdvbkRlYWN0aXZhdGUnLCAnb25FZGl0T3B0aW9ucycsICdvbktleURvd24nLCAnb25LZXlVcCddLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2wocHJvcHMpIHtcbiAgICAgIFBhcGVyU2NvcGVJdGVtLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLl9tb3ZlQ291bnQgPSAtMTtcbiAgICAgIHRoaXMuX2Rvd25Db3VudCA9IC0xO1xuICAgICAgdGhpcy5zZXQocHJvcHMpO1xuICAgIH0sXG4gICAgZ2V0TWluRGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taW5EaXN0YW5jZTtcbiAgICB9LFxuICAgIHNldE1pbkRpc3RhbmNlOiBmdW5jdGlvbiAobWluRGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX21pbkRpc3RhbmNlID0gbWluRGlzdGFuY2U7XG5cbiAgICAgIGlmIChtaW5EaXN0YW5jZSAhPSBudWxsICYmIHRoaXMuX21heERpc3RhbmNlICE9IG51bGwgJiYgbWluRGlzdGFuY2UgPiB0aGlzLl9tYXhEaXN0YW5jZSkge1xuICAgICAgICB0aGlzLl9tYXhEaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXhEaXN0YW5jZTtcbiAgICB9LFxuICAgIHNldE1heERpc3RhbmNlOiBmdW5jdGlvbiAobWF4RGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX21heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG5cbiAgICAgIGlmICh0aGlzLl9taW5EaXN0YW5jZSAhPSBudWxsICYmIG1heERpc3RhbmNlICE9IG51bGwgJiYgbWF4RGlzdGFuY2UgPCB0aGlzLl9taW5EaXN0YW5jZSkge1xuICAgICAgICB0aGlzLl9taW5EaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Rml4ZWREaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlID09IHRoaXMuX21heERpc3RhbmNlID8gdGhpcy5fbWluRGlzdGFuY2UgOiBudWxsO1xuICAgIH0sXG4gICAgc2V0Rml4ZWREaXN0YW5jZTogZnVuY3Rpb24gKGRpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9taW5EaXN0YW5jZSA9IHRoaXMuX21heERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSxcbiAgICBfaGFuZGxlTW91c2VFdmVudDogZnVuY3Rpb24gKHR5cGUsIGV2ZW50LCBwb2ludCwgbW91c2UpIHtcbiAgICAgIHBhcGVyID0gdGhpcy5fc2NvcGU7XG4gICAgICBpZiAobW91c2UuZHJhZyAmJiAhdGhpcy5yZXNwb25kcyh0eXBlKSkgdHlwZSA9ICdtb3VzZW1vdmUnO1xuICAgICAgdmFyIG1vdmUgPSBtb3VzZS5tb3ZlIHx8IG1vdXNlLmRyYWcsXG4gICAgICAgICAgcmVzcG9uZHMgPSB0aGlzLnJlc3BvbmRzKHR5cGUpLFxuICAgICAgICAgIG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZSxcbiAgICAgICAgICBtYXhEaXN0YW5jZSA9IHRoaXMubWF4RGlzdGFuY2UsXG4gICAgICAgICAgY2FsbGVkID0gZmFsc2UsXG4gICAgICAgICAgdG9vbCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZShtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnQsXG4gICAgICAgICAgICB0b29sUG9pbnQgPSBtb3ZlID8gdG9vbC5fcG9pbnQgOiB0b29sLl9kb3duUG9pbnQgfHwgcHQ7XG5cbiAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICBpZiAodG9vbC5fbW92ZUNvdW50ID49IDAgJiYgcHQuZXF1YWxzKHRvb2xQb2ludCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9vbFBvaW50ICYmIChtaW5EaXN0YW5jZSAhPSBudWxsIHx8IG1heERpc3RhbmNlICE9IG51bGwpKSB7XG4gICAgICAgICAgICB2YXIgdmVjdG9yID0gcHQuc3VidHJhY3QodG9vbFBvaW50KSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHZlY3Rvci5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IChtaW5EaXN0YW5jZSB8fCAwKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAobWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgcHQgPSB0b29sUG9pbnQuYWRkKHZlY3Rvci5ub3JtYWxpemUoTWF0aC5taW4oZGlzdGFuY2UsIG1heERpc3RhbmNlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvb2wuX21vdmVDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9vbC5fcG9pbnQgPSBwdDtcbiAgICAgICAgdG9vbC5fbGFzdFBvaW50ID0gdG9vbFBvaW50IHx8IHB0O1xuXG4gICAgICAgIGlmIChtb3VzZS5kb3duKSB7XG4gICAgICAgICAgdG9vbC5fbW92ZUNvdW50ID0gLTE7XG4gICAgICAgICAgdG9vbC5fZG93blBvaW50ID0gcHQ7XG4gICAgICAgICAgdG9vbC5fZG93bkNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW1pdCgpIHtcbiAgICAgICAgaWYgKHJlc3BvbmRzKSB7XG4gICAgICAgICAgY2FsbGVkID0gdG9vbC5lbWl0KHR5cGUsIG5ldyBUb29sRXZlbnQodG9vbCwgdHlwZSwgZXZlbnQpKSB8fCBjYWxsZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vdXNlLmRvd24pIHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIGVtaXQoKTtcbiAgICAgIH0gZWxzZSBpZiAobW91c2UudXApIHtcbiAgICAgICAgdXBkYXRlKG51bGwsIG1heERpc3RhbmNlKTtcbiAgICAgICAgZW1pdCgpO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25kcykge1xuICAgICAgICB3aGlsZSAodXBkYXRlKG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSkpIGVtaXQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxlZDtcbiAgICB9XG4gIH0pO1xuICB2YXIgVHdlZW4gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG4gICAgX2NsYXNzOiAnVHdlZW4nLFxuICAgIHN0YXRpY3M6IHtcbiAgICAgIGVhc2luZ3M6IHtcbiAgICAgICAgbGluZWFyOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0ICogdDtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAyICogKDIgLSB0KSAqIHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJbkN1YmljOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0ICogdCAqIHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCA8IDAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xuICAgICAgICB9LFxuICAgICAgICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLSAtLXQgKiB0ICogdCAqIHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0IDwgMC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqIC0tdCAqIHQgKiB0ICogdDtcbiAgICAgICAgfSxcbiAgICAgICAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuICAgICAgICB9LFxuICAgICAgICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIDEgKyAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICAgICAgICB9LFxuICAgICAgICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCA8IDAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBUd2VlbihvYmplY3QsIGZyb20sIHRvLCBkdXJhdGlvbiwgZWFzaW5nLCBzdGFydCkge1xuICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBlYXNpbmc7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgICB0aGlzLnR5cGUgPSBpc0Z1bmN0aW9uID8gdHlwZSA6IHR5cGUgPT09ICdzdHJpbmcnID8gZWFzaW5nIDogJ2xpbmVhcic7XG4gICAgICB0aGlzLmVhc2luZyA9IGlzRnVuY3Rpb24gPyBlYXNpbmcgOiBUd2Vlbi5lYXNpbmdzW3RoaXMudHlwZV07XG4gICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3RoZW4gPSBudWxsO1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgIHZhciBzdGF0ZSA9IGZyb20gfHwgdG87XG4gICAgICB0aGlzLl9rZXlzID0gc3RhdGUgPyBPYmplY3Qua2V5cyhzdGF0ZSkgOiBbXTtcbiAgICAgIHRoaXMuX3BhcnNlZEtleXMgPSB0aGlzLl9wYXJzZUtleXModGhpcy5fa2V5cyk7XG4gICAgICB0aGlzLl9mcm9tID0gc3RhdGUgJiYgdGhpcy5fZ2V0U3RhdGUoZnJvbSk7XG4gICAgICB0aGlzLl90byA9IHN0YXRlICYmIHRoaXMuX2dldFN0YXRlKHRvKTtcblxuICAgICAgaWYgKHN0YXJ0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0aGVuOiBmdW5jdGlvbiAodGhlbikge1xuICAgICAgdGhpcy5fdGhlbiA9IHRoZW47XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgICAgcHJvZ3Jlc3MgPSAxO1xuICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhY3RvciA9IHRoaXMuZWFzaW5nKHByb2dyZXNzKSxcbiAgICAgICAgICAgIGtleXMgPSB0aGlzLl9rZXlzLFxuICAgICAgICAgICAgZ2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUoZmFjdG9yLCBwcm9ncmVzcykgOiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMgJiYga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgICAgZnJvbSA9IGdldFZhbHVlKHRoaXMuX2Zyb21ba2V5XSksXG4gICAgICAgICAgICAgIHRvID0gZ2V0VmFsdWUodGhpcy5fdG9ba2V5XSksXG4gICAgICAgICAgICAgIHZhbHVlID0gZnJvbSAmJiB0byAmJiBmcm9tLl9fYWRkICYmIHRvLl9fYWRkID8gdG8uX19zdWJ0cmFjdChmcm9tKS5fX211bHRpcGx5KGZhY3RvcikuX19hZGQoZnJvbSkgOiAodG8gLSBmcm9tKSAqIGZhY3RvciArIGZyb207XG5cbiAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eSh0aGlzLl9wYXJzZWRLZXlzW2tleV0sIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnJlc3BvbmRzKCd1cGRhdGUnKSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbmV3IEJhc2Uoe1xuICAgICAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICAgICAgZmFjdG9yOiBmYWN0b3JcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucnVubmluZyAmJiB0aGlzLl90aGVuKSB7XG4gICAgICAgICAgdGhpcy5fdGhlbih0aGlzLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfZXZlbnRzOiB7XG4gICAgICBvblVwZGF0ZToge31cbiAgICB9LFxuICAgIF9oYW5kbGVGcmFtZTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgIHZhciBzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWUsXG4gICAgICAgICAgcHJvZ3Jlc3MgPSBzdGFydFRpbWUgPyAodGltZSAtIHN0YXJ0VGltZSkgLyB0aGlzLmR1cmF0aW9uIDogMDtcblxuICAgICAgaWYgKCFzdGFydFRpbWUpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGUocHJvZ3Jlc3MpO1xuICAgIH0sXG4gICAgX2dldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cyxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgIHBhdGggPSB0aGlzLl9wYXJzZWRLZXlzW2tleV0sXG4gICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5fZ2V0UHJvcGVydHkocGF0aCksXG4gICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSB0aGlzLl9yZXNvbHZlVmFsdWUoY3VycmVudCwgc3RhdGVba2V5XSk7XG5cbiAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwYXRoLCByZXNvbHZlZCk7XG5cbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2dldFByb3BlcnR5KHBhdGgpO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgJiYgdmFsdWUuY2xvbmUgPyB2YWx1ZS5jbG9uZSgpIDogdmFsdWU7XG5cbiAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwYXRoLCBjdXJyZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGN1cnJlbnQgJiYgY3VycmVudC5jbG9uZSA/IGN1cnJlbnQuY2xvbmUoKSA6IGN1cnJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgX3Jlc29sdmVWYWx1ZTogZnVuY3Rpb24gKGN1cnJlbnQsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHZhciBvcGVyYXRvciA9IHZhbHVlWzBdO1xuICAgICAgICAgIHJldHVybiBvcGVyYXRvciAmJiBvcGVyYXRvci5tYXRjaCAmJiBvcGVyYXRvci5tYXRjaCgvXlsrXFwtXFwqXFwvXT0vKSA/IHRoaXMuX2NhbGN1bGF0ZShjdXJyZW50LCBvcGVyYXRvclswXSwgdmFsdWVbMV0pIDogdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eWytcXC0qL109KC4qKS8pO1xuXG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShtYXRjaFsxXS5yZXBsYWNlKC8oWydcIl0pPyhbYS16QS1aMC05X10rKShbJ1wiXSk/Oi9nLCAnXCIkMlwiOiAnKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlKGN1cnJlbnQsIHZhbHVlWzBdLCBwYXJzZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBfY2FsY3VsYXRlOiBmdW5jdGlvbiAobGVmdCwgb3BlcmF0b3IsIHJpZ2h0KSB7XG4gICAgICByZXR1cm4gcGFwZXIuUGFwZXJTY3JpcHQuY2FsY3VsYXRlQmluYXJ5KGxlZnQsIG9wZXJhdG9yLCByaWdodCk7XG4gICAgfSxcbiAgICBfcGFyc2VLZXlzOiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgdmFyIHBhcnNlZCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLFxuICAgICAgICAgICAgcGF0aCA9IGtleS5yZXBsYWNlKC9cXC4oW14uXSopL2csICcvJDEnKS5yZXBsYWNlKC9cXFtbJ1wiXT8oW14nXCJcXF1dKilbJ1wiXT9cXF0vZywgJy8kMScpO1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9LFxuICAgIF9nZXRQcm9wZXJ0eTogZnVuY3Rpb24gKHBhdGgsIG9mZnNldCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMub2JqZWN0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoIC0gKG9mZnNldCB8fCAwKTsgaSA8IGwgJiYgb2JqOyBpKyspIHtcbiAgICAgICAgb2JqID0gb2JqW3BhdGhbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgX3NldFByb3BlcnR5OiBmdW5jdGlvbiAocGF0aCwgdmFsdWUpIHtcbiAgICAgIHZhciBkZXN0ID0gdGhpcy5fZ2V0UHJvcGVydHkocGF0aCwgMSk7XG5cbiAgICAgIGlmIChkZXN0KSB7XG4gICAgICAgIGRlc3RbcGF0aFtwYXRoLmxlbmd0aCAtIDFdXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBIdHRwID0ge1xuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgeGhyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKChvcHRpb25zLm1ldGhvZCB8fCAnZ2V0JykudG9VcHBlckNhc2UoKSwgb3B0aW9ucy51cmwsIEJhc2UucGljayhvcHRpb25zLmFzeW5jLCB0cnVlKSk7XG4gICAgICBpZiAob3B0aW9ucy5taW1lVHlwZSkgeGhyLm92ZXJyaWRlTWltZVR5cGUob3B0aW9ucy5taW1lVHlwZSk7XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDAgfHwgc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbkxvYWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25Mb2FkLmNhbGwoeGhyLCB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLm9uZXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgbWVzc2FnZSA9ICdDb3VsZCBub3QgbG9hZCBcIicgKyBvcHRpb25zLnVybCArICdcIiAoU3RhdHVzOiAnICsgc3RhdHVzICsgJyknO1xuXG4gICAgICAgIGlmIChvcHRpb25zLm9uRXJyb3IpIHtcbiAgICAgICAgICBvcHRpb25zLm9uRXJyb3IobWVzc2FnZSwgc3RhdHVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB4aHIuc2VuZChudWxsKTtcbiAgICB9XG4gIH07XG4gIHZhciBDYW52YXNQcm92aWRlciA9IEJhc2UuZXhwb3J0cy5DYW52YXNQcm92aWRlciA9IHtcbiAgICBjYW52YXNlczogW10sXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKCF3aW5kb3cpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGNhbnZhcyxcbiAgICAgICAgICBjbGVhciA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2Ygd2lkdGggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGhlaWdodCA9IHdpZHRoLmhlaWdodDtcbiAgICAgICAgd2lkdGggPSB3aWR0aC53aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FudmFzZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMuY2FudmFzZXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2xlYXIgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnZhcyAnICsgY2FudmFzICsgJyBpcyB1bmFibGUgdG8gcHJvdmlkZSBhIDJEIGNvbnRleHQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgICBpZiAoY2xlYXIpIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGggKyAxLCBoZWlnaHQgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9LFxuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gY2FudmFzID8gY2FudmFzLmdldENvbnRleHQoJzJkJykgOiBudWxsO1xuICAgIH0sXG4gICAgcmVsZWFzZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgdmFyIGNhbnZhcyA9IG9iaiAmJiBvYmouY2FudmFzID8gb2JqLmNhbnZhcyA6IG9iajtcblxuICAgICAgaWYgKGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5yZXN0b3JlKCk7XG4gICAgICAgIHRoaXMuY2FudmFzZXMucHVzaChjYW52YXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIEJsZW5kTW9kZSA9IG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluLFxuICAgICAgICBtYXggPSBNYXRoLm1heCxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgIHNyLFxuICAgICAgICBzZyxcbiAgICAgICAgc2IsXG4gICAgICAgIHNhLFxuICAgICAgICBicixcbiAgICAgICAgYmcsXG4gICAgICAgIGJiLFxuICAgICAgICBiYSxcbiAgICAgICAgZHIsXG4gICAgICAgIGRnLFxuICAgICAgICBkYjtcblxuICAgIGZ1bmN0aW9uIGdldEx1bShyLCBnLCBiKSB7XG4gICAgICByZXR1cm4gMC4yOTg5ICogciArIDAuNTg3ICogZyArIDAuMTE0ICogYjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRMdW0ociwgZywgYiwgbCkge1xuICAgICAgdmFyIGQgPSBsIC0gZ2V0THVtKHIsIGcsIGIpO1xuICAgICAgZHIgPSByICsgZDtcbiAgICAgIGRnID0gZyArIGQ7XG4gICAgICBkYiA9IGIgKyBkO1xuICAgICAgdmFyIGwgPSBnZXRMdW0oZHIsIGRnLCBkYiksXG4gICAgICAgICAgbW4gPSBtaW4oZHIsIGRnLCBkYiksXG4gICAgICAgICAgbXggPSBtYXgoZHIsIGRnLCBkYik7XG5cbiAgICAgIGlmIChtbiA8IDApIHtcbiAgICAgICAgdmFyIGxtbiA9IGwgLSBtbjtcbiAgICAgICAgZHIgPSBsICsgKGRyIC0gbCkgKiBsIC8gbG1uO1xuICAgICAgICBkZyA9IGwgKyAoZGcgLSBsKSAqIGwgLyBsbW47XG4gICAgICAgIGRiID0gbCArIChkYiAtIGwpICogbCAvIGxtbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG14ID4gMjU1KSB7XG4gICAgICAgIHZhciBsbiA9IDI1NSAtIGwsXG4gICAgICAgICAgICBteGwgPSBteCAtIGw7XG4gICAgICAgIGRyID0gbCArIChkciAtIGwpICogbG4gLyBteGw7XG4gICAgICAgIGRnID0gbCArIChkZyAtIGwpICogbG4gLyBteGw7XG4gICAgICAgIGRiID0gbCArIChkYiAtIGwpICogbG4gLyBteGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2F0KHIsIGcsIGIpIHtcbiAgICAgIHJldHVybiBtYXgociwgZywgYikgLSBtaW4ociwgZywgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0U2F0KHIsIGcsIGIsIHMpIHtcbiAgICAgIHZhciBjb2wgPSBbciwgZywgYl0sXG4gICAgICAgICAgbXggPSBtYXgociwgZywgYiksXG4gICAgICAgICAgbW4gPSBtaW4ociwgZywgYiksXG4gICAgICAgICAgbWQ7XG4gICAgICBtbiA9IG1uID09PSByID8gMCA6IG1uID09PSBnID8gMSA6IDI7XG4gICAgICBteCA9IG14ID09PSByID8gMCA6IG14ID09PSBnID8gMSA6IDI7XG4gICAgICBtZCA9IG1pbihtbiwgbXgpID09PSAwID8gbWF4KG1uLCBteCkgPT09IDEgPyAyIDogMSA6IDA7XG5cbiAgICAgIGlmIChjb2xbbXhdID4gY29sW21uXSkge1xuICAgICAgICBjb2xbbWRdID0gKGNvbFttZF0gLSBjb2xbbW5dKSAqIHMgLyAoY29sW214XSAtIGNvbFttbl0pO1xuICAgICAgICBjb2xbbXhdID0gcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbFttZF0gPSBjb2xbbXhdID0gMDtcbiAgICAgIH1cblxuICAgICAgY29sW21uXSA9IDA7XG4gICAgICBkciA9IGNvbFswXTtcbiAgICAgIGRnID0gY29sWzFdO1xuICAgICAgZGIgPSBjb2xbMl07XG4gICAgfVxuXG4gICAgdmFyIG1vZGVzID0ge1xuICAgICAgbXVsdGlwbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBiciAqIHNyIC8gMjU1O1xuICAgICAgICBkZyA9IGJnICogc2cgLyAyNTU7XG4gICAgICAgIGRiID0gYmIgKiBzYiAvIDI1NTtcbiAgICAgIH0sXG4gICAgICBzY3JlZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBiciArIHNyIC0gYnIgKiBzciAvIDI1NTtcbiAgICAgICAgZGcgPSBiZyArIHNnIC0gYmcgKiBzZyAvIDI1NTtcbiAgICAgICAgZGIgPSBiYiArIHNiIC0gYmIgKiBzYiAvIDI1NTtcbiAgICAgIH0sXG4gICAgICBvdmVybGF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gYnIgPCAxMjggPyAyICogYnIgKiBzciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NTtcbiAgICAgICAgZGcgPSBiZyA8IDEyOCA/IDIgKiBiZyAqIHNnIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1O1xuICAgICAgICBkYiA9IGJiIDwgMTI4ID8gMiAqIGJiICogc2IgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJiKSAqICgyNTUgLSBzYikgLyAyNTU7XG4gICAgICB9LFxuICAgICAgJ3NvZnQtbGlnaHQnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gc3IgKiBiciAvIDI1NTtcbiAgICAgICAgZHIgPSB0ICsgYnIgKiAoMjU1IC0gKDI1NSAtIGJyKSAqICgyNTUgLSBzcikgLyAyNTUgLSB0KSAvIDI1NTtcbiAgICAgICAgdCA9IHNnICogYmcgLyAyNTU7XG4gICAgICAgIGRnID0gdCArIGJnICogKDI1NSAtICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1IC0gdCkgLyAyNTU7XG4gICAgICAgIHQgPSBzYiAqIGJiIC8gMjU1O1xuICAgICAgICBkYiA9IHQgKyBiYiAqICgyNTUgLSAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NSAtIHQpIC8gMjU1O1xuICAgICAgfSxcbiAgICAgICdoYXJkLWxpZ2h0JzogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IHNyIDwgMTI4ID8gMiAqIHNyICogYnIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNyKSAqICgyNTUgLSBicikgLyAyNTU7XG4gICAgICAgIGRnID0gc2cgPCAxMjggPyAyICogc2cgKiBiZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc2cpICogKDI1NSAtIGJnKSAvIDI1NTtcbiAgICAgICAgZGIgPSBzYiA8IDEyOCA/IDIgKiBzYiAqIGJiIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzYikgKiAoMjU1IC0gYmIpIC8gMjU1O1xuICAgICAgfSxcbiAgICAgICdjb2xvci1kb2RnZSc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBiciA9PT0gMCA/IDAgOiBzciA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYnIgLyAoMjU1IC0gc3IpKTtcbiAgICAgICAgZGcgPSBiZyA9PT0gMCA/IDAgOiBzZyA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYmcgLyAoMjU1IC0gc2cpKTtcbiAgICAgICAgZGIgPSBiYiA9PT0gMCA/IDAgOiBzYiA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYmIgLyAoMjU1IC0gc2IpKTtcbiAgICAgIH0sXG4gICAgICAnY29sb3ItYnVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBiciA9PT0gMjU1ID8gMjU1IDogc3IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBicikgKiAyNTUgLyBzcik7XG4gICAgICAgIGRnID0gYmcgPT09IDI1NSA/IDI1NSA6IHNnID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmcpICogMjU1IC8gc2cpO1xuICAgICAgICBkYiA9IGJiID09PSAyNTUgPyAyNTUgOiBzYiA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJiKSAqIDI1NSAvIHNiKTtcbiAgICAgIH0sXG4gICAgICBkYXJrZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBiciA8IHNyID8gYnIgOiBzcjtcbiAgICAgICAgZGcgPSBiZyA8IHNnID8gYmcgOiBzZztcbiAgICAgICAgZGIgPSBiYiA8IHNiID8gYmIgOiBzYjtcbiAgICAgIH0sXG4gICAgICBsaWdodGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyID0gYnIgPiBzciA/IGJyIDogc3I7XG4gICAgICAgIGRnID0gYmcgPiBzZyA/IGJnIDogc2c7XG4gICAgICAgIGRiID0gYmIgPiBzYiA/IGJiIDogc2I7XG4gICAgICB9LFxuICAgICAgZGlmZmVyZW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IGJyIC0gc3I7XG4gICAgICAgIGlmIChkciA8IDApIGRyID0gLWRyO1xuICAgICAgICBkZyA9IGJnIC0gc2c7XG4gICAgICAgIGlmIChkZyA8IDApIGRnID0gLWRnO1xuICAgICAgICBkYiA9IGJiIC0gc2I7XG4gICAgICAgIGlmIChkYiA8IDApIGRiID0gLWRiO1xuICAgICAgfSxcbiAgICAgIGV4Y2x1c2lvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IGJyICsgc3IgKiAoMjU1IC0gYnIgLSBicikgLyAyNTU7XG4gICAgICAgIGRnID0gYmcgKyBzZyAqICgyNTUgLSBiZyAtIGJnKSAvIDI1NTtcbiAgICAgICAgZGIgPSBiYiArIHNiICogKDI1NSAtIGJiIC0gYmIpIC8gMjU1O1xuICAgICAgfSxcbiAgICAgIGh1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTYXQoc3IsIHNnLCBzYiwgZ2V0U2F0KGJyLCBiZywgYmIpKTtcbiAgICAgICAgc2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG4gICAgICB9LFxuICAgICAgc2F0dXJhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTYXQoYnIsIGJnLCBiYiwgZ2V0U2F0KHNyLCBzZywgc2IpKTtcbiAgICAgICAgc2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG4gICAgICB9LFxuICAgICAgbHVtaW5vc2l0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRMdW0oYnIsIGJnLCBiYiwgZ2V0THVtKHNyLCBzZywgc2IpKTtcbiAgICAgIH0sXG4gICAgICBjb2xvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRMdW0oc3IsIHNnLCBzYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcbiAgICAgIH0sXG4gICAgICBhZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSBtaW4oYnIgKyBzciwgMjU1KTtcbiAgICAgICAgZGcgPSBtaW4oYmcgKyBzZywgMjU1KTtcbiAgICAgICAgZGIgPSBtaW4oYmIgKyBzYiwgMjU1KTtcbiAgICAgIH0sXG4gICAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IG1heChiciAtIHNyLCAwKTtcbiAgICAgICAgZGcgPSBtYXgoYmcgLSBzZywgMCk7XG4gICAgICAgIGRiID0gbWF4KGJiIC0gc2IsIDApO1xuICAgICAgfSxcbiAgICAgIGF2ZXJhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZHIgPSAoYnIgKyBzcikgLyAyO1xuICAgICAgICBkZyA9IChiZyArIHNnKSAvIDI7XG4gICAgICAgIGRiID0gKGJiICsgc2IpIC8gMjtcbiAgICAgIH0sXG4gICAgICBuZWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBkciA9IDI1NSAtIGFicygyNTUgLSBzciAtIGJyKTtcbiAgICAgICAgZGcgPSAyNTUgLSBhYnMoMjU1IC0gc2cgLSBiZyk7XG4gICAgICAgIGRiID0gMjU1IC0gYWJzKDI1NSAtIHNiIC0gYmIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG5hdGl2ZU1vZGVzID0gdGhpcy5uYXRpdmVNb2RlcyA9IEJhc2UuZWFjaChbJ3NvdXJjZS1vdmVyJywgJ3NvdXJjZS1pbicsICdzb3VyY2Utb3V0JywgJ3NvdXJjZS1hdG9wJywgJ2Rlc3RpbmF0aW9uLW92ZXInLCAnZGVzdGluYXRpb24taW4nLCAnZGVzdGluYXRpb24tb3V0JywgJ2Rlc3RpbmF0aW9uLWF0b3AnLCAnbGlnaHRlcicsICdkYXJrZXInLCAnY29weScsICd4b3InXSwgZnVuY3Rpb24gKG1vZGUpIHtcbiAgICAgIHRoaXNbbW9kZV0gPSB0cnVlO1xuICAgIH0sIHt9KTtcbiAgICB2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIEJhc2UuZWFjaChtb2RlcywgZnVuY3Rpb24gKGZ1bmMsIG1vZGUpIHtcbiAgICAgICAgdmFyIGRhcmtlbiA9IG1vZGUgPT09ICdkYXJrZW4nLFxuICAgICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnIzMwMCcgOiAnI2EwMCc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuXG4gICAgICAgICAgaWYgKGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPT09IG1vZGUpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnI2EwMCcgOiAnIzMwMCc7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICAgICAgICBvayA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVswXSAhPT0gZGFya2VuID8gMTcwIDogNTE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIG5hdGl2ZU1vZGVzW21vZGVdID0gb2s7XG4gICAgICB9KTtcbiAgICAgIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbiAobW9kZSwgc3JjQ29udGV4dCwgZHN0Q29udGV4dCwgYWxwaGEsIG9mZnNldCkge1xuICAgICAgdmFyIHNyY0NhbnZhcyA9IHNyY0NvbnRleHQuY2FudmFzLFxuICAgICAgICAgIG5vcm1hbCA9IG1vZGUgPT09ICdub3JtYWwnO1xuXG4gICAgICBpZiAobm9ybWFsIHx8IG5hdGl2ZU1vZGVzW21vZGVdKSB7XG4gICAgICAgIGRzdENvbnRleHQuc2F2ZSgpO1xuICAgICAgICBkc3RDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgZHN0Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgICBpZiAoIW5vcm1hbCkgZHN0Q29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuICAgICAgICBkc3RDb250ZXh0LmRyYXdJbWFnZShzcmNDYW52YXMsIG9mZnNldC54LCBvZmZzZXQueSk7XG4gICAgICAgIGRzdENvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb2Nlc3MgPSBtb2Rlc1ttb2RlXTtcbiAgICAgICAgaWYgKCFwcm9jZXNzKSByZXR1cm47XG4gICAgICAgIHZhciBkc3REYXRhID0gZHN0Q29udGV4dC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLFxuICAgICAgICAgICAgZHN0ID0gZHN0RGF0YS5kYXRhLFxuICAgICAgICAgICAgc3JjID0gc3JjQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgc3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KS5kYXRhO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZHN0Lmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICAgIHNyID0gc3JjW2ldO1xuICAgICAgICAgIGJyID0gZHN0W2ldO1xuICAgICAgICAgIHNnID0gc3JjW2kgKyAxXTtcbiAgICAgICAgICBiZyA9IGRzdFtpICsgMV07XG4gICAgICAgICAgc2IgPSBzcmNbaSArIDJdO1xuICAgICAgICAgIGJiID0gZHN0W2kgKyAyXTtcbiAgICAgICAgICBzYSA9IHNyY1tpICsgM107XG4gICAgICAgICAgYmEgPSBkc3RbaSArIDNdO1xuICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICB2YXIgYTEgPSBzYSAqIGFscGhhIC8gMjU1LFxuICAgICAgICAgICAgICBhMiA9IDEgLSBhMTtcbiAgICAgICAgICBkc3RbaV0gPSBhMSAqIGRyICsgYTIgKiBicjtcbiAgICAgICAgICBkc3RbaSArIDFdID0gYTEgKiBkZyArIGEyICogYmc7XG4gICAgICAgICAgZHN0W2kgKyAyXSA9IGExICogZGIgKyBhMiAqIGJiO1xuICAgICAgICAgIGRzdFtpICsgM10gPSBzYSAqIGFscGhhICsgYTIgKiBiYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRzdENvbnRleHQucHV0SW1hZ2VEYXRhKGRzdERhdGEsIG9mZnNldC54LCBvZmZzZXQueSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuICB2YXIgU3ZnRWxlbWVudCA9IG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN2ZyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgICAgIHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMnLFxuICAgICAgICB4bGluayA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlID0ge1xuICAgICAgaHJlZjogeGxpbmssXG4gICAgICB4bGluazogeG1sbnMsXG4gICAgICB4bWxuczogeG1sbnMgKyAnLycsXG4gICAgICAneG1sbnM6eGxpbmsnOiB4bWxucyArICcvJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGUodGFnLCBhdHRyaWJ1dGVzLCBmb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiBzZXQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2ZywgdGFnKSwgYXR0cmlidXRlcywgZm9ybWF0dGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQobm9kZSwgbmFtZSkge1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZVtuYW1lXSxcbiAgICAgICAgICB2YWx1ZSA9IG5hbWVzcGFjZSA/IG5vZGUuZ2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lKSA6IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgcmV0dXJuIHZhbHVlID09PSAnbnVsbCcgPyBudWxsIDogdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KG5vZGUsIGF0dHJpYnV0ZXMsIGZvcm1hdHRlcikge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV0sXG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2VbbmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGZvcm1hdHRlcikgdmFsdWUgPSBmb3JtYXR0ZXIubnVtYmVyKHZhbHVlKTtcblxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN2Zzogc3ZnLFxuICAgICAgeG1sbnM6IHhtbG5zLFxuICAgICAgeGxpbms6IHhsaW5rLFxuICAgICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgICBnZXQ6IGdldCxcbiAgICAgIHNldDogc2V0XG4gICAgfTtcbiAgfSgpO1xuICB2YXIgU3ZnU3R5bGVzID0gQmFzZS5lYWNoKHtcbiAgICBmaWxsQ29sb3I6IFsnZmlsbCcsICdjb2xvciddLFxuICAgIGZpbGxSdWxlOiBbJ2ZpbGwtcnVsZScsICdzdHJpbmcnXSxcbiAgICBzdHJva2VDb2xvcjogWydzdHJva2UnLCAnY29sb3InXSxcbiAgICBzdHJva2VXaWR0aDogWydzdHJva2Utd2lkdGgnLCAnbnVtYmVyJ10sXG4gICAgc3Ryb2tlQ2FwOiBbJ3N0cm9rZS1saW5lY2FwJywgJ3N0cmluZyddLFxuICAgIHN0cm9rZUpvaW46IFsnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cmluZyddLFxuICAgIHN0cm9rZVNjYWxpbmc6IFsndmVjdG9yLWVmZmVjdCcsICdsb29rdXAnLCB7XG4gICAgICB0cnVlOiAnbm9uZScsXG4gICAgICBmYWxzZTogJ25vbi1zY2FsaW5nLXN0cm9rZSdcbiAgICB9LCBmdW5jdGlvbiAoaXRlbSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiAhdmFsdWUgJiYgKGl0ZW0gaW5zdGFuY2VvZiBQYXRoSXRlbSB8fCBpdGVtIGluc3RhbmNlb2YgU2hhcGUgfHwgaXRlbSBpbnN0YW5jZW9mIFRleHRJdGVtKTtcbiAgICB9XSxcbiAgICBtaXRlckxpbWl0OiBbJ3N0cm9rZS1taXRlcmxpbWl0JywgJ251bWJlciddLFxuICAgIGRhc2hBcnJheTogWydzdHJva2UtZGFzaGFycmF5JywgJ2FycmF5J10sXG4gICAgZGFzaE9mZnNldDogWydzdHJva2UtZGFzaG9mZnNldCcsICdudW1iZXInXSxcbiAgICBmb250RmFtaWx5OiBbJ2ZvbnQtZmFtaWx5JywgJ3N0cmluZyddLFxuICAgIGZvbnRXZWlnaHQ6IFsnZm9udC13ZWlnaHQnLCAnc3RyaW5nJ10sXG4gICAgZm9udFNpemU6IFsnZm9udC1zaXplJywgJ251bWJlciddLFxuICAgIGp1c3RpZmljYXRpb246IFsndGV4dC1hbmNob3InLCAnbG9va3VwJywge1xuICAgICAgbGVmdDogJ3N0YXJ0JyxcbiAgICAgIGNlbnRlcjogJ21pZGRsZScsXG4gICAgICByaWdodDogJ2VuZCdcbiAgICB9XSxcbiAgICBvcGFjaXR5OiBbJ29wYWNpdHknLCAnbnVtYmVyJ10sXG4gICAgYmxlbmRNb2RlOiBbJ21peC1ibGVuZC1tb2RlJywgJ3N0eWxlJ11cbiAgfSwgZnVuY3Rpb24gKGVudHJ5LCBrZXkpIHtcbiAgICB2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuICAgICAgICBsb29rdXAgPSBlbnRyeVsyXTtcbiAgICB0aGlzW2tleV0gPSB7XG4gICAgICB0eXBlOiBlbnRyeVsxXSxcbiAgICAgIHByb3BlcnR5OiBrZXksXG4gICAgICBhdHRyaWJ1dGU6IGVudHJ5WzBdLFxuICAgICAgdG9TVkc6IGxvb2t1cCxcbiAgICAgIGZyb21TVkc6IGxvb2t1cCAmJiBCYXNlLmVhY2gobG9va3VwLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpc1t2YWx1ZV0gPSBuYW1lO1xuICAgICAgfSwge30pLFxuICAgICAgZXhwb3J0RmlsdGVyOiBlbnRyeVszXSxcbiAgICAgIGdldDogJ2dldCcgKyBwYXJ0LFxuICAgICAgc2V0OiAnc2V0JyArIHBhcnRcbiAgICB9O1xuICB9LCB7fSk7XG4gIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvcm1hdHRlcjtcblxuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybShtYXRyaXgsIGNvb3JkaW5hdGVzLCBjZW50ZXIpIHtcbiAgICAgIHZhciBhdHRycyA9IG5ldyBCYXNlKCksXG4gICAgICAgICAgdHJhbnMgPSBtYXRyaXguZ2V0VHJhbnNsYXRpb24oKTtcblxuICAgICAgaWYgKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHZhciBwb2ludDtcblxuICAgICAgICBpZiAobWF0cml4LmlzSW52ZXJ0aWJsZSgpKSB7XG4gICAgICAgICAgbWF0cml4ID0gbWF0cml4Ll9zaGlmdGxlc3MoKTtcbiAgICAgICAgICBwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0cmFucyk7XG4gICAgICAgICAgdHJhbnMgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50ID0gbmV3IFBvaW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyc1tjZW50ZXIgPyAnY3gnIDogJ3gnXSA9IHBvaW50Lng7XG4gICAgICAgIGF0dHJzW2NlbnRlciA/ICdjeScgOiAneSddID0gcG9pbnQueTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRyaXguaXNJZGVudGl0eSgpKSB7XG4gICAgICAgIHZhciBkZWNvbXBvc2VkID0gbWF0cml4LmRlY29tcG9zZSgpO1xuXG4gICAgICAgIGlmIChkZWNvbXBvc2VkKSB7XG4gICAgICAgICAgdmFyIHBhcnRzID0gW10sXG4gICAgICAgICAgICAgIGFuZ2xlID0gZGVjb21wb3NlZC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgc2NhbGUgPSBkZWNvbXBvc2VkLnNjYWxpbmcsXG4gICAgICAgICAgICAgIHNrZXcgPSBkZWNvbXBvc2VkLnNrZXdpbmc7XG4gICAgICAgICAgaWYgKHRyYW5zICYmICF0cmFucy5pc1plcm8oKSkgcGFydHMucHVzaCgndHJhbnNsYXRlKCcgKyBmb3JtYXR0ZXIucG9pbnQodHJhbnMpICsgJyknKTtcbiAgICAgICAgICBpZiAoYW5nbGUpIHBhcnRzLnB1c2goJ3JvdGF0ZSgnICsgZm9ybWF0dGVyLm51bWJlcihhbmdsZSkgKyAnKScpO1xuICAgICAgICAgIGlmICghTnVtZXJpY2FsLmlzWmVybyhzY2FsZS54IC0gMSkgfHwgIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueSAtIDEpKSBwYXJ0cy5wdXNoKCdzY2FsZSgnICsgZm9ybWF0dGVyLnBvaW50KHNjYWxlKSArICcpJyk7XG4gICAgICAgICAgaWYgKHNrZXcueCkgcGFydHMucHVzaCgnc2tld1goJyArIGZvcm1hdHRlci5udW1iZXIoc2tldy54KSArICcpJyk7XG4gICAgICAgICAgaWYgKHNrZXcueSkgcGFydHMucHVzaCgnc2tld1koJyArIGZvcm1hdHRlci5udW1iZXIoc2tldy55KSArICcpJyk7XG4gICAgICAgICAgYXR0cnMudHJhbnNmb3JtID0gcGFydHMuam9pbignICcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJzLnRyYW5zZm9ybSA9ICdtYXRyaXgoJyArIG1hdHJpeC5nZXRWYWx1ZXMoKS5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydEdyb3VwKGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpLFxuICAgICAgICAgIGNoaWxkcmVuID0gaXRlbS5fY2hpbGRyZW47XG4gICAgICB2YXIgbm9kZSA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdnJywgYXR0cnMsIGZvcm1hdHRlcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gZXhwb3J0U1ZHKGNoaWxkLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmlzQ2xpcE1hc2soKSkge1xuICAgICAgICAgICAgdmFyIGNsaXAgPSBTdmdFbGVtZW50LmNyZWF0ZSgnY2xpcFBhdGgnKTtcbiAgICAgICAgICAgIGNsaXAuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcbiAgICAgICAgICAgIHNldERlZmluaXRpb24oY2hpbGQsIGNsaXAsICdjbGlwJyk7XG4gICAgICAgICAgICBTdmdFbGVtZW50LnNldChub2RlLCB7XG4gICAgICAgICAgICAgICdjbGlwLXBhdGgnOiAndXJsKCMnICsgY2xpcC5pZCArICcpJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0UmFzdGVyKGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpLFxuICAgICAgICAgIHNpemUgPSBpdGVtLmdldFNpemUoKSxcbiAgICAgICAgICBpbWFnZSA9IGl0ZW0uZ2V0SW1hZ2UoKTtcbiAgICAgIGF0dHJzLnggLT0gc2l6ZS53aWR0aCAvIDI7XG4gICAgICBhdHRycy55IC09IHNpemUuaGVpZ2h0IC8gMjtcbiAgICAgIGF0dHJzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgIGF0dHJzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgYXR0cnMuaHJlZiA9IG9wdGlvbnMuZW1iZWRJbWFnZXMgPT0gZmFsc2UgJiYgaW1hZ2UgJiYgaW1hZ2Uuc3JjIHx8IGl0ZW0udG9EYXRhVVJMKCk7XG4gICAgICByZXR1cm4gU3ZnRWxlbWVudC5jcmVhdGUoJ2ltYWdlJywgYXR0cnMsIGZvcm1hdHRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0UGF0aChpdGVtLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbWF0Y2hTaGFwZXMgPSBvcHRpb25zLm1hdGNoU2hhcGVzO1xuXG4gICAgICBpZiAobWF0Y2hTaGFwZXMpIHtcbiAgICAgICAgdmFyIHNoYXBlID0gaXRlbS50b1NoYXBlKGZhbHNlKTtcbiAgICAgICAgaWYgKHNoYXBlKSByZXR1cm4gZXhwb3J0U2hhcGUoc2hhcGUsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VnbWVudHMgPSBpdGVtLl9zZWdtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuXG4gICAgICBpZiAobWF0Y2hTaGFwZXMgJiYgbGVuZ3RoID49IDIgJiYgIWl0ZW0uaGFzSGFuZGxlcygpKSB7XG4gICAgICAgIGlmIChsZW5ndGggPiAyKSB7XG4gICAgICAgICAgdHlwZSA9IGl0ZW0uX2Nsb3NlZCA/ICdwb2x5Z29uJyA6ICdwb2x5bGluZSc7XG4gICAgICAgICAgdmFyIHBhcnRzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGZvcm1hdHRlci5wb2ludChzZWdtZW50c1tpXS5fcG9pbnQpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdHRycy5wb2ludHMgPSBwYXJ0cy5qb2luKCcgJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9ICdsaW5lJztcbiAgICAgICAgICB2YXIgc3RhcnQgPSBzZWdtZW50c1swXS5fcG9pbnQsXG4gICAgICAgICAgICAgIGVuZCA9IHNlZ21lbnRzWzFdLl9wb2ludDtcbiAgICAgICAgICBhdHRycy5zZXQoe1xuICAgICAgICAgICAgeDE6IHN0YXJ0LngsXG4gICAgICAgICAgICB5MTogc3RhcnQueSxcbiAgICAgICAgICAgIHgyOiBlbmQueCxcbiAgICAgICAgICAgIHkyOiBlbmQueVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gJ3BhdGgnO1xuICAgICAgICBhdHRycy5kID0gaXRlbS5nZXRQYXRoRGF0YShudWxsLCBvcHRpb25zLnByZWNpc2lvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSh0eXBlLCBhdHRycywgZm9ybWF0dGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRTaGFwZShpdGVtKSB7XG4gICAgICB2YXIgdHlwZSA9IGl0ZW0uX3R5cGUsXG4gICAgICAgICAgcmFkaXVzID0gaXRlbS5fcmFkaXVzLFxuICAgICAgICAgIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSwgdHlwZSAhPT0gJ3JlY3RhbmdsZScpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcbiAgICAgICAgdHlwZSA9ICdyZWN0JztcbiAgICAgICAgdmFyIHNpemUgPSBpdGVtLl9zaXplLFxuICAgICAgICAgICAgd2lkdGggPSBzaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIGF0dHJzLnggLT0gd2lkdGggLyAyO1xuICAgICAgICBhdHRycy55IC09IGhlaWdodCAvIDI7XG4gICAgICAgIGF0dHJzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGF0dHJzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgaWYgKHJhZGl1cy5pc1plcm8oKSkgcmFkaXVzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhZGl1cykge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICBhdHRycy5yID0gcmFkaXVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJzLnJ4ID0gcmFkaXVzLndpZHRoO1xuICAgICAgICAgIGF0dHJzLnJ5ID0gcmFkaXVzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3ZnRWxlbWVudC5jcmVhdGUodHlwZSwgYXR0cnMsIGZvcm1hdHRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0Q29tcG91bmRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuICAgICAgdmFyIGRhdGEgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgIGlmIChkYXRhKSBhdHRycy5kID0gZGF0YTtcbiAgICAgIHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSgncGF0aCcsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydFN5bWJvbEl0ZW0oaXRlbSwgb3B0aW9ucykge1xuICAgICAgdmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IGl0ZW0uX2RlZmluaXRpb24sXG4gICAgICAgICAgbm9kZSA9IGdldERlZmluaXRpb24oZGVmaW5pdGlvbiwgJ3N5bWJvbCcpLFxuICAgICAgICAgIGRlZmluaXRpb25JdGVtID0gZGVmaW5pdGlvbi5faXRlbSxcbiAgICAgICAgICBib3VuZHMgPSBkZWZpbml0aW9uSXRlbS5nZXRTdHJva2VCb3VuZHMoKTtcblxuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIG5vZGUgPSBTdmdFbGVtZW50LmNyZWF0ZSgnc3ltYm9sJywge1xuICAgICAgICAgIHZpZXdCb3g6IGZvcm1hdHRlci5yZWN0YW5nbGUoYm91bmRzKVxuICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChleHBvcnRTVkcoZGVmaW5pdGlvbkl0ZW0sIG9wdGlvbnMpKTtcbiAgICAgICAgc2V0RGVmaW5pdGlvbihkZWZpbml0aW9uLCBub2RlLCAnc3ltYm9sJyk7XG4gICAgICB9XG5cbiAgICAgIGF0dHJzLmhyZWYgPSAnIycgKyBub2RlLmlkO1xuICAgICAgYXR0cnMueCArPSBib3VuZHMueDtcbiAgICAgIGF0dHJzLnkgKz0gYm91bmRzLnk7XG4gICAgICBhdHRycy53aWR0aCA9IGJvdW5kcy53aWR0aDtcbiAgICAgIGF0dHJzLmhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG4gICAgICBhdHRycy5vdmVyZmxvdyA9ICd2aXNpYmxlJztcbiAgICAgIHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSgndXNlJywgYXR0cnMsIGZvcm1hdHRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0R3JhZGllbnQoY29sb3IpIHtcbiAgICAgIHZhciBncmFkaWVudE5vZGUgPSBnZXREZWZpbml0aW9uKGNvbG9yLCAnY29sb3InKTtcblxuICAgICAgaWYgKCFncmFkaWVudE5vZGUpIHtcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gY29sb3IuZ2V0R3JhZGllbnQoKSxcbiAgICAgICAgICAgIHJhZGlhbCA9IGdyYWRpZW50Ll9yYWRpYWwsXG4gICAgICAgICAgICBvcmlnaW4gPSBjb2xvci5nZXRPcmlnaW4oKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gY29sb3IuZ2V0RGVzdGluYXRpb24oKSxcbiAgICAgICAgICAgIGF0dHJzO1xuXG4gICAgICAgIGlmIChyYWRpYWwpIHtcbiAgICAgICAgICBhdHRycyA9IHtcbiAgICAgICAgICAgIGN4OiBvcmlnaW4ueCxcbiAgICAgICAgICAgIGN5OiBvcmlnaW4ueSxcbiAgICAgICAgICAgIHI6IG9yaWdpbi5nZXREaXN0YW5jZShkZXN0aW5hdGlvbilcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBjb2xvci5nZXRIaWdobGlnaHQoKTtcblxuICAgICAgICAgIGlmIChoaWdobGlnaHQpIHtcbiAgICAgICAgICAgIGF0dHJzLmZ4ID0gaGlnaGxpZ2h0Lng7XG4gICAgICAgICAgICBhdHRycy5meSA9IGhpZ2hsaWdodC55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRycyA9IHtcbiAgICAgICAgICAgIHgxOiBvcmlnaW4ueCxcbiAgICAgICAgICAgIHkxOiBvcmlnaW4ueSxcbiAgICAgICAgICAgIHgyOiBkZXN0aW5hdGlvbi54LFxuICAgICAgICAgICAgeTI6IGRlc3RpbmF0aW9uLnlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cnMuZ3JhZGllbnRVbml0cyA9ICd1c2VyU3BhY2VPblVzZSc7XG4gICAgICAgIGdyYWRpZW50Tm9kZSA9IFN2Z0VsZW1lbnQuY3JlYXRlKChyYWRpYWwgPyAncmFkaWFsJyA6ICdsaW5lYXInKSArICdHcmFkaWVudCcsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuICAgICAgICB2YXIgc3RvcHMgPSBncmFkaWVudC5fc3RvcHM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW2ldLFxuICAgICAgICAgICAgICBzdG9wQ29sb3IgPSBzdG9wLl9jb2xvcixcbiAgICAgICAgICAgICAgYWxwaGEgPSBzdG9wQ29sb3IuZ2V0QWxwaGEoKSxcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gc3RvcC5fb2Zmc2V0O1xuICAgICAgICAgIGF0dHJzID0ge1xuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgPT0gbnVsbCA/IGkgLyAobCAtIDEpIDogb2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoc3RvcENvbG9yKSBhdHRyc1snc3RvcC1jb2xvciddID0gc3RvcENvbG9yLnRvQ1NTKHRydWUpO1xuICAgICAgICAgIGlmIChhbHBoYSA8IDEpIGF0dHJzWydzdG9wLW9wYWNpdHknXSA9IGFscGhhO1xuICAgICAgICAgIGdyYWRpZW50Tm9kZS5hcHBlbmRDaGlsZChTdmdFbGVtZW50LmNyZWF0ZSgnc3RvcCcsIGF0dHJzLCBmb3JtYXR0ZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldERlZmluaXRpb24oY29sb3IsIGdyYWRpZW50Tm9kZSwgJ2NvbG9yJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAndXJsKCMnICsgZ3JhZGllbnROb2RlLmlkICsgJyknO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydFRleHQoaXRlbSkge1xuICAgICAgdmFyIG5vZGUgPSBTdmdFbGVtZW50LmNyZWF0ZSgndGV4dCcsIGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpLCBmb3JtYXR0ZXIpO1xuICAgICAgbm9kZS50ZXh0Q29udGVudCA9IGl0ZW0uX2NvbnRlbnQ7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICB2YXIgZXhwb3J0ZXJzID0ge1xuICAgICAgR3JvdXA6IGV4cG9ydEdyb3VwLFxuICAgICAgTGF5ZXI6IGV4cG9ydEdyb3VwLFxuICAgICAgUmFzdGVyOiBleHBvcnRSYXN0ZXIsXG4gICAgICBQYXRoOiBleHBvcnRQYXRoLFxuICAgICAgU2hhcGU6IGV4cG9ydFNoYXBlLFxuICAgICAgQ29tcG91bmRQYXRoOiBleHBvcnRDb21wb3VuZFBhdGgsXG4gICAgICBTeW1ib2xJdGVtOiBleHBvcnRTeW1ib2xJdGVtLFxuICAgICAgUG9pbnRUZXh0OiBleHBvcnRUZXh0XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KSB7XG4gICAgICB2YXIgYXR0cnMgPSB7fSxcbiAgICAgICAgICBwYXJlbnQgPSAhaXNSb290ICYmIGl0ZW0uZ2V0UGFyZW50KCksXG4gICAgICAgICAgc3R5bGUgPSBbXTtcbiAgICAgIGlmIChpdGVtLl9uYW1lICE9IG51bGwpIGF0dHJzLmlkID0gaXRlbS5fbmFtZTtcbiAgICAgIEJhc2UuZWFjaChTdmdTdHlsZXMsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICB2YXIgZ2V0ID0gZW50cnkuZ2V0LFxuICAgICAgICAgICAgdHlwZSA9IGVudHJ5LnR5cGUsXG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZW1bZ2V0XSgpO1xuXG4gICAgICAgIGlmIChlbnRyeS5leHBvcnRGaWx0ZXIgPyBlbnRyeS5leHBvcnRGaWx0ZXIoaXRlbSwgdmFsdWUpIDogIXBhcmVudCB8fCAhQmFzZS5lcXVhbHMocGFyZW50W2dldF0oKSwgdmFsdWUpKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb2xvcicgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gdmFsdWUuZ2V0QWxwaGEoKTtcbiAgICAgICAgICAgIGlmIChhbHBoYSA8IDEpIGF0dHJzW2VudHJ5LmF0dHJpYnV0ZSArICctb3BhY2l0eSddID0gYWxwaGE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIHN0eWxlLnB1c2goZW50cnkuYXR0cmlidXRlICsgJzogJyArIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0cnNbZW50cnkuYXR0cmlidXRlXSA9IHZhbHVlID09IG51bGwgPyAnbm9uZScgOiB0eXBlID09PSAnY29sb3InID8gdmFsdWUuZ3JhZGllbnQgPyBleHBvcnRHcmFkaWVudCh2YWx1ZSwgaXRlbSkgOiB2YWx1ZS50b0NTUyh0cnVlKSA6IHR5cGUgPT09ICdhcnJheScgPyB2YWx1ZS5qb2luKCcsJykgOiB0eXBlID09PSAnbG9va3VwJyA/IGVudHJ5LnRvU1ZHW3ZhbHVlXSA6IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc3R5bGUubGVuZ3RoKSBhdHRycy5zdHlsZSA9IHN0eWxlLmpvaW4oJzsnKTtcbiAgICAgIGlmIChhdHRycy5vcGFjaXR5ID09PSAxKSBkZWxldGUgYXR0cnMub3BhY2l0eTtcbiAgICAgIGlmICghaXRlbS5fdmlzaWJsZSkgYXR0cnMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgcmV0dXJuIFN2Z0VsZW1lbnQuc2V0KG5vZGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZpbml0aW9ucztcblxuICAgIGZ1bmN0aW9uIGdldERlZmluaXRpb24oaXRlbSwgdHlwZSkge1xuICAgICAgaWYgKCFkZWZpbml0aW9ucykgZGVmaW5pdGlvbnMgPSB7XG4gICAgICAgIGlkczoge30sXG4gICAgICAgIHN2Z3M6IHt9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGl0ZW0gJiYgZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nICsgKGl0ZW0uX2lkIHx8IGl0ZW0uX19pZCB8fCAoaXRlbS5fX2lkID0gVUlELmdldCgnc3ZnJykpKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RGVmaW5pdGlvbihpdGVtLCBub2RlLCB0eXBlKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb25zKSBnZXREZWZpbml0aW9uKCk7XG4gICAgICB2YXIgdHlwZUlkID0gZGVmaW5pdGlvbnMuaWRzW3R5cGVdID0gKGRlZmluaXRpb25zLmlkc1t0eXBlXSB8fCAwKSArIDE7XG4gICAgICBub2RlLmlkID0gdHlwZSArICctJyArIHR5cGVJZDtcbiAgICAgIGRlZmluaXRpb25zLnN2Z3NbdHlwZSArICctJyArIChpdGVtLl9pZCB8fCBpdGVtLl9faWQpXSA9IG5vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHN2ZyA9IG5vZGUsXG4gICAgICAgICAgZGVmcyA9IG51bGw7XG5cbiAgICAgIGlmIChkZWZpbml0aW9ucykge1xuICAgICAgICBzdmcgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnICYmIG5vZGU7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiBkZWZpbml0aW9ucy5zdmdzKSB7XG4gICAgICAgICAgaWYgKCFkZWZzKSB7XG4gICAgICAgICAgICBpZiAoIXN2Zykge1xuICAgICAgICAgICAgICBzdmcgPSBTdmdFbGVtZW50LmNyZWF0ZSgnc3ZnJyk7XG4gICAgICAgICAgICAgIHN2Zy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmcyA9IHN2Zy5pbnNlcnRCZWZvcmUoU3ZnRWxlbWVudC5jcmVhdGUoJ2RlZnMnKSwgc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZGVmaW5pdGlvbnMuc3Znc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWZpbml0aW9ucyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zLmFzU3RyaW5nID8gbmV3IHNlbGYuWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2ZykgOiBzdmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0U1ZHKGl0ZW0sIG9wdGlvbnMsIGlzUm9vdCkge1xuICAgICAgdmFyIGV4cG9ydGVyID0gZXhwb3J0ZXJzW2l0ZW0uX2NsYXNzXSxcbiAgICAgICAgICBub2RlID0gZXhwb3J0ZXIgJiYgZXhwb3J0ZXIoaXRlbSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHZhciBvbkV4cG9ydCA9IG9wdGlvbnMub25FeHBvcnQ7XG4gICAgICAgIGlmIChvbkV4cG9ydCkgbm9kZSA9IG9uRXhwb3J0KGl0ZW0sIG5vZGUsIG9wdGlvbnMpIHx8IG5vZGU7XG4gICAgICAgIHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkoaXRlbS5fZGF0YSk7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEgIT09ICd7fScgJiYgZGF0YSAhPT0gJ251bGwnKSBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJywgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlICYmIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBJdGVtLmluamVjdCh7XG4gICAgICBleHBvcnRTVkc6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMoZXhwb3J0U1ZHKHRoaXMsIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBQcm9qZWN0LmluamVjdCh7XG4gICAgICBleHBvcnRTVkc6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICAgIHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcbiAgICAgICAgICAgIGJvdW5kcyA9IEJhc2UucGljayhvcHRpb25zLmJvdW5kcywgJ3ZpZXcnKSxcbiAgICAgICAgICAgIG14ID0gb3B0aW9ucy5tYXRyaXggfHwgYm91bmRzID09PSAndmlldycgJiYgdmlldy5fbWF0cml4LFxuICAgICAgICAgICAgbWF0cml4ID0gbXggJiYgTWF0cml4LnJlYWQoW214XSksXG4gICAgICAgICAgICByZWN0ID0gYm91bmRzID09PSAndmlldycgPyBuZXcgUmVjdGFuZ2xlKFswLCAwXSwgdmlldy5nZXRWaWV3U2l6ZSgpKSA6IGJvdW5kcyA9PT0gJ2NvbnRlbnQnID8gSXRlbS5fZ2V0Qm91bmRzKGNoaWxkcmVuLCBtYXRyaXgsIHtcbiAgICAgICAgICBzdHJva2U6IHRydWVcbiAgICAgICAgfSkucmVjdCA6IFJlY3RhbmdsZS5yZWFkKFtib3VuZHNdLCAwLCB7XG4gICAgICAgICAgcmVhZE51bGw6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgICAgICBhdHRycyA9IHtcbiAgICAgICAgICB2ZXJzaW9uOiAnMS4xJyxcbiAgICAgICAgICB4bWxuczogU3ZnRWxlbWVudC5zdmcsXG4gICAgICAgICAgJ3htbG5zOnhsaW5rJzogU3ZnRWxlbWVudC54bGlua1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgYXR0cnMud2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgIGF0dHJzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgIGlmIChyZWN0LnggfHwgcmVjdC54ID09PSAwIHx8IHJlY3QueSB8fCByZWN0LnkgPT09IDApIGF0dHJzLnZpZXdCb3ggPSBmb3JtYXR0ZXIucmVjdGFuZ2xlKHJlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSBTdmdFbGVtZW50LmNyZWF0ZSgnc3ZnJywgYXR0cnMsIGZvcm1hdHRlciksXG4gICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuXG4gICAgICAgIGlmIChtYXRyaXggJiYgIW1hdHJpeC5pc0lkZW50aXR5KCkpIHtcbiAgICAgICAgICBwYXJlbnQgPSBub2RlLmFwcGVuZENoaWxkKFN2Z0VsZW1lbnQuY3JlYXRlKCdnJywgZ2V0VHJhbnNmb3JtKG1hdHJpeCksIGZvcm1hdHRlcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGNoaWxkcmVuW2ldLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0oKTtcbiAgbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmaW5pdGlvbnMgPSB7fSxcbiAgICAgICAgcm9vdFNpemU7XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZShub2RlLCBuYW1lLCBpc1N0cmluZywgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHZhbHVlID0gU3ZnRWxlbWVudC5nZXQobm9kZSwgbmFtZSkgfHwgZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIHJlcyA9IHZhbHVlID09IG51bGwgPyBhbGxvd051bGwgPyBudWxsIDogaXNTdHJpbmcgPyAnJyA6IDAgOiBpc1N0cmluZyA/IHZhbHVlIDogcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gLyVcXHMqJC8udGVzdCh2YWx1ZSkgPyByZXMgLyAxMDAgKiAoYWxsb3dQZXJjZW50ID8gMSA6IHJvb3RTaXplWy94fF53aWR0aC8udGVzdChuYW1lKSA/ICd3aWR0aCcgOiAnaGVpZ2h0J10pIDogcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBvaW50KG5vZGUsIHgsIHksIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50LCBkZWZhdWx0WCwgZGVmYXVsdFkpIHtcbiAgICAgIHggPSBnZXRWYWx1ZShub2RlLCB4IHx8ICd4JywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50LCBkZWZhdWx0WCk7XG4gICAgICB5ID0gZ2V0VmFsdWUobm9kZSwgeSB8fCAneScsIGZhbHNlLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCwgZGVmYXVsdFkpO1xuICAgICAgcmV0dXJuIGFsbG93TnVsbCAmJiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkgPyBudWxsIDogbmV3IFBvaW50KHgsIHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNpemUobm9kZSwgdywgaCwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQpIHtcbiAgICAgIHcgPSBnZXRWYWx1ZShub2RlLCB3IHx8ICd3aWR0aCcsIGZhbHNlLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCk7XG4gICAgICBoID0gZ2V0VmFsdWUobm9kZSwgaCB8fCAnaGVpZ2h0JywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50KTtcbiAgICAgIHJldHVybiBhbGxvd051bGwgJiYgKHcgPT0gbnVsbCB8fCBoID09IG51bGwpID8gbnVsbCA6IG5ldyBTaXplKHcsIGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSwgdHlwZSwgbG9va3VwKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09ICdub25lJyA/IG51bGwgOiB0eXBlID09PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQodmFsdWUpIDogdHlwZSA9PT0gJ2FycmF5JyA/IHZhbHVlID8gdmFsdWUuc3BsaXQoL1tcXHMsXSsvZykubWFwKHBhcnNlRmxvYXQpIDogW10gOiB0eXBlID09PSAnY29sb3InID8gZ2V0RGVmaW5pdGlvbih2YWx1ZSkgfHwgdmFsdWUgOiB0eXBlID09PSAnbG9va3VwJyA/IGxvb2t1cFt2YWx1ZV0gOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbXBvcnRHcm91cChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcbiAgICAgIHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2RlcyxcbiAgICAgICAgICBpc0NsaXAgPSB0eXBlID09PSAnY2xpcHBhdGgnLFxuICAgICAgICAgIGlzRGVmcyA9IHR5cGUgPT09ICdkZWZzJyxcbiAgICAgICAgICBpdGVtID0gbmV3IEdyb3VwKCksXG4gICAgICAgICAgcHJvamVjdCA9IGl0ZW0uX3Byb2plY3QsXG4gICAgICAgICAgY3VycmVudFN0eWxlID0gcHJvamVjdC5fY3VycmVudFN0eWxlLFxuICAgICAgICAgIGNoaWxkcmVuID0gW107XG5cbiAgICAgIGlmICghaXNDbGlwICYmICFpc0RlZnMpIHtcbiAgICAgICAgaXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuICAgICAgICBwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBpdGVtLl9zdHlsZS5jbG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIHZhciBkZWZzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdkZWZzJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkZWZzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGltcG9ydE5vZGUoZGVmc1tpXSwgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBub2Rlc1tpXSxcbiAgICAgICAgICAgIGNoaWxkO1xuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxICYmICEvXmRlZnMkL2kudGVzdChjaGlsZE5vZGUubm9kZU5hbWUpICYmIChjaGlsZCA9IGltcG9ydE5vZGUoY2hpbGROb2RlLCBvcHRpb25zLCBmYWxzZSkpICYmICEoY2hpbGQgaW5zdGFuY2VvZiBTeW1ib2xEZWZpbml0aW9uKSkgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGl0ZW0uYWRkQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgaWYgKGlzQ2xpcCkgaXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLnJlZHVjZSgpLCBub2RlLCBpc1Jvb3QpO1xuICAgICAgcHJvamVjdC5fY3VycmVudFN0eWxlID0gY3VycmVudFN0eWxlO1xuXG4gICAgICBpZiAoaXNDbGlwIHx8IGlzRGVmcykge1xuICAgICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgICBpdGVtID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW1wb3J0UG9seShub2RlLCB0eXBlKSB7XG4gICAgICB2YXIgY29vcmRzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpLm1hdGNoKC9bKy1dPyg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPy9nKSxcbiAgICAgICAgICBwb2ludHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb29yZHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSBwb2ludHMucHVzaChuZXcgUG9pbnQocGFyc2VGbG9hdChjb29yZHNbaV0pLCBwYXJzZUZsb2F0KGNvb3Jkc1tpICsgMV0pKSk7XG5cbiAgICAgIHZhciBwYXRoID0gbmV3IFBhdGgocG9pbnRzKTtcbiAgICAgIGlmICh0eXBlID09PSAncG9seWdvbicpIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbXBvcnRQYXRoKG5vZGUpIHtcbiAgICAgIHJldHVybiBQYXRoSXRlbS5jcmVhdGUobm9kZS5nZXRBdHRyaWJ1dGUoJ2QnKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW1wb3J0R3JhZGllbnQobm9kZSwgdHlwZSkge1xuICAgICAgdmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcbiAgICAgICAgICByYWRpYWwgPSB0eXBlID09PSAncmFkaWFsZ3JhZGllbnQnLFxuICAgICAgICAgIGdyYWRpZW50O1xuXG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgZ3JhZGllbnQgPSBkZWZpbml0aW9uc1tpZF0uZ2V0R3JhZGllbnQoKTtcblxuICAgICAgICBpZiAoZ3JhZGllbnQuX3JhZGlhbCBeIHJhZGlhbCkge1xuICAgICAgICAgIGdyYWRpZW50ID0gZ3JhZGllbnQuY2xvbmUoKTtcbiAgICAgICAgICBncmFkaWVudC5fcmFkaWFsID0gcmFkaWFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsXG4gICAgICAgICAgICBzdG9wcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSBzdG9wcy5wdXNoKGFwcGx5QXR0cmlidXRlcyhuZXcgR3JhZGllbnRTdG9wKCksIGNoaWxkKSk7XG4gICAgICAgIH1cblxuICAgICAgICBncmFkaWVudCA9IG5ldyBHcmFkaWVudChzdG9wcywgcmFkaWFsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9yaWdpbixcbiAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICBoaWdobGlnaHQsXG4gICAgICAgICAgc2NhbGVUb0JvdW5kcyA9IGdldFZhbHVlKG5vZGUsICdncmFkaWVudFVuaXRzJywgdHJ1ZSkgIT09ICd1c2VyU3BhY2VPblVzZSc7XG5cbiAgICAgIGlmIChyYWRpYWwpIHtcbiAgICAgICAgb3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JywgZmFsc2UsIHNjYWxlVG9Cb3VuZHMsICc1MCUnLCAnNTAlJyk7XG4gICAgICAgIGRlc3RpbmF0aW9uID0gb3JpZ2luLmFkZChnZXRWYWx1ZShub2RlLCAncicsIGZhbHNlLCBmYWxzZSwgc2NhbGVUb0JvdW5kcywgJzUwJScpLCAwKTtcbiAgICAgICAgaGlnaGxpZ2h0ID0gZ2V0UG9pbnQobm9kZSwgJ2Z4JywgJ2Z5JywgdHJ1ZSwgc2NhbGVUb0JvdW5kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcmlnaW4gPSBnZXRQb2ludChub2RlLCAneDEnLCAneTEnLCBmYWxzZSwgc2NhbGVUb0JvdW5kcywgJzAlJywgJzAlJyk7XG4gICAgICAgIGRlc3RpbmF0aW9uID0gZ2V0UG9pbnQobm9kZSwgJ3gyJywgJ3kyJywgZmFsc2UsIHNjYWxlVG9Cb3VuZHMsICcxMDAlJywgJzAlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvciA9IGFwcGx5QXR0cmlidXRlcyhuZXcgQ29sb3IoZ3JhZGllbnQsIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodCksIG5vZGUpO1xuICAgICAgY29sb3IuX3NjYWxlVG9Cb3VuZHMgPSBzY2FsZVRvQm91bmRzO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGltcG9ydGVycyA9IHtcbiAgICAgICcjZG9jdW1lbnQnOiBmdW5jdGlvbiAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG4gICAgICAgIHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2RlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkgcmV0dXJuIGltcG9ydE5vZGUoY2hpbGQsIG9wdGlvbnMsIGlzUm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnOiBpbXBvcnRHcm91cCxcbiAgICAgIHN2ZzogaW1wb3J0R3JvdXAsXG4gICAgICBjbGlwcGF0aDogaW1wb3J0R3JvdXAsXG4gICAgICBwb2x5Z29uOiBpbXBvcnRQb2x5LFxuICAgICAgcG9seWxpbmU6IGltcG9ydFBvbHksXG4gICAgICBwYXRoOiBpbXBvcnRQYXRoLFxuICAgICAgbGluZWFyZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuICAgICAgcmFkaWFsZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByYXN0ZXIgPSBuZXcgUmFzdGVyKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkpO1xuICAgICAgICByYXN0ZXIub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSBnZXRTaXplKG5vZGUpO1xuICAgICAgICAgIHRoaXMuc2V0U2l6ZShzaXplKTtcbiAgICAgICAgICB2YXIgY2VudGVyID0gZ2V0UG9pbnQobm9kZSkuYWRkKHNpemUuZGl2aWRlKDIpKTtcblxuICAgICAgICAgIHRoaXMuX21hdHJpeC5hcHBlbmQobmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByYXN0ZXI7XG4gICAgICB9LFxuICAgICAgc3ltYm9sOiBmdW5jdGlvbiAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ltYm9sRGVmaW5pdGlvbihpbXBvcnRHcm91cChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBkZWZzOiBpbXBvcnRHcm91cCxcbiAgICAgIHVzZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcbiAgICAgICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uc1tpZF0sXG4gICAgICAgICAgICBwb2ludCA9IGdldFBvaW50KG5vZGUpO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbiA/IGRlZmluaXRpb24gaW5zdGFuY2VvZiBTeW1ib2xEZWZpbml0aW9uID8gZGVmaW5pdGlvbi5wbGFjZShwb2ludCkgOiBkZWZpbml0aW9uLmNsb25lKCkudHJhbnNsYXRlKHBvaW50KSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgY2lyY2xlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNoYXBlLkNpcmNsZShnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSwgZ2V0VmFsdWUobm9kZSwgJ3InKSk7XG4gICAgICB9LFxuICAgICAgZWxsaXBzZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaGFwZS5FbGxpcHNlKHtcbiAgICAgICAgICBjZW50ZXI6IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpLFxuICAgICAgICAgIHJhZGl1czogZ2V0U2l6ZShub2RlLCAncngnLCAncnknKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZWN0OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNoYXBlLlJlY3RhbmdsZShuZXcgUmVjdGFuZ2xlKGdldFBvaW50KG5vZGUpLCBnZXRTaXplKG5vZGUpKSwgZ2V0U2l6ZShub2RlLCAncngnLCAncnknKSk7XG4gICAgICB9LFxuICAgICAgbGluZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoLkxpbmUoZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyksIGdldFBvaW50KG5vZGUsICd4MicsICd5MicpKTtcbiAgICAgIH0sXG4gICAgICB0ZXh0OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgdGV4dCA9IG5ldyBQb2ludFRleHQoZ2V0UG9pbnQobm9kZSkuYWRkKGdldFBvaW50KG5vZGUsICdkeCcsICdkeScpKSk7XG4gICAgICAgIHRleHQuc2V0Q29udGVudChub2RlLnRleHRDb250ZW50LnRyaW0oKSB8fCAnJyk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfSxcbiAgICAgIHN3aXRjaDogaW1wb3J0R3JvdXBcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0oaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUpIHtcbiAgICAgIGlmIChpdGVtLnRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtcyA9IChub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCAnJykuc3BsaXQoL1xcKVxccyovZyksXG4gICAgICAgICAgICBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW2ldO1xuICAgICAgICAgIGlmICghdHJhbnNmb3JtKSBicmVhaztcbiAgICAgICAgICB2YXIgcGFydHMgPSB0cmFuc2Zvcm0uc3BsaXQoL1xcKFxccyovKSxcbiAgICAgICAgICAgICAgY29tbWFuZCA9IHBhcnRzWzBdLFxuICAgICAgICAgICAgICB2ID0gcGFydHNbMV0uc3BsaXQoL1tcXHMsXSsvZyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHYubGVuZ3RoOyBqIDwgbTsgaisrKSB2W2pdID0gcGFyc2VGbG9hdCh2W2pdKTtcblxuICAgICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSAnbWF0cml4JzpcbiAgICAgICAgICAgICAgbWF0cml4LmFwcGVuZChuZXcgTWF0cml4KHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICAgIG1hdHJpeC5yb3RhdGUodlswXSwgdlsxXSB8fCAwLCB2WzJdIHx8IDApO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcbiAgICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZSh2WzBdLCB2WzFdIHx8IDApO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgICAgICBtYXRyaXguc2NhbGUodik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdza2V3WCc6XG4gICAgICAgICAgICAgIG1hdHJpeC5za2V3KHZbMF0sIDApO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc2tld1knOlxuICAgICAgICAgICAgICBtYXRyaXguc2tldygwLCB2WzBdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS50cmFuc2Zvcm0obWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseU9wYWNpdHkoaXRlbSwgdmFsdWUsIG5hbWUpIHtcbiAgICAgIHZhciBrZXkgPSBuYW1lID09PSAnZmlsbC1vcGFjaXR5JyA/ICdnZXRGaWxsQ29sb3InIDogJ2dldFN0cm9rZUNvbG9yJyxcbiAgICAgICAgICBjb2xvciA9IGl0ZW1ba2V5XSAmJiBpdGVtW2tleV0oKTtcbiAgICAgIGlmIChjb2xvcikgY29sb3Iuc2V0QWxwaGEocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVzID0gQmFzZS5zZXQoQmFzZS5lYWNoKFN2Z1N0eWxlcywgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICB0aGlzW2VudHJ5LmF0dHJpYnV0ZV0gPSBmdW5jdGlvbiAoaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGl0ZW1bZW50cnkuc2V0XSkge1xuICAgICAgICAgIGl0ZW1bZW50cnkuc2V0XShjb252ZXJ0VmFsdWUodmFsdWUsIGVudHJ5LnR5cGUsIGVudHJ5LmZyb21TVkcpKTtcblxuICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBpdGVtW2VudHJ5LmdldF0oKTtcblxuICAgICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgIGlmIChjb2xvci5fc2NhbGVUb0JvdW5kcykge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZHMgPSBpdGVtLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgICAgIGNvbG9yLnRyYW5zZm9ybShuZXcgTWF0cml4KCkudHJhbnNsYXRlKGJvdW5kcy5nZXRQb2ludCgpKS5zY2FsZShib3VuZHMuZ2V0U2l6ZSgpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwge30pLCB7XG4gICAgICBpZDogZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgIGRlZmluaXRpb25zW3ZhbHVlXSA9IGl0ZW07XG4gICAgICAgIGlmIChpdGVtLnNldE5hbWUpIGl0ZW0uc2V0TmFtZSh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgJ2NsaXAtcGF0aCc6IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSkge1xuICAgICAgICB2YXIgY2xpcCA9IGdldERlZmluaXRpb24odmFsdWUpO1xuXG4gICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgY2xpcCA9IGNsaXAuY2xvbmUoKTtcbiAgICAgICAgICBjbGlwLnNldENsaXBNYXNrKHRydWUpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgaXRlbS5pbnNlcnRDaGlsZCgwLCBjbGlwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBHcm91cChjbGlwLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBncmFkaWVudFRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuICAgICAgJ2ZpbGwtb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcbiAgICAgICdzdHJva2Utb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcbiAgICAgIHZpc2liaWxpdHk6IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXRlbS5zZXRWaXNpYmxlKSBpdGVtLnNldFZpc2libGUodmFsdWUgPT09ICd2aXNpYmxlJyk7XG4gICAgICB9LFxuICAgICAgZGlzcGxheTogZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgIGlmIChpdGVtLnNldFZpc2libGUpIGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSAhPT0gbnVsbCk7XG4gICAgICB9LFxuICAgICAgJ3N0b3AtY29sb3InOiBmdW5jdGlvbiAoaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGl0ZW0uc2V0Q29sb3IpIGl0ZW0uc2V0Q29sb3IodmFsdWUpO1xuICAgICAgfSxcbiAgICAgICdzdG9wLW9wYWNpdHknOiBmdW5jdGlvbiAoaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGl0ZW0uX2NvbG9yKSBpdGVtLl9jb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICB9LFxuICAgICAgb2Zmc2V0OiBmdW5jdGlvbiAoaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGl0ZW0uc2V0T2Zmc2V0KSB7XG4gICAgICAgICAgdmFyIHBlcmNlbnQgPSB2YWx1ZS5tYXRjaCgvKC4qKSUkLyk7XG4gICAgICAgICAgaXRlbS5zZXRPZmZzZXQocGVyY2VudCA/IHBlcmNlbnRbMV0gLyAxMDAgOiBwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aWV3Qm94OiBmdW5jdGlvbiAoaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcykge1xuICAgICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUoY29udmVydFZhbHVlKHZhbHVlLCAnYXJyYXknKSksXG4gICAgICAgICAgICBzaXplID0gZ2V0U2l6ZShub2RlLCBudWxsLCBudWxsLCB0cnVlKSxcbiAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgbWF0cml4O1xuXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICB2YXIgc2NhbGUgPSBzaXplID8gc2l6ZS5kaXZpZGUocmVjdC5nZXRTaXplKCkpIDogMSxcbiAgICAgICAgICAgICAgbWF0cml4ID0gbmV3IE1hdHJpeCgpLnNjYWxlKHNjYWxlKS50cmFuc2xhdGUocmVjdC5nZXRQb2ludCgpLm5lZ2F0ZSgpKTtcbiAgICAgICAgICBncm91cCA9IGl0ZW07XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb24pIHtcbiAgICAgICAgICBpZiAoc2l6ZSkgcmVjdC5zZXRTaXplKHNpemUpO1xuICAgICAgICAgIGdyb3VwID0gaXRlbS5faXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgIGlmIChnZXRBdHRyaWJ1dGUobm9kZSwgJ292ZXJmbG93Jywgc3R5bGVzKSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICB2YXIgY2xpcCA9IG5ldyBTaGFwZS5SZWN0YW5nbGUocmVjdCk7XG4gICAgICAgICAgICBjbGlwLnNldENsaXBNYXNrKHRydWUpO1xuICAgICAgICAgICAgZ3JvdXAuYWRkQ2hpbGQoY2xpcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdHJpeCkgZ3JvdXAudHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpIHtcbiAgICAgIHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzW25hbWVdLFxuICAgICAgICAgIHZhbHVlID0gYXR0ciAmJiBhdHRyLnZhbHVlO1xuXG4gICAgICBpZiAoIXZhbHVlICYmIG5vZGUuc3R5bGUpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gQmFzZS5jYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgdmFsdWUgPSBub2RlLnN0eWxlW3N0eWxlXTtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBzdHlsZXMubm9kZVtzdHlsZV0gIT09IHN0eWxlcy5wYXJlbnRbc3R5bGVdKSB2YWx1ZSA9IHN0eWxlcy5ub2RlW3N0eWxlXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICF2YWx1ZSA/IHVuZGVmaW5lZCA6IHZhbHVlID09PSAnbm9uZScgPyBudWxsIDogdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICBzdHlsZXMgPSB7XG4gICAgICAgIG5vZGU6IERvbUVsZW1lbnQuZ2V0U3R5bGVzKG5vZGUpIHx8IHt9LFxuICAgICAgICBwYXJlbnQ6ICFpc1Jvb3QgJiYgIS9eZGVmcyQvaS50ZXN0KHBhcmVudC50YWdOYW1lKSAmJiBEb21FbGVtZW50LmdldFN0eWxlcyhwYXJlbnQpIHx8IHt9XG4gICAgICB9O1xuICAgICAgQmFzZS5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChhcHBseSwgbmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKTtcbiAgICAgICAgaXRlbSA9IHZhbHVlICE9PSB1bmRlZmluZWQgJiYgYXBwbHkoaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcykgfHwgaXRlbTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG1hdGNoID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL1xcKCg/OltcIicjXSopKFteXCInKV0rKS8pLFxuICAgICAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXSxcbiAgICAgICAgICByZXMgPSBuYW1lICYmIGRlZmluaXRpb25zW3dpbmRvdyA/IG5hbWUucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzBdICsgJyMnLCAnJykgOiBuYW1lXTtcblxuICAgICAgaWYgKHJlcyAmJiByZXMuX3NjYWxlVG9Cb3VuZHMpIHtcbiAgICAgICAgcmVzID0gcmVzLmNsb25lKCk7XG4gICAgICAgIHJlcy5fc2NhbGVUb0JvdW5kcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW1wb3J0Tm9kZShub2RlLCBvcHRpb25zLCBpc1Jvb3QpIHtcbiAgICAgIHZhciB0eXBlID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIGlzRWxlbWVudCA9IHR5cGUgIT09ICcjZG9jdW1lbnQnLFxuICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgbmV4dDtcblxuICAgICAgaWYgKGlzUm9vdCAmJiBpc0VsZW1lbnQpIHtcbiAgICAgICAgcm9vdFNpemUgPSBwYXBlci5nZXRWaWV3KCkuZ2V0U2l6ZSgpO1xuICAgICAgICByb290U2l6ZSA9IGdldFNpemUobm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSkgfHwgcm9vdFNpemU7XG4gICAgICAgIGNvbnRhaW5lciA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdzdmcnLCB7XG4gICAgICAgICAgc3R5bGU6ICdzdHJva2Utd2lkdGg6IDFweDsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwJ1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXR0aW5ncyA9IHBhcGVyLnNldHRpbmdzLFxuICAgICAgICAgIGFwcGx5TWF0cml4ID0gc2V0dGluZ3MuYXBwbHlNYXRyaXgsXG4gICAgICAgICAgaW5zZXJ0SXRlbXMgPSBzZXR0aW5ncy5pbnNlcnRJdGVtcztcbiAgICAgIHNldHRpbmdzLmFwcGx5TWF0cml4ID0gZmFsc2U7XG4gICAgICBzZXR0aW5ncy5pbnNlcnRJdGVtcyA9IGZhbHNlO1xuICAgICAgdmFyIGltcG9ydGVyID0gaW1wb3J0ZXJzW3R5cGVdLFxuICAgICAgICAgIGl0ZW0gPSBpbXBvcnRlciAmJiBpbXBvcnRlcihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHx8IG51bGw7XG4gICAgICBzZXR0aW5ncy5pbnNlcnRJdGVtcyA9IGluc2VydEl0ZW1zO1xuICAgICAgc2V0dGluZ3MuYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeDtcblxuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgaWYgKGlzRWxlbWVudCAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkpIGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcbiAgICAgICAgdmFyIG9uSW1wb3J0ID0gb3B0aW9ucy5vbkltcG9ydCxcbiAgICAgICAgICAgIGRhdGEgPSBpc0VsZW1lbnQgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScpO1xuICAgICAgICBpZiAob25JbXBvcnQpIGl0ZW0gPSBvbkltcG9ydChub2RlLCBpdGVtLCBvcHRpb25zKSB8fCBpdGVtO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmV4cGFuZFNoYXBlcyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcbiAgICAgICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgICAgIGl0ZW0gPSBpdGVtLnRvUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEpIGl0ZW0uX2RhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICBkZWZpbml0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoaXRlbSAmJiBCYXNlLnBpY2sob3B0aW9ucy5hcHBseU1hdHJpeCwgYXBwbHlNYXRyaXgpKSBpdGVtLm1hdHJpeC5hcHBseSh0cnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW1wb3J0U1ZHKHNvdXJjZSwgb3B0aW9ucywgb3duZXIpIHtcbiAgICAgIGlmICghc291cmNlKSByZXR1cm4gbnVsbDtcbiAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IHtcbiAgICAgICAgb25Mb2FkOiBvcHRpb25zXG4gICAgICB9IDogb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBzY29wZSA9IHBhcGVyLFxuICAgICAgICAgIGl0ZW0gPSBudWxsO1xuXG4gICAgICBmdW5jdGlvbiBvbkxvYWQoc3ZnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2Ygc3ZnID09PSAnb2JqZWN0JyA/IHN2ZyA6IG5ldyBzZWxmLkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdmcudHJpbSgpLCAnaW1hZ2Uvc3ZnK3htbCcpO1xuXG4gICAgICAgICAgaWYgKCFub2RlLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICBub2RlID0gbnVsbDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgU1ZHIHNvdXJjZTogJyArIHNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFwZXIgPSBzY29wZTtcbiAgICAgICAgICBpdGVtID0gaW1wb3J0Tm9kZShub2RlLCBvcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLmluc2VydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG93bmVyLl9pbnNlcnRJdGVtKHVuZGVmaW5lZCwgaXRlbSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9uTG9hZCA9IG9wdGlvbnMub25Mb2FkO1xuICAgICAgICAgIGlmIChvbkxvYWQpIG9uTG9hZChpdGVtLCBzdmcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkVycm9yKG1lc3NhZ2UsIHN0YXR1cykge1xuICAgICAgICB2YXIgb25FcnJvciA9IG9wdGlvbnMub25FcnJvcjtcblxuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IobWVzc2FnZSwgc3RhdHVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmICEvXltcXHNcXFNdKjwvLnRlc3Qoc291cmNlKSkge1xuICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBvbkxvYWQobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHVybDogc291cmNlLFxuICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICBvbkxvYWQ6IG9uTG9hZCxcbiAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9uTG9hZChyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvbkVycm9yKHJlYWRlci5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQXNUZXh0KHNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkxvYWQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgSXRlbS5pbmplY3Qoe1xuICAgICAgaW1wb3J0U1ZHOiBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFByb2plY3QuaW5qZWN0KHtcbiAgICAgIGltcG9ydFNWRzogZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICByZXR1cm4gaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KCk7XG5cbiAgQmFzZS5leHBvcnRzLlBhcGVyU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnbG9iYWwgPSB0aGlzLFxuICAgICAgICBhY29ybiA9IGdsb2JhbC5hY29ybjtcblxuICAgIGlmICghYWNvcm4gJiYgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhY29ybiA9IHJlcXVpcmUoJ2Fjb3JuJyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIGlmICghYWNvcm4pIHtcbiAgICAgIHZhciBleHBvcnRzLCBtb2R1bGU7XG4gICAgICBhY29ybiA9IGV4cG9ydHMgPSBtb2R1bGUgPSB7fTtcblxuICAgICAgKGZ1bmN0aW9uIChyb290LCBtb2QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSByZXR1cm4gbW9kKGV4cG9ydHMpO1xuICAgICAgICBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgcmV0dXJuIGRlZmluZShbXCJleHBvcnRzXCJdLCBtb2QpO1xuICAgICAgICBtb2Qocm9vdC5hY29ybiB8fCAocm9vdC5hY29ybiA9IHt9KSk7XG4gICAgICB9KSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICBleHBvcnRzLnZlcnNpb24gPSBcIjAuNS4wXCI7XG4gICAgICAgIHZhciBvcHRpb25zLCBpbnB1dCwgaW5wdXRMZW4sIHNvdXJjZUZpbGU7XG5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChpbnB0LCBvcHRzKSB7XG4gICAgICAgICAgaW5wdXQgPSBTdHJpbmcoaW5wdCk7XG4gICAgICAgICAgaW5wdXRMZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgc2V0T3B0aW9ucyhvcHRzKTtcbiAgICAgICAgICBpbml0VG9rZW5TdGF0ZSgpO1xuICAgICAgICAgIHJldHVybiBwYXJzZVRvcExldmVsKG9wdGlvbnMucHJvZ3JhbSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICBlY21hVmVyc2lvbjogNSxcbiAgICAgICAgICBzdHJpY3RTZW1pY29sb25zOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd1RyYWlsaW5nQ29tbWFzOiB0cnVlLFxuICAgICAgICAgIGZvcmJpZFJlc2VydmVkOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgICAgICAgbG9jYXRpb25zOiBmYWxzZSxcbiAgICAgICAgICBvbkNvbW1lbnQ6IG51bGwsXG4gICAgICAgICAgcmFuZ2VzOiBmYWxzZSxcbiAgICAgICAgICBwcm9ncmFtOiBudWxsLFxuICAgICAgICAgIHNvdXJjZUZpbGU6IG51bGwsXG4gICAgICAgICAgZGlyZWN0U291cmNlRmlsZTogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0cykge1xuICAgICAgICAgIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHQpKSBvcHRpb25zW29wdF0gPSBkZWZhdWx0T3B0aW9uc1tvcHRdO1xuXG4gICAgICAgICAgc291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZSB8fCBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldExpbmVJbmZvID0gZXhwb3J0cy5nZXRMaW5lSW5mbyA9IGZ1bmN0aW9uIChpbnB1dCwgb2Zmc2V0KSB7XG4gICAgICAgICAgZm9yICh2YXIgbGluZSA9IDEsIGN1ciA9IDA7Oykge1xuICAgICAgICAgICAgbGluZUJyZWFrLmxhc3RJbmRleCA9IGN1cjtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVCcmVhay5leGVjKGlucHV0KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICsrbGluZTtcbiAgICAgICAgICAgICAgY3VyID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG9mZnNldCAtIGN1clxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIChpbnB0LCBvcHRzKSB7XG4gICAgICAgICAgaW5wdXQgPSBTdHJpbmcoaW5wdCk7XG4gICAgICAgICAgaW5wdXRMZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgc2V0T3B0aW9ucyhvcHRzKTtcbiAgICAgICAgICBpbml0VG9rZW5TdGF0ZSgpO1xuICAgICAgICAgIHZhciB0ID0ge307XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRUb2tlbihmb3JjZVJlZ2V4cCkge1xuICAgICAgICAgICAgbGFzdEVuZCA9IHRva0VuZDtcbiAgICAgICAgICAgIHJlYWRUb2tlbihmb3JjZVJlZ2V4cCk7XG4gICAgICAgICAgICB0LnN0YXJ0ID0gdG9rU3RhcnQ7XG4gICAgICAgICAgICB0LmVuZCA9IHRva0VuZDtcbiAgICAgICAgICAgIHQuc3RhcnRMb2MgPSB0b2tTdGFydExvYztcbiAgICAgICAgICAgIHQuZW5kTG9jID0gdG9rRW5kTG9jO1xuICAgICAgICAgICAgdC50eXBlID0gdG9rVHlwZTtcbiAgICAgICAgICAgIHQudmFsdWUgPSB0b2tWYWw7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRUb2tlbi5qdW1wVG8gPSBmdW5jdGlvbiAocG9zLCByZUFsbG93ZWQpIHtcbiAgICAgICAgICAgIHRva1BvcyA9IHBvcztcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgIHRva0N1ckxpbmUgPSAxO1xuICAgICAgICAgICAgICB0b2tMaW5lU3RhcnQgPSBsaW5lQnJlYWsubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgdmFyIG1hdGNoO1xuXG4gICAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgcG9zKSB7XG4gICAgICAgICAgICAgICAgKyt0b2tDdXJMaW5lO1xuICAgICAgICAgICAgICAgIHRva0xpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva1JlZ2V4cEFsbG93ZWQgPSByZUFsbG93ZWQ7XG4gICAgICAgICAgICBza2lwU3BhY2UoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIGdldFRva2VuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0b2tQb3M7XG4gICAgICAgIHZhciB0b2tTdGFydCwgdG9rRW5kO1xuICAgICAgICB2YXIgdG9rU3RhcnRMb2MsIHRva0VuZExvYztcbiAgICAgICAgdmFyIHRva1R5cGUsIHRva1ZhbDtcbiAgICAgICAgdmFyIHRva1JlZ2V4cEFsbG93ZWQ7XG4gICAgICAgIHZhciB0b2tDdXJMaW5lLCB0b2tMaW5lU3RhcnQ7XG4gICAgICAgIHZhciBsYXN0U3RhcnQsIGxhc3RFbmQsIGxhc3RFbmRMb2M7XG4gICAgICAgIHZhciBpbkZ1bmN0aW9uLCBsYWJlbHMsIHN0cmljdDtcblxuICAgICAgICBmdW5jdGlvbiByYWlzZShwb3MsIG1lc3NhZ2UpIHtcbiAgICAgICAgICB2YXIgbG9jID0gZ2V0TGluZUluZm8oaW5wdXQsIHBvcyk7XG4gICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyLnBvcyA9IHBvcztcbiAgICAgICAgICBlcnIubG9jID0gbG9jO1xuICAgICAgICAgIGVyci5yYWlzZWRBdCA9IHRva1BvcztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW1wdHkgPSBbXTtcbiAgICAgICAgdmFyIF9udW0gPSB7XG4gICAgICAgICAgdHlwZTogXCJudW1cIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX3JlZ2V4cCA9IHtcbiAgICAgICAgICB0eXBlOiBcInJlZ2V4cFwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfc3RyaW5nID0ge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9uYW1lID0ge1xuICAgICAgICAgIHR5cGU6IFwibmFtZVwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfZW9mID0ge1xuICAgICAgICAgIHR5cGU6IFwiZW9mXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9icmVhayA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImJyZWFrXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9jYXNlID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiY2FzZVwiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9jYXRjaCA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImNhdGNoXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9jb250aW51ZSA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImNvbnRpbnVlXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9kZWJ1Z2dlciA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImRlYnVnZ2VyXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9kZWZhdWx0ID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiZGVmYXVsdFwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfZG8gPSB7XG4gICAgICAgICAga2V5d29yZDogXCJkb1wiLFxuICAgICAgICAgIGlzTG9vcDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX2Vsc2UgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJlbHNlXCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2ZpbmFsbHkgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJmaW5hbGx5XCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9mb3IgPSB7XG4gICAgICAgICAga2V5d29yZDogXCJmb3JcIixcbiAgICAgICAgICBpc0xvb3A6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9mdW5jdGlvbiA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImZ1bmN0aW9uXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9pZiA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcImlmXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZXR1cm4gPSB7XG4gICAgICAgICAga2V5d29yZDogXCJyZXR1cm5cIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfc3dpdGNoID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwic3dpdGNoXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF90aHJvdyA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcInRocm93XCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX3RyeSA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcInRyeVwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfdmFyID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwidmFyXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF93aGlsZSA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcIndoaWxlXCIsXG4gICAgICAgICAgaXNMb29wOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfd2l0aCA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcIndpdGhcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX25ldyA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcIm5ld1wiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF90aGlzID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwidGhpc1wiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfbnVsbCA9IHtcbiAgICAgICAgICBrZXl3b3JkOiBcIm51bGxcIixcbiAgICAgICAgICBhdG9tVmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF90cnVlID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwidHJ1ZVwiLFxuICAgICAgICAgIGF0b21WYWx1ZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2ZhbHNlID0ge1xuICAgICAgICAgIGtleXdvcmQ6IFwiZmFsc2VcIixcbiAgICAgICAgICBhdG9tVmFsdWU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfaW4gPSB7XG4gICAgICAgICAga2V5d29yZDogXCJpblwiLFxuICAgICAgICAgIGJpbm9wOiA3LFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGtleXdvcmRUeXBlcyA9IHtcbiAgICAgICAgICBcImJyZWFrXCI6IF9icmVhayxcbiAgICAgICAgICBcImNhc2VcIjogX2Nhc2UsXG4gICAgICAgICAgXCJjYXRjaFwiOiBfY2F0Y2gsXG4gICAgICAgICAgXCJjb250aW51ZVwiOiBfY29udGludWUsXG4gICAgICAgICAgXCJkZWJ1Z2dlclwiOiBfZGVidWdnZXIsXG4gICAgICAgICAgXCJkZWZhdWx0XCI6IF9kZWZhdWx0LFxuICAgICAgICAgIFwiZG9cIjogX2RvLFxuICAgICAgICAgIFwiZWxzZVwiOiBfZWxzZSxcbiAgICAgICAgICBcImZpbmFsbHlcIjogX2ZpbmFsbHksXG4gICAgICAgICAgXCJmb3JcIjogX2ZvcixcbiAgICAgICAgICBcImZ1bmN0aW9uXCI6IF9mdW5jdGlvbixcbiAgICAgICAgICBcImlmXCI6IF9pZixcbiAgICAgICAgICBcInJldHVyblwiOiBfcmV0dXJuLFxuICAgICAgICAgIFwic3dpdGNoXCI6IF9zd2l0Y2gsXG4gICAgICAgICAgXCJ0aHJvd1wiOiBfdGhyb3csXG4gICAgICAgICAgXCJ0cnlcIjogX3RyeSxcbiAgICAgICAgICBcInZhclwiOiBfdmFyLFxuICAgICAgICAgIFwid2hpbGVcIjogX3doaWxlLFxuICAgICAgICAgIFwid2l0aFwiOiBfd2l0aCxcbiAgICAgICAgICBcIm51bGxcIjogX251bGwsXG4gICAgICAgICAgXCJ0cnVlXCI6IF90cnVlLFxuICAgICAgICAgIFwiZmFsc2VcIjogX2ZhbHNlLFxuICAgICAgICAgIFwibmV3XCI6IF9uZXcsXG4gICAgICAgICAgXCJpblwiOiBfaW4sXG4gICAgICAgICAgXCJpbnN0YW5jZW9mXCI6IHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwiaW5zdGFuY2VvZlwiLFxuICAgICAgICAgICAgYmlub3A6IDcsXG4gICAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRoaXNcIjogX3RoaXMsXG4gICAgICAgICAgXCJ0eXBlb2ZcIjoge1xuICAgICAgICAgICAga2V5d29yZDogXCJ0eXBlb2ZcIixcbiAgICAgICAgICAgIHByZWZpeDogdHJ1ZSxcbiAgICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidm9pZFwiOiB7XG4gICAgICAgICAgICBrZXl3b3JkOiBcInZvaWRcIixcbiAgICAgICAgICAgIHByZWZpeDogdHJ1ZSxcbiAgICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlXCI6IHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgICBwcmVmaXg6IHRydWUsXG4gICAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2JyYWNrZXRMID0ge1xuICAgICAgICAgIHR5cGU6IFwiW1wiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9icmFja2V0UiA9IHtcbiAgICAgICAgICB0eXBlOiBcIl1cIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX2JyYWNlTCA9IHtcbiAgICAgICAgICB0eXBlOiBcIntcIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfYnJhY2VSID0ge1xuICAgICAgICAgIHR5cGU6IFwifVwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfcGFyZW5MID0ge1xuICAgICAgICAgIHR5cGU6IFwiKFwiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgICAgIF9wYXJlblIgPSB7XG4gICAgICAgICAgdHlwZTogXCIpXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9jb21tYSA9IHtcbiAgICAgICAgICB0eXBlOiBcIixcIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfc2VtaSA9IHtcbiAgICAgICAgICB0eXBlOiBcIjtcIixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfY29sb24gPSB7XG4gICAgICAgICAgdHlwZTogXCI6XCIsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX2RvdCA9IHtcbiAgICAgICAgICB0eXBlOiBcIi5cIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX3F1ZXN0aW9uID0ge1xuICAgICAgICAgIHR5cGU6IFwiP1wiLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9zbGFzaCA9IHtcbiAgICAgICAgICBiaW5vcDogMTAsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX2VxID0ge1xuICAgICAgICAgIGlzQXNzaWduOiB0cnVlLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9hc3NpZ24gPSB7XG4gICAgICAgICAgaXNBc3NpZ246IHRydWUsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2luY0RlYyA9IHtcbiAgICAgICAgICBwb3N0Zml4OiB0cnVlLFxuICAgICAgICAgIHByZWZpeDogdHJ1ZSxcbiAgICAgICAgICBpc1VwZGF0ZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgX3ByZWZpeCA9IHtcbiAgICAgICAgICBwcmVmaXg6IHRydWUsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2xvZ2ljYWxPUiA9IHtcbiAgICAgICAgICBiaW5vcDogMSxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfbG9naWNhbEFORCA9IHtcbiAgICAgICAgICBiaW5vcDogMixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfYml0d2lzZU9SID0ge1xuICAgICAgICAgIGJpbm9wOiAzLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9iaXR3aXNlWE9SID0ge1xuICAgICAgICAgIGJpbm9wOiA0LFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9iaXR3aXNlQU5EID0ge1xuICAgICAgICAgIGJpbm9wOiA1LFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9lcXVhbGl0eSA9IHtcbiAgICAgICAgICBiaW5vcDogNixcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfcmVsYXRpb25hbCA9IHtcbiAgICAgICAgICBiaW5vcDogNyxcbiAgICAgICAgICBiZWZvcmVFeHByOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfYml0U2hpZnQgPSB7XG4gICAgICAgICAgYmlub3A6IDgsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3BsdXNNaW4gPSB7XG4gICAgICAgICAgYmlub3A6IDksXG4gICAgICAgICAgcHJlZml4OiB0cnVlLFxuICAgICAgICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9tdWx0aXBseU1vZHVsbyA9IHtcbiAgICAgICAgICBiaW5vcDogMTAsXG4gICAgICAgICAgYmVmb3JlRXhwcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBleHBvcnRzLnRva1R5cGVzID0ge1xuICAgICAgICAgIGJyYWNrZXRMOiBfYnJhY2tldEwsXG4gICAgICAgICAgYnJhY2tldFI6IF9icmFja2V0UixcbiAgICAgICAgICBicmFjZUw6IF9icmFjZUwsXG4gICAgICAgICAgYnJhY2VSOiBfYnJhY2VSLFxuICAgICAgICAgIHBhcmVuTDogX3BhcmVuTCxcbiAgICAgICAgICBwYXJlblI6IF9wYXJlblIsXG4gICAgICAgICAgY29tbWE6IF9jb21tYSxcbiAgICAgICAgICBzZW1pOiBfc2VtaSxcbiAgICAgICAgICBjb2xvbjogX2NvbG9uLFxuICAgICAgICAgIGRvdDogX2RvdCxcbiAgICAgICAgICBxdWVzdGlvbjogX3F1ZXN0aW9uLFxuICAgICAgICAgIHNsYXNoOiBfc2xhc2gsXG4gICAgICAgICAgZXE6IF9lcSxcbiAgICAgICAgICBuYW1lOiBfbmFtZSxcbiAgICAgICAgICBlb2Y6IF9lb2YsXG4gICAgICAgICAgbnVtOiBfbnVtLFxuICAgICAgICAgIHJlZ2V4cDogX3JlZ2V4cCxcbiAgICAgICAgICBzdHJpbmc6IF9zdHJpbmdcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBrdyBpbiBrZXl3b3JkVHlwZXMpIGV4cG9ydHMudG9rVHlwZXNbXCJfXCIgKyBrd10gPSBrZXl3b3JkVHlwZXNba3ddO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VQcmVkaWNhdGUod29yZHMpIHtcbiAgICAgICAgICB3b3JkcyA9IHdvcmRzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICB2YXIgZiA9IFwiXCIsXG4gICAgICAgICAgICAgIGNhdHMgPSBbXTtcblxuICAgICAgICAgIG91dDogZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYXRzLmxlbmd0aDsgKytqKSBpZiAoY2F0c1tqXVswXS5sZW5ndGggPT0gd29yZHNbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhdHNbal0ucHVzaCh3b3Jkc1tpXSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2F0cy5wdXNoKFt3b3Jkc1tpXV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVUbyhhcnIpIHtcbiAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoID09IDEpIHJldHVybiBmICs9IFwicmV0dXJuIHN0ciA9PT0gXCIgKyBKU09OLnN0cmluZ2lmeShhcnJbMF0pICsgXCI7XCI7XG4gICAgICAgICAgICBmICs9IFwic3dpdGNoKHN0cil7XCI7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSBmICs9IFwiY2FzZSBcIiArIEpTT04uc3RyaW5naWZ5KGFycltpXSkgKyBcIjpcIjtcblxuICAgICAgICAgICAgZiArPSBcInJldHVybiB0cnVlfXJldHVybiBmYWxzZTtcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2F0cy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICBjYXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGYgKz0gXCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2F0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgY2F0ID0gY2F0c1tpXTtcbiAgICAgICAgICAgICAgZiArPSBcImNhc2UgXCIgKyBjYXRbMF0ubGVuZ3RoICsgXCI6XCI7XG4gICAgICAgICAgICAgIGNvbXBhcmVUbyhjYXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmICs9IFwifVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wYXJlVG8od29yZHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJzdHJcIiwgZik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNSZXNlcnZlZFdvcmQzID0gbWFrZVByZWRpY2F0ZShcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIik7XG4gICAgICAgIHZhciBpc1Jlc2VydmVkV29yZDUgPSBtYWtlUHJlZGljYXRlKFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIik7XG4gICAgICAgIHZhciBpc1N0cmljdFJlc2VydmVkV29yZCA9IG1ha2VQcmVkaWNhdGUoXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIpO1xuICAgICAgICB2YXIgaXNTdHJpY3RCYWRJZFdvcmQgPSBtYWtlUHJlZGljYXRlKFwiZXZhbCBhcmd1bWVudHNcIik7XG4gICAgICAgIHZhciBpc0tleXdvcmQgPSBtYWtlUHJlZGljYXRlKFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCIpO1xuICAgICAgICB2YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLztcbiAgICAgICAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG4gICAgICAgIHZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjQ5XFx1MDY3Mi1cXHUwNmQzXFx1MDZlNy1cXHUwNmU4XFx1MDZmYi1cXHUwNmZjXFx1MDczMC1cXHUwNzRhXFx1MDgwMC1cXHUwODE0XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg0MC1cXHUwODU3XFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDlkN1xcdTA5ZGYtXFx1MDllMFxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Zi1cXHUwYjYwXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjItXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDQ2LVxcdTBkNDhcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzNC1cXHUwZTNhXFx1MGU0MC1cXHUwZTQ1XFx1MGU1MC1cXHUwZTU5XFx1MGViNC1cXHUwZWI5XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjQxLVxcdTBmNDdcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcwZS1cXHUxNzEwXFx1MTcyMC1cXHUxNzMwXFx1MTc0MC1cXHUxNzUwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3YjJcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk1MS1cXHUxOTZkXFx1MTliMC1cXHUxOWMwXFx1MTljOC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTE1XFx1MWEyMC1cXHUxYTUzXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWI0Ni1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMwMC1cXHUxYzIyXFx1MWM0MC1cXHUxYzQ5XFx1MWM1Yi1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWQwMC1cXHUxZGJlXFx1MWUwMS1cXHUxZjE1XFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmQ4MS1cXHUyZDk2XFx1MmRlMC1cXHUyZGZmXFx1MzAyMS1cXHUzMDI4XFx1MzA5OVxcdTMwOWFcXHVhNjQwLVxcdWE2NmRcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMC1cXHVhNmYxXFx1YTdmOC1cXHVhODAwXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwLVxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGYzLVxcdWE4ZjdcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTMwLVxcdWE5NDVcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhYTAwLVxcdWFhMjdcXHVhYTQwLVxcdWFhNDFcXHVhYTRjLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFlMC1cXHVhYWU5XFx1YWFmMi1cXHVhYWYzXFx1YWJjMC1cXHVhYmUxXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjIwLVxcdWZiMjhcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcbiAgICAgICAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG4gICAgICAgIHZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuICAgICAgICB2YXIgbmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcbiAgICAgICAgdmFyIGxpbmVCcmVhayA9IC9cXHJcXG58W1xcblxcclxcdTIwMjhcXHUyMDI5XS9nO1xuXG4gICAgICAgIHZhciBpc0lkZW50aWZpZXJTdGFydCA9IGV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNjtcbiAgICAgICAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgICAgICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlO1xuICAgICAgICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaXNJZGVudGlmaWVyQ2hhciA9IGV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICAgICAgICAgIGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgICAgICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlO1xuICAgICAgICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbGluZV9sb2NfdCgpIHtcbiAgICAgICAgICB0aGlzLmxpbmUgPSB0b2tDdXJMaW5lO1xuICAgICAgICAgIHRoaXMuY29sdW1uID0gdG9rUG9zIC0gdG9rTGluZVN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFRva2VuU3RhdGUoKSB7XG4gICAgICAgICAgdG9rQ3VyTGluZSA9IDE7XG4gICAgICAgICAgdG9rUG9zID0gdG9rTGluZVN0YXJ0ID0gMDtcbiAgICAgICAgICB0b2tSZWdleHBBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICBza2lwU3BhY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmlzaFRva2VuKHR5cGUsIHZhbCkge1xuICAgICAgICAgIHRva0VuZCA9IHRva1BvcztcbiAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHRva0VuZExvYyA9IG5ldyBsaW5lX2xvY190KCk7XG4gICAgICAgICAgdG9rVHlwZSA9IHR5cGU7XG4gICAgICAgICAgc2tpcFNwYWNlKCk7XG4gICAgICAgICAgdG9rVmFsID0gdmFsO1xuICAgICAgICAgIHRva1JlZ2V4cEFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBza2lwQmxvY2tDb21tZW50KCkge1xuICAgICAgICAgIHZhciBzdGFydExvYyA9IG9wdGlvbnMub25Db21tZW50ICYmIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190KCk7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdG9rUG9zLFxuICAgICAgICAgICAgICBlbmQgPSBpbnB1dC5pbmRleE9mKFwiKi9cIiwgdG9rUG9zICs9IDIpO1xuICAgICAgICAgIGlmIChlbmQgPT09IC0xKSByYWlzZSh0b2tQb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpO1xuICAgICAgICAgIHRva1BvcyA9IGVuZCArIDI7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgIGxpbmVCcmVhay5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgIHZhciBtYXRjaDtcblxuICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVhay5leGVjKGlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCB0b2tQb3MpIHtcbiAgICAgICAgICAgICAgKyt0b2tDdXJMaW5lO1xuICAgICAgICAgICAgICB0b2tMaW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5vbkNvbW1lbnQpIG9wdGlvbnMub25Db21tZW50KHRydWUsIGlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRva1Bvcywgc3RhcnRMb2MsIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2tpcExpbmVDb21tZW50KCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRva1BvcztcbiAgICAgICAgICB2YXIgc3RhcnRMb2MgPSBvcHRpb25zLm9uQ29tbWVudCAmJiBvcHRpb25zLmxvY2F0aW9ucyAmJiBuZXcgbGluZV9sb2NfdCgpO1xuICAgICAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICs9IDIpO1xuXG4gICAgICAgICAgd2hpbGUgKHRva1BvcyA8IGlucHV0TGVuICYmIGNoICE9PSAxMCAmJiBjaCAhPT0gMTMgJiYgY2ggIT09IDgyMzIgJiYgY2ggIT09IDgyMzMpIHtcbiAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMub25Db21tZW50KSBvcHRpb25zLm9uQ29tbWVudChmYWxzZSwgaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCB0b2tQb3MpLCBzdGFydCwgdG9rUG9zLCBzdGFydExvYywgb3B0aW9ucy5sb2NhdGlvbnMgJiYgbmV3IGxpbmVfbG9jX3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBza2lwU3BhY2UoKSB7XG4gICAgICAgICAgd2hpbGUgKHRva1BvcyA8IGlucHV0TGVuKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gMzIpIHtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAxMykge1xuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cbiAgICAgICAgICAgICAgaWYgKG5leHQgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICArK3Rva0N1ckxpbmU7XG4gICAgICAgICAgICAgICAgdG9rTGluZVN0YXJ0ID0gdG9rUG9zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykge1xuICAgICAgICAgICAgICArK3Rva1BvcztcblxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICArK3Rva0N1ckxpbmU7XG4gICAgICAgICAgICAgICAgdG9rTGluZVN0YXJ0ID0gdG9rUG9zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID4gOCAmJiBjaCA8IDE0KSB7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNDcpIHtcbiAgICAgICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXG4gICAgICAgICAgICAgIGlmIChuZXh0ID09PSA0Mikge1xuICAgICAgICAgICAgICAgIHNraXBCbG9ja0NvbW1lbnQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0ID09PSA0Nykge1xuICAgICAgICAgICAgICAgIHNraXBMaW5lQ29tbWVudCgpO1xuICAgICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAxNjApIHtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFRva2VuX2RvdCgpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgcmV0dXJuIHJlYWROdW1iZXIodHJ1ZSk7XG4gICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9kb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFRva2VuX3NsYXNoKCkge1xuICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblxuICAgICAgICAgIGlmICh0b2tSZWdleHBBbGxvd2VkKSB7XG4gICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIHJldHVybiByZWFkUmVnZXhwKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE9wKF9zbGFzaCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVG9rZW5fbXVsdF9tb2R1bG8oKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hPcChfbXVsdGlwbHlNb2R1bG8sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPT09IGNvZGUpIHJldHVybiBmaW5pc2hPcChjb2RlID09PSAxMjQgPyBfbG9naWNhbE9SIDogX2xvZ2ljYWxBTkQsIDIpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hPcChjb2RlID09PSAxMjQgPyBfYml0d2lzZU9SIDogX2JpdHdpc2VBTkQsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFRva2VuX2NhcmV0KCkge1xuICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoT3AoX2JpdHdpc2VYT1IsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFRva2VuX3BsdXNfbWluKGNvZGUpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gNDUgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PSA2MiAmJiBuZXdsaW5lLnRlc3QoaW5wdXQuc2xpY2UobGFzdEVuZCwgdG9rUG9zKSkpIHtcbiAgICAgICAgICAgICAgdG9rUG9zICs9IDM7XG4gICAgICAgICAgICAgIHNraXBMaW5lQ29tbWVudCgpO1xuICAgICAgICAgICAgICBza2lwU3BhY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmluaXNoT3AoX2luY0RlYywgMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE9wKF9wbHVzTWluLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUb2tlbl9sdF9ndChjb2RlKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuICAgICAgICAgIHZhciBzaXplID0gMTtcblxuICAgICAgICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICAgICAgICBzaXplID0gY29kZSA9PT0gNjIgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIHNpemUpID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIHNpemUgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hPcChfYml0U2hpZnQsIHNpemUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0ID09IDMzICYmIGNvZGUgPT0gNjAgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PSA0NSAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDMpID09IDQ1KSB7XG4gICAgICAgICAgICB0b2tQb3MgKz0gNDtcbiAgICAgICAgICAgIHNraXBMaW5lQ29tbWVudCgpO1xuICAgICAgICAgICAgc2tpcFNwYWNlKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHQgPT09IDYxKSBzaXplID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PT0gNjEgPyAzIDogMjtcbiAgICAgICAgICByZXR1cm4gZmluaXNoT3AoX3JlbGF0aW9uYWwsIHNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFRva2VuX2VxX2V4Y2woY29kZSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfZXF1YWxpdHksIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT09IDYxID8gMyA6IDIpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hPcChjb2RlID09PSA2MSA/IF9lcSA6IF9wcmVmaXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuX2RvdCgpO1xuXG4gICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9wYXJlbkwpO1xuXG4gICAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9wYXJlblIpO1xuXG4gICAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9zZW1pKTtcblxuICAgICAgICAgICAgY2FzZSA0NDpcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfY29tbWEpO1xuXG4gICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFja2V0TCk7XG5cbiAgICAgICAgICAgIGNhc2UgOTM6XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNrZXRSKTtcblxuICAgICAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNlTCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFjZVIpO1xuXG4gICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9jb2xvbik7XG5cbiAgICAgICAgICAgIGNhc2UgNjM6XG4gICAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX3F1ZXN0aW9uKTtcblxuICAgICAgICAgICAgY2FzZSA0ODpcbiAgICAgICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSByZXR1cm4gcmVhZEhleE51bWJlcigpO1xuXG4gICAgICAgICAgICBjYXNlIDQ5OlxuICAgICAgICAgICAgY2FzZSA1MDpcbiAgICAgICAgICAgIGNhc2UgNTE6XG4gICAgICAgICAgICBjYXNlIDUyOlxuICAgICAgICAgICAgY2FzZSA1MzpcbiAgICAgICAgICAgIGNhc2UgNTQ6XG4gICAgICAgICAgICBjYXNlIDU1OlxuICAgICAgICAgICAgY2FzZSA1NjpcbiAgICAgICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgICAgIHJldHVybiByZWFkTnVtYmVyKGZhbHNlKTtcblxuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgIHJldHVybiByZWFkU3RyaW5nKGNvZGUpO1xuXG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuX3NsYXNoKGNvZGUpO1xuXG4gICAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbl9tdWx0X21vZHVsbygpO1xuXG4gICAgICAgICAgICBjYXNlIDEyNDpcbiAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTQ6XG4gICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5fY2FyZXQoKTtcblxuICAgICAgICAgICAgY2FzZSA0MzpcbiAgICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5fcGx1c19taW4oY29kZSk7XG5cbiAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuX2x0X2d0KGNvZGUpO1xuXG4gICAgICAgICAgICBjYXNlIDYxOlxuICAgICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpO1xuXG4gICAgICAgICAgICBjYXNlIDEyNjpcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE9wKF9wcmVmaXgsIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUb2tlbihmb3JjZVJlZ2V4cCkge1xuICAgICAgICAgIGlmICghZm9yY2VSZWdleHApIHRva1N0YXJ0ID0gdG9rUG9zO2Vsc2UgdG9rUG9zID0gdG9rU3RhcnQgKyAxO1xuICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgdG9rU3RhcnRMb2MgPSBuZXcgbGluZV9sb2NfdCgpO1xuICAgICAgICAgIGlmIChmb3JjZVJlZ2V4cCkgcmV0dXJuIHJlYWRSZWdleHAoKTtcbiAgICAgICAgICBpZiAodG9rUG9zID49IGlucHV0TGVuKSByZXR1cm4gZmluaXNoVG9rZW4oX2VvZik7XG4gICAgICAgICAgdmFyIGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpIHx8IGNvZGUgPT09IDkyKSByZXR1cm4gcmVhZFdvcmQoKTtcbiAgICAgICAgICB2YXIgdG9rID0gZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcblxuICAgICAgICAgIGlmICh0b2sgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcXFxcIiB8fCBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KGNoKSkgcmV0dXJuIHJlYWRXb3JkKCk7XG4gICAgICAgICAgICByYWlzZSh0b2tQb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmlzaE9wKHR5cGUsIHNpemUpIHtcbiAgICAgICAgICB2YXIgc3RyID0gaW5wdXQuc2xpY2UodG9rUG9zLCB0b2tQb3MgKyBzaXplKTtcbiAgICAgICAgICB0b2tQb3MgKz0gc2l6ZTtcbiAgICAgICAgICBmaW5pc2hUb2tlbih0eXBlLCBzdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFJlZ2V4cCgpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IFwiXCIsXG4gICAgICAgICAgICAgIGVzY2FwZWQsXG4gICAgICAgICAgICAgIGluQ2xhc3MsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gdG9rUG9zO1xuXG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRva1BvcyA+PSBpbnB1dExlbikgcmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTtcbiAgICAgICAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJBdCh0b2tQb3MpO1xuICAgICAgICAgICAgaWYgKG5ld2xpbmUudGVzdChjaCkpIHJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7XG5cbiAgICAgICAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09IFwiW1wiKSBpbkNsYXNzID0gdHJ1ZTtlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgaW5DbGFzcyA9IGZhbHNlO2Vsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykgYnJlYWs7XG4gICAgICAgICAgICAgIGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCI7XG4gICAgICAgICAgICB9IGVsc2UgZXNjYXBlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29udGVudCA9IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpO1xuICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgIHZhciBtb2RzID0gcmVhZFdvcmQxKCk7XG4gICAgICAgICAgaWYgKG1vZHMgJiYgIS9eW2dtc2l5XSokLy50ZXN0KG1vZHMpKSByYWlzZShzdGFydCwgXCJJbnZhbGlkIHJlZ2V4cCBmbGFnXCIpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ldyBSZWdFeHAoY29udGVudCwgbW9kcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikgcmFpc2Uoc3RhcnQsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICByYWlzZShlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX3JlZ2V4cCwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZEludChyYWRpeCwgbGVuKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdG9rUG9zLFxuICAgICAgICAgICAgICB0b3RhbCA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpLFxuICAgICAgICAgICAgICAgIHZhbDtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDk3KSB2YWwgPSBjb2RlIC0gOTcgKyAxMDtlbHNlIGlmIChjb2RlID49IDY1KSB2YWwgPSBjb2RlIC0gNjUgKyAxMDtlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHZhbCA9IGNvZGUgLSA0ODtlbHNlIHZhbCA9IEluZmluaXR5O1xuICAgICAgICAgICAgaWYgKHZhbCA+PSByYWRpeCkgYnJlYWs7XG4gICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9rUG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0b2tQb3MgLSBzdGFydCAhPT0gbGVuKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkSGV4TnVtYmVyKCkge1xuICAgICAgICAgIHRva1BvcyArPSAyO1xuICAgICAgICAgIHZhciB2YWwgPSByZWFkSW50KDE2KTtcbiAgICAgICAgICBpZiAodmFsID09IG51bGwpIHJhaXNlKHRva1N0YXJ0ICsgMiwgXCJFeHBlY3RlZCBoZXhhZGVjaW1hbCBudW1iZXJcIik7XG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSkpIHJhaXNlKHRva1BvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX251bSwgdmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWROdW1iZXIoc3RhcnRzV2l0aERvdCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRva1BvcyxcbiAgICAgICAgICAgICAgaXNGbG9hdCA9IGZhbHNlLFxuICAgICAgICAgICAgICBvY3RhbCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSA9PT0gNDg7XG4gICAgICAgICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHJlYWRJbnQoMTApID09PSBudWxsKSByYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtcblxuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDQ2KSB7XG4gICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIHJlYWRJbnQoMTApO1xuICAgICAgICAgICAgaXNGbG9hdCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSB7XG4gICAgICAgICAgICBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCgrK3Rva1Bvcyk7XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpICsrdG9rUG9zO1xuICAgICAgICAgICAgaWYgKHJlYWRJbnQoMTApID09PSBudWxsKSByYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtcbiAgICAgICAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykpKSByYWlzZSh0b2tQb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7XG4gICAgICAgICAgdmFyIHN0ciA9IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpLFxuICAgICAgICAgICAgICB2YWw7XG4gICAgICAgICAgaWYgKGlzRmxvYXQpIHZhbCA9IHBhcnNlRmxvYXQoc3RyKTtlbHNlIGlmICghb2N0YWwgfHwgc3RyLmxlbmd0aCA9PT0gMSkgdmFsID0gcGFyc2VJbnQoc3RyLCAxMCk7ZWxzZSBpZiAoL1s4OV0vLnRlc3Qoc3RyKSB8fCBzdHJpY3QpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO2Vsc2UgdmFsID0gcGFyc2VJbnQoc3RyLCA4KTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX251bSwgdmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRTdHJpbmcocXVvdGUpIHtcbiAgICAgICAgICB0b2tQb3MrKztcbiAgICAgICAgICB2YXIgb3V0ID0gXCJcIjtcblxuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0b2tQb3MgPj0gaW5wdXRMZW4pIHJhaXNlKHRva1N0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7XG4gICAgICAgICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfc3RyaW5nLCBvdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2ggPT09IDkyKSB7XG4gICAgICAgICAgICAgIGNoID0gaW5wdXQuY2hhckNvZGVBdCgrK3Rva1Bvcyk7XG4gICAgICAgICAgICAgIHZhciBvY3RhbCA9IC9eWzAtN10rLy5leGVjKGlucHV0LnNsaWNlKHRva1BvcywgdG9rUG9zICsgMykpO1xuICAgICAgICAgICAgICBpZiAob2N0YWwpIG9jdGFsID0gb2N0YWxbMF07XG5cbiAgICAgICAgICAgICAgd2hpbGUgKG9jdGFsICYmIHBhcnNlSW50KG9jdGFsLCA4KSA+IDI1NSkgb2N0YWwgPSBvY3RhbC5zbGljZSgwLCAtMSk7XG5cbiAgICAgICAgICAgICAgaWYgKG9jdGFsID09PSBcIjBcIikgb2N0YWwgPSBudWxsO1xuICAgICAgICAgICAgICArK3Rva1BvcztcblxuICAgICAgICAgICAgICBpZiAob2N0YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0KSByYWlzZSh0b2tQb3MgLSAyLCBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQob2N0YWwsIDgpKTtcbiAgICAgICAgICAgICAgICB0b2tQb3MgKz0gb2N0YWwubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDExMDpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiXFxyXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDEyMDpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocmVhZEhleENoYXIoMikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlYWRIZXhDaGFyKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgODU6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlYWRIZXhDaGFyKDgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE2OlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgOTg6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIlxcYlwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMTg6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIlxcdTAwMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCJcXGZcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgNDg6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIlxcMFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSA9PT0gMTApICsrdG9rUG9zO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgKyt0b2tDdXJMaW5lO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzIHx8IGNoID09PSAxMCB8fCBjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykgcmFpc2UodG9rU3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTtcbiAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkSGV4Q2hhcihsZW4pIHtcbiAgICAgICAgICB2YXIgbiA9IHJlYWRJbnQoMTYsIGxlbik7XG4gICAgICAgICAgaWYgKG4gPT09IG51bGwpIHJhaXNlKHRva1N0YXJ0LCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRhaW5zRXNjO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRXb3JkMSgpIHtcbiAgICAgICAgICBjb250YWluc0VzYyA9IGZhbHNlO1xuICAgICAgICAgIHZhciB3b3JkLFxuICAgICAgICAgICAgICBmaXJzdCA9IHRydWUsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gdG9rUG9zO1xuXG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zRXNjKSB3b3JkICs9IGlucHV0LmNoYXJBdCh0b2tQb3MpO1xuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7XG4gICAgICAgICAgICAgIGlmICghY29udGFpbnNFc2MpIHdvcmQgPSBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKTtcbiAgICAgICAgICAgICAgY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCgrK3Rva1BvcykgIT0gMTE3KSByYWlzZSh0b2tQb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIHZhciBlc2MgPSByZWFkSGV4Q2hhcig0KTtcbiAgICAgICAgICAgICAgdmFyIGVzY1N0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXNjKTtcbiAgICAgICAgICAgICAgaWYgKCFlc2NTdHIpIHJhaXNlKHRva1BvcyAtIDEsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTtcbiAgICAgICAgICAgICAgaWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydChlc2MpIDogaXNJZGVudGlmaWVyQ2hhcihlc2MpKSkgcmFpc2UodG9rUG9zIC0gNCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgICAgICAgICB3b3JkICs9IGVzY1N0cjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250YWluc0VzYyA/IHdvcmQgOiBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRXb3JkKCkge1xuICAgICAgICAgIHZhciB3b3JkID0gcmVhZFdvcmQxKCk7XG4gICAgICAgICAgdmFyIHR5cGUgPSBfbmFtZTtcbiAgICAgICAgICBpZiAoIWNvbnRhaW5zRXNjICYmIGlzS2V5d29yZCh3b3JkKSkgdHlwZSA9IGtleXdvcmRUeXBlc1t3b3JkXTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4odHlwZSwgd29yZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIGxhc3RTdGFydCA9IHRva1N0YXJ0O1xuICAgICAgICAgIGxhc3RFbmQgPSB0b2tFbmQ7XG4gICAgICAgICAgbGFzdEVuZExvYyA9IHRva0VuZExvYztcbiAgICAgICAgICByZWFkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldFN0cmljdChzdHJjdCkge1xuICAgICAgICAgIHN0cmljdCA9IHN0cmN0O1xuICAgICAgICAgIHRva1BvcyA9IHRva1N0YXJ0O1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICB3aGlsZSAodG9rUG9zIDwgdG9rTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgIHRva0xpbmVTdGFydCA9IGlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHRva0xpbmVTdGFydCAtIDIpICsgMTtcbiAgICAgICAgICAgICAgLS10b2tDdXJMaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNraXBTcGFjZSgpO1xuICAgICAgICAgIHJlYWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbm9kZV90KCkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHRva1N0YXJ0O1xuICAgICAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5vZGVfbG9jX3QoKSB7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHRva1N0YXJ0TG9jO1xuICAgICAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICAgICAgICBpZiAoc291cmNlRmlsZSAhPT0gbnVsbCkgdGhpcy5zb3VyY2UgPSBzb3VyY2VGaWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RhcnROb2RlKCkge1xuICAgICAgICAgIHZhciBub2RlID0gbmV3IG5vZGVfdCgpO1xuICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgbm9kZS5sb2MgPSBuZXcgbm9kZV9sb2NfdCgpO1xuICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpIG5vZGUuc291cmNlRmlsZSA9IG9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5yYW5nZXMpIG5vZGUucmFuZ2UgPSBbdG9rU3RhcnQsIDBdO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RhcnROb2RlRnJvbShvdGhlcikge1xuICAgICAgICAgIHZhciBub2RlID0gbmV3IG5vZGVfdCgpO1xuICAgICAgICAgIG5vZGUuc3RhcnQgPSBvdGhlci5zdGFydDtcblxuICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgbm9kZS5sb2MgPSBuZXcgbm9kZV9sb2NfdCgpO1xuICAgICAgICAgICAgbm9kZS5sb2Muc3RhcnQgPSBvdGhlci5sb2Muc3RhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKSBub2RlLnJhbmdlID0gW290aGVyLnJhbmdlWzBdLCAwXTtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmlzaE5vZGUobm9kZSwgdHlwZSkge1xuICAgICAgICAgIG5vZGUudHlwZSA9IHR5cGU7XG4gICAgICAgICAgbm9kZS5lbmQgPSBsYXN0RW5kO1xuICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgbm9kZS5sb2MuZW5kID0gbGFzdEVuZExvYztcbiAgICAgICAgICBpZiAob3B0aW9ucy5yYW5nZXMpIG5vZGUucmFuZ2VbMV0gPSBsYXN0RW5kO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNVc2VTdHJpY3Qoc3RtdCkge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgc3RtdC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgc3RtdC5leHByZXNzaW9uLnZhbHVlID09PSBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVhdCh0eXBlKSB7XG4gICAgICAgICAgaWYgKHRva1R5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbkluc2VydFNlbWljb2xvbigpIHtcbiAgICAgICAgICByZXR1cm4gIW9wdGlvbnMuc3RyaWN0U2VtaWNvbG9ucyAmJiAodG9rVHlwZSA9PT0gX2VvZiB8fCB0b2tUeXBlID09PSBfYnJhY2VSIHx8IG5ld2xpbmUudGVzdChpbnB1dC5zbGljZShsYXN0RW5kLCB0b2tTdGFydCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNlbWljb2xvbigpIHtcbiAgICAgICAgICBpZiAoIWVhdChfc2VtaSkgJiYgIWNhbkluc2VydFNlbWljb2xvbigpKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBleHBlY3QodHlwZSkge1xuICAgICAgICAgIGlmICh0b2tUeXBlID09PSB0eXBlKSBuZXh0KCk7ZWxzZSB1bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1bmV4cGVjdGVkKCkge1xuICAgICAgICAgIHJhaXNlKHRva1N0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja0xWYWwoZXhwcikge1xuICAgICAgICAgIGlmIChleHByLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIGV4cHIudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHJhaXNlKGV4cHIuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgaXNTdHJpY3RCYWRJZFdvcmQoZXhwci5uYW1lKSkgcmFpc2UoZXhwci5zdGFydCwgXCJBc3NpZ25pbmcgdG8gXCIgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlVG9wTGV2ZWwocHJvZ3JhbSkge1xuICAgICAgICAgIGxhc3RTdGFydCA9IGxhc3RFbmQgPSB0b2tQb3M7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSBsYXN0RW5kTG9jID0gbmV3IGxpbmVfbG9jX3QoKTtcbiAgICAgICAgICBpbkZ1bmN0aW9uID0gc3RyaWN0ID0gbnVsbDtcbiAgICAgICAgICBsYWJlbHMgPSBbXTtcbiAgICAgICAgICByZWFkVG9rZW4oKTtcbiAgICAgICAgICB2YXIgbm9kZSA9IHByb2dyYW0gfHwgc3RhcnROb2RlKCksXG4gICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXByb2dyYW0pIG5vZGUuYm9keSA9IFtdO1xuXG4gICAgICAgICAgd2hpbGUgKHRva1R5cGUgIT09IF9lb2YpIHtcbiAgICAgICAgICAgIHZhciBzdG10ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIGlzVXNlU3RyaWN0KHN0bXQpKSBzZXRTdHJpY3QodHJ1ZSk7XG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb29wTGFiZWwgPSB7XG4gICAgICAgICAga2luZDogXCJsb29wXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHN3aXRjaExhYmVsID0ge1xuICAgICAgICAgIGtpbmQ6IFwic3dpdGNoXCJcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gX3NsYXNoIHx8IHRva1R5cGUgPT09IF9hc3NpZ24gJiYgdG9rVmFsID09IFwiLz1cIikgcmVhZFRva2VuKHRydWUpO1xuICAgICAgICAgIHZhciBzdGFydHR5cGUgPSB0b2tUeXBlLFxuICAgICAgICAgICAgICBub2RlID0gc3RhcnROb2RlKCk7XG5cbiAgICAgICAgICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICAgICAgICAgICAgY2FzZSBfYnJlYWs6XG4gICAgICAgICAgICBjYXNlIF9jb250aW51ZTpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICB2YXIgaXNCcmVhayA9IHN0YXJ0dHlwZSA9PT0gX2JyZWFrO1xuICAgICAgICAgICAgICBpZiAoZWF0KF9zZW1pKSB8fCBjYW5JbnNlcnRTZW1pY29sb24oKSkgbm9kZS5sYWJlbCA9IG51bGw7ZWxzZSBpZiAodG9rVHlwZSAhPT0gX25hbWUpIHVuZXhwZWN0ZWQoKTtlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmxhYmVsID0gcGFyc2VJZGVudCgpO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiID0gbGFiZWxzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSBicmVhaztcbiAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpID09PSBsYWJlbHMubGVuZ3RoKSByYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsgc3RhcnR0eXBlLmtleXdvcmQpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfZGVidWdnZXI6XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX2RvOlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIGxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgICAgICAgICAgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgIGxhYmVscy5wb3AoKTtcbiAgICAgICAgICAgICAgZXhwZWN0KF93aGlsZSk7XG4gICAgICAgICAgICAgIG5vZGUudGVzdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX2ZvcjpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBsYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgICAgICAgICAgICBleHBlY3QoX3BhcmVuTCk7XG4gICAgICAgICAgICAgIGlmICh0b2tUeXBlID09PSBfc2VtaSkgcmV0dXJuIHBhcnNlRm9yKG5vZGUsIG51bGwpO1xuXG4gICAgICAgICAgICAgIGlmICh0b2tUeXBlID09PSBfdmFyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXQgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VWYXIoaW5pdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZmluaXNoTm9kZShpbml0LCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKGluaXQuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBlYXQoX2luKSkgcmV0dXJuIHBhcnNlRm9ySW4obm9kZSwgaW5pdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRm9yKG5vZGUsIGluaXQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGluaXQgPSBwYXJzZUV4cHJlc3Npb24oZmFsc2UsIHRydWUpO1xuXG4gICAgICAgICAgICAgIGlmIChlYXQoX2luKSkge1xuICAgICAgICAgICAgICAgIGNoZWNrTFZhbChpbml0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGb3JJbihub2RlLCBpbml0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZvcihub2RlLCBpbml0KTtcblxuICAgICAgICAgICAgY2FzZSBfZnVuY3Rpb246XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb24obm9kZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNhc2UgX2lmOlxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIG5vZGUudGVzdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgIG5vZGUuY29uc2VxdWVudCA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlID0gZWF0KF9lbHNlKSA/IHBhcnNlU3RhdGVtZW50KCkgOiBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBjYXNlIF9yZXR1cm46XG4gICAgICAgICAgICAgIGlmICghaW5GdW5jdGlvbiAmJiAhb3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbikgcmFpc2UodG9rU3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBpZiAoZWF0KF9zZW1pKSB8fCBjYW5JbnNlcnRTZW1pY29sb24oKSkgbm9kZS5hcmd1bWVudCA9IG51bGw7ZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBjYXNlIF9zd2l0Y2g6XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbm9kZS5kaXNjcmltaW5hbnQgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICBub2RlLmNhc2VzID0gW107XG4gICAgICAgICAgICAgIGV4cGVjdChfYnJhY2VMKTtcbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGN1ciwgc2F3RGVmYXVsdDsgdG9rVHlwZSAhPSBfYnJhY2VSOykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tUeXBlID09PSBfY2FzZSB8fCB0b2tUeXBlID09PSBfZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGlzQ2FzZSA9IHRva1R5cGUgPT09IF9jYXNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cikgZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTtcbiAgICAgICAgICAgICAgICAgIG5vZGUuY2FzZXMucHVzaChjdXIgPSBzdGFydE5vZGUoKSk7XG4gICAgICAgICAgICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FzZSkgY3VyLnRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhd0RlZmF1bHQpIHJhaXNlKGxhc3RTdGFydCwgXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHNhd0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjdXIudGVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBleHBlY3QoX2NvbG9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKCFjdXIpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGN1cikgZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBsYWJlbHMucG9wKCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBjYXNlIF90aHJvdzpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBpZiAobmV3bGluZS50ZXN0KGlucHV0LnNsaWNlKGxhc3RFbmQsIHRva1N0YXJ0KSkpIHJhaXNlKGxhc3RFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpO1xuICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBjYXNlIF90cnk6XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbm9kZS5ibG9jayA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgICAgICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gX2NhdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXVzZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoX3BhcmVuTCk7XG4gICAgICAgICAgICAgICAgY2xhdXNlLnBhcmFtID0gcGFyc2VJZGVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RCYWRJZFdvcmQoY2xhdXNlLnBhcmFtLm5hbWUpKSByYWlzZShjbGF1c2UucGFyYW0uc3RhcnQsIFwiQmluZGluZyBcIiArIGNsYXVzZS5wYXJhbS5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICAgICAgZXhwZWN0KF9wYXJlblIpO1xuICAgICAgICAgICAgICAgIGNsYXVzZS5ndWFyZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2xhdXNlLmJvZHkgPSBwYXJzZUJsb2NrKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5oYW5kbGVyID0gZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBub2RlLmd1YXJkZWRIYW5kbGVycyA9IGVtcHR5O1xuICAgICAgICAgICAgICBub2RlLmZpbmFsaXplciA9IGVhdChfZmluYWxseSkgPyBwYXJzZUJsb2NrKCkgOiBudWxsO1xuICAgICAgICAgICAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpIHJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX3ZhcjpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBwYXJzZVZhcihub2RlKTtcbiAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcblxuICAgICAgICAgICAgY2FzZSBfd2hpbGU6XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbm9kZS50ZXN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICAgICAgICAgICAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgbGFiZWxzLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBjYXNlIF93aXRoOlxuICAgICAgICAgICAgICBpZiAoc3RyaWN0KSByYWlzZSh0b2tTdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbm9kZS5vYmplY3QgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX2JyYWNlTDpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQmxvY2soKTtcblxuICAgICAgICAgICAgY2FzZSBfc2VtaTpcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB2YXIgbWF5YmVOYW1lID0gdG9rVmFsLFxuICAgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgICAgICAgIGlmIChzdGFydHR5cGUgPT09IF9uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZWF0KF9jb2xvbikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSkgaWYgKGxhYmVsc1tpXS5uYW1lID09PSBtYXliZU5hbWUpIHJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG5cbiAgICAgICAgICAgICAgICB2YXIga2luZCA9IHRva1R5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0b2tUeXBlID09PSBfc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbmFtZTogbWF5YmVOYW1lLFxuICAgICAgICAgICAgICAgICAga2luZDoga2luZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnBvcCgpO1xuICAgICAgICAgICAgICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VQYXJlbkV4cHJlc3Npb24oKSB7XG4gICAgICAgICAgZXhwZWN0KF9wYXJlbkwpO1xuICAgICAgICAgIHZhciB2YWwgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICBleHBlY3QoX3BhcmVuUik7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlQmxvY2soYWxsb3dTdHJpY3QpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpLFxuICAgICAgICAgICAgICBmaXJzdCA9IHRydWUsXG4gICAgICAgICAgICAgIHN0cmljdCA9IGZhbHNlLFxuICAgICAgICAgICAgICBvbGRTdHJpY3Q7XG4gICAgICAgICAgbm9kZS5ib2R5ID0gW107XG4gICAgICAgICAgZXhwZWN0KF9icmFjZUwpO1xuXG4gICAgICAgICAgd2hpbGUgKCFlYXQoX2JyYWNlUikpIHtcbiAgICAgICAgICAgIHZhciBzdG10ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3QgJiYgYWxsb3dTdHJpY3QgJiYgaXNVc2VTdHJpY3Qoc3RtdCkpIHtcbiAgICAgICAgICAgICAgb2xkU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICAgICAgICBzZXRTdHJpY3Qoc3RyaWN0ID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0cmljdCAmJiAhb2xkU3RyaWN0KSBzZXRTdHJpY3QoZmFsc2UpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUZvcihub2RlLCBpbml0KSB7XG4gICAgICAgICAgbm9kZS5pbml0ID0gaW5pdDtcbiAgICAgICAgICBleHBlY3QoX3NlbWkpO1xuICAgICAgICAgIG5vZGUudGVzdCA9IHRva1R5cGUgPT09IF9zZW1pID8gbnVsbCA6IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIGV4cGVjdChfc2VtaSk7XG4gICAgICAgICAgbm9kZS51cGRhdGUgPSB0b2tUeXBlID09PSBfcGFyZW5SID8gbnVsbCA6IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICAgICAgICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgIGxhYmVscy5wb3AoKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRm9ySW4obm9kZSwgaW5pdCkge1xuICAgICAgICAgIG5vZGUubGVmdCA9IGluaXQ7XG4gICAgICAgICAgbm9kZS5yaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICAgICAgICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgIGxhYmVscy5wb3AoKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkZvckluU3RhdGVtZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VWYXIobm9kZSwgbm9Jbikge1xuICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgICAgICAgbm9kZS5raW5kID0gXCJ2YXJcIjtcblxuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHZhciBkZWNsID0gc3RhcnROb2RlKCk7XG4gICAgICAgICAgICBkZWNsLmlkID0gcGFyc2VJZGVudCgpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBpc1N0cmljdEJhZElkV29yZChkZWNsLmlkLm5hbWUpKSByYWlzZShkZWNsLmlkLnN0YXJ0LCBcIkJpbmRpbmcgXCIgKyBkZWNsLmlkLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgIGRlY2wuaW5pdCA9IGVhdChfZXEpID8gcGFyc2VFeHByZXNzaW9uKHRydWUsIG5vSW4pIDogbnVsbDtcbiAgICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2goZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgICAgICAgICBpZiAoIWVhdChfY29tbWEpKSBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihub0NvbW1hLCBub0luKSB7XG4gICAgICAgICAgdmFyIGV4cHIgPSBwYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuXG4gICAgICAgICAgaWYgKCFub0NvbW1hICYmIHRva1R5cGUgPT09IF9jb21tYSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGV4cHIpO1xuICAgICAgICAgICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcblxuICAgICAgICAgICAgd2hpbGUgKGVhdChfY29tbWEpKSBub2RlLmV4cHJlc3Npb25zLnB1c2gocGFyc2VNYXliZUFzc2lnbihub0luKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VNYXliZUFzc2lnbihub0luKSB7XG4gICAgICAgICAgdmFyIGxlZnQgPSBwYXJzZU1heWJlQ29uZGl0aW9uYWwobm9Jbik7XG5cbiAgICAgICAgICBpZiAodG9rVHlwZS5pc0Fzc2lnbikge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGxlZnQpO1xuICAgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcbiAgICAgICAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBub2RlLnJpZ2h0ID0gcGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICAgICAgICAgIGNoZWNrTFZhbChsZWZ0KTtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZU1heWJlQ29uZGl0aW9uYWwobm9Jbikge1xuICAgICAgICAgIHZhciBleHByID0gcGFyc2VFeHByT3BzKG5vSW4pO1xuXG4gICAgICAgICAgaWYgKGVhdChfcXVlc3Rpb24pKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oZXhwcik7XG4gICAgICAgICAgICBub2RlLnRlc3QgPSBleHByO1xuICAgICAgICAgICAgbm9kZS5jb25zZXF1ZW50ID0gcGFyc2VFeHByZXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KF9jb2xvbik7XG4gICAgICAgICAgICBub2RlLmFsdGVybmF0ZSA9IHBhcnNlRXhwcmVzc2lvbih0cnVlLCBub0luKTtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VFeHByT3BzKG5vSW4pIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VFeHByT3AocGFyc2VNYXliZVVuYXJ5KCksIC0xLCBub0luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRXhwck9wKGxlZnQsIG1pblByZWMsIG5vSW4pIHtcbiAgICAgICAgICB2YXIgcHJlYyA9IHRva1R5cGUuYmlub3A7XG5cbiAgICAgICAgICBpZiAocHJlYyAhPSBudWxsICYmICghbm9JbiB8fCB0b2tUeXBlICE9PSBfaW4pKSB7XG4gICAgICAgICAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGxlZnQpO1xuICAgICAgICAgICAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gdG9rVmFsO1xuICAgICAgICAgICAgICB2YXIgb3AgPSB0b2tUeXBlO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIG5vZGUucmlnaHQgPSBwYXJzZUV4cHJPcChwYXJzZU1heWJlVW5hcnkoKSwgcHJlYywgbm9Jbik7XG4gICAgICAgICAgICAgIHZhciBleHByTm9kZSA9IGZpbmlzaE5vZGUobm9kZSwgb3AgPT09IF9sb2dpY2FsT1IgfHwgb3AgPT09IF9sb2dpY2FsQU5EID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHByT3AoZXhwck5vZGUsIG1pblByZWMsIG5vSW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VNYXliZVVuYXJ5KCkge1xuICAgICAgICAgIGlmICh0b2tUeXBlLnByZWZpeCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKSxcbiAgICAgICAgICAgICAgICB1cGRhdGUgPSB0b2tUeXBlLmlzVXBkYXRlO1xuICAgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcbiAgICAgICAgICAgIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRva1JlZ2V4cEFsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgbm9kZS5hcmd1bWVudCA9IHBhcnNlTWF5YmVVbmFyeSgpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZSkgY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQpO2Vsc2UgaWYgKHN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHJhaXNlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBleHByID0gcGFyc2VFeHByU3Vic2NyaXB0cygpO1xuXG4gICAgICAgICAgd2hpbGUgKHRva1R5cGUucG9zdGZpeCAmJiAhY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShleHByKTtcbiAgICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG4gICAgICAgICAgICBub2RlLnByZWZpeCA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICAgICAgICBjaGVja0xWYWwoZXhwcik7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBleHByID0gZmluaXNoTm9kZShub2RlLCBcIlVwZGF0ZUV4cHJlc3Npb25cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHRzKCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN1YnNjcmlwdHMocGFyc2VFeHByQXRvbSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlU3Vic2NyaXB0cyhiYXNlLCBub0NhbGxzKSB7XG4gICAgICAgICAgaWYgKGVhdChfZG90KSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGJhc2UpO1xuICAgICAgICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICAgICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpLCBub0NhbGxzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVhdChfYnJhY2tldEwpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oYmFzZSk7XG4gICAgICAgICAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICAgICAgICBub2RlLnByb3BlcnR5ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBub2RlLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGV4cGVjdChfYnJhY2tldFIpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhmaW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKSwgbm9DYWxscyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiBlYXQoX3BhcmVuTCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShiYXNlKTtcbiAgICAgICAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgICAgICAgIG5vZGUuYXJndW1lbnRzID0gcGFyc2VFeHByTGlzdChfcGFyZW5SLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKSwgbm9DYWxscyk7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBiYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VFeHByQXRvbSgpIHtcbiAgICAgICAgICBzd2l0Y2ggKHRva1R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgX3RoaXM6XG4gICAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKTtcblxuICAgICAgICAgICAgY2FzZSBfbmFtZTpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSWRlbnQoKTtcblxuICAgICAgICAgICAgY2FzZSBfbnVtOlxuICAgICAgICAgICAgY2FzZSBfc3RyaW5nOlxuICAgICAgICAgICAgY2FzZSBfcmVnZXhwOlxuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICBub2RlLnZhbHVlID0gdG9rVmFsO1xuICAgICAgICAgICAgICBub2RlLnJhdyA9IGlucHV0LnNsaWNlKHRva1N0YXJ0LCB0b2tFbmQpO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKTtcblxuICAgICAgICAgICAgY2FzZSBfbnVsbDpcbiAgICAgICAgICAgIGNhc2UgX3RydWU6XG4gICAgICAgICAgICBjYXNlIF9mYWxzZTpcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHRva1R5cGUuYXRvbVZhbHVlO1xuICAgICAgICAgICAgICBub2RlLnJhdyA9IHRva1R5cGUua2V5d29yZDtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIik7XG5cbiAgICAgICAgICAgIGNhc2UgX3BhcmVuTDpcbiAgICAgICAgICAgICAgdmFyIHRva1N0YXJ0TG9jMSA9IHRva1N0YXJ0TG9jLFxuICAgICAgICAgICAgICAgICAgdG9rU3RhcnQxID0gdG9rU3RhcnQ7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICB2YWwuc3RhcnQgPSB0b2tTdGFydDE7XG4gICAgICAgICAgICAgIHZhbC5lbmQgPSB0b2tFbmQ7XG5cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFsLmxvYy5zdGFydCA9IHRva1N0YXJ0TG9jMTtcbiAgICAgICAgICAgICAgICB2YWwubG9jLmVuZCA9IHRva0VuZExvYztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnJhbmdlcykgdmFsLnJhbmdlID0gW3Rva1N0YXJ0MSwgdG9rRW5kXTtcbiAgICAgICAgICAgICAgZXhwZWN0KF9wYXJlblIpO1xuICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuXG4gICAgICAgICAgICBjYXNlIF9icmFja2V0TDpcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICBub2RlLmVsZW1lbnRzID0gcGFyc2VFeHByTGlzdChfYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkFycmF5RXhwcmVzc2lvblwiKTtcblxuICAgICAgICAgICAgY2FzZSBfYnJhY2VMOlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VPYmooKTtcblxuICAgICAgICAgICAgY2FzZSBfZnVuY3Rpb246XG4gICAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb24obm9kZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICBjYXNlIF9uZXc6XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZU5ldygpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VOZXcoKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgbm9kZS5jYWxsZWUgPSBwYXJzZVN1YnNjcmlwdHMocGFyc2VFeHByQXRvbSgpLCB0cnVlKTtcbiAgICAgICAgICBpZiAoZWF0KF9wYXJlbkwpKSBub2RlLmFyZ3VtZW50cyA9IHBhcnNlRXhwckxpc3QoX3BhcmVuUiwgZmFsc2UpO2Vsc2Ugbm9kZS5hcmd1bWVudHMgPSBlbXB0eTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZU9iaigpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpLFxuICAgICAgICAgICAgICBmaXJzdCA9IHRydWUsXG4gICAgICAgICAgICAgIHNhd0dldFNldCA9IGZhbHNlO1xuICAgICAgICAgIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgIHdoaWxlICghZWF0KF9icmFjZVIpKSB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgIGV4cGVjdChfY29tbWEpO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1RyYWlsaW5nQ29tbWFzICYmIGVhdChfYnJhY2VSKSkgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgZmlyc3QgPSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIHByb3AgPSB7XG4gICAgICAgICAgICAgIGtleTogcGFyc2VQcm9wZXJ0eU5hbWUoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0dldFNldCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtpbmQ7XG5cbiAgICAgICAgICAgIGlmIChlYXQoX2NvbG9uKSkge1xuICAgICAgICAgICAgICBwcm9wLnZhbHVlID0gcGFyc2VFeHByZXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgICBraW5kID0gcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSkge1xuICAgICAgICAgICAgICBpc0dldFNldCA9IHNhd0dldFNldCA9IHRydWU7XG4gICAgICAgICAgICAgIGtpbmQgPSBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgICAgICAgICAgICBwcm9wLmtleSA9IHBhcnNlUHJvcGVydHlOYW1lKCk7XG4gICAgICAgICAgICAgIGlmICh0b2tUeXBlICE9PSBfcGFyZW5MKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgIHByb3AudmFsdWUgPSBwYXJzZUZ1bmN0aW9uKHN0YXJ0Tm9kZSgpLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2UgdW5leHBlY3RlZCgpO1xuXG4gICAgICAgICAgICBpZiAocHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgKHN0cmljdCB8fCBzYXdHZXRTZXQpKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gbm9kZS5wcm9wZXJ0aWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyLmtleS5uYW1lID09PSBwcm9wLmtleS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29uZmxpY3QgPSBraW5kID09IG90aGVyLmtpbmQgfHwgaXNHZXRTZXQgJiYgb3RoZXIua2luZCA9PT0gXCJpbml0XCIgfHwga2luZCA9PT0gXCJpbml0XCIgJiYgKG90aGVyLmtpbmQgPT09IFwiZ2V0XCIgfHwgb3RoZXIua2luZCA9PT0gXCJzZXRcIik7XG4gICAgICAgICAgICAgICAgICBpZiAoY29uZmxpY3QgJiYgIXN0cmljdCAmJiBraW5kID09PSBcImluaXRcIiAmJiBvdGhlci5raW5kID09PSBcImluaXRcIikgY29uZmxpY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb25mbGljdCkgcmFpc2UocHJvcC5rZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIk9iamVjdEV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5TmFtZSgpIHtcbiAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gX251bSB8fCB0b2tUeXBlID09PSBfc3RyaW5nKSByZXR1cm4gcGFyc2VFeHByQXRvbSgpO1xuICAgICAgICAgIHJldHVybiBwYXJzZUlkZW50KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICAgICAgICAgIGlmICh0b2tUeXBlID09PSBfbmFtZSkgbm9kZS5pZCA9IHBhcnNlSWRlbnQoKTtlbHNlIGlmIChpc1N0YXRlbWVudCkgdW5leHBlY3RlZCgpO2Vsc2Ugbm9kZS5pZCA9IG51bGw7XG4gICAgICAgICAgbm9kZS5wYXJhbXMgPSBbXTtcbiAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgIGV4cGVjdChfcGFyZW5MKTtcblxuICAgICAgICAgIHdoaWxlICghZWF0KF9wYXJlblIpKSB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0KSBleHBlY3QoX2NvbW1hKTtlbHNlIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBub2RlLnBhcmFtcy5wdXNoKHBhcnNlSWRlbnQoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9sZEluRnVuYyA9IGluRnVuY3Rpb24sXG4gICAgICAgICAgICAgIG9sZExhYmVscyA9IGxhYmVscztcbiAgICAgICAgICBpbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBsYWJlbHMgPSBbXTtcbiAgICAgICAgICBub2RlLmJvZHkgPSBwYXJzZUJsb2NrKHRydWUpO1xuICAgICAgICAgIGluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7XG4gICAgICAgICAgbGFiZWxzID0gb2xkTGFiZWxzO1xuXG4gICAgICAgICAgaWYgKHN0cmljdCB8fCBub2RlLmJvZHkuYm9keS5sZW5ndGggJiYgaXNVc2VTdHJpY3Qobm9kZS5ib2R5LmJvZHlbMF0pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbm9kZS5pZCA/IC0xIDogMDsgaSA8IG5vZGUucGFyYW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9IGkgPCAwID8gbm9kZS5pZCA6IG5vZGUucGFyYW1zW2ldO1xuICAgICAgICAgICAgICBpZiAoaXNTdHJpY3RSZXNlcnZlZFdvcmQoaWQubmFtZSkgfHwgaXNTdHJpY3RCYWRJZFdvcmQoaWQubmFtZSkpIHJhaXNlKGlkLnN0YXJ0LCBcIkRlZmluaW5nICdcIiArIGlkLm5hbWUgKyBcIicgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICAgIGlmIChpID49IDApIGZvciAodmFyIGogPSAwOyBqIDwgaTsgKytqKSBpZiAoaWQubmFtZSA9PT0gbm9kZS5wYXJhbXNbal0ubmFtZSkgcmFpc2UoaWQuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaCBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUV4cHJMaXN0KGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHkpIHtcbiAgICAgICAgICB2YXIgZWx0cyA9IFtdLFxuICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG5cbiAgICAgICAgICB3aGlsZSAoIWVhdChjbG9zZSkpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgZXhwZWN0KF9jb21tYSk7XG4gICAgICAgICAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgb3B0aW9ucy5hbGxvd1RyYWlsaW5nQ29tbWFzICYmIGVhdChjbG9zZSkpIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRva1R5cGUgPT09IF9jb21tYSkgZWx0cy5wdXNoKG51bGwpO2Vsc2UgZWx0cy5wdXNoKHBhcnNlRXhwcmVzc2lvbih0cnVlKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsdHM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUlkZW50KGxpYmVyYWwpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIGlmIChsaWJlcmFsICYmIG9wdGlvbnMuZm9yYmlkUmVzZXJ2ZWQgPT0gXCJldmVyeXdoZXJlXCIpIGxpYmVyYWwgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICh0b2tUeXBlID09PSBfbmFtZSkge1xuICAgICAgICAgICAgaWYgKCFsaWJlcmFsICYmIChvcHRpb25zLmZvcmJpZFJlc2VydmVkICYmIChvcHRpb25zLmVjbWFWZXJzaW9uID09PSAzID8gaXNSZXNlcnZlZFdvcmQzIDogaXNSZXNlcnZlZFdvcmQ1KSh0b2tWYWwpIHx8IHN0cmljdCAmJiBpc1N0cmljdFJlc2VydmVkV29yZCh0b2tWYWwpKSAmJiBpbnB1dC5zbGljZSh0b2tTdGFydCwgdG9rRW5kKS5pbmRleE9mKFwiXFxcXFwiKSA9PSAtMSkgcmFpc2UodG9rU3RhcnQsIFwiVGhlIGtleXdvcmQgJ1wiICsgdG9rVmFsICsgXCInIGlzIHJlc2VydmVkXCIpO1xuICAgICAgICAgICAgbm9kZS5uYW1lID0gdG9rVmFsO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGliZXJhbCAmJiB0b2tUeXBlLmtleXdvcmQpIHtcbiAgICAgICAgICAgIG5vZGUubmFtZSA9IHRva1R5cGUua2V5d29yZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva1JlZ2V4cEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFhY29ybi52ZXJzaW9uKSBhY29ybiA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIChnbG9iYWwuYWNvcm4gfHwgYWNvcm4pLnBhcnNlKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBiaW5hcnlPcGVyYXRvcnMgPSB7XG4gICAgICAnKyc6ICdfX2FkZCcsXG4gICAgICAnLSc6ICdfX3N1YnRyYWN0JyxcbiAgICAgICcqJzogJ19fbXVsdGlwbHknLFxuICAgICAgJy8nOiAnX19kaXZpZGUnLFxuICAgICAgJyUnOiAnX19tb2R1bG8nLFxuICAgICAgJz09JzogJ19fZXF1YWxzJyxcbiAgICAgICchPSc6ICdfX2VxdWFscydcbiAgICB9O1xuICAgIHZhciB1bmFyeU9wZXJhdG9ycyA9IHtcbiAgICAgICctJzogJ19fbmVnYXRlJyxcbiAgICAgICcrJzogJ19fc2VsZidcbiAgICB9O1xuICAgIHZhciBmaWVsZHMgPSBCYXNlLmVhY2goWydhZGQnLCAnc3VidHJhY3QnLCAnbXVsdGlwbHknLCAnZGl2aWRlJywgJ21vZHVsbycsICdlcXVhbHMnLCAnbmVnYXRlJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB0aGlzWydfXycgKyBuYW1lXSA9ICcjJyArIG5hbWU7XG4gICAgfSwge1xuICAgICAgX19zZWxmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFBvaW50LmluamVjdChmaWVsZHMpO1xuICAgIFNpemUuaW5qZWN0KGZpZWxkcyk7XG4gICAgQ29sb3IuaW5qZWN0KGZpZWxkcyk7XG5cbiAgICBmdW5jdGlvbiBfXyRfXyhsZWZ0LCBvcGVyYXRvciwgcmlnaHQpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gYmluYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblxuICAgICAgaWYgKGxlZnQgJiYgbGVmdFtoYW5kbGVyXSkge1xuICAgICAgICB2YXIgcmVzID0gbGVmdFtoYW5kbGVyXShyaWdodCk7XG4gICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gJyE9JyA/ICFyZXMgOiByZXM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodDtcblxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuXG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgIHJldHVybiBsZWZ0ICogcmlnaHQ7XG5cbiAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgcmV0dXJuIGxlZnQgLyByaWdodDtcblxuICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICByZXR1cm4gbGVmdCAlIHJpZ2h0O1xuXG4gICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICByZXR1cm4gbGVmdCA9PSByaWdodDtcblxuICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgcmV0dXJuIGxlZnQgIT0gcmlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJF9fKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgdmFyIGhhbmRsZXIgPSB1bmFyeU9wZXJhdG9yc1tvcGVyYXRvcl07XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWVbaGFuZGxlcl0pIHJldHVybiB2YWx1ZVtoYW5kbGVyXSgpO1xuXG4gICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgIHJldHVybiArdmFsdWU7XG5cbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcmV0dXJuIC12YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21waWxlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghY29kZSkgcmV0dXJuICcnO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgaW5zZXJ0aW9ucyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBnZXRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5zZXJ0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgaW5zZXJ0aW9uID0gaW5zZXJ0aW9uc1tpXTtcbiAgICAgICAgICBpZiAoaW5zZXJ0aW9uWzBdID49IG9mZnNldCkgYnJlYWs7XG4gICAgICAgICAgb2Zmc2V0ICs9IGluc2VydGlvblsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldENvZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gY29kZS5zdWJzdHJpbmcoZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMF0pLCBnZXRPZmZzZXQobm9kZS5yYW5nZVsxXSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRCZXR3ZWVuKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBjb2RlLnN1YnN0cmluZyhnZXRPZmZzZXQobGVmdC5yYW5nZVsxXSksIGdldE9mZnNldChyaWdodC5yYW5nZVswXSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZXBsYWNlQ29kZShub2RlLCBzdHIpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMF0pLFxuICAgICAgICAgICAgZW5kID0gZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMV0pLFxuICAgICAgICAgICAgaW5zZXJ0ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gaW5zZXJ0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChzdGFydCA+IGluc2VydGlvbnNbaV1bMF0pIHtcbiAgICAgICAgICAgIGluc2VydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5zZXJ0aW9ucy5zcGxpY2UoaW5zZXJ0LCAwLCBbc3RhcnQsIHN0ci5sZW5ndGggLSBlbmQgKyBzdGFydF0pO1xuICAgICAgICBjb2RlID0gY29kZS5zdWJzdHJpbmcoMCwgc3RhcnQpICsgc3RyICsgY29kZS5zdWJzdHJpbmcoZW5kKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlT3ZlcmxvYWRpbmcobm9kZSwgcGFyZW50KSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGlmIChub2RlLm9wZXJhdG9yIGluIHVuYXJ5T3BlcmF0b3JzICYmIG5vZGUuYXJndW1lbnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgIHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpO1xuICAgICAgICAgICAgICByZXBsYWNlQ29kZShub2RlLCAnJF9fKFwiJyArIG5vZGUub3BlcmF0b3IgKyAnXCIsICcgKyBhcmcgKyAnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgaW4gYmluYXJ5T3BlcmF0b3JzICYmIG5vZGUubGVmdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgICAgdmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG4gICAgICAgICAgICAgICAgICByaWdodCA9IGdldENvZGUobm9kZS5yaWdodCksXG4gICAgICAgICAgICAgICAgICBiZXR3ZWVuID0gZ2V0QmV0d2Vlbihub2RlLmxlZnQsIG5vZGUucmlnaHQpLFxuICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yO1xuICAgICAgICAgICAgICByZXBsYWNlQ29kZShub2RlLCAnX18kX18oJyArIGxlZnQgKyAnLCcgKyBiZXR3ZWVuLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXCcgKyBvcGVyYXRvciksICdcIicgKyBvcGVyYXRvciArICdcIicpICsgJywgJyArIHJpZ2h0ICsgJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHBhcmVudCAmJiBwYXJlbnQudHlwZTtcblxuICAgICAgICAgICAgaWYgKCEocGFyZW50VHlwZSA9PT0gJ0ZvclN0YXRlbWVudCcgfHwgcGFyZW50VHlwZSA9PT0gJ0JpbmFyeUV4cHJlc3Npb24nICYmIC9eWz0hPD5dLy50ZXN0KHBhcmVudC5vcGVyYXRvcikgfHwgcGFyZW50VHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmIHBhcmVudC5jb21wdXRlZCkpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1VwZGF0ZUV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IGdldENvZGUobm9kZS5hcmd1bWVudCksXG4gICAgICAgICAgICAgICAgICAgIGV4cCA9ICdfXyRfXygnICsgYXJnICsgJywgXCInICsgbm9kZS5vcGVyYXRvclswXSArICdcIiwgMSknLFxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBhcmcgKyAnID0gJyArIGV4cDtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlLnByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJygnICsgc3RyICsgJyknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50VHlwZSA9PT0gJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyB8fCBwYXJlbnRUeXBlID09PSAnVmFyaWFibGVEZWNsYXJhdG9yJyB8fCBwYXJlbnRUeXBlID09PSAnQmluYXJ5RXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChnZXRDb2RlKHBhcmVudC5sZWZ0IHx8IHBhcmVudC5pZCkgPT09IGFyZykgc3RyID0gZXhwO1xuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnICsgJzsgJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXBsYWNlQ29kZShub2RlLCBzdHIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgvXi49JC8udGVzdChub2RlLm9wZXJhdG9yKSAmJiBub2RlLmxlZnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGdldENvZGUobm9kZS5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IGdldENvZGUobm9kZS5yaWdodCksXG4gICAgICAgICAgICAgICAgICAgICAgZXhwID0gbGVmdCArICcgPSBfXyRfXygnICsgbGVmdCArICcsIFwiJyArIG5vZGUub3BlcmF0b3JbMF0gKyAnXCIsICcgKyByaWdodCArICcpJztcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb2RlKG5vZGUsIC9eXFwoLipcXCkkLy50ZXN0KGdldENvZGUobm9kZSkpID8gJygnICsgZXhwICsgJyknIDogZXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlRXhwb3J0cyhub2RlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJzpcbiAgICAgICAgICAgIHJlcGxhY2VDb2RlKHtcbiAgICAgICAgICAgICAgcmFuZ2U6IFtub2RlLnN0YXJ0LCBub2RlLmRlY2xhcmF0aW9uLnN0YXJ0XVxuICAgICAgICAgICAgfSwgJ21vZHVsZS5leHBvcnRzID0gJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nOlxuICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBzcGVjaWZpZXJzID0gbm9kZS5zcGVjaWZpZXJzO1xuXG4gICAgICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucztcblxuICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlYykge1xuICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvZGUoZGVjLCAnbW9kdWxlLmV4cG9ydHMuJyArIGdldENvZGUoZGVjKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvZGUoe1xuICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtub2RlLnN0YXJ0LCBkZWNsYXJhdGlvbi5zdGFydCArIGRlY2xhcmF0aW9uLmtpbmQubGVuZ3RoXVxuICAgICAgICAgICAgICAgIH0sICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjaWZpZXJzKSB7XG4gICAgICAgICAgICAgIHZhciBleHBvcnRzID0gc3BlY2lmaWVycy5tYXAoZnVuY3Rpb24gKHNwZWNpZmllcikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29kZShzcGVjaWZpZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnbW9kdWxlLmV4cG9ydHMuJyArIG5hbWUgKyAnID0gJyArIG5hbWUgKyAnOyAnO1xuICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcblxuICAgICAgICAgICAgICBpZiAoZXhwb3J0cykge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VDb2RlKG5vZGUsIGV4cG9ydHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdhbGtBU1Qobm9kZSwgcGFyZW50LCBwYXBlckZlYXR1cmVzKSB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdyYW5nZScgJiYga2V5ICE9PSAnbG9jJykge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlW2tleV07XG5cbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHdhbGtBU1QodmFsdWVbaV0sIG5vZGUsIHBhcGVyRmVhdHVyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgd2Fsa0FTVCh2YWx1ZSwgbm9kZSwgcGFwZXJGZWF0dXJlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFwZXJGZWF0dXJlcy5vcGVyYXRvck92ZXJsb2FkaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaGFuZGxlT3ZlcmxvYWRpbmcobm9kZSwgcGFyZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFwZXJGZWF0dXJlcy5tb2R1bGVFeHBvcnRzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaGFuZGxlRXhwb3J0cyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5jb2RlVkxRKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSAnJyxcbiAgICAgICAgICAgIGJhc2U2NCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICAgICAgdmFsdWUgPSAoTWF0aC5hYnModmFsdWUpIDw8IDEpICsgKHZhbHVlIDwgMCA/IDEgOiAwKTtcblxuICAgICAgICB3aGlsZSAodmFsdWUgfHwgIXJlcykge1xuICAgICAgICAgIHZhciBuZXh0ID0gdmFsdWUgJiAzMiAtIDE7XG4gICAgICAgICAgdmFsdWUgPj49IDU7XG4gICAgICAgICAgaWYgKHZhbHVlKSBuZXh0IHw9IDMyO1xuICAgICAgICAgIHJlcyArPSBiYXNlNjRbbmV4dF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXJsID0gb3B0aW9ucy51cmwgfHwgJycsXG4gICAgICAgICAgc291cmNlTWFwcyA9IG9wdGlvbnMuc291cmNlTWFwcyxcbiAgICAgICAgICBwYXBlckZlYXR1cmVzID0gb3B0aW9ucy5wYXBlckZlYXR1cmVzIHx8IHt9LFxuICAgICAgICAgIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlIHx8IGNvZGUsXG4gICAgICAgICAgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMCxcbiAgICAgICAgICBhZ2VudCA9IHBhcGVyLmFnZW50LFxuICAgICAgICAgIHZlcnNpb24gPSBhZ2VudC52ZXJzaW9uTnVtYmVyLFxuICAgICAgICAgIG9mZnNldENvZGUgPSBmYWxzZSxcbiAgICAgICAgICBsaW5lQnJlYWtzID0gL1xcclxcbnxcXG58XFxyL21nLFxuICAgICAgICAgIG1hcDtcblxuICAgICAgaWYgKHNvdXJjZU1hcHMgJiYgKGFnZW50LmNocm9tZSAmJiB2ZXJzaW9uID49IDMwIHx8IGFnZW50LndlYmtpdCAmJiB2ZXJzaW9uID49IDUzNy43NiB8fCBhZ2VudC5maXJlZm94ICYmIHZlcnNpb24gPj0gMjMgfHwgYWdlbnQubm9kZSkpIHtcbiAgICAgICAgaWYgKGFnZW50Lm5vZGUpIHtcbiAgICAgICAgICBvZmZzZXQgLT0gMjtcbiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cgJiYgdXJsICYmICF3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKHVybCkpIHtcbiAgICAgICAgICB2YXIgaHRtbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0uaW5uZXJIVE1MO1xuICAgICAgICAgIG9mZnNldCA9IGh0bWwuc3Vic3RyKDAsIGh0bWwuaW5kZXhPZihjb2RlKSArIDEpLm1hdGNoKGxpbmVCcmVha3MpLmxlbmd0aCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXRDb2RlID0gb2Zmc2V0ID4gMCAmJiAhKGFnZW50LmNocm9tZSAmJiB2ZXJzaW9uID49IDM2IHx8IGFnZW50LnNhZmFyaSAmJiB2ZXJzaW9uID49IDYwMCB8fCBhZ2VudC5maXJlZm94ICYmIHZlcnNpb24gPj0gNDAgfHwgYWdlbnQubm9kZSk7XG4gICAgICAgIHZhciBtYXBwaW5ncyA9IFsnQUEnICsgZW5jb2RlVkxRKG9mZnNldENvZGUgPyAwIDogb2Zmc2V0KSArICdBJ107XG4gICAgICAgIG1hcHBpbmdzLmxlbmd0aCA9IChjb2RlLm1hdGNoKGxpbmVCcmVha3MpIHx8IFtdKS5sZW5ndGggKyAxICsgKG9mZnNldENvZGUgPyBvZmZzZXQgOiAwKTtcbiAgICAgICAgbWFwID0ge1xuICAgICAgICAgIHZlcnNpb246IDMsXG4gICAgICAgICAgZmlsZTogdXJsLFxuICAgICAgICAgIG5hbWVzOiBbXSxcbiAgICAgICAgICBtYXBwaW5nczogbWFwcGluZ3Muam9pbignO0FBQ0EnKSxcbiAgICAgICAgICBzb3VyY2VSb290OiAnJyxcbiAgICAgICAgICBzb3VyY2VzOiBbdXJsXSxcbiAgICAgICAgICBzb3VyY2VzQ29udGVudDogW3NvdXJjZV1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcGVyRmVhdHVyZXMub3BlcmF0b3JPdmVybG9hZGluZyAhPT0gZmFsc2UgfHwgcGFwZXJGZWF0dXJlcy5tb2R1bGVFeHBvcnRzICE9PSBmYWxzZSkge1xuICAgICAgICB3YWxrQVNUKHBhcnNlKGNvZGUsIHtcbiAgICAgICAgICByYW5nZXM6IHRydWUsXG4gICAgICAgICAgcHJlc2VydmVQYXJlbnM6IHRydWUsXG4gICAgICAgICAgc291cmNlVHlwZTogJ21vZHVsZSdcbiAgICAgICAgfSksIG51bGwsIHBhcGVyRmVhdHVyZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFwKSB7XG4gICAgICAgIGlmIChvZmZzZXRDb2RlKSB7XG4gICAgICAgICAgY29kZSA9IG5ldyBBcnJheShvZmZzZXQgKyAxKS5qb2luKCdcXG4nKSArIGNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL14oaW5saW5lfGJvdGgpJC8udGVzdChzb3VyY2VNYXBzKSkge1xuICAgICAgICAgIGNvZGUgKz0gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgc2VsZi5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShtYXApKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSArPSBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyAodXJsIHx8ICdwYXBlcnNjcmlwdCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgIG1hcDogbWFwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWN1dGUoY29kZSwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgICAgIHBhcGVyID0gc2NvcGU7XG4gICAgICB2YXIgdmlldyA9IHNjb3BlLmdldFZpZXcoKSxcbiAgICAgICAgICB0b29sID0gL1xcYnRvb2xcXC5cXHcrfFxccytvbig/OktleXxNb3VzZSkoPzpVcHxEb3dufE1vdmV8RHJhZylcXGIvLnRlc3QoY29kZSkgJiYgIS9cXGJuZXdcXHMrVG9vbFxcYi8udGVzdChjb2RlKSA/IG5ldyBUb29sKCkgOiBudWxsLFxuICAgICAgICAgIHRvb2xIYW5kbGVycyA9IHRvb2wgPyB0b29sLl9ldmVudHMgOiBbXSxcbiAgICAgICAgICBoYW5kbGVycyA9IFsnb25GcmFtZScsICdvblJlc2l6ZSddLmNvbmNhdCh0b29sSGFuZGxlcnMpLFxuICAgICAgICAgIHBhcmFtcyA9IFtdLFxuICAgICAgICAgIGFyZ3MgPSBbXSxcbiAgICAgICAgICBmdW5jLFxuICAgICAgICAgIGNvbXBpbGVkID0gdHlwZW9mIGNvZGUgPT09ICdvYmplY3QnID8gY29kZSA6IGNvbXBpbGUoY29kZSwgb3B0aW9ucyk7XG4gICAgICBjb2RlID0gY29tcGlsZWQuY29kZTtcblxuICAgICAgZnVuY3Rpb24gZXhwb3NlKHNjb3BlLCBoaWRkZW4pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNjb3BlKSB7XG4gICAgICAgICAgaWYgKChoaWRkZW4gfHwgIS9eXy8udGVzdChrZXkpKSAmJiBuZXcgUmVnRXhwKCcoW1xcXFxiXFxcXHNcXFxcV118XiknICsga2V5LnJlcGxhY2UoL1xcJC9nLCAnXFxcXCQnKSArICdcXFxcYicpLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleSk7XG4gICAgICAgICAgICBhcmdzLnB1c2goc2NvcGVba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cG9zZSh7XG4gICAgICAgIF9fJF9fOiBfXyRfXyxcbiAgICAgICAgJF9fOiAkX18sXG4gICAgICAgIHBhcGVyOiBzY29wZSxcbiAgICAgICAgdG9vbDogdG9vbFxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBleHBvc2Uoc2NvcGUpO1xuICAgICAgY29kZSA9ICd2YXIgbW9kdWxlID0geyBleHBvcnRzOiB7fSB9OyAnICsgY29kZTtcbiAgICAgIHZhciBleHBvcnRzID0gQmFzZS5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChuZXcgUmVnRXhwKCdcXFxccysnICsga2V5ICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKGtleSk7XG4gICAgICAgICAgdGhpcy5wdXNoKCdtb2R1bGUuZXhwb3J0cy4nICsga2V5ICsgJyA9ICcgKyBrZXkgKyAnOycpO1xuICAgICAgICB9XG4gICAgICB9LCBbXSkuam9pbignXFxuJyk7XG5cbiAgICAgIGlmIChleHBvcnRzKSB7XG4gICAgICAgIGNvZGUgKz0gJ1xcbicgKyBleHBvcnRzO1xuICAgICAgfVxuXG4gICAgICBjb2RlICs9ICdcXG5yZXR1cm4gbW9kdWxlLmV4cG9ydHM7JztcbiAgICAgIHZhciBhZ2VudCA9IHBhcGVyLmFnZW50O1xuXG4gICAgICBpZiAoZG9jdW1lbnQgJiYgKGFnZW50LmNocm9tZSB8fCBhZ2VudC5maXJlZm94ICYmIGFnZW50LnZlcnNpb25OdW1iZXIgPCA0MCkpIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgICAgICAgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgaWYgKGFnZW50LmZpcmVmb3gpIGNvZGUgPSAnXFxuJyArIGNvZGU7XG4gICAgICAgIHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnZG9jdW1lbnQuX19wYXBlcnNjcmlwdF9fID0gZnVuY3Rpb24oJyArIHBhcmFtcyArICcpIHsnICsgY29kZSArICdcXG59JykpO1xuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIGZ1bmMgPSBkb2N1bWVudC5fX3BhcGVyc2NyaXB0X187XG4gICAgICAgIGRlbGV0ZSBkb2N1bWVudC5fX3BhcGVyc2NyaXB0X187XG4gICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmMgPSBGdW5jdGlvbihwYXJhbXMsIGNvZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXhwb3J0cyA9IGZ1bmMgJiYgZnVuYy5hcHBseShzY29wZSwgYXJncyk7XG4gICAgICB2YXIgb2JqID0gZXhwb3J0cyB8fCB7fTtcbiAgICAgIEJhc2UuZWFjaCh0b29sSGFuZGxlcnMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSkgdG9vbFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgaWYgKG9iai5vblJlc2l6ZSkgdmlldy5zZXRPblJlc2l6ZShvYmoub25SZXNpemUpO1xuICAgICAgICB2aWV3LmVtaXQoJ3Jlc2l6ZScsIHtcbiAgICAgICAgICBzaXplOiB2aWV3LnNpemUsXG4gICAgICAgICAgZGVsdGE6IG5ldyBQb2ludCgpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob2JqLm9uRnJhbWUpIHZpZXcuc2V0T25GcmFtZShvYmoub25GcmFtZSk7XG4gICAgICAgIHZpZXcucmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwb3J0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkU2NyaXB0KHNjcmlwdCkge1xuICAgICAgaWYgKC9edGV4dFxcLyg/OngtfClwYXBlcnNjcmlwdCQvLnRlc3Qoc2NyaXB0LnR5cGUpICYmIFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKHNjcmlwdCwgJ2lnbm9yZScpICE9PSAndHJ1ZScpIHtcbiAgICAgICAgdmFyIGNhbnZhc0lkID0gUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnY2FudmFzJyksXG4gICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNJZCksXG4gICAgICAgICAgICBzcmMgPSBzY3JpcHQuc3JjIHx8IHNjcmlwdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyksXG4gICAgICAgICAgICBhc3luYyA9IFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKHNjcmlwdCwgJ2FzeW5jJyksXG4gICAgICAgICAgICBzY29wZUF0dHJpYnV0ZSA9ICdkYXRhLXBhcGVyLXNjb3BlJztcbiAgICAgICAgaWYgKCFjYW52YXMpIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgY2FudmFzIHdpdGggaWQgXCInICsgY2FudmFzSWQgKyAnXCInKTtcbiAgICAgICAgdmFyIHNjb3BlID0gUGFwZXJTY29wZS5nZXQoY2FudmFzLmdldEF0dHJpYnV0ZShzY29wZUF0dHJpYnV0ZSkpIHx8IG5ldyBQYXBlclNjb3BlKCkuc2V0dXAoY2FudmFzKTtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShzY29wZUF0dHJpYnV0ZSwgc2NvcGUuX2lkKTtcblxuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHVybDogc3JjLFxuICAgICAgICAgICAgYXN5bmM6IGFzeW5jLFxuICAgICAgICAgICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAgIG9uTG9hZDogZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICAgICAgZXhlY3V0ZShjb2RlLCBzY29wZSwgc3JjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGVjdXRlKHNjcmlwdC5pbm5lckhUTUwsIHNjb3BlLCBzY3JpcHQuYmFzZVVSSSk7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWlnbm9yZScsICd0cnVlJyk7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkQWxsKCkge1xuICAgICAgQmFzZS5lYWNoKGRvY3VtZW50ICYmIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSwgbG9hZFNjcmlwdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZChzY3JpcHQpIHtcbiAgICAgIHJldHVybiBzY3JpcHQgPyBsb2FkU2NyaXB0KHNjcmlwdCkgOiBsb2FkQWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdykge1xuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgc2V0VGltZW91dChsb2FkQWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERvbUV2ZW50LmFkZCh3aW5kb3csIHtcbiAgICAgICAgICBsb2FkOiBsb2FkQWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgZXhlY3V0ZTogZXhlY3V0ZSxcbiAgICAgIGxvYWQ6IGxvYWQsXG4gICAgICBwYXJzZTogcGFyc2UsXG4gICAgICBjYWxjdWxhdGVCaW5hcnk6IF9fJF9fLFxuICAgICAgY2FsY3VsYXRlVW5hcnk6ICRfX1xuICAgIH07XG4gIH0uY2FsbCh0aGlzKTtcblxuICB2YXIgcGFwZXIgPSBuZXcgKFBhcGVyU2NvcGUuaW5qZWN0KEJhc2UuZXhwb3J0cywge1xuICAgIEJhc2U6IEJhc2UsXG4gICAgTnVtZXJpY2FsOiBOdW1lcmljYWwsXG4gICAgS2V5OiBLZXksXG4gICAgRG9tRXZlbnQ6IERvbUV2ZW50LFxuICAgIERvbUVsZW1lbnQ6IERvbUVsZW1lbnQsXG4gICAgZG9jdW1lbnQ6IGRvY3VtZW50LFxuICAgIHdpbmRvdzogd2luZG93LFxuICAgIFN5bWJvbDogU3ltYm9sRGVmaW5pdGlvbixcbiAgICBQbGFjZWRTeW1ib2w6IFN5bWJvbEl0ZW1cbiAgfSkpKCk7XG5cbiAgaWYgKHBhcGVyLmFnZW50Lm5vZGUpIHtcbiAgICByZXF1aXJlKCcuL25vZGUvZXh0ZW5kLmpzJykocGFwZXIpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgncGFwZXInLCBwYXBlcik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXBlcjtcbiAgfVxuXG4gIHJldHVybiBwYXBlcjtcbn0uY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgPyBzZWxmIDogbnVsbCk7IiwiaW1wb3J0IFwiLi9zdHlsZXMvaW5kZXguc2Nzc1wiO1xyXG5pbXBvcnQgcGFwZXIsIHsgUmVjdGFuZ2xlLCBQYXRoLCBQb2ludCwgVG9vbCwgUG9pbnRUZXh0IH0gZnJvbSAncGFwZXInO1xyXG5pbXBvcnQgU2lkZWJhciBmcm9tICcuL3NjcmlwdHMvc2lkZWJhci9zaWRlYmFyJztcclxuaW1wb3J0IHNpZGViYXJEYXRhIGZyb20gJy4vc2NyaXB0cy91dGlsL3NpZGViYXJfZGF0YSdcclxuaW1wb3J0IE15Q2FudmFzIGZyb20gXCIuL3NjcmlwdHMvY2FudmFzL2NhbnZhc1wiO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4vc2NyaXB0cy9tb2RhbC9tb2RhbFwiO1xyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgbWFpbiA9PntcclxuICAgIC8vIGNhbnZhc1xyXG4gICAgY29uc3QgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteUNhbnZhcycpO1xyXG4gICAgY29uc3QgbXlDYW52YXMgPSBuZXcgTXlDYW52YXMoY2FudmFzRWxlbWVudCk7XHJcblxyXG4gICBcclxuXHJcbiAgICAvL3NpZGViYXJcclxuICAgIGNvbnN0IHNpZGViYXJFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlY3Rpb24tY29udGVudC1zaWRlYmFyJyk7XHJcbiAgICBjb25zdCBzaWRlYmFyID0gbmV3IFNpZGViYXIoXHJcbiAgICAgICAgc2lkZWJhckRhdGFbMF0sIFxyXG4gICAgICAgIHNpZGViYXJFbGVtZW50LFxyXG4gICAgICAgIG15Q2FudmFzLmRyYXdTaGFwZXMpO1xyXG59KTtcclxuXHJcblxyXG4iLCJpbXBvcnQgeyBTSEFQRVMgfSBmcm9tIFwiLi4vdXRpbC9jb25zdGFudHNcIjtcclxuaW1wb3J0IHBhcGVyLCB7IFByb2plY3QsIFBhdGgsIEdyb3VwLCBQb2ludFRleHQsIHRvb2wsIFRvb2wsIFJlY3RhbmdsZSwgUG9pbnQsIFNpemUgfSBmcm9tICdwYXBlcic7XHJcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vbW9kYWwvbW9kYWxcIjtcclxuXHJcbmltcG9ydCB7Z2V0QW5nbGVEZWd9IGZyb20gJy4uL3V0aWwvdXRpbCc7XHJcblxyXG5jb25zdCBib3VuZHNJZGVudGlmaWVyT2JqID0ge1xyXG4gIDE6ICd0b3BMZWZ0JywgMjogJ3RvcFJpZ2h0JywgMzogJ2JvdHRvbVJpZ2h0JywgMDogJ2JvdHRvbUxlZnQnXHJcbn1cclxuY29uc3QgTElORSA9ICdsaW5lJzsgXHJcblxyXG5jbGFzcyBNeUNhbnZhcyB7XHJcbiAgY29uc3RydWN0b3IoY2FudmFzRWxlbWVudCkge1xyXG4gICAgdGhpcy5jYW52YXNFbGVtZW50ID0gIGNhbnZhc0VsZW1lbnQ7XHJcbiAgICB0aGlzLmNlbnRlclBvc2l0aW9uID0gdGhpcy5nZXRDZW50ZXJQb3NpdGlvbigpO1xyXG4gICAgdGhpcy5zdHJva2VDb2xvciA9ICdibGFjayc7XHJcbiAgICB0aGlzLmZpbGxDb2xvciA9IFwid2hpdGVcIjtcclxuICAgIHRoaXMuZGVmYXVsdFNpemUgPSBbMTAwLDEwMF07XHJcbiAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtID0gbnVsbDtcclxuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAyO1xyXG5cclxuICAgIC8vIHNldHMgdXAgcGFwZXIganMgb24gY2FudmFzXHJcbiAgICBwYXBlci5zZXR1cChjYW52YXNFbGVtZW50KTtcclxuXHJcbiAgICAvL2NyZWF0ZXMgbmV3IHByb2plY3QgaW4gcGFwZXJcclxuICAgIHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGNhbnZhc0VsZW1lbnQpXHJcblxyXG4gICAgLy9jcmVhdGluZyB0b29sXHJcbiAgICB0aGlzLnRvb2wgPSBuZXcgVG9vbCgpO1xyXG4gICAgLy8gaGFzIG1vdmVkIGF0IGxlYXN0IDEwIHBvaW50czpcclxuICAgIHRvb2wubWluRGlzdGFuY2UgPSAyO1xyXG5cclxuICAgIC8vYmluZHMgbWV0aG9kc1xyXG4gICAgLy9zaGFwZXMgbWV0aG9kIGJpbmRpbmdcclxuICAgIHRoaXMuZHJhd1NoYXBlcyA9IHRoaXMuZHJhd1NoYXBlcy5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5kcmF3Q2xhc3NTaGFwZSA9IHRoaXMuZHJhd0NsYXNzU2hhcGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZHJhd0xpbmVTaGFwZSA9IHRoaXMuZHJhd0xpbmVTaGFwZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5kcmF3T2JqZWN0U2hhcGUgPSB0aGlzLmRyYXdPYmplY3RTaGFwZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5kcmF3VGV4dFNoYXBlID0gdGhpcy5kcmF3VGV4dFNoYXBlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmRyYXdVc2VyQ2FzZVNoYXBlID0gdGhpcy5kcmF3VXNlQ2FzZVNoYXBlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmRyYXdDb21wb25lbnRTaGFwZSA9IHRoaXMuZHJhd0NvbXBvbmVudFNoYXBlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmRyYXdNb2R1bGVTaGFwZSA9IHRoaXMuZHJhd01vZHVsZVNoYXBlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmRyYXdBY3Rpdml0eVNoYXBlID0gdGhpcy5kcmF3QWN0aXZpdHlTaGFwZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5kcmF3RGVjaXNpb25TaGFwZSA9IHRoaXMuZHJhd0RlY2lzaW9uU2hhcGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZHJhd0FjdG9yU2hhcGUgPSB0aGlzLmRyYXdBY3RvclNoYXBlLmJpbmQodGhpcyk7XHJcblxyXG4gICAgLy9nZW5lcmFsIG1ldGhvZCBiaW5kaW5nXHJcbiAgICB0aGlzLmdldENlbnRlclBvc2l0aW9uID0gdGhpcy5nZXRDZW50ZXJQb3NpdGlvbi5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vdXNlciBpbnRlcmFjdGlvbiBtZXRob2QgYmluZGluZ1xyXG4gICAgdGhpcy5vblRvb2xEb3VibGVDbGljayA9IHRoaXMub25Ub29sRG91YmxlQ2xpY2suYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25Ub29sTW91c2VEb3duID0gdGhpcy5vblRvb2xNb3VzZURvd24uYmluZCh0aGlzKTtcclxuICAgIHRoaXMuc2V0T25lSXRlbVNlbGVjdGVkID0gdGhpcy5zZXRPbmVJdGVtU2VsZWN0ZWQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25Ub29sRHJhZyA9IHRoaXMub25Ub29sRHJhZy5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vblRvb2xLZXlEb3duID0gdGhpcy5vblRvb2xLZXlEb3duLmJpbmQodGhpcyk7XHJcblxyXG4gICAgLy90b29sIGxldmVsIGNsaWNrbGlzdGVuZXJcclxuICAgIHRoaXMudG9vbC5vbk1vdXNlRG93biA9IHRoaXMub25Ub29sTW91c2VEb3duO1xyXG4gICAgdGhpcy50b29sLm9uTW91c2VVcCA9IHRoaXMub25Ub29sTW91c2VVcDtcclxuICAgIHRoaXMudG9vbC5vbk1vdXNlRHJhZyA9IHRoaXMub25Ub29sRHJhZztcclxuICAgIHRoaXMudG9vbC5vbktleURvd24gPSB0aGlzLm9uVG9vbEtleURvd247XHJcblxyXG4gICAgIC8vYWRkIGRvdWJsZSBjbGljayBsaXN0ZW5lciBvbiBjYW52YXMgYmVjYXVzZSB0b29sIGhhdmUgbm8gZG91YmxlIGNsaWNrIGxpc3RlbmVyXHJcbiAgICB0aGlzLmNhbnZhc0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIHRoaXMub25Ub29sRG91YmxlQ2xpY2spO1xyXG5cclxuICAgIC8vc2V0IHJpZ2h0IG1lbnUgbGl0ZW5lcnNcclxuICAgIHRoaXMuc2V0UmlnaHRNZW51TGlzdGVuZXJzID0gdGhpcy5zZXRSaWdodE1lbnVMaXN0ZW5lcnMuYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNldFJpZ2h0TWVudUxpc3RlbmVycygpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vc2V0IHJpZ2h0IG1lbnUgY2xpY2sgbGlzdGVuZXJcclxuICBzZXRSaWdodE1lbnVMaXN0ZW5lcnMoKXtcclxuICAgIGNvbnN0IG9wZW5GaWxlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvcGVuLWZpbGUnKTtcclxuICAgIGNvbnN0IGRvd25sb2FkRmlsZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93bmxvYWQtZmlsZScpO1xyXG5cclxuICAgIG9wZW5GaWxlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsdGhpcy5vcGVuRmlsZSk7XHJcblxyXG4gICAgZG93bmxvYWRGaWxlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZG93bmxvYWRBc1NWRy5iaW5kKHRoaXMpKTtcclxuICB9XHJcblxyXG4gIC8vc2V0IGlucHV0IHRvIG9wZW4gZmlsZSBwaWNrZXIgZGlhbG9nXHJcbiAgb3BlbkZpbGUoKXtcclxuICAgIGxldCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICBpbnB1dC50eXBlID0gJ2ZpbGUnO1xyXG4gICAgaW5wdXQubXVsdGlwbGUgPSBmYWxzZTtcclxuICAgIGlucHV0LmFjY2VwdCA9ICdpbWFnZS9zdmcreG1sJztcclxuICAgIGlucHV0Lm9uY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2plY3QuaW1wb3J0U1ZHKFVSTC5jcmVhdGVPYmplY3RVUkwoaW5wdXQuZmlsZXNbMF0pLChncm91cCwgc3ZnKT0+e1xyXG4gICAgICAgICAgICAgIHRoaXMucHJvamVjdC5jbGVhcigpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgIGRlYnVnZ2VyXHJcbiAgICAgICAgICAgICAgd2hpbGUoZ3JvdXAuY2hpbGRyZW5bMV0uY2hpbGRyZW4ubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnByb2plY3QuYWN0aXZlTGF5ZXIuYWRkQ2hpbGQoZ3JvdXAuY2hpbGRyZW5bMV0uY2hpbGRyZW5bMF0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH07XHJcbiAgICBpbnB1dC5jbGljaygpO1xyXG4gICAgXHJcbiAgfVxyXG5cclxuICAvLyBzZXQgZG93bmxvYWQgcHJvamVjdCBhcyBzdmdcclxuICBkb3dubG9hZEFzU1ZHKCkge1xyXG4gICBcclxuICAgIGlmKHRoaXMucHJvamVjdC5hY3RpdmVMYXllci5jaGlsZHJlbi5sZW5ndGggPT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGZpbGVOYW1lID0gYHVtbGNoYXJ0XyR7RGF0ZS5ub3coKX0uc3ZnYDtcclxuIFxyXG4gICAgdmFyIHVybCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsXCIgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5wcm9qZWN0LmV4cG9ydFNWRyh7YXNTdHJpbmc6dHJ1ZX0pKTtcclxuICAgIFxyXG4gICAgdmFyIGRvd25sb2FkTGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgIGRvd25sb2FkTGlua0VsZW1lbnQuZG93bmxvYWQgPSBmaWxlTmFtZTtcclxuICAgIGRvd25sb2FkTGlua0VsZW1lbnQuaHJlZiA9IHVybDtcclxuICAgIGRvd25sb2FkTGlua0VsZW1lbnQuY2xpY2soKTtcclxuIH1cclxuXHJcbiAgLy9zaGFwZSBkcmF3IGRpc3RyaWJ1dG9yXHJcbiAgZHJhd1NoYXBlcyhzaGFwZU5hbWUpe1xyXG5cclxuICAgIHN3aXRjaCAoc2hhcGVOYW1lKSB7XHJcbiAgICAgIGNhc2UgU0hBUEVTLkNMQVNTOlxyXG4gICAgICAgIHRoaXMuZHJhd0NsYXNzU2hhcGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuQUdHUkVHQVRJT046XHJcbiAgICAgIGNhc2UgU0hBUEVTLkNPTVBPU0lUSU9OOlxyXG4gICAgICBjYXNlIFNIQVBFUy5ESVZJREVSOiAgXHJcbiAgICAgIGNhc2UgU0hBUEVTLkFTU09DSUFUSU9OOiAgXHJcbiAgICAgICAgbGV0IHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LTUwLCB0aGlzLmNlbnRlclBvc2l0aW9uLnkpO1xyXG4gICAgICAgIGxldCBlbmRQb2ludCA9IG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngrNTAsIHRoaXMuY2VudGVyUG9zaXRpb24ueSk7XHJcbiAgICAgICAgdGhpcy5kcmF3TGluZVNoYXBlKHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBzaGFwZU5hbWUpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFNIQVBFUy5TUVVBUkU6XHJcbiAgICAgIGNhc2UgU0hBUEVTLk9CSkVDVDpcclxuICAgICAgY2FzZSBTSEFQRVMuSU5URVJGQUNFOlxyXG4gICAgICAgICAgdGhpcy5kcmF3T2JqZWN0U2hhcGUoc2hhcGVOYW1lKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuVElUTEU6XHJcbiAgICAgICAgc3RhcnRQb2ludCA9IG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngtMjUsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0yNSk7XHJcbiAgICAgICAgdGhpcy5kcmF3VGV4dFNoYXBlKHN0YXJ0UG9pbnQsIFwiQWRkIFRleHRcIik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU0hBUEVTLkNJUkNMRTpcclxuICAgICAgY2FzZSBTSEFQRVMuVVNFQ0FTRTpcclxuICAgICAgICB0aGlzLmRyYXdVc2VDYXNlU2hhcGUoc2hhcGVOYW1lKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuQ09NUE9ORU5UOlxyXG4gICAgICAgIHRoaXMuZHJhd0NvbXBvbmVudFNoYXBlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU0hBUEVTLk1PRFVMRTpcclxuICAgICAgICB0aGlzLmRyYXdNb2R1bGVTaGFwZSgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFNIQVBFUy5BQ1RJVklUWTpcclxuICAgICAgICB0aGlzLmRyYXdBY3Rpdml0eVNoYXBlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU0hBUEVTLkRFQ0lTSU9OOlxyXG4gICAgICAgIHRoaXMuZHJhd0RlY2lzaW9uU2hhcGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTSEFQRVMuQUNUT1I6XHJcbiAgICAgICAgdGhpcy5kcmF3QWN0b3JTaGFwZSgpO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlcyB0aHJlZSByZWN0YW5nbGUgdG8gbWFrZSBhIGNsYXNzIFVNTFxyXG4gIGRyYXdDbGFzc1NoYXBlKCl7XHJcbiAgICAvL2NyZWF0ZXMgZ3JvdXAgYW5kIGFkZCBzaGFwZXNcclxuXHJcbiAgICAvL2NyZWF0ZSBjbGFzcyByZWN0YW5nbGVcclxuICAgIGNvbnN0IGdyb3VwQ2xhc3MgPSBuZXcgR3JvdXAoKTtcclxuICAgIGNvbnN0IGZpcnN0UmVjdFggPSB0aGlzLmNlbnRlclBvc2l0aW9uLngtNTA7XHJcbiAgICBjb25zdCBmaXJzdFJlY3RZID0gdGhpcy5jZW50ZXJQb3NpdGlvbi55LTUwO1xyXG4gICAgY29uc3QgZmlyc3RSZWN0SGVpZ2h0ID0gMjA7XHJcbiAgICBjb25zdCBmcmlzdFJlY3RXaWR0aCA9IHRoaXMuZGVmYXVsdFNpemVbMV07XHJcbiAgICBjb25zdCBjbGFzc05hbWVSZWN0YW5nbGUgPSBuZXcgUGF0aC5SZWN0YW5nbGUoZmlyc3RSZWN0WCwgZmlyc3RSZWN0WSwgZnJpc3RSZWN0V2lkdGgsIGZpcnN0UmVjdEhlaWdodCk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoY2xhc3NOYW1lUmVjdGFuZ2xlKTtcclxuICAgIGdyb3VwQ2xhc3MuYWRkQ2hpbGQoY2xhc3NOYW1lUmVjdGFuZ2xlKTtcclxuXHJcbiAgICAvL2NyZWF0ZSB2YXJhaWJsZSByZWN0YW5nbGVcclxuICAgIGNvbnN0IHNlY1JlY3RYID0gZmlyc3RSZWN0WDtcclxuICAgIGNvbnN0IHNlY1JlY3RZID0gZmlyc3RSZWN0WSArIGZpcnN0UmVjdEhlaWdodDtcclxuICAgIGNvbnN0IHNlY1JlY3RIZWlnaHQgPSA1MDtcclxuICAgIGNvbnN0IHNlY1JlY3RXaWR0aCA9IHRoaXMuZGVmYXVsdFNpemVbMV07XHJcbiAgICBjb25zdCB2YXJpYWJsZU5hbWVSZWN0YW5nbGUgPSBuZXcgUGF0aC5SZWN0YW5nbGUoc2VjUmVjdFgsIHNlY1JlY3RZLCBzZWNSZWN0V2lkdGgsIHNlY1JlY3RIZWlnaHQpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHZhcmlhYmxlTmFtZVJlY3RhbmdsZSk7XHJcbiAgICBncm91cENsYXNzLmFkZENoaWxkKHZhcmlhYmxlTmFtZVJlY3RhbmdsZSk7XHJcblxyXG5cclxuICAgIC8vY3JlYXRlIG1ldGhvZCByZWN0YW5nbGVcclxuICAgIGNvbnN0IHRoaXJkUmVjdFggPSBmaXJzdFJlY3RYO1xyXG4gICAgY29uc3QgdGhpcmRSZWN0WSA9IHNlY1JlY3RZICsgc2VjUmVjdEhlaWdodDtcclxuICAgIGNvbnN0IHRoaXJkUmVjdEhlaWdodCA9IDMwO1xyXG4gICAgY29uc3QgdGhpcmRSZWN0V2lkdGggPSB0aGlzLmRlZmF1bHRTaXplWzFdO1xyXG4gICAgY29uc3QgbWV0aG9kTmFtZVJlY3RhbmdsZSA9IG5ldyBQYXRoLlJlY3RhbmdsZSh0aGlyZFJlY3RYLCB0aGlyZFJlY3RZLCB0aGlyZFJlY3RXaWR0aCwgdGhpcmRSZWN0SGVpZ2h0KTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChtZXRob2ROYW1lUmVjdGFuZ2xlKTtcclxuICAgIGdyb3VwQ2xhc3MuYWRkQ2hpbGQobWV0aG9kTmFtZVJlY3RhbmdsZSk7XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gYWRkcyB0ZXh0IHRvIHRoZSBjbGlja2VkIGFyZWFcclxuICBkcmF3VGV4dFNoYXBlKHBvc2l0aW9uLCB0ZXh0KXtcclxuICAgIC8vY3JlYXRlIHRleHQgc2hhcGVcclxuICAgIGxldCB0ZXh0U2hhcGUgPSBuZXcgUG9pbnRUZXh0KHBvc2l0aW9uKTtcclxuICAgIHRleHRTaGFwZS5maWxsQ29sb3IgPSB0aGlzLnN0cm9rZUNvbG9yO1xyXG4gICAgdGV4dFNoYXBlLmNvbnRlbnQgPSB0ZXh0O1xyXG5cclxuICAgIC8vYWRkcyBkb3VibGVjbGljayBsaXN0bmVyIHRvIHRleHRcclxuICAgIHRleHRTaGFwZS5vbkRvdWJsZUNsaWNrID0gKGUpPT57XHJcbiAgICAgIC8vc2hvdyBtb2RhbCB0byB1cGRhdGUgdGV4dFxyXG4gICAgICBpZih0ZXh0U2hhcGUuc2VsZWN0ZWQpe1xyXG4gICAgICAgIG5ldyBNb2RhbCgodXBkYXRlZFRleHQpPT57XHJcbiAgICAgICAgICB0ZXh0U2hhcGUuY29udGVudCA9IHVwZGF0ZWRUZXh0O1xyXG4gICAgICAgIH0pLnNob3coKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0U2hhcGVcclxuICB9XHJcblxyXG4gIC8vYWRkIERpdmlkZXIvQXNzb2NpYXRpb24vQ29tcG9zaXRpb2luL0FnZ3JlZ2F0aW9uIHdpdGggaGVhZCBzaGFwZSBhbmQgdGhyZWUgY2lyY2xlcyAodG8gYWlkIG1vdmVtZW50IGFuZCBkcmFnKVxyXG4gIGRyYXdMaW5lU2hhcGUoc3RhcnRQb2ludCwgZW5kUG9pbnQsIGxpbmVUeXBlKXtcclxuICAgIFxyXG5cclxuICAgIGxldCBtYWluR3JvdXAgPSBuZXcgR3JvdXAoKTtcclxuICAgIGxldCBncm91cCA9ICBuZXcgR3JvdXAoKTtcclxuICAgIFxyXG4gICAgLy9kcmF3IGxpbmVcclxuICAgIGNvbnN0IGxpbmUgPSBuZXcgUGF0aC5MaW5lKHN0YXJ0UG9pbnQsIGVuZFBvaW50KTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChsaW5lKTtcclxuXHJcbiAgICAvLyBkcmF3IGhlYWQgY2lyY2xlXHJcbiAgICBjb25zdCBoZWFkQ2lyY2xlID0gbmV3IFBhdGguQ2lyY2xlKGVuZFBvaW50LCA1KTtcclxuICAgIGhlYWRDaXJjbGUuZmlsbENvbG9yID0gJ2JsYWNrJztcclxuICAgIGhlYWRDaXJjbGUuc3Ryb2tlV2lkdGggPSAxO1xyXG5cclxuICAgIC8vZHJhdyBtaWRkbGUgY2lyY2xlXHJcbiAgICBjb25zdCBtaWRQb2ludCA9IG5ldyBQb2ludCgoc3RhcnRQb2ludC54K2VuZFBvaW50LngpLzIsIChzdGFydFBvaW50LnkrZW5kUG9pbnQueSkvMilcclxuICAgIGNvbnN0IG1pZENpcmNsZSA9IG5ldyBQYXRoLkNpcmNsZShtaWRQb2ludCwgNCk7XHJcbiAgICBtaWRDaXJjbGUuZmlsbENvbG9yID0gJ2JsYWNrJztcclxuICAgIG1pZENpcmNsZS5zdHJva2VXaWR0aCA9IDE7XHJcblxyXG5cclxuICAgIC8vZHJhdyB0YWlsIGNpcmNsZVxyXG4gICAgY29uc3QgdGFpbENpcmNsZSA9IG5ldyBQYXRoLkNpcmNsZShzdGFydFBvaW50LCA1KTtcclxuICAgIHRhaWxDaXJjbGUuZmlsbENvbG9yID0gJ2JsYWNrJztcclxuICAgIHRhaWxDaXJjbGUuc3Ryb2tlV2lkdGggPSAxO1xyXG5cclxuXHJcbiAgICAvL2FkZCBjaXJjbGVzIGFuZCBsaW5lIHRvIGdyb3VwXHJcbiAgICBncm91cC5hZGRDaGlsZChsaW5lKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKHRhaWxDaXJjbGUpO1xyXG4gICAgZ3JvdXAuYWRkQ2hpbGQobWlkQ2lyY2xlKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKGhlYWRDaXJjbGUpO1xyXG5cclxuICAgIC8vZHJhdyBhcnJvdyBzaGFwZVxyXG4gICAgY29uc3QgaGVhZFNoYXBlID0gbmV3IFBhdGgoKTtcclxuICAgIGhlYWRTaGFwZS5zdHJva2VDb2xvcj0gdGhpcy5zdHJva2VDb2xvcjtcclxuICAgIGhlYWRTaGFwZS5zdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XHJcblxyXG4gICAgbGV0IGFycm93Q2VudGVyID0gZW5kUG9pbnQ7XHJcblxyXG4gICAgLy9iYXNlZCBvbiBsaW5lIHR5cGUgZHJhdyBzaGFwZVxyXG4gICAgaWYobGluZVR5cGUgIT09IFNIQVBFUy5ESVZJREVSKXtcclxuICAgICAgY29uc3QgbGVmdEVkZ2UgPSBuZXcgUG9pbnQoYXJyb3dDZW50ZXIueC0xMCwgYXJyb3dDZW50ZXIueS0xMCk7XHJcbiAgICAgIGNvbnN0IHJpZ2h0RWRnZSA9IG5ldyBQb2ludChhcnJvd0NlbnRlci54LTEwLCBhcnJvd0NlbnRlci55KzEwKTtcclxuICAgICAgaGVhZFNoYXBlLmFkZChsZWZ0RWRnZSk7XHJcbiAgICAgIGhlYWRTaGFwZS5hZGQoYXJyb3dDZW50ZXIpO1xyXG4gICAgICBoZWFkU2hhcGUuYWRkKHJpZ2h0RWRnZSk7XHJcblxyXG4gICAgICBpZihsaW5lVHlwZSA9PT0gU0hBUEVTLkFHR1JFR0FUSU9OIHx8IGxpbmVUeXBlID09PSAgU0hBUEVTLkNPTVBPU0lUSU9OKXtcclxuICAgICAgICBjb25zdCBib3R0b21SaWdodEVkZ2UgPSBuZXcgUG9pbnQoYXJyb3dDZW50ZXIueC0yMCwgYXJyb3dDZW50ZXIueSk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tTGVmdEVkZ2UgPSBsZWZ0RWRnZTtcclxuICAgICAgICBoZWFkU2hhcGUuYWRkKGJvdHRvbVJpZ2h0RWRnZSk7XHJcbiAgICAgICAgaGVhZFNoYXBlLmFkZChib3R0b21MZWZ0RWRnZSk7XHJcblxyXG4gICAgICAgIGlmKGxpbmVUeXBlID09PSBTSEFQRVMuQUdHUkVHQVRJT04pe1xyXG4gICAgICAgICAgaGVhZFNoYXBlLnN0cm9rZUNvbG9yID0gJ3doaXRlJztcclxuICAgICAgICAgIGhlYWRTaGFwZS5maWxsQ29sb3IgPSAnd2hpdGUnO1xyXG4gICAgICAgICAgaGVhZFNoYXBlLnNoYWRvd0NvbG9yID0gJ2dyYXknO1xyXG4gICAgICAgICAgaGVhZFNoYXBlLnNoYWRvd09mZnNldD0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYobGluZVR5cGUgPT09IFNIQVBFUy5DT01QT1NJVElPTil7XHJcbiAgICAgICAgICBoZWFkU2hhcGUuZmlsbENvbG9yID0gJ2JsYWNrJztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBcclxuXHJcbiAgICAvL3JvdGF0ZSB0aGUgaGVhZCBzaGFwZVxyXG4gICAgaWYobGluZVR5cGUgIT09IFNIQVBFUy5ESVZJREVSKVxyXG4gICAgICBoZWFkU2hhcGUucm90YXRlKFxyXG4gICAgICAgIGdldEFuZ2xlRGVnKGVuZFBvaW50LngsIGVuZFBvaW50Lnksc3RhcnRQb2ludC54LCBzdGFydFBvaW50LnkpLCBcclxuICAgICAgICBhcnJvd0NlbnRlcik7XHJcblxyXG4gICAgXHJcbiAgICAvL2FkZCBncm91cCB0byBtYWluIGdyb3VwXHJcbiAgICBtYWluR3JvdXAuYWRkQ2hpbGQoZ3JvdXApO1xyXG4gICAgaWYobGluZVR5cGUgIT09IFNIQVBFUy5ESVZJREVSKVxyXG4gICAgICBtYWluR3JvdXAuYWRkQ2hpbGQoaGVhZFNoYXBlKTtcclxuICAgIG1haW5Hcm91cC5kYXRhLnR5cGUgPSBMSU5FO1xyXG4gICAgbWFpbkdyb3VwLmRhdGEubGluZVR5cGUgPSBsaW5lVHlwZTtcclxuXHJcbiAgICByZXR1cm4gbWFpbkdyb3VwO1xyXG4gIH1cclxuXHJcbiAgLy9hZGQgT2JqZWN0L0ludGVyZmFjZSBzaGFwZVxyXG4gIGRyYXdPYmplY3RTaGFwZSh0eXBlKXtcclxuICAgIC8vY3JlYXRlcyBvYmplY3QgcmVjdGFuZ2xlXHJcbiAgICBjb25zdCBzdGFydFBvaW50ID0gbmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueC01MCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTI1KVxyXG4gICAgY29uc3QgcmVjdGFuZ2xlID0gbmV3IFBhdGguUmVjdGFuZ2xlKHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55LCB0aGlzLmRlZmF1bHRTaXplWzBdLCB0aGlzLmRlZmF1bHRTaXplWzBdLzIpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHJlY3RhbmdsZSk7XHJcblxyXG5cclxuXHJcbiAgICAvL2NyZWF0ZSB0ZXh0c2hhcGVcclxuICAgIGlmKHR5cGUgIT09IFNIQVBFUy5TUVVBUkUpe1xyXG4gICAgICBjb25zdCB0ZXh0U2hhcGVTdGFydFBvaW50ID0gbmV3IFBvaW50KHN0YXJ0UG9pbnQueCszMCwgc3RhcnRQb2ludC55KzMwKTtcclxuICAgICAgY29uc3QgdGV4dFNoYXBlID0gdGhpcy5kcmF3VGV4dFNoYXBlKHRleHRTaGFwZVN0YXJ0UG9pbnQsIHR5cGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy9hZGQgVXNlY2FzZS9BY3Rpdml0eSBzaGFwZVxyXG4gIGRyYXdVc2VDYXNlU2hhcGUodHlwZSl7XHJcbiAgICAvL2RyYXcgY2lyY2xlXHJcbiAgICBsZXQgY2lyY2xlUGF0aCA9IG5ldyBQYXRoLkNpcmNsZSh0aGlzLmNlbnRlclBvc2l0aW9uLCAyNSk7XHJcbiAgICBjaXJjbGVQYXRoLnNjYWxlKDIsMS4yKTtcclxuICAgIFxyXG4gICAgLy9zY2FsZSB0byBtYWtlIGl0IGFuIG92YWxcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChjaXJjbGVQYXRoKVxyXG5cclxuICAgIGlmKHR5cGUgPT09IFNIQVBFUy5VU0VDQVNFKXtcclxuICAgICAgLy9hZGQgVGV4dFxyXG4gICAgICBjb25zdCB0ZXh0U2hhcGUgPSB0aGlzLmRyYXdUZXh0U2hhcGUobmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueC0yNSwgdGhpcy5jZW50ZXJQb3NpdGlvbi55KzUpLCB0eXBlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vYWRkIENvbXBvbmVudCBzaGFwZVxyXG4gIGRyYXdDb21wb25lbnRTaGFwZSgpe1xyXG4gICAgLy9kcmF3IG1haW4gcmVjdGFuZ2xlXHJcbiAgICBjb25zdCBzdGFydFBvaW50ID0gbmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueC01MCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTI1KVxyXG4gICAgY29uc3QgcmVjdGFuZ2xlID0gbmV3IFBhdGguUmVjdGFuZ2xlKHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55LCB0aGlzLmRlZmF1bHRTaXplWzBdKzIwLCB0aGlzLmRlZmF1bHRTaXplWzBdLTQ1KTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChyZWN0YW5nbGUpO1xyXG5cclxuICAgIC8vIGRyYXcgc3ViIHBhcnQgb2YgdGhlIHNoYXBlXHJcbiAgICBjb25zdCBzdWJSZWN0ID0gbmV3IFBhdGguUmVjdGFuZ2xlKHJlY3RhbmdsZS5ib3VuZHMudG9wUmlnaHQueC0yNSwgc3RhcnRQb2ludC55KzYsIDIwLCAyNSk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoc3ViUmVjdCk7XHJcbiAgICBzdWJSZWN0LnN0cm9rZVdpZHRoID0gMi90aGlzLnN0cm9rZVdpZHRoO1xyXG5cclxuICAgIC8vZHJhdyB0d28gc3ViIHJlY1xyXG4gICAgY29uc3Qgc3ViUmVjdDEgPSBuZXcgUGF0aC5SZWN0YW5nbGUocmVjdGFuZ2xlLmJvdW5kcy50b3BSaWdodC54LTI4LCBzdGFydFBvaW50LnkrOSwgNywgNyk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoc3ViUmVjdDEpO1xyXG4gICAgc3ViUmVjdDEuc3Ryb2tlV2lkdGggPSAyL3RoaXMuc3Ryb2tlV2lkdGg7XHJcblxyXG4gICAgY29uc3Qgc3ViUmVjdDIgPSBuZXcgUGF0aC5SZWN0YW5nbGUocmVjdGFuZ2xlLmJvdW5kcy50b3BSaWdodC54LTI4LCBzdGFydFBvaW50LnkrMjAsIDcsIDcpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHN1YlJlY3QyKTtcclxuICAgIHN1YlJlY3QyLnN0cm9rZVdpZHRoID0gMi90aGlzLnN0cm9rZVdpZHRoO1xyXG5cclxuICAgIC8vY3JlYXRlIGdyb3VwIGFuZCBhZGQgc2hhcGVzXHJcbiAgICBsZXQgZ3JvdXAgPSAgbmV3IEdyb3VwKCk7XHJcblxyXG4gICAgZ3JvdXAuYWRkQ2hpbGQocmVjdGFuZ2xlKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKHN1YlJlY3QpO1xyXG4gICAgZ3JvdXAuYWRkQ2hpbGQoc3ViUmVjdDEpO1xyXG4gICAgZ3JvdXAuYWRkQ2hpbGQoc3ViUmVjdDIpO1xyXG5cclxuICAgIC8vYWRkIHRleHQgdG8gc2hhcGVcclxuICAgIGNvbnN0IHRleHRTaGFwZSA9IHRoaXMuZHJhd1RleHRTaGFwZShuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LTI1LCB0aGlzLmNlbnRlclBvc2l0aW9uLnkrOCksIFNIQVBFUy5DT01QT05FTlQpO1xyXG4gIH1cclxuXHJcbiAgLy9hZGQgbW9kdWxlIHNoYXBlXHJcbiAgZHJhd01vZHVsZVNoYXBlKCl7XHJcbiAgICBcclxuICAgIC8vIGRyYXcgbWFpbiByZWN0XHJcbiAgICBjb25zdCByZWN0YW5nbGUgPSBuZXcgUGF0aC5SZWN0YW5nbGUodGhpcy5jZW50ZXJQb3NpdGlvbi54LTUwLCB0aGlzLmNlbnRlclBvc2l0aW9uLnktNTAsIHRoaXMuZGVmYXVsdFNpemVbMF0rMjAsIHRoaXMuZGVmYXVsdFNpemVbMF0tNDApO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHJlY3RhbmdsZSk7XHJcblxyXG4gICAgLy9kcmF3IHR3byBzdWIgcmVjXHJcbiAgICBjb25zdCBzdWJSZWN0MSA9IG5ldyBQYXRoLlJlY3RhbmdsZShyZWN0YW5nbGUuYm91bmRzLnRvcExlZnQueC03LCByZWN0YW5nbGUuYm91bmRzLnRvcExlZnQueSsxMiwgMTUsIDEyKTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQW5kRmlsbChzdWJSZWN0MSk7XHJcblxyXG4gICAgY29uc3Qgc3ViUmVjdDIgPSBuZXcgUGF0aC5SZWN0YW5nbGUocmVjdGFuZ2xlLmJvdW5kcy50b3BMZWZ0LngtNywgcmVjdGFuZ2xlLmJvdW5kcy50b3BMZWZ0LnkrMzUsIDE1LCAxMik7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoc3ViUmVjdDIpO1xyXG5cclxuICAgIC8vY3JlYXRlIGdyb3VwIGFuZCBhZGQgc2hhcGVzXHJcbiAgICBsZXQgZ3JvdXAgPSAgbmV3IEdyb3VwKCk7XHJcblxyXG4gICAgZ3JvdXAuYWRkQ2hpbGQocmVjdGFuZ2xlKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKHN1YlJlY3QxKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKHN1YlJlY3QyKTtcclxuXHJcbiAgICAvL2FkZCB0ZXh0IHRvIHNoYXBlXHJcbiAgICBjb25zdCB0ZXh0U2hhcGUgPSB0aGlzLmRyYXdUZXh0U2hhcGUobmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueC0xMCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTE1KSwgU0hBUEVTLk1PRFVMRSk7XHJcbiAgfVxyXG4gIFxyXG5cclxuICAvL2FkZCBhY3Rpdml0eSBzaGFwZVxyXG4gIGRyYXdBY3Rpdml0eVNoYXBlKCl7XHJcbiAgICAvL2NyZWF0ZSByb3VuZGVkIHNoYXBlIHJlY3RhbmdsZVxyXG4gICAgY29uc3QgcmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSh0aGlzLmNlbnRlclBvc2l0aW9uLnN1YnRyYWN0KDUwKSwgbmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueCs3MCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55KSk7XHJcbiAgICBjb25zdCByYWRpdXMgPSBuZXcgU2l6ZSgzMCwgMzApO1xyXG4gICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoLlJlY3RhbmdsZShyZWN0YW5nbGUsIHJhZGl1cyk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwocGF0aCk7XHJcblxyXG4gICAgXHJcbiAgICAvL2FkZCB0ZXh0IHRvIHNoYXBlXHJcbiAgICBjb25zdCB0ZXh0U2hhcGUgPSB0aGlzLmRyYXdUZXh0U2hhcGUobmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueC0xMCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTIwKSwgU0hBUEVTLkFDVElWSVRZKTtcclxuICB9XHJcblxyXG4gIC8vYWRkIGRlY2lzaW9uIHNoYXBlXHJcbiAgZHJhd0RlY2lzaW9uU2hhcGUoKXtcclxuICAgIC8vY3JlYXRlIHJlY3RhbmdsZVxyXG4gICAgY29uc3QgcmVjdGFuZ2xlID0gbmV3IFBhdGguUmVjdGFuZ2xlKHRoaXMuY2VudGVyUG9zaXRpb24ueC0yMCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTIwLCB0aGlzLmRlZmF1bHRTaXplWzBdLzIuNSwgdGhpcy5kZWZhdWx0U2l6ZVswXS8yLjUpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKHJlY3RhbmdsZSk7XHJcblxyXG4gICAgLy9yb3RhdGVcclxuICAgIHJlY3RhbmdsZS5yb3RhdGUoNDUpO1xyXG4gIH1cclxuXHJcbiAgLy9vbiB0b29sIGNsaWNrXHJcbiAgb25Ub29sTW91c2VEb3duKGUpe1xyXG4gICAgLy90b2dnbGUgaXRlbSBzZWxlY3RlZFxyXG4gICAgdGhpcy5zZXRPbmVJdGVtU2VsZWN0ZWQoZSk7XHJcblxyXG4gICAgLy9yZXR1cm4gaWYgbm8gY3VycmVudEFjdGl2ZUl0ZW1cclxuICAgIGlmKCF0aGlzLmN1cnJlbnRBY3RpdmVJdGVtKSByZXR1cm47XHJcblxyXG4gICAgLy9jbGVhcmluZyBjdXJyZW50QWN0aXZlSXRlbSBkYXRhIHRvIGZpeCB0aGUgaXNzdWUgb2YgdW5pbnRlbmRlZCBtb3Zlc1xyXG4gICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnN0YXRlID0gbnVsbDtcclxuXHJcbiAgICBpZih0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmNvbnRhaW5zKGUucG9pbnQpKXtcclxuICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnN0YXRlID0gJ21vdmUnXHJcbiAgICB9XHJcbiAgICAvL3NldCBpdGVtcyBkYXRhIGJhc2VkIG9uIGl0ZW0gbW91c2VEb3duIHBvaW50XHJcbiAgICBpZih0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEudHlwZSAhPT0gTElORSl7XHJcbiAgICAgIGlmKHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uaGl0VGVzdChlLnBvaW50LCB7Ym91bmRzOiB0cnVlLCB0b2xlcmFuY2U6IDV9KSl7XHJcbiAgICAgICAgLy9nZXQgYm91bmRzIG9mIHRoZSBzaGFwZVxyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uYm91bmRzO1xyXG5cclxuXHJcbiAgICAgICAgLy9pdHJhdGluZyB0byBmaW5kIHRoZSBleGFjdCBib3VuZCBwb2ludFxyXG4gICAgICAgIGZvcihsZXRba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYm91bmRzSWRlbnRpZmllck9iaikpe1xyXG4gICAgICAgICAgaWYoYm91bmRzW3ZhbHVlXS5pc0Nsb3NlKGUucG9pbnQsIDUpKXtcclxuICAgICAgICAgICAgY29uc3Qgb3Bwb3NpdGVCb3VuZCA9IGJvdW5kc1tib3VuZHNJZGVudGlmaWVyT2JqWyhwYXJzZUludChrZXkpICsgMikgJSA0XV07XHJcbiAgICAgICAgICAgIC8vZ2V0IG9wcG9zaXRlIGJvdW5kIHBvaW50XHJcbiAgICAgICAgICAgIGNvbnN0IG9wcG9zaXRlUG9pbnQgPSBuZXcgUG9pbnQob3Bwb3NpdGVCb3VuZC54LG9wcG9zaXRlQm91bmQueSk7XHJcbiAgICAgICAgICAgIC8vZ2V0IGN1cnJlbnQgYm91bmQgcG9pbnRcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFBvaW50ID0gbmV3IFBvaW50KGJvdW5kc1t2YWx1ZV0ueCwgYm91bmRzW3ZhbHVlXS55KTtcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IHNoYXBlIGRhdGEgdG8gYmUgdXNlZCBmb3IgcmVzaXppbmcgbGF0ZXJcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnN0YXRlID0gJ3Jlc2l6ZSdcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLmZyb20gPSBvcHBvc2l0ZVBvaW50O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEudG8gPSBjdXJyZW50UG9pbnQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy9vbmx5IGZvciBzaGFwZXMgd2l0aCB0eXBlIExJTkVcclxuICAgICAgY29uc3QgaGVhZENpcmNsZUl0ZW0gPSB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmZpcnN0Q2hpbGQuY2hpbGRyZW5bM107XHJcbiAgICAgIGlmKGhlYWRDaXJjbGVJdGVtLmNvbnRhaW5zKGUucG9pbnQpKXtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEuc3RhdGUgPSAncmVzaXplJ1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvL2RyYXcgYWN0b3Igc2hhcGVcclxuICBkcmF3QWN0b3JTaGFwZSgpe1xyXG4gICAgLy9kcmF3IGFjdG9yIGhlYWRcclxuICAgIGNvbnN0IGhlYWQgPSBuZXcgUGF0aC5DaXJjbGUobmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTUwKSwgNyk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoaGVhZClcclxuXHJcbiAgICAvL2RyYXcgYWN0b3IgYm9keVxyXG4gICAgY29uc3QgYm9keSA9IG5ldyBQYXRoLkxpbmUobmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTQzKSwgbmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTEwKSk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoYm9keSlcclxuXHJcbiAgICAvL2RyYXcgYWN0b3IgYXJtc1xyXG4gICAgY29uc3QgYXJtcyA9IG5ldyBQYXRoLkxpbmUobmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueC0yMCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTM4KSwgbmV3IFBvaW50KHRoaXMuY2VudGVyUG9zaXRpb24ueCsyMCwgdGhpcy5jZW50ZXJQb3NpdGlvbi55LTM4KSk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwoYXJtcykgXHJcblxyXG4gICAgLy9kcmF3IGZlZXRcclxuICAgIGNvbnN0IGxlZnRGZWV0ID0gbmV3IFBhdGguTGluZShuZXcgUG9pbnQodGhpcy5jZW50ZXJQb3NpdGlvbi54LTIwLCB0aGlzLmNlbnRlclBvc2l0aW9uLnkrNSksIG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0xMCkpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VBbmRGaWxsKGxlZnRGZWV0KSBcclxuXHJcbiAgICBjb25zdCByaWdodEZlZXQgPSBuZXcgUGF0aC5MaW5lKG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngsIHRoaXMuY2VudGVyUG9zaXRpb24ueS0xMCksIG5ldyBQb2ludCh0aGlzLmNlbnRlclBvc2l0aW9uLngrMjAsIHRoaXMuY2VudGVyUG9zaXRpb24ueSs1KSk7XHJcbiAgICB0aGlzLnNldFN0cm9rZUFuZEZpbGwocmlnaHRGZWV0KSBcclxuXHJcbiAgICAvL2FkZCBzaGFwZXMgdG8gZ3JvdXAgdG8gbWFrZSBmdWxsIGFjdG9yXHJcbiAgICBsZXQgZ3JvdXAgPSAgbmV3IEdyb3VwKCk7XHJcbiAgICBncm91cC5hZGRDaGlsZChoZWFkKTtcclxuICAgIGdyb3VwLmFkZENoaWxkKGJvZHkpO1xyXG4gICAgZ3JvdXAuYWRkQ2hpbGQoYXJtcyk7XHJcbiAgICBncm91cC5hZGRDaGlsZChsZWZ0RmVldCk7XHJcbiAgICBncm91cC5hZGRDaGlsZChyaWdodEZlZXQpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vaXRlbSBkcmFnIGxpc3RlbmVyXHJcbiAgb25Ub29sRHJhZyhlKXtcclxuICAgIC8vIGRlYnVnZ2VyXHJcbiAgICBpZih0aGlzLmN1cnJlbnRBY3RpdmVJdGVtID09IG51bGwpIHJldHVybjtcclxuXHJcbiAgICBpZih0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEuc3RhdGUgPT09ICdtb3ZlJyl7XHJcbiAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0ucG9zaXRpb24gPSBlLnBvaW50OyAgXHJcbiAgICB9IGVsc2VcclxuICAgIGlmKHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5zdGF0ZSA9PT0gJ3Jlc2l6ZScpe1xyXG4gICAgICBpZih0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmRhdGEudHlwZSA9PT0gTElORSl7XHJcbiAgICAgICAgLy9zaGFwZXMgd2l0aCB0eXBlIGxpbmUsIHJlLXJlbmRlcmluZyBsaW5lIG9uIGVhY2ggdXNlciBtb3ZlXHJcbiAgICAgICAgY29uc3QgbGluZVN0YXJ0UG9pbnQgPSB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZC5zZWdtZW50c1swXS5wb2ludDtcclxuICAgICAgICBjb25zdCBsaW5lVHlwZSA9IHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0uZGF0YS5saW5lVHlwZTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEFjdGl2ZUl0ZW0gPSAgdGhpcy5kcmF3TGluZVNoYXBlKGxpbmVTdGFydFBvaW50LCBlLnBvaW50LCBsaW5lVHlwZSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLnN0YXRlID0gJ3Jlc2l6ZSdcclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgLy9zaGFwZXMgb3RoZXIgdGhhbiBsaW5lLCB1cGRhdGluZyB0aGUgYm91bmRzXHJcbiAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5ib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKFxyXG4gICAgICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5kYXRhLmZyb20sZS5wb2ludCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbS5zZWxlY3RlZCA9IHRydWVcclxuICAgIH0gXHJcbiAgfVxyXG5cclxuICAvL29uIHRvb2wgZG91YmxlIGNsaWNrXHJcbiAgb25Ub29sRG91YmxlQ2xpY2soZSl7XHJcbiAgICBpZihlLmN0cmxLZXkpIHtcclxuICAgICAgdGhpcy5kcmF3VGV4dFNoYXBlKHt4OiBlLmxheWVyWCwgeTogZS5sYXllcll9LCBcIkFkZCBUZXh0XCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgXHJcblxyXG4gIC8vdG9nZ2xlIGl0ZW0gc2VsZWN0ZWlvbiBhbmQgc2F2aW5nIGN1cnJlbnRBY3RpdmVJdGVtXHJcbiAgc2V0T25lSXRlbVNlbGVjdGVkKGUpe1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSBlLnBvaW50O1xyXG4gICAgbGV0IGNsaWNrZWRJdGVtcyA9IFtdXHJcbiAgICB0aGlzLnByb2plY3QuYWN0aXZlTGF5ZXIuY2hpbGRyZW4uZm9yRWFjaChjaGlsZD0+e1xyXG4gICAgICBpZihjaGlsZC5jb250YWlucyhwb3NpdGlvbikpe1xyXG4gICAgICAgIGNsaWNrZWRJdGVtcy5wdXNoKGNoaWxkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGlsZC5zZWxlY3RlZCA9ICBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIC8vcmV0dXJuIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWRcclxuICAgIGlmKGNsaWNrZWRJdGVtcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAvL3NlbGVjdCB0aGUgY2xpY2tlZCBpdGVtXHJcbiAgICBsZXQgbGF0ZXN0SXRlbSA9IGNsaWNrZWRJdGVtc1swXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xpY2tlZEl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmKGxhdGVzdEl0ZW0uaWQgPCBjbGlja2VkSXRlbXNbaV0uaWQpe1xyXG4gICAgICAgIGxhdGVzdEl0ZW0gPSBjbGlja2VkSXRlbXNbaV07XHJcbiAgICAgIH1lbHNlXHJcbiAgICAgIHtcclxuICAgICAgICBjbGlja2VkSXRlbXNbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5jdXJyZW50QWN0aXZlSXRlbSA9IGxhdGVzdEl0ZW07XHJcbiAgICBsYXRlc3RJdGVtLnNlbGVjdGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG5cclxuICAvLyBrZXlib2FyZCBpbnRyYWN0aW9uIHRvIG1vdmUgc2hhcGVzXHJcbiAgb25Ub29sS2V5RG93bihlKXtcclxuICAgIGlmKCF0aGlzLmN1cnJlbnRBY3RpdmVJdGVtKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLnBvc2l0aW9uO1xyXG4gICAgY29uc3Qgc3RlcCA9IDU7XHJcbiAgICBzd2l0Y2goZS5rZXkpe1xyXG4gICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICBwb3NpdGlvbi54IC09IHN0ZXA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICBwb3NpdGlvbi54ICs9IHN0ZXA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3VwJzpcclxuICAgICAgICBwb3NpdGlvbi55IC09IHN0ZXA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2Rvd24nOlxyXG4gICAgICAgIHBvc2l0aW9uLnkgKz0gc3RlcDtcclxuICAgICAgICBicmVhazsgXHJcbiAgICB9XHJcbiAgICB0aGlzLmN1cnJlbnRBY3RpdmVJdGVtLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBnZW5lcmFsIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyByZXR1cm4gY2VudGVyIHBvc2l0aW9uIG9mIGNhbnZhc1xyXG4gIGdldENlbnRlclBvc2l0aW9uKCl7XHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHt4OiB0aGlzLmNhbnZhc0VsZW1lbnQuY2xpZW50V2lkdGgvMiwgeTp0aGlzLmNhbnZhc0VsZW1lbnQuY2xpZW50SGVpZ2h0LzJ9KTtcclxuICB9XHJcblxyXG4gIC8vIGhlbHBlciB0byBzZXQgc3Ryb2tlIGFuZCBmaWxsXHJcbiAgc2V0U3Ryb2tlQW5kRmlsbChpdGVtKXtcclxuICAgIGl0ZW0uc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xyXG4gICAgaXRlbS5zdHJva2VDb2xvciA9IHRoaXMuc3Ryb2tlQ29sb3I7XHJcbiAgICBpdGVtLmZpbGxDb2xvciA9IHRoaXMuZmlsbENvbG9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTXlDYW52YXM7XHJcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsIHtcclxuICAgIGNvbnN0cnVjdG9yKHRleHRDYWxsYmFjayl7XHJcbiAgICAgICAgdGhpcy50ZXh0Q2FsbGJhY2sgPSB0ZXh0Q2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5zaG93ID0gdGhpcy5zaG93LmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvdygpe1xyXG4gICAgICAgIGNvbnN0IGJvZHlFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JvZHknKTtcclxuICAgICAgICBjb25zdCBtb2RhbE1haW5Db250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgbW9kYWxNYWluQ29udGFpbmVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywnbW9kYWwtbWFpbi1jb250YWluZXInKVxyXG4gICAgICAgIGNvbnN0IG1vZGFsQ29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIG1vZGFsQ29udGFpbmVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywnbW9kYWwtY29udGFpbmVyJylcclxuICAgICAgICBjb25zdCBtb2RhbFRpdGxlQ29uYWluZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgbW9kYWxUaXRsZUNvbmFpbmVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywnbW9kYWwtdGl0bGUtY29udGFpbmVyJyk7XHJcbiAgICAgICAgY29uc3QgbW9kYWxUaXRsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpO1xyXG4gICAgICAgIG1vZGFsVGl0bGVFbGVtZW50LmlubmVySFRNTCA9IFwiQWRkIFRleHRcIlxyXG4gICAgICAgIG1vZGFsVGl0bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdtb2RhbC10aXRsZScpO1xyXG4gICAgICAgIGNvbnN0IG1vZGFsQ2xvc2VFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgIG1vZGFsQ2xvc2VFbGVtZW50LmlubmVySFRNTCA9IFwiWFwiXHJcbiAgICAgICAgbW9kYWxDbG9zZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsJ21vZGFsLWNsb3NlJyk7XHJcbiAgICAgICAgY29uc3QgbW9kYWxJbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gICAgICAgIG1vZGFsSW5wdXRFbGVtZW50LnBsYWNlaG9sZGVyID0gXCJBZGQgdGV4dCBoZXJlXCJcclxuICAgICAgICBtb2RhbElucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywnbW9kYWwtaW5wdXQnKTtcclxuICAgICAgICBjb25zdCBtb2RhbFN1Ym1pdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICAgICAgICBtb2RhbFN1Ym1pdEVsZW1lbnQuaW5uZXJIVE1MID0gXCJTdWJtaXRcIlxyXG4gICAgICAgIG1vZGFsU3VibWl0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywnbW9kYWwtc3VibWl0Jyk7XHJcblxyXG4gICAgICAgIG1vZGFsVGl0bGVDb25haW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQobW9kYWxUaXRsZUVsZW1lbnQpO1xyXG4gICAgICAgIG1vZGFsVGl0bGVDb25haW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQobW9kYWxDbG9zZUVsZW1lbnQpO1xyXG4gICAgICAgIG1vZGFsQ29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChtb2RhbFRpdGxlQ29uYWluZXJFbGVtZW50KTtcclxuICAgICAgICBtb2RhbENvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQobW9kYWxJbnB1dEVsZW1lbnQpO1xyXG4gICAgICAgIG1vZGFsQ29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChtb2RhbFN1Ym1pdEVsZW1lbnQpO1xyXG4gICAgICAgIG1vZGFsTWFpbkNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQobW9kYWxDb250YWluZXJFbGVtZW50KTtcclxuICAgICAgICBib2R5RWxlbWVudC5hcHBlbmRDaGlsZChtb2RhbE1haW5Db250YWluZXJFbGVtZW50KTtcclxuXHJcbiAgICAgICAgLy9hZGRzIGxpc3RlbmVyc1xyXG5cclxuICAgICAgICAvL2Nsb3NlIG1vZGFsIG9uIG91dHNpZGUgY2xpY2tcclxuICAgICAgICBtb2RhbE1haW5Db250YWluZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpPT57XHJcbiAgICAgICAgICAgIG1vZGFsTWFpbkNvbnRhaW5lckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsJ2hpZGRkZW4nKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy9zdG9wcyBtb2RhbCBmcm9tIGNsb3NpbmcgaWYgY2xpY2tlZCBpbnNpZGUgbW9kYWxcclxuICAgICAgICBtb2RhbENvbnRhaW5lckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLChlKT0+e1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy9jbG9zZXMgbW9kYWwgb24gY2xpY2tcclxuICAgICAgICBtb2RhbENsb3NlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKT0+e1xyXG4gICAgICAgICAgICBtb2RhbE1haW5Db250YWluZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdoaWRkZGVuJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vZ2V0cyB0ZXh0IGZvcm0gaW5wdXQgb24gc3VibWl0IGFuZCBzZW5kaW5nIHRvIGNhbGxiYWNrXHJcbiAgICAgICAgbW9kYWxTdWJtaXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywoZSk9PntcclxuICAgICAgICAgICAgY29uc3QgaW5wdXRUZXh0ID0gbW9kYWxJbnB1dEVsZW1lbnQudmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dENhbGxiYWNrKGlucHV0VGV4dCk7XHJcbiAgICAgICAgICAgIG1vZGFsTWFpbkNvbnRhaW5lckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsJ2hpZGRkZW4nKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZGViYXJ7XHJcbiAgICBjb25zdHJ1Y3RvcihjYXRlZ29yeU9iaiwgc2lkZWJhckVsZW1lbnQsIG9uU2hhcGVDbGlja0NhbGxiYWNrKXtcclxuICAgICAgICB0aGlzLmNhdGVnb3J5VGl0bGUgPSBjYXRlZ29yeU9iai5jYXRlZ29yeU5hbWU7XHJcbiAgICAgICAgdGhpcy5zaGFwZXMgPSBjYXRlZ29yeU9iai5zaGFwZXM7XHJcbiAgICAgICAgdGhpcy5zaWRlYmFyRWxlbWVudCA9IHNpZGViYXJFbGVtZW50O1xyXG4gICAgICAgIHRoaXMub25TaGFwZUNsaWNrQ2FsbGJhY2sgPSBvblNoYXBlQ2xpY2tDYWxsYmFjaztcclxuICAgICAgICB0aGlzLmRyYXcoKTtcclxuICAgICAgICB0aGlzLnNoYXBlQ2xpY2tMaXN0ZW5lciA9IHRoaXMuc2hhcGVDbGlja0xpc3RlbmVyLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2hhcGVDbGlja0xpc3RlbmVyKHNoYXBlTmFtZSl7XHJcbiAgICAgICAgcmV0dXJuIGU9PntcclxuICAgICAgICAgICAgdGhpcy5vblNoYXBlQ2xpY2tDYWxsYmFjayhzaGFwZU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCl7XHJcbiAgICAgICAgLy9hZGRzIGNhdGVnb3J5IHRpdGxlIGluIHNpZGViYXJcclxuICAgICAgICBjb25zdCBjYXRlZ29yeVRpdGxlRWxlbWVudCAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpO1xyXG4gICAgICAgIGNhdGVnb3J5VGl0bGVFbGVtZW50LmlubmVySFRNTCA9IHRoaXMuY2F0ZWdvcnlUaXRsZTtcclxuICAgICAgICBjYXRlZ29yeVRpdGxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NpZGViYXItY2F0ZWdvcnktdGl0bGUnKTtcclxuICAgICAgICB0aGlzLnNpZGViYXJFbGVtZW50LmFwcGVuZENoaWxkKGNhdGVnb3J5VGl0bGVFbGVtZW50KTtcclxuXHJcbiAgICAgICAgLy9hZGRzIGNhdGVnb3J5IHNoYXBlcyBpbiBzaWRlYmFyXHJcbiAgICAgICAgY29uc3Qgc2hhcGVzVWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcclxuICAgICAgICBzaGFwZXNVbEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIFwic2lkZWJhci1jYXRlZ29yeS1zaGFwZXMtdWxcIilcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5zaGFwZXNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlTGlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcclxuICAgICAgICAgICAgc2hhcGVMaUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIFwic2lkZWJhci1jYXRlZ29yeS1zaGFwZXMtbGlcIilcclxuICAgICAgICAgICAgc2hhcGVMaUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuc2hhcGVDbGlja0xpc3RlbmVyKHNoYXBlLm5hbWUpKVxyXG4gICAgICAgICAgICBjb25zdCBzaGFwZUltYWdlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG4gICAgICAgICAgICBzaGFwZUltYWdlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJyxcInNpZGViYXItY2F0ZWdvcnktaW1hZ2VzXCIpXHJcbiAgICAgICAgICAgIHNoYXBlSW1hZ2VFbGVtZW50LnNyYyA9IHNoYXBlLnVyaTtcclxuICAgICAgICAgICAgc2hhcGVMaUVsZW1lbnQuYXBwZW5kQ2hpbGQoc2hhcGVJbWFnZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICBzaGFwZXNVbEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2hhcGVMaUVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNpZGViYXJFbGVtZW50LmFwcGVuZENoaWxkKHNoYXBlc1VsRWxlbWVudCk7XHJcblxyXG4gICAgfVxyXG59IiwiZXhwb3J0IGNvbnN0IFNIQVBFUyA9IHtcclxuICAgIENMQVNTOiAnQ2xhc3MnLFxyXG4gICAgU1FVQVJFOiAnU3F1YXJlJyxcclxuICAgIERJVklERVI6ICdEaXZpZGVyJyxcclxuICAgIENJUkNMRTogJ0NpcmNsZScsXHJcbiAgICBPQkpFQ1Q6ICdPYmplY3QnLFxyXG4gICAgSU5URVJGQUNFOiAnSW50ZXJmYWNlJyxcclxuICAgIEFDVE9SOiAnQWN0b3InLFxyXG4gICAgQUdHUkVHQVRJT046ICdBZ2dyZWdhdGlvbicsXHJcbiAgICBDT01QT1NJVElPTjogJ0NvbXBvc2l0aW9uJyxcclxuICAgIEFTU09DSUFUSU9OOiAnQXNzb2NpYXRpb24nLFxyXG4gICAgQ09NUE9ORU5UOiAnQ29tcG9uZW50JyxcclxuICAgIE1PRFVMRTogJ01vZHVsZScsXHJcbiAgICBUSVRMRTogJ1RpdGxlJyxcclxuICAgIEFDVElWSVRZOiAnQWN0aXZpdHknLFxyXG4gICAgVVNFQ0FTRTogJ1VzZSBDYXNlJyxcclxuICAgIERFQ0lTSU9OOiAnRGVjaXNpb24nXHJcbn0iLCJpbXBvcnQgeyBTSEFQRVMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcclxuXHJcbmNvbnN0IHNpZGViYXJEYXRhID0gIFtcclxuIHtcclxuICAgICBjYXRlZ29yeU5hbWU6IFwiVU1MXCIsXHJcbiAgICAgc2hhcGVzOltcclxuICAgICAgICAge1xyXG4gICAgICAgICAgICAgbmFtZTogU0hBUEVTLk9CSkVDVCxcclxuICAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9vYmplY3Quc3ZnJ1xyXG4gICAgICAgICB9LFxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5JTlRFUkZBQ0UsXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9pbnRlcmZhY2Uuc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuQ0xBU1MsXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9jbGFzcy5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5ESVZJREVSLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvZGl2aWRlci5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5USVRMRSxcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL3RpdGxlLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLkNPTVBPTkVOVCxcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2NvbXBvbmVudC5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5NT0RVTEUsXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9tb2R1bGUuc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuQUNUT1IsXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9hY3Rvci5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5VU0VDQVNFLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvdXNlcmNhc2Uuc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuQUNUSVZJVFksXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9hY3Rpdml0eS5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5ERUNJU0lPTixcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2RlY2lzaW9uLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLkFHR1JFR0FUSU9OLFxyXG4gICAgICAgICAgICB1cmk6ICcuL3NyYy9pbWFnZXMvYWdncmVnYXRpb24uc3ZnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiBTSEFQRVMuQ09NUE9TSVRJT04sXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9jb21wb3NpdGlvbi5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5BU1NPQ0lBVElPTixcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2Fzc29jaWF0aW9uLnN2ZydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogU0hBUEVTLkNJUkNMRSxcclxuICAgICAgICAgICAgdXJpOiAnLi9zcmMvaW1hZ2VzL2NpcmNsZS5zdmcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6IFNIQVBFUy5TUVVBUkUsXHJcbiAgICAgICAgICAgIHVyaTogJy4vc3JjL2ltYWdlcy9zcXVhcmUuc3ZnJ1xyXG4gICAgICAgIH1cclxuICAgICBdXHJcbiB9ICAgXHJcbl1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHNpZGViYXJEYXRhOyIsImV4cG9ydCBmdW5jdGlvbiBnZXRBbmdsZURlZyhleCxleSxjeCxjeSkge1xyXG4gIHZhciBkeSA9IGV5IC0gY3k7XHJcbiAgdmFyIGR4ID0gZXggLSBjeDtcclxuICB2YXIgdGhldGEgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XHJcbiAgdGhldGEgKj0gMTgwIC8gTWF0aC5QSTsgXHJcbiAgcmV0dXJuIHRoZXRhO1xyXG59IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==